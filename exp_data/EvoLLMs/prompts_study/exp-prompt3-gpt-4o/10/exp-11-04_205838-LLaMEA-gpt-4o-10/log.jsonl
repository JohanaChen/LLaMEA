{"id": "a89b704e-386b-48be-b47d-722f15f815d5", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 0, "fitness": 0.29875257011177614, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "adc00af5-2ce1-4526-823f-ae6bcbe29721", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "7714f60b-23c3-45c9-90fa-5cb966ce9f17", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "bd15dfac-8671-4ea9-98b7-8832cf6a75cb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "37c599be-f9fc-47a6-8f96-f975f2ea093a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "6b88589c-59cc-4f93-be67-26db8e7198d1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "16aca2fc-547d-43b6-878b-567d4c90bee9", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "1a71dff4-c3d4-41d5-9fd7-6901da647a51", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "8fbac441-caa6-4c3e-b507-90024432a24a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with stochastic local sampling\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                local_sampling = np.random.normal(0, (self.upper_bound - self.lower_bound) / 10.0, self.dim)\n                mutant = np.clip(mutant + local_sampling, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm with stochastic local sampling to improve exploration and exploitation balance by utilizing neighborhood-based variances.", "configspace": "", "generation": 8, "fitness": 0.16127537298328196, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.2871149529507927, 0.2676946600027835, 0.3030795670199561, 0.29153220413247904, 0.3050225940637393, 0.27263906758939227, 0.28588045110402194, 0.2822793788780912, 0.3021795956321709, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08048486704103397, 0.09046523708209209, 0.0926277079880623, 0.100348586817124, 0.08599485602537771, 0.08074220648458685, 0.08550112151250866, 0.08687324736604207, 0.07779128781123323, 0.07645263759694221, 0.06798161322302476, 0.06713100995871368, 0.0707887982057529, 0.0748383865138268, 0.08398552896706057, 0.06932276762090328, 0.07355496912423609, 0.07275524289493074, 0.9823124531096423, 0.9681564811454805, 0.9255110261937035, 0.955092760423875, 0.9422420852388393, 0.9734177463255487, 0.9345298303528896, 0.9762421014283449, 0.9704049330130838, 0.1383129268228337, 0.13141279891271263, 0.14066517712412374, 0.14485203526973034, 0.13375853059023868, 0.13397185654640253, 0.14152009731457837, 0.14429593491095116, 0.1420830326267234, 0.1777739166399519, 0.17630209934585728, 0.18886061101496887, 0.18243093511284536, 0.19841298227877735, 0.18051459662793135, 0.18810741844140277, 0.17931454570477579, 0.2247428086805039, 0.07684024042844395, 0.06545689778714747, 0.07944484498173554, 0.054838827571028426, 0.09221335359628524, 0.09587570705504422, 0.08201553820349039, 0.08736246082885213, 0.07069986023608632, 0.08363624685860782, 0.0416243621284309, 0.04591143664758124, 0.08649620516440482, 0.0863982308596033, 0.09369772956512501, 0.06495220168671989, 0.06009024953670883, 0.06973750531473888, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03992001245492516, 0.08165690153549965, 0.04440772789310299, 0.054838827012271385, 0.061464070392904024, 0.05880664718351669, 0.057899493843748706, 0.06398275338661608, 0.05019851035934719, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028729883053361882, 0.04033061694171014, 0.03260921695370855, 0.0312421222467808, 0.028806657572673644, 0.021958358424636337, 0.0285994122751827, 0.03453755690687699, 0.043308825843352494, 0.27510766031093437, 0.27501476566429617, 0.27237272602476015, 0.28568214028170447, 0.2856102289450311, 0.2865821970779179, 0.28828041445020824, 0.27405952627134034, 0.2873569293764706, 0.08955149297062925, 0.07464185701262938, 0.07671499155141703, 0.08181986712080203, 0.07057465515846506, 0.08043857761532436, 0.08199458995849673, 0.09111540925854278, 0.07055856161210505, 0.16232461179159086, 0.1427335988370967, 0.19843314455438898, 0.14595148683717274, 0.1846673325611604, 0.14920082072429364, 0.1736800206258191, 0.13671845843305697, 0.15139440828852735, 0.22102817521081908, 0.20781053689169715, 0.20117621313098422, 0.21520258421898109, 0.2163889519348119, 0.20518765883938772, 0.2261156482847968, 0.20323705962319194, 0.213633860089799, 0.14876431201244888, 0.1707681230491246, 0.13953790023855728, 0.13421560138070454, 0.1422416986969942, 0.1335434112324756, 0.15115144533772784, 0.14878199204331322, 0.13886461643596815, 0.19718478284524577, 0.19067458255338943, 0.167650691935455, 0.1815003125910032, 0.18529678541909433, 0.19087354219722308, 0.1945732222500285, 0.20411328130010153, 0.1801034468569409, 0.16871266339711144, 0.16928900684613268, 0.16681995978479025, 0.1680534343555966, 0.1723386382750245, 0.16507212240988034, 0.17380016917458074, 0.17973621497492387, 0.16875578870464436, 0.2280874966838845, 0.19775390604861243, 0.16783707846913243, 0.29309180148108505, 0.1655405374993164, 0.1943565890524961, 0.22761195247760724, 0.21746348238568503, 0.19032753401250913, 0.16900157680680428, 0.17807351849544917, 0.2614776373518558, 0.16779808449722822, 0.19616184393887615, 0.1905129425554256, 0.19305797065725383, 0.19763784609585644, 0.1997927914227131, 0.18297987937697857, 0.19028439504203642, 0.19664047805025997, 0.17576716006450444, 0.19021454646932656, 0.20633221798083112, 0.17590516221203745, 0.17053112546932736, 0.17909330826273506, 0.06678050202617236, 0.06497981993924751, 0.07044312386043816, 0.08181352355294425, 0.06802785497463049, 0.06799540644673163, 0.08035409977296659, 0.07393912292819027, 0.0694415826567778]}, "mutation_prompt": null}
{"id": "6c32d9cd-410f-442a-8693-991ee5b7002b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "9965b2aa-2976-40eb-b47d-24b60c0a1668", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "9eb2fb77-c5ca-4c3a-8291-49db409eea06", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.initial_population_size = self.population_size\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    self.population_size = max(self.initial_population_size // 2, 4)  # Dynamic population size\n                    self.population = np.resize(self.population, (self.population_size, self.dim))\n                    fitness = np.resize(fitness, self.population_size)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "An enhanced adaptive differential evolution algorithm with a dynamic population size adjustment strategy to improve exploration and exploitation.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('list.remove(x): x not in list').", "error": "ValueError('list.remove(x): x not in list')", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {}, "mutation_prompt": null}
{"id": "eb1c6b87-a2d3-4695-9948-4f25718da181", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A novel algorithm using adaptive differential evolution with a dynamic crossover rate and mutation factor, combined with a local search to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6797583485824017, 0.6575708878496123, 0.7432827802577753, 0.7196780935020338, 0.7454288999096608, 0.7006892938579383, 0.7302499411883809, 0.7056072998491404, 0.719968029607471, 0.5012841528766481, 0.5105941192292764, 0.46949586773100704, 0.5822824385476866, 0.48890816891552313, 0.5155430304330948, 0.5417589611322937, 0.5851646374094575, 0.5361297259198932, 0.10950275982401414, 0.10586835987095256, 0.10954616789199867, 0.1142378055843365, 0.1041834869188264, 0.09744601360589389, 0.13233338069951006, 0.11612965855015756, 0.10371033607980085, 0.10335430178058158, 0.10425770283320468, 0.09586830204732999, 0.0985593152818427, 0.10619429563375338, 0.10843440436301977, 0.09793458361231844, 0.08580423205203946, 0.10307276031462043, 0.9398583710510596, 0.9594377194623217, 0.9450818798493137, 0.9193363571105649, 0.9782056184055499, 0.939692521209274, 0.9395689283381795, 0.9285837417831104, 0.947772278948537, 0.32388852675831903, 0.29386512653460717, 0.30823738775246035, 0.32725318760416444, 0.30757403841716113, 0.3190328103336497, 0.35968612608624373, 0.3341694427731511, 0.3327222624872819, 0.5039880238155439, 0.4996331975704228, 0.5333511253132602, 0.6597662847583567, 0.5399090575216283, 0.6370411385587058, 0.5787446491208084, 0.6234471778865958, 0.6144640343763976, 0.24288070358074665, 0.2854511057152568, 0.28772927492655176, 0.22613340958192873, 0.28763854949194956, 0.23157522804520636, 0.2862409943164239, 0.28036587427196824, 0.23456812076022104, 0.2544107614372604, 0.0491839744185687, 0.01582421375140075, 0.25352032951149606, 0.22733912369759124, 0.1925185527714529, 0.19423116018864128, 0.21473711842950705, 0.21240179995814257, 0.1371296664075191, 0.19097771076829773, 0.19455999228121246, 0.17982742273309593, 0.24040090653673296, 0.19348589446386, 0.20489494866964508, 0.15922703721332931, 0.13941506571443263, 0.3106113524855896, 0.4428392452499311, 0.40383630123920844, 0.25645861374360357, 0.33022135482162507, 0.3240619991000915, 0.28442444976796677, 0.35285312918234446, 0.3455425095111869, 0.02962144929514765, 0.021301729515953216, 0.045058435373206196, 0.10604102203564614, 0.06876455520952407, 0.07982360531420107, 0.06654544874170965, 0.05610467509456796, 0.030870309749098324, 0.18252811715106787, 0.2097142130835774, 0.19837873540475304, 0.18128520184371488, 0.20705907087227116, 0.19538845669852012, 0.1686395718189999, 0.21736753311509038, 0.18769607229912755, 0.5229247235026329, 0.5878942280284023, 0.5679060963913409, 0.5837890020930838, 0.5877139771760749, 0.5138240751595082, 0.5379758531976764, 0.6624218546104874, 0.5909073094361592, 0.0868055360235116, 0.0794903062231952, 0.0896498945280535, 0.07838718874717976, 0.07526409479703089, 0.0771281567107337, 0.08299060899134125, 0.08179240949247646, 0.09730900437885015, 0.14304410653435207, 0.13344545097148164, 0.18114780840730738, 0.1351780999886112, 0.14806082318063907, 0.15810807159957418, 0.1354887952915118, 0.13793345054190653, 0.1404808843372437, 0.2907186735052656, 0.3054264194906383, 0.305432593997253, 0.2892956207476577, 0.30000007891168856, 0.299698333012571, 0.3259614079034696, 0.32846189060048847, 0.3130600267903615, 0.21415151646724373, 0.22936919771296715, 0.23035647419149796, 0.22314343543982962, 0.22145723055833177, 0.20212098282557556, 0.22488379224891053, 0.24462902745774584, 0.23021325156672856, 0.18246842865912172, 0.19235637266245253, 0.20553530649671525, 0.1958570498263943, 0.19969709904183153, 0.17393783147790942, 0.18386387808573867, 0.187973601215209, 0.18161948169457942, 0.17507986926563568, 0.18182309219648007, 0.17951494570839566, 0.18200365090629278, 0.18451465396559963, 0.1844974937706182, 0.17733889933964853, 0.18661641841470422, 0.1884755426448661, 0.6906107428764156, 0.14749831891353093, 0.16618122049831396, 0.5891267898384492, 0.3312733979893706, 0.2769261254303187, 0.4700483710812614, 0.3864163472241977, 0.5982403614380327, 0.5533766729554013, 0.16584300205819835, 0.5518913503650441, 0.17517344134420143, 0.29115731141208945, 0.4061928466210466, 0.20481891736748792, 0.14733568713519163, 0.20411350722806187, 0.18576318020772387, 0.18586233441985023, 0.17540090700700517, 0.18887236836036703, 0.17146566031806565, 0.180625803753242, 0.1728866305815916, 0.1957784047701856, 0.1798186370320185, 0.07048063007363692, 0.0737832143827587, 0.06806294158075366, 0.08248954475924108, 0.07433159500694708, 0.07350500779005631, 0.07219251147023587, 0.06570802416756927, 0.07483830261467483]}, "mutation_prompt": null}
{"id": "b2fcf4f8-8b5e-404c-a29f-a05691c52a53", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f = 0.8  # Initial mutation factor\n        self.cr = 0.9  # Initial crossover rate\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                # Mutation with dynamic scaling\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                adapted_f = self.f + 0.1 * np.random.rand()  # slight randomization in f\n                mutant = self.population[a] + adapted_f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Improved Crossover with adaptive rate\n                cross_points = np.random.rand(self.dim) < (self.cr - 0.1 * np.random.rand())\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                # Adaptation strategy for f and cr\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "AdaptiveDifferentialEvolution", "description": "A refined adaptive differential evolution algorithm with enhanced mutation and crossover strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 13, "fitness": 0.2620625778950878, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.7109420510994963, 0.6757033138988742, 0.6545029065250418, 0.655273127967626, 0.7055358825420022, 0.6765613582702794, 0.665430416478777, 0.6878394945726308, 0.6879425279810943, 0.4708026955155715, 0.49647316427556376, 0.47224374715033923, 0.4793164723740384, 0.43537979499032786, 0.532344989639155, 0.5278707483196563, 0.4696371618000381, 0.5301150841458961, 0.09620567632887556, 0.10739435000587672, 0.11108276818664686, 0.11698162312826754, 0.10843010251153096, 0.110141326164376, 0.125272408395109, 0.12079539927864402, 0.11701758714801802, 0.11125718037566856, 0.1008241980620278, 0.11991008790085056, 0.10114081328208246, 0.10770459039623437, 0.0990167179445689, 0.0999798417569524, 0.10255107791893026, 0.1020547923907319, 0.9720521458908171, 0.9394951340496879, 0.9455676660107613, 0.9575697677247351, 0.9679135667272982, 0.967258818657186, 0.9768275046830152, 0.9836315961655483, 0.9568646998714232, 0.2719624601392784, 0.2663527651837079, 0.26983239061289066, 0.2785028350476094, 0.2793323210209051, 0.3167559609695624, 0.3222271294461001, 0.29294256892481985, 0.3406940084706719, 0.45487991411646655, 0.3467779848264386, 0.2757319402770563, 0.48830965011157146, 0.5392163514482193, 0.37485802703896465, 0.5194634196532125, 0.4779942410752631, 0.519479678332158, 0.18307099803005578, 0.18825051404816817, 0.14564208916623012, 0.18207138318800187, 0.1824186051323431, 0.18377929132644222, 0.17988888907435374, 0.2679957851639685, 0.17272254677940457, 0.15431516197804196, 0.009895155623442564, 0.1043579443699324, 0.2222897408950234, 0.1834667443690181, 0.20944734769064433, 0.1663222322651412, 0.1776422177215452, 0.23147282615994413, 0.09925790472171359, 0.08308721491641058, 0.06888860140273867, 0.13029319033812825, 0.06112235506975938, 0.07301144506038093, 0.061529316061809336, 0.08143034487492984, 0.07327089666062436, 0.17980390609705332, 0.18897801834699612, 0.20125037812501068, 0.16419214093463053, 0.18470828124434624, 0.13393103844230625, 0.23691538560272674, 0.21191811786418435, 0.21209742605708914, 0.00610839011846942, 0.0019171908691322237, 0.009125210286753282, 0.029191090700480538, 0.026152578941647908, 0.012212928524432343, 0.03782234907950044, 0.014823596611482914, 0.051591682663724714, 0.14472885235403077, 0.14066314221788156, 0.12633731957717353, 0.16190587942789803, 0.12934597134285797, 0.12086010831310523, 0.15581212994147264, 0.13754868022287015, 0.1309758087017744, 0.5030531678595119, 0.4893567434661299, 0.4745010099720147, 0.5221729972451521, 0.4620427990804381, 0.5010787981199949, 0.4868523685453866, 0.4945010890670596, 0.48130855890962143, 0.11111076391106123, 0.0767281779893445, 0.08476415365027046, 0.08279617537347239, 0.09006469059137123, 0.08109794077930832, 0.08932956143879167, 0.08757212404369019, 0.08023110776183306, 0.16450301390336808, 0.13688979911074417, 0.17200443233237506, 0.1470294693975105, 0.16074359799639604, 0.1637930272523046, 0.11945569082408547, 0.14698304787234973, 0.16840312030358096, 0.2697021203648329, 0.2987298493277907, 0.27310881118313035, 0.2594216019784058, 0.26657480371699704, 0.2631886619815519, 0.2809235480874158, 0.28830007621744846, 0.28809221297124654, 0.2011379774919545, 0.196246050651535, 0.21415263845243282, 0.188247093417927, 0.20421863540064733, 0.1787103719850338, 0.21883218647590597, 0.2188001741504123, 0.19423248402122018, 0.18443275981095497, 0.16293309642884124, 0.18581380029875805, 0.20068097972739296, 0.17343424403661323, 0.1775875427860637, 0.18075763798588163, 0.17988809884250279, 0.19506480510441648, 0.18114580365891575, 0.1853910850982019, 0.17724121698846151, 0.1741197021360431, 0.18542051627952516, 0.1810975525717995, 0.17259516199280456, 0.18206137083061114, 0.18720618242932952, 0.545809771703561, 0.1838260926807993, 0.1589653669974327, 0.18238879205131964, 0.17368443974306902, 0.17440809750655972, 0.44109273620577094, 0.4447199173332663, 0.14617684328818237, 0.4500312480887273, 0.19746458880579443, 0.19174813986679018, 0.19396726162015276, 0.2355345808576247, 0.243528327663752, 0.5201155904073593, 0.2062016632702386, 0.5904767909243915, 0.18956972698081742, 0.1890140455199607, 0.1828325033525383, 0.18479301504348955, 0.1903444794514323, 0.2050053184813292, 0.1831384371276481, 0.18160434493176714, 0.18596596933213883, 0.07163787927424925, 0.07266634643650871, 0.06392553944390222, 0.07659836737455794, 0.0735533112523461, 0.06888220326182615, 0.07647723791453975, 0.07283995011833644, 0.08664124945221807]}, "mutation_prompt": null}
{"id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 14, "fitness": 0.30242950212292563, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "a89b704e-386b-48be-b47d-722f15f815d5", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "cfda1621-6653-4144-9957-17f87156e940", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "a3ae8c17-6eb1-4369-a6e4-70aef218b425", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "9139e906-8e1c-465f-8461-bdbdc76b3af7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "99755b71-888f-447e-b649-9633fc50a7e9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "6659d2b0-9a3c-4fa9-9d59-ccfa3c786bd7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "a48fe8cb-a30d-4f85-bc15-c24c9b6dd401", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "ae121234-9ce5-4dda-9220-18bf0449ab2b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using adaptive mutation factor based on population diversity to improve convergence speed and solution quality.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.6796981309820858, 0.6664368965903156, 0.6784094288760576, 0.6974754854958098, 0.7014637668086829, 0.6981391449603034, 0.7563044161509553, 0.6965768827394205, 0.7125209983233826, 0.575933268700151, 0.47613349448687603, 0.541462493160136, 0.45995525390993375, 0.49072867879058657, 0.48076158307807193, 0.47340103444556747, 0.5428590371907724, 0.43720882438204167, 0.10217932677223485, 0.11269194875680766, 0.11200035906772321, 0.09933361383803474, 0.11030125920468759, 0.09846430258192651, 0.11567121800738556, 0.11021208614496136, 0.09637860049782865, 0.0953823193092338, 0.09731689264282428, 0.09898429416128307, 0.09675796490867283, 0.0990094321930981, 0.09856589075652278, 0.1085096985917553, 0.10226477407583656, 0.11215119152090336, 0.9165966928497205, 0.9456006169617412, 0.9399543030018389, 0.9417679161540143, 0.9156517305975606, 0.9249926082170554, 0.8704969744677205, 0.9362328883002619, 0.9801291837504769, 0.3011168561116252, 0.2846663527752624, 0.3060678514768558, 0.3548265503836947, 0.29946067062995485, 0.3127170464031709, 0.33606795922076327, 0.33763656559762345, 0.34206027822594, 0.5975822561429345, 0.5590630171212113, 0.6535060233806838, 0.5620760169616575, 0.5631302686520572, 0.6109292665148331, 0.5785696415115178, 0.5321108905308326, 0.686145448653871, 0.2232134789141974, 0.2548944998582302, 0.2816889131340554, 0.18856945418938265, 0.25549744293061616, 0.23305399851905606, 0.23521102664432925, 0.20183644862757932, 0.1964012095453005, 0.25055844070722044, 0.21115931552477984, 0.31515946531660255, 0.20006721882696066, 0.17844113752635227, 0.18764878007701324, 0.2092420196661784, 0.23838076105628647, 0.2638176383683798, 0.19817098990938598, 0.19720181532692327, 0.17134477737007114, 0.1698049271488501, 0.1564354952879039, 0.1555051377272899, 0.23196357939791423, 0.2096098750118749, 0.18643520717308348, 0.3435616867655471, 0.39927088120582976, 0.32059487177805646, 0.2965818833329751, 0.29789439506698534, 0.293485082856382, 0.37643918701699763, 0.3103170507931261, 0.3837862779780483, 0.0394878603812826, 0.03800494532057941, 0.06967936956453791, 0.06051003793206433, 0.0483363232386288, 0.06513172488333552, 0.041209328901841924, 0.05281725682869254, 0.06940813095497378, 0.17635097654109266, 0.1740191193554117, 0.1425387594869968, 0.16377181293890952, 0.17232098305191068, 0.1875075988746584, 0.17554833519501012, 0.13918301266800515, 0.1687171517063245, 0.5238618719923372, 0.5162402899183185, 0.5574952578297456, 0.48968207615827775, 0.5396616753100714, 0.5001161680697397, 0.5150348166083013, 0.5089605763422828, 0.5243561986646952, 0.1007811065500851, 0.09351870732604639, 0.11172094983457914, 0.09261061726649877, 0.08641225335429459, 0.08490890519947769, 0.08133647201055771, 0.09301803618226201, 0.08938932931213572, 0.16045001083117383, 0.14443924034440048, 0.1624756715699608, 0.18515717846164714, 0.13562347966069754, 0.14319035211040243, 0.15691761273344473, 0.15567935490150853, 0.14387960893660257, 0.30240851507382926, 0.28705394632356807, 0.27482154003110426, 0.27661108173668225, 0.2938172857334087, 0.29873372254075525, 0.3227999580231874, 0.3034507871419081, 0.3151070607693439, 0.23057377728200346, 0.20587975449027984, 0.2555747811252268, 0.21567157203553966, 0.23484576137918856, 0.21872523089800722, 0.23957863417885417, 0.2529684419194661, 0.23972007186605726, 0.18330501327248827, 0.18786157510875068, 0.18141672151869748, 0.17702427794940667, 0.18511595688966442, 0.186999594683395, 0.18936779935169235, 0.18517032848579618, 0.18159476292903498, 0.19716274927588895, 0.1857864414670355, 0.17649550491762167, 0.1830672530597942, 0.17702212023558972, 0.18152586780573876, 0.19112685089909942, 0.1730855568169991, 0.1867324968644608, 0.15811193340391727, 0.6708830543269492, 0.1793483043844728, 0.5691552199211722, 0.5929272159400524, 0.6615142770148295, 0.603499037312333, 0.5279042095257879, 0.3626663148256545, 0.48326724708483904, 0.5642949138711167, 0.48965073563834205, 0.20038167998037826, 0.18734073787525796, 0.1860098860668724, 0.6516856724276188, 0.19901391169086624, 0.6761619266973735, 0.18953817647514937, 0.19169316259502778, 0.17878682686435843, 0.18320962369283267, 0.18738879862570135, 0.17667839932508866, 0.18982202545069304, 0.1874285632841387, 0.19791825569775812, 0.07844711168692742, 0.07275333109486748, 0.0807305715586788, 0.07972985934181775, 0.06672986072383102, 0.07905567799972446, 0.06771431129260841, 0.07978860040018443, 0.06983544779382156]}, "mutation_prompt": null}
{"id": "a00681e8-34fa-4488-a243-37b0502b16b5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced stochastic crossover rate adaptation and adaptive population resizing based on evaluation progress to improve convergence and diversity handling.", "configspace": "", "generation": 22, "fitness": 0.3587389763495858, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.23.", "error": "", "parent_id": "53a417fc-9b20-4fc1-9e22-3a1dcec948dc", "metadata": {"aucs": [0.7784798931044141, 0.7655063229607122, 0.7596439170708892, 0.7610386423393949, 0.7500072986606561, 0.7586052584951755, 0.7392535657199596, 0.7824777581544456, 0.7490494016802807, 0.6636556238516647, 0.6149817313559317, 0.6673498242428926, 0.6574076283954073, 0.7014745738169026, 0.6516206380557547, 0.6540154095067675, 0.6392726743234781, 0.6385771026611384, 0.3525810263912452, 0.27107864573331897, 0.376178792782106, 0.26958305332963395, 0.14118752430055315, 0.3151937620929368, 0.3125525811484, 0.25479274103064375, 0.3875386160520158, 0.2794669302372663, 0.28170000793823236, 0.31207041992345996, 0.21324156847523057, 0.28766460030606955, 0.2879310736676789, 0.25450230957075104, 0.140956494967857, 0.13343779646243836, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.909267897862198, 0.9578631346330645, 0.9470363812207531, 0.9588976011215037, 0.9391441015782311, 0.9460440544094463, 0.35425204551472533, 0.4220749137942156, 0.49420349570609345, 0.5031200299999343, 0.45195636679599016, 0.5131125305000808, 0.43515034737697, 0.48532787729347016, 0.4751683702664986, 0.6326123790512214, 0.5697638224488079, 0.5858372462066311, 0.6946529741935636, 0.670625484382702, 0.6374152133853723, 0.6317780381074959, 0.6077104820224053, 0.6421220711844277, 0.2678465144978519, 0.18320340935093704, 0.2619684023503953, 0.362674889306954, 0.44575285664651987, 0.3443521638350412, 0.2733704095589693, 0.345949436350112, 0.30562351291864265, 0.16784432570114027, 0.21697035834226397, 0.12096357805167557, 0.36803810087625666, 0.3607220937218123, 0.21986118491905415, 0.19898501918946854, 0.40931555627632554, 0.18117165260918522, 0.29147051186300554, 0.21759276839323594, 0.18213133082291866, 0.2542047915279786, 0.22796577338302026, 0.29760446619016434, 0.21417785706843173, 0.2609218509983158, 0.292583891314935, 0.36003650823323685, 0.30522075282629413, 0.3375992107456829, 0.2761349120121971, 0.3588891945944497, 0.3149322835439732, 0.35928040252611315, 0.42196107819411555, 0.40357275781876145, 0.07970791749080852, 0.09148133851474627, 0.10977833474852505, 0.05408894118898111, 0.07319452127873904, 0.07185464205650638, 0.13992916424102753, 0.07258664823363614, 0.15143172249093773, 0.24983948603746486, 0.23782085714090861, 0.24453714903010426, 0.2466912471642737, 0.2593609511147351, 0.2579545641722438, 0.2178461135814228, 0.19425996967007153, 0.21640430248661713, 0.6576072560248089, 0.6315666877723554, 0.5773872927971857, 0.6380869720879601, 0.6185509118955491, 0.6159555691915317, 0.5882113104497735, 0.5832075934850647, 0.6304574663608927, 0.09904055349885676, 0.09194904180458674, 0.08922389059787983, 0.09428135615849165, 0.09657903228636677, 0.0994093242956573, 0.0965260237321085, 0.1163511603577928, 0.08588748883542607, 0.21298866242453274, 0.13979791269200437, 0.15089048850707654, 0.15313532476920022, 0.15547976423614618, 0.16717465339424176, 0.1667967067976177, 0.14610228064162512, 0.147110876032729, 0.38413883909762014, 0.34549796291714663, 0.32564103839987657, 0.3564520988903631, 0.4100666003495007, 0.4176413071046995, 0.4316624924003012, 0.47645257095405313, 0.4287427959095924, 0.28463120292733857, 0.2912793706279676, 0.2681813690730116, 0.2970101533584829, 0.27208697877598087, 0.28434027795149464, 0.32610417904119715, 0.31803139776024925, 0.27773568767877344, 0.1945134069812421, 0.17968730056642512, 0.19261945217218313, 0.21136209434464048, 0.19389835312570636, 0.19916181239452102, 0.2077108976818055, 0.19658340417000075, 0.20241014888307363, 0.19049260874086205, 0.299798252135718, 0.3220257925386323, 0.3401019536711152, 0.2231607318406824, 0.2605628772664039, 0.5111419566149864, 0.3167998173844334, 0.2114674651310091, 0.6244242558029438, 0.1712621758961772, 0.721975539020777, 0.6141237023033308, 0.4520293242184553, 0.5531139081536134, 0.6357567006241667, 0.42820465463724044, 0.5347862306600244, 0.2488777866639731, 0.6131149202221121, 0.16060303968927236, 0.1950130030831818, 0.18876733007490887, 0.18602922149536727, 0.20570075414983635, 0.5899718711574098, 0.20877683868943542, 0.19121018432654957, 0.17757764220060512, 0.1938268969840421, 0.18585293983569884, 0.18657206728305886, 0.19288006948116299, 0.1742738101440069, 0.18879212015690017, 0.2088450803462868, 0.06914487305205308, 0.06713904161468964, 0.0702974958724224, 0.07683112662538572, 0.07517405026598967, 0.07859817964527516, 0.07340031989519324, 0.07277596261888286, 0.0779735490338801]}, "mutation_prompt": null}
{"id": "477507ac-ef88-4477-85e9-8d0eab9b262f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced stochastic crossover rate adaptation and adaptive population resizing based on evaluation progress to improve convergence and diversity handling.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a00681e8-34fa-4488-a243-37b0502b16b5", "metadata": {"aucs": [0.7784798931044141, 0.7655063229607122, 0.7596439170708892, 0.7610386423393949, 0.7500072986606561, 0.7586052584951755, 0.7392535657199596, 0.7824777581544456, 0.7490494016802807, 0.6636556238516647, 0.6149817313559317, 0.6673498242428926, 0.6574076283954073, 0.7014745738169026, 0.6516206380557547, 0.6540154095067675, 0.6392726743234781, 0.6385771026611384, 0.3525810263912452, 0.27107864573331897, 0.376178792782106, 0.26958305332963395, 0.14118752430055315, 0.3151937620929368, 0.3125525811484, 0.25479274103064375, 0.3875386160520158, 0.2794669302372663, 0.28170000793823236, 0.31207041992345996, 0.21324156847523057, 0.28766460030606955, 0.2879310736676789, 0.25450230957075104, 0.140956494967857, 0.13343779646243836, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.909267897862198, 0.9578631346330645, 0.9470363812207531, 0.9588976011215037, 0.9391441015782311, 0.9460440544094463, 0.35425204551472533, 0.4220749137942156, 0.49420349570609345, 0.5031200299999343, 0.45195636679599016, 0.5131125305000808, 0.43515034737697, 0.48532787729347016, 0.4751683702664986, 0.6326123790512214, 0.5697638224488079, 0.5858372462066311, 0.6946529741935636, 0.670625484382702, 0.6374152133853723, 0.6317780381074959, 0.6077104820224053, 0.6421220711844277, 0.2678465144978519, 0.18320340935093704, 0.2619684023503953, 0.362674889306954, 0.44575285664651987, 0.3443521638350412, 0.2733704095589693, 0.345949436350112, 0.30562351291864265, 0.16784432570114027, 0.21697035834226397, 0.12096357805167557, 0.36803810087625666, 0.3607220937218123, 0.21986118491905415, 0.19898501918946854, 0.40931555627632554, 0.18117165260918522, 0.29147051186300554, 0.21759276839323594, 0.18213133082291866, 0.2542047915279786, 0.22796577338302026, 0.29760446619016434, 0.21417785706843173, 0.2609218509983158, 0.292583891314935, 0.36003650823323685, 0.30522075282629413, 0.3375992107456829, 0.2761349120121971, 0.3588891945944497, 0.3149322835439732, 0.35928040252611315, 0.42196107819411555, 0.40357275781876145, 0.07970791749080852, 0.09148133851474627, 0.10977833474852505, 0.05408894118898111, 0.07319452127873904, 0.07185464205650638, 0.13992916424102753, 0.07258664823363614, 0.15143172249093773, 0.24983948603746486, 0.23782085714090861, 0.24453714903010426, 0.2466912471642737, 0.2593609511147351, 0.2579545641722438, 0.2178461135814228, 0.19425996967007153, 0.21640430248661713, 0.6576072560248089, 0.6315666877723554, 0.5773872927971857, 0.6380869720879601, 0.6185509118955491, 0.6159555691915317, 0.5882113104497735, 0.5832075934850647, 0.6304574663608927, 0.09904055349885676, 0.09194904180458674, 0.08922389059787983, 0.09428135615849165, 0.09657903228636677, 0.0994093242956573, 0.0965260237321085, 0.1163511603577928, 0.08588748883542607, 0.21298866242453274, 0.13979791269200437, 0.15089048850707654, 0.15313532476920022, 0.15547976423614618, 0.16717465339424176, 0.1667967067976177, 0.14610228064162512, 0.147110876032729, 0.38413883909762014, 0.34549796291714663, 0.32564103839987657, 0.3564520988903631, 0.4100666003495007, 0.4176413071046995, 0.4316624924003012, 0.47645257095405313, 0.4287427959095924, 0.28463120292733857, 0.2912793706279676, 0.2681813690730116, 0.2970101533584829, 0.27208697877598087, 0.28434027795149464, 0.32610417904119715, 0.31803139776024925, 0.27773568767877344, 0.1945134069812421, 0.17968730056642512, 0.19261945217218313, 0.21136209434464048, 0.19389835312570636, 0.19916181239452102, 0.2077108976818055, 0.19658340417000075, 0.20241014888307363, 0.19049260874086205, 0.299798252135718, 0.3220257925386323, 0.3401019536711152, 0.2231607318406824, 0.2605628772664039, 0.5111419566149864, 0.3167998173844334, 0.2114674651310091, 0.6244242558029438, 0.1712621758961772, 0.721975539020777, 0.6141237023033308, 0.4520293242184553, 0.5531139081536134, 0.6357567006241667, 0.42820465463724044, 0.5347862306600244, 0.2488777866639731, 0.6131149202221121, 0.16060303968927236, 0.1950130030831818, 0.18876733007490887, 0.18602922149536727, 0.20570075414983635, 0.5899718711574098, 0.20877683868943542, 0.19121018432654957, 0.17757764220060512, 0.1938268969840421, 0.18585293983569884, 0.18657206728305886, 0.19288006948116299, 0.1742738101440069, 0.18879212015690017, 0.2088450803462868, 0.06914487305205308, 0.06713904161468964, 0.0702974958724224, 0.07683112662538572, 0.07517405026598967, 0.07859817964527516, 0.07340031989519324, 0.07277596261888286, 0.0779735490338801]}, "mutation_prompt": null}
{"id": "74a3f32f-cfc1-4cd4-9275-e29b918ff871", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced stochastic crossover rate adaptation and adaptive population resizing based on evaluation progress to improve convergence and diversity handling.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a00681e8-34fa-4488-a243-37b0502b16b5", "metadata": {"aucs": [0.7784798931044141, 0.7655063229607122, 0.7596439170708892, 0.7610386423393949, 0.7500072986606561, 0.7586052584951755, 0.7392535657199596, 0.7824777581544456, 0.7490494016802807, 0.6636556238516647, 0.6149817313559317, 0.6673498242428926, 0.6574076283954073, 0.7014745738169026, 0.6516206380557547, 0.6540154095067675, 0.6392726743234781, 0.6385771026611384, 0.3525810263912452, 0.27107864573331897, 0.376178792782106, 0.26958305332963395, 0.14118752430055315, 0.3151937620929368, 0.3125525811484, 0.25479274103064375, 0.3875386160520158, 0.2794669302372663, 0.28170000793823236, 0.31207041992345996, 0.21324156847523057, 0.28766460030606955, 0.2879310736676789, 0.25450230957075104, 0.140956494967857, 0.13343779646243836, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.909267897862198, 0.9578631346330645, 0.9470363812207531, 0.9588976011215037, 0.9391441015782311, 0.9460440544094463, 0.35425204551472533, 0.4220749137942156, 0.49420349570609345, 0.5031200299999343, 0.45195636679599016, 0.5131125305000808, 0.43515034737697, 0.48532787729347016, 0.4751683702664986, 0.6326123790512214, 0.5697638224488079, 0.5858372462066311, 0.6946529741935636, 0.670625484382702, 0.6374152133853723, 0.6317780381074959, 0.6077104820224053, 0.6421220711844277, 0.2678465144978519, 0.18320340935093704, 0.2619684023503953, 0.362674889306954, 0.44575285664651987, 0.3443521638350412, 0.2733704095589693, 0.345949436350112, 0.30562351291864265, 0.16784432570114027, 0.21697035834226397, 0.12096357805167557, 0.36803810087625666, 0.3607220937218123, 0.21986118491905415, 0.19898501918946854, 0.40931555627632554, 0.18117165260918522, 0.29147051186300554, 0.21759276839323594, 0.18213133082291866, 0.2542047915279786, 0.22796577338302026, 0.29760446619016434, 0.21417785706843173, 0.2609218509983158, 0.292583891314935, 0.36003650823323685, 0.30522075282629413, 0.3375992107456829, 0.2761349120121971, 0.3588891945944497, 0.3149322835439732, 0.35928040252611315, 0.42196107819411555, 0.40357275781876145, 0.07970791749080852, 0.09148133851474627, 0.10977833474852505, 0.05408894118898111, 0.07319452127873904, 0.07185464205650638, 0.13992916424102753, 0.07258664823363614, 0.15143172249093773, 0.24983948603746486, 0.23782085714090861, 0.24453714903010426, 0.2466912471642737, 0.2593609511147351, 0.2579545641722438, 0.2178461135814228, 0.19425996967007153, 0.21640430248661713, 0.6576072560248089, 0.6315666877723554, 0.5773872927971857, 0.6380869720879601, 0.6185509118955491, 0.6159555691915317, 0.5882113104497735, 0.5832075934850647, 0.6304574663608927, 0.09904055349885676, 0.09194904180458674, 0.08922389059787983, 0.09428135615849165, 0.09657903228636677, 0.0994093242956573, 0.0965260237321085, 0.1163511603577928, 0.08588748883542607, 0.21298866242453274, 0.13979791269200437, 0.15089048850707654, 0.15313532476920022, 0.15547976423614618, 0.16717465339424176, 0.1667967067976177, 0.14610228064162512, 0.147110876032729, 0.38413883909762014, 0.34549796291714663, 0.32564103839987657, 0.3564520988903631, 0.4100666003495007, 0.4176413071046995, 0.4316624924003012, 0.47645257095405313, 0.4287427959095924, 0.28463120292733857, 0.2912793706279676, 0.2681813690730116, 0.2970101533584829, 0.27208697877598087, 0.28434027795149464, 0.32610417904119715, 0.31803139776024925, 0.27773568767877344, 0.1945134069812421, 0.17968730056642512, 0.19261945217218313, 0.21136209434464048, 0.19389835312570636, 0.19916181239452102, 0.2077108976818055, 0.19658340417000075, 0.20241014888307363, 0.19049260874086205, 0.299798252135718, 0.3220257925386323, 0.3401019536711152, 0.2231607318406824, 0.2605628772664039, 0.5111419566149864, 0.3167998173844334, 0.2114674651310091, 0.6244242558029438, 0.1712621758961772, 0.721975539020777, 0.6141237023033308, 0.4520293242184553, 0.5531139081536134, 0.6357567006241667, 0.42820465463724044, 0.5347862306600244, 0.2488777866639731, 0.6131149202221121, 0.16060303968927236, 0.1950130030831818, 0.18876733007490887, 0.18602922149536727, 0.20570075414983635, 0.5899718711574098, 0.20877683868943542, 0.19121018432654957, 0.17757764220060512, 0.1938268969840421, 0.18585293983569884, 0.18657206728305886, 0.19288006948116299, 0.1742738101440069, 0.18879212015690017, 0.2088450803462868, 0.06914487305205308, 0.06713904161468964, 0.0702974958724224, 0.07683112662538572, 0.07517405026598967, 0.07859817964527516, 0.07340031989519324, 0.07277596261888286, 0.0779735490338801]}, "mutation_prompt": null}
{"id": "6709584c-375d-4f00-8113-b58b41cee11a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced stochastic crossover rate adaptation and adaptive population resizing based on evaluation progress to improve convergence and diversity handling.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a00681e8-34fa-4488-a243-37b0502b16b5", "metadata": {"aucs": [0.7784798931044141, 0.7655063229607122, 0.7596439170708892, 0.7610386423393949, 0.7500072986606561, 0.7586052584951755, 0.7392535657199596, 0.7824777581544456, 0.7490494016802807, 0.6636556238516647, 0.6149817313559317, 0.6673498242428926, 0.6574076283954073, 0.7014745738169026, 0.6516206380557547, 0.6540154095067675, 0.6392726743234781, 0.6385771026611384, 0.3525810263912452, 0.27107864573331897, 0.376178792782106, 0.26958305332963395, 0.14118752430055315, 0.3151937620929368, 0.3125525811484, 0.25479274103064375, 0.3875386160520158, 0.2794669302372663, 0.28170000793823236, 0.31207041992345996, 0.21324156847523057, 0.28766460030606955, 0.2879310736676789, 0.25450230957075104, 0.140956494967857, 0.13343779646243836, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.909267897862198, 0.9578631346330645, 0.9470363812207531, 0.9588976011215037, 0.9391441015782311, 0.9460440544094463, 0.35425204551472533, 0.4220749137942156, 0.49420349570609345, 0.5031200299999343, 0.45195636679599016, 0.5131125305000808, 0.43515034737697, 0.48532787729347016, 0.4751683702664986, 0.6326123790512214, 0.5697638224488079, 0.5858372462066311, 0.6946529741935636, 0.670625484382702, 0.6374152133853723, 0.6317780381074959, 0.6077104820224053, 0.6421220711844277, 0.2678465144978519, 0.18320340935093704, 0.2619684023503953, 0.362674889306954, 0.44575285664651987, 0.3443521638350412, 0.2733704095589693, 0.345949436350112, 0.30562351291864265, 0.16784432570114027, 0.21697035834226397, 0.12096357805167557, 0.36803810087625666, 0.3607220937218123, 0.21986118491905415, 0.19898501918946854, 0.40931555627632554, 0.18117165260918522, 0.29147051186300554, 0.21759276839323594, 0.18213133082291866, 0.2542047915279786, 0.22796577338302026, 0.29760446619016434, 0.21417785706843173, 0.2609218509983158, 0.292583891314935, 0.36003650823323685, 0.30522075282629413, 0.3375992107456829, 0.2761349120121971, 0.3588891945944497, 0.3149322835439732, 0.35928040252611315, 0.42196107819411555, 0.40357275781876145, 0.07970791749080852, 0.09148133851474627, 0.10977833474852505, 0.05408894118898111, 0.07319452127873904, 0.07185464205650638, 0.13992916424102753, 0.07258664823363614, 0.15143172249093773, 0.24983948603746486, 0.23782085714090861, 0.24453714903010426, 0.2466912471642737, 0.2593609511147351, 0.2579545641722438, 0.2178461135814228, 0.19425996967007153, 0.21640430248661713, 0.6576072560248089, 0.6315666877723554, 0.5773872927971857, 0.6380869720879601, 0.6185509118955491, 0.6159555691915317, 0.5882113104497735, 0.5832075934850647, 0.6304574663608927, 0.09904055349885676, 0.09194904180458674, 0.08922389059787983, 0.09428135615849165, 0.09657903228636677, 0.0994093242956573, 0.0965260237321085, 0.1163511603577928, 0.08588748883542607, 0.21298866242453274, 0.13979791269200437, 0.15089048850707654, 0.15313532476920022, 0.15547976423614618, 0.16717465339424176, 0.1667967067976177, 0.14610228064162512, 0.147110876032729, 0.38413883909762014, 0.34549796291714663, 0.32564103839987657, 0.3564520988903631, 0.4100666003495007, 0.4176413071046995, 0.4316624924003012, 0.47645257095405313, 0.4287427959095924, 0.28463120292733857, 0.2912793706279676, 0.2681813690730116, 0.2970101533584829, 0.27208697877598087, 0.28434027795149464, 0.32610417904119715, 0.31803139776024925, 0.27773568767877344, 0.1945134069812421, 0.17968730056642512, 0.19261945217218313, 0.21136209434464048, 0.19389835312570636, 0.19916181239452102, 0.2077108976818055, 0.19658340417000075, 0.20241014888307363, 0.19049260874086205, 0.299798252135718, 0.3220257925386323, 0.3401019536711152, 0.2231607318406824, 0.2605628772664039, 0.5111419566149864, 0.3167998173844334, 0.2114674651310091, 0.6244242558029438, 0.1712621758961772, 0.721975539020777, 0.6141237023033308, 0.4520293242184553, 0.5531139081536134, 0.6357567006241667, 0.42820465463724044, 0.5347862306600244, 0.2488777866639731, 0.6131149202221121, 0.16060303968927236, 0.1950130030831818, 0.18876733007490887, 0.18602922149536727, 0.20570075414983635, 0.5899718711574098, 0.20877683868943542, 0.19121018432654957, 0.17757764220060512, 0.1938268969840421, 0.18585293983569884, 0.18657206728305886, 0.19288006948116299, 0.1742738101440069, 0.18879212015690017, 0.2088450803462868, 0.06914487305205308, 0.06713904161468964, 0.0702974958724224, 0.07683112662538572, 0.07517405026598967, 0.07859817964527516, 0.07340031989519324, 0.07277596261888286, 0.0779735490338801]}, "mutation_prompt": null}
{"id": "d2e8d868-f84d-462d-89d2-262688f86b7f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduced stochastic crossover rate adaptation and adaptive population resizing based on evaluation progress to improve convergence and diversity handling.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a00681e8-34fa-4488-a243-37b0502b16b5", "metadata": {"aucs": [0.7784798931044141, 0.7655063229607122, 0.7596439170708892, 0.7610386423393949, 0.7500072986606561, 0.7586052584951755, 0.7392535657199596, 0.7824777581544456, 0.7490494016802807, 0.6636556238516647, 0.6149817313559317, 0.6673498242428926, 0.6574076283954073, 0.7014745738169026, 0.6516206380557547, 0.6540154095067675, 0.6392726743234781, 0.6385771026611384, 0.3525810263912452, 0.27107864573331897, 0.376178792782106, 0.26958305332963395, 0.14118752430055315, 0.3151937620929368, 0.3125525811484, 0.25479274103064375, 0.3875386160520158, 0.2794669302372663, 0.28170000793823236, 0.31207041992345996, 0.21324156847523057, 0.28766460030606955, 0.2879310736676789, 0.25450230957075104, 0.140956494967857, 0.13343779646243836, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.909267897862198, 0.9578631346330645, 0.9470363812207531, 0.9588976011215037, 0.9391441015782311, 0.9460440544094463, 0.35425204551472533, 0.4220749137942156, 0.49420349570609345, 0.5031200299999343, 0.45195636679599016, 0.5131125305000808, 0.43515034737697, 0.48532787729347016, 0.4751683702664986, 0.6326123790512214, 0.5697638224488079, 0.5858372462066311, 0.6946529741935636, 0.670625484382702, 0.6374152133853723, 0.6317780381074959, 0.6077104820224053, 0.6421220711844277, 0.2678465144978519, 0.18320340935093704, 0.2619684023503953, 0.362674889306954, 0.44575285664651987, 0.3443521638350412, 0.2733704095589693, 0.345949436350112, 0.30562351291864265, 0.16784432570114027, 0.21697035834226397, 0.12096357805167557, 0.36803810087625666, 0.3607220937218123, 0.21986118491905415, 0.19898501918946854, 0.40931555627632554, 0.18117165260918522, 0.29147051186300554, 0.21759276839323594, 0.18213133082291866, 0.2542047915279786, 0.22796577338302026, 0.29760446619016434, 0.21417785706843173, 0.2609218509983158, 0.292583891314935, 0.36003650823323685, 0.30522075282629413, 0.3375992107456829, 0.2761349120121971, 0.3588891945944497, 0.3149322835439732, 0.35928040252611315, 0.42196107819411555, 0.40357275781876145, 0.07970791749080852, 0.09148133851474627, 0.10977833474852505, 0.05408894118898111, 0.07319452127873904, 0.07185464205650638, 0.13992916424102753, 0.07258664823363614, 0.15143172249093773, 0.24983948603746486, 0.23782085714090861, 0.24453714903010426, 0.2466912471642737, 0.2593609511147351, 0.2579545641722438, 0.2178461135814228, 0.19425996967007153, 0.21640430248661713, 0.6576072560248089, 0.6315666877723554, 0.5773872927971857, 0.6380869720879601, 0.6185509118955491, 0.6159555691915317, 0.5882113104497735, 0.5832075934850647, 0.6304574663608927, 0.09904055349885676, 0.09194904180458674, 0.08922389059787983, 0.09428135615849165, 0.09657903228636677, 0.0994093242956573, 0.0965260237321085, 0.1163511603577928, 0.08588748883542607, 0.21298866242453274, 0.13979791269200437, 0.15089048850707654, 0.15313532476920022, 0.15547976423614618, 0.16717465339424176, 0.1667967067976177, 0.14610228064162512, 0.147110876032729, 0.38413883909762014, 0.34549796291714663, 0.32564103839987657, 0.3564520988903631, 0.4100666003495007, 0.4176413071046995, 0.4316624924003012, 0.47645257095405313, 0.4287427959095924, 0.28463120292733857, 0.2912793706279676, 0.2681813690730116, 0.2970101533584829, 0.27208697877598087, 0.28434027795149464, 0.32610417904119715, 0.31803139776024925, 0.27773568767877344, 0.1945134069812421, 0.17968730056642512, 0.19261945217218313, 0.21136209434464048, 0.19389835312570636, 0.19916181239452102, 0.2077108976818055, 0.19658340417000075, 0.20241014888307363, 0.19049260874086205, 0.299798252135718, 0.3220257925386323, 0.3401019536711152, 0.2231607318406824, 0.2605628772664039, 0.5111419566149864, 0.3167998173844334, 0.2114674651310091, 0.6244242558029438, 0.1712621758961772, 0.721975539020777, 0.6141237023033308, 0.4520293242184553, 0.5531139081536134, 0.6357567006241667, 0.42820465463724044, 0.5347862306600244, 0.2488777866639731, 0.6131149202221121, 0.16060303968927236, 0.1950130030831818, 0.18876733007490887, 0.18602922149536727, 0.20570075414983635, 0.5899718711574098, 0.20877683868943542, 0.19121018432654957, 0.17757764220060512, 0.1938268969840421, 0.18585293983569884, 0.18657206728305886, 0.19288006948116299, 0.1742738101440069, 0.18879212015690017, 0.2088450803462868, 0.06914487305205308, 0.06713904161468964, 0.0702974958724224, 0.07683112662538572, 0.07517405026598967, 0.07859817964527516, 0.07340031989519324, 0.07277596261888286, 0.0779735490338801]}, "mutation_prompt": null}
{"id": "babc37b1-8c55-46a8-bad7-bcc19383e971", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance solution exploitation by introducing a hybrid local search that combines elitism with Gaussian perturbation for better convergence.", "configspace": "", "generation": 27, "fitness": 0.3674109895257014, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.23.", "error": "", "parent_id": "a00681e8-34fa-4488-a243-37b0502b16b5", "metadata": {"aucs": [0.7685894203369232, 0.7369397570993315, 0.766809962427716, 0.7505757051120239, 0.7682703407834737, 0.8057306223197575, 0.7428168089709306, 0.800603152598218, 0.7662502078278356, 0.6252831136022223, 0.6708280714545009, 0.6266331665430174, 0.6531036803114995, 0.6365797713146712, 0.6469155778718529, 0.5976675033975374, 0.6655258123813226, 0.7183537868812604, 0.30722519806763704, 0.3781342665260552, 0.1478572814719633, 0.2833062521545199, 0.30419083007456515, 0.36023464053202303, 0.3482061109829627, 0.391836626145188, 0.40885679072679937, 0.28206268944605684, 0.24083021535901894, 0.3159412759402247, 0.3463167105657987, 0.122669639721115, 0.3099662427731249, 0.2685275860523423, 0.132529093411197, 0.30379516606737245, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.9412572792272851, 0.9578631346330645, 0.9524346260492567, 0.9474309980663823, 0.9717627237525952, 0.9460440544094463, 0.48510810461478837, 0.459982779055378, 0.4827089190336724, 0.48399354117485305, 0.4643804089730573, 0.5089746712781968, 0.44225625375894706, 0.4715589237542748, 0.4923578245821849, 0.682434726109038, 0.5798076429139782, 0.5725180240224129, 0.5855501265705796, 0.665129352299217, 0.6443779300328755, 0.6416646647928508, 0.6179833093853513, 0.7129811489854705, 0.22876263209796388, 0.24707901469203475, 0.25897304770131624, 0.199203371167051, 0.3264024975215387, 0.22805005475369977, 0.3605928201033457, 0.2912962063355712, 0.38585607518961773, 0.18228361765842604, 0.3173648383669513, 0.4086402767493982, 0.2180804098064164, 0.2818919014987127, 0.41965710418840807, 0.27506960573928196, 0.21465583959610846, 0.19900679974158075, 0.1827655414239746, 0.17110810024129808, 0.18900382357466883, 0.2543671520730413, 0.13887242216031737, 0.2380096256041867, 0.18368590915302585, 0.2214222464867105, 0.24899297422253042, 0.32649402158128127, 0.3387455036288286, 0.35755363318199385, 0.2881085563166893, 0.25264194428964215, 0.4342310144710321, 0.47378844913112084, 0.39538072964861126, 0.4191662811901331, 0.08472488267570988, 0.079681960725416, 0.07102274024503241, 0.074591902062081, 0.10456593741157016, 0.0900167047290037, 0.10213822765524361, 0.12791873625433614, 0.10376586033478852, 0.22511774306869436, 0.2069521873991551, 0.23250314682754747, 0.2616192391948935, 0.21965772161811292, 0.24971735000462003, 0.2189197200031644, 0.2009544118857649, 0.22171237497527263, 0.6065494774093629, 0.6107231310194818, 0.6008371528892986, 0.6085615530774218, 0.6063318778670428, 0.5897554684241706, 0.5941381685274607, 0.5988231977843355, 0.6041481965678586, 0.10786773362838453, 0.10234785527025614, 0.10297454014169738, 0.11177171745779124, 0.09798840779446016, 0.09948951485496782, 0.10783395246822947, 0.10598303932153319, 0.11762626184152869, 0.18628159551600532, 0.14980433728599984, 0.18145412815360284, 0.18103403899003023, 0.16295113435302178, 0.159836010633031, 0.15430164437198768, 0.24846404474076544, 0.15512665171048579, 0.3839675627492284, 0.3598894888646488, 0.35091994449034214, 0.39386504364160524, 0.3633733270735233, 0.4047449989543459, 0.44028580649603566, 0.44945870674326993, 0.405717843462149, 0.2830434437163406, 0.2644380923499967, 0.2939836303835467, 0.27573684260681697, 0.2457482561933364, 0.2822598839346857, 0.31395321392923226, 0.27148002523634085, 0.3181856469081581, 0.1779036402953187, 0.17759551266662843, 0.21661223260733808, 0.18336067541908452, 0.18366592243898183, 0.19268323483885363, 0.18229321078063465, 0.18830195415921158, 0.1994530498014655, 0.2006785411350911, 0.21216636133302036, 0.2750631783363088, 0.19323699736910038, 0.3474991370462912, 0.4454503298876199, 0.2085457610457977, 0.32325205032000837, 0.36956146482304697, 0.6921952762536157, 0.7462603889427523, 0.7238187113205716, 0.5444020986703161, 0.6642193402175847, 0.6165137226107464, 0.746013406471252, 0.6598554587829778, 0.7200555158298129, 0.5844447907484085, 0.6141001938009852, 0.19583216976417783, 0.2026536058753715, 0.1919718870256636, 0.5819931223477065, 0.20287679130908143, 0.20098091763370618, 0.20854872833505156, 0.17974805549447337, 0.18138958277545825, 0.17494480639477406, 0.20071196126785928, 0.17479712502488653, 0.18081507814595144, 0.18061893406634122, 0.18511687131415655, 0.18570686232072753, 0.07181658101066168, 0.08290485814011805, 0.0728014295996442, 0.07732970758121593, 0.07699963030151791, 0.08422641051386803, 0.0823876989646598, 0.07559500852259005, 0.07533980241607463]}, "mutation_prompt": null}
{"id": "f3c11a37-46d9-4256-ba6f-20f8d561e755", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            self.f = self.f_initial * (1 + 0.1 * (1 - diversity))  # Adaptive mutation factor\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - self.eval_count / self.budget)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Stochastic crossover rate adaptation\n                self.cr = 0.5 + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance solution exploitation by introducing a hybrid local search that combines elitism with Gaussian perturbation for better convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "babc37b1-8c55-46a8-bad7-bcc19383e971", "metadata": {"aucs": [0.7685894203369232, 0.7369397570993315, 0.766809962427716, 0.7505757051120239, 0.7682703407834737, 0.8057306223197575, 0.7428168089709306, 0.800603152598218, 0.7662502078278356, 0.6252831136022223, 0.6708280714545009, 0.6266331665430174, 0.6531036803114995, 0.6365797713146712, 0.6469155778718529, 0.5976675033975374, 0.6655258123813226, 0.7183537868812604, 0.30722519806763704, 0.3781342665260552, 0.1478572814719633, 0.2833062521545199, 0.30419083007456515, 0.36023464053202303, 0.3482061109829627, 0.391836626145188, 0.40885679072679937, 0.28206268944605684, 0.24083021535901894, 0.3159412759402247, 0.3463167105657987, 0.122669639721115, 0.3099662427731249, 0.2685275860523423, 0.132529093411197, 0.30379516606737245, 0.9455036057305768, 0.9588233804218586, 0.9417712443825527, 0.9412572792272851, 0.9578631346330645, 0.9524346260492567, 0.9474309980663823, 0.9717627237525952, 0.9460440544094463, 0.48510810461478837, 0.459982779055378, 0.4827089190336724, 0.48399354117485305, 0.4643804089730573, 0.5089746712781968, 0.44225625375894706, 0.4715589237542748, 0.4923578245821849, 0.682434726109038, 0.5798076429139782, 0.5725180240224129, 0.5855501265705796, 0.665129352299217, 0.6443779300328755, 0.6416646647928508, 0.6179833093853513, 0.7129811489854705, 0.22876263209796388, 0.24707901469203475, 0.25897304770131624, 0.199203371167051, 0.3264024975215387, 0.22805005475369977, 0.3605928201033457, 0.2912962063355712, 0.38585607518961773, 0.18228361765842604, 0.3173648383669513, 0.4086402767493982, 0.2180804098064164, 0.2818919014987127, 0.41965710418840807, 0.27506960573928196, 0.21465583959610846, 0.19900679974158075, 0.1827655414239746, 0.17110810024129808, 0.18900382357466883, 0.2543671520730413, 0.13887242216031737, 0.2380096256041867, 0.18368590915302585, 0.2214222464867105, 0.24899297422253042, 0.32649402158128127, 0.3387455036288286, 0.35755363318199385, 0.2881085563166893, 0.25264194428964215, 0.4342310144710321, 0.47378844913112084, 0.39538072964861126, 0.4191662811901331, 0.08472488267570988, 0.079681960725416, 0.07102274024503241, 0.074591902062081, 0.10456593741157016, 0.0900167047290037, 0.10213822765524361, 0.12791873625433614, 0.10376586033478852, 0.22511774306869436, 0.2069521873991551, 0.23250314682754747, 0.2616192391948935, 0.21965772161811292, 0.24971735000462003, 0.2189197200031644, 0.2009544118857649, 0.22171237497527263, 0.6065494774093629, 0.6107231310194818, 0.6008371528892986, 0.6085615530774218, 0.6063318778670428, 0.5897554684241706, 0.5941381685274607, 0.5988231977843355, 0.6041481965678586, 0.10786773362838453, 0.10234785527025614, 0.10297454014169738, 0.11177171745779124, 0.09798840779446016, 0.09948951485496782, 0.10783395246822947, 0.10598303932153319, 0.11762626184152869, 0.18628159551600532, 0.14980433728599984, 0.18145412815360284, 0.18103403899003023, 0.16295113435302178, 0.159836010633031, 0.15430164437198768, 0.24846404474076544, 0.15512665171048579, 0.3839675627492284, 0.3598894888646488, 0.35091994449034214, 0.39386504364160524, 0.3633733270735233, 0.4047449989543459, 0.44028580649603566, 0.44945870674326993, 0.405717843462149, 0.2830434437163406, 0.2644380923499967, 0.2939836303835467, 0.27573684260681697, 0.2457482561933364, 0.2822598839346857, 0.31395321392923226, 0.27148002523634085, 0.3181856469081581, 0.1779036402953187, 0.17759551266662843, 0.21661223260733808, 0.18336067541908452, 0.18366592243898183, 0.19268323483885363, 0.18229321078063465, 0.18830195415921158, 0.1994530498014655, 0.2006785411350911, 0.21216636133302036, 0.2750631783363088, 0.19323699736910038, 0.3474991370462912, 0.4454503298876199, 0.2085457610457977, 0.32325205032000837, 0.36956146482304697, 0.6921952762536157, 0.7462603889427523, 0.7238187113205716, 0.5444020986703161, 0.6642193402175847, 0.6165137226107464, 0.746013406471252, 0.6598554587829778, 0.7200555158298129, 0.5844447907484085, 0.6141001938009852, 0.19583216976417783, 0.2026536058753715, 0.1919718870256636, 0.5819931223477065, 0.20287679130908143, 0.20098091763370618, 0.20854872833505156, 0.17974805549447337, 0.18138958277545825, 0.17494480639477406, 0.20071196126785928, 0.17479712502488653, 0.18081507814595144, 0.18061893406634122, 0.18511687131415655, 0.18570686232072753, 0.07181658101066168, 0.08290485814011805, 0.0728014295996442, 0.07732970758121593, 0.07699963030151791, 0.08422641051386803, 0.0823876989646598, 0.07559500852259005, 0.07533980241607463]}, "mutation_prompt": null}
{"id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.38529080328008536, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "babc37b1-8c55-46a8-bad7-bcc19383e971", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "987b3eed-3dfc-4ee3-9db5-a5cc10e9b93d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "316d13f3-8be5-4d5f-b7c5-4049710913c0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "2663373b-c7ac-4b15-8e02-3ac49fb312a1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "981b1cd1-1050-4012-9909-a5084c1f6608", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "5957277d-731c-40c1-b2bd-854cd46ec529", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "3d5c96ff-3a7e-4b34-a0b1-4be5ab8f6819", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "574dec76-aaee-4bf2-898f-71ae844e6c42", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "eb6b0569-268e-4551-9b15-5a4bc1e3acb0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "eb3ec558-6e7a-4a32-a7ba-80b9b8d5df3d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "b068bca7-51af-4032-a63b-947ab28cc550", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.successful_f = []  # Track successful F\n        self.successful_cr = []  # Track successful CR\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Use average of successful F and CR for adaptation if available\n            if self.successful_f:\n                self.f *= np.mean(self.successful_f)\n            if self.successful_cr:\n                self.cr = np.mean(self.successful_cr)\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_f.append(self.f)  # Store successful F\n                    self.successful_cr.append(self.cr)  # Store successful CR\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce an adaptive learning strategy using past successful parameters to enhance search efficiency and exploitation.", "configspace": "", "generation": 39, "fitness": 0.29746408825804066, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.6378864954053984, 0.456262195671827, 0.8682640446708652, 0.8266261328124259, 0.599488196322149, 0.6872256625565485, 0.862655739926319, 0.8714533716349998, 0.6467500303525289, 0.37160716436405694, 0.06904166357570152, 0.7815273222465609, 0.389545874690296, 0.0818392104500939, 9.999999999998899e-05, 0.32502004162526077, 0.07468279417411194, 0.04644022448705343, 0.40828960336646425, 0.13307612316713024, 0.15602874191357752, 0.1429569078301236, 0.17663513421965205, 0.16301148380185293, 0.31635240221867333, 0.17880045748485007, 0.15490420758642032, 0.13143777491777853, 0.12813162853765747, 0.13077060881822522, 0.1067904161955825, 0.13821669107722334, 0.2797449830483284, 0.15001344969637376, 0.2300482330539556, 0.12322220260449868, 0.26443529689146195, 0.35052696985877574, 0.18061453014777362, 0.8779573296507773, 0.9138444829198091, 0.6858371412679192, 0.15525913524613622, 0.7838880100251557, 0.5265959111004435, 0.18465863983782738, 0.28942687905878695, 0.08771968406337094, 0.19965330145562077, 0.12071408528660033, 0.236522780164645, 0.15294106065331892, 0.18732124064988798, 0.2806417291918105, 0.877068576301471, 0.8860596552581828, 0.8390225773314004, 0.8718840325267094, 0.8898561697226677, 0.8918386738790459, 0.3515557163999661, 0.392489645032123, 0.8605538158539238, 0.5906381290286915, 0.13295319864353128, 0.12593812271588722, 0.15170541201090637, 0.12833900103824214, 0.33042754814046627, 0.21632669737467847, 0.1684486242142973, 0.184738132055419, 0.12671742176574696, 0.2220716793312385, 0.1559872431262338, 0.15565619936094222, 0.1335724945302481, 0.18573981853912047, 0.13025954418459895, 0.13902577041018216, 0.13164966955849244, 0.16104360355602587, 0.09424866206202187, 9.999999999998899e-05, 0.30521793036124345, 0.29351061277544566, 0.06682340456864999, 0.014528538488269072, 0.16000850804981492, 0.2550457712721331, 0.47490345870302186, 0.3425702645547448, 0.566295344549155, 0.15364606977359851, 0.2279541323816584, 0.39019479568385096, 0.18860168055960425, 0.1311245977867791, 0.15214670632947713, 0.126312598154114, 0.09730373660600089, 0.23637347610194304, 0.08013954654430744, 0.19579406751255557, 0.14527978556573307, 0.10164463293350001, 0.19217416523233366, 0.20395554365618318, 0.1442630076260879, 0.38322674936045387, 0.27132077212887284, 0.19470443207850086, 0.3044239322601574, 0.15460901390007875, 0.09647568915847338, 0.36971210544502, 0.3820801208449448, 0.5722558001166411, 0.4642842582248976, 0.6111548448411501, 0.48653889101741, 0.4869828591604062, 0.36505882706401116, 0.823149398259621, 0.8059054165385414, 0.47708309607270505, 0.15093400365962029, 0.10821025243812232, 0.14989570459217305, 0.14008133324271332, 0.1439536065573026, 0.15069249740065116, 0.14275433078251076, 0.3595414901573438, 0.09927820684869149, 0.17080929918720555, 0.1943931266590202, 0.20424438413827328, 0.17115911473968648, 0.2953571879811264, 0.248574502747269, 0.23670355465005255, 0.2321860355789772, 0.19953617559243253, 0.3907285996546058, 0.43249416963640286, 0.4679368030641313, 0.569135764576103, 0.4809335202482261, 0.3471994286196932, 0.40877891181491033, 0.5040060556652772, 0.3947846630483143, 0.34040928523739566, 0.4334020486233541, 0.30993090465106676, 0.3065185127609181, 0.38229853959685245, 0.36966639434514814, 0.373447887745881, 0.20662774498955527, 0.3127032701134421, 0.21714127185862164, 0.1949194371949492, 0.19419169375831546, 0.2338180646059348, 0.23531993125307427, 0.22257172687124904, 0.21600339783320177, 0.2369025412628093, 0.20792172144348664, 0.20298200601202, 0.20817465355163167, 0.20713286761465022, 0.669907712586246, 0.20533903470385628, 0.19516627904499173, 0.22331997813477478, 0.21885651090860525, 0.590868988901315, 0.6098068367373677, 0.19065666555119665, 0.7307542324399761, 0.8080020267182744, 0.19473358972439292, 0.41756053742985044, 0.18188540477838866, 0.19345251367649852, 0.17992275182047557, 0.1677527962162252, 0.20641395803545004, 0.21256637413556267, 0.3334977614170356, 0.20529646125992596, 0.16415986264095372, 0.14724885815113198, 0.21030483954836787, 0.20681533895481197, 0.18964263663826098, 0.2056651391239307, 0.17805342079063102, 0.17151549125956012, 0.16671238794741639, 0.18747449365853686, 0.1878607066885204, 0.17745505529397088, 0.19499603347890948, 0.08319731104709793, 0.08009102267723978, 0.08002175488290653, 0.08855901250621379, 0.09314930652640452, 0.09157449963734055, 0.087969674227105, 0.08357046116931088, 0.08995887989412077]}, "mutation_prompt": null}
{"id": "a11550c8-d9b0-494e-b23a-1f23a1f307a4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "164c8f31-dd23-4a78-b3ad-9dc3f2dfe0d3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "621633b3-ac7d-42ed-a0fc-0c5b6c1b81a0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation_scale = 0.1 * (1 - diversity) * (1 - progress_ratio)\n                    perturbation = np.random.normal(0, perturbation_scale, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance local exploitation by introducing a dynamic Gaussian perturbation scale based on progress and diversity.", "configspace": "", "generation": 42, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {}, "mutation_prompt": null}
{"id": "ef126beb-9228-4097-854d-e15e6bea16fe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            fitness_variance = np.var(fitness)\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio) * (1 + 0.1 * fitness_variance)\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive learning rates for mutation factor and crossover rate based on population fitness variance.", "configspace": "", "generation": 43, "fitness": 0.12492167507787569, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.20.", "error": "", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.23585040136985214, 0.1337398630945671, 0.17234594887207677, 0.29541972837573116, 0.2476673315917841, 0.25926227243920363, 0.21220186337273406, 0.17869064306422755, 0.20449749857010868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02856832485030736, 0.040036127922855824, 0.04256964870280322, 0.03585928936157545, 0.02964372811778071, 0.05845462318515815, 0.04165982883343822, 0.07445270170421447, 0.047956810937450634, 0.017336894968192795, 0.0031328492251283535, 0.020992868808870857, 0.054196811481579066, 0.013733542988828451, 0.04735668244621216, 0.05590947731591278, 0.013011955134816011, 0.045103245004613046, 0.993656355559458, 0.9827525227363035, 0.9896688491858799, 0.9884352372269859, 0.9927915793902491, 0.9941099318286302, 0.9951654756436832, 0.9935258279467165, 0.9933064063063762, 0.07906517911124067, 0.04657372960051287, 0.0005166685146310579, 0.026022429570206618, 0.04496360758385198, 0.025711011820522822, 9.999999999998899e-05, 0.032108109859016465, 9.999999999998899e-05, 0.1917558006131369, 0.16534315635175367, 0.12874651546071747, 0.15916727005746711, 0.09886130764288115, 0.11709962640986638, 0.06694942818933103, 0.08807086050279644, 0.041889419724350785, 0.06707907250788703, 0.040414710473663074, 9.999999999998899e-05, 0.015636607049144713, 0.06279915737707287, 0.06729447994821036, 0.06863497505247218, 0.04255510874645552, 9.999999999998899e-05, 0.04076882306700813, 0.037185549479339386, 0.049494788149249125, 9.999999999998899e-05, 9.999999999998899e-05, 0.04103504746659159, 0.046826303255047774, 0.0019109416886158304, 0.07047417689656543, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035741536079780034, 0.019478263870386203, 9.999999999998899e-05, 9.999999999998899e-05, 0.00915597860674311, 9.999999999998899e-05, 0.03528581928594254, 0.04924083601977969, 0.030822325234991177, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03738513619320527, 0.004325488528709287, 0.006488531078111759, 9.999999999998899e-05, 0.03096405128767854, 0.02697096060624915, 9.999999999998899e-05, 0.02289974487262847, 0.011206856690629152, 0.2066823654554265, 0.24639095111434517, 0.21209068093272043, 0.17329653308040904, 0.27562346224860335, 0.19364929359736915, 0.35541832819699526, 0.1316804739658195, 0.23756894972926568, 0.04520339042069532, 0.04036117476523582, 0.039168267915359656, 0.0535223954713725, 0.022551042962020484, 0.07843006342203951, 0.027129400521172964, 0.042704746399738536, 0.0571363354757225, 0.12597175152759688, 0.12416600944219713, 0.12537854735105447, 0.13515776628472553, 0.13999995919693864, 0.11380159254093924, 0.17257855349312412, 0.0976556919760112, 0.13010573473879228, 0.146961885693483, 0.1687728616883467, 0.19027977733508994, 0.23075070395708985, 0.20606933944465722, 0.23279091331564727, 0.22049534605639187, 0.2089040905796038, 0.23004703496524392, 0.10308429295035071, 0.053972610677790356, 0.1090182358965156, 0.09080680142933073, 0.07394753219721517, 0.07405232312885834, 0.1155569189807285, 0.09999119524286526, 0.1087708497707055, 0.14959195953944293, 0.12786583200892998, 0.13345086981233123, 0.16347694237528154, 0.1251094262462128, 0.12841236851142745, 0.14003839480243618, 0.14785228840950204, 0.12653866504550149, 0.1263868929727502, 0.10818410510943943, 0.11766550345587024, 0.12784636557002416, 0.07146352907628573, 0.10655055803594538, 0.10011250884762923, 0.07930339625178362, 0.04722767641329195, 0.11447659660805654, 0.11301457183235453, 0.13441683563430162, 0.16919127291681013, 0.18478379175025983, 0.15008815551221233, 0.13526461897514674, 0.1211520777546592, 0.1772538881218374, 0.2907755741493153, 0.16322001639420447, 0.16136521944960536, 0.10310713727168164, 0.14306851565072942, 0.09684083038474778, 0.18949204996587554, 0.1961745965206303, 0.19009352271262614, 0.1762606352641065, 0.22349690368622355, 0.17006883765412018, 0.15434034111975492, 0.21125821283539392, 0.16005245053048167, 0.19478368958017322, 0.15024877264927328, 0.16029235783038098, 0.04419485428865377, 0.023952681307203405, 0.03836763028442236, 0.035512545240440674, 0.04703306179025746, 0.039092393544201465, 0.02960540667681999, 0.04827233645027773, 0.025913438375473552]}, "mutation_prompt": null}
{"id": "c938eef9-1f86-472c-9c99-4e48b8e27e23", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "46a54a00-c18e-4c57-a61c-89cae2fbd0d2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "8227235d-0e7c-4b50-b8d6-683e6edb9b44", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "a6d0f542-9ca0-4407-a648-861c4b1f9540", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget  # Track budget usage ratio\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)  # Dynamically adjust with progress\n\n            # Adapt population size based on budget usage\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Time-varying crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    # Hybrid local search enhancement: Gaussian perturbation\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)  # Initialization value adjustment\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate a time-varying search mechanism by dynamically adjusting the mutation factor and crossover rate for enhanced exploration and exploitation balance.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7476281285730656, 0.7802117342784185, 0.7367392418473243, 0.7896594743201584, 0.8075288857137801, 0.7928673955120148, 0.7502764442513943, 0.7611569661650479, 0.7753073533368995, 0.625877452456006, 0.6172708281430674, 0.6420017960541995, 0.6569417816388974, 0.6660529153390342, 0.7087057105331378, 0.6663001130256891, 0.6466544626691999, 0.6754706643440761, 0.21287978206189828, 0.12166039140505769, 0.3205142343119183, 0.3327294537713473, 0.12022714170252258, 0.12782253775102526, 0.2315690622895452, 0.3193774375098516, 0.1482151397040472, 0.12144459779703243, 0.2151694232880481, 0.10744080638872733, 0.12038711539134184, 0.10926717250519502, 0.11045573037769352, 0.11695005817899162, 0.25080893159339246, 0.13279353992292053, 0.8826242306781416, 0.9192572295202763, 0.9018962194055204, 0.8969492754633206, 0.9030704822089475, 0.9091134957468547, 0.8902107417224361, 0.9558254323464235, 0.9093093785017019, 0.4369349302201134, 0.5425929595659826, 0.46213668164274346, 0.5801080303601914, 0.5874858074534031, 0.5529939662199687, 0.5605297041547141, 0.41201631122290006, 0.4217413098864339, 0.730416005915134, 0.7401345743401447, 0.7137561807391226, 0.7492185780224856, 0.8047167920933558, 0.7811937251902514, 0.7785252999816605, 0.7658661894889718, 0.7049903003423191, 0.5143228085179139, 0.4542140128434098, 0.14606986531961264, 0.23063760741085837, 0.18655063853213294, 0.2719046747127998, 0.41514627177439156, 0.49315203830112575, 0.17163997608933568, 0.30368025822230515, 0.031634506309067056, 0.11269426789734949, 0.42086288445016806, 0.19261671480181697, 0.5860203856671891, 0.43050309079062143, 0.150218355400482, 0.2020364722200153, 0.49847813861341206, 0.5494902164590753, 0.3603032911520808, 0.5091018416644869, 0.5328553117229277, 0.273079440400826, 0.5146903501053343, 0.5305926070050546, 0.4439475155163435, 0.5979091560544333, 0.5574878515157491, 0.6045335157117464, 0.4241186022909321, 0.5140617901461604, 0.6654021432536976, 0.6074642329326573, 0.6448780995880146, 0.6228492715181702, 0.08892735702102583, 0.09727634536646934, 0.1300725558624376, 0.17177898599651453, 0.08895159720891754, 0.21545113350356482, 0.12120097712887457, 0.15395484234451884, 0.14873995364809867, 0.35256205837022925, 0.3616504786536472, 0.36769958648875045, 0.42898373996481143, 0.355897127572396, 0.29682628490302354, 0.3466189237442865, 0.380119592596713, 0.3122124827666396, 0.6893323693397132, 0.700523574218464, 0.7406057749117787, 0.6857895798914944, 0.7259115543924096, 0.6867199939579329, 0.7382777466390145, 0.726359796279268, 0.5928939540830055, 0.10926390376987527, 0.10256111839054427, 0.10301831432536834, 0.10545091677737961, 0.09723607170410686, 0.12177202641249185, 0.10081785961351364, 0.11122980948374883, 0.10250923371036913, 0.1415125401398316, 0.1690443426898035, 0.2012555885112639, 0.1964064143229607, 0.14144605692034706, 0.22982852747088955, 0.14972321667092858, 0.1794640876068403, 0.18169915627690603, 0.4039369284324156, 0.37243930194522756, 0.425252758537216, 0.400786632303888, 0.478574208816393, 0.44537009463744703, 0.41695371265849446, 0.465810829631093, 0.485962963370576, 0.2760333423854936, 0.336590232964055, 0.29924224065528693, 0.3012281521643242, 0.35414893012884885, 0.2893023744157769, 0.3325120948382886, 0.352294025210393, 0.3572754014627867, 0.19296288361056013, 0.19897949420263716, 0.18605381741937577, 0.18488976916499, 0.1884894772912289, 0.18750807991983842, 0.19252366638893714, 0.19637832330418215, 0.19677336609431983, 0.29486373994998694, 0.20295796574296732, 0.3237463588295567, 0.44246707368191474, 0.2147718280886477, 0.20736664443657404, 0.19693204954894172, 0.18552520958800955, 0.1945628196214093, 0.7916129020293526, 0.7308608908271064, 0.18794686520988457, 0.17162097580643654, 0.19133890677252408, 0.17558169475589802, 0.6645119065095932, 0.6616309052464568, 0.17710046032574078, 0.16639754217492408, 0.20416700841809965, 0.6299436896012361, 0.1960490505317095, 0.19366371344064415, 0.19290075207404234, 0.7589016139598115, 0.20899679888164946, 0.2079394824129076, 0.18541199563854505, 0.1897071278142829, 0.17375671551603777, 0.20408472096902075, 0.19467794487489887, 0.182552080550214, 0.17316821294788065, 0.19325222967595268, 0.17358791770201842, 0.07514436220748122, 0.0733238475984399, 0.07406601203657304, 0.07363327483947668, 0.09501028387062993, 0.07787664151813567, 0.06623721884325062, 0.07615611079687645, 0.0738313675302752]}, "mutation_prompt": null}
{"id": "22ed7901-27c8-4615-a930-67261689c774", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 48, "fitness": 0.4023885534982379, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.24.", "error": "", "parent_id": "ae1e29be-dde5-4d47-bfa5-e46121f21759", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "db983258-8730-4c43-a11a-847643a25207", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n    \n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n            # Introduce dynamic elitism by replacing a portion of the population\n            num_elites = int(self.population_size * 0.1)\n            elite_indices = np.argsort(fitness)[:num_elites]\n            for index in elite_indices:\n                if self.eval_count >= self.budget:\n                    break\n                random_idx = np.random.randint(0, self.population_size)\n                self.population[random_idx] = self.population[index]\n                fitness[random_idx] = fitness[index]\n                self.eval_count += 1\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate dynamic elitism to enhance convergence and maintain diversity by periodically replacing a portion of the population with the best solutions.", "configspace": "", "generation": 49, "fitness": 0.30752604626132163, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.8785593476404604, 0.8260425411718378, 0.8633724788433725, 0.8487684943509621, 0.8672192236882221, 0.8548770256945801, 0.8640075321509639, 0.8609717261358653, 0.8605459564587186, 0.6297737281316942, 0.7732038922827484, 0.7437007531493063, 0.0, 0.7439937271073376, 0.796628829025913, 0.39755410916984224, 0.7898233158000074, 0.7414076992023733, 0.14193575061138908, 0.10932638126664385, 0.0941032446070249, 0.09994785170705744, 0.11145119361484956, 0.13103951202194564, 0.11362572612719446, 0.13632496645567593, 0.07254105123610732, 0.11953793859232043, 0.13675404460742335, 0.10822885981309538, 0.07376487760685246, 0.12067245464629417, 0.05829689623291212, 0.06278101496446165, 0.1123728735534989, 0.06668806786492021, 0.9325275613963484, 0.9450624842815478, 0.9688411257699798, 0.9355400698315532, 0.960385998288875, 0.9454929367677076, 0.91866544458758, 0.9627579557421317, 0.9820039167209669, 0.32877787236758627, 0.11302851861651142, 0.49414413591643314, 0.2651519775961574, 0.7412832175875046, 0.5114890960920266, 0.4122137037062761, 0.12484411257034844, 0.6799259806801099, 0.37796377881226595, 0.22687255758364078, 0.38261478446591035, 0.36448790197006264, 0.18926096017359706, 0.21883196028832785, 0.8627422845080152, 0.23261948762082785, 0.23910405657655143, 0.12926933921043926, 0.12133251216148744, 0.7227873290239026, 0.23249245758233084, 0.12717248973152817, 0.10316283927447656, 0.1259909034781478, 0.20221987968442456, 0.3156906099688733, 0.19914451035666203, 0.22212594932007956, 0.009730786560883775, 0.32938475729578354, 0.2013438408776146, 0.6085637259919602, 0.4512349026286202, 0.36069881802226134, 0.29649803252829166, 0.1993926175848475, 0.05773553677681398, 0.2487756161014012, 0.0998735389560601, 0.13404884199924583, 0.21918455896597744, 0.10497639416294258, 0.0, 0.12444283233248066, 0.7620336077810091, 0.2189415036088913, 0.24538008188119953, 0.47531713516477025, 0.010107436558126959, 0.12492262029860357, 0.0733674022453179, 0.7503714953175266, 0.11202958690149678, 0.3307147610346699, 0.08580320871729286, 0.08547514719731386, 0.11422089574975125, 0.07423870268763244, 0.2520475779574456, 0.19450648446923458, 0.1451297178126817, 0.10302207336148406, 0.22301172701893868, 0.09889858660725148, 0.34568685887839656, 0.2375192125246225, 0.4015307446747385, 0.29975074270562685, 0.346625688578167, 0.3391792216877547, 0.20301709738805684, 0.8152839605849811, 0.6446314182529926, 0.7868536611294124, 0.5924467921887016, 0.6411222106303553, 0.7308510120086906, 0.6447761364851149, 0.6475796914035717, 0.6127977975898364, 0.04903041869956326, 0.06552897713141248, 0.05981673571313928, 0.11100448677783536, 0.07933630465088914, 0.07037494941097977, 0.0759960950701668, 0.06777792581162101, 0.07301970627501209, 0.1790339802465527, 0.09740029795802041, 0.12216019799635358, 0.13238581479123002, 0.10844057434017362, 0.10789794917816686, 0.08799080449344876, 0.11663249766728256, 0.11638708443038248, 0.2708840872187358, 0.2725158899066662, 0.24333874364115404, 0.30505724942396073, 0.5234947820909852, 0.27915491302714646, 0.19390672268349285, 0.3098474509128568, 0.18307079909701063, 0.20017034715857007, 0.11401075780924608, 0.18815376974949583, 0.20798974026486672, 0.3243370022508474, 0.14929142889813352, 0.21318775945214585, 0.19241703002567834, 0.14895024576281723, 0.17122323358763392, 0.19788746957056214, 0.19854812235833053, 0.17823740733033644, 0.16807165440863958, 0.16014634082801626, 0.19201319294992747, 0.1802306782774391, 0.16532602720374456, 0.18863637500632513, 0.17912688166753155, 0.18614698166202948, 0.19367722099429607, 0.2178984490695144, 0.20600874677706438, 0.20648547068875045, 0.1899810931050756, 0.17071201571668393, 0.1454156503133225, 0.1297151892477173, 0.16760376919843134, 0.7449905356195227, 0.1988866293613899, 0.12924358722593554, 0.18482666778932189, 0.16738365627764162, 0.8914392271925682, 0.8725673765528079, 0.8230571597608568, 0.20394552663821364, 0.20739874560013805, 0.16209261088400184, 0.11506319570624601, 0.1649542689550091, 0.1970159178562484, 0.20411952699256708, 0.16795179080912404, 0.19718667322707795, 0.1725849318165712, 0.15098980560170772, 0.14795643278505266, 0.17147477346755746, 0.15007379744632, 0.18856353272057613, 0.1643161759198567, 0.059555293262551046, 0.06331323320651883, 0.05699592349912597, 0.06665134130618866, 0.06226479326768897, 0.05768667003572958, 0.06511746819661879, 0.03793735337636339, 0.10199329439904559]}, "mutation_prompt": null}
{"id": "8bba076d-525d-4923-8894-f5f2e150e598", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "8dfd4ef3-cace-4563-869f-1c27278ad848", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "4e2de565-e434-4424-898f-8d0bae88939b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "af6b5349-1c98-4f82-b22f-9356bfb91505", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "918a1c55-9a78-4a5e-884d-0155c5856953", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "eb366184-fb77-4d34-ac00-76fa94fe8556", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "5db8ff88-ae5a-4f84-9042-08cf3fd0afa8", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Fitness-dependent crossover rate\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) * (1 - (fitness[i] / self.best_fitness)) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Introduce fitness-dependent adaptive scaling and crossover rates to improve convergence speed and solution precision.", "configspace": "", "generation": 56, "fitness": 0.2754046164136557, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7678155959663444, 0.7612685093270378, 0.7665539780036188, 0.7512290338392013, 0.7604162077019332, 0.7711645020970938, 0.7769975878093079, 0.7817220832540905, 0.757699681412983, 0.6109870213684423, 0.5968170911971006, 0.6250476728720821, 0.5834216990384569, 0.5983961832005512, 0.5534506809930875, 0.5803064514294327, 0.6465356268406752, 0.5912797436855574, 0.5572143615845977, 0.5558283853986874, 0.5729975340541882, 0.5744144982464727, 0.5804370147797361, 0.5752002766240434, 0.5829002225119146, 0.574406229282451, 0.5164140182869628, 0.5238526911356416, 0.548193068301686, 0.5003769533889014, 0.5291790838789134, 0.5656670387919025, 0.5369079579344751, 0.5134243899175672, 0.5161113158362287, 0.5259057203701247, 0.9324483705921783, 0.9247735300446998, 0.9560571246357372, 0.9728020068522839, 0.9523707189809918, 0.9484570653694104, 0.9599032035058516, 0.9458688498122838, 0.9478222664263805, 0.20137422775581448, 0.15967275632611744, 0.15624911886922455, 0.13881875910286667, 0.14291563550742759, 0.19401703682608873, 0.2136870517428905, 0.25811925180818585, 0.20536773052541168, 0.17796601756833152, 0.13830913426119062, 0.18462578058713475, 0.2339415883409418, 0.2068389268773464, 0.1965926073831793, 0.20003011213063748, 0.19445520771066616, 0.20205081261993363, 0.1712099273986769, 0.1484052590893109, 0.1343491366099686, 0.16062251684955287, 0.19180075272754282, 0.18583621398508832, 0.15503497784557274, 0.16826974743430478, 0.1768753751285176, 0.11143514729107373, 0.11713775942361737, 0.1291155062492969, 0.125273862791498, 0.14954451056418094, 0.13366732129228354, 0.11911984831253353, 0.1176999953674922, 0.11999268080095349, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035715065763059495, 9.999999999998899e-05, 9.999999999998899e-05, 0.061569647919156534, 0.04819600595332518, 0.057088739670020594, 0.17980716434985256, 0.06120944349140445, 0.11052309688621698, 0.05169553115398062, 0.06945313242198159, 0.07340886104030031, 9.999999999998899e-05, 0.018761617983199863, 0.017464907737958724, 0.02233762161235464, 0.02591006872509971, 0.01507181532446722, 0.0004759564206134881, 9.999999999998899e-05, 9.999999999998899e-05, 0.06374082962222871, 0.05440810851720557, 0.07075458542567326, 0.13224240739575888, 0.13030380065504665, 0.15205185240897678, 0.1040790938838898, 0.09159251782919786, 0.09783587991966924, 0.4436491032399055, 0.4328263806861369, 0.4443275994799747, 0.42368128043374076, 0.44800961315313703, 0.42255484124176723, 0.4262493701311668, 0.42343558782897006, 0.4370926924515438, 0.0925423938787242, 0.09158813396728016, 0.08799330305044772, 0.07917386744426891, 0.07579067100491743, 0.08451908593072499, 0.09796981743901945, 0.09300789361796091, 0.10135565632418042, 0.15499356999067881, 0.14312963479380547, 0.1654936825505987, 0.1518186360648175, 0.15425773132949094, 0.1627053124270591, 0.2404973227653533, 0.18894738061271232, 0.17526559953662346, 0.24293832276233818, 0.28004325932368423, 0.2871213843826501, 0.2017345607418427, 0.2075449218074663, 0.23368911727563513, 0.289203499182177, 0.28179595400178203, 0.23804269867093286, 0.18704814572438466, 0.19630748512596086, 0.19139553992308678, 0.16131127393194478, 0.1435500295737665, 0.14128868520262805, 0.17297163710418795, 0.17798930183730177, 0.16938135098910823, 0.17952036977556796, 0.211673832454632, 0.17877226943330404, 0.22015301793867148, 0.19027496700974988, 0.20565472758643943, 0.2032358937562272, 0.18176048203141904, 0.20073256945311813, 0.2358508000569064, 0.22096590087409973, 0.2505675383383845, 0.3277472552148123, 0.22189287552298798, 0.20046752158772074, 0.23617934226424842, 0.3177798141006194, 0.20468799818956984, 0.20277579658741984, 0.25275911459603584, 0.2202379272726498, 0.6366171075777125, 0.18834443325991512, 0.6073916528661958, 0.20440895996872632, 0.15655113143833255, 0.26279254274892194, 0.3055604143577073, 0.1924921424217949, 0.19234810263310276, 0.2215602536911181, 0.17705797334250328, 0.25389793773063374, 0.1531601345545056, 0.20579251410392907, 0.2087524531713395, 0.18364137464806152, 0.18758049169893676, 0.18823147735286205, 0.18249878788760188, 0.18781771667945013, 0.20463360311021095, 0.1915664194043728, 0.178411228414329, 0.19502992594390545, 0.06676558561566404, 0.06578364849027296, 0.07626961709045177, 0.075565837797828, 0.07133382366205354, 0.0889906957359966, 0.0714141118593472, 0.09093656173566156, 0.06601184757891931]}, "mutation_prompt": null}
{"id": "38fe37f8-fedf-4462-9799-7f3a08769fff", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        # Adding a counter for stagnation\n        self.fitness_stagnation_threshold = 30\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n        # Track best fitness to determine stagnation\n        last_best_fitness = self.best_fitness\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n            # Introduce stochastic restart if stagnation is detected\n            if self.best_fitness == last_best_fitness:\n                if trials_without_improvement % self.fitness_stagnation_threshold == 0:\n                    self.population = np.random.uniform(\n                        self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n                    )\n                    fitness = np.apply_along_axis(func, 1, self.population)\n                    self.eval_count += self.population_size\n            else:\n                last_best_fitness = self.best_fitness\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce stochastic restarts based on fitness stagnation to enhance global exploration and escape local optima.", "configspace": "", "generation": 57, "fitness": 0.23433850829563668, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.5369437648537876, 0.6050085581073859, 0.7587613529195313, 0.6188661799161287, 0.4460950673466698, 0.3824068782557889, 0.5964567364763478, 0.4582293226893486, 0.42119662656191015, 0.28684905131030847, 0.6004178340578965, 0.06559752835615107, 0.13592032910980156, 0.10793174958204166, 0.20714121241443584, 0.1855625592589335, 0.43003830229558004, 0.5690109945271795, 0.0963343409289984, 0.09275517800548283, 0.10938461816006095, 0.091363486820495, 0.09591994645138968, 0.09514624786932169, 0.09467829533091954, 0.0947502778879622, 0.0814889525181981, 0.07998263885028778, 0.07887721690774874, 0.08694708948787921, 0.07861480396632892, 0.08751420228720141, 0.07884966576311758, 0.08851966412690704, 0.07419978968362362, 0.07795091469978888, 0.9609592712132133, 0.857920195534595, 0.9097034520548285, 0.9159002552413142, 0.9382981032899255, 0.83733667940094, 0.9054755784730659, 0.8863792749639668, 0.9098249762559245, 0.2661531816661191, 0.18611695265017114, 0.20772756190175612, 0.257915078157109, 0.21072685741200525, 0.23140992895040247, 0.19570340238362527, 0.15504561555863816, 0.1881367704205077, 0.2417315548914445, 0.2087888413815463, 0.35801072437664183, 0.2445711665325342, 0.3323296071255126, 0.7241334029688731, 0.2729824406799768, 0.30990520650100517, 0.2152725487882915, 0.15809453715550248, 0.3158504495718608, 0.09873373099586391, 0.16478363869537638, 0.121401323177323, 0.13254130523720564, 0.14964950039979397, 0.12714082713795027, 0.14403701875901354, 0.13275233244294737, 0.08064706388916332, 0.3273754734726311, 0.13795586201724763, 0.18581704118021958, 0.10268754305768057, 0.12347749285439824, 0.10572201928565517, 0.17346950482153867, 0.08754696240304416, 0.10147624547159007, 0.06703336281050798, 0.025145630063440727, 0.17097602222751307, 9.999999999998899e-05, 0.08483840057720304, 0.03467146981006464, 9.999999999998899e-05, 0.41621087963746184, 0.08611057354079676, 0.22484861524124167, 0.2700167590817766, 0.24438619835029107, 0.14015582916268088, 0.4152960803491873, 0.25522301046897544, 0.3749885666101671, 0.046701467634706395, 0.013682379347834783, 9.999999999998899e-05, 0.019081699236370375, 0.02843696510862903, 0.10635296120235194, 0.0050274863430415095, 0.1005177944191612, 0.15353878491307038, 0.10278322948050866, 0.10288842897728245, 0.10488355139902361, 0.2023244140094942, 0.07767703229135625, 0.16522184634609205, 0.08105163774010593, 0.14760245655417026, 0.19343133733113638, 0.3807214487777767, 0.42841816718684655, 0.5515367586367441, 0.45514364003936203, 0.44041494836542094, 0.42934731270105697, 0.4642836391413657, 0.37090047878849697, 0.31086776020146223, 0.0880941024857742, 0.08566516657344769, 0.07735399822290911, 0.07924421922583147, 0.07272475649512833, 0.09399440850330743, 0.07667170728581385, 0.08930074824402945, 0.07525626842320943, 0.14967663531436814, 0.14612879472414875, 0.14451873357610534, 0.14432932004430044, 0.13700085855291488, 0.17385992447832233, 0.14148270660847406, 0.1502611191046297, 0.16226412198671858, 0.21732590275198627, 0.234669802709763, 0.24625452803103687, 0.2583242449607491, 0.2541297230362276, 0.3080386899669214, 0.209818464100753, 0.2585207147333949, 0.2221474319230975, 0.1740371025802684, 0.1741217149896065, 0.21127388584364015, 0.18009696398763841, 0.1753838529183981, 0.1614089422288595, 0.18531480527408128, 0.21867146041598862, 0.22620430751144405, 0.23391512269876635, 0.1803527399843733, 0.18731414192355567, 0.19540821656053275, 0.19014061966045626, 0.21470121457390068, 0.19570057460086632, 0.18806672950353664, 0.18790158460464368, 0.1600539605709722, 0.18848389310943936, 0.17947318674466683, 0.17210871953502882, 0.17311331480239556, 0.17238205615124624, 0.175612761007912, 0.1831145154161702, 0.1719248078088369, 0.2096826459998523, 0.6701396970486838, 0.35745200946457234, 0.19573187758362431, 0.16961635408314246, 0.1847728375226737, 0.2265356711484836, 0.2701825825306162, 0.7042783660469616, 0.5479358004444206, 0.6317792606654248, 0.20476536263172807, 0.2788193764198881, 0.17010195525070082, 0.1884251909939978, 0.3038395346186952, 0.2224356609898005, 0.20807464202547576, 0.17532080243747072, 0.1810198540691199, 0.17657663304571036, 0.19287564055882345, 0.1795946368682737, 0.18667254507387765, 0.18716303250155097, 0.2138508095885514, 0.1948332869826943, 0.07023719045510912, 0.07063516937891823, 0.07302189577329887, 0.06745618664876163, 0.06705578101265164, 0.08321172645499808, 0.07324747783399033, 0.06384832919760952, 0.07422077874772604]}, "mutation_prompt": null}
{"id": "85011b2e-5b75-4748-b22b-28caaaa96752", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "6a1dc66d-5cdc-4610-b87b-940b4050094c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.success_hist = []  # Store history of successful improvements\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.success_hist.append(1)\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    self.success_hist.append(0)\n                    trials_without_improvement += 1\n\n                if len(self.success_hist) > 50:  # Adjust parameters based on recent success rate\n                    recent_success_rate = np.mean(self.success_hist[-50:])\n                    self.f_initial = 0.8 * recent_success_rate + 0.2 * (1 - recent_success_rate)\n                    self.cr_initial = 0.9 * recent_success_rate + 0.1 * (1 - recent_success_rate)\n                    if trials_without_improvement >= self.max_trials_without_improvement:\n                        perturbation = self.levy_flight()\n                        local_solution = self.best_solution + perturbation\n                        local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                        local_fitness = func(local_solution)\n                        self.eval_count += 1\n                        if local_fitness < self.best_fitness:\n                            self.best_solution = local_solution\n                            self.best_fitness = local_fitness\n                        trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate dynamic parameter adaptation using historical success rates to enhance convergence efficiency and robustness.", "configspace": "", "generation": 59, "fitness": 0.3370819751673529, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.8400790415181802, 0.8386953194050515, 0.8398709740116805, 0.8273884259053268, 0.8333384206126978, 0.8281965993351046, 0.8417388099478267, 0.8283601780691213, 0.8278794553148041, 0.7249476860409165, 0.7011810947828667, 0.7136494203883885, 0.7085280400084137, 0.7314438866755997, 0.713894875093458, 0.7184945247745826, 0.7430389661239258, 0.7306896798244211, 0.5450654714144252, 0.5930950873440259, 0.17211933390562695, 0.586607249624542, 0.6327016496953881, 0.5685114761432803, 0.5755984364075618, 0.6044431756928504, 0.6146521478152899, 0.16223723119664302, 0.1689195754158742, 0.16537468683210022, 0.5772748182697555, 0.5808007077201309, 0.5498730011626036, 0.5853626680596545, 0.5401354735183606, 0.5976842981849046, 0.9555675448278768, 0.9780081136837789, 0.8908655158238583, 0.9695764586357781, 0.9556944581802824, 0.9506090354670593, 0.9648859983639164, 0.9226292389767013, 0.9299027481760036, 0.4160046974521525, 0.3972115874910318, 0.4001409733861405, 0.3562158150397038, 0.3594031864491142, 0.3669866839972973, 0.2800885685256721, 0.3122493838783752, 0.29179283571490455, 0.5984307799249293, 0.20175648592119155, 0.2259358732706812, 0.7331604863195234, 0.43048279824409175, 0.43191082613860377, 0.5184189438920882, 0.5639487182263128, 0.5731066887318113, 0.15753731047503994, 0.162189188155633, 0.17333184250365485, 0.22196044793754743, 0.25509947939774325, 0.25904194903909805, 0.1928054906148785, 0.17048101425338247, 0.20728367431596273, 0.14503728926446824, 0.18512238704733897, 0.1610596181373798, 0.15013578462742028, 0.15978116247928775, 0.1487174466041481, 0.16236837446543195, 0.15379156620098988, 0.17928070565436105, 0.01997499169373773, 0.009129764448406186, 9.999999999998899e-05, 0.012463590731507268, 0.0028143304098330324, 0.016985865404600564, 0.012038388148271184, 0.00020131480590879214, 0.058478402173229416, 0.09854670455087, 0.06504561213136728, 0.13613403837122495, 0.035291023026034596, 0.06294577103146004, 0.09305685963484045, 0.07139368637348598, 0.12672634759606682, 0.07479678877308238, 0.04691201896124653, 0.04952900959872586, 0.05360689508145444, 0.048503650337153204, 0.08970903498945826, 0.03708202488690426, 0.05296898322819066, 0.06412250081163351, 0.07776857594173647, 0.1243953736556197, 0.10864103620384935, 0.11696727158186171, 0.21152870532933754, 0.16326291614217792, 0.19494062945825497, 0.14741273197551197, 0.1299503914497283, 0.13837413338303028, 0.539578432511802, 0.5073218908881267, 0.5286634229604692, 0.5260739507884452, 0.5269184492002291, 0.5230930552872486, 0.492594222601328, 0.5371612334211803, 0.5256610232120498, 0.13284673016002913, 0.11000491208968, 0.11760065234696271, 0.09913345789936101, 0.11157319516955744, 0.1234559438652586, 0.11908748521847101, 0.10562441928141086, 0.13383117890033303, 0.16095234649467782, 0.1514707537968275, 0.1554624228010949, 0.15094389257777896, 0.17399209546349426, 0.1501544132345205, 0.16137241599099794, 0.15680924967090937, 0.14445972680563302, 0.3827768425251643, 0.4584177071059977, 0.37572017935282687, 0.3312346930577883, 0.3986542297640834, 0.39774611929750636, 0.469305950207738, 0.5357817509215845, 0.37418313929908686, 0.20094705801664592, 0.2444049974037401, 0.2625403389469211, 0.22450557948520433, 0.2528764351105939, 0.2395759446565453, 0.2947485978843012, 0.2763332619713187, 0.3229983169117506, 0.20651703741549432, 0.21352779343657624, 0.19731609212140655, 0.208214850935717, 0.20662709626999576, 0.19804402310459668, 0.19885175171799796, 0.21376412377543452, 0.23251925341842583, 0.3917594377663035, 0.4898863599376304, 0.4860249210043508, 0.2218303966027937, 0.5894058541325793, 0.5099164017558869, 0.5884510179067703, 0.23717858004033388, 0.5931046838870955, 0.4462045383757709, 0.3364284628543843, 0.6389581895578647, 0.6684280211460099, 0.7015541212569936, 0.757629963205297, 0.36412529696601104, 0.16725734057696096, 0.7044130947844977, 0.21313250042429177, 0.16589162856324524, 0.18942643364965228, 0.19618888327552464, 0.2168329040757241, 0.16110269992348636, 0.14949652247744438, 0.20375753695194643, 0.19450115429794423, 0.19197265939909303, 0.17881561952616498, 0.17659962587207356, 0.1816919906999418, 0.1774503630401414, 0.1926485262610792, 0.1708873978183445, 0.17459018976882357, 0.18116176604869216, 0.08474342824047931, 0.07155623059574878, 0.08214429242493737, 0.08208146467005206, 0.08298215540079867, 0.07778902504889595, 0.07668839822295104, 0.08834002219926973, 0.08702197429379066]}, "mutation_prompt": null}
{"id": "dfab61b4-3411-477f-8a7b-d3757766acd1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            convergence_speed = np.std(fitness) / self.best_fitness  # New metric\n            dynamic_factor = max(0.5, min(1.5, 1 / (1 + convergence_speed)))  # New scaling\n\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio) * dynamic_factor\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) * dynamic_factor + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate dynamic scaling of mutation factor and crossover rate based on convergence speed to enhance adaptability.", "configspace": "", "generation": 60, "fitness": 0.35776954591747984, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7896891576022618, 0.81217885681794, 0.8043958603832869, 0.7311804680256274, 0.7466019965299422, 0.802115826785088, 0.7676760727788695, 0.8148993541211011, 0.7306517773732597, 0.7547248291139598, 0.7541496296843769, 0.7382886344562019, 0.7357743532199614, 0.7249685623239951, 0.750536681097566, 0.7392084759249625, 0.7395311501346109, 0.7594251853675629, 0.29411559980299373, 0.29098955673963467, 0.12187771498144628, 0.5468329757341185, 0.5673509275190165, 0.5314687487913414, 0.4624044826201047, 0.5190138115993954, 0.4858381516105912, 0.11612453606849304, 0.1419744426260401, 0.10516210287472116, 0.15234822249208702, 0.2656143664187105, 0.3503715711051638, 0.21971375112222424, 0.39186431084382356, 0.3854105160355804, 0.94922385469608, 0.9596191088665522, 0.913985835329469, 0.8857660819372455, 0.8089821676264698, 0.9779725601265511, 0.8908177657420847, 0.900351546795611, 0.9163806610859552, 0.41922336980129427, 0.22269773393584524, 0.3375871847321933, 0.46599460109921687, 0.2515500435910213, 0.42274161601928795, 0.21532077067010547, 0.15404222870210194, 0.26304027090124815, 0.7678627001172894, 0.8223738921933221, 0.7215808093635157, 0.7867834812602765, 0.7961563901147517, 0.7301155977207989, 0.7615346616863397, 0.7365420877099386, 0.7863881005261772, 0.2158687489090133, 0.15417432916547402, 0.12874102487509886, 0.3993084625004407, 0.1478613901552972, 0.16123671228548642, 0.17420660516039843, 0.19886271178673998, 0.1440806491941894, 0.16211050895137158, 0.13539862090031807, 0.15828824392774277, 0.1432466535558793, 0.17101550869924953, 0.1646331373164741, 0.1653349296857286, 0.15404255247779186, 0.22053313939731456, 0.07867346583286339, 0.1647158420012318, 0.10255620615130079, 0.15501945359356273, 0.08194860530024961, 0.1207518579595036, 0.05835552115733733, 0.0829402974846315, 0.09886997356631821, 0.25282120246684914, 0.131064696286332, 0.15055933093813123, 0.17727112314207227, 0.08080238845169019, 0.1789845236812363, 0.31762839251281605, 0.23018754761855365, 0.1422333007548081, 0.10113073633527725, 0.07761306968289305, 0.10139118991395613, 0.10011839315027282, 0.15835218002380147, 0.06239862068250279, 0.1688655811692481, 0.13126247799915036, 0.13067056563795032, 0.22709097201108475, 0.18707002490467717, 0.1972676147560738, 0.27196600345099664, 0.28251881107671917, 0.288801352044722, 0.2001557548204772, 0.18000257160465094, 0.24069097702852582, 0.6581235599965912, 0.4824499953264897, 0.6756652575038383, 0.5513006069845837, 0.6957012016134598, 0.7085324554056922, 0.7248792548299143, 0.7045012370170697, 0.6559343743419264, 0.10407919488030726, 0.11068534560782972, 0.10461329395577645, 0.09586431073194268, 0.11357241473024915, 0.11154464645345374, 0.09307623677338417, 0.11497209583115586, 0.10281349964519737, 0.14059879530561015, 0.1320809185145586, 0.14461374649804437, 0.16102531382492835, 0.23385852834004905, 0.23085813378987063, 0.3008583014316749, 0.20553502357202746, 0.1986615662666783, 0.31876694743887346, 0.3531857394926694, 0.36685517452345073, 0.4138569032314222, 0.4416765901773113, 0.43706954233117346, 0.4604983869444771, 0.465524302376759, 0.4461629337972959, 0.3660494997689857, 0.32534126845942624, 0.22099981680300085, 0.3390036694607629, 0.27808070863725876, 0.3342738012010019, 0.32035213034132914, 0.35201626814586495, 0.364460938416726, 0.18385943573669428, 0.18224510115735715, 0.18827612056681142, 0.1875234100270291, 0.20089629484740967, 0.20154261002084395, 0.19991199885972422, 0.2009900130475556, 0.1865747945378734, 0.3700447816751756, 0.5770606474377467, 0.2138692325563214, 0.5120680175332575, 0.5555670714608225, 0.5312759616494442, 0.5329105688690723, 0.40465653590449535, 0.5785132238838999, 0.7535354927634073, 0.1754970419419316, 0.18290357058265283, 0.7084376938881193, 0.18083249220545028, 0.7487278272197873, 0.7051907846097731, 0.6748850305060822, 0.7671765125123412, 0.19850082387078005, 0.7549020204866721, 0.1955578820063616, 0.30334503420659076, 0.18868613629639353, 0.1972891905879619, 0.14740901527303762, 0.20746822012761634, 0.1888902875234627, 0.1868038747066707, 0.19533229322510215, 0.18249182619864746, 0.19598351385110002, 0.1800166767401442, 0.18008673820728094, 0.1982174333876796, 0.18054365271287187, 0.1975971884800347, 0.0717162344716813, 0.07185253996672636, 0.08533500636938263, 0.08686269991068984, 0.07243729739483973, 0.07537172150355875, 0.08162679558465458, 0.080995287950553, 0.08655399320070467]}, "mutation_prompt": null}
{"id": "d018cc0d-9df8-4276-b36c-ac1de2603b62", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "984268b2-72a8-41e5-aa5f-e31be6285a28", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "abe6492e-7471-44a7-addc-e69fc6083e18", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "4efd2d4f-55a5-484e-a33d-b35f907d0ad2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "f88f274c-d137-4077-9832-9c88f4c680fb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "eb83526b-3376-43b5-ad0d-817cc5cf77f0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "b0e53781-f660-4701-851e-7c3df008ca72", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "5ac0fda3-f040-4e4a-8b97-aa3002e8c550", "solution": "import numpy as np\n\nclass RefinedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - diversity * progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand() * diversity\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "RefinedAdaptiveDifferentialEvolution", "description": "Integrate adaptive population resizing with diversity-based crossover probability adjustment for better convergence.", "configspace": "", "generation": 68, "fitness": 0.3824873885581283, "feedback": "The algorithm RefinedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7220350439652301, 0.7507524659851204, 0.733333306115435, 0.789138311389534, 0.7872372195711645, 0.7770480763438719, 0.7684157491256577, 0.7710436819378657, 0.777599616020618, 0.6947846778055478, 0.694573796212141, 0.673381778220133, 0.6416163723044702, 0.6961183975586676, 0.66831839842976, 0.670039199072466, 0.698355511874384, 0.7395986432810807, 0.3038673438615691, 0.2663771820798444, 0.13307398233198764, 0.12578507904316372, 0.12071887710731477, 0.26909819544417013, 0.35928141620459375, 0.3964957382975425, 0.1320736957952635, 0.1292201244783877, 0.12112945678150877, 0.1061775320235423, 0.1300557454267166, 0.11627086679711374, 0.12394813865726828, 0.10459661505048556, 0.10793998986439346, 0.119255656262366, 0.8540387590786502, 0.8076882745194831, 0.9136984763383327, 0.9040706392284683, 0.9316322154184666, 0.9163288413260784, 0.7900982628204567, 0.8167895139325008, 0.9548130148889055, 0.40155946088358974, 0.5027242016980864, 0.3985006204259408, 0.4413693091437608, 0.5726541159403373, 0.5014685018171784, 0.5624966684585937, 0.38315641268558476, 0.4807826411311362, 0.7190632044678744, 0.7546593219098026, 0.7776887235979847, 0.7995916158387021, 0.7718490814987525, 0.7709042849494239, 0.6840339903389014, 0.7110044870810361, 0.7104659365480801, 0.2029912796657567, 0.1723466457887295, 0.4916718006936892, 0.3070696617870573, 0.1728389060279737, 0.20705448817156935, 0.3282431375271361, 0.3732564689089686, 0.5152793320998407, 0.11695612966048552, 0.13744759558705522, 0.623625653781287, 0.23634979156499258, 0.4022347035083498, 0.2109699691770881, 0.38136054675604625, 0.19869241127185944, 0.18229851691349186, 0.56305645436784, 0.5520196520438766, 0.571066882607883, 0.25700991069105705, 0.45950432600804914, 0.4484620673267232, 0.5991541216487491, 0.46638972592035055, 0.5445045976036282, 0.4404935792139656, 0.6482061111946822, 0.4303486141315589, 0.3878955718768994, 0.4060956671889534, 0.44665622150543627, 0.48840333252253154, 0.40832716052415396, 0.6375856186427289, 0.20194095624922825, 0.12298160722651197, 0.17965270782835907, 0.2288310478909118, 0.34400976467460165, 0.3126943884463532, 0.2131846783381517, 0.13615682684931285, 0.12002961953150026, 0.2776873545501033, 0.3585886657970091, 0.44497226678991764, 0.31133511920753076, 0.32055940994820586, 0.28456769786914315, 0.4286717754252424, 0.34059564292975886, 0.38814464378055247, 0.6930325075907735, 0.6890572840808523, 0.6690697505843772, 0.6506078017072237, 0.5652614524338564, 0.6932361196144021, 0.5079725939838912, 0.7346597958407248, 0.7475703953280184, 0.10564441171986305, 0.11691047714500913, 0.10988403608767972, 0.0855103728885167, 0.09292991364268377, 0.11875189593760282, 0.1127194691816441, 0.0958160633752484, 0.09907550046795421, 0.1384893345606062, 0.13605050833102617, 0.1419569844463765, 0.13707920771898097, 0.15455532630268065, 0.18457756818751336, 0.18287601246653862, 0.11955379087021378, 0.1454276230841517, 0.39199194165023277, 0.493286695788673, 0.4105543775598075, 0.4583062539654913, 0.4098637564545812, 0.45529723270783207, 0.4382781771886277, 0.3767388128462066, 0.4538848455337615, 0.38553189116045083, 0.3748250902286051, 0.29461887367055484, 0.33295757766237444, 0.33561744275601, 0.29312482164455045, 0.3992135447341921, 0.3249798258841645, 0.39507881383991095, 0.20634171828946068, 0.1961700756010799, 0.19152720948329138, 0.18177436309791384, 0.18689092735855628, 0.16627325061923515, 0.19024302756533884, 0.21203325002562112, 0.21658030822593333, 0.5168888884985121, 0.22747327453416843, 0.4253009259893753, 0.3549503110011606, 0.18961616312238794, 0.2928538276089335, 0.20504068600965852, 0.4834727307868195, 0.23110303594769632, 0.8180213923486793, 0.18906857778839836, 0.18954600143068678, 0.18422811911655124, 0.18367260076570702, 0.1768519586926357, 0.4900750786811403, 0.5735864333050379, 0.7763897533011784, 0.20114163825823506, 0.8041085864060775, 0.20126777993943235, 0.15860043764763154, 0.6002760807793446, 0.19739251906274968, 0.12466787351409658, 0.20823333912259856, 0.21019714477877838, 0.17671932982055383, 0.17769417385685515, 0.1774797005031742, 0.17174939882777684, 0.17964773975083403, 0.17358908507722937, 0.19127017650472522, 0.1726540032178131, 0.1932327944767459, 0.07412207169581364, 0.08850672815695215, 0.07334560759920716, 0.07270291202410573, 0.07427398866519253, 0.09162116598690317, 0.07480092284490492, 0.07512520296952985, 0.08209818108953437]}, "mutation_prompt": null}
{"id": "1d233eb3-856d-4413-9347-6024f4d07e7b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.3 * (1 - diversity) * progress_ratio)  # Adjusted mutation strategy\n\n            # Dynamic population resizing based on diversity\n            self.population_size = max(5, int(self.initial_population_size * (1.5 - diversity)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhance convergence by integrating dynamic population resizing with adaptive crossover and mutation strategies.", "configspace": "", "generation": 69, "fitness": 0.08801093514471642, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.10.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.192666258800817, 0.1641919402616715, 0.19106389254464762, 0.14403252248689424, 0.15506622815260818, 0.1732778680736763, 0.18391428846621616, 0.1507774178329624, 0.15269420386670174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09348884713069205, 0.029294598854833542, 0.02144969556556353, 0.03226786078484023, 0.027453252350935653, 0.026200090571982027, 0.036788094081314004, 0.040921101405984706, 0.026681968275400703, 0.02746722684868197, 0.029240534747398628, 0.026775668499544936, 0.02294795718197984, 0.011945648320084046, 0.02351052961551392, 0.017186076961127617, 0.017162606421781468, 0.08712586793524135, 0.660201018561495, 0.11140084094925529, 0.6249055865504507, 0.14334514072768267, 0.24712547797310636, 0.4800853881070689, 0.17001261199444706, 0.729469389351117, 0.41301635881499554, 0.06370898871169395, 0.020819732576565553, 0.05186751021149649, 0.13884868072837342, 0.05013347698724335, 0.055868971374669285, 0.07013364225310159, 0.05084754557154081, 0.06511498843580799, 0.10308566172102396, 0.09992094282803954, 0.07940735326471382, 0.07680607598718125, 0.10430380997606514, 0.10868246640803703, 0.05722553598479918, 0.09709838785210045, 0.07149452224396113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03707724739494589, 0.024157843690445047, 0.03888888013117231, 0.10217774378071987, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022505456444692484, 9.999999999998899e-05, 0.0075008096412438885, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03812044886948662, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10231091923360058, 0.03967523991019717, 0.06289686598098765, 0.004729863193836947, 9.999999999998899e-05, 0.023805443095909706, 0.10835450074036868, 0.04216971029504979, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.16859228138412896, 0.21401289142013524, 0.21515432005799984, 0.1763301237580157, 0.1664329084055296, 0.17835158293119513, 0.19629155264220022, 0.17664688898656733, 0.19863474462535635, 0.02872579460238267, 0.049563032413977415, 0.041269678033985624, 0.03331456021730317, 0.04182559061629132, 0.03788043118863116, 0.0017603881553086564, 0.043060162423516735, 0.03661539984549966, 0.12138406400252222, 0.1596735826419139, 0.12219416680818007, 0.10625766875070453, 0.17985593379853348, 0.10798713552628325, 0.11935890053647147, 0.12296726588515472, 0.08391220709655323, 0.1286315397469756, 0.16544737529404097, 0.1613932299901244, 0.13859452389685212, 0.17329360787067782, 0.15325565096496685, 0.14337049520261114, 0.17377774300845283, 0.1441033008099879, 0.07933991424512554, 0.12149774287220338, 0.09585251997710331, 0.16194635147862158, 0.07848288669595782, 0.07569862554418127, 0.08750765332126287, 0.0997711199450243, 0.11858252226534782, 0.16047212736846084, 0.13577357742874285, 0.13714520284076903, 0.15868252599104105, 0.1525355481003915, 0.15171225477215156, 0.16337958625447357, 0.1213590360557193, 0.16198237758121925, 0.14189272875653192, 9.999999999998899e-05, 0.11873081720867107, 0.07715011000989103, 0.12134646253317694, 0.16407147030434266, 0.08505371055376176, 0.0813231090397778, 0.074252569613516, 0.10803193524255661, 0.08589764599818539, 0.11591881853135932, 0.1444080057951933, 0.1549783075389678, 0.15094523200750576, 0.10881820781808471, 0.13783716463411855, 0.08043778293216419, 0.14382271393661117, 0.11965172177877503, 0.07365938799026062, 0.09131220292148134, 0.10826221668937597, 0.07109215691857684, 0.07635733842818937, 0.07298578151577018, 0.09444221698102429, 0.16965369393037177, 0.128372137474824, 0.15252056892289168, 0.1444795400274168, 0.17224149684423085, 0.139575312365934, 0.15005227056541548, 0.14206234267676332, 0.1621068163096907, 0.03836629128233071, 0.03872081126504401, 0.04842795825734192, 0.02930804197515735, 0.03438346249053925, 0.04634262779194909, 0.0767740189147531, 0.039822031587983475, 0.03319204283385058]}, "mutation_prompt": null}
{"id": "46e612d1-22a1-48d8-9d20-273e1a9cc437", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "ca737d56-11fc-4e49-85be-f382e229f2f5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, dim)\n        )\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight()\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive local search with Lévy flights to improve exploration and exploitation synergy.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7564891526030392, 0.7933506838304425, 0.7749986193848662, 0.7882218640431771, 0.7639614033717266, 0.7882224655590819, 0.7659524125006338, 0.7665553538465053, 0.758473282361158, 0.6233546827776928, 0.6423509388327937, 0.6558842466453956, 0.6670739671117736, 0.6559256807338474, 0.6829175598428245, 0.606826349396497, 0.6392731721741306, 0.6988191961994209, 0.2476085687568924, 0.34915034427039704, 0.1291140358351116, 0.2566034404763311, 0.30407809366455063, 0.2957444975329838, 0.3028880503848035, 0.1145156999010587, 0.2477642874426531, 0.31510569328458926, 0.11154104692140177, 0.10871685095944883, 0.10809290729785714, 0.1193811791764019, 0.12602054379144523, 0.11503459825827322, 0.2759211091776781, 0.11859316661210817, 0.8660235456769283, 0.8918022079601338, 0.9097034520548285, 0.9162550747181208, 0.9382981032899255, 0.9438468636428023, 0.9068548116559754, 0.8722203040191018, 0.9098249762559245, 0.4578955095229942, 0.45292778823201263, 0.47017084298114276, 0.5550960129662605, 0.6063604174035822, 0.5368186519100759, 0.46627523564357365, 0.5817607128773161, 0.5391781836493683, 0.6889312077118854, 0.7548075974289776, 0.7266353690444852, 0.7734914703486575, 0.7375387472120347, 0.7241334029688731, 0.754656670245405, 0.7561915644985533, 0.7469959801078494, 0.49892466359296805, 0.5305552077505249, 0.37775705110751456, 0.5341932736733226, 0.21989316806808568, 0.15024869340979352, 0.4670599551124939, 0.2195205664838924, 0.23764924410113686, 0.21382332940741866, 0.05202519827310048, 0.11531934331134797, 0.4362620607705109, 0.43744630012544916, 0.14651391580710604, 0.16076896854429945, 0.41410472134192344, 0.17165171880767616, 0.5497181587306604, 0.4080251070510639, 0.5072068471836456, 0.5068842423967189, 0.5549447555324615, 0.5757113954047579, 0.527323590197891, 0.4461311207755865, 0.5127456002284092, 0.6060524514295502, 0.4243867965933582, 0.6120879981249332, 0.6325084639681018, 0.5588302550907771, 0.5987918341677572, 0.6342554150336805, 0.5934690087135561, 0.6468543427781622, 0.24650382057621112, 0.17265482355927375, 0.09235752720471047, 0.29963317636816256, 0.24509951441305955, 0.17867982336746013, 0.22506765249929517, 0.1790174083881324, 0.18500761674432165, 0.3907182343401341, 0.34456392978926087, 0.2990359588991216, 0.38430315054641706, 0.41466996573559045, 0.382763220987975, 0.39146269973113557, 0.3623209143131394, 0.3605102126742753, 0.6875378293198483, 0.7272815533563297, 0.719508595671047, 0.7239854505417455, 0.7330056655174795, 0.7015977101348142, 0.7437918460455593, 0.6647549918324573, 0.7056242723940003, 0.09537004935418658, 0.0966613313164838, 0.10890645505873708, 0.09888329519625128, 0.11427299136747426, 0.09855945233937835, 0.10352227622680166, 0.08625519848675522, 0.08584136608483328, 0.17086039474261194, 0.14994284897990617, 0.14630310590449713, 0.24278817527438779, 0.17052915508149513, 0.20780703961932778, 0.13084547052126216, 0.1891527723774531, 0.1920495125651429, 0.41830632984114746, 0.4097941846771693, 0.4082209148778163, 0.36902498280943186, 0.46888234295214737, 0.3713474294929814, 0.46122785275120737, 0.4950528291441506, 0.41196174407641006, 0.3459324130205862, 0.3162004397529635, 0.3004533832873181, 0.35351272009685286, 0.35208671928158697, 0.29675143510947977, 0.32843181187131, 0.36948664920846463, 0.306069794138239, 0.23391512269876635, 0.18389158641056358, 0.1902861282788385, 0.18992771550053844, 0.1939546072321422, 0.18154210317906228, 0.18966196086601672, 0.18299801585353714, 0.1799529326188909, 0.362746201089878, 0.33215106307970377, 0.2873353213733344, 0.3353140703771934, 0.4128907604849824, 0.3036815220720771, 0.34732313789801184, 0.3773878953459393, 0.44669149974321765, 0.7587671201282263, 0.708662130597835, 0.1949061982689697, 0.660181319330605, 0.18873364592392305, 0.15422296576633265, 0.6924038576238015, 0.6472637399018089, 0.7042783660469616, 0.8037475339181579, 0.7188400739237153, 0.18551877383128734, 0.15892896270398382, 0.19380639644992237, 0.18901156385718265, 0.20781493011418017, 0.20815572690794748, 0.20807472587791076, 0.18040890566236745, 0.19021286705922968, 0.18098144689132112, 0.1767177111260766, 0.17528671322445266, 0.17234940049819902, 0.18148596234250913, 0.1990301958242633, 0.18908940104168304, 0.07961792859913097, 0.07107768719304364, 0.07951636652546334, 0.07279668434160436, 0.07791311441838589, 0.071342428363812, 0.06877498568771567, 0.0795171575551833, 0.08322188007686981]}, "mutation_prompt": null}
{"id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 72, "fitness": 0.4274129013302059, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.24.", "error": "", "parent_id": "22ed7901-27c8-4615-a930-67261689c774", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "5905e76b-4465-4fa0-b7f4-10ff0d5ff18a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "8ddb07da-db27-42c9-93bc-67aea6f82e29", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "54f2b700-acb5-489e-a13c-795efd9c3470", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def chaotic_crossover(self, dim):\n        \"\"\"Adaptive chaotic crossover strategy.\"\"\"\n        chaotic_sequence = np.sin(np.arange(dim) * 4.0 * np.pi / dim)\n        chaotic_sequence = (chaotic_sequence + 1) / 2\n        return chaotic_sequence < np.random.rand(dim)\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = self.chaotic_crossover(self.dim)  # Changed crossover strategy\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce adaptive crossover strategies with chaotic sequence-based perturbations to enhance exploration and exploitation balance.", "configspace": "", "generation": 75, "fitness": 0.1906933103633102, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.5933737231220638, 0.4775760072949191, 0.53930868282092, 0.5787075933046937, 0.5134471064301118, 0.5127936005709535, 0.5084165116650952, 0.5673873826110759, 0.5582789690262877, 0.07518064052797968, 0.08010317536668066, 0.1135005091793353, 0.057825336086513524, 0.1657202655977742, 0.07084232062471796, 0.046460216495020745, 0.09292292126676927, 0.14311250704910927, 0.43887883982163967, 0.16400932019534997, 0.2172895896262883, 0.2227203548893587, 0.1702092764809109, 0.2717311946255976, 0.1822117313830267, 0.1918765141695694, 0.17926231588618724, 0.16636137456371747, 0.23651993792050985, 0.17870016200389038, 0.21358339536721405, 0.1655117646286579, 0.1892811591116853, 0.21514798786736344, 0.23326477565981774, 0.1493529147475825, 0.9402256934274149, 0.9349138431327859, 0.9286914335609773, 0.9453413363783421, 0.9462333493954519, 0.9601037943543602, 0.9370183708727555, 0.9526674629111315, 0.9257042929179035, 0.15314894860726314, 0.14691764185223566, 0.1570896638462398, 0.173546558552356, 0.18525171344011404, 0.13171494735338052, 0.14550972427075126, 0.15283847358456637, 0.1795420066726542, 0.20280812620507993, 0.19527393038342367, 0.22131633837023623, 0.2260938571835922, 0.19403312388555582, 0.20540771045526673, 0.19433069551790028, 0.2305049385933563, 0.19587796288924408, 0.10986749537546259, 0.08321558212167257, 0.09007529413200299, 0.0724189763510833, 0.07480587147159568, 0.10105718096769634, 0.09059319689744438, 0.10181757023937521, 0.0947905597718085, 0.08963342675275965, 0.06292064773785622, 0.08117968593202318, 0.06979701329287802, 0.06986962250806261, 0.08947970555142148, 0.07646884493759265, 0.04769871151789162, 0.07713489955131791, 9.999999999998899e-05, 9.999999999998899e-05, 0.00028305222000890584, 9.999999999998899e-05, 0.00048623586932283747, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037437323205047335, 0.07261922244563135, 0.052708076033367246, 0.04717246174953904, 0.054735226084814737, 0.04449797972381653, 0.04228576206150447, 0.05088851503798286, 0.07390777559070161, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004766341920663386, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05060687270276154, 0.034767432543903354, 0.07362544182381137, 0.07069664190035707, 0.06472557665856293, 0.0557668029741919, 0.03660935155217904, 0.036725544688196665, 0.05382121166141529, 0.34527005894099594, 0.3329228154585444, 0.317345930962474, 0.33803401127728405, 0.33745832003977316, 0.375674590309124, 0.3184185971714142, 0.3251278164556044, 0.3459329690231018, 0.07856108113756877, 0.08661951658391354, 0.08365813915335008, 0.07285751427336584, 0.0732221575476446, 0.07237463790868837, 0.07356153918067687, 0.06803264585739566, 0.06899195748374531, 0.12506109535743104, 0.13245726203349462, 0.12907682923732589, 0.12926087608119874, 0.13662866124349016, 0.19161197569063682, 0.1481501564199429, 0.15539339769047333, 0.1489079833598218, 0.21964628595714408, 0.22907113794942768, 0.20783556795305091, 0.19200810675126612, 0.19106720944281164, 0.20448296902467844, 0.20062227113349929, 0.2251182231208415, 0.22007395125980522, 0.1466840705629705, 0.153879732835003, 0.15739046999130257, 0.13200188391123047, 0.14417123802233256, 0.1466163932243162, 0.13442292417878465, 0.15446293332697536, 0.1423708248730221, 0.18421923982871158, 0.18837348676362686, 0.19268658502669256, 0.18895558825161085, 0.18850258031982925, 0.19438256828399259, 0.18916825564743656, 0.18208000879987463, 0.18977456007401017, 0.16710431790511393, 0.18037223929635726, 0.192839163170473, 0.17373886517597892, 0.18800449561369803, 0.17337636125117317, 0.18394672820050906, 0.1802759048410768, 0.1827445091244998, 0.2109206374774124, 0.2520267945412856, 0.1641696067221461, 0.33565394422246086, 0.20565490281067766, 0.1693437978990252, 0.16738842482510297, 0.2391945793985537, 0.16258697781598674, 0.2224743138681693, 0.2364144125784423, 0.2090225969505063, 0.20132968995634015, 0.1657486375808166, 0.14589190465507929, 0.191730382994996, 0.20905664126957968, 0.18375002787899253, 0.1934084145817867, 0.18597021700852645, 0.18124939036252286, 0.2018040056978352, 0.17938885141842797, 0.17716440524085397, 0.19035529706125676, 0.1968533389100443, 0.19104091455381134, 0.06750944335881504, 0.06401265108020593, 0.0629388396547731, 0.06525417301119829, 0.07054293922971888, 0.0680204749769453, 0.06712054385919763, 0.06338023923890601, 0.07615499638113543]}, "mutation_prompt": null}
{"id": "d63dbf58-bd63-4cc6-a0c4-4c4035c09018", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "90814c4e-264f-4972-b98f-713c4263bd02", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "d6238b89-e1a0-4541-80a5-1be9419658bd", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "2217d975-4e1f-4ea5-b9f0-0673bfe46819", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "6652c827-928f-4a94-823c-973bdeebb696", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def chaotic_scaling_factor(self, progress_ratio):\n        chaotic_factor = np.sin(progress_ratio * np.pi)\n        return self.f_initial * chaotic_factor\n\n    def rejuvenate_population(self):\n        rejuvenated_indices = np.random.choice(self.population_size, size=self.dim, replace=False)\n        for i in rejuvenated_indices:\n            self.population[i] = self.init_population_with_chaos(1, self.dim)[0]\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.chaotic_scaling_factor(progress_ratio)  # Update using chaotic scaling\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n                    self.rejuvenate_population()\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce chaotic mutation factor scaling and population rejuvenation to enhance exploration and prevent premature convergence.", "configspace": "", "generation": 80, "fitness": 0.20254392377700928, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.5685649991726067, 0.5351924002176929, 0.5900783617604601, 0.5034663041328435, 0.5069220317913187, 0.49847019516088253, 0.5687548713198236, 0.5460771604554704, 0.5089538287466877, 0.44143094658628834, 0.4237609039843552, 0.36486046891756374, 0.371341551350834, 0.34517196339290945, 0.2973902185552081, 0.4610480477229968, 0.4667574470193434, 0.44552541878422103, 0.08617812181638329, 0.05101862406411872, 0.057663320607095225, 0.08489974762826025, 0.06017132178661355, 0.06661998980029948, 0.08909932419515787, 0.07288519791324599, 0.05465964811577595, 0.08886716337527412, 0.08636935202474594, 0.12225035923484906, 0.034446830718097954, 0.060167915095233004, 0.06326104429818336, 0.08235770536512466, 0.0639686845811046, 0.040745872442148556, 0.6064997338664782, 0.6125369384977286, 0.6628161578653418, 0.5711739799841882, 0.5966941369400898, 0.6683826720388956, 0.5726927470584118, 0.7435464972121788, 0.6789603618831335, 0.29664573712718856, 0.2603220561686297, 0.1730492031063583, 0.2861252785010593, 0.27646503446985493, 0.2860646291930241, 0.1978698615755854, 0.1627384296769815, 0.24087400894466937, 0.16824741838824198, 0.14154818166216443, 0.13156775776653973, 0.11775626123923044, 0.16623506685982248, 0.22581783002569633, 0.0948297644398366, 0.07596174159816094, 0.10336831756246778, 0.07769936205409034, 0.10435770815759993, 0.13588301900646838, 0.13693454618167233, 0.11164212160837872, 0.3382787339147768, 0.09636347491017982, 0.09633398461066811, 0.20890085610781106, 0.20844566732277814, 0.14468048557976876, 0.13262345681715237, 0.13311819493875132, 0.48648542346872403, 0.12183600646787107, 0.24503780320755086, 0.28825058127219294, 0.3356793319638899, 0.07033793920910048, 0.073571664164221, 0.2724847802524263, 0.04975316094731186, 0.07383264788071353, 9.999999999998899e-05, 0.043218750257486005, 0.01806140909742393, 0.03924876257277121, 0.11567622278670331, 0.2347522973392543, 0.207168734979997, 0.1348189539775242, 0.08200166539128928, 0.15111988323511072, 0.024877116093146467, 0.055622980678850076, 0.16797620617507436, 0.008953345774484811, 0.038856206609076294, 0.06392118725080798, 0.03694318005088737, 0.09213958345163897, 0.04112771838340068, 0.07822259897451056, 9.999999999998899e-05, 0.09477637621689139, 0.08857453811636129, 0.14344008811492126, 0.06766315334247797, 0.13629102218829248, 0.10555378697608542, 0.16245936239899328, 0.06972597922762958, 0.14044097920973275, 0.08242639570447519, 0.3638497440550603, 0.4901502526334036, 0.4257309892534553, 0.39273474340258463, 0.35461518822678983, 0.43251654517529914, 0.4357819303251177, 0.3530167411895211, 0.4345488366041268, 0.06574353908112718, 0.05263969629440146, 0.0725601032053621, 0.0732687644185962, 0.07225828661766986, 0.06727366654594935, 0.09468664739857069, 0.05048967455683162, 0.056051476891740504, 0.1633058256978085, 0.20806682264386045, 0.2291642135139088, 0.12996119708264398, 0.19940571817869324, 0.13984043641127697, 0.16915101224969697, 0.15806604482786102, 0.13475515915451686, 0.20593740824179818, 0.15664441723233846, 0.15418498711756168, 0.17064153155584594, 0.1795677371410187, 0.30897077744326384, 0.18536084133962571, 0.1432039504242293, 0.14589466735495793, 0.10499507148249432, 0.08687165719797962, 0.1178475626645048, 0.10433289795742517, 0.1027310051903525, 0.11039144898657394, 0.1198204033357202, 0.11019499908265185, 0.1366911231895509, 0.2868787038815639, 0.23080361822458606, 0.21702929234460666, 0.1926400451768968, 0.2174878603005732, 0.19183261582847977, 0.2764259872516144, 0.2868165491099035, 0.22663467634564138, 0.17702696883662372, 0.13005403275495797, 0.11081143950871519, 0.1629178934762211, 0.14988032248326943, 0.15143901788231218, 0.17292988522291164, 0.21927492723739783, 0.19207764116433967, 0.16219999566982446, 0.1548275098835793, 0.16552287171545144, 0.14502130980647798, 0.14139984990571197, 0.15122165265603194, 0.12463908820958458, 0.1790392674310548, 0.11253739090518389, 0.6713706894117196, 0.5423898168857464, 0.555666499305745, 0.12982437902024035, 0.13024565169922264, 0.1279857976810863, 0.13138347103599257, 0.13258315931989906, 0.1357386941381281, 0.16565128042902288, 0.17397716139251118, 0.18023687464933424, 0.1682130819079839, 0.16149646757064673, 0.18188964888001646, 0.17009944851449688, 0.1986483674563998, 0.2937353379246739, 0.08668040061796145, 0.06309077051975909, 0.06800902206009418, 0.05690302887518939, 0.04648949602844443, 0.07373350802734513, 0.0691517758700515, 0.06516653876842304, 0.07886443165201962]}, "mutation_prompt": null}
{"id": "3aaf7cfb-daab-4e19-9a44-2cfb1868c45f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "3bb0fc30-2852-43e4-8528-396082c06182", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "2f84ba5d-e366-4cd7-a4db-948cc85ec6bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "97d1512d-f8cd-4a3f-8cc8-8a9f6955959e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.elite_size = max(1, dim // 10)  # Introduce elitism\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        elite_indices = np.argsort(fitness)[:self.elite_size]  # Track elite solutions\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                if i < self.elite_size:\n                    continue\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce elitism and dynamic population resizing to enhance the balance between exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.3970891892593084, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7112540558814782, 0.7446919222631928, 0.7632085789274757, 0.7657297180491347, 0.7463941353517167, 0.7843234492441844, 0.7975650774138965, 0.771656149361772, 0.7308562869943507, 0.5922823995643606, 0.624169379772084, 0.6085728685402965, 0.6226154904261856, 0.6854544582494917, 0.6025846923616287, 0.6327463407608247, 0.58510197149712, 0.6139028841972005, 0.2301633451442574, 0.2731397296764557, 0.18116593812336867, 0.19016390226371216, 0.1277055074937018, 0.15281462176922067, 0.13780015302193405, 0.15712367572232344, 0.12837167541897632, 0.12916011594105326, 0.12545352872602122, 0.12733772548634825, 0.09586336797015371, 0.1202065872243131, 0.12952049239575025, 0.14313771595958702, 0.20565089372793688, 0.11148543538007505, 0.93268620968124, 0.9041101372800079, 0.9327335557682268, 0.8759563651856134, 0.8961051839681518, 0.8990506776593853, 0.8145145435204717, 0.9080593173565964, 0.9565873328981064, 0.5340674555814051, 0.49974016835968027, 0.5136743183896317, 0.504429553869103, 0.41732371468409823, 0.3829661229725274, 0.40709129768046637, 0.5401119211521148, 0.4006287911198255, 0.7060408697613485, 0.5919995213005742, 0.7764641322069257, 0.6867109588720823, 0.7349213033429544, 0.7185341929530218, 0.7632441056588332, 0.7796526318529313, 0.7028117091245238, 0.3830504588514606, 0.234331169585413, 0.5253035949588243, 0.33160707757581276, 0.3778219325544455, 0.2722639740993761, 0.32338187737581525, 0.1650697221463201, 0.4749566363612614, 0.5317236593718768, 0.5363785546010508, 0.5522013757266191, 0.5541402992561054, 0.5636550305137964, 0.649708640041623, 0.5143163540323437, 0.6041913561747747, 0.5891856399554488, 0.43777953777481615, 0.3836900005875755, 0.5268773944077659, 0.43550840263753676, 0.5620950373914605, 0.4168662154366908, 0.554541795904794, 0.5000871619616434, 0.5094983007867282, 0.5472065528159049, 0.6277399785022612, 0.554129369927123, 0.602903480832545, 0.509644652475145, 0.6876953293714236, 0.6477691361699508, 0.5580282732805721, 0.6657391722235166, 0.2126733189177158, 0.041174371806496635, 0.15383566615715705, 0.3490682356901046, 0.18328487283571304, 0.18487376371322972, 0.13522474816393515, 0.15359751432161706, 0.1177665338474535, 0.3234732246040475, 0.27150418834486034, 0.24653279101895986, 0.3275439434899857, 0.3768319272997782, 0.3397499075613527, 0.2928033977513901, 0.22886393132479865, 0.2581205250169095, 0.6385931580895108, 0.7030197968117029, 0.6350978207980678, 0.7132870484382715, 0.5952281690380301, 0.6910542685201024, 0.680016214912663, 0.709806489150413, 0.712884434768984, 0.11887164287357355, 0.09075435736898685, 0.0901725960421571, 0.09956473204179217, 0.10962625692979511, 0.10255519276512581, 0.10730209889247255, 0.08653748793815796, 0.10223756576454213, 0.15005413411125867, 0.1282497357849588, 0.13958136016056655, 0.1446084960626497, 0.148671727327499, 0.13768177668974457, 0.1995167331622193, 0.2007915093297028, 0.16982848248753435, 0.369621260233153, 0.3728462797054326, 0.3660125525830039, 0.4179536262802622, 0.4276333580550369, 0.3784003125887261, 0.4283775879484292, 0.39385942826394826, 0.3706830144442941, 0.3335822279825752, 0.3074185106461126, 0.3084904444348342, 0.3239229109122158, 0.3103029497922374, 0.2983848198999206, 0.32463288499891174, 0.3063165476796319, 0.332378501470874, 0.19498096705045143, 0.2213615123945195, 0.20294709598764293, 0.22128465326005464, 0.19821633336419975, 0.1931149965376051, 0.20033739698982034, 0.20829771088320026, 0.21797989586544186, 0.35667225977736183, 0.2979143542926337, 0.20494247158269185, 0.287673784110265, 0.38902930942727776, 0.2178632574482562, 0.23902676251649957, 0.3086370856583136, 0.21166574348023293, 0.19585895316286028, 0.1785852021922828, 0.1602415982205514, 0.1648131988498942, 0.16537653697035382, 0.16532215141848317, 0.1691452543687223, 0.16000110995942518, 0.6633650107017492, 0.8012432292672197, 0.7416507443863614, 0.7372715815509157, 0.7911386282271263, 0.09410586581675218, 0.7210426072805564, 0.7142994516582883, 0.817231202847312, 0.7610853592870056, 0.18182340034193245, 0.176788909943426, 0.1892032404665972, 0.18435030399654095, 0.18368058576966317, 0.19775436286592218, 0.2025696392090075, 0.17758073569762367, 0.18057964511043156, 0.0809151241896725, 0.07312754957238576, 0.0935181550451869, 0.0757297293717194, 0.07321043670066496, 0.07238599364476372, 0.07986102057226396, 0.08645557674476545, 0.07399631975888221]}, "mutation_prompt": null}
{"id": "8324bd88-217e-4d3b-89a1-79d24aa2af8a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "959fc206-9a8a-4d63-8226-0f0cb2dcfe12", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "693c8eb4-10e4-4d00-95a1-d625731b1d07", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "ff68cda3-c0a9-4ff8-be81-4b3d2bf28305", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "aecf0472-18fe-4922-a310-d9687793daae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "651618f4-844e-49c3-969c-ea6b97b67e02", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n        self.successful_mutations = []\n\n    def init_population_with_chaos(self, pop_size, dim):\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def update_mutation_factors(self):\n        if self.successful_mutations:\n            self.f_initial = np.mean(self.successful_mutations) + 0.1\n            self.successful_mutations = []\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.successful_mutations.append(self.f)\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.update_mutation_factors()\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce self-adaptive chaotic mutation factors and dynamic crossover rates based on success history to enhance convergence and diversity.", "configspace": "", "generation": 90, "fitness": 0.17902636401945418, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.24772999946691276, 0.3100488493125726, 0.2674461899965679, 0.23597290549039374, 0.3347344189109228, 0.2613067028044589, 0.26619220360845053, 0.317798995104035, 0.30464703861805664, 0.053481444360853114, 0.09450374950770346, 0.07572901425004475, 0.11933562253630303, 0.09648915659697299, 0.0896414640531884, 0.14100754003550142, 0.12365325580420905, 0.1280184099813514, 0.062062213080377626, 0.06209116838126971, 0.08062964119819283, 0.07436243976623336, 0.059821796394046056, 0.07277600040507626, 0.07867095723833517, 0.09332968008822895, 0.06314399372908774, 0.10709812329587565, 0.06542229231670194, 0.0729101457177469, 0.055463040570825406, 0.06240083313962186, 0.059574285482860256, 0.06673109071013295, 0.058863484105881825, 0.04716360974655687, 0.9222709351164704, 0.9280542687297492, 0.9071287360121661, 0.90306295364154, 0.8749784622587188, 0.8639953298194586, 0.9591165638039288, 0.15630408188096012, 0.8996232236168735, 0.15847228848050543, 0.12437159295307154, 0.19186549664488683, 0.12913061574484253, 0.11100316042789271, 0.12349982584029662, 0.1393561658851279, 0.1140885734225019, 0.12804665901681334, 0.20804320507056107, 0.20135700288879277, 0.22631307898343933, 0.1798117350408176, 0.2289965227515317, 0.2374595747485917, 0.23529869445668794, 0.19823370779519423, 0.2239150327875552, 0.05210686646522322, 0.07647706701691803, 0.06533068839866041, 0.08222081455307872, 0.06274550777295806, 0.07776917543235362, 0.11321267573756688, 0.05034920076062177, 0.07046028571298435, 0.1318296476850932, 0.153740931898803, 0.12867578517490952, 0.14571752838250418, 0.09939210971369916, 0.10410017289906404, 0.08339532148218509, 0.1664246963226116, 0.11242890820660378, 0.06956926690873055, 0.02222839545479205, 0.05313692434862627, 0.09552148075878719, 0.02612221820818772, 0.09872879771694554, 0.0411497758943542, 0.14842974463779068, 0.052160728145508095, 0.14921976390862313, 0.15813923801894858, 0.21827161972265818, 0.2323501238250505, 0.21460016030087847, 0.15809819549548432, 0.19971622149510992, 0.17828773032841505, 0.21446999731448302, 0.003792054689886415, 0.016806038363415987, 0.052864122718024764, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06372301548519188, 0.04162804587418889, 0.028320489098660806, 0.03300459842841752, 0.019035029093161793, 0.02529616657980749, 0.028776527630301807, 0.0706111939038383, 0.04192186383886942, 0.2477542313842218, 0.23085637527461988, 0.25253144406019035, 0.2628057069181403, 0.28470515005674, 0.2988973687509451, 0.28563070209744923, 0.26540477156589304, 0.3117110595661152, 0.06825338110069024, 0.06701174873092064, 0.06382865939725957, 0.07506760166441928, 0.07927863836324611, 0.07102771512851525, 0.056777877914467534, 0.06395029580686773, 0.062237780039322566, 0.21830686808592525, 0.15657101789837757, 0.18976433139997495, 0.16292861299108208, 0.18141039630655853, 0.24220492012737427, 0.21339873417435906, 0.2342535410270017, 0.19964143025890158, 0.185878967528752, 0.21127520416723367, 0.21326521734440906, 0.19022375409842118, 0.20976448154449945, 0.18893054409969445, 0.20069720712989592, 0.20785055575061595, 0.22411794081901892, 0.1316433223516117, 0.13461711121460318, 0.13577616161992678, 0.1467897958888812, 0.1540859213207968, 0.1486913067723108, 0.15522763005198992, 0.1602421146323304, 0.13313000319571366, 0.23036661489962018, 0.1757665547857712, 0.17299697628554844, 0.1880416809839448, 0.18133685222186025, 0.20665404177937918, 0.18413224718941845, 0.20654890725538955, 0.17782740996861246, 0.16911100008891677, 0.16895296350163735, 0.16238925987913677, 0.17312722116701496, 0.17129089006741216, 0.17318121361238414, 0.18534656699900287, 0.17788785977770605, 0.18346635733894512, 0.18593856916511342, 0.16346761948648314, 0.3994864747716712, 0.2622552755701616, 0.14725463992954813, 0.3405249896643052, 0.5246766249864652, 0.14224383415478226, 0.17752009859498397, 0.34255124216212585, 0.24655883044943872, 0.4411642604032292, 0.4184073270148809, 0.17522065132488496, 0.23692416876654188, 0.33595513557557366, 0.5261017266493497, 0.22528867757483073, 0.18112753811996996, 0.1973123928031868, 0.17983286604753812, 0.18851347941291663, 0.1775518036555146, 0.19579622564200716, 0.18606448790038244, 0.1886418637730526, 0.17513448231582263, 0.07764624073356285, 0.06570096040526352, 0.06006587401292074, 0.06123730150841655, 0.05911097142680044, 0.07447223811523074, 0.07947540432369893, 0.06754521815696912, 0.07907676075498804]}, "mutation_prompt": null}
{"id": "f459a949-5e29-47a8-8608-ffd173850768", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "b18b77df-bfc5-4375-bb92-bf5d632d195c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "122b0885-a01b-470f-b69a-fe67b15d6383", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "9a1ca0c7-4b06-42ae-abe3-2df1815698bf", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "695404a4-a9ab-4d7d-8d89-189b44c701dc", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "540db470-01fa-4d93-ab4c-10a56f4fa88b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio) + np.random.normal(0, 0.2)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Introduce randomization in mutation scaling and enhance diversity check to bolster exploration while controlling convergence speed.", "configspace": "", "generation": 96, "fitness": 0.41357138763866164, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.24.", "error": "", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.8244686141989983, 0.746158011795562, 0.8077929377638791, 0.7711533054822753, 0.76790667431815, 0.7932519719285208, 0.8021620816019714, 0.7645947231031303, 0.7515741768007218, 0.6740424214748386, 0.6614907889630546, 0.6229544572279495, 0.667745265188925, 0.6731984040412186, 0.6992623058279404, 0.6511664217420703, 0.6144060592855063, 0.6853950381308187, 0.3135237521512161, 0.297040265288148, 0.17735015373429264, 0.2634771003175128, 0.29888953952235187, 0.12857864938790953, 0.22175155323149842, 0.20799513856540408, 0.23283736279441336, 0.1282341685008931, 0.13122432519309568, 0.13595732924386716, 0.12608679713538362, 0.23613503527873203, 0.23137943146000284, 0.13924561810750313, 0.23659685482426296, 0.12706173231719642, 0.8432297874507576, 0.9370043827247424, 0.9128290244477941, 0.3623189884999277, 0.22599623319398954, 0.9064479965039326, 0.17959988820041362, 0.13106315155197445, 0.972005323474005, 0.39380280647448673, 0.5316355014324987, 0.43417555252757456, 0.6100616151171453, 0.5030659293724762, 0.5807820646912631, 0.4025712910548469, 0.504443132865074, 0.573400700332985, 0.7698321164306665, 0.8152634502152403, 0.7927261685797946, 0.7379242313726424, 0.734798976030753, 0.7460950302537666, 0.8002398653250147, 0.7750329065239855, 0.7834088925164064, 0.1917820513822036, 0.11942558081700205, 0.1916673542113806, 0.2330801050212531, 0.31342321036575427, 0.1194827674532124, 0.282910214714695, 0.4414631093732231, 0.48985171137857564, 0.38850693349128973, 0.4787634652609024, 0.6379348675314567, 0.6165418830853897, 0.5828532637683088, 0.5423784041065965, 0.5675760950146526, 0.49031700178315496, 0.5759818716530949, 0.40961718083665133, 0.4961525196463388, 0.6115981962157409, 0.6315778154457908, 0.39623430583264896, 0.3782896358514054, 0.6898104181965609, 0.5694783538879838, 0.5908669795253881, 0.6962913399570042, 0.5158529430945766, 0.5963584277080541, 0.6917125877497563, 0.6436588971443473, 0.6280519569426355, 0.7290072092363621, 0.6079680092441309, 0.5857046519474419, 0.22994660302027514, 0.10475149267097728, 0.16430653021516117, 0.16497944486409466, 0.43141657481882245, 0.24699985167629035, 0.2103831555200507, 0.1484744303072244, 0.17699146911558383, 0.31422410428192327, 0.3437138204226342, 0.4141775858988529, 0.42378669746711617, 0.40438354077683325, 0.32169385298025766, 0.39587033323993726, 0.3494622571081665, 0.4299374537018381, 0.7490989615882364, 0.6942113627027489, 0.71845600297729, 0.6932586204723753, 0.6241686367279746, 0.6896265568543307, 0.7271787267507493, 0.6692405288799481, 0.7375739375119801, 0.14416201436834797, 0.10160844353430731, 0.1031217470414465, 0.10011014791183948, 0.10332057596241462, 0.09001387412515793, 0.10932452101869605, 0.10662941019640182, 0.29087507274163826, 0.2585526471883447, 0.2174160574821815, 0.28130361255827274, 0.22236917758753838, 0.23151094113122128, 0.1479755346059921, 0.25752698614503766, 0.5579687620355833, 0.19980992058775127, 0.43813932287396595, 0.3720575981157236, 0.40960216847877284, 0.46103678765415756, 0.4769953085869624, 0.48039131275876534, 0.40414531100965245, 0.44342774952586284, 0.4275722217694642, 0.35169336967667464, 0.3773018837739318, 0.3674885792850002, 0.31484266319543763, 0.3053260195666231, 0.3328450192021051, 0.36935260146491466, 0.2004588062648902, 0.382703372314371, 0.2286163505530604, 0.2106000282739573, 0.21925082504213356, 0.23698556469415533, 0.20806883296403644, 0.19667244292867214, 0.2034847343511853, 0.2186459279229379, 0.19698959368992663, 0.546402342249878, 0.19322138937973976, 0.37779584553505274, 0.22546915239654397, 0.205320707487334, 0.2016666492269431, 0.20002798000504318, 0.23358675277117913, 0.3897566970408971, 0.1962797180755178, 0.18271954794173917, 0.8062244343208435, 0.163109378576772, 0.15210342612043992, 0.15224531175597644, 0.1574984474005876, 0.6842408167417223, 0.16311084653989638, 0.8276865685559627, 0.693261850376095, 0.807175367797959, 0.7787445871967926, 0.15138161918441384, 0.8696017594286984, 0.698109669864174, 0.7442633214039709, 0.8455807433322239, 0.1848069609927545, 0.17826370371246447, 0.18410498476687498, 0.18809612514599017, 0.19014916459847975, 0.2257733456249258, 0.18759089073661805, 0.1922406286965478, 0.19031460288943625, 0.08740484183704611, 0.07187547224649804, 0.08671671692212257, 0.07253112391546224, 0.0742573133573976, 0.07672832948360031, 0.0936638196777374, 0.07090484297934985, 0.08879076498167071]}, "mutation_prompt": null}
{"id": "49f74156-706c-48b3-8106-9f580ee969fe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
{"id": "db572998-408e-407b-9146-d749d88c2923", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        scaling_factor = 0.5 + 0.5 * np.std(chaotic_map)  # Adaptive scaling based on diversity\n        chaotic_pop = self.lower_bound + scaling_factor * chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Incorporate an adaptive chaotic map scaling factor to dynamically adjust exploration-exploitation balance based on population diversity.", "configspace": "", "generation": 98, "fitness": 0.4198196304861786, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.24.", "error": "", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7264246351418819, 0.7435409216709594, 0.7808296339416023, 0.7574606078159207, 0.7591298880771625, 0.792766527878248, 0.7432431860641837, 0.7316298979544776, 0.7828624264475261, 0.6672326153739091, 0.7015248731652788, 0.6809548992102836, 0.6131090200181124, 0.6529770656214283, 0.614695712867111, 0.62283482321842, 0.635721240145156, 0.5916364013430693, 0.24310250123067, 0.18272233865675103, 0.3150212926888062, 0.17467199320150228, 0.12290348157071562, 0.2729200176731289, 0.29120000820664227, 0.122992522951064, 0.2603413893510774, 0.2189671477544718, 0.13859889539015147, 0.1398235998861137, 0.3004095399484069, 0.12431392628409121, 0.2128877048765191, 0.2916460139145034, 0.26752511306734883, 0.1283878101372422, 0.8759340635551508, 0.9028414960695453, 0.9035343793100369, 0.8787112799517915, 0.8288349771585413, 0.8779071619831298, 0.946821174185857, 0.18179541267666233, 0.9235636675403701, 0.5110716268248678, 0.42512557033619236, 0.5804401234855737, 0.42088090866912153, 0.45989101774926544, 0.5777134190316016, 0.4984420669373233, 0.5681559542607781, 0.3583090870475514, 0.737209095746283, 0.7717991181757052, 0.7792522925379695, 0.731228387747727, 0.7614437816709244, 0.7452088199656629, 0.695661242944539, 0.7626668656809183, 0.7262316714226595, 0.16964452215963288, 0.3561852117225953, 0.516996224187761, 0.25313863291237926, 0.45241299338266894, 0.14568184376760274, 0.5067676254769427, 0.19656446173339448, 0.5809006536874037, 0.6208502548002272, 0.35822582796736546, 0.6124868735765525, 0.6819774343718914, 0.5723278286194282, 0.6072823078826389, 0.6091539649789786, 0.44270014979982264, 0.6505611315578114, 0.5142786055914229, 0.47598142758128514, 0.5493518141527398, 0.464245760818205, 0.5468751973850186, 0.47219289529847475, 0.5225867809818217, 0.10502959692343772, 0.5139158605755216, 0.6251444374433233, 0.6420272373910214, 0.6799699285436946, 0.5807088690541655, 0.30310174066299833, 0.6533625173569908, 0.6378428149235573, 0.698127974792319, 0.6639025079773793, 0.056050616774412476, 0.06543337468004173, 0.11303314428377798, 0.2581642569226209, 0.26763180861846747, 0.2691396976997108, 0.131593633118801, 0.1358408653226586, 0.14824997562291153, 0.2977959378434102, 0.3782527197170651, 0.2973126578255527, 0.4779768508339801, 0.36499375438949855, 0.3311582516518693, 0.32426208857275296, 0.32066190749525925, 0.4219480780523004, 0.6630580815923162, 0.6735653345337154, 0.7027310643790298, 0.6321785486656539, 0.6507136722348021, 0.7072296239616052, 0.707125888045046, 0.6828486696140026, 0.6988841673414714, 0.11177376450930354, 0.09003576521573853, 0.12900103737486301, 0.08701267469160279, 0.10861025554353165, 0.09470765622300081, 0.09360153937130877, 0.11723433685298712, 0.09322763138875545, 0.4885036353498161, 0.21328579111008994, 0.48441486092769415, 0.1841009641096516, 0.1321564844463322, 0.21777463177036638, 0.45639839897932644, 0.26367748996749785, 0.24295157727518046, 0.42713740192135186, 0.3877710997476157, 0.4575942851896764, 0.420279408421817, 0.3959532614776705, 0.43173683264948737, 0.4274052369524035, 0.4473335686187103, 0.4266317746189574, 0.32622518675532286, 0.3786662541400282, 0.2989395521692956, 0.32353410030256446, 0.3271626168408226, 0.2783459087960958, 0.31129207801561376, 0.3682612591495974, 0.3650201778992438, 0.2215933463546207, 0.21045767518215852, 0.209681026085053, 0.22952565074126308, 0.20636985134531327, 0.222057822519933, 0.2293253618375466, 0.21133002383962907, 0.2297281937397061, 0.2124895273321915, 0.19410017803367796, 0.23425293431974725, 0.19881956411071555, 0.34001833207926835, 0.2765908579256683, 0.4047467408707688, 0.48309132320752846, 0.4351237739202738, 0.19586384630405185, 0.1792615941157274, 0.18453026223360047, 0.15359851931409774, 0.1494103142938784, 0.16698325990333018, 0.7273285404020996, 0.7289144863242145, 0.7463345609919583, 0.803768429565896, 0.8574089865730685, 0.8251145140078617, 0.5901221583202866, 0.15109450811179614, 0.6430806197058336, 0.838497247224264, 0.813444444578423, 0.7523458213429848, 0.18014410330933495, 0.190126628660926, 0.18027734663332307, 0.17913691459106773, 0.17942547480608007, 0.1884283985116284, 0.17987258276128537, 0.1805831109662086, 0.19321196475219438, 0.07276171212912175, 0.08717036762667851, 0.08496579598196641, 0.0894973269274556, 0.07816426048060221, 0.08453447329226216, 0.09092774296312511, 0.10253428287946154, 0.07709198696920538]}, "mutation_prompt": null}
{"id": "2076fad9-30e8-4cb6-81d8-2b183595ef63", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.max_trials_without_improvement = 100\n        self.f_initial = 0.8\n        self.cr_initial = 0.9\n        # Use chaotic maps for initial population generation\n        self.population = self.init_population_with_chaos(self.initial_population_size, dim)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.eval_count = 0\n\n    def init_population_with_chaos(self, pop_size, dim):\n        \"\"\"Generate initial population using chaotic maps.\"\"\"\n        chaotic_map = np.sin(np.arange(pop_size * dim) * 4.0 * np.pi / (pop_size * dim))\n        chaotic_map = (chaotic_map + 1) / 2  # Normalize to [0, 1]\n        chaotic_pop = self.lower_bound + chaotic_map * (self.upper_bound - self.lower_bound)\n        return chaotic_pop.reshape((pop_size, dim))\n\n    def calculate_diversity(self):\n        \"\"\"Calculate population diversity to adapt mutation factor.\"\"\"\n        return np.mean(np.std(self.population, axis=0))\n\n    def levy_flight(self, L=1.5):\n        \"\"\"Generate Levy flight steps.\"\"\"\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.fabs(v) ** (1.0 / L))\n        return step\n\n    def __call__(self, func):\n        fitness = np.apply_along_axis(func, 1, self.population)\n        self.eval_count += self.population_size\n\n        best_idx = np.argmin(fitness)\n        self.best_solution = self.population[best_idx]\n        self.best_fitness = fitness[best_idx]\n\n        trials_without_improvement = 0\n\n        while self.eval_count < self.budget:\n            diversity = self.calculate_diversity()\n            progress_ratio = self.eval_count / self.budget\n            self.f = self.f_initial * (1 + 0.2 * (1 - diversity) * progress_ratio)\n\n            self.population_size = max(5, int(self.initial_population_size * (1 - progress_ratio)))\n\n            for i in range(self.population_size):\n                if self.eval_count >= self.budget:\n                    break\n\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.f * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                self.cr = self.cr_initial * (1 - 0.5 * progress_ratio) + 0.5 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < self.cr\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                    if trial_fitness < self.best_fitness:\n                        self.best_solution = trial\n                        self.best_fitness = trial_fitness\n                        trials_without_improvement = 0\n                else:\n                    trials_without_improvement += 1\n\n                if trials_without_improvement >= self.max_trials_without_improvement:\n                    perturbation = self.levy_flight() * (0.5 + 0.5 * np.random.rand())  # Adaptive scaling\n                    local_solution = self.best_solution + perturbation\n                    local_solution = np.clip(local_solution, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_solution)\n                    self.eval_count += 1\n                    if local_fitness < self.best_fitness:\n                        self.best_solution = local_solution\n                        self.best_fitness = local_fitness\n                    self.f_initial = np.random.uniform(0.5, 1)\n                    self.cr_initial = np.random.uniform(0.7, 1)\n                    trials_without_improvement = 0\n\n        return self.best_solution", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Integrate chaotic maps to enhance initial population diversity and introduce adaptive scaling of perturbation during local search to improve convergence.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af933c14-4a12-47c2-b5ba-352db86eb49b", "metadata": {"aucs": [0.7698424593303628, 0.7213302857330047, 0.7224698329367318, 0.7216932656792211, 0.7349912708654256, 0.7621121388497776, 0.7742714514113864, 0.7912713414358146, 0.764576152503218, 0.6652777835778472, 0.5780609933310894, 0.6276390405388017, 0.6715340776027494, 0.6018269246076515, 0.627605421516475, 0.657901584671736, 0.6737241803095649, 0.642280571291705, 0.30087616071479983, 0.1167876215489565, 0.24855012744970306, 0.18968106481203628, 0.13371869511810253, 0.32926345086372144, 0.23409503224994976, 0.11696247753398603, 0.2909329951853903, 0.11583987276724106, 0.3088824515687556, 0.24595540289578743, 0.11720770491347199, 0.2461566234028303, 0.12078398180057626, 0.12049412350025435, 0.18870435386868445, 0.2369327995713636, 0.9222709351164704, 0.9280542687297492, 0.7043432396441653, 0.90306295364154, 0.8749784622587188, 0.8540497753999916, 0.9591165638039288, 0.18179126479233187, 0.8177599693192832, 0.34313745704454135, 0.5829365883836872, 0.46674767229084246, 0.5132975344017559, 0.40670186705179867, 0.527168167206729, 0.3849504253072811, 0.5554530068306591, 0.40176461725657286, 0.7298638477073691, 0.7870496791069723, 0.8083994453800946, 0.7478026766020112, 0.8005752833854244, 0.7269992240772116, 0.8032661258032385, 0.7254832704214053, 0.693086862399911, 0.4892183557681349, 0.19038393702126888, 0.5162477478948384, 0.28380093532791484, 0.2729108355409825, 0.3048194204540161, 0.5139160531052249, 0.26707039860260706, 0.3002031125259558, 0.6210152331003176, 0.5731909252033794, 0.6324731685363123, 0.6128728105489729, 0.5875582107797666, 0.5188686124694962, 0.5840331326004433, 0.5537388568189998, 0.5365035182229185, 0.5465509655179352, 0.5243233870359455, 0.49929581837788284, 0.5322955254320236, 0.5247183816508447, 0.46356121706430453, 0.6263916470789836, 0.4979960274261602, 0.47960713860469495, 0.646572002477044, 0.6547165749813146, 0.5570469326204195, 0.6106167594233962, 0.6345379238808266, 0.6157814748571467, 0.634424672167586, 0.6242490193743486, 0.6994354285160446, 0.1687716209670852, 0.14037202212074973, 0.2010452597633231, 0.11834103595031542, 0.36637394653016275, 0.17321783775671662, 0.14197070786589772, 0.23235090337870268, 0.19450391117058052, 0.3405004472100287, 0.36126185269327427, 0.3694362146192133, 0.350075267467741, 0.32827834196902517, 0.3326318264937935, 0.3847850540750335, 0.33419410805385763, 0.3218635047189049, 0.7136281190149335, 0.7055384105965943, 0.6816171104411111, 0.6665773978528169, 0.6305525403805563, 0.6864000813025178, 0.7192545649856747, 0.6394927512998325, 0.7159132297341504, 0.1955472563958951, 0.10249034116016353, 0.10612825158760875, 0.12107416709502672, 0.12095613408025419, 0.08769691938319923, 0.1040870766781341, 0.097818067332202, 0.09614286458228327, 0.21100499218974123, 0.1905218155362456, 0.17954713502315411, 0.1556252884968926, 0.17364113124634273, 0.17759896386512541, 0.3165998756935645, 0.6066712053077616, 0.2575158849827617, 0.3818090184700348, 0.43270994651546535, 0.4305277670610367, 0.4130185293214066, 0.3783434734347223, 0.37517873620569975, 0.4597272779845787, 0.41487154237283597, 0.4530960376658566, 0.2992496789911435, 0.3067175677322389, 0.3217941687421655, 0.32481153151689146, 0.33332113370223637, 0.30506555326274754, 0.3101118738660865, 0.34990164468766805, 0.3685247989931859, 0.23447395530362114, 0.209169187109288, 0.20004988708239102, 0.22270055993947335, 0.20875082338034612, 0.19981476395101894, 0.2569731445181045, 0.198340922422646, 0.19702986207208195, 0.3521754335856754, 0.38385197913944746, 0.19195168588892908, 0.30842402674956315, 0.22796455437367624, 0.3358187849876333, 0.4508223125628841, 0.46214886824351986, 0.31489181857350956, 0.19211756546006087, 0.18194491956231884, 0.7963480295192648, 0.16906813962886413, 0.1514262140717474, 0.8009328363590771, 0.6847473146524037, 0.7128403312364939, 0.7056228989502116, 0.8108746949988621, 0.7765478035120559, 0.8034642774403722, 0.8194909778927439, 0.19201624392979255, 0.7717692467889407, 0.7326657909080666, 0.8259257548897285, 0.8231545031214343, 0.17129013556471495, 0.18209880126347888, 0.18480111223066353, 0.18527630611087498, 0.1747400515952251, 0.21097614062496572, 0.17279843404110728, 0.18164993811195207, 0.19260140027058215, 0.07159631855268467, 0.07957009331739606, 0.0843060673461461, 0.07495620107398826, 0.06653799715336195, 0.0998236032705705, 0.0838523256034992, 0.09086723115219297, 0.07744763732955018]}, "mutation_prompt": null}
