{"id": "a2b362c0-2785-4201-9bb0-cc41d8e7a0c2", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "A hybrid metaheuristic algorithm that combines Particle Swarm Optimization (PSO) with Differential Evolution (DE) to balance exploration and exploitation for efficient global optimization. ", "configspace": "", "generation": 0, "fitness": 0.20364377690064708, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7398843950633286, 0.7491698202354757, 0.7586473999448823, 0.18979890625198848, 0.1885799053865027, 0.18905020371077663, 0.7588477294521091, 0.17825140070578072, 0.7493994326741421, 9.999999999998899e-05, 0.06961279982963331, 9.999999999998899e-05, 0.390274421097623, 9.999999999998899e-05, 0.04362464996433024, 0.044833526479620245, 9.999999999998899e-05, 9.999999999998899e-05, 0.11030833183125766, 0.129585097517129, 0.15250622051823015, 0.3204213991544298, 0.04104224050609118, 0.11289526353485801, 0.0691262958490455, 0.048149104496759576, 0.1091681609470635, 0.1294127595984852, 0.11022751052273483, 0.11250861464835393, 0.116984309595766, 0.04093743619625678, 0.043273959664154926, 0.09691726698671632, 0.10718407066854141, 0.1040450204256329, 0.9833865773756957, 0.9915126049649892, 0.9905310322793902, 0.990680031673109, 0.9928196953025974, 0.9902329528124808, 0.9958047075708714, 0.9920385194782168, 0.9941475726115554, 0.40034741902432924, 0.05987438629801689, 0.054587098438923176, 9.999999999998899e-05, 0.35694210484601796, 0.14984498217747388, 0.08917008571542084, 9.999999999998899e-05, 0.05090358738835077, 0.4130986831122022, 0.4586151670166809, 0.3629669988205674, 0.2082327554268535, 0.18550269276118836, 0.11406031886202439, 0.6048238090423909, 0.12455837931457459, 0.08953289646891549, 0.1602777789884049, 9.999999999998899e-05, 0.18339884108006532, 0.1609580973136011, 9.999999999998899e-05, 0.12226917946025317, 9.999999999998899e-05, 9.999999999998899e-05, 0.15660754348858374, 0.16560730231499965, 0.021549917939129637, 0.016612089191512136, 0.1270476508870414, 0.11953247645691767, 0.10885422293545566, 0.03279625082119819, 9.999999999998899e-05, 0.03358055004119087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008676013615410705, 9.999999999998899e-05, 9.999999999998899e-05, 0.04161833074965471, 0.09360837482774009, 0.07623723009425698, 0.04540549983141595, 0.011928122817366993, 0.1154546810409709, 0.024306511145462117, 0.0528105467279294, 0.07848231530076188, 0.05984119157937384, 9.999999999998899e-05, 9.999999999998899e-05, 0.07559998018442327, 0.06843802926358222, 0.07896169475239534, 0.07249857638855906, 0.07756057119491122, 0.07578825697352765, 0.0406280483295286, 9.999999999998899e-05, 0.12725092037351493, 0.03678126495860856, 9.999999999998899e-05, 0.03475948761975889, 0.07569963416965875, 9.999999999998899e-05, 0.07905830968446337, 0.509092918116399, 0.49647709716935595, 0.4432799758017113, 0.20815801946542756, 0.20783566829315192, 0.47533599951730554, 0.5289547715893318, 0.5340559815675694, 0.5501706569194287, 0.09646182811077342, 0.06611483279651531, 0.09545184220573388, 0.1013052257135445, 0.0421410603196124, 0.08023726216616556, 0.09832086750024904, 0.11470378278869142, 0.12309750819558685, 0.15881947314050449, 0.18306063461077615, 0.2577474244814276, 0.1800014280347556, 0.14338373327302056, 0.15591151135604797, 0.2487803077603319, 0.17837347129273495, 0.14694612680414498, 0.3362397328281902, 0.36908911610959894, 0.3106135284614263, 0.19348306473390442, 0.3698421289446936, 0.25201310168900226, 0.27653310902843187, 0.2051236446954413, 0.17400300540288094, 0.15751191695725286, 0.230819745970388, 0.2201367253626858, 0.19052537893516985, 0.12881691817323793, 0.1906889096277301, 0.12027714849091642, 0.22619627748750093, 0.20147685759185063, 0.1933298110083752, 0.20130219035346497, 0.19123045517104742, 0.21727371053089295, 0.19807719738372231, 0.23259682657292347, 0.18385775326771614, 0.19651389217924697, 0.17052891314463992, 0.6605646984105141, 0.4212715155232001, 0.1967790094038695, 0.1989159767702281, 0.2239905207716295, 0.19967485877860303, 0.17648620461544706, 0.45669344523406497, 0.22838775941749878, 0.20885660723125887, 0.18153464495080562, 0.19599965000286268, 0.8625259271770007, 0.16761028186448546, 0.16676891065931687, 0.09019012324283626, 0.18265092526851523, 0.20842986028054988, 0.16182984952757995, 0.1167359966454804, 0.11214560760027703, 0.3836310754808816, 0.20697696332407245, 0.10945677005980925, 0.18623127028447795, 0.185957053503641, 0.18448475134878672, 0.19226589424656249, 0.18524257012227585, 0.1872586889616653, 0.19423180304511534, 0.2112934619498833, 0.20031984455751795, 0.1892017313644535, 0.1884351700105209, 0.19079423015371222, 0.09485776213970853, 0.07397380481827609, 0.08211579607406749, 0.06991284427499433, 0.07160710841445872, 0.07848855351070905, 0.04253417276322524, 0.09258927315171583, 0.0929641697284267]}, "mutation_prompt": null}
{"id": "730a9a95-f823-410f-9071-e857c37e5bf5", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "A hybrid metaheuristic algorithm that combines Particle Swarm Optimization (PSO) with Differential Evolution (DE) to balance exploration and exploitation for efficient global optimization. ", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a2b362c0-2785-4201-9bb0-cc41d8e7a0c2", "metadata": {"aucs": [0.7398843950633286, 0.7491698202354757, 0.7586473999448823, 0.18979890625198848, 0.1885799053865027, 0.18905020371077663, 0.7588477294521091, 0.17825140070578072, 0.7493994326741421, 9.999999999998899e-05, 0.06961279982963331, 9.999999999998899e-05, 0.390274421097623, 9.999999999998899e-05, 0.04362464996433024, 0.044833526479620245, 9.999999999998899e-05, 9.999999999998899e-05, 0.11030833183125766, 0.129585097517129, 0.15250622051823015, 0.3204213991544298, 0.04104224050609118, 0.11289526353485801, 0.0691262958490455, 0.048149104496759576, 0.1091681609470635, 0.1294127595984852, 0.11022751052273483, 0.11250861464835393, 0.116984309595766, 0.04093743619625678, 0.043273959664154926, 0.09691726698671632, 0.10718407066854141, 0.1040450204256329, 0.9833865773756957, 0.9915126049649892, 0.9905310322793902, 0.990680031673109, 0.9928196953025974, 0.9902329528124808, 0.9958047075708714, 0.9920385194782168, 0.9941475726115554, 0.40034741902432924, 0.05987438629801689, 0.054587098438923176, 9.999999999998899e-05, 0.35694210484601796, 0.14984498217747388, 0.08917008571542084, 9.999999999998899e-05, 0.05090358738835077, 0.4130986831122022, 0.4586151670166809, 0.3629669988205674, 0.2082327554268535, 0.18550269276118836, 0.11406031886202439, 0.6048238090423909, 0.12455837931457459, 0.08953289646891549, 0.1602777789884049, 9.999999999998899e-05, 0.18339884108006532, 0.1609580973136011, 9.999999999998899e-05, 0.12226917946025317, 9.999999999998899e-05, 9.999999999998899e-05, 0.15660754348858374, 0.16560730231499965, 0.021549917939129637, 0.016612089191512136, 0.1270476508870414, 0.11953247645691767, 0.10885422293545566, 0.03279625082119819, 9.999999999998899e-05, 0.03358055004119087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008676013615410705, 9.999999999998899e-05, 9.999999999998899e-05, 0.04161833074965471, 0.09360837482774009, 0.07623723009425698, 0.04540549983141595, 0.011928122817366993, 0.1154546810409709, 0.024306511145462117, 0.0528105467279294, 0.07848231530076188, 0.05984119157937384, 9.999999999998899e-05, 9.999999999998899e-05, 0.07559998018442327, 0.06843802926358222, 0.07896169475239534, 0.07249857638855906, 0.07756057119491122, 0.07578825697352765, 0.0406280483295286, 9.999999999998899e-05, 0.12725092037351493, 0.03678126495860856, 9.999999999998899e-05, 0.03475948761975889, 0.07569963416965875, 9.999999999998899e-05, 0.07905830968446337, 0.509092918116399, 0.49647709716935595, 0.4432799758017113, 0.20815801946542756, 0.20783566829315192, 0.47533599951730554, 0.5289547715893318, 0.5340559815675694, 0.5501706569194287, 0.09646182811077342, 0.06611483279651531, 0.09545184220573388, 0.1013052257135445, 0.0421410603196124, 0.08023726216616556, 0.09832086750024904, 0.11470378278869142, 0.12309750819558685, 0.15881947314050449, 0.18306063461077615, 0.2577474244814276, 0.1800014280347556, 0.14338373327302056, 0.15591151135604797, 0.2487803077603319, 0.17837347129273495, 0.14694612680414498, 0.3362397328281902, 0.36908911610959894, 0.3106135284614263, 0.19348306473390442, 0.3698421289446936, 0.25201310168900226, 0.27653310902843187, 0.2051236446954413, 0.17400300540288094, 0.15751191695725286, 0.230819745970388, 0.2201367253626858, 0.19052537893516985, 0.12881691817323793, 0.1906889096277301, 0.12027714849091642, 0.22619627748750093, 0.20147685759185063, 0.1933298110083752, 0.20130219035346497, 0.19123045517104742, 0.21727371053089295, 0.19807719738372231, 0.23259682657292347, 0.18385775326771614, 0.19651389217924697, 0.17052891314463992, 0.6605646984105141, 0.4212715155232001, 0.1967790094038695, 0.1989159767702281, 0.2239905207716295, 0.19967485877860303, 0.17648620461544706, 0.45669344523406497, 0.22838775941749878, 0.20885660723125887, 0.18153464495080562, 0.19599965000286268, 0.8625259271770007, 0.16761028186448546, 0.16676891065931687, 0.09019012324283626, 0.18265092526851523, 0.20842986028054988, 0.16182984952757995, 0.1167359966454804, 0.11214560760027703, 0.3836310754808816, 0.20697696332407245, 0.10945677005980925, 0.18623127028447795, 0.185957053503641, 0.18448475134878672, 0.19226589424656249, 0.18524257012227585, 0.1872586889616653, 0.19423180304511534, 0.2112934619498833, 0.20031984455751795, 0.1892017313644535, 0.1884351700105209, 0.19079423015371222, 0.09485776213970853, 0.07397380481827609, 0.08211579607406749, 0.06991284427499433, 0.07160710841445872, 0.07848855351070905, 0.04253417276322524, 0.09258927315171583, 0.0929641697284267]}, "mutation_prompt": null}
{"id": "a3e351a9-b225-4ef5-a146-0d7051b5da76", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "A hybrid metaheuristic algorithm that combines Particle Swarm Optimization (PSO) with Differential Evolution (DE) to balance exploration and exploitation for efficient global optimization. ", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a2b362c0-2785-4201-9bb0-cc41d8e7a0c2", "metadata": {"aucs": [0.7398843950633286, 0.7491698202354757, 0.7586473999448823, 0.18979890625198848, 0.1885799053865027, 0.18905020371077663, 0.7588477294521091, 0.17825140070578072, 0.7493994326741421, 9.999999999998899e-05, 0.06961279982963331, 9.999999999998899e-05, 0.390274421097623, 9.999999999998899e-05, 0.04362464996433024, 0.044833526479620245, 9.999999999998899e-05, 9.999999999998899e-05, 0.11030833183125766, 0.129585097517129, 0.15250622051823015, 0.3204213991544298, 0.04104224050609118, 0.11289526353485801, 0.0691262958490455, 0.048149104496759576, 0.1091681609470635, 0.1294127595984852, 0.11022751052273483, 0.11250861464835393, 0.116984309595766, 0.04093743619625678, 0.043273959664154926, 0.09691726698671632, 0.10718407066854141, 0.1040450204256329, 0.9833865773756957, 0.9915126049649892, 0.9905310322793902, 0.990680031673109, 0.9928196953025974, 0.9902329528124808, 0.9958047075708714, 0.9920385194782168, 0.9941475726115554, 0.40034741902432924, 0.05987438629801689, 0.054587098438923176, 9.999999999998899e-05, 0.35694210484601796, 0.14984498217747388, 0.08917008571542084, 9.999999999998899e-05, 0.05090358738835077, 0.4130986831122022, 0.4586151670166809, 0.3629669988205674, 0.2082327554268535, 0.18550269276118836, 0.11406031886202439, 0.6048238090423909, 0.12455837931457459, 0.08953289646891549, 0.1602777789884049, 9.999999999998899e-05, 0.18339884108006532, 0.1609580973136011, 9.999999999998899e-05, 0.12226917946025317, 9.999999999998899e-05, 9.999999999998899e-05, 0.15660754348858374, 0.16560730231499965, 0.021549917939129637, 0.016612089191512136, 0.1270476508870414, 0.11953247645691767, 0.10885422293545566, 0.03279625082119819, 9.999999999998899e-05, 0.03358055004119087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008676013615410705, 9.999999999998899e-05, 9.999999999998899e-05, 0.04161833074965471, 0.09360837482774009, 0.07623723009425698, 0.04540549983141595, 0.011928122817366993, 0.1154546810409709, 0.024306511145462117, 0.0528105467279294, 0.07848231530076188, 0.05984119157937384, 9.999999999998899e-05, 9.999999999998899e-05, 0.07559998018442327, 0.06843802926358222, 0.07896169475239534, 0.07249857638855906, 0.07756057119491122, 0.07578825697352765, 0.0406280483295286, 9.999999999998899e-05, 0.12725092037351493, 0.03678126495860856, 9.999999999998899e-05, 0.03475948761975889, 0.07569963416965875, 9.999999999998899e-05, 0.07905830968446337, 0.509092918116399, 0.49647709716935595, 0.4432799758017113, 0.20815801946542756, 0.20783566829315192, 0.47533599951730554, 0.5289547715893318, 0.5340559815675694, 0.5501706569194287, 0.09646182811077342, 0.06611483279651531, 0.09545184220573388, 0.1013052257135445, 0.0421410603196124, 0.08023726216616556, 0.09832086750024904, 0.11470378278869142, 0.12309750819558685, 0.15881947314050449, 0.18306063461077615, 0.2577474244814276, 0.1800014280347556, 0.14338373327302056, 0.15591151135604797, 0.2487803077603319, 0.17837347129273495, 0.14694612680414498, 0.3362397328281902, 0.36908911610959894, 0.3106135284614263, 0.19348306473390442, 0.3698421289446936, 0.25201310168900226, 0.27653310902843187, 0.2051236446954413, 0.17400300540288094, 0.15751191695725286, 0.230819745970388, 0.2201367253626858, 0.19052537893516985, 0.12881691817323793, 0.1906889096277301, 0.12027714849091642, 0.22619627748750093, 0.20147685759185063, 0.1933298110083752, 0.20130219035346497, 0.19123045517104742, 0.21727371053089295, 0.19807719738372231, 0.23259682657292347, 0.18385775326771614, 0.19651389217924697, 0.17052891314463992, 0.6605646984105141, 0.4212715155232001, 0.1967790094038695, 0.1989159767702281, 0.2239905207716295, 0.19967485877860303, 0.17648620461544706, 0.45669344523406497, 0.22838775941749878, 0.20885660723125887, 0.18153464495080562, 0.19599965000286268, 0.8625259271770007, 0.16761028186448546, 0.16676891065931687, 0.09019012324283626, 0.18265092526851523, 0.20842986028054988, 0.16182984952757995, 0.1167359966454804, 0.11214560760027703, 0.3836310754808816, 0.20697696332407245, 0.10945677005980925, 0.18623127028447795, 0.185957053503641, 0.18448475134878672, 0.19226589424656249, 0.18524257012227585, 0.1872586889616653, 0.19423180304511534, 0.2112934619498833, 0.20031984455751795, 0.1892017313644535, 0.1884351700105209, 0.19079423015371222, 0.09485776213970853, 0.07397380481827609, 0.08211579607406749, 0.06991284427499433, 0.07160710841445872, 0.07848855351070905, 0.04253417276322524, 0.09258927315171583, 0.0929641697284267]}, "mutation_prompt": null}
{"id": "7b83c18e-89f2-4d16-b328-1c52b84ad457", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1 = 2.0  # Cognitive component\n        self.c2 = 2.0  # Social component\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "A hybrid metaheuristic algorithm that combines Particle Swarm Optimization (PSO) with Differential Evolution (DE) to balance exploration and exploitation for efficient global optimization. ", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a2b362c0-2785-4201-9bb0-cc41d8e7a0c2", "metadata": {"aucs": [0.7398843950633286, 0.7491698202354757, 0.7586473999448823, 0.18979890625198848, 0.1885799053865027, 0.18905020371077663, 0.7588477294521091, 0.17825140070578072, 0.7493994326741421, 9.999999999998899e-05, 0.06961279982963331, 9.999999999998899e-05, 0.390274421097623, 9.999999999998899e-05, 0.04362464996433024, 0.044833526479620245, 9.999999999998899e-05, 9.999999999998899e-05, 0.11030833183125766, 0.129585097517129, 0.15250622051823015, 0.3204213991544298, 0.04104224050609118, 0.11289526353485801, 0.0691262958490455, 0.048149104496759576, 0.1091681609470635, 0.1294127595984852, 0.11022751052273483, 0.11250861464835393, 0.116984309595766, 0.04093743619625678, 0.043273959664154926, 0.09691726698671632, 0.10718407066854141, 0.1040450204256329, 0.9833865773756957, 0.9915126049649892, 0.9905310322793902, 0.990680031673109, 0.9928196953025974, 0.9902329528124808, 0.9958047075708714, 0.9920385194782168, 0.9941475726115554, 0.40034741902432924, 0.05987438629801689, 0.054587098438923176, 9.999999999998899e-05, 0.35694210484601796, 0.14984498217747388, 0.08917008571542084, 9.999999999998899e-05, 0.05090358738835077, 0.4130986831122022, 0.4586151670166809, 0.3629669988205674, 0.2082327554268535, 0.18550269276118836, 0.11406031886202439, 0.6048238090423909, 0.12455837931457459, 0.08953289646891549, 0.1602777789884049, 9.999999999998899e-05, 0.18339884108006532, 0.1609580973136011, 9.999999999998899e-05, 0.12226917946025317, 9.999999999998899e-05, 9.999999999998899e-05, 0.15660754348858374, 0.16560730231499965, 0.021549917939129637, 0.016612089191512136, 0.1270476508870414, 0.11953247645691767, 0.10885422293545566, 0.03279625082119819, 9.999999999998899e-05, 0.03358055004119087, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008676013615410705, 9.999999999998899e-05, 9.999999999998899e-05, 0.04161833074965471, 0.09360837482774009, 0.07623723009425698, 0.04540549983141595, 0.011928122817366993, 0.1154546810409709, 0.024306511145462117, 0.0528105467279294, 0.07848231530076188, 0.05984119157937384, 9.999999999998899e-05, 9.999999999998899e-05, 0.07559998018442327, 0.06843802926358222, 0.07896169475239534, 0.07249857638855906, 0.07756057119491122, 0.07578825697352765, 0.0406280483295286, 9.999999999998899e-05, 0.12725092037351493, 0.03678126495860856, 9.999999999998899e-05, 0.03475948761975889, 0.07569963416965875, 9.999999999998899e-05, 0.07905830968446337, 0.509092918116399, 0.49647709716935595, 0.4432799758017113, 0.20815801946542756, 0.20783566829315192, 0.47533599951730554, 0.5289547715893318, 0.5340559815675694, 0.5501706569194287, 0.09646182811077342, 0.06611483279651531, 0.09545184220573388, 0.1013052257135445, 0.0421410603196124, 0.08023726216616556, 0.09832086750024904, 0.11470378278869142, 0.12309750819558685, 0.15881947314050449, 0.18306063461077615, 0.2577474244814276, 0.1800014280347556, 0.14338373327302056, 0.15591151135604797, 0.2487803077603319, 0.17837347129273495, 0.14694612680414498, 0.3362397328281902, 0.36908911610959894, 0.3106135284614263, 0.19348306473390442, 0.3698421289446936, 0.25201310168900226, 0.27653310902843187, 0.2051236446954413, 0.17400300540288094, 0.15751191695725286, 0.230819745970388, 0.2201367253626858, 0.19052537893516985, 0.12881691817323793, 0.1906889096277301, 0.12027714849091642, 0.22619627748750093, 0.20147685759185063, 0.1933298110083752, 0.20130219035346497, 0.19123045517104742, 0.21727371053089295, 0.19807719738372231, 0.23259682657292347, 0.18385775326771614, 0.19651389217924697, 0.17052891314463992, 0.6605646984105141, 0.4212715155232001, 0.1967790094038695, 0.1989159767702281, 0.2239905207716295, 0.19967485877860303, 0.17648620461544706, 0.45669344523406497, 0.22838775941749878, 0.20885660723125887, 0.18153464495080562, 0.19599965000286268, 0.8625259271770007, 0.16761028186448546, 0.16676891065931687, 0.09019012324283626, 0.18265092526851523, 0.20842986028054988, 0.16182984952757995, 0.1167359966454804, 0.11214560760027703, 0.3836310754808816, 0.20697696332407245, 0.10945677005980925, 0.18623127028447795, 0.185957053503641, 0.18448475134878672, 0.19226589424656249, 0.18524257012227585, 0.1872586889616653, 0.19423180304511534, 0.2112934619498833, 0.20031984455751795, 0.1892017313644535, 0.1884351700105209, 0.19079423015371222, 0.09485776213970853, 0.07397380481827609, 0.08211579607406749, 0.06991284427499433, 0.07160710841445872, 0.07848855351070905, 0.04253417276322524, 0.09258927315171583, 0.0929641697284267]}, "mutation_prompt": null}
{"id": "03b34e3c-4974-4efc-b530-d8a22252f329", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improves balance between exploration and exploitation through adaptive adjustment of cognitive and social components.", "configspace": "", "generation": 4, "fitness": 0.3053781513977092, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "a2b362c0-2785-4201-9bb0-cc41d8e7a0c2", "metadata": {"aucs": [0.8836075720745684, 0.8981403389935606, 0.880100413439386, 0.8960334767078061, 0.8964817377859402, 0.8900342821667296, 0.8648005832441995, 0.87287832029994, 0.8904418417329802, 0.7562978871456798, 0.7374053967074378, 0.5352653834078299, 0.758601983182168, 0.7469450232215638, 0.7496864088191351, 0.6865190847318863, 0.6446671169643694, 0.05259381128160989, 0.18254616079917518, 0.1326018337991851, 0.17272160717618268, 0.09818923216040198, 0.5793396545174577, 0.18320177011657424, 0.12706300673588777, 0.10605589688772632, 0.6734534510083137, 0.12330755222642453, 0.09321592187627792, 0.1288727640458035, 0.11307471452068052, 0.1698402563108934, 0.12872109070029636, 0.1413147693426292, 0.10543959410142945, 0.1362090611659973, 0.9891948600799025, 0.9904662395558373, 0.9797686308234222, 0.983774113743326, 0.9910818640124301, 0.9876499942543007, 0.9871158231585849, 0.9904049243381535, 0.9905154257201639, 0.05937951939605213, 0.05978090340367903, 0.7153316310676052, 0.15028470844283914, 0.15015625600022375, 0.1532250785932907, 0.7358955880432775, 0.0869643219221834, 0.08790523534411698, 0.223663500184886, 0.2261375154958004, 0.835885737060374, 0.19367433182422433, 0.27876145538014885, 0.19212964459287818, 0.8737170292535832, 0.1272899283324821, 0.17659933981230447, 0.17527486522830027, 0.24216938795318332, 0.23324417981319545, 0.23131281896858058, 0.10273568061610949, 0.23881550285697584, 0.23961153995668372, 0.2494274576779304, 0.23185364673090259, 0.23012290780896183, 0.11843681280639617, 0.25986568286473066, 0.2517907411166842, 0.27717074775591477, 0.2645291858534957, 9.999999999998899e-05, 0.2528571215595664, 0.251979290671856, 0.0061814348541072706, 9.999999999998899e-05, 0.0033411079100623686, 9.999999999998899e-05, 0.009868740107869423, 9.999999999998899e-05, 9.999999999998899e-05, 0.00235566763275763, 0.06426397011842289, 0.06538085497584856, 0.05581578588944325, 0.08596146211923061, 0.04088118134421581, 0.010769388628100729, 0.038219385113574256, 0.10756294181631221, 0.12130901994451981, 0.06435726128303254, 0.09035430639898057, 0.034334930639006944, 9.999999999998899e-05, 0.33214679540074, 0.07713983174775729, 0.39309863716189564, 0.16606623824612365, 0.09909314999036012, 0.12252518372659793, 0.12751745504052592, 0.08330430136037903, 0.04193068962506963, 0.03808970913960874, 9.999999999998899e-05, 0.2431861427708769, 0.08143203037247515, 0.08497580064352239, 0.10833327858527209, 0.5487281674465889, 0.6232866170502139, 0.5521999890528677, 0.5502217465804353, 0.5836809497098641, 0.547787580106923, 0.6108185666949636, 0.5805898731817607, 0.5781123952150873, 0.136271877392094, 0.10632524515406672, 0.07664740902126943, 0.11098850682643202, 0.13333274170949294, 0.10714753483309158, 0.1412085510839024, 0.10438819129228982, 0.1287110203703401, 0.1805879235831439, 0.34163853145268974, 0.24592064893829457, 0.1635479300245124, 0.1543550363258428, 0.17802628150205313, 0.17090430961770597, 0.1889545708995738, 0.1624893111398873, 0.35491358923841265, 0.2317213580474936, 0.3384840579374848, 0.20522180978639648, 0.5087980230791027, 0.28811453943100984, 0.2894096287992648, 0.6421221712546823, 0.4504813602038843, 0.41627129577997335, 0.26853137703895535, 0.30900892544163894, 0.2072532635361748, 0.1956285958738493, 0.304319112025208, 0.21775105033263442, 0.12442099260453054, 0.3693575646612153, 0.21385525720350185, 0.21156600240549472, 0.24677674558337825, 0.2133169043736679, 0.20452397270782752, 0.2237408294036065, 0.23616731267375257, 0.22199060291440187, 0.23774117833621522, 0.19447483652371045, 0.2070073418830981, 0.18317662032627013, 0.20493964012096222, 0.19301443736084556, 0.20735119038808247, 0.6922611583310765, 0.19427733446077955, 0.1970874892875044, 0.16470733211852806, 0.8769473058432168, 0.19533638968326483, 0.1863016141336269, 0.18643851777221976, 0.1857156305990355, 0.1684215544499713, 0.8715923396266874, 0.8708743426370747, 0.49622714779592847, 0.8038695170572907, 0.6481769793760409, 0.6878120573555526, 0.16437606911500602, 0.20862788816968048, 0.19431934911747006, 0.18888912016051385, 0.2857554793101098, 0.1993037432232836, 0.20805112736109166, 0.188540532112915, 0.19506432787036976, 0.19202329056609246, 0.18389005135017888, 0.19466622521270205, 0.2118475762220975, 0.18371992571964224, 0.1099481524688154, 0.09216725530237202, 0.10089886279907789, 0.09243021265352558, 0.10195011001871357, 0.13050673667653934, 0.09287069911299128, 0.09747382818395323, 0.08587348310777432]}, "mutation_prompt": null}
{"id": "31fded4a-6b38-4fc1-bc69-d850a039a689", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w_init = 0.9   # Initial inertia weight\n        self.w_final = 0.4  # Final inertia weight\n        self.w = self.w_init\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1, c2, and w based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = self.w_init * (1 - progress) + self.w_final * progress\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances exploitation by dynamically adjusting inertia weight based on convergence.", "configspace": "", "generation": 5, "fitness": 0.20703460738761942, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.22.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.5608058347504556, 0.5766606083617176, 0.5352821626652566, 0.6110812627077258, 0.6295596714003311, 0.6291812072125835, 0.1762451775708852, 0.1753279223405001, 0.5816051272592766, 0.23736609424335608, 9.999999999998899e-05, 0.2898441108693294, 0.26931720793099667, 0.023799409041080466, 9.999999999998899e-05, 0.03621709023279962, 0.2756873217885727, 0.033711476095276915, 0.1376876436564386, 0.11748809155678597, 0.11212077679293198, 0.05594781004825433, 0.10516499430452864, 0.33263857805016583, 0.12825256018274345, 0.10206823428172063, 0.10120418750238491, 0.2286347576776202, 0.08038546300508442, 0.09491704249864363, 0.09174787557270336, 0.03853764287407191, 0.10549755338300926, 0.0973907890300959, 0.09422763156060832, 0.09831134175745082, 0.9896111005040676, 0.9874599289950058, 0.9795411625373632, 0.9839963031233663, 0.9911348293575024, 0.9909450672144462, 0.9933634017881492, 0.9904623267286293, 0.9940748314433536, 0.0567405975709786, 0.056577297567789175, 0.09186628629821059, 9.999999999998899e-05, 0.4257818361145832, 0.13988348469313094, 0.08837274547863583, 0.35898941572066156, 0.048253230080999354, 0.20079831775439994, 0.15466040046770635, 0.5230363885878023, 0.18669957143590832, 0.11260700734148321, 0.1797516391800611, 0.12283100941891445, 0.12399149107632712, 0.5224867264881984, 0.18655653916885084, 0.1310478117058056, 0.1812260705377412, 0.10085949494251545, 0.09406760827971938, 0.0728592773866954, 0.12982059425186576, 0.15672231649224722, 0.13480897812563652, 0.01498936636695758, 0.00940130457894972, 0.04464537095739873, 0.13895882677628435, 0.11787438957151608, 0.1323922743212761, 0.0674649231165293, 0.12487211486663441, 0.07155043874453826, 0.01965805935871745, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007743317775774083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.060265462121651625, 0.05907915469789171, 0.06801124446104201, 0.0022454305740952085, 0.01355297495790364, 0.017665410510868784, 0.021321418727938135, 0.06241172955962615, 0.020152777162049995, 0.0597235949730881, 9.999999999998899e-05, 0.016096227292514365, 9.999999999998899e-05, 0.03987002496129899, 0.04084101600719081, 9.999999999998899e-05, 0.05878039958005721, 0.08997299459444841, 0.1372849906380954, 9.999999999998899e-05, 0.06629543641966607, 0.1085470354800756, 9.999999999998899e-05, 0.0038625764565720644, 0.06491808037093671, 0.03883674419334071, 0.055369890193070925, 0.46287813271062705, 0.4191165351937379, 0.3957009350078706, 0.4665054329623589, 0.4398275508256062, 0.5079762474461423, 0.45062496152975495, 0.40920489851222397, 0.47964214488807244, 0.11695606429924721, 0.08005079995442865, 0.06159874468756421, 0.07763744308681475, 0.11625115850639722, 0.10495831080686491, 0.11185856724839705, 0.08965710813918482, 0.11478891560350146, 0.15471202876955759, 0.22011195153546304, 0.1604966686159589, 0.16208622329615296, 0.1657971366366997, 0.2679584776018278, 0.18210038863732347, 0.20755673856450463, 0.13124252444467055, 0.26838332695102574, 0.21205708656404232, 0.32541455267009545, 0.35389580180782876, 0.30119865569394544, 0.2979004630275486, 0.24651254709850756, 0.35422465948388693, 0.3670425624793262, 0.16853587792365943, 0.16801251104770676, 0.19864953273653774, 0.17939453267719563, 0.1649969564815772, 0.21926327699621184, 0.29748717730936636, 0.20966946921863416, 0.2520023986572273, 0.17680037501945722, 0.19868905413774096, 0.1890423334443121, 0.1891899594312274, 0.17409196748404487, 0.16206615376325006, 0.21776076680526069, 0.17177144964260083, 0.18734809474822955, 0.423412180990298, 0.1768108568487019, 0.1758827028172213, 0.1856962715129099, 0.18256713984064687, 0.1762563162419314, 0.20702374234579457, 0.17973420412350183, 0.17763607991496033, 0.5794773761147335, 0.13985542315456856, 0.17061823346837957, 0.16361267282895386, 0.5737863562250985, 0.18421404095414007, 0.17786493948632065, 0.17769313192368752, 0.1971345147677407, 0.16285198115592248, 0.16271689890758478, 0.15733170891963633, 0.4550136129951803, 0.3881057944855464, 0.25287809175006193, 0.11711961281777161, 0.18551252948117258, 0.21444780137425035, 0.1887224424053181, 0.20299959059238526, 0.182228050945348, 0.17224025496427364, 0.2005451798670722, 0.18793710107437167, 0.18919594436962206, 0.22360664774728445, 0.19574295451847779, 0.08548704002358931, 0.0828366479320033, 0.08064935017808184, 0.07224223735131285, 0.07964086835094186, 0.09231397816943554, 0.0748348910550789, 0.07269958430156698, 0.07964583718937579]}, "mutation_prompt": null}
{"id": "0451896f-6db9-46a6-8895-361ddedd7de5", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improves balance between exploration and exploitation through adaptive adjustment of cognitive and social components.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8836075720745684, 0.8981403389935606, 0.880100413439386, 0.8960334767078061, 0.8964817377859402, 0.8900342821667296, 0.8648005832441995, 0.87287832029994, 0.8904418417329802, 0.7562978871456798, 0.7374053967074378, 0.5352653834078299, 0.758601983182168, 0.7469450232215638, 0.7496864088191351, 0.6865190847318863, 0.6446671169643694, 0.05259381128160989, 0.18254616079917518, 0.1326018337991851, 0.17272160717618268, 0.09818923216040198, 0.5793396545174577, 0.18320177011657424, 0.12706300673588777, 0.10605589688772632, 0.6734534510083137, 0.12330755222642453, 0.09321592187627792, 0.1288727640458035, 0.11307471452068052, 0.1698402563108934, 0.12872109070029636, 0.1413147693426292, 0.10543959410142945, 0.1362090611659973, 0.9891948600799025, 0.9904662395558373, 0.9797686308234222, 0.983774113743326, 0.9910818640124301, 0.9876499942543007, 0.9871158231585849, 0.9904049243381535, 0.9905154257201639, 0.05937951939605213, 0.05978090340367903, 0.7153316310676052, 0.15028470844283914, 0.15015625600022375, 0.1532250785932907, 0.7358955880432775, 0.0869643219221834, 0.08790523534411698, 0.223663500184886, 0.2261375154958004, 0.835885737060374, 0.19367433182422433, 0.27876145538014885, 0.19212964459287818, 0.8737170292535832, 0.1272899283324821, 0.17659933981230447, 0.17527486522830027, 0.24216938795318332, 0.23324417981319545, 0.23131281896858058, 0.10273568061610949, 0.23881550285697584, 0.23961153995668372, 0.2494274576779304, 0.23185364673090259, 0.23012290780896183, 0.11843681280639617, 0.25986568286473066, 0.2517907411166842, 0.27717074775591477, 0.2645291858534957, 9.999999999998899e-05, 0.2528571215595664, 0.251979290671856, 0.0061814348541072706, 9.999999999998899e-05, 0.0033411079100623686, 9.999999999998899e-05, 0.009868740107869423, 9.999999999998899e-05, 9.999999999998899e-05, 0.00235566763275763, 0.06426397011842289, 0.06538085497584856, 0.05581578588944325, 0.08596146211923061, 0.04088118134421581, 0.010769388628100729, 0.038219385113574256, 0.10756294181631221, 0.12130901994451981, 0.06435726128303254, 0.09035430639898057, 0.034334930639006944, 9.999999999998899e-05, 0.33214679540074, 0.07713983174775729, 0.39309863716189564, 0.16606623824612365, 0.09909314999036012, 0.12252518372659793, 0.12751745504052592, 0.08330430136037903, 0.04193068962506963, 0.03808970913960874, 9.999999999998899e-05, 0.2431861427708769, 0.08143203037247515, 0.08497580064352239, 0.10833327858527209, 0.5487281674465889, 0.6232866170502139, 0.5521999890528677, 0.5502217465804353, 0.5836809497098641, 0.547787580106923, 0.6108185666949636, 0.5805898731817607, 0.5781123952150873, 0.136271877392094, 0.10632524515406672, 0.07664740902126943, 0.11098850682643202, 0.13333274170949294, 0.10714753483309158, 0.1412085510839024, 0.10438819129228982, 0.1287110203703401, 0.1805879235831439, 0.34163853145268974, 0.24592064893829457, 0.1635479300245124, 0.1543550363258428, 0.17802628150205313, 0.17090430961770597, 0.1889545708995738, 0.1624893111398873, 0.35491358923841265, 0.2317213580474936, 0.3384840579374848, 0.20522180978639648, 0.5087980230791027, 0.28811453943100984, 0.2894096287992648, 0.6421221712546823, 0.4504813602038843, 0.41627129577997335, 0.26853137703895535, 0.30900892544163894, 0.2072532635361748, 0.1956285958738493, 0.304319112025208, 0.21775105033263442, 0.12442099260453054, 0.3693575646612153, 0.21385525720350185, 0.21156600240549472, 0.24677674558337825, 0.2133169043736679, 0.20452397270782752, 0.2237408294036065, 0.23616731267375257, 0.22199060291440187, 0.23774117833621522, 0.19447483652371045, 0.2070073418830981, 0.18317662032627013, 0.20493964012096222, 0.19301443736084556, 0.20735119038808247, 0.6922611583310765, 0.19427733446077955, 0.1970874892875044, 0.16470733211852806, 0.8769473058432168, 0.19533638968326483, 0.1863016141336269, 0.18643851777221976, 0.1857156305990355, 0.1684215544499713, 0.8715923396266874, 0.8708743426370747, 0.49622714779592847, 0.8038695170572907, 0.6481769793760409, 0.6878120573555526, 0.16437606911500602, 0.20862788816968048, 0.19431934911747006, 0.18888912016051385, 0.2857554793101098, 0.1993037432232836, 0.20805112736109166, 0.188540532112915, 0.19506432787036976, 0.19202329056609246, 0.18389005135017888, 0.19466622521270205, 0.2118475762220975, 0.18371992571964224, 0.1099481524688154, 0.09216725530237202, 0.10089886279907789, 0.09243021265352558, 0.10195011001871357, 0.13050673667653934, 0.09287069911299128, 0.09747382818395323, 0.08587348310777432]}, "mutation_prompt": null}
{"id": "70b76007-780a-4f29-a988-305123f5b8eb", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.6   # Increased inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.f = 0.8 * (1 - progress)  # Mutation rate decay\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Slightly increased the inertia weight for better exploration and added a mutation rate decay for enhanced convergence over time.", "configspace": "", "generation": 7, "fitness": 0.2767445976974349, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8091489992114275, 0.7968142745168894, 0.8058368390723971, 0.18977107682511918, 0.8303434395329025, 0.8376344682754231, 0.7886115133554498, 0.8494247225686871, 0.1815435559235069, 0.6405995601307684, 0.6187147062221566, 0.43652067799322025, 0.5869507630466658, 0.6140608315532547, 0.5945583671896764, 0.6805781444534711, 0.6002830297250146, 0.6436151327501138, 0.1630276846169818, 0.16296604195126596, 0.1436474378234669, 0.13868376203004096, 0.15153914613207964, 0.1757903582490815, 0.15127970783195854, 0.0518035254733058, 0.11986499384358362, 0.09320889784319775, 0.14203753289692211, 0.10645346624832785, 0.09233219493530209, 0.11698083711242979, 0.14703090169388067, 0.10516833632012912, 0.10356427029147275, 0.1127907696335746, 0.9895732791164593, 0.9904146759481752, 0.9799631033091019, 0.9834096390388001, 0.9910868208609914, 0.9878361010239631, 0.9901101522944241, 0.9904137711656659, 0.9906443147840721, 0.05930550016244707, 0.6660353848970154, 0.059462583049436746, 0.14638509589043547, 0.4562705701915477, 0.15203488259006515, 0.6457175042581033, 0.08768279389436939, 0.08643956959191068, 0.7214708621115438, 0.3578816215273606, 0.1356086728791086, 0.19131837046030353, 0.18928911135310544, 0.2030392641447306, 0.14825819527086737, 0.13518883023213635, 0.11604192669563729, 0.21264521905779243, 0.2368125125797308, 0.12571339011447358, 0.10178993574802986, 0.1283354378617081, 0.1176275634796351, 0.2109371691009414, 0.21809463579050548, 0.21737805292110057, 0.021880179666012523, 0.02214005845589584, 0.22526464846780947, 0.18463511844652092, 0.21886851304860577, 0.2322453919196682, 0.131583098713429, 0.12480358490721122, 0.21735925019455415, 9.999999999998899e-05, 0.004054621685616655, 0.010655057262682899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051627561714451264, 0.16036236122058345, 0.06974997938650118, 0.07402477248866401, 0.017995197058926715, 0.039462075801924956, 0.07593879745118615, 0.08243530859756865, 0.06612320275076422, 0.08671515909132654, 0.13195436481048872, 9.999999999998899e-05, 9.999999999998899e-05, 0.08648876390636107, 0.07450879937446675, 0.15549250246565427, 0.09352069001310714, 0.0911146374213998, 0.20127945551762982, 0.2385349817218616, 9.999999999998899e-05, 0.17999796569048543, 0.37787865170391866, 0.03765579645566053, 0.10051325678328793, 0.07827166330197255, 0.05819726980669948, 0.07895442760511251, 0.4951746916590022, 0.5399345378774321, 0.5213740565178355, 0.5460281506668531, 0.519286916367989, 0.5792326517443815, 0.5714560538661153, 0.5648380521585682, 0.5392916937289547, 0.12865615052115065, 0.07089727236749754, 0.09584976885589347, 0.13755744681126358, 0.10880412308565379, 0.1421358181548762, 0.08552354614905455, 0.15076227417387655, 0.5443138889937821, 0.14267434660502443, 0.14853298948756477, 0.2335479471743772, 0.23812630169189253, 0.22566305049710478, 0.16554229598532277, 0.17322895932891091, 0.2392116556118603, 0.28740290310233196, 0.44500369843149523, 0.252734981617318, 0.5149206110287319, 0.43703131082478874, 0.511686268290334, 0.24816592187105047, 0.5127154754524663, 0.438219271024631, 0.5313189761661197, 0.20440896696114064, 0.18970795547406882, 0.3107077224684355, 0.18889180056632882, 0.2002453004903043, 0.30860569917354264, 0.26258347169851637, 0.2702769693748912, 0.2436619164084486, 0.1857428342427213, 0.19679269306384117, 0.2051900181373637, 0.22026843136091867, 0.19046117700097953, 0.17484763630255107, 0.19563667589964007, 0.23285576451786172, 0.23265031747418452, 0.21721558355077986, 0.1891222073533967, 0.2039157197024789, 0.21822406352418788, 0.23713331679464444, 0.21648567886455616, 0.2173293892260817, 0.23198167370026668, 0.23728016747539227, 0.855780298845499, 0.865834156620525, 0.19719940694170035, 0.17483668857979573, 0.16771242233957195, 0.16496264677835315, 0.09923855556593231, 0.8304338089673629, 0.18714993339091868, 0.21006494175582424, 0.17122245831777616, 0.16448159465682566, 0.12654577396190758, 0.20726954735640313, 0.6433276749357151, 0.18604880465732754, 0.198951817569069, 0.7276188762241835, 0.1998203424449102, 0.20744765367401907, 0.20575179850189584, 0.19210580239769137, 0.19626128937354947, 0.20059038309768573, 0.17996580964937914, 0.21125642215971718, 0.18539690473759007, 0.09002435477834547, 0.0881698078784029, 0.10040438761720138, 0.08435764636074927, 0.09322039140620964, 0.08911849052270715, 0.09523307794182345, 0.08224342047611477, 0.1211348578873842]}, "mutation_prompt": null}
{"id": "7a2ffa88-a53d-4205-84c3-b0d3f64ec62a", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            diversity = np.std(self.swarm, axis=0).mean()\n            self.velocities[i] = (self.w + 0.1 * diversity) * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances adaptive search by incorporating swarm diversity awareness in weight adjustment.", "configspace": "", "generation": 8, "fitness": 0.27442645647305575, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8441155091779843, 0.8432183198946623, 0.8286172352929753, 0.861505989453778, 0.8475642529442105, 0.8662863712757146, 0.1805934102063791, 0.18147180987535372, 0.8405091404710189, 0.6635595930185512, 0.5296634132303585, 0.5770520654529125, 0.6679010457981578, 0.633773428456019, 0.04286736067315544, 0.603692176059452, 0.6612722615898246, 0.6105282072202209, 0.14521343812750942, 0.138185809275718, 0.1507098232522781, 0.14859802992759508, 0.1120037328680954, 0.1426083165954125, 0.1539202232257072, 0.4896567886342491, 0.04657770852694798, 0.12739293163455745, 0.08919754674423896, 0.11342612669861096, 0.11108427385253439, 0.1172593056375133, 0.07183512732378317, 0.16862238150015818, 0.11114496044321409, 0.13909676782195002, 0.9896015965237757, 0.9872660608708653, 0.9762100329065824, 0.9829667968500776, 0.9911175112989502, 0.9909286399484668, 0.9901754074002614, 0.9904813541741592, 0.9912522074391181, 0.7246999179048591, 0.6698752536331474, 0.05909139904853278, 0.14756796013652618, 0.6470950617201802, 0.15135689974950073, 0.7191145158686927, 0.7009134807561066, 0.08780165346723245, 0.639126362447236, 0.1625406359350936, 0.2225367658651246, 0.2042320346865032, 0.19094723664133695, 0.189334409909089, 0.21342714642732752, 0.7825482802772812, 0.34506138363577255, 0.21705691409097883, 0.23830332677513033, 0.21796738202337662, 0.21862390393565123, 0.21473995436673987, 0.21241963409167297, 9.999999999998899e-05, 0.21753187802762886, 0.23589376142828622, 0.21219604891569033, 0.19894705544257818, 0.2006472010743905, 0.23148578839303857, 0.10444718413832743, 0.23620982624248832, 0.243934368836635, 0.2382181369434173, 0.09925247392417369, 0.07711698758073293, 0.0020504487057946275, 0.0004748669711196474, 9.999999999998899e-05, 0.019160003839097994, 0.0001552199510084229, 0.00364043458816099, 9.999999999998899e-05, 0.10007415488978166, 0.03220595542952864, 0.028465057802731786, 0.05870916461484288, 0.03802927860639216, 0.0667569955691264, 0.08626213614680711, 0.03922237952015761, 0.0663035728985567, 0.06007163587601916, 0.03362891278727298, 9.999999999998899e-05, 9.999999999998899e-05, 0.09054994841099273, 0.0739691003054006, 0.07418618349322292, 0.09572770882906301, 0.09337731628638835, 0.17780289895301138, 0.2456827455939098, 9.999999999998899e-05, 0.04215119367767184, 0.06615703231840087, 9.999999999998899e-05, 0.031609381771777634, 0.16277385415563517, 0.055762676647000964, 0.08156753712152132, 0.5570552062621118, 0.586540989654033, 0.14051947392581354, 0.5589135008631027, 0.18045631052151312, 0.53102654893848, 0.5475292116228068, 0.562639012209298, 0.5459750375999205, 0.1389590803686489, 0.09666102625653661, 0.06425873270178362, 0.12663189767753047, 0.10261587252698989, 0.12257204082285267, 0.11040982472339911, 0.16714148525921757, 0.11643484011150262, 0.2854988483391879, 0.14580151221313153, 0.18084232926617883, 0.14283116439145582, 0.22223485174859592, 0.2120529704652171, 0.1669091997430836, 0.15882709238448656, 0.12235361827457669, 0.34851174719956735, 0.2340381428363607, 0.2650033931475899, 0.36243159456535956, 0.3090249888643647, 0.21907155156140812, 0.202107889342657, 0.1967571357328861, 0.39875730441688784, 0.25504988894429115, 0.17626842636156748, 0.2748578158646501, 0.19473072483348308, 0.20518242044482737, 0.31920314054905163, 0.2861076206417503, 0.1513311125965232, 0.2247413839216772, 0.26850625716153376, 0.18603966193519872, 0.20557378335838783, 0.1958336452837064, 0.1997290362159646, 0.20062281821369865, 0.23762914731860763, 0.22814795416954758, 0.21303175228992344, 0.1863799178387764, 0.18829251185307294, 0.20096728769306016, 0.19854733733379348, 0.19544031457098188, 0.1950740410927616, 0.18688443452293746, 0.18998681819262242, 0.20895880780213727, 0.1632019085808315, 0.15433951311651417, 0.16127408790702336, 0.1642110510218867, 0.1864074043190057, 0.5845871981507875, 0.8122066328084463, 0.7546123811173214, 0.8182321804982852, 0.15623216381978633, 0.6108532188044109, 0.1667860751241369, 0.1262080217265935, 0.1978335293014326, 0.1991217344265036, 0.19331207019979968, 0.18547254255629553, 0.7489642310059623, 0.17721302308743414, 0.20063479820440355, 0.1980858694966824, 0.1918431701580997, 0.20072083930843054, 0.20267717504587812, 0.20652781888929572, 0.18584576508468797, 0.1777740199124952, 0.07982193790086367, 0.08031039705051335, 0.08952260999067274, 0.09787918753085456, 0.08220468796194769, 0.09490391464659897, 0.08784736576507857, 0.0899277408139576, 0.09579033561012607]}, "mutation_prompt": null}
{"id": "48fc51a0-90e9-4545-a8da-a1616aa6de52", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f_initial = 0.8  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            progress = self.func_evals / self.budget\n            f_dynamic = self.f_initial * (1 - progress) + 0.5 * progress\n            mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances the search efficiency by introducing a dynamic adjustment of the DE mutation factor based on progress.", "configspace": "", "generation": 9, "fitness": 0.29091711968022504, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8781580621845597, 0.890847392568937, 0.8831326390898435, 0.8936275846815231, 0.8872783819955405, 0.8861452221449355, 0.8803537485392654, 0.8768226031209981, 0.868861990691139, 0.7311628254081883, 0.6588622298440346, 0.749831526973712, 0.7488210739321974, 0.7608404572721296, 0.06064414250092964, 0.050802590804452485, 0.727975293134441, 0.7231837209656775, 0.15406709659003193, 0.1421165667627371, 0.1373818459662629, 0.1451817891729995, 0.157057751467386, 0.14302610433483876, 0.141649817727023, 0.11821884163880891, 0.15094570334838298, 0.12533917947949413, 0.11175734837507212, 0.11630487313053195, 0.10793318661997442, 0.1705204336657813, 0.11646728382798188, 0.0989960007057119, 0.11347398190763291, 0.1494007703584158, 0.989196057133488, 0.9904665376760685, 0.9797663679654313, 0.9834739817116325, 0.9910809387039168, 0.987649977662786, 0.9871156429372823, 0.9904048014609057, 0.9905159236183135, 0.059446779039975084, 0.059782952405849965, 0.75243399643745, 0.14910833153012448, 0.15033515281626897, 0.1528951445525346, 0.7531860107682099, 0.08663286188006458, 0.08790411740200832, 0.3677937828148704, 0.2395839459919492, 0.8054888511100762, 0.19356234194884414, 0.19238745994205164, 0.1919911028886928, 0.37548160721029256, 0.13023486090807623, 0.1732161050078901, 0.24888543583245226, 0.25880265914671796, 0.2413242693886677, 0.23511707959869044, 0.10084642914144593, 0.2527362925722785, 0.23595671507271598, 0.22751322001624696, 0.2377357080993272, 0.13096795845860287, 0.11535013271410044, 0.24747626679143642, 0.25211108466556587, 0.2762677166287011, 0.2906300180402134, 0.15504813720415822, 0.1305560461565516, 0.2504199013757884, 0.0056346901094284085, 9.999999999998899e-05, 0.002379434368771527, 9.999999999998899e-05, 0.09300272085998496, 9.999999999998899e-05, 9.999999999998899e-05, 0.04268570443259834, 0.0003536590189514577, 0.06964278230558807, 0.052734529644640094, 0.07689292775287326, 0.01329053545875103, 0.008831347220868202, 0.006802964557603652, 0.06994141014876076, 0.1321118150169892, 0.07778437130187488, 0.08994012356568815, 9.999999999998899e-05, 9.999999999998899e-05, 0.32411447785546665, 0.08317638552703266, 0.09020615041640845, 0.13653441371028097, 0.09989099743464025, 0.09706010452433944, 0.2875930527041137, 0.13165429901504155, 0.04633559645621321, 0.06594450034739163, 9.999999999998899e-05, 0.3222878281416771, 0.08169717928112274, 0.08267732068536371, 0.0972359005693505, 0.5906611438610349, 0.58034611108581, 0.556557843638949, 0.605332373353956, 0.5274780819773469, 0.5798565793223442, 0.5838181731860556, 0.5749148066318972, 0.601899217790575, 0.09646117574818669, 0.10440492988155292, 0.05275114795568292, 0.15206005903395048, 0.13880052184119052, 0.12008756557940525, 0.13091506217844473, 0.07999051210206931, 0.15380352190903068, 0.17653222340686137, 0.2616276073377287, 0.2355231615094383, 0.17843807248611554, 0.19018594354854856, 0.21203339722408843, 0.20438430108699146, 0.346773994063973, 0.23376381128381918, 0.41717482822159024, 0.23859698653940964, 0.37665458637124216, 0.21820852576724892, 0.34844196616635814, 0.23252436495682172, 0.5324161928891833, 0.6652689374121736, 0.5859273392249245, 0.2813276452503214, 0.3610014550737437, 0.38855716918941785, 0.19199709510555363, 0.20236582575432427, 0.18401534172409506, 0.40231901155414473, 0.13734854619925285, 0.23411821742400662, 0.2064421693997769, 0.18833618344118808, 0.22778216426322428, 0.18219071561316214, 0.17458891961478695, 0.17220832897530924, 0.2765757425875822, 0.19384991647635041, 0.2591406494866516, 0.19979778871831755, 0.22287423806315743, 0.21164791433423835, 0.1904632577418235, 0.2177073394242628, 0.19881492892057007, 0.19798900661919483, 0.20487770109303283, 0.1959718169064505, 0.16487485398549617, 0.26428509826856494, 0.14052621178902736, 0.18624418402094212, 0.18732720681355997, 0.18576324883997652, 0.16841798966664612, 0.8873818665009341, 0.8738715789981275, 0.20343974668843334, 0.5601457368087099, 0.6403476060509734, 0.1665360264424811, 0.2062615887014373, 0.20796685963556105, 0.19432012935633336, 0.188857710583606, 0.8015064428858325, 0.18475868987724475, 0.20353751684486554, 0.21703410644620302, 0.18025188919650081, 0.21239351988845856, 0.2010654474189415, 0.2116638466732006, 0.2246162653495667, 0.18576512607614382, 0.10790966335313756, 0.10800210675015509, 0.09992179772878462, 0.09660731152547031, 0.08561662046611218, 0.08988199674588104, 0.07987686448044984, 0.10140356171631992, 0.08558529103448798]}, "mutation_prompt": null}
{"id": "c6c299a0-7ca6-4688-9909-1ca25a90347d", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f_initial = 0.8   # DE mutation factor initial\n        self.f = self.f_initial  # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive updates for c1, c2, and f based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.f = self.f_initial * (1 - 0.5 * progress)  # Adaptively reduce f\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances exploration by varying DE mutation factor adaptively based on progress.", "configspace": "", "generation": 10, "fitness": 0.2949722337671947, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8829091480511645, 0.8799005250640742, 0.8703579540570132, 0.9028812908406298, 0.1902837541971304, 0.8847607836446234, 0.8699315520197417, 0.8757563014251056, 0.8881696313136167, 0.7687330383173139, 0.07483570248529248, 0.6948191874134095, 0.7667631378849354, 0.7659419167467524, 9.999999999998899e-05, 0.05191095091972997, 0.7157962784004757, 0.722978565404871, 0.17899247901474646, 0.13229582695847764, 0.12053813910025979, 0.12956107253079385, 0.18385213355662178, 0.13264693700165409, 0.13828207624103395, 0.11334000813031964, 0.15684837418990594, 0.1326821374032594, 0.10053968617298337, 0.07508678729056684, 0.11404393055981832, 0.1327451123425708, 0.114210163991318, 0.12783162465364584, 0.11308141350905954, 0.17586991177208022, 0.9891959607668073, 0.9904659266643937, 0.9797660049551572, 0.9834730953029398, 0.9910817505398465, 0.9876503580968322, 0.9871158742497048, 0.9904049309957778, 0.9905167183076701, 0.7178894819347388, 0.059783242219932475, 0.7453967084983297, 0.14887506241341397, 0.7129233431575843, 0.1531674018673379, 0.7591922961413721, 0.08648685211199758, 0.08790418291463353, 0.3726100350533912, 0.37625085612554, 0.7990813722091273, 0.19356234194884414, 0.20524184647521926, 0.19198599364382463, 0.8849212369139666, 0.13782088346540766, 0.3512762482891626, 0.2514614841811518, 0.24662980080350594, 0.24900187252201833, 0.24595198111806527, 0.10248616265747479, 0.2353576097914415, 0.22623463504931007, 0.21191046638675592, 0.23303660490240086, 0.2163018273847983, 0.1160945675537649, 0.25734654625773523, 0.2698789664590907, 0.2523077152379899, 0.266163103022075, 0.1543573701986567, 0.166326512843477, 0.2544949344743189, 0.010559995638233177, 9.999999999998899e-05, 0.007924307491979032, 9.999999999998899e-05, 0.020076737140837908, 0.03377887437975913, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08615918851753979, 0.05544177849159182, 0.08019664618573064, 0.007735220434480605, 0.015323537036326496, 9.999999999998899e-05, 0.09958668934519377, 0.12721789331711753, 0.09169095257425708, 0.08976631392082268, 9.999999999998899e-05, 0.03440518558865735, 0.30112869765495354, 0.08465060971443639, 0.09096226225690751, 0.13454400433838853, 0.10114108348471584, 0.09761848839565845, 0.12092879519599742, 0.14175694091163515, 0.05380050412413473, 0.09685347908950337, 9.999999999998899e-05, 0.188802215683042, 0.08149076295194158, 0.05628844241568676, 0.12443879977982175, 0.5437969956184431, 0.5391605385698959, 0.555301801303338, 0.5785742118077415, 0.5734881759799682, 0.584803453983737, 0.5899576868734024, 0.575693875188152, 0.6134377600702341, 0.14626637055252445, 0.06946305768262695, 0.052747667648957, 0.1520608105103034, 0.13662305355584958, 0.11243256345508124, 0.12086643326179147, 0.08002041924136938, 0.15361856571072097, 0.22063929833186147, 0.1816222451297297, 0.2686430650614636, 0.18146227034128803, 0.16214657137945865, 0.22138786427142843, 0.18904114449737275, 0.23277908896805566, 0.28647212050986093, 0.39780746811956524, 0.23899568636254154, 0.7002185359655738, 0.20196153645958048, 0.3646329950349928, 0.22763793486503414, 0.5338340863923102, 0.38412266319262034, 0.4850383867506405, 0.17039682846012894, 0.1794083483204698, 0.29821780752190286, 0.18991208727024977, 0.20883821414235648, 0.2787733825506328, 0.4305168634238751, 0.26376172247664176, 0.3824819509503443, 0.20197898578448104, 0.2276455321828681, 0.23165057409965606, 0.19877979733345497, 0.22444548813498355, 0.21942781696713187, 0.2255747684331818, 0.21060027129296532, 0.23403293306580475, 0.21623387454039988, 0.7093336266320412, 0.18737881096889286, 0.20511795342106065, 0.2166897150835726, 0.2218142484554817, 0.18698406324652395, 0.18743663024197477, 0.20819229224392, 0.15472814114251454, 0.2639402524193415, 0.14055120395386966, 0.18608890545293866, 0.18714446217508673, 0.18586259747188283, 0.16842302508422968, 0.868283873323899, 0.840495918037427, 0.19597111285208524, 0.6567450773548991, 0.620456275808427, 0.16653855215215663, 0.20688974695754914, 0.20817277343109497, 0.19432476277237354, 0.18557155367353806, 0.8152722726878433, 0.1895242168320873, 0.19734688556218605, 0.20836433238987384, 0.20771429579099165, 0.1886689552634685, 0.2041120666785432, 0.19948842840550218, 0.22540143821901026, 0.1941398639226981, 0.08267844000346414, 0.09858128067918082, 0.09938148749134013, 0.08516507625839609, 0.0819559935486599, 0.09845158137068444, 0.09709108670209732, 0.09058869905536415, 0.10377876412551668]}, "mutation_prompt": null}
{"id": "b1fda0d2-039b-402c-953a-b1cab6351aaf", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improves balance between exploration and exploitation through adaptive adjustment of cognitive and social components.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8836075720745684, 0.8981403389935606, 0.880100413439386, 0.8960334767078061, 0.8964817377859402, 0.8900342821667296, 0.8648005832441995, 0.87287832029994, 0.8904418417329802, 0.7562978871456798, 0.7374053967074378, 0.5352653834078299, 0.758601983182168, 0.7469450232215638, 0.7496864088191351, 0.6865190847318863, 0.6446671169643694, 0.05259381128160989, 0.18254616079917518, 0.1326018337991851, 0.17272160717618268, 0.09818923216040198, 0.5793396545174577, 0.18320177011657424, 0.12706300673588777, 0.10605589688772632, 0.6734534510083137, 0.12330755222642453, 0.09321592187627792, 0.1288727640458035, 0.11307471452068052, 0.1698402563108934, 0.12872109070029636, 0.1413147693426292, 0.10543959410142945, 0.1362090611659973, 0.9891948600799025, 0.9904662395558373, 0.9797686308234222, 0.983774113743326, 0.9910818640124301, 0.9876499942543007, 0.9871158231585849, 0.9904049243381535, 0.9905154257201639, 0.05937951939605213, 0.05978090340367903, 0.7153316310676052, 0.15028470844283914, 0.15015625600022375, 0.1532250785932907, 0.7358955880432775, 0.0869643219221834, 0.08790523534411698, 0.223663500184886, 0.2261375154958004, 0.835885737060374, 0.19367433182422433, 0.27876145538014885, 0.19212964459287818, 0.8737170292535832, 0.1272899283324821, 0.17659933981230447, 0.17527486522830027, 0.24216938795318332, 0.23324417981319545, 0.23131281896858058, 0.10273568061610949, 0.23881550285697584, 0.23961153995668372, 0.2494274576779304, 0.23185364673090259, 0.23012290780896183, 0.11843681280639617, 0.25986568286473066, 0.2517907411166842, 0.27717074775591477, 0.2645291858534957, 9.999999999998899e-05, 0.2528571215595664, 0.251979290671856, 0.0061814348541072706, 9.999999999998899e-05, 0.0033411079100623686, 9.999999999998899e-05, 0.009868740107869423, 9.999999999998899e-05, 9.999999999998899e-05, 0.00235566763275763, 0.06426397011842289, 0.06538085497584856, 0.05581578588944325, 0.08596146211923061, 0.04088118134421581, 0.010769388628100729, 0.038219385113574256, 0.10756294181631221, 0.12130901994451981, 0.06435726128303254, 0.09035430639898057, 0.034334930639006944, 9.999999999998899e-05, 0.33214679540074, 0.07713983174775729, 0.39309863716189564, 0.16606623824612365, 0.09909314999036012, 0.12252518372659793, 0.12751745504052592, 0.08330430136037903, 0.04193068962506963, 0.03808970913960874, 9.999999999998899e-05, 0.2431861427708769, 0.08143203037247515, 0.08497580064352239, 0.10833327858527209, 0.5487281674465889, 0.6232866170502139, 0.5521999890528677, 0.5502217465804353, 0.5836809497098641, 0.547787580106923, 0.6108185666949636, 0.5805898731817607, 0.5781123952150873, 0.136271877392094, 0.10632524515406672, 0.07664740902126943, 0.11098850682643202, 0.13333274170949294, 0.10714753483309158, 0.1412085510839024, 0.10438819129228982, 0.1287110203703401, 0.1805879235831439, 0.34163853145268974, 0.24592064893829457, 0.1635479300245124, 0.1543550363258428, 0.17802628150205313, 0.17090430961770597, 0.1889545708995738, 0.1624893111398873, 0.35491358923841265, 0.2317213580474936, 0.3384840579374848, 0.20522180978639648, 0.5087980230791027, 0.28811453943100984, 0.2894096287992648, 0.6421221712546823, 0.4504813602038843, 0.41627129577997335, 0.26853137703895535, 0.30900892544163894, 0.2072532635361748, 0.1956285958738493, 0.304319112025208, 0.21775105033263442, 0.12442099260453054, 0.3693575646612153, 0.21385525720350185, 0.21156600240549472, 0.24677674558337825, 0.2133169043736679, 0.20452397270782752, 0.2237408294036065, 0.23616731267375257, 0.22199060291440187, 0.23774117833621522, 0.19447483652371045, 0.2070073418830981, 0.18317662032627013, 0.20493964012096222, 0.19301443736084556, 0.20735119038808247, 0.6922611583310765, 0.19427733446077955, 0.1970874892875044, 0.16470733211852806, 0.8769473058432168, 0.19533638968326483, 0.1863016141336269, 0.18643851777221976, 0.1857156305990355, 0.1684215544499713, 0.8715923396266874, 0.8708743426370747, 0.49622714779592847, 0.8038695170572907, 0.6481769793760409, 0.6878120573555526, 0.16437606911500602, 0.20862788816968048, 0.19431934911747006, 0.18888912016051385, 0.2857554793101098, 0.1993037432232836, 0.20805112736109166, 0.188540532112915, 0.19506432787036976, 0.19202329056609246, 0.18389005135017888, 0.19466622521270205, 0.2118475762220975, 0.18371992571964224, 0.1099481524688154, 0.09216725530237202, 0.10089886279907789, 0.09243021265352558, 0.10195011001871357, 0.13050673667653934, 0.09287069911299128, 0.09747382818395323, 0.08587348310777432]}, "mutation_prompt": null}
{"id": "79f6d6fe-67fd-45e4-827e-054bb7f64b3e", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        diversity = np.mean(np.std(self.swarm, axis=0))\n        adaptive_f = self.f * (1.1 if diversity > 0.5 else 0.9)\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + adaptive_f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances convergence by introducing adaptive mutation factor scaling in DE based on population diversity.", "configspace": "", "generation": 12, "fitness": 0.2962129498751238, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8710273245964639, 0.8771439762363596, 0.8854953031106869, 0.8916938697094636, 0.8657553106715962, 0.8684710671388164, 0.1825856751645092, 0.8788186907660464, 0.8865107712093815, 0.7315322611901014, 0.042938979031411195, 0.7168173882378526, 0.7713220404684102, 0.7616580673266882, 0.7461410737539931, 0.05133856264518122, 0.7568496820105375, 0.7143423878045672, 0.1760021563107137, 0.1537930501094088, 0.1505806071158804, 0.13939473561445526, 0.1439048948173951, 0.17735992080832708, 0.11329612293778935, 0.048423385517386675, 0.17432163237496023, 0.1503761101406761, 0.1326082985327537, 0.10324774279067062, 0.10373214843364509, 0.11055301502444859, 0.09644842206962934, 0.11170924363345058, 0.12737105558563144, 0.11406669990855567, 0.9891710792357551, 0.9874914197018662, 0.9811521127219298, 0.9838610405827104, 0.9901844271194, 0.9877250785293332, 0.9907001167556125, 0.9904747620294464, 0.9902027642728819, 0.059629355813025864, 0.059857322057084494, 0.7263089047738592, 0.6921112595716798, 0.15041848990757622, 0.15245324240535063, 0.7307293527902294, 0.7059854391494319, 0.08812354375303255, 0.7900943240975, 0.3609680795995118, 0.16984162603996922, 0.2787356023120957, 0.19094556228016168, 0.2070947302021876, 0.17556165708137783, 0.8509834542666201, 0.8059258913347104, 0.15308418220601083, 0.2352685046914872, 0.24161462706756853, 0.2623357608770249, 0.23181041106108946, 0.2243414349720283, 0.20693441418354752, 0.1315588834031297, 0.13062806921091918, 0.2324922582412482, 0.010069194915340085, 0.25014181974949456, 0.2662807735152525, 0.13084215461370163, 0.2338824605483001, 0.2690072018555172, 0.1283890828508789, 0.15062419854725118, 0.0012286048652567771, 9.999999999998899e-05, 0.00041401039631405734, 0.0003442224181633424, 9.999999999998899e-05, 0.05244537102970459, 0.0035702163052979685, 9.999999999998899e-05, 0.005091593454357279, 0.06367946422321857, 0.08660518970239595, 0.08511903276428934, 0.08124472389808013, 9.999999999998899e-05, 0.002136628803666496, 0.014716635849656101, 0.007777536278556152, 0.054884746907954085, 0.16718841602167034, 0.04959230526518221, 0.13434969357529247, 0.07729538834904703, 0.10264351104049552, 0.1404221911140081, 0.09943561309904092, 0.09928602262719866, 0.09753027170519724, 0.07770281487367192, 9.999999999998899e-05, 0.1617405373768419, 0.038218804282134755, 0.03595333024219871, 0.17721437898406733, 0.08610006211795229, 0.04884413119266795, 0.08401684081637084, 0.5381629436887991, 0.5929489251354858, 0.6641363169141671, 0.6156886803617074, 0.620411015441968, 0.5756988600143428, 0.620349482577211, 0.5943074268081542, 0.570573641761915, 0.07293577419895592, 0.10632859881758372, 0.092499012390164, 0.13981735587291555, 0.11789648742695646, 0.08918987753859897, 0.07799709988982018, 0.13847353115424643, 0.095131934490441, 0.1502139681160184, 0.19048768475544597, 0.2659988154525499, 0.18519543904970293, 0.2627213551797014, 0.1833177262712683, 0.22493400630682037, 0.2015477548369753, 0.15259582581608522, 0.44840342856628357, 0.42318400630367237, 0.3386645720460497, 0.19239811243804794, 0.21281606116101326, 0.2834750503327744, 0.42144833389188285, 0.5844075420997342, 0.6225354507362387, 0.30170961722209755, 0.21587163892461336, 0.1992473609846962, 0.19411328084503499, 0.23001322407509972, 0.21199111124707437, 0.23816783057603508, 0.22517159157292976, 0.2117256610998961, 0.21295139723399426, 0.22117250294482804, 0.22179068886873288, 0.19781270522681216, 0.18685073940801245, 0.20627703670709696, 0.20145480138864846, 0.22156098702936355, 0.21987173621478573, 0.20496007333320188, 0.7952120945676261, 0.21294754497587876, 0.2514043277668141, 0.1775225644880558, 0.18391004365501218, 0.17554675881052828, 0.21781312316701273, 0.18951406950920247, 0.16492229005509396, 0.16483099954836855, 0.16169226018054017, 0.17616133201158535, 0.17837904865475285, 0.8948542170893954, 0.19962287208996732, 0.8859156528607744, 0.18430939101778399, 0.7139843830025925, 0.7121576462007184, 0.659017116056059, 0.11306328181146841, 0.2089444576399434, 0.28210625639217213, 0.19378265964286645, 0.21170182542019333, 0.8197320743414037, 0.20151658150994878, 0.19050237980802387, 0.18799547259095362, 0.17048387688489652, 0.18400188867912737, 0.18393333830429992, 0.1823983939042505, 0.18761588401252682, 0.18745709095043017, 0.09321580040740174, 0.09000957428204004, 0.08583721770593289, 0.0813200612580447, 0.09318705260067506, 0.11908947828828809, 0.08831500191495634, 0.1001900396455574, 0.0953136333049952]}, "mutation_prompt": null}
{"id": "a24514c4-eec1-4020-b921-3d1210f6703a", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            random_search = np.random.normal(0, 0.1, self.dim) * (self.global_best - self.swarm[i])\n            self.velocities[i] += random_search\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances exploration by introducing random search steps based on global best influence.", "configspace": "", "generation": 13, "fitness": 0.2994229704087765, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8815875184833073, 0.8828746749859951, 0.8736682339841741, 0.8832404738746648, 0.8710563362926875, 0.8945141551197674, 0.8827076461321696, 0.8784914961440928, 0.8794417012606034, 0.7450542270303853, 0.7512306551280978, 0.5996102286523141, 0.7533200118981855, 0.04723494042991083, 0.745806993112208, 0.7214357631724027, 0.7736107658453564, 0.7127149376568107, 0.15965560049715477, 0.10387601739656527, 0.6011876898623361, 0.1786490770807544, 0.11450550266296855, 0.12114375213080508, 0.06686207441901426, 0.14025075110223284, 0.1746962526347856, 0.10569364286560612, 0.11164458428975232, 0.1742040274321256, 0.1354952222022333, 0.12699238361438858, 0.10517911371734823, 0.13220581752972793, 0.15466529573363896, 0.15410930082493746, 0.9853154742964115, 0.9859895904138802, 0.9884839998544388, 0.9862668498180369, 0.985999785583071, 0.9841128310990693, 0.9901699305116319, 0.990336992892553, 0.9913473656674936, 0.7407200267811604, 0.05939027409068298, 0.7300050002584101, 0.7342568972751362, 0.6568262848774671, 0.7380361769351858, 0.08823369850096663, 0.050757372796158995, 0.7210029965713944, 0.2097985505759511, 0.2064861866951906, 0.22361826914430738, 0.189763905550558, 0.3523046694412306, 0.18728161509149988, 0.07937959331264177, 0.23196211811744583, 0.11942563326071953, 0.2383228933995053, 0.2458026275805526, 0.2323223397099129, 0.1307072863429748, 0.12929827616580192, 0.34606302007538003, 0.23240031926006732, 0.24275363681439555, 0.12520508196530988, 0.22817251074602163, 0.11993724142184725, 0.25011113428460663, 0.123141531956654, 0.2462667974223567, 0.24171082928793752, 0.10348380483828401, 0.26664527025145557, 0.09842341656191589, 0.07264704633514107, 9.999999999998899e-05, 0.005521319041137618, 0.007185127763181476, 0.024245606681633447, 9.999999999998899e-05, 0.009303102900685922, 9.999999999998899e-05, 9.999999999998899e-05, 0.0795418910025959, 0.10070601211049357, 0.07058318837316424, 0.045960122472500586, 0.04702608780798201, 0.11552888968189401, 0.03720412265435513, 0.03849879470262929, 0.15248904105821115, 0.05079068890668115, 0.15025716660037758, 0.035192706376906635, 0.07680658595619205, 0.07704934729326629, 0.1459643083498937, 0.09897924467011376, 0.24398981135283926, 0.13805516927015837, 0.07451928380669393, 0.04177977244645026, 9.999999999998899e-05, 9.999999999998899e-05, 0.15174064681865507, 0.006638071551614333, 0.09604431695300186, 0.08239377915969925, 0.0841282001688427, 0.5725748458622559, 0.5975558693230212, 0.591004001272674, 0.579849426158429, 0.569152286048153, 0.5579717492652014, 0.5733386185644338, 0.5546516092853663, 0.603226786764826, 0.12158413562332482, 0.11259882677730315, 0.10751056994287334, 0.1397890602016425, 0.14809234668053772, 0.12856478424312223, 0.09562106568995132, 0.15671849740262955, 0.1282517376383121, 0.15082679369206475, 0.18485229690860605, 0.23497918820859198, 0.17708303257704572, 0.2681506495046373, 0.28032842041210737, 0.16915298279407676, 0.1624814436916886, 0.2719369763275691, 0.3065852088247847, 0.5359126755423294, 0.25602751802093093, 0.4344276961549446, 0.4926129678434771, 0.27464385664855373, 0.5740035921187854, 0.534714147498023, 0.5810296500199925, 0.3390554996083265, 0.22107407390588496, 0.2098871220153945, 0.1987887024048105, 0.19788544658968776, 0.19081891347969537, 0.2148599232955093, 0.1497847954467032, 0.3206574962048059, 0.21946823143611205, 0.1911676570034292, 0.2231645198229042, 0.20446399962317696, 0.19984751615909868, 0.23231865097791726, 0.20753626721665386, 0.21084391409035574, 0.23312171828062345, 0.2248356306514243, 0.2159075739779004, 0.23977016166408693, 0.6936978769975171, 0.22373433247408514, 0.19958993845938744, 0.2178384291258716, 0.24467658209891874, 0.2482233344949869, 0.1652194850071006, 0.8412129333243166, 0.8826124007327104, 0.17775649580767017, 0.1878787925240527, 0.18802093079681226, 0.16484850139712615, 0.16541802574103115, 0.15809426307847885, 0.2098292715822666, 0.6671559197031482, 0.11218998141774306, 0.6556372670397277, 0.20990359580360884, 0.11095281850631322, 0.1989570829038373, 0.2125746869549362, 0.20101658229015795, 0.1896283510862925, 0.19963881935453642, 0.20590499287502317, 0.19909282846282816, 0.19495014843092773, 0.21582476631553216, 0.21239563810653617, 0.21625048012211223, 0.19257027474422628, 0.1013719244729937, 0.10321657167070075, 0.08486932783985102, 0.09160972168509374, 0.07829750212390174, 0.09747179145414431, 0.10284272400808026, 0.08186930034159301, 0.08942736458861944]}, "mutation_prompt": null}
{"id": "ecaae1b5-7fcf-4bdf-88dd-4fb6e870b84d", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.f = 0.5 + (0.5 * np.std(self.swarm) / np.sqrt(self.dim))  # Dynamic DE mutation factor\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances exploration by dynamically adjusting the DE mutation factor based on swarm diversity.", "configspace": "", "generation": 14, "fitness": 0.2910180392289754, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.28.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8849675597526493, 0.8627918482116617, 0.8905702593054671, 0.8706795396708229, 0.8446736672527783, 0.8839329374973847, 0.8880701642644675, 0.17522394410750697, 0.8743542734824342, 0.7572334773704561, 0.7506575400095727, 0.7268073811476405, 0.754264059437605, 0.741683105416407, 0.0644403788411253, 0.7370626723913711, 0.7528684803748625, 0.7333479427563461, 0.11420224693883774, 0.17486155514796808, 0.12154387504849151, 0.15918221169261737, 0.061513676574583176, 0.1579295993689388, 0.13267782780070814, 0.14440154162493513, 0.10794776299559761, 0.09829374206834562, 0.1537178079337005, 0.09560068529645194, 0.131490380922045, 0.09976545391940983, 0.10524458689134752, 0.14223150894492542, 0.17594050689469876, 0.07694015043915536, 0.988543339006761, 0.9875822898211588, 0.9834522237134126, 0.9903252735357015, 0.993514209125915, 0.9876603468165237, 0.9935666096728086, 0.9912031146335122, 0.9925625174211503, 0.7560865883296181, 0.7203013106117359, 0.058595077233225656, 0.14876286250457338, 0.7414876791049109, 0.15004727383959748, 0.08863245034603262, 0.6930267357769784, 0.08831043112422232, 0.8178034197992853, 0.12825656834204346, 0.37198705220866823, 0.20835532831844317, 0.1918756923387901, 0.19250617090928124, 0.8573918783768049, 0.861372762867978, 0.23085013955813927, 0.2318880824685452, 0.24943416427683318, 0.24964485210266052, 0.12979401448643368, 0.2330009226104739, 0.10476958023159333, 0.24121712785935967, 0.22846037942098363, 0.23249734772919883, 0.2568196112324327, 0.05077584318934458, 0.2384516950340524, 0.27294751138598616, 0.2411678282041878, 0.24629694831498194, 0.2804741032794206, 0.2742165038875827, 9.999999999998899e-05, 0.000776787692675529, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004898350774461546, 0.08397163050212453, 0.033373000689781995, 0.07391258637262399, 0.02196595542655211, 0.11725994178159838, 0.05120277866136025, 0.052465709963549156, 0.07941088935663998, 0.011914657443004573, 0.06840218748421156, 0.04894006192684064, 0.04750201719268354, 0.18859514247747833, 0.1540524874887247, 0.13462613412777014, 9.999999999998899e-05, 9.999999999998899e-05, 0.103111144267095, 0.2105922841103629, 9.999999999998899e-05, 0.31052435982444826, 0.269373193866573, 0.03915103832695732, 0.06829213475047868, 0.04870214691054575, 0.053643633705622085, 0.08204482443714511, 0.5407597760919836, 0.5528117811391753, 0.5617703014797932, 0.6041039627040177, 0.5918477364463826, 0.5452908124101297, 0.5538906797091991, 0.5595667798894625, 0.6007271607544217, 0.15292544538808617, 0.11472896269331234, 0.10634114995676536, 0.10831639096212697, 0.1221824973487301, 0.1068747565552034, 0.11223727503722636, 0.13004661729657097, 0.11818555671362174, 0.16400241206808985, 0.18582994001755637, 0.17441411434734477, 0.17890143789711233, 0.1531793238002117, 0.1912509257829047, 0.17965104617940142, 0.3182426539859976, 0.24904416641866056, 0.5086533674185971, 0.23749086736070846, 0.6707802589946351, 0.2193196573120848, 0.22002885506535919, 0.2930336527207914, 0.6231284658431913, 0.2067108325900866, 0.3987502650668461, 0.23514100099368784, 0.27938580343073116, 0.38245645177327325, 0.19106803432824027, 0.14570507389683462, 0.1585561601397858, 0.17423596172553701, 0.14892880967311395, 0.4603493993960718, 0.19100991427556524, 0.1854321064018093, 0.23501229890528585, 0.21254375793531355, 0.17810237292405784, 0.2159154033012195, 0.21187074986196208, 0.21063699418618342, 0.2633139228403455, 0.18942096597762814, 0.24566682403137197, 0.21041952803360486, 0.2215109127480971, 0.22009324987563927, 0.2035286313773308, 0.20830817309845373, 0.18136497895628867, 0.72248660770428, 0.18742702797556066, 0.16487212057150136, 0.1729937111765636, 0.1858917264906027, 0.18656748133517498, 0.1869655332448351, 0.16872267780953842, 0.18619521078685497, 0.1714566838949909, 0.1149813499456579, 0.686259828789146, 0.7876313305767548, 0.15964149053617605, 0.13941527904694972, 0.6682738133395196, 0.19813812529941122, 0.18458197328871917, 0.1269098440900378, 0.20213427986032706, 0.17841116446182093, 0.2024442326033844, 0.18637649717276228, 0.1850709767329065, 0.1897272242541732, 0.19971947187957328, 0.1902511066202235, 0.22513576300373528, 0.09085258005287411, 0.0839443309387089, 0.0809604410980923, 0.09884897506201273, 0.09325340105530244, 0.09401993620480698, 0.08705537327421897, 0.08636175705361127, 0.09249300398570381]}, "mutation_prompt": null}
{"id": "f5beca87-7542-428f-ad65-ebefacb3d62e", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            diversity = np.std(self.swarm, axis=0).mean()\n            if diversity < 0.1:  # Dynamic switch based on population diversity\n                for i, trial in self.differential_evolution():\n                    if self.func_evals >= self.budget:\n                        break\n                    trial_score = func(trial)\n                    self.func_evals += 1\n                    if trial_score < self.personal_best_scores[i]:\n                        self.personal_best[i] = trial\n                        self.personal_best_scores[i] = trial_score\n                        if trial_score < self.global_best_score:\n                            self.global_best = trial\n                            self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Optimizes function evaluations by introducing a dynamic switch between PSO and DE based on population diversity.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {}, "mutation_prompt": null}
{"id": "06574ad4-78b9-4877-826b-1eed5472a3db", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improves balance between exploration and exploitation through adaptive adjustment of cognitive and social components.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8836075720745684, 0.8981403389935606, 0.880100413439386, 0.8960334767078061, 0.8964817377859402, 0.8900342821667296, 0.8648005832441995, 0.87287832029994, 0.8904418417329802, 0.7562978871456798, 0.7374053967074378, 0.5352653834078299, 0.758601983182168, 0.7469450232215638, 0.7496864088191351, 0.6865190847318863, 0.6446671169643694, 0.05259381128160989, 0.18254616079917518, 0.1326018337991851, 0.17272160717618268, 0.09818923216040198, 0.5793396545174577, 0.18320177011657424, 0.12706300673588777, 0.10605589688772632, 0.6734534510083137, 0.12330755222642453, 0.09321592187627792, 0.1288727640458035, 0.11307471452068052, 0.1698402563108934, 0.12872109070029636, 0.1413147693426292, 0.10543959410142945, 0.1362090611659973, 0.9891948600799025, 0.9904662395558373, 0.9797686308234222, 0.983774113743326, 0.9910818640124301, 0.9876499942543007, 0.9871158231585849, 0.9904049243381535, 0.9905154257201639, 0.05937951939605213, 0.05978090340367903, 0.7153316310676052, 0.15028470844283914, 0.15015625600022375, 0.1532250785932907, 0.7358955880432775, 0.0869643219221834, 0.08790523534411698, 0.223663500184886, 0.2261375154958004, 0.835885737060374, 0.19367433182422433, 0.27876145538014885, 0.19212964459287818, 0.8737170292535832, 0.1272899283324821, 0.17659933981230447, 0.17527486522830027, 0.24216938795318332, 0.23324417981319545, 0.23131281896858058, 0.10273568061610949, 0.23881550285697584, 0.23961153995668372, 0.2494274576779304, 0.23185364673090259, 0.23012290780896183, 0.11843681280639617, 0.25986568286473066, 0.2517907411166842, 0.27717074775591477, 0.2645291858534957, 9.999999999998899e-05, 0.2528571215595664, 0.251979290671856, 0.0061814348541072706, 9.999999999998899e-05, 0.0033411079100623686, 9.999999999998899e-05, 0.009868740107869423, 9.999999999998899e-05, 9.999999999998899e-05, 0.00235566763275763, 0.06426397011842289, 0.06538085497584856, 0.05581578588944325, 0.08596146211923061, 0.04088118134421581, 0.010769388628100729, 0.038219385113574256, 0.10756294181631221, 0.12130901994451981, 0.06435726128303254, 0.09035430639898057, 0.034334930639006944, 9.999999999998899e-05, 0.33214679540074, 0.07713983174775729, 0.39309863716189564, 0.16606623824612365, 0.09909314999036012, 0.12252518372659793, 0.12751745504052592, 0.08330430136037903, 0.04193068962506963, 0.03808970913960874, 9.999999999998899e-05, 0.2431861427708769, 0.08143203037247515, 0.08497580064352239, 0.10833327858527209, 0.5487281674465889, 0.6232866170502139, 0.5521999890528677, 0.5502217465804353, 0.5836809497098641, 0.547787580106923, 0.6108185666949636, 0.5805898731817607, 0.5781123952150873, 0.136271877392094, 0.10632524515406672, 0.07664740902126943, 0.11098850682643202, 0.13333274170949294, 0.10714753483309158, 0.1412085510839024, 0.10438819129228982, 0.1287110203703401, 0.1805879235831439, 0.34163853145268974, 0.24592064893829457, 0.1635479300245124, 0.1543550363258428, 0.17802628150205313, 0.17090430961770597, 0.1889545708995738, 0.1624893111398873, 0.35491358923841265, 0.2317213580474936, 0.3384840579374848, 0.20522180978639648, 0.5087980230791027, 0.28811453943100984, 0.2894096287992648, 0.6421221712546823, 0.4504813602038843, 0.41627129577997335, 0.26853137703895535, 0.30900892544163894, 0.2072532635361748, 0.1956285958738493, 0.304319112025208, 0.21775105033263442, 0.12442099260453054, 0.3693575646612153, 0.21385525720350185, 0.21156600240549472, 0.24677674558337825, 0.2133169043736679, 0.20452397270782752, 0.2237408294036065, 0.23616731267375257, 0.22199060291440187, 0.23774117833621522, 0.19447483652371045, 0.2070073418830981, 0.18317662032627013, 0.20493964012096222, 0.19301443736084556, 0.20735119038808247, 0.6922611583310765, 0.19427733446077955, 0.1970874892875044, 0.16470733211852806, 0.8769473058432168, 0.19533638968326483, 0.1863016141336269, 0.18643851777221976, 0.1857156305990355, 0.1684215544499713, 0.8715923396266874, 0.8708743426370747, 0.49622714779592847, 0.8038695170572907, 0.6481769793760409, 0.6878120573555526, 0.16437606911500602, 0.20862788816968048, 0.19431934911747006, 0.18888912016051385, 0.2857554793101098, 0.1993037432232836, 0.20805112736109166, 0.188540532112915, 0.19506432787036976, 0.19202329056609246, 0.18389005135017888, 0.19466622521270205, 0.2118475762220975, 0.18371992571964224, 0.1099481524688154, 0.09216725530237202, 0.10089886279907789, 0.09243021265352558, 0.10195011001871357, 0.13050673667653934, 0.09287069911299128, 0.09747382818395323, 0.08587348310777432]}, "mutation_prompt": null}
{"id": "58e92c28-8110-4b3b-8bd0-a9fdd4faf501", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial + 0.1 * np.random.randn(self.dim)  # Mutation on global best\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i] + 0.1 * np.random.randn(self.dim)  # Mutation on global best\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhances solution diversity by incorporating a mutation mechanism to update global best solutions.", "configspace": "", "generation": 17, "fitness": 0.23189252301513014, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.5313749017954448, 0.5265467860442554, 0.505709567764911, 0.4842693898274255, 0.44301575881713573, 0.49666093443789294, 0.4938643552876121, 0.4855307794840945, 0.4927542477784307, 0.11259864693707111, 0.06432427526385087, 0.06199016166238702, 0.14083882768654699, 0.0927439417776843, 0.0596191797495369, 0.045300858383073184, 0.09982433131242474, 0.07316336414715585, 0.15486072091449699, 0.1477233041546795, 0.11499898913561923, 0.1375778254574327, 0.13471608269513835, 0.10651797596398815, 0.12801418543224152, 0.14363201586567176, 0.16376886393847867, 0.1185466201503097, 0.11297607948113186, 0.10632801399575653, 0.14287107165560697, 0.10416259287883856, 0.10594597254803939, 0.10699350774823291, 0.1265580211609315, 0.10236615394421933, 0.9871332597570157, 0.9837145948442676, 0.9830313291861346, 0.9872738740364737, 0.9906628602381747, 0.98659315046682, 0.985418560353004, 0.9863740400870336, 0.9902110539446228, 0.3310493365653646, 0.32765083350072033, 0.3158058437335458, 0.30433419696270525, 0.32011959263753464, 0.3045530557988232, 0.33026167373925497, 0.31461936245614197, 0.299426200305428, 0.317575318939773, 0.20589478655474835, 0.8806974352892935, 0.5450994679933142, 0.27150891336160543, 0.216778275858725, 0.21299968091319643, 0.33870288215318, 0.13094183006942295, 0.14486688304693984, 0.12488298552587185, 0.2752257623771921, 0.17191517467818773, 0.14968024294470228, 0.15857889072628317, 0.15478101187012727, 0.16437714529974568, 0.16594339329153185, 0.04942967836850132, 0.1279035698205102, 0.12631821910677266, 0.15909733788004854, 0.16970806087956802, 0.18629822132458462, 0.16241325431953224, 0.1901243347488607, 0.17749061719850867, 0.009834580493217948, 9.999999999998899e-05, 0.00014378490606303806, 9.999999999998899e-05, 9.999999999998899e-05, 0.002078803783425065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03907393426703587, 0.06078100895765315, 0.15909359176110716, 0.013179817064296051, 0.03737921237135866, 0.017305015518476075, 0.007864913935964113, 0.04715970801536018, 0.016752656189946924, 9.999999999998899e-05, 0.019173163642053792, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000250457601210341, 0.12157039780482615, 0.046339989134355664, 0.10735889846389346, 0.14661894991681546, 0.08874484548051675, 0.08273713900900581, 0.07279757856177493, 0.053796067531267866, 0.09693120304237857, 0.4365521423138182, 0.4981318724892786, 0.43073516628576203, 0.4629834919200321, 0.45169624949337916, 0.4407871299521082, 0.45835223478907094, 0.42582315687415395, 0.43032799975836256, 0.14628905426451166, 0.12134750402657357, 0.11579819805594249, 0.09720052506776578, 0.1311001045082839, 0.12514317751348536, 0.12072310545125697, 0.12120845275661762, 0.10369760565768138, 0.26759278999317304, 0.29318699261424686, 0.1515976223601554, 0.16083980955932908, 0.21059128150410167, 0.2420453910720718, 0.16067673255940973, 0.2155807338975645, 0.18920329907980082, 0.3174207667316379, 0.24866345415808067, 0.33592980121396876, 0.29714284740248653, 0.22319746644185745, 0.24157811370922777, 0.32058484245282415, 0.304406700304215, 0.3025793648794779, 0.25487077312535267, 0.22348057137513055, 0.17718370478678258, 0.18358147171135986, 0.2608926476739861, 0.25468025996374444, 0.2508436528895408, 0.21301730893988446, 0.20280980712549335, 0.2296402621467345, 0.190576347141443, 0.20120524500386638, 0.18122763955448162, 0.20630622633743612, 0.19897596280813457, 0.2119407436973072, 0.18795994888431033, 0.23393628983205117, 0.2149022447679404, 0.3010006116946693, 0.2204801193288275, 0.20483648919906194, 0.21231185180691647, 0.2329289597870674, 0.3179180979078077, 0.32311953889832323, 0.21579436908655303, 0.17167245001646902, 0.6274568162691467, 0.17647300440629166, 0.1782024716978956, 0.18856778725455525, 0.17816939596247539, 0.12566949545756123, 0.664797875223504, 0.200055683244031, 0.2107566658068768, 0.16880880605913295, 0.20955140660028815, 0.5049185126837181, 0.4363152167779518, 0.5719178973963037, 0.208992108572864, 0.5157552613326826, 0.16749557085510847, 0.19153443244330048, 0.1916484898715719, 0.17758022803854367, 0.18250672986442484, 0.20323053841439442, 0.18587193361972454, 0.1823814794806804, 0.17644587606536954, 0.188652822986215, 0.08421632734236062, 0.08611815705429748, 0.08618428731299099, 0.08621886615080299, 0.091582576053575, 0.07425947080569673, 0.08371740130952043, 0.0892621463293588, 0.09024024003896625]}, "mutation_prompt": null}
{"id": "a2de8941-337e-4ea4-86f8-6dc0aac9f4ca", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5   # Inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            # Adaptive update for c1 and c2 based on function evaluations\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improves balance between exploration and exploitation through adaptive adjustment of cognitive and social components.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8836075720745684, 0.8981403389935606, 0.880100413439386, 0.8960334767078061, 0.8964817377859402, 0.8900342821667296, 0.8648005832441995, 0.87287832029994, 0.8904418417329802, 0.7562978871456798, 0.7374053967074378, 0.5352653834078299, 0.758601983182168, 0.7469450232215638, 0.7496864088191351, 0.6865190847318863, 0.6446671169643694, 0.05259381128160989, 0.18254616079917518, 0.1326018337991851, 0.17272160717618268, 0.09818923216040198, 0.5793396545174577, 0.18320177011657424, 0.12706300673588777, 0.10605589688772632, 0.6734534510083137, 0.12330755222642453, 0.09321592187627792, 0.1288727640458035, 0.11307471452068052, 0.1698402563108934, 0.12872109070029636, 0.1413147693426292, 0.10543959410142945, 0.1362090611659973, 0.9891948600799025, 0.9904662395558373, 0.9797686308234222, 0.983774113743326, 0.9910818640124301, 0.9876499942543007, 0.9871158231585849, 0.9904049243381535, 0.9905154257201639, 0.05937951939605213, 0.05978090340367903, 0.7153316310676052, 0.15028470844283914, 0.15015625600022375, 0.1532250785932907, 0.7358955880432775, 0.0869643219221834, 0.08790523534411698, 0.223663500184886, 0.2261375154958004, 0.835885737060374, 0.19367433182422433, 0.27876145538014885, 0.19212964459287818, 0.8737170292535832, 0.1272899283324821, 0.17659933981230447, 0.17527486522830027, 0.24216938795318332, 0.23324417981319545, 0.23131281896858058, 0.10273568061610949, 0.23881550285697584, 0.23961153995668372, 0.2494274576779304, 0.23185364673090259, 0.23012290780896183, 0.11843681280639617, 0.25986568286473066, 0.2517907411166842, 0.27717074775591477, 0.2645291858534957, 9.999999999998899e-05, 0.2528571215595664, 0.251979290671856, 0.0061814348541072706, 9.999999999998899e-05, 0.0033411079100623686, 9.999999999998899e-05, 0.009868740107869423, 9.999999999998899e-05, 9.999999999998899e-05, 0.00235566763275763, 0.06426397011842289, 0.06538085497584856, 0.05581578588944325, 0.08596146211923061, 0.04088118134421581, 0.010769388628100729, 0.038219385113574256, 0.10756294181631221, 0.12130901994451981, 0.06435726128303254, 0.09035430639898057, 0.034334930639006944, 9.999999999998899e-05, 0.33214679540074, 0.07713983174775729, 0.39309863716189564, 0.16606623824612365, 0.09909314999036012, 0.12252518372659793, 0.12751745504052592, 0.08330430136037903, 0.04193068962506963, 0.03808970913960874, 9.999999999998899e-05, 0.2431861427708769, 0.08143203037247515, 0.08497580064352239, 0.10833327858527209, 0.5487281674465889, 0.6232866170502139, 0.5521999890528677, 0.5502217465804353, 0.5836809497098641, 0.547787580106923, 0.6108185666949636, 0.5805898731817607, 0.5781123952150873, 0.136271877392094, 0.10632524515406672, 0.07664740902126943, 0.11098850682643202, 0.13333274170949294, 0.10714753483309158, 0.1412085510839024, 0.10438819129228982, 0.1287110203703401, 0.1805879235831439, 0.34163853145268974, 0.24592064893829457, 0.1635479300245124, 0.1543550363258428, 0.17802628150205313, 0.17090430961770597, 0.1889545708995738, 0.1624893111398873, 0.35491358923841265, 0.2317213580474936, 0.3384840579374848, 0.20522180978639648, 0.5087980230791027, 0.28811453943100984, 0.2894096287992648, 0.6421221712546823, 0.4504813602038843, 0.41627129577997335, 0.26853137703895535, 0.30900892544163894, 0.2072532635361748, 0.1956285958738493, 0.304319112025208, 0.21775105033263442, 0.12442099260453054, 0.3693575646612153, 0.21385525720350185, 0.21156600240549472, 0.24677674558337825, 0.2133169043736679, 0.20452397270782752, 0.2237408294036065, 0.23616731267375257, 0.22199060291440187, 0.23774117833621522, 0.19447483652371045, 0.2070073418830981, 0.18317662032627013, 0.20493964012096222, 0.19301443736084556, 0.20735119038808247, 0.6922611583310765, 0.19427733446077955, 0.1970874892875044, 0.16470733211852806, 0.8769473058432168, 0.19533638968326483, 0.1863016141336269, 0.18643851777221976, 0.1857156305990355, 0.1684215544499713, 0.8715923396266874, 0.8708743426370747, 0.49622714779592847, 0.8038695170572907, 0.6481769793760409, 0.6878120573555526, 0.16437606911500602, 0.20862788816968048, 0.19431934911747006, 0.18888912016051385, 0.2857554793101098, 0.1993037432232836, 0.20805112736109166, 0.188540532112915, 0.19506432787036976, 0.19202329056609246, 0.18389005135017888, 0.19466622521270205, 0.2118475762220975, 0.18371992571964224, 0.1099481524688154, 0.09216725530237202, 0.10089886279907789, 0.09243021265352558, 0.10195011001871357, 0.13050673667653934, 0.09287069911299128, 0.09747382818395323, 0.08587348310777432]}, "mutation_prompt": null}
{"id": "d636462f-887d-410b-b869-3b6c13f81a98", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0  # Cognitive component initial\n        self.c2_initial = 2.0  # Social component initial\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w_initial = 0.9   # Initial inertia weight\n        self.w_final = 0.4     # Final inertia weight\n        self.f = 0.8   # DE mutation factor\n        self.cr = 0.9  # DE crossover probability\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        progress = self.func_evals / self.budget\n        self.w = self.w_initial - progress * (self.w_initial - self.w_final)  # Dynamic inertia weight\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance hybrid PSO-DE optimizer by dynamically adjusting inertia weight for better exploration-exploitation balance.", "configspace": "", "generation": 19, "fitness": 0.2045659147453478, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.5667737015671589, 0.5482575611061344, 0.5905991260322294, 0.5931240214738431, 0.6413843886031194, 0.6424144140486778, 0.1784993829584428, 0.5936852897648537, 0.5536564636122662, 0.3261202282589031, 9.999999999998899e-05, 0.3007783293151427, 0.2750461948302688, 0.21408684541312628, 0.2974320808229033, 0.03380741727718828, 0.31202931863827543, 0.3402426492462981, 0.1325349560056598, 0.09445055298582794, 0.14585433410481363, 0.09766693855196351, 0.08298793007141425, 0.12221078176302358, 0.1071484732053819, 0.11401432895387786, 0.1018880665766646, 0.11626209083010142, 0.1059516930208223, 0.08165485330775335, 0.10533325873884913, 0.042163100660806085, 0.09850796099679826, 0.09084515163545692, 0.08958015213262083, 0.10990369241403475, 0.9896109667084126, 0.9874601752405675, 0.97953916532815, 0.983997233849832, 0.9911345233917327, 0.9909449337634699, 0.993363086795973, 0.9904623884768519, 0.9940749024622503, 0.05696114828738286, 0.055880949417390524, 0.05426139483540393, 9.999999999998899e-05, 0.37086045434078485, 0.13497645128969993, 0.08804437015632283, 0.0780586811622841, 0.048660703659991644, 0.2756006606016079, 0.15749831933111802, 0.20256016376899566, 0.18799627572788447, 0.1109549437001861, 0.1824500835676528, 0.12770705668875526, 0.2375612249555349, 0.163120868815694, 0.13215410702894292, 0.13568528678004854, 0.07075172025101906, 0.09446903457927602, 0.14128620073943143, 0.07218783450312605, 9.999999999998899e-05, 0.139880763227337, 0.14033451204636227, 0.15220958364407033, 0.01901040117863395, 0.16345780157187906, 0.1499630160242137, 0.1180782475556631, 0.09737149593587369, 0.02358092015869029, 0.028357783357403465, 0.0933034168119029, 0.038692421569420765, 0.0011119726507123895, 0.0001196518270532021, 9.999999999998899e-05, 0.024208820415083987, 9.999999999998899e-05, 0.009691366215415331, 9.999999999998899e-05, 9.999999999998899e-05, 0.07792265036227031, 0.06564122475322842, 0.030693560195486636, 0.01156722091351059, 0.01193746708751553, 0.036550284622668516, 0.048069574485222644, 0.05484127825609808, 0.013290350639598714, 0.024911509497738238, 9.999999999998899e-05, 0.019908300357395103, 9.999999999998899e-05, 0.04887303603794768, 9.999999999998899e-05, 0.05280707578508659, 0.052412913685691453, 0.062416708313410174, 0.12828591746858453, 9.999999999998899e-05, 0.029370089859853787, 0.10571920498887832, 9.999999999998899e-05, 0.003913717742001777, 0.06285454206766439, 0.04292892472441712, 0.06099518360906242, 0.4147984520278386, 0.43058393713467125, 0.13937511891253085, 0.4303348584934852, 0.40285833727508247, 0.4104269730539454, 0.43968051308550105, 0.4349291890207887, 0.4241787184071081, 0.08861024503546755, 0.10669724512934486, 0.05948727515525554, 0.123488264094751, 0.09635098510553786, 0.07889807066929477, 0.17914348572532113, 0.07779321529932637, 0.13463845124381513, 0.15459433749538332, 0.20905278158486285, 0.1535300528753042, 0.14343080901599392, 0.16531546837280298, 0.16167559564511502, 0.1418730427324092, 0.19846002354186598, 0.18531559359897287, 0.3250861782472193, 0.22326600258940188, 0.23399062516575164, 0.3449249955707465, 0.1967648433789454, 0.24182495168739626, 0.33282073534082623, 0.33640414979599365, 0.33556500294846725, 0.21375158798791793, 0.1877718365879526, 0.2971608977605241, 0.17282293175885133, 0.16909751842177667, 0.23249140053541928, 0.2012052086900451, 0.21527112177340446, 0.2101255990267329, 0.1805210102364092, 0.1961844891510981, 0.18917375269941572, 0.17341480257987618, 0.17211428991655864, 0.17641335714721684, 0.21857808888492758, 0.19462703834452644, 0.20293525808240087, 0.19014269969074793, 0.20236242980924757, 0.1910478578745678, 0.1801158593107388, 0.16835233121715665, 0.1947442186429622, 0.19654826450092422, 0.18012542918567853, 0.20707876171117134, 0.626874210624655, 0.15307692439892595, 0.17081369351878561, 0.18211134159200149, 0.17307132650329804, 0.18375569771653766, 0.18580849421624157, 0.18080461593487962, 0.6068295718782406, 0.16250874077525257, 0.16691934912260786, 0.1565807594562959, 0.4827203765444188, 0.18541999406976295, 0.19103864305167395, 0.18239488346180754, 0.1853925927971316, 0.5226088717326125, 0.19497404050958256, 0.18409017834064545, 0.1863243086857047, 0.20833533346659538, 0.20136982607219445, 0.17829433722800714, 0.1833601925263112, 0.1905791202798136, 0.19109967300505992, 0.07909201785288222, 0.0772841081800929, 0.08029256009255736, 0.08747703298180165, 0.08217469789939347, 0.09605288404936041, 0.07495614290039898, 0.0754413194074004, 0.07230920936390317]}, "mutation_prompt": null}
{"id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 20, "fitness": 0.3291926302513602, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "03b34e3c-4974-4efc-b530-d8a22252f329", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "2e81bfc3-b9fb-4338-b7e2-c20c354fd5cf", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w_initial = 0.9  # Start with higher inertia weight\n        self.w_final = 0.4    # End with lower inertia weight\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = self.w_initial * (1 - progress) + self.w_final * progress  # Adaptive inertia weight\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce adaptive inertia weight for velocity update to balance exploration and exploitation dynamically.", "configspace": "", "generation": 21, "fitness": 0.21816610310001985, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.5618116844573193, 0.5731010915316824, 0.537584283180766, 0.542823026073378, 0.5396695352939898, 0.5804260036582451, 0.5922206366926361, 0.5516902024209258, 0.36648083759042205, 0.28507045885723725, 0.2435365513441512, 0.33457323811905726, 0.023870415570379167, 0.26926795658125946, 0.3050458692456418, 0.03972399197474319, 0.13765646457296565, 0.03387437995577203, 0.10312362815074083, 0.10652960672328282, 0.11422793093953021, 0.06578602976880155, 0.067333171527442, 0.11053273458362634, 0.12380467416097563, 0.14650594817325913, 0.0970460830898413, 0.07663710871102225, 0.09476629297444983, 0.10626266052060951, 0.11089584169346722, 0.07638002340003824, 0.08764203226545964, 0.0875228895185679, 0.10006187596723193, 0.10657402398029703, 0.9781610898903992, 0.9863417739045842, 0.9879474564926002, 0.9892904579638052, 0.993516068562045, 0.9888247510078739, 0.9893890043542307, 0.9889068717076386, 0.9924554270690193, 0.36914082720511265, 0.34055432301042976, 0.28053981208908707, 0.3664227220988965, 0.38345365914132923, 0.3667348171187116, 0.3054680387827682, 0.20995851836339063, 0.3650349763882932, 0.19136216603093836, 0.18764033043591066, 0.16163073501052516, 0.19013002019050274, 0.17367773773043083, 0.19333376396313284, 0.27490422494152544, 0.12817066065381422, 0.15884926323621928, 0.13555089631284778, 0.1353166809670433, 0.15824234789086, 0.08584459544579126, 0.08238742298319901, 0.15954456237284653, 0.08660318682952417, 0.2419585939748663, 0.15403150717220015, 0.07671869470237602, 0.039654474230500836, 0.12636114973613222, 0.19925782113147372, 0.15505781395468987, 0.14519850467194917, 0.05231327779114203, 0.1612895687929946, 0.13343299644089934, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017241960418593827, 9.999999999998899e-05, 9.999999999998899e-05, 0.02052554560926234, 9.999999999998899e-05, 9.999999999998899e-05, 0.04533244304392792, 0.04035364718357892, 0.07515117732607413, 9.999999999998899e-05, 0.01665041526600819, 0.00913246720890526, 0.032204733900876414, 0.024759276315703627, 0.014883986102128266, 9.999999999998899e-05, 0.024179116374912657, 0.017947563378502673, 0.04246711147646931, 0.049732732005294156, 0.17854336548020766, 0.06125511389036675, 0.05672298250536645, 0.053548626624451034, 0.028384197792555632, 0.02836020870938505, 0.03547150289681844, 0.004350871295115244, 0.10188138027045823, 0.004996000703867298, 0.045343066436339896, 0.06956621208728198, 0.03487530840674735, 0.4193379183835413, 0.30570124511812624, 0.43989550955931467, 0.4131638486931555, 0.42444702950236424, 0.359782943906911, 0.4137356448590034, 0.4387585993484727, 0.420873805185661, 0.07883396286243127, 0.1022185801447868, 0.07826477721328484, 0.08456683013514943, 0.11393727090242334, 0.09357592651075886, 0.0939766431443888, 0.05481659243118209, 0.1113978685796767, 0.16784036485874132, 0.13845449787634212, 0.18956899491405532, 0.24654937864899662, 0.17600520974592238, 0.15317024335293827, 0.16313424206050353, 0.17814614633881953, 0.17928390291600393, 0.3107627052175638, 0.3206830706939531, 0.2648376837776437, 0.2852348154536011, 0.30945975906515577, 0.2441042561494583, 0.3313724024675415, 0.355481671998079, 0.18668710040230563, 0.22831588233142608, 0.2414189217274466, 0.17781288911752435, 0.1609021322766654, 0.20696667865537666, 0.14669746744436474, 0.1344002430405684, 0.19622405539012477, 0.22952130085319078, 0.1837837175925413, 0.2083031861917366, 0.1896939346815314, 0.18893916414049494, 0.19126192532278619, 0.17530031695920656, 0.17983376002203455, 0.18352517553434855, 0.17684130838532364, 0.16962991905472768, 0.17605093715837683, 0.18384590019036517, 0.2147902319627466, 0.2018084231076921, 0.19662609420473198, 0.17717283890256097, 0.20023949985876255, 0.18390316426105813, 0.19830240425026036, 0.16134092511038967, 0.673374924856041, 0.5107830508891746, 0.17252662174729017, 0.18169780058125518, 0.6019528785027493, 0.16989602419212857, 0.16481657045711695, 0.18943851301533932, 0.19041549057840135, 0.20203495813129158, 0.4463906677204037, 0.17719377535922431, 0.569715816137114, 0.16041244337313454, 0.26612665428831717, 0.5389687562707824, 0.21516298253681032, 0.18385159299924148, 0.21407989753491585, 0.20128731856779425, 0.18999986587383977, 0.18528537830269165, 0.20348602156396323, 0.1963186835893035, 0.1905807981973171, 0.08168442246907126, 0.08035222700758315, 0.07794133916455681, 0.0784057869448247, 0.07724633660472113, 0.07408080516957016, 0.08599659814394656, 0.08228428975430413, 0.07315135021048536]}, "mutation_prompt": null}
{"id": "03ec47c9-d3c4-47db-b3fd-2c4e6afef0e9", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        proximity_factor = np.linalg.norm(trial - self.global_best) / (self.upper_bound - self.lower_bound)\n                        for _ in range(int(1 + 4 * (1 - proximity_factor))):  # Dynamic adjustment\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Refine the local search phase by introducing dynamic adjustment of local search intensity based on proximity to the global best.", "configspace": "", "generation": 22, "fitness": 0.30519278865288973, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8795016660549987, 0.8786170164379847, 0.8766809518554883, 0.8834319860907635, 0.877572961416127, 0.8704667666870628, 0.8820650256266468, 0.8728332750354104, 0.8909415453571554, 0.07305439965915361, 0.6868864674740625, 0.6140065559207446, 0.7007971517145263, 0.04655109543020808, 0.7335621525728728, 0.7332167902921792, 0.05640175443250317, 0.7205144419848861, 0.1556402739131303, 0.17825364462067628, 0.14118307799005392, 0.17222028823751567, 0.15167704675322224, 0.11344665175441337, 0.12161500441848871, 0.1338481989509599, 0.15515970616717512, 0.15199186042391688, 0.12065118749380166, 0.13422366960903598, 0.10360166910065383, 0.15514553540260112, 0.11658284754597548, 0.11014410247749584, 0.11831155596918563, 0.10736415251994424, 0.9835469215557828, 0.9808154425341792, 0.9787176413124136, 0.9799268965234996, 0.9898324798975812, 0.9882580597026078, 0.9835385202310967, 0.9858970608414869, 0.9893284959296578, 0.6773252368336502, 0.6857441616778794, 0.6763270505815191, 0.6804062612824493, 0.6981303004073346, 0.714708376500206, 0.725657225051678, 0.6885136164472363, 0.6685759500378313, 0.3778585085275137, 0.21516933832607033, 0.22398514288451343, 0.27453795028402184, 0.1574667907371129, 0.1886856044815738, 0.746917271780592, 0.22401505506127328, 0.38275804157003235, 0.2513297606808016, 0.25045831497744697, 0.12923754257556064, 0.24973156981648437, 0.23462338516803172, 0.13065435327565644, 0.24520960971367223, 0.2730456568951426, 0.2521743425571459, 0.2153492474413311, 0.23031726349010928, 0.23606190874011568, 0.2513155959415939, 0.11758218761024453, 0.2513148690318169, 0.26553861816733393, 0.26870834151316225, 0.24416446974019435, 0.0014130659219535602, 0.059823891083262914, 0.032312814005958534, 0.00036383747958457224, 9.999999999998899e-05, 9.999999999998899e-05, 0.04140204822133475, 9.999999999998899e-05, 9.999999999998899e-05, 0.052889906903341055, 0.06553571824695104, 0.019056555644280215, 0.030227632729749376, 0.00452187391128267, 0.08542747842442477, 0.05177852622708745, 0.07166922750082527, 0.08857806456895179, 0.06597277870763285, 0.07701441565523148, 0.2717254565549355, 0.07482016035365091, 0.13511858643137364, 0.07708618732528938, 0.0972419774116553, 0.11169668267691413, 0.10548565230096973, 0.19764214126376078, 0.06245229368108063, 0.04433957926971066, 0.006336471605422944, 0.03963951966175194, 0.0065638101928429116, 0.22875851873101916, 0.08142695206621997, 0.3128417505458049, 0.5661193442002281, 0.5366624561772266, 0.5564062941207766, 0.5620365994940301, 0.6546586211797749, 0.600221765143971, 0.5637742614949148, 0.5955475883174457, 0.5750707917791461, 0.08811615309628629, 0.14175193617633908, 0.12836316751581722, 0.14664435449320135, 0.12868445295924413, 0.09253339381305048, 0.1096352292681837, 0.16279344436585452, 0.13672654837234166, 0.3333837865832241, 0.25489948257163575, 0.19444451535326024, 0.20100117605005985, 0.14458509951101495, 0.176857569396223, 0.12919404755832453, 0.13496787693545553, 0.3000511482692957, 0.2847000990473967, 0.3326395693586017, 0.4326924586181593, 0.207193084281606, 0.3090601000380282, 0.3100969655262087, 0.6566458616956983, 0.4446705188798694, 0.3354230670369729, 0.2011359355033614, 0.2109499335435847, 0.22075770425913221, 0.1952805939380271, 0.22187782082568042, 0.2025624810046185, 0.27660059926130065, 0.3108193405822972, 0.26928557038417766, 0.2207574945028966, 0.25511658480288035, 0.24234755455704082, 0.23895113893010944, 0.18162014675491833, 0.22759161994190613, 0.22648230049806573, 0.24041821282455345, 0.2344047130445469, 0.2182435095136681, 0.23599324515187114, 0.1868855470388644, 0.19830552996348993, 0.22177355485086025, 0.24531933094399505, 0.18175893020258949, 0.20182174648237683, 0.22343301049889364, 0.17096978326889112, 0.15128201127346597, 0.8944934549980346, 0.19843733710273515, 0.1878918725725155, 0.16408877041671643, 0.15614409473828983, 0.17556413444854568, 0.856862860857833, 0.11224004726037051, 0.1679637065546853, 0.7824482868493735, 0.1268892318935948, 0.16684078929804036, 0.7018602463728089, 0.1661402100590874, 0.2127577073875806, 0.8113593092479358, 0.1830092010918044, 0.20578621351908588, 0.19867100968967621, 0.20563958069378196, 0.22444822352586502, 0.19770082741723494, 0.2057038974396359, 0.19145023305764342, 0.18305044651868485, 0.09476536619039033, 0.23827847515388267, 0.09596032622391382, 0.10054683005708354, 0.08352485225968231, 0.08699073056359885, 0.09915592278480578, 0.13988312254740465, 0.0809097661730106]}, "mutation_prompt": null}
{"id": "1568fabc-c97e-4332-a194-02ee034839e4", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.9 - 0.4 * progress  # Adjust inertia weight dynamically\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance PSO-DE balance by dynamically adjusting inertia weight for better exploration-exploitation trade-off.", "configspace": "", "generation": 23, "fitness": 0.21153263739629158, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.5394327667846935, 0.5311134571929991, 0.45382155483522413, 0.4717077860207247, 0.46142787986199085, 0.45762652841359197, 0.5668706648484243, 0.6081321019634907, 0.44363976898737223, 9.999999999998899e-05, 0.2321861413032995, 0.23304279092324554, 0.03188967719751168, 0.22375673573367272, 0.26794698704784414, 0.03245098392315304, 0.2336271825147035, 0.210305322424174, 0.10602878520954817, 0.09959015878748856, 0.12625017202337474, 0.06682875895445772, 0.10555431040825913, 0.12626076480879178, 0.1377597963374495, 0.12158108962797143, 0.10937114296089223, 0.09812031138718413, 0.07812151989710603, 0.08265225795055153, 0.10819114283671771, 0.08049299308209301, 0.08970286820912698, 0.09752193766596484, 0.09056740543579322, 0.0827312509825211, 0.9781614736052086, 0.986341970103565, 0.9867556384597495, 0.9892907383650358, 0.993516068562045, 0.9888247596029163, 0.9893894023480297, 0.9889076551258639, 0.9924554329071278, 0.3432704933669185, 0.05797426006857731, 0.18034109042845647, 0.13303490434437149, 0.2634423040259045, 0.3710971685587017, 0.1948227453104331, 0.0815446125069218, 0.2693199476916235, 0.26283766339942105, 0.25898985953164155, 0.15586599592886907, 0.2378598716235253, 0.2678077182426498, 0.17394381429181482, 0.23606196065270746, 0.1261770958965608, 0.25103475386503604, 0.08660446746274042, 0.12209535802619698, 0.1226715768372475, 0.09214301769011313, 0.07994261123755986, 0.13838072812864266, 0.08628921262607869, 0.12741051022755634, 0.13304720125258296, 0.03997218721778284, 0.06687437307985655, 0.1083179115757188, 0.13271248641980182, 0.11149227837143294, 0.12226223276616532, 0.0672489353670791, 0.09577828593265458, 0.23437672782306695, 0.036739573880900545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025796039994189224, 0.025890064497948728, 0.07042864227254342, 0.00034059570099087555, 0.03359769171603, 0.010791039280989567, 0.01763501415882618, 0.02734386568636582, 0.017965279794695532, 0.01622452316435463, 0.01544333631503414, 0.016182058734897198, 0.031213071458668695, 0.04247020473660845, 0.09353853398302492, 0.050638903905842914, 0.045314403180712004, 0.0620292671074405, 0.025025234973739874, 0.03481516920970773, 0.03191390427010887, 0.0037575360507424715, 0.12222680308652689, 0.0051176298449763236, 0.048822991517349146, 0.06052714458997943, 0.12069809776927432, 0.4054662956608015, 0.34800423256213353, 0.3843401747942431, 0.38687809057575573, 0.4079892738266604, 0.36973016238495393, 0.46357229598745575, 0.3759007554530712, 0.39943693602138697, 0.059649129650380384, 0.07978882603022996, 0.08676161153291728, 0.08950301481290335, 0.09592173042635244, 0.09055933453570109, 0.05988866416054062, 0.05769183242210241, 0.12275891425147134, 0.1392964183360086, 0.15292788718441586, 0.17359499410777413, 0.17478011644840663, 0.15546796760309267, 0.1850216091221183, 0.16349177074922028, 0.1990853979350481, 0.17388142542560836, 0.2993004461655161, 0.21647454942234523, 0.2545171698020856, 0.29274550262074595, 0.2470806721557125, 0.31607276644385973, 0.2883561081574114, 0.29400944821614694, 0.18320839240909337, 0.20771909699432134, 0.19442993876255954, 0.15734259843656162, 0.17363431018290498, 0.21178121890828427, 0.19095450801212566, 0.20921410372659566, 0.21563488992776247, 0.19484950130608625, 0.1835908222306003, 0.2051506248077073, 0.19934811652928897, 0.16583005405000717, 0.1858988237482574, 0.17883330005973308, 0.2010697992509901, 0.1737079179617469, 0.18998418801390737, 0.19333783616428024, 0.18574044902472697, 0.19020189385881436, 0.17603407776902946, 0.19083487864833082, 0.20106055249436816, 0.16536614090705537, 0.19422111633450223, 0.3384169273810069, 0.19407990983998147, 0.1627461429446686, 0.6444719043867794, 0.5156363533364814, 0.17309329385067063, 0.6853684740835655, 0.6086516418368859, 0.5977719508466487, 0.16661849337509738, 0.19012959960169706, 0.1825998832165615, 0.16375252227288017, 0.4480881838322067, 0.19609272072406336, 0.3234882824313233, 0.19764378699343044, 0.513673156721817, 0.1963436180215502, 0.2193511698108127, 0.18112293571865268, 0.1828350360017501, 0.18821272318051874, 0.19923764654015186, 0.2013010832456431, 0.18197185976618335, 0.20790625622167958, 0.18567425672217386, 0.07239796037335344, 0.08569328305573132, 0.07675227653835626, 0.08853134435823029, 0.06464851443429653, 0.07700848563000795, 0.08048432983338172, 0.07451540394260303, 0.06943247274409592]}, "mutation_prompt": null}
{"id": "a10ab0cf-fe8d-4542-b31b-87583bafb925", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "6e44475f-2f44-4f1a-bee7-b0d8b2c1276b", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "4137c333-d840-43ac-8610-925e418ea482", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "ad0c8f94-b1b4-4034-a296-df2ab6053776", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        random_perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                        self.global_best = np.clip(trial + random_perturbation, self.lower_bound, self.upper_bound)\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance swarm diversity by introducing random perturbations in global best updates to escape local optima.", "configspace": "", "generation": 27, "fitness": 0.2670550197127964, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.6120944114119835, 0.6320865655527899, 0.642052780596049, 0.7571212838689549, 0.7692055769777684, 0.7952067533292221, 0.5833850321019665, 0.6985948493465788, 0.7114276208489685, 0.2589041101269792, 0.4065571796451143, 0.3858005489195757, 0.5068473636987709, 0.07449433424352137, 0.06462066120525922, 0.3816593678946155, 0.36190412154614016, 0.04948610019468758, 0.15062648906788423, 0.15482842893476167, 0.1384152419691207, 0.28771423855432543, 0.1487810053597579, 0.14468171362980686, 0.17469870532968723, 0.14424506201934395, 0.13874817672639217, 0.14889372608746765, 0.11000361446832907, 0.10766469659397804, 0.13562500547176515, 0.11360756813814421, 0.15728767740235694, 0.1055943889909442, 0.10343136846256906, 0.14818118952468362, 0.9910695270110464, 0.99170846198531, 0.9817884468920135, 0.9897490217382067, 0.9923629144973011, 0.9862469385999232, 0.9921600847276627, 0.9902113684458336, 0.9955396419746222, 0.42970843516955193, 0.4409299225175103, 0.44456681219833893, 0.4675523530587252, 0.43302315419722515, 0.4040491823000778, 0.37844657020290506, 0.39289683986392143, 0.3771806658247874, 0.21921887047050703, 0.8396846252232204, 0.22680189845407162, 0.3737227210649884, 0.2751789820322008, 0.2094410872620871, 0.12414132141300338, 0.17411053179314406, 0.24481257039636262, 0.20642437470160768, 0.12389824454967235, 0.23316389291024076, 0.13377784293086004, 0.12763041557417842, 0.18496506478233465, 0.1918049634433201, 0.1912801323923261, 0.1739734562512797, 0.20523280646745268, 0.19071857169881323, 0.11437668026972492, 0.18427155102246062, 0.20403276024615002, 0.20512103499993173, 0.2428811851513515, 0.12622390816528783, 0.22802594996549286, 0.011409211999034552, 9.999999999998899e-05, 9.999999999998899e-05, 0.033197264528103565, 9.999999999998899e-05, 0.014360069700548261, 9.999999999998899e-05, 0.06238604601048159, 9.999999999998899e-05, 0.031088117774715096, 0.078814866390846, 0.05611543621407433, 0.06830034096675641, 0.017186955499131185, 0.018500064718696696, 0.08311008453715496, 0.04020951827016617, 0.06846536566893668, 0.011798940265166813, 0.03281743452111208, 0.05247366132909026, 0.05570057436879994, 0.10171540538418034, 0.07110064388821502, 0.056125350318165124, 0.09060187435709, 0.0735695264922559, 0.23056204017653859, 0.23168067478002363, 0.2241114949768941, 0.056774215821064566, 0.06817789087474646, 0.20271391543792083, 0.05649699567413358, 0.05716727757038076, 0.08175686953651262, 0.498803029521661, 0.4901872000474623, 0.5002672258931201, 0.5211878884474153, 0.5299752730663043, 0.4940591883623383, 0.49337547361888523, 0.5240749277857671, 0.5075113483860778, 0.1063405139279281, 0.08882449052386765, 0.1279218934096027, 0.08133263602805241, 0.257474836606963, 0.10948464126096391, 0.11078866518383179, 0.11398319457025374, 0.13258458637788373, 0.2495978261391376, 0.23091126265069473, 0.15819623882047507, 0.2037639406678572, 0.4514845277222189, 0.3754711024741828, 0.14676515905850485, 0.14548075441744457, 0.232493406139742, 0.36231285451600703, 0.23695963760144956, 0.3797411430466403, 0.3582483458329808, 0.4862244115191868, 0.44427477315970565, 0.3787417434007453, 0.43378369047815357, 0.5261620478517713, 0.22456946966535896, 0.2249804805313914, 0.2577504522832259, 0.201363590944585, 0.20706828116517817, 0.1960668338504853, 0.2385625444077797, 0.31275151166520687, 0.3587265391075255, 0.2153239960420661, 0.22718885238216013, 0.20859867263683152, 0.20929393190691659, 0.2366590313197665, 0.186619043609072, 0.20761226601719984, 0.1905542411315554, 0.2583085423988746, 0.2065652580164049, 0.22059325284312958, 0.2086178286442678, 0.22327356807246856, 0.24682628589035482, 0.1913984148400747, 0.2461867832706608, 0.24484974462767561, 0.20313298557597992, 0.8858635869867334, 0.19908182205337888, 0.16213946650858246, 0.16479988113778332, 0.16521157819502152, 0.16719049662123087, 0.16595563947917213, 0.8537988661292197, 0.21163498147017967, 0.11265218238699204, 0.16787656973554765, 0.16653400173579846, 0.2098047992358908, 0.15338932949076955, 0.20985311920877636, 0.20865721117687253, 0.21208666605754323, 0.7722224503698485, 0.17974434001471817, 0.1925388895857283, 0.20132250081507497, 0.18970722148350505, 0.19136440900524598, 0.1802768564719459, 0.19614990512277564, 0.2086951401219731, 0.1796091419990855, 0.09653455967904923, 0.10477983134995938, 0.0958905455433734, 0.07508718710434548, 0.08534273639082024, 0.1037577079448323, 0.08993614225635882, 0.09362219762569313, 0.11096914498049315]}, "mutation_prompt": null}
{"id": "6ded65f4-05c9-4071-bc50-522b6895da16", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Dynamic local search phase\n                        variation_range = 0.1 * (1 - progress) + 0.05 * progress\n                        for _ in range(2):\n                            variation = np.random.uniform(-variation_range, variation_range, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance exploitation by dynamic adjustment of the local search perturbation range based on progress.", "configspace": "", "generation": 28, "fitness": 0.328489856377397, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8860413529060658, 0.8741842997503757, 0.8819137530900443, 0.8926460773229393, 0.8426011943628222, 0.8780466723184843, 0.8964663921626548, 0.8992918660545899, 0.8934748398418202, 0.7432728236001824, 0.7094654624348364, 0.7455720213508339, 0.7572269194746093, 0.7534182724637217, 0.7297426649554997, 0.7266299399695857, 0.6749839187357114, 0.7419949651547204, 0.15364710040560836, 0.14585885195876724, 0.1511231833789336, 0.07481054645644725, 0.10769271892292653, 0.1794041435710615, 0.18529069462113756, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.10327567031695417, 0.15112574090044328, 0.13550518955600455, 0.13032554837597077, 0.09465756835607375, 0.10902969601954005, 0.11502537867682694, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320303522562, 0.9857350449059153, 0.9884797817620105, 0.9922191813574057, 0.7449519313060811, 0.7473753569042874, 0.7192749081588126, 0.6945961118262136, 0.7371640773493247, 0.6390990402684191, 0.732524277845256, 0.6532152564846299, 0.7542314085498666, 0.13470102837396736, 0.22576441002713543, 0.34829821930755767, 0.2710997034248589, 0.3784734164844281, 0.2098248940537556, 0.8308690488757176, 0.9060993370312379, 0.8331738617133266, 0.23541415924286557, 0.12966044716029612, 0.2632159444108062, 0.13362988152789745, 0.2665530638723662, 0.22851314740721795, 0.23530142879834604, 0.28330400371008013, 0.2189482916013028, 0.2878331802111601, 0.23365795826591174, 0.23964313336494647, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.22339084433075218, 0.24416705010882822, 9.999999999998899e-05, 0.006428084864026795, 0.010646926669843237, 0.03901577285660207, 0.0036463913966814365, 0.05923616190913217, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06982385599209795, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09446230207341655, 0.03537985130394139, 0.11335639980098167, 0.0803572842821102, 0.1300327683893665, 0.0775317674260616, 0.09691995018218513, 0.2629926953271614, 0.10421140356380743, 0.043577946196350026, 0.04136089003181065, 0.04521183706836418, 0.07843298738463034, 0.12556656413337042, 0.1691199683875868, 0.08235827498026083, 0.05575228838581048, 0.08127509916866948, 0.5454213261939407, 0.5446995367881586, 0.5388170120597994, 0.6197533059648217, 0.5548567369740798, 0.5495062789456442, 0.5908477465943274, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.13094227158196903, 0.11422062957024248, 0.08322819854295771, 0.11255953089431403, 0.13244834413496587, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.18884363808994709, 0.25631308138128306, 0.19912563666598504, 0.2408327507964556, 0.15457647785283135, 0.2543480201542333, 0.6485233853327113, 0.40256471683416917, 0.27452074757542055, 0.4746984406195248, 0.5192134451417441, 0.5264462329065025, 0.6692264054186141, 0.3857845356465298, 0.3502947754498429, 0.2354432435589614, 0.24470391440370975, 0.16491962084129297, 0.21139350117417832, 0.27806233495970645, 0.26911070101385026, 0.14614990629497493, 0.3115767715484723, 0.19523427586277664, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.19862759568718769, 0.2183065463153463, 0.24439093961867142, 0.22598357992221285, 0.19032549396386889, 0.22066117300303567, 0.2166366502106083, 0.2442380057306891, 0.1998450145095617, 0.19553898355682864, 0.20519270900196407, 0.20884834039941802, 0.216164768137034, 0.15214661907611593, 0.16404899715874777, 0.17422759702593682, 0.17675123883404775, 0.2048220527554656, 0.8980776689079129, 0.8008890600083405, 0.8774277759717669, 0.8481811676438529, 0.20809768921397243, 0.16641529411305656, 0.1671294799082541, 0.20774838042248778, 0.7455948409704166, 0.8119555939530788, 0.1676116528023769, 0.1271994165839334, 0.16755044341796788, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "3a024910-55da-4c98-900d-bd563e618043", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "4d563ae9-1d5c-46eb-8b65-f2202c52702e", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * (1 - progress) + 2.0 * progress  # Adjusted\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(3):  # Increased iterations for refinement\n                            variation = np.random.uniform(-0.05, 0.05, self.dim)  # Tighter range\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by dynamically adjusting the social component of PSO and strategically refining the local search phase.", "configspace": "", "generation": 30, "fitness": 0.2513826156626649, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.7909429001616212, 0.7899754553625269, 0.8033765259001602, 0.7941614794734226, 0.8291276232069105, 0.7625879976704751, 0.6435305674596663, 0.7848412777411103, 0.7166276924304835, 0.6168229221295052, 9.999999999998899e-05, 9.999999999998899e-05, 0.6147755046860592, 9.999999999998899e-05, 0.6090637230941848, 0.01793840929835755, 0.05293725294400209, 0.5398645788778474, 0.14245295085345078, 0.08962888154971116, 0.4900943912406559, 0.14079332091264274, 0.10991211913326593, 0.1718302818435673, 0.12820738723164982, 0.14129458474870082, 0.12252408739456255, 0.141637102607706, 0.13495313011471421, 0.1259727488561979, 0.027792238509098732, 0.1637054783346097, 0.09298671363763966, 0.11794964669727359, 0.12485948406124969, 0.116373473807598, 0.9918682822169254, 0.9900996960505581, 0.983540608589148, 0.9875458795796086, 0.9922601075066502, 0.9931501422874212, 0.9927203866194109, 0.9939452684141742, 0.9949526613501322, 0.6458838572133869, 0.5329973503886308, 0.5400272705072184, 0.5332239211302277, 0.3496514812954007, 0.4766620932133263, 0.5451204677907211, 0.4880377476220076, 0.321602573020921, 0.21564015074902887, 0.3553956186679573, 0.1351959797695108, 0.19552248368616598, 0.1828497520831034, 0.2068909958882601, 0.12442377871073163, 0.08909352821482719, 0.2345867835801645, 0.18854582995184288, 0.11477863978242209, 0.24827857166030398, 0.11270542826564012, 0.0938904943892781, 0.19912149132699364, 0.22450442412670546, 0.20421932725522485, 0.19481547781936293, 0.17607958632749576, 0.195938133310544, 0.059636392033699526, 0.24984775587181107, 0.12933214064101395, 0.11919161968557568, 0.21966413611297098, 0.12464596812952655, 0.07837520154124089, 0.0014698114995040923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028360666127790868, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05012896503651443, 0.03401307059716929, 0.0719963489463944, 0.07773282380258661, 0.07379743610853295, 0.034590923597973, 0.020038630591354023, 0.018634366020362392, 0.13137654835278356, 0.030842702227009466, 0.031034019644612054, 0.032332810902775955, 0.0657784659053594, 0.06936243601380043, 0.06953899698159216, 0.0796670798020972, 0.07640374981344034, 0.1672042405596087, 0.1937844154025944, 0.1777896819630621, 0.05785237058680304, 0.033963147236847346, 0.07150034131625638, 0.0059397760002700695, 0.05527612349226496, 9.999999999998899e-05, 0.07528178584226897, 0.5161375421603074, 0.5088736229190091, 0.5208077055669114, 0.5128696504537547, 0.514426724195512, 0.5281958466264448, 0.5248554743022875, 0.5592836813903068, 0.5104868381621352, 0.12355604017487043, 0.13123056497872143, 0.05140124775717281, 0.1286654769818535, 0.12934393272100098, 0.04973108624339906, 0.09677808203693972, 0.10419603645885567, 0.1419207065390199, 0.15039007026968887, 0.1668612347582088, 0.15230448360495397, 0.17969055656271316, 0.14104018226466775, 0.2226463954873087, 0.148538122538585, 0.2415839847603315, 0.17541828951179128, 0.37246190759765385, 0.22499815523796385, 0.21242761503626229, 0.3154741835919008, 0.2576540625457667, 0.3030499799969494, 0.39932385250656255, 0.42606027432485893, 0.18584156196315305, 0.2942721439528694, 0.21955075911934485, 0.17436183432589647, 0.3261078160175024, 0.18981442483077093, 0.19921598232594462, 0.29768572953961236, 0.21876177396036411, 0.19957653109770834, 0.22301295734452875, 0.1516938758046812, 0.2073542323412163, 0.17894804742785397, 0.17261475774913926, 0.18389191678262962, 0.24697039107339191, 0.1888624770138092, 0.21309104694819914, 0.1686609798809211, 0.23274894108908784, 0.20429084205756154, 0.23630049583521118, 0.23190890926600383, 0.23769794469849026, 0.23074232107768555, 0.18161538089460072, 0.20427169463580364, 0.13105126958392632, 0.20430879501774624, 0.170218048543043, 0.18528485933777594, 0.1648331718801519, 0.1763055100114851, 0.1772153307684946, 0.2076264578922593, 0.7919684644641762, 0.1127290005165551, 0.1659519162904195, 0.09719701226650612, 0.12340960112324939, 0.20718533407028494, 0.14200148259501788, 0.639242136002938, 0.20856444211137004, 0.2830931225393454, 0.19724499425699982, 0.19156465284386892, 0.2146373102555983, 0.18818103952164633, 0.20942914823202352, 0.19703066925015433, 0.20190734882435835, 0.192109675258071, 0.19402281159762913, 0.07840428600440752, 0.0738102028433425, 0.08884860211396461, 0.083699541985233, 0.0862693579573035, 0.08635668091440818, 0.094126914592639, 0.07708566671270745, 0.10038759491834026]}, "mutation_prompt": null}
{"id": "df69db25-97ae-48aa-ab38-501c91293681", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "da3ca885-7064-4acf-8f3a-9e61dcd45703", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "6e4ea7b8-c589-4c33-8b24-f982b7ba2161", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "25c79b69-ddfb-4387-a239-6300cd976421", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        progress = self.func_evals / self.budget\n        self.w = self.w_max - progress * (self.w_max - self.w_min)\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance velocity update by adding an adaptive inertia weight mechanism to balance exploration and exploitation.", "configspace": "", "generation": 34, "fitness": 0.22520125231826327, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.5981923529700726, 0.5415313106444467, 0.5423228591930198, 0.5573590631908081, 0.5750686599411636, 0.23351591387592185, 0.5163145579895538, 0.5765133548267911, 0.5373422431394375, 0.3437298910918275, 0.3286794997306245, 0.28379884652546383, 0.30207294737682233, 9.999999999998899e-05, 0.366021014094973, 0.010851524078705044, 0.3021434991365125, 0.32043468502538985, 0.10630586424311772, 0.060249256633334025, 0.11453792517805284, 0.06216210568916136, 0.06678376265408992, 0.06952581144270575, 0.1112959481115009, 0.12910797936614604, 0.2843047157693953, 0.1112336839059852, 0.0976394364355776, 0.09140152265974044, 0.08068585661817851, 0.097606708361333, 0.1140281609401893, 0.08462338721745, 0.08535720104861977, 0.10645929000427568, 0.9781598102775291, 0.986341042030282, 0.9879475852718347, 0.9892897866806666, 0.993515998066411, 0.9888247237922861, 0.9893877121422113, 0.9889052689833905, 0.9924553709408356, 0.40587630960115917, 0.1970629155719985, 0.33578027328055626, 0.13192283729257392, 0.3959154841717294, 0.16050922325568895, 0.10192475723240946, 0.2770083347378566, 0.407215434747481, 0.42995983139824456, 0.4475456100983789, 0.16427542921927907, 0.19952588989845121, 0.14675079492299958, 0.19176689497614574, 0.1639112963019952, 0.11811117465005883, 0.16189213217468057, 0.14454866989694348, 0.15507049079323554, 0.13808506509722973, 0.10746699364363399, 0.08071229421768589, 0.16287717429598592, 0.14003085404744342, 0.13734811276130476, 0.12625105539483827, 0.042484601982963666, 0.09830424896998924, 0.07742398146635221, 0.16881349672377433, 0.1455860600557044, 0.1418373432891067, 0.025919338644799228, 0.16235079639969663, 0.10280405509813606, 0.00807800908119427, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04543414603360818, 0.004117088013979808, 0.06346931788819621, 0.005808045618382995, 0.015518887844279572, 0.01542838955273551, 0.03901438924819234, 0.027099838839512835, 0.02131083229229913, 0.01826746319832384, 0.011368865493055047, 0.010748390957909026, 0.04795426130397151, 0.04227734178344433, 0.1476349870457394, 0.05452227941655552, 0.12850942909797647, 0.08443034809138006, 0.03233189946836301, 0.036588147254287495, 0.024400925728189415, 0.0038971856233911417, 0.07592847312075679, 0.16199014309861448, 0.15173332217723223, 0.03791066146096089, 0.08307155089915519, 0.4445273190843385, 0.4071160138821076, 0.4337251986486601, 0.45557832945559673, 0.409073220022691, 0.42512869791107843, 0.45854704078089237, 0.4775940928607012, 0.41243596513869474, 0.06452237472344691, 0.08509793258409515, 0.14766556854168544, 0.1056175749127829, 0.08687766920545414, 0.09533914548615563, 0.08440351603856255, 0.06459909516772133, 0.1078482555613095, 0.17855859403254382, 0.23716035064410157, 0.17891114887752957, 0.1776569320469472, 0.14316690946716082, 0.14413138015580496, 0.1497603936616635, 0.172204727631589, 0.19933996739892035, 0.3569336711625597, 0.21248268177582408, 0.34077212997811046, 0.31473033919728, 0.3502358601975555, 0.2645795059444178, 0.3395352205025467, 0.29823761566795315, 0.18967028615045456, 0.2120392270641226, 0.19556885331093365, 0.21034736991444214, 0.16761001540371667, 0.2211043727101073, 0.18279760181037719, 0.21807542713444494, 0.18773234035345132, 0.2042864510231337, 0.18165281821404689, 0.18167066377200913, 0.1898282946827471, 0.22105241206850545, 0.17918934655591967, 0.17518198760987858, 0.16945088468246117, 0.20988516079478836, 0.20133855111206178, 0.38688587159054755, 0.18118053334621176, 0.20038652090227338, 0.19616359425444452, 0.1864686245110031, 0.1793363279419795, 0.17754412913870277, 0.17293937190616215, 0.17912200088023345, 0.5987316488500787, 0.15995074416548105, 0.6472304172603669, 0.15336613257900522, 0.17587765102443698, 0.18324669233322288, 0.6418023908620434, 0.1445691110588534, 0.48985062167744897, 0.1603450842723536, 0.19847808796141309, 0.1781680872034096, 0.4862303663127797, 0.557576781670676, 0.5213430139178634, 0.1614785144321762, 0.5011524832192689, 0.19725216272657475, 0.20880644713272922, 0.19287851912663423, 0.1868101400730071, 0.18656424209677103, 0.19293544786969474, 0.21081794763418849, 0.1823330283782404, 0.16903209963101995, 0.19182381923979197, 0.07568633604647368, 0.07360681484496057, 0.0704870407023811, 0.0817058845729578, 0.06763338867250368, 0.08097264346881872, 0.066925726795937, 0.08486370194617743, 0.08169179055945208]}, "mutation_prompt": null}
{"id": "a0aecc5a-7ed2-426b-9894-9537d8a69983", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w_initial = 0.9  # Changed initial inertia weight\n        self.w_final = 0.4   # Changed final inertia weight\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        progress = self.func_evals / self.budget\n        self.w = self.w_initial * (1 - progress) + self.w_final * progress  # Dynamic inertia weight\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "PSO_DE_Optimizer with dynamic inertia weight for improved exploration-exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.22519074689175841, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.5981923529700081, 0.5415313106445447, 0.5423228591925842, 0.5573590631908358, 0.5750686599386542, 0.23351591387592552, 0.5163145579890673, 0.5765133548258343, 0.5373422431383682, 0.34372989081981054, 0.32867950015376957, 0.2837988464586849, 0.30207294744885715, 9.999999999998899e-05, 0.36602101410531074, 0.010851524078705044, 0.3021434991948052, 0.3204346850342993, 0.10630586424311772, 0.06024925663333247, 0.11453792517805284, 0.06216210568916136, 0.06678376265408992, 0.06952581144270575, 0.1112959481115009, 0.12910797936614604, 0.2843047157725904, 0.11123368390599297, 0.0976394364355776, 0.09140152265979773, 0.08068585661817851, 0.097606708361333, 0.11402816094018564, 0.08462338721745, 0.08535720104861977, 0.10645929000427945, 0.9781598102775291, 0.986341042030282, 0.9879475852718347, 0.9892897866806666, 0.993515998066411, 0.9888247237922861, 0.9893877121422113, 0.9889052689833905, 0.9924553709408356, 0.40587630960383525, 0.19706291557737554, 0.3357802729578374, 0.13192283729257392, 0.3959154841708249, 0.1605092232556844, 0.10192475723241023, 0.27700833473779163, 0.4072154347569521, 0.42995983139824456, 0.4475456100983789, 0.16427542921927907, 0.19952588989845121, 0.14675079492299958, 0.19176689497614574, 0.1639112963019952, 0.11811117465005883, 0.16189213217468057, 0.14454866989696635, 0.15507049079323965, 0.13808506509721807, 0.10746699364363399, 0.08071229421767345, 0.1628771742961448, 0.14003085404745996, 0.13734811276128545, 0.12625105539491543, 0.042484601980366854, 0.09830424896996359, 0.07742398146638474, 0.16881349672378254, 0.14558606005569275, 0.14183734328910502, 0.02365016642992901, 0.16235079639967875, 0.10280405509813606, 0.008078009081203152, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04543414603360285, 0.004117088013979808, 0.06346931788819621, 0.005808045618382995, 0.015518887844279572, 0.015428389552737287, 0.03901438924828349, 0.027099838839512835, 0.02131083229229913, 0.018267463198330725, 0.011368865493095237, 0.010748390957909026, 0.047954261303970847, 0.042277341783432676, 0.14763498704362932, 0.054522279416536534, 0.12850942909804586, 0.08443034809145245, 0.03233189946841686, 0.036588147254287495, 0.024400925728189415, 0.0038971856233911417, 0.07592847312078099, 0.16199014309859616, 0.1517333221778414, 0.03791066146096089, 0.08307155089914942, 0.44452731908475507, 0.4071160138817047, 0.43372519864852543, 0.4555783294548722, 0.4090732200231392, 0.42512869791115904, 0.4585470407812202, 0.47759409286216137, 0.4124359651390127, 0.06452237472344691, 0.08509793258409515, 0.14766556854168544, 0.1056175749127829, 0.08687766920545414, 0.09533914548615563, 0.08440351603855056, 0.06459909516772133, 0.1078482555613095, 0.1785585940325065, 0.23716035064412144, 0.17891114887747683, 0.17765693204693966, 0.14316690946715882, 0.14413138015589122, 0.14976039366216698, 0.1722047276315647, 0.19933996739890258, 0.35693367110215646, 0.21248268177060814, 0.3407721299967077, 0.31473033924867655, 0.3502358602178408, 0.26457950594568336, 0.3395352204875851, 0.2982376156705041, 0.18967028615059267, 0.21203922706411427, 0.19556885331163343, 0.2103473699146985, 0.16761001554156352, 0.2211043727097528, 0.18279760181044846, 0.21807542713436423, 0.18773234034364572, 0.20428645102247778, 0.18165281820719803, 0.18167066377205776, 0.18982829468224738, 0.22105241206841875, 0.17918934655584617, 0.17518198761057102, 0.16945088468255798, 0.20988516079478836, 0.20133855111215915, 0.38688587162238897, 0.18118053334621176, 0.20038652090227338, 0.19616359425444452, 0.1864686245110031, 0.1793363279419795, 0.17754412913870277, 0.17293937190616215, 0.17912200088023345, 0.5987316488501115, 0.15995074416548105, 0.6472304172603544, 0.15336613257900522, 0.17587765102443698, 0.18324669233322288, 0.6418023908620434, 0.1445691110588534, 0.48985062167744897, 0.1603450842723536, 0.1984780879614213, 0.1781680872034096, 0.4862303663127976, 0.5575767816707552, 0.5213430139178398, 0.1614785144321762, 0.5011524832179586, 0.19725216272657475, 0.2088064471326747, 0.1928785191265583, 0.1868101400729707, 0.1865642420967617, 0.1929354478697063, 0.21081794763432538, 0.1823330283782394, 0.16903209963106836, 0.19182381923979197, 0.07568633604647368, 0.07360681484497944, 0.07048704070222722, 0.08170588457292871, 0.0676333886725281, 0.08097264346877597, 0.066925726795937, 0.08486370194617088, 0.08169179055945985]}, "mutation_prompt": null}
{"id": "7bfd9372-dfd9-44e4-b8ef-fa166460f1f1", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.7  # Adaptable inertia weight\n        self.f = 0.9  # Increased mutation factor\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce adaptable inertia weight and increased mutation diversity to enhance convergence in PSO-DE hybrid optimization.", "configspace": "", "generation": 36, "fitness": 0.2518229570292554, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.7153478365277324, 0.6923981225926606, 0.704013006898677, 0.7237992731879284, 0.7403258348782642, 0.6733008165975957, 0.6819532556025012, 0.7121338181758314, 0.7242230833889577, 0.3119804842762971, 0.05621404657586171, 0.3961719883572833, 0.3970213509834738, 0.42476786972174263, 0.40073579118176816, 0.2917485583927911, 0.31806458355466716, 0.40580822265564687, 0.15004457179356212, 0.13772858505068086, 0.1340635846142686, 0.15549546822219895, 0.1378026071436831, 0.1589416199556859, 0.15065828283748328, 0.12968027976885865, 0.09740920115391616, 0.12590866648633492, 0.12946775609246064, 0.12239189179822496, 0.11923595397466324, 0.10228573549291486, 0.1292036496461576, 0.11317732736294384, 0.09863608001461521, 0.13067541449097775, 0.9846274909897007, 0.9862321223635921, 0.9861816190925494, 0.9842308476199242, 0.9934808068628318, 0.9861851554167006, 0.9887038771850566, 0.9887444883777454, 0.9925526831429207, 0.3514682056270494, 0.33092119056708025, 0.37034443478907, 0.4446114178845054, 0.37218243053185696, 0.23235585362466604, 0.3877809508734493, 0.18548618288505936, 0.3227147496442502, 0.3427221283633677, 0.47038073784827583, 0.6094238725585602, 0.1580708447516812, 0.2505724135054995, 0.2634905404337875, 0.591161623591773, 0.08788582725325922, 0.2531349024543782, 0.16834473403298977, 0.16994554270432505, 0.19480847192955708, 0.16075627983841478, 0.11674381698020786, 0.09381895788495498, 0.104239285980812, 0.17186709984214776, 0.15967842202954274, 0.07086810883239669, 0.11099901430272052, 0.13685377452176617, 0.1932886571048541, 0.17894888293656697, 0.16627803766696014, 0.0890446872207411, 0.22624015713486645, 0.18609344970612474, 9.999999999998899e-05, 0.006849873092957037, 0.002317666877290181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07785517861753344, 0.07119636726020495, 0.05212760140927386, 0.06669319835130971, 0.03211468079036417, 0.056067512427068644, 0.013370071592046617, 0.02863219452007504, 0.06121673678205475, 0.04117419573882053, 0.02944879463111061, 0.15341619054899436, 0.13429317619563974, 0.05823958084505432, 0.07255883025897802, 0.09133147447819101, 0.10012811581513947, 0.06947228447122666, 0.0404366123707639, 0.07742064727593156, 0.0795378589580591, 0.14636498493217553, 0.03469287859659942, 0.005797573547888124, 0.07227938354015895, 0.04644711760403242, 0.07147998340848027, 0.48345881045193084, 0.4970072493212365, 0.4772540458456185, 0.49510081546624474, 0.49525420754359895, 0.46662936199789806, 0.47110650729622383, 0.46482712227094125, 0.5133477728302942, 0.09195057275648832, 0.10293564027698243, 0.15745461773932312, 0.15893604071657896, 0.10193111566515223, 0.12407653234817373, 0.11779116490915498, 0.09927775837623698, 0.09295410071998378, 0.23231564030108642, 0.1727842875985347, 0.1779075840614356, 0.1715482229398947, 0.20561644654392253, 0.1513772698174407, 0.22119925066136992, 0.1947694820551914, 0.3064794380786672, 0.3648580868626037, 0.35555400754796807, 0.23295969276731576, 0.3995993358520429, 0.3033788553296475, 0.28585932898560773, 0.3155998986091879, 0.3703078520320534, 0.34366897905803895, 0.23519888844317716, 0.22940271910256138, 0.19198816031124266, 0.18280181013990648, 0.16734623864085552, 0.22308465458587545, 0.2535119086380754, 0.191970080645129, 0.2791055942269757, 0.20250635813145368, 0.17921143765961856, 0.19041077507849302, 0.17831362192305755, 0.2154433607753986, 0.22767732076306324, 0.2170144841603744, 0.2138102689118797, 0.18462705420022607, 0.18717163335249187, 0.17396674565225134, 0.16612654883885758, 0.1973369366672394, 0.3608237832048501, 0.2121983807738579, 0.2320246299521017, 0.19392191760113497, 0.17118451439316063, 0.15075770176523673, 0.19560564194171892, 0.18312884582627098, 0.16423682151375596, 0.1818291859422585, 0.7512236219204356, 0.8116716688820973, 0.1653009132285138, 0.1696605698420317, 0.16631151276318157, 0.20468748646331225, 0.6854821161314593, 0.12574808662544934, 0.20612634827362986, 0.19814772173074646, 0.1661518362159775, 0.12621309811050485, 0.15111590356091076, 0.2002728970665033, 0.19000700065223075, 0.22857971396838062, 0.21663280490290893, 0.18701381837050046, 0.21820879999899667, 0.18317375037179384, 0.20639520210531737, 0.19588939884575562, 0.07568431006577847, 0.0898171271015955, 0.08259656358275302, 0.08041955611182006, 0.10741592990290316, 0.09210384049608633, 0.07911431926276313, 0.08935369422652983, 0.09148382486640638]}, "mutation_prompt": null}
{"id": "ca5322be-0ee5-458c-9c47-a518911d48ac", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "f3373822-70f3-4778-a3f4-32f56a39401a", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f_initial = 0.8\n        self.f = self.f_initial\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            self.f = self.f_initial * (1 - self.func_evals / self.budget)  # Dynamic f adjustment\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global exploration by dynamically adjusting mutation factor `f` in DE, improving search space coverage.", "configspace": "", "generation": 38, "fitness": 0.3204958409667023, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8788783087273754, 0.8657090755701333, 0.8905734869724915, 0.8844936197838575, 0.8725082905519368, 0.8771186119563622, 0.880164012996233, 0.8927759776917842, 0.8843380875868212, 0.7412676894896386, 0.7206832326590131, 0.7151717942343306, 0.044490916344294806, 0.7574352394221194, 0.7546192400534045, 0.6823524840537338, 0.65451219127761, 0.7446444367023681, 0.1795455919492912, 0.1179866310033576, 0.14711899441594267, 0.14986508846123037, 0.07639460088567884, 0.11637445785435518, 0.17686111877971922, 0.1214832456173599, 0.1538497815742207, 0.1292536157775801, 0.11010862664681986, 0.13654213775119173, 0.02754636581503911, 0.10977327616321253, 0.1033526491103739, 0.17736891509358887, 0.10765548880133191, 0.09748172146403611, 0.9822403142886088, 0.9854285605974482, 0.9859286342719125, 0.9867720644896932, 0.9934927256754976, 0.9861265165119707, 0.9857365560764524, 0.9884808753914753, 0.9922176479331912, 0.7440673856473463, 0.7177727388285002, 0.776118978972265, 0.7180109427577596, 0.7206255280454504, 0.7146239221958912, 0.7686443447259365, 0.6014213140270851, 0.7311339623143269, 0.16734989885382567, 0.22602322568579092, 0.7420348505659271, 0.824037589024935, 0.37961057949277544, 0.3555925820941328, 0.12236778730346343, 0.3791322914522359, 0.23408396456299374, 0.11516668626240467, 0.25007411678407376, 0.25199402246039815, 0.13165884128801553, 0.2420379130540441, 0.2500658257222741, 0.23736940968356335, 0.21255463516799222, 0.12916713555696402, 0.23669017605144527, 0.24200123238091686, 0.24394906054310117, 0.1289509910638269, 0.1311290655947429, 0.27021422179526944, 0.1038225340996034, 0.25245741459325133, 0.27159777572952093, 0.0006634648717764868, 0.0015103129322311393, 0.0015452009524902222, 0.04145802679502353, 9.999999999998899e-05, 0.05903562991598099, 0.0026208482762949403, 9.999999999998899e-05, 9.999999999998899e-05, 0.038783280350579985, 0.07511021061720624, 0.08782712088934808, 0.03505699095562853, 0.019951995391006894, 0.03245735858384835, 0.05506752969158368, 0.027922677540792362, 0.10319269168813172, 0.09417189083888056, 0.03429576926056199, 0.1325279057113199, 0.07806760982596739, 0.1699325275443534, 0.08028973454409027, 0.09985717592405885, 0.23571506404464038, 0.07423451130207503, 0.04292338351510594, 0.04340289158862287, 0.042942079106388364, 0.09940139427360062, 0.08113368928336318, 0.20683281323227243, 0.08190724943641614, 0.0639374664005038, 0.08134734989116876, 0.5287705091852632, 0.5508806841777476, 0.5605677189398194, 0.5625550902474186, 0.5735784608528695, 0.5575085337719506, 0.5767486008262885, 0.5598594382448409, 0.5921639014733622, 0.15674156851199028, 0.10490582315324426, 0.09039455732876212, 0.11071396077002404, 0.15693841711830758, 0.09305893025895862, 0.06590601443715893, 0.12013647055012311, 0.15635029140772216, 0.15777780519861972, 0.200028883741027, 0.21081217472730085, 0.1536778044018069, 0.18422161622000444, 0.19836498213027665, 0.37727064457145776, 0.2695934443934581, 0.16107341171453793, 0.2816733283910213, 0.3626520864636045, 0.536950004617513, 0.31226888494214744, 0.3228241523026978, 0.4634399437570994, 0.5649115801437667, 0.16405010120247898, 0.3533328144119541, 0.2443567928092909, 0.26500238650659413, 0.1957929673667671, 0.29769721382101266, 0.18874569401728547, 0.3834551717970138, 0.09452281737553259, 0.28463750173723135, 0.31315745820817475, 0.19267546614830466, 0.2603259264250287, 0.23045260412209212, 0.21899387630851275, 0.24177633220252193, 0.2264743883624063, 0.21968707331705317, 0.21193907839096726, 0.222826658786776, 0.7549847108971746, 0.7301426261169699, 0.19507704544015647, 0.2443041094539976, 0.740188518503242, 0.1865934422631007, 0.24111842363326297, 0.22160945235522944, 0.18984254970640124, 0.14705972065729656, 0.16866727257974345, 0.17710255259548635, 0.17694613424482308, 0.16583059430902358, 0.9129474495076042, 0.790502709805931, 0.914780311839833, 0.16292994561620422, 0.2090008051458624, 0.45527547854541994, 0.16664492234730455, 0.2086492585598484, 0.12519887398263108, 0.6717305065697712, 0.16754856305090526, 0.7366431984852466, 0.16663774243716767, 0.19737616335895047, 0.20471924850115886, 0.18364787722891074, 0.1952623889445032, 0.19483180473766015, 0.20169144020577834, 0.19760162941057668, 0.1986323400405252, 0.1929796016990345, 0.09258586298771065, 0.08061150112758064, 0.12962058059137793, 0.10363798118652645, 0.12137236747072655, 0.13660190517813875, 0.09378687939332575, 0.0912842561937649, 0.08197917158117907]}, "mutation_prompt": null}
{"id": "311fc8ce-8064-4a17-871f-09ee39d05b38", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "bb5ac8d7-a96d-4da8-84d7-166c2e128821", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            adaptive_f = self.f * (1 - (self.func_evals / self.budget))  # Adaptive mutation scaling\n            mutant = np.clip(a + adaptive_f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate adaptive mutation scaling in the DE phase for improved exploration capabilities.", "configspace": "", "generation": 40, "fitness": 0.3204958409667023, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8788783087273754, 0.8657090755701333, 0.8905734869724915, 0.8844936197838575, 0.8725082905519368, 0.8771186119563622, 0.880164012996233, 0.8927759776917842, 0.8843380875868212, 0.7412676894896386, 0.7206832326590131, 0.7151717942343306, 0.044490916344294806, 0.7574352394221194, 0.7546192400534045, 0.6823524840537338, 0.65451219127761, 0.7446444367023681, 0.1795455919492912, 0.1179866310033576, 0.14711899441594267, 0.14986508846123037, 0.07639460088567884, 0.11637445785435518, 0.17686111877971922, 0.1214832456173599, 0.1538497815742207, 0.1292536157775801, 0.11010862664681986, 0.13654213775119173, 0.02754636581503911, 0.10977327616321253, 0.1033526491103739, 0.17736891509358887, 0.10765548880133191, 0.09748172146403611, 0.9822403142886088, 0.9854285605974482, 0.9859286342719125, 0.9867720644896932, 0.9934927256754976, 0.9861265165119707, 0.9857365560764524, 0.9884808753914753, 0.9922176479331912, 0.7440673856473463, 0.7177727388285002, 0.776118978972265, 0.7180109427577596, 0.7206255280454504, 0.7146239221958912, 0.7686443447259365, 0.6014213140270851, 0.7311339623143269, 0.16734989885382567, 0.22602322568579092, 0.7420348505659271, 0.824037589024935, 0.37961057949277544, 0.3555925820941328, 0.12236778730346343, 0.3791322914522359, 0.23408396456299374, 0.11516668626240467, 0.25007411678407376, 0.25199402246039815, 0.13165884128801553, 0.2420379130540441, 0.2500658257222741, 0.23736940968356335, 0.21255463516799222, 0.12916713555696402, 0.23669017605144527, 0.24200123238091686, 0.24394906054310117, 0.1289509910638269, 0.1311290655947429, 0.27021422179526944, 0.1038225340996034, 0.25245741459325133, 0.27159777572952093, 0.0006634648717764868, 0.0015103129322311393, 0.0015452009524902222, 0.04145802679502353, 9.999999999998899e-05, 0.05903562991598099, 0.0026208482762949403, 9.999999999998899e-05, 9.999999999998899e-05, 0.038783280350579985, 0.07511021061720624, 0.08782712088934808, 0.03505699095562853, 0.019951995391006894, 0.03245735858384835, 0.05506752969158368, 0.027922677540792362, 0.10319269168813172, 0.09417189083888056, 0.03429576926056199, 0.1325279057113199, 0.07806760982596739, 0.1699325275443534, 0.08028973454409027, 0.09985717592405885, 0.23571506404464038, 0.07423451130207503, 0.04292338351510594, 0.04340289158862287, 0.042942079106388364, 0.09940139427360062, 0.08113368928336318, 0.20683281323227243, 0.08190724943641614, 0.0639374664005038, 0.08134734989116876, 0.5287705091852632, 0.5508806841777476, 0.5605677189398194, 0.5625550902474186, 0.5735784608528695, 0.5575085337719506, 0.5767486008262885, 0.5598594382448409, 0.5921639014733622, 0.15674156851199028, 0.10490582315324426, 0.09039455732876212, 0.11071396077002404, 0.15693841711830758, 0.09305893025895862, 0.06590601443715893, 0.12013647055012311, 0.15635029140772216, 0.15777780519861972, 0.200028883741027, 0.21081217472730085, 0.1536778044018069, 0.18422161622000444, 0.19836498213027665, 0.37727064457145776, 0.2695934443934581, 0.16107341171453793, 0.2816733283910213, 0.3626520864636045, 0.536950004617513, 0.31226888494214744, 0.3228241523026978, 0.4634399437570994, 0.5649115801437667, 0.16405010120247898, 0.3533328144119541, 0.2443567928092909, 0.26500238650659413, 0.1957929673667671, 0.29769721382101266, 0.18874569401728547, 0.3834551717970138, 0.09452281737553259, 0.28463750173723135, 0.31315745820817475, 0.19267546614830466, 0.2603259264250287, 0.23045260412209212, 0.21899387630851275, 0.24177633220252193, 0.2264743883624063, 0.21968707331705317, 0.21193907839096726, 0.222826658786776, 0.7549847108971746, 0.7301426261169699, 0.19507704544015647, 0.2443041094539976, 0.740188518503242, 0.1865934422631007, 0.24111842363326297, 0.22160945235522944, 0.18984254970640124, 0.14705972065729656, 0.16866727257974345, 0.17710255259548635, 0.17694613424482308, 0.16583059430902358, 0.9129474495076042, 0.790502709805931, 0.914780311839833, 0.16292994561620422, 0.2090008051458624, 0.45527547854541994, 0.16664492234730455, 0.2086492585598484, 0.12519887398263108, 0.6717305065697712, 0.16754856305090526, 0.7366431984852466, 0.16663774243716767, 0.19737616335895047, 0.20471924850115886, 0.18364787722891074, 0.1952623889445032, 0.19483180473766015, 0.20169144020577834, 0.19760162941057668, 0.1986323400405252, 0.1929796016990345, 0.09258586298771065, 0.08061150112758064, 0.12962058059137793, 0.10363798118652645, 0.12137236747072655, 0.13660190517813875, 0.09378687939332575, 0.0912842561937649, 0.08197917158117907]}, "mutation_prompt": null}
{"id": "c3de5afb-e8b2-48fe-b80f-16a2d23ba274", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification with Gaussian perturbation\n                            variation = np.random.normal(0, 0.05, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance local search by adding Gaussian perturbations and varying the local search step size.", "configspace": "", "generation": 41, "fitness": 0.3189702442473731, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.888497662414897, 0.887329216929206, 0.8691695495288101, 0.8942146886431246, 0.8344660441533365, 0.893252343418484, 0.8684277337162951, 0.8789026084454988, 0.8749731853762781, 0.7321855608231835, 0.7506706824621747, 0.07531200524758863, 0.7636508771544505, 9.999999999998899e-05, 0.6875589534512785, 0.7011712765442184, 0.7365677861639923, 0.7556846838390516, 0.15279161409540343, 0.1366122083529393, 0.16742620287446675, 0.1463825737989808, 0.07211253771953763, 0.11499850571573844, 0.15400665928006674, 0.15473972426874139, 0.13060628995039947, 0.09434891057640327, 0.13941780702954787, 0.10553389077502229, 0.10950913843666399, 0.1025669522802366, 0.09569056586040481, 0.11161267019844268, 0.15044827947039463, 0.07041505156765993, 0.9891908627205376, 0.9897476873466731, 0.98830173960828, 0.9813436510273201, 0.9930397285194555, 0.9869948403781438, 0.9785614301030674, 0.9887019834736932, 0.9865716994829059, 0.7533291698862742, 0.691518760161745, 0.7538536416685343, 0.7586387655287636, 0.6083332989293577, 0.6673282271850935, 0.7024252664408304, 0.6517852088703948, 0.7682090202107771, 0.22432383249879229, 0.22316489119695904, 0.36604980685774413, 0.36719369910818656, 0.3758227613554278, 0.19202427297805913, 0.1235115941384205, 0.861041900711839, 0.3960904820015928, 0.23383830635305325, 0.23596331758934042, 0.2418929716638647, 0.25607249219417494, 0.13340807802276378, 0.2347526978540495, 0.23603227540086136, 0.23293171855065842, 0.1211800694758356, 0.23551433674102817, 0.2369150929782765, 0.12506021499142184, 0.13200534419059573, 0.12999607360118093, 0.25692108170202166, 0.10822856410212878, 0.259201457932386, 0.25393753966385635, 9.999999999998899e-05, 0.0841266457773836, 9.999999999998899e-05, 0.04191960764849878, 9.999999999998899e-05, 0.015134212522271762, 0.00022972937353149536, 0.003467234223239024, 0.05781390180513446, 0.1052636699312437, 0.05043233180994999, 0.07028250562408334, 0.029198254221476594, 0.07044147039246018, 0.09882269030764745, 0.05686661263349446, 0.027563773911348677, 0.07943682869434232, 0.03650014775045296, 0.020856468782529003, 0.08698922869831005, 0.07818960380560225, 0.09568342368168736, 0.11973258929885311, 0.1235126522688621, 0.07566053438993581, 0.28376437158481316, 0.21260727019012715, 0.04342238306877766, 0.17668823476134787, 0.09015057165284501, 0.038799456055860215, 0.16856100248237582, 0.04786858631122981, 0.04802782084468871, 0.08569717857428027, 0.5764021978137859, 0.5479028337153546, 0.5477763542466932, 0.6157976624005174, 0.5910278417582335, 0.6074018563047245, 0.5636879615261845, 0.596708930830536, 0.5702655189368304, 0.10218459047224038, 0.10603078301814672, 0.15488586263566573, 0.1118714446189204, 0.13280647034753634, 0.12551120913366298, 0.13738142623510607, 0.12671592941768572, 0.10844497182458201, 0.2592293628693819, 0.26558322847781723, 0.16940200878017442, 0.24826291434231662, 0.5021998267470442, 0.1546395074369299, 0.18216204533914837, 0.15776922575563934, 0.3775880873055082, 0.5661103651533329, 0.3162059720210305, 0.567323309471734, 0.41552372518549996, 0.3133616552292552, 0.43829085689447667, 0.5203498812798912, 0.5259672530246142, 0.5763774947948134, 0.29863087391997867, 0.24723070023794846, 0.3250265825663051, 0.2575151747501695, 0.2077989806799122, 0.2277831860711238, 0.30496802395231803, 0.3668474191707356, 0.27379914380089054, 0.20972792162215104, 0.20926361127219228, 0.21790801807182414, 0.21511780764441435, 0.1874463614413855, 0.2398449019441189, 0.21143901451721925, 0.2059040561309663, 0.23338956230645713, 0.20483863843308192, 0.20436728259720582, 0.19249758909753734, 0.21715531491374962, 0.7408904235674609, 0.19602521566472464, 0.21702929303832053, 0.18468636266908356, 0.18718077166277491, 0.17452457344948047, 0.2101216563522531, 0.20784141097255926, 0.18605289021619187, 0.18776608618102464, 0.9143603321527023, 0.15135315312401532, 0.2074695244926804, 0.910328101069847, 0.15463349805501203, 0.16724715090262166, 0.43743320667397656, 0.2115407759842205, 0.7420660330098776, 0.7024568169263907, 0.725020731773514, 0.20837902769729, 0.15547818651677847, 0.19982702223765536, 0.1942484239233695, 0.1841239546508857, 0.1927840938957922, 0.18657620660066665, 0.2095298538437237, 0.1888175218454684, 0.19510388011584423, 0.19723600521677154, 0.09780951681369165, 0.10063236229473715, 0.08929582011517156, 0.14667938017441196, 0.07768063692365268, 0.0908421276287571, 0.08735075559765815, 0.09575106924819721, 0.08943288462866184]}, "mutation_prompt": null}
{"id": "cb668cec-532c-4bab-84da-325dc6081c5e", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Dynamic local search phase\n                        for _ in range(2 + int(progress)):  # Adapt search based on progress\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a dynamic local search phase based on convergence progress for adaptive fine-tuning near optima.", "configspace": "", "generation": 42, "fitness": 0.3291926302513602, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "33e0f714-4afc-4bb4-99e6-a385a876e6b9", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            # Introduce random walk perturbation\n            perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n            self.swarm[i] += self.velocities[i] + perturbation\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance the exploration phase by introducing random walk perturbation in positions to diversify the search space.", "configspace": "", "generation": 43, "fitness": 0.24657213527413938, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.4983064635017902, 0.489406070633861, 0.49062317651500376, 0.5224956171115672, 0.5039541613610641, 0.4807207042723787, 0.5059238000894106, 0.5087885299934578, 0.5039874389748953, 0.0907228381217765, 0.036829327314495064, 0.06877066510809893, 0.054590937197096734, 0.14458717975993673, 0.08692898122712545, 0.1171710457223668, 0.035807612602044014, 0.08475520410473458, 0.13780003781346173, 0.12531039794642929, 0.14117979880320475, 0.12257086303036502, 0.1419727052191998, 0.1326401207432324, 0.14906575650597698, 0.13161048871312375, 0.1665534692762387, 0.12632045976981532, 0.1285242038101433, 0.11998143236800585, 0.12092273344758597, 0.11002055361242169, 0.11872520873504022, 0.12149131279270164, 0.11177704723405446, 0.11296163282453886, 0.9889364680950395, 0.9891766618699632, 0.9839663599168565, 0.9828082840068757, 0.99020509540409, 0.9819601332298714, 0.9858630911980752, 0.9867347697548582, 0.9887986576048745, 0.33113372663942675, 0.36436298735750483, 0.34190964132426116, 0.3465328105812705, 0.34481700702531926, 0.3394928048316035, 0.3224420057562649, 0.33740154228539654, 0.3395822992587023, 0.16799788615413114, 0.8476404043912984, 0.8205441434150034, 0.680584896307891, 0.214026366393815, 0.7896416287472118, 0.5863242280124432, 0.6488820182020703, 0.22883295883053423, 0.23653926796453228, 0.13145404488332768, 0.16788365901147406, 0.17342012255939898, 0.1816387738807278, 0.20268101281558892, 0.21794768196164405, 0.17208317733421952, 0.17931829375554176, 0.2047880084308472, 0.19419720504422056, 0.18650086947762246, 0.17729018647571826, 0.1292339140015143, 0.18830444668975432, 0.21407520859142137, 0.1881783484747147, 0.23957587287931503, 0.05996787173710405, 9.999999999998899e-05, 0.0016324806679418602, 0.030436483644146528, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051873752456840116, 0.12234904708349659, 0.14412966138475736, 0.059951073454349024, 0.12807142153850914, 0.039350855210738, 0.11107140092365375, 0.05890677142584533, 0.08000999421913535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005596675278710661, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031063340592912825, 9.999999999998899e-05, 9.999999999998899e-05, 0.07431744368592386, 0.10623408209476581, 0.10435267645948787, 0.1093546848447382, 0.11195472629438752, 0.12717623287229385, 0.058955586001801175, 0.07355365597076502, 0.05684412088638824, 0.4617273093407358, 0.43586125430671085, 0.4292055400611371, 0.4411496889957329, 0.45221860995824104, 0.4577264917345335, 0.45525528540206417, 0.4549379527226711, 0.46181878379602126, 0.08111018786051938, 0.13675343235374926, 0.07550414726267685, 0.13728498839657222, 0.15392263787402116, 0.1350867832617081, 0.10257949190071136, 0.1375204950381692, 0.15109013955587414, 0.18106038878041864, 0.29656395287696746, 0.1838071072617169, 0.2821503290264351, 0.2825033056933627, 0.18527129170814627, 0.23871484530436127, 0.27183973755185764, 0.18279704976531497, 0.3109874955292037, 0.32761613452985117, 0.2770598040653304, 0.31784913007890947, 0.305335024887775, 0.33371422860789957, 0.2666406558197325, 0.30848742157094133, 0.31503102364376223, 0.25789034321256177, 0.16576634046273353, 0.21034528750560444, 0.18323344578636458, 0.23976469215141705, 0.14735786624995795, 0.2884767744833252, 0.2629331743869956, 0.2575130156505766, 0.20029127168741467, 0.20690166550743916, 0.21781436067680104, 0.1624286504003858, 0.2236767051501729, 0.21640330395466023, 0.23017816773895794, 0.20363685674397403, 0.20536962739919407, 0.2316887549077442, 0.20348176001060725, 0.23781974487776747, 0.20096033026962612, 0.21420550358699064, 0.2869422935076271, 0.20463605405550578, 0.21601201499157863, 0.22086737408469803, 0.15191331594802138, 0.16132137703736193, 0.7260107586521989, 0.1780159821317604, 0.18388920039768553, 0.17220393800673306, 0.7294320044125385, 0.18535551296636787, 0.7385196307486998, 0.20939707363478377, 0.2053980687041248, 0.1675562567914467, 0.2097746952641436, 0.208981821347057, 0.1651170885181371, 0.21090538003753434, 0.4980825489129468, 0.16414367248953798, 0.19568666652092392, 0.1747966639476204, 0.20300519499034375, 0.17902649386816738, 0.18437548769179024, 0.18670709734279167, 0.18533229043209665, 0.19677034976644525, 0.20598608533685303, 0.08313202010301679, 0.08713977209736024, 0.08889812376883022, 0.08430365373649007, 0.08003822753440204, 0.08211261341240539, 0.08858352298579408, 0.1030506871258603, 0.07983643730936352]}, "mutation_prompt": null}
{"id": "912c691c-324f-46d2-9418-948353b8d027", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Combine PSO with DE and introduce a local search phase for enhanced fine-tuning near optima.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8888218781764702, 0.880908822584544, 0.8819137530900443, 0.9024527077825863, 0.8275492990477269, 0.8780466723184843, 0.8865179522940839, 0.8896961030550945, 0.8931615802150625, 0.7431507963936428, 0.7398258670596445, 0.7455720213508339, 0.7609868435163809, 0.7650364839167398, 0.7297426649554997, 0.7412901613802305, 0.6749839187357114, 0.7441227178104867, 0.15364710040560836, 0.14585885195876724, 0.15103507201481947, 0.07480976431634756, 0.10769271892292653, 0.17942314599346387, 0.7077073606683236, 0.15396533784347544, 0.11651891770201184, 0.09135013062031228, 0.12090339695724628, 0.1513677330693437, 0.13550518955600455, 0.12286599508425788, 0.09465756835607375, 0.10421637482378154, 0.11501699600369808, 0.10664446523797921, 0.9817235171022014, 0.9854296361641361, 0.9859321331884477, 0.9856438479314018, 0.9934927733958694, 0.9861320696557457, 0.9857350586171216, 0.9884797817620105, 0.9922191813574057, 0.7390538229130708, 0.7456304091074786, 0.7395821719499789, 0.6968374025747736, 0.7233026919327552, 0.6614252288657516, 0.7215366315841594, 0.6251094568622771, 0.7520180943665379, 0.13470102837396736, 0.22576441002713543, 0.21522078162363145, 0.359093606646417, 0.3784734164844281, 0.20982366752152126, 0.8308690488757176, 0.39846702994374816, 0.8331738617133266, 0.22292577252365497, 0.1297909233873077, 0.2409342012840937, 0.1336088546233295, 0.25293246515546963, 0.2263059391436344, 0.23530142879834604, 0.2780869750131114, 0.2189482916013028, 0.28978346488725626, 0.23365795826591174, 0.24792769790886537, 0.2750085058311519, 0.24703495024927857, 0.2724621835217931, 0.10096209321256033, 0.12763835115469524, 0.23769031469334023, 9.999999999998899e-05, 0.010018027497873505, 0.060923237623890625, 0.03901577285660207, 0.003770482613189574, 0.05923616190913217, 0.00011129425083911126, 9.999999999998899e-05, 9.999999999998899e-05, 0.06940469216796119, 0.11350507481528016, 0.06615947430098734, 0.01434223300596893, 0.05195326428870306, 0.018746393510402082, 0.06276552309485328, 0.02218830527636617, 0.05939201056902743, 0.09458047039854478, 0.03455464894786875, 0.11335639980098167, 0.07905248723640013, 0.1288068988360508, 0.0775317674260616, 0.09685545134132922, 0.2629926953271614, 0.10427367955057198, 0.0425288421199046, 0.0413930087388753, 0.04566306797057207, 0.07848987769647575, 0.12556656413337042, 0.1691092810970708, 0.08238774405999116, 0.04841157601511881, 0.0812734325622474, 0.5410924493878307, 0.6009032256950365, 0.6145530852173484, 0.6197533059648217, 0.5450092979178375, 0.5680190063690906, 0.5742546226187777, 0.5723406939771347, 0.612300937440909, 0.11812818412284609, 0.11392953314654608, 0.11058362055984794, 0.11473721783749047, 0.08322819854295771, 0.09237335574495609, 0.11691255144092316, 0.14947741680242144, 0.1521407699135967, 0.2406847132573129, 0.2512465746222008, 0.17242091210505373, 0.21598973460597704, 0.2012023932428192, 0.25631308138128306, 0.2123607100847258, 0.2408327507964556, 0.15457647785283135, 0.257268536340595, 0.3603980841995117, 0.504803965577266, 0.27452074757542055, 0.5275432321272382, 0.6370537239111412, 0.4215785470425456, 0.5090530643524369, 0.6459392747161186, 0.3502947754498429, 0.2965991752663366, 0.24554749986513646, 0.18752096460141388, 0.20259012086591088, 0.27806233495970645, 0.27608212221377404, 0.27223723443527137, 0.3739969844153206, 0.22045564181544586, 0.21015227435499684, 0.25488532762901184, 0.20197996462564205, 0.23546297483480805, 0.2032576798023613, 0.2183065463153463, 0.20548387413672442, 0.22598357992221285, 0.1903174277912132, 0.2206624234454475, 0.21627413138804963, 0.24423933455290203, 0.1998450145095617, 0.19553886936670606, 0.20520866631169843, 0.19071371012178429, 0.216164768137034, 0.15214969213745078, 0.16403582946425854, 0.17418637424286154, 0.17680976170232354, 0.20483259880149862, 0.8980776689079129, 0.8162726335220362, 0.8762036871482406, 0.8304614126103659, 0.20808774044842193, 0.16641608876783398, 0.16713232672487488, 0.2077147134918862, 0.7751916982010196, 0.725795886548245, 0.1676116528023769, 0.12720064734426217, 0.16756003660815755, 0.22854420681709176, 0.1851377253367984, 0.17590506699584474, 0.20112326042360473, 0.18362533634955835, 0.2083390453098699, 0.20013690441895138, 0.18113232982453598, 0.18536104902949202, 0.09857937944191886, 0.0855724556136398, 0.15067590551275956, 0.08765599755006892, 0.15991339982432617, 0.10187103208966442, 0.10064044288879903, 0.13729572276723756, 0.09547367094714787]}, "mutation_prompt": null}
{"id": "4efdc77f-9dd9-4545-ac84-654d8218d5c2", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.9  # Adaptive starting weight\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            # Adaptive inertia weight\n            self.w = 0.4 + 0.5 * (1 - self.func_evals / self.budget)  \n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            # Adaptive mutation factor\n            self.f = 0.5 + 0.4 * (self.func_evals / self.budget)\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce adaptive inertia weight in PSO and scale mutation factor dynamically for better balance between exploration and exploitation.", "configspace": "", "generation": 45, "fitness": 0.22436300160848333, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.6072962705161444, 0.6014422109922748, 0.5782569891041666, 0.6209765788909305, 0.6139903821588215, 0.6206429266293998, 0.5430717224373837, 0.5973684834794769, 0.5879364096284991, 0.05159867635491899, 0.358235470935907, 0.31953996027230536, 0.037178355822942266, 0.26568423448023026, 0.25707364631156115, 0.307034078099369, 0.27538111273662547, 0.2708727814878993, 0.11203173664262778, 0.07246644945777514, 0.10833360981766149, 0.06986866075700471, 0.131369357954099, 0.12476910348874193, 0.25570957855572274, 0.10613598094436094, 0.1208774978071715, 0.08907148303049695, 0.0859317102227034, 0.09033662583681179, 0.0908473927908865, 0.11763225087351803, 0.11680614624136465, 0.11818219560026233, 0.11513487288197832, 0.0842019306274906, 0.989317190604788, 0.9858265747842114, 0.9883586250988468, 0.9828217622755104, 0.9893741367344971, 0.9912752399209661, 0.9859271244075718, 0.9830751302175351, 0.9927717896115007, 0.35656880654133916, 0.33549442357344894, 0.10281138744963614, 0.3843731335767784, 0.23809518818440079, 0.1534841800264628, 0.3503066844995546, 0.3379148330660847, 0.29743979569117074, 0.2735935438629914, 0.15719834576388803, 0.2777785802504066, 0.15094525911838375, 0.2431757335802266, 0.18518383309850828, 0.28891877910330455, 0.21273009276368637, 0.19517226012783906, 0.1504549457050678, 0.16195854150822164, 0.14099943284268868, 0.07598836037173329, 0.08827046074703482, 0.10240770493916895, 0.12161966239278588, 0.1464463930455817, 0.14715274563386682, 0.10172825452739143, 0.1540910720952119, 0.09314956191561685, 0.13285239016375783, 0.0718986044549691, 0.1817711712249419, 0.11472633063778759, 0.058603918100003316, 0.0754451804480395, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04285007484547909, 0.020511788223296357, 0.0009158042079141504, 9.999999999998899e-05, 0.002208417762760151, 9.999999999998899e-05, 0.10466598120048332, 0.054857359484516754, 0.05314261776375062, 0.0685737763222738, 0.0008994581286493331, 0.10071399150538107, 0.016764034992317822, 0.05562846425011103, 0.05131084895071458, 0.030212995902299422, 0.020448075932232523, 0.02142071843244342, 0.04038274694183641, 0.08830259205953406, 0.0461380307994117, 0.057772132149968236, 0.05062123701754295, 0.038403040518052545, 0.06546483961597283, 0.03854913032998597, 0.19084224928102556, 0.054474277655109704, 0.028946127745204442, 0.07871295454393168, 0.09051972652691531, 0.04117655503696949, 0.06427433262585713, 0.40575942516080743, 0.4526068899250526, 0.38224988421576267, 0.4240775977316201, 0.4617960974651786, 0.46865364237162455, 0.43932878702621836, 0.4252088005734942, 0.4319605779679966, 0.08482366814522357, 0.11427455980020351, 0.0991184634528236, 0.09416835425549941, 0.1061935871977977, 0.10498333895806011, 0.11407980590766442, 0.09737205931439841, 0.10416935097902369, 0.186349047011236, 0.1563898472785038, 0.2571971252084563, 0.3363701386866864, 0.2314702781378155, 0.2359576447224434, 0.1853144200047837, 0.183159177717237, 0.18284468593604963, 0.26987451953314545, 0.22395933316837346, 0.37586644408978076, 0.3066239638588558, 0.31965594521194607, 0.287104036782713, 0.2600690817812197, 0.37343861311975135, 0.34803328259315236, 0.2346219085797394, 0.22655998508419284, 0.20926180759596313, 0.2163141420723027, 0.17448393827151554, 0.2097870495833024, 0.2745478170127803, 0.22894607567305902, 0.22110489034015923, 0.19616193558248796, 0.17586423439162813, 0.20473670295893498, 0.1886898321873094, 0.1752415227576536, 0.20942934689209025, 0.20285763552027414, 0.18273455007761408, 0.21532411343876146, 0.20546767031217394, 0.2032607753326191, 0.21543154528192532, 0.1880820227358574, 0.376034349618935, 0.19332059203582896, 0.20365905874998147, 0.19341536929637926, 0.20663429648767695, 0.16758376467318647, 0.17017606318633316, 0.18883407099959182, 0.6865649684371073, 0.163160496564706, 0.1577169062524203, 0.1833893480951423, 0.17840514765140647, 0.16016998192580834, 0.16168654043227926, 0.16208937352364006, 0.24690256272031907, 0.38813033471580427, 0.18939552770238444, 0.19063987393548631, 0.20938553631212042, 0.21024922276794367, 0.20992830202634138, 0.1886036274113564, 0.18661184989374802, 0.18438306671879856, 0.21738153712718, 0.19673777760403177, 0.19343928814666655, 0.20193550760515577, 0.20481522436068722, 0.204637866371981, 0.07759504611117796, 0.07093378809610018, 0.08172210871033858, 0.07790568777804296, 0.084076152324565, 0.07062617505894664, 0.08631659946076631, 0.07693578169173776, 0.07787917856847804]}, "mutation_prompt": null}
{"id": "40a05a5b-7bba-4311-b0a0-6920b08398d0", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w_initial = 0.5\n        self.w_final = 0.3\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = self.w_initial * (1 - progress) + self.w_final * progress\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(3):  # Increase number of variations for local search\n                            variation = np.random.uniform(-0.2, 0.2, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improve convergence by dynamically adjusting the inertia weight and adding a larger local search phase near the best-known solution.", "configspace": "", "generation": 46, "fitness": 0.30664066417506475, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.8797447991682865, 0.8902492940929075, 0.883166206935251, 0.8793625368159391, 0.896056705218585, 0.8844877068109593, 0.8843506526634076, 0.8969355460399009, 0.8720310033228214, 0.769356180818317, 0.07220626588470314, 0.7507232291100125, 0.6148591500718075, 0.7532806147266258, 0.06220570755552435, 0.7523867195852542, 0.7000880637624686, 0.7625206774614484, 0.11396635797314791, 0.1357654492680609, 0.11345483466050332, 0.13733462081764924, 0.17407683828673726, 0.09903552310467167, 0.1467006257885407, 0.14761988845433083, 0.14230282436253183, 0.15438064625976344, 0.11494333481716767, 0.1251030199259099, 0.11108250747823789, 0.151119923706046, 0.14687539177370312, 0.155876510779285, 0.10588996892180735, 0.09719924769590382, 0.9906939811414301, 0.9914359981657651, 0.9808283311584299, 0.9891928573643265, 0.9921799436794616, 0.9858478583829362, 0.9917827682789181, 0.990038444576631, 0.994951317060766, 0.7664725638560821, 0.7677766124455391, 0.7503319123369376, 0.7690866728719054, 0.7520309743340715, 0.7135761698551519, 0.7032375585908843, 0.6706507566051912, 0.6657498256671052, 0.2354517429798919, 0.3805121092194583, 0.1717961371276815, 0.27541720639466705, 0.21007846247972162, 0.2085767613713333, 0.2278936895075362, 0.22964272511660366, 0.8569436138308199, 0.2315226502143375, 0.12489904700580934, 0.13088178104320436, 0.23871645338973346, 0.11265328879552272, 0.22290844031439816, 0.22449219315299107, 0.24352633454555594, 0.228994678002989, 0.2676291153207402, 0.22298318539745599, 0.11692842804429382, 0.29091805298321927, 0.1309124917752893, 0.306387806449141, 0.2779990742144768, 0.26419916564647505, 0.28009266905985775, 0.07514366885102186, 9.999999999998899e-05, 0.004892051584367674, 0.003514053571067599, 0.0005275715404593484, 0.03901013251169916, 0.0002360202230616837, 9.999999999998899e-05, 0.08018314464361065, 0.07841209304403196, 0.0399453980554727, 0.17740685438842263, 0.02041539120547131, 0.023976207327728427, 0.08991946861578093, 0.0869839712000181, 0.11160851202902144, 0.09830847186168923, 0.026653015085870146, 0.07622139610083889, 0.05014855395427298, 0.07636419870588274, 0.09378506871895131, 0.07734540599049056, 0.09808062584800559, 0.16374143361797777, 0.09393483440391304, 0.11154292260116183, 0.12927732155565208, 0.011240464583952448, 0.04618565892944393, 0.10012225033796263, 0.15582934328447484, 0.04883034270017672, 0.04867117251607711, 0.08428567185994962, 0.6186395204324695, 0.5658122425725096, 0.5529207332330127, 0.5747452439836411, 0.5293968261176356, 0.6159439863239176, 0.586414401217662, 0.6387651375559515, 0.5932258642711017, 0.07573328386516809, 0.051317571569585385, 0.11364545772268253, 0.08073107188009887, 0.14041428049532, 0.14033671390367286, 0.11397587439488821, 0.11277775569246062, 0.11671238845417031, 0.18810392102827211, 0.17448507902715193, 0.21857154796148548, 0.26237847001063896, 0.2664542691101969, 0.22304432795580476, 0.3525376539113164, 0.26138252888220104, 0.38374172904015547, 0.22202229642207472, 0.4497865974891744, 0.23642656520596317, 0.41841488156471796, 0.5062778145111535, 0.3702297720631026, 0.5234692166195948, 0.5582744729148694, 0.5924633434683947, 0.27011278353106327, 0.19329706123820223, 0.2867528432203279, 0.29155383756530007, 0.18693761863009584, 0.20965180288153418, 0.3582056647806794, 0.29922046430598437, 0.2068316109424182, 0.20577831095307353, 0.23428067794147067, 0.19459225137824376, 0.21683658961425967, 0.19169994974343185, 0.225257743275863, 0.22817585422554443, 0.2399655263110515, 0.18277082550927848, 0.23950567674437184, 0.22296880225257687, 0.22368782919551322, 0.22160242555284293, 0.20548487914058067, 0.183136156324751, 0.20953727578268766, 0.1963128294748525, 0.7704073212778411, 0.1714951982101124, 0.19953569244859193, 0.161553304214186, 0.17512729567337704, 0.16526882146629562, 0.19628834946371954, 0.16653519995127897, 0.1926002809896079, 0.21202403623760635, 0.11277783659796203, 0.1676096510191919, 0.2092322933073062, 0.7799583811843106, 0.7082582049584317, 0.20915415453494735, 0.20980424749730997, 0.21209119638754237, 0.11148478647711124, 0.19264287745162223, 0.20254782681688333, 0.18978853622857939, 0.19907812280150317, 0.20463981003165976, 0.18929219837300038, 0.1845887718183884, 0.1820391315242076, 0.17860660320528277, 0.10891960096319087, 0.09303566290135079, 0.09212225005065289, 0.0835683164720693, 0.0991620767838276, 0.08922304702978456, 0.09027485177327821, 0.09219448069658664, 0.09921979828624572]}, "mutation_prompt": null}
{"id": "d39339fe-94e3-44dd-b5a2-69687afd8426", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Gaussian perturbation\n                            variation = np.random.normal(0, 0.05, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce Gaussian perturbation in the local search phase for enhanced exploration and convergence.", "configspace": "", "generation": 47, "fitness": 0.3189702442473731, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.888497662414897, 0.887329216929206, 0.8691695495288101, 0.8942146886431246, 0.8344660441533365, 0.893252343418484, 0.8684277337162951, 0.8789026084454988, 0.8749731853762781, 0.7321855608231835, 0.7506706824621747, 0.07531200524758863, 0.7636508771544505, 9.999999999998899e-05, 0.6875589534512785, 0.7011712765442184, 0.7365677861639923, 0.7556846838390516, 0.15279161409540343, 0.1366122083529393, 0.16742620287446675, 0.1463825737989808, 0.07211253771953763, 0.11499850571573844, 0.15400665928006674, 0.15473972426874139, 0.13060628995039947, 0.09434891057640327, 0.13941780702954787, 0.10553389077502229, 0.10950913843666399, 0.1025669522802366, 0.09569056586040481, 0.11161267019844268, 0.15044827947039463, 0.07041505156765993, 0.9891908627205376, 0.9897476873466731, 0.98830173960828, 0.9813436510273201, 0.9930397285194555, 0.9869948403781438, 0.9785614301030674, 0.9887019834736932, 0.9865716994829059, 0.7533291698862742, 0.691518760161745, 0.7538536416685343, 0.7586387655287636, 0.6083332989293577, 0.6673282271850935, 0.7024252664408304, 0.6517852088703948, 0.7682090202107771, 0.22432383249879229, 0.22316489119695904, 0.36604980685774413, 0.36719369910818656, 0.3758227613554278, 0.19202427297805913, 0.1235115941384205, 0.861041900711839, 0.3960904820015928, 0.23383830635305325, 0.23596331758934042, 0.2418929716638647, 0.25607249219417494, 0.13340807802276378, 0.2347526978540495, 0.23603227540086136, 0.23293171855065842, 0.1211800694758356, 0.23551433674102817, 0.2369150929782765, 0.12506021499142184, 0.13200534419059573, 0.12999607360118093, 0.25692108170202166, 0.10822856410212878, 0.259201457932386, 0.25393753966385635, 9.999999999998899e-05, 0.0841266457773836, 9.999999999998899e-05, 0.04191960764849878, 9.999999999998899e-05, 0.015134212522271762, 0.00022972937353149536, 0.003467234223239024, 0.05781390180513446, 0.1052636699312437, 0.05043233180994999, 0.07028250562408334, 0.029198254221476594, 0.07044147039246018, 0.09882269030764745, 0.05686661263349446, 0.027563773911348677, 0.07943682869434232, 0.03650014775045296, 0.020856468782529003, 0.08698922869831005, 0.07818960380560225, 0.09568342368168736, 0.11973258929885311, 0.1235126522688621, 0.07566053438993581, 0.28376437158481316, 0.21260727019012715, 0.04342238306877766, 0.17668823476134787, 0.09015057165284501, 0.038799456055860215, 0.16856100248237582, 0.04786858631122981, 0.04802782084468871, 0.08569717857428027, 0.5764021978137859, 0.5479028337153546, 0.5477763542466932, 0.6157976624005174, 0.5910278417582335, 0.6074018563047245, 0.5636879615261845, 0.596708930830536, 0.5702655189368304, 0.10218459047224038, 0.10603078301814672, 0.15488586263566573, 0.1118714446189204, 0.13280647034753634, 0.12551120913366298, 0.13738142623510607, 0.12671592941768572, 0.10844497182458201, 0.2592293628693819, 0.26558322847781723, 0.16940200878017442, 0.24826291434231662, 0.5021998267470442, 0.1546395074369299, 0.18216204533914837, 0.15776922575563934, 0.3775880873055082, 0.5661103651533329, 0.3162059720210305, 0.567323309471734, 0.41552372518549996, 0.3133616552292552, 0.43829085689447667, 0.5203498812798912, 0.5259672530246142, 0.5763774947948134, 0.29863087391997867, 0.24723070023794846, 0.3250265825663051, 0.2575151747501695, 0.2077989806799122, 0.2277831860711238, 0.30496802395231803, 0.3668474191707356, 0.27379914380089054, 0.20972792162215104, 0.20926361127219228, 0.21790801807182414, 0.21511780764441435, 0.1874463614413855, 0.2398449019441189, 0.21143901451721925, 0.2059040561309663, 0.23338956230645713, 0.20483863843308192, 0.20436728259720582, 0.19249758909753734, 0.21715531491374962, 0.7408904235674609, 0.19602521566472464, 0.21702929303832053, 0.18468636266908356, 0.18718077166277491, 0.17452457344948047, 0.2101216563522531, 0.20784141097255926, 0.18605289021619187, 0.18776608618102464, 0.9143603321527023, 0.15135315312401532, 0.2074695244926804, 0.910328101069847, 0.15463349805501203, 0.16724715090262166, 0.43743320667397656, 0.2115407759842205, 0.7420660330098776, 0.7024568169263907, 0.725020731773514, 0.20837902769729, 0.15547818651677847, 0.19982702223765536, 0.1942484239233695, 0.1841239546508857, 0.1927840938957922, 0.18657620660066665, 0.2095298538437237, 0.1888175218454684, 0.19510388011584423, 0.19723600521677154, 0.09780951681369165, 0.10063236229473715, 0.08929582011517156, 0.14667938017441196, 0.07768063692365268, 0.0908421276287571, 0.08735075559765815, 0.09575106924819721, 0.08943288462866184]}, "mutation_prompt": null}
{"id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 48, "fitness": 0.3387711369178315, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "9fb6042e-4d87-4059-b2ab-ec1310122026", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "d2b01b61-416d-409d-83b9-fab2bd552031", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.6 * (1 - progress) + 0.2 * progress  # Increased adaptive weight range\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        if np.random.rand() < 0.3:  # Adjusted probability for minor variation\n                            for _ in range(2):\n                                variation = np.random.uniform(-0.1, 0.1, self.dim)\n                                candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                                candidate_score = func(candidate)\n                                self.func_evals += 1\n                                if candidate_score < self.global_best_score:\n                                    self.global_best = candidate\n                                    self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improve local search by modifying trial selection criteria and increasing adaptive weight range.", "configspace": "", "generation": 49, "fitness": 0.31076360419593363, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8431800888619712, 0.8665842618169449, 0.841041335344747, 0.8573452956639898, 0.8601787221096487, 0.6209825177984292, 0.847134999432566, 0.877673592986552, 0.8448688798519197, 0.6998896424608694, 0.5485733593124811, 0.735712908367256, 0.6718314112785202, 0.04652243893010144, 0.7118629486892558, 0.6928434828254365, 0.7424185674341138, 0.6918358738823644, 0.13838506132358275, 0.1602475216296958, 0.16586859473870408, 0.07131793169397493, 0.17230569116182737, 0.6608689945492211, 0.1146472300158482, 0.1523633483179776, 0.1064542181243443, 0.16318987477369207, 0.11086798961061362, 0.12659031666450138, 0.12430358549079068, 0.12894053100187797, 0.12363394659066418, 0.163755698915382, 0.12503398899286056, 0.11699712890004865, 0.9892243267939446, 0.9907975896283161, 0.9823876947111037, 0.9866214967697886, 0.993412850561347, 0.986899746788935, 0.9900399376681215, 0.9906280032949975, 0.9903934600947185, 0.725745295201758, 0.6406481080811246, 0.6235728893196688, 0.14317556987865065, 0.7042947252441276, 0.6385489503465587, 0.16406566270123368, 0.7239056208492712, 0.5832517248058529, 0.3425130385214751, 0.36439124809630574, 0.8140814327386348, 0.2037196830403053, 0.3625572947440776, 0.8450743313608562, 0.8621015137004497, 0.8271914603134516, 0.23572197645727155, 0.22068970895171436, 0.2408573621572221, 0.20596598475790084, 0.21519078050362628, 0.10401695072336858, 0.12723909627971974, 0.2196243194840074, 0.20035398261774506, 0.22396909224600137, 0.10700909465518238, 0.08473931743404595, 0.23413264738062212, 0.247124377119317, 0.12850552899484702, 0.24556167531694384, 0.15190751021451887, 0.23676269053770516, 0.07279072784847762, 0.0013190730401496653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033503518413338096, 0.08227520066666272, 0.07951951016617953, 0.08064787383636829, 0.07464528188721031, 0.07254266941853038, 0.16178740491348342, 0.05368366629401444, 0.04620808214706229, 0.061626894824220235, 0.16901363624932053, 0.03193246626876356, 9.999999999998899e-05, 0.03378206190269717, 0.18076884892079614, 0.09274111979581845, 0.08982839545707033, 0.1028832099657595, 0.10134031026992252, 0.11387851494350376, 0.14337637601394893, 0.04189452793421333, 0.08030279328861212, 0.08205650312536394, 0.11379257280419375, 0.1432115299161154, 0.056442624345703574, 0.04843507972597727, 0.10647601048558464, 0.6144007659262822, 0.5312924630621372, 0.5477030599689383, 0.5627625159246756, 0.5858388116396034, 0.5595211060018273, 0.5472436764097481, 0.5983745895415118, 0.5921486218022829, 0.13983317878475177, 0.11434580909341707, 0.0975593195273301, 0.12167070580776185, 0.15271778553274618, 0.1437765419206396, 0.12148713088538365, 0.12899593223677674, 0.1453939575954497, 0.2625797534963853, 0.17289064710919588, 0.20467694969955252, 0.16292516406988944, 0.22898193133406808, 0.1853667229173599, 0.2020280420852213, 0.2021314607091974, 0.2527365538961196, 0.3469803859635303, 0.4715387424119504, 0.3061249192244513, 0.3904631385094536, 0.32145592992859007, 0.35871562434623083, 0.20977222506284332, 0.5865131546182105, 0.22670892373082174, 0.17077147054847064, 0.42974509190011967, 0.23858884627850152, 0.33256378647677887, 0.3462105217096004, 0.25111656839928087, 0.25262639642642015, 0.2691181855121123, 0.3595905843025091, 0.19660384978188272, 0.22381786562165584, 0.1846611281242575, 0.20518547428906964, 0.27637135336589524, 0.21261907820588688, 0.19771673698773962, 0.2031084208536459, 0.2079346564088672, 0.24213611634299903, 0.23935689258633774, 0.20657335537215793, 0.2156533960264604, 0.24394788351405228, 0.19370552983710876, 0.7142059940212665, 0.18334414708622426, 0.1975971004117788, 0.20727240816445447, 0.8977825894757197, 0.19751743403303712, 0.8308300664149679, 0.12984514774630262, 0.1773873582567912, 0.16662065398652504, 0.8398962786371643, 0.1841852677649699, 0.6471252861419664, 0.20849383961456613, 0.14340589868809217, 0.20551015054549027, 0.09776138669807866, 0.2074971929897017, 0.2056948715810335, 0.21092285071919636, 0.15260246231592678, 0.19068677514282473, 0.18454023707364586, 0.21843884602712804, 0.17974159594962402, 0.21503864641766457, 0.18712711634571355, 0.18642930766716703, 0.2191612346093944, 0.23000270440977155, 0.09211768463090375, 0.08691073045393838, 0.08606213081339298, 0.10998365265715004, 0.08269578995875271, 0.09423807039084531, 0.09641819332649759, 0.09950050392270238, 0.08469325608648537]}, "mutation_prompt": null}
{"id": "73fecf2e-786d-4b38-af9b-ef1532d8fc80", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            progress = self.func_evals / self.budget\n            f_dynamic = self.f * (1 - progress) + 0.4 * progress  # Adaptive mutation scaling\n            mutant = np.clip(a + f_dynamic * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce adaptive mutation scaling in DE based on progress to balance exploration and exploitation dynamically.", "configspace": "", "generation": 50, "fitness": 0.33072768685220083, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8775970197419508, 0.8762424784320849, 0.880367829532201, 0.891590245009517, 0.8556753200607838, 0.8930696772191762, 0.9014459259224872, 0.8999676807206769, 0.8994007159185398, 0.7698477099542083, 0.7637624358883336, 0.7630096615749391, 0.7356320959503715, 0.7616881299365278, 0.7827367155782775, 0.018316082927927524, 0.5873841988152846, 0.7672877585204088, 0.17475202630342268, 0.16013619027369008, 0.10038791805828007, 0.15216039132484727, 0.07390369122337748, 0.07186961953880056, 0.11360597566525288, 0.1766179329143439, 0.0626693726708325, 0.14677137699395448, 0.6325853049330605, 0.09262317318738189, 0.10614470559304812, 0.11286560822231295, 0.14827738875275953, 0.13045040812984676, 0.11469673673995495, 0.17277488440489397, 0.9822985185984799, 0.9854275012047206, 0.985929693202049, 0.9867673356664995, 0.9934927486024009, 0.9861287025008786, 0.9857353423331451, 0.9884796693839042, 0.992218157587406, 0.7635572328326118, 0.7405561734014867, 0.7512649354986394, 0.7204595359191468, 0.763869175377313, 0.7296061474816085, 0.7225440324198564, 0.6281355162230121, 0.7659699777628345, 0.2322768388482126, 0.3812542535286766, 0.20257871192321808, 0.4738032502420937, 0.8989587596789317, 0.8779949057862574, 0.22399381745353908, 0.24444522476286368, 0.8177487097093796, 0.11698980475435461, 0.247202203798228, 0.25720706409412897, 0.13228213354481833, 0.2578517201597129, 0.24677947150749535, 0.21694055080943586, 0.17736361141841284, 0.23779542027057854, 0.13082983961983496, 0.24275697800516083, 0.23198634744720414, 0.30076737670246134, 0.24508145413611715, 0.23191086321603493, 0.09936556785833162, 0.2638810367165706, 0.2389223427305721, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025902576077800887, 0.02727829624196365, 9.999999999998899e-05, 0.060022939593978086, 0.0013023093067900948, 9.999999999998899e-05, 0.011511525047990134, 0.0753951877843263, 0.09310579144176045, 0.11294055083744448, 0.01404180377413744, 0.03959054503509851, 0.01791940807349124, 0.04304655379312461, 0.014199434910377784, 0.07439445760549512, 0.06823559468979001, 0.02886397610527036, 0.1406896707969192, 0.07599675678424356, 0.16268819472795892, 0.07866570702463727, 0.10221841804396936, 0.30363569364790743, 0.1082981862203104, 0.04240974411274656, 0.04385383391366382, 0.04339138602374659, 0.15208006073664238, 0.06023212767470554, 0.17723444174362735, 0.08231328732448506, 0.048436025706083075, 0.08198124727864231, 0.6026569252300514, 0.5418818601898725, 0.5984687830442018, 0.5740961615780698, 0.5697984895527548, 0.6235012427982274, 0.5847225129361171, 0.5719369732655428, 0.598228345994838, 0.12104997859308964, 0.10289321641280635, 0.08161584640742492, 0.10405085881486953, 0.11951313538821873, 0.08459429480045089, 0.11587128234644295, 0.10532226786950649, 0.11415670699405289, 0.26869334123013866, 0.2901943423600749, 0.22582315359331828, 0.2176669128940718, 0.19281237405772778, 0.2218166722668573, 0.179880700854108, 0.1261321097102771, 0.24154630551335288, 0.3222741140491342, 0.28442220330042867, 0.28840449684924974, 0.6115083901387062, 0.4008255400012928, 0.3108786148792001, 0.4136171219627597, 0.41486457152631195, 0.5451058554573328, 0.3656598031240048, 0.2824050867011305, 0.29000223889523735, 0.17419750282619118, 0.3525141870365833, 0.22903684271128577, 0.10684438475132119, 0.2895991639438026, 0.27279998030645725, 0.2103202746887829, 0.23838328070463732, 0.2428157852138605, 0.2531226444386996, 0.1768712830215593, 0.2077806523044604, 0.21610852097471112, 0.2374634641609642, 0.21231538786778736, 0.7481876792514379, 0.21849316708788413, 0.2032460671412163, 0.21984021781116148, 0.2188276611367843, 0.2178309467800592, 0.20475169048178188, 0.22067324649372444, 0.18872195237879363, 0.15092436373403484, 0.1674606746320877, 0.8493788816164335, 0.17652443278772156, 0.1657569175005843, 0.9143657250468561, 0.8036034590395033, 0.9002000362693715, 0.16352655712745912, 0.11253603617296082, 0.2045665843443878, 0.4526133976750697, 0.20851298755250447, 0.2010235630895818, 0.7380869364421468, 0.16766340396083235, 0.8144900396676484, 0.16787140442367565, 0.19621891782921352, 0.1897426937821337, 0.19159254322642028, 0.19164714104183211, 0.1891015442385673, 0.18955007475792696, 0.2164017134260382, 0.22395826715401346, 0.191469082520062, 0.09934665004050836, 0.08889068161647684, 0.13655694347261105, 0.09818460405473395, 0.14229110236213438, 0.06630939900396993, 0.08468546979716829, 0.15438889878163287, 0.09941396183038465]}, "mutation_prompt": null}
{"id": "e320de3f-601c-4a7a-a62f-79aec579e79b", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n\n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Dynamic local search phase\n                        for _ in range(3):  # Minor modification now iteratively\n                            variation = np.random.uniform(-0.05, 0.05, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce a more dynamic local search strategy within PSO_DE to enhance fine-tuning of solutions.", "configspace": "", "generation": 51, "fitness": 0.3185005562604008, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8797402978233343, 0.8902492033056675, 0.8756458378331249, 0.8880632401149007, 0.8766115010184894, 0.8789526732425675, 0.8763888729118711, 0.8797383605868144, 0.824333515879853, 0.7206431340222185, 0.07346688110918076, 0.7395987009478491, 0.7330631660652468, 0.7583795308799381, 0.6940815502179171, 0.764530760754494, 0.751419838860958, 0.6026519927669988, 0.1291238345729473, 0.15584914284572005, 0.13820058382392286, 0.17636466599120781, 0.11092771381593425, 0.12241903343764282, 0.1099478410181739, 0.6929694909829966, 0.15274840070882312, 0.1299430527226113, 0.09612991862711928, 0.0913834546985316, 0.12600548546085266, 0.1524670101066351, 0.15419844070449285, 0.10583409813365507, 0.15733509865736728, 0.13594245176957742, 0.9906873653962719, 0.9914193124710319, 0.9807912123861222, 0.9891779009646615, 0.9921697650107754, 0.9858478334689661, 0.9917710425488139, 0.9900096496480852, 0.9949504929125641, 0.7198958479375526, 0.7906351388599211, 0.6710448760361923, 0.7425582365895451, 0.7867876001518243, 0.7252855882992866, 0.7086288524073505, 0.7163633320976008, 0.5061107177024335, 0.2354517429798919, 0.8225737572809764, 0.2275965164656788, 0.20801057666664424, 0.9032418493027073, 0.21098426429693096, 0.842464045098741, 0.23071489415942592, 0.8593793502664211, 0.24528999009651775, 0.10714469629328871, 0.2456091595470481, 0.1324669718760071, 0.12727613272220883, 0.12945996585734842, 0.24299378383505188, 0.12965128968881323, 0.2324926739940466, 0.20946077007663466, 0.24156852935055617, 0.11705052556224838, 0.25482368034951264, 0.26837967897552695, 0.27914694971946297, 0.26983046615259454, 0.2518471371512523, 0.28322023847032385, 0.05235275690213581, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005275715404593484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1516180132821917, 0.04573550498880563, 0.0926364015970268, 0.03747453176357651, 0.027690214307984018, 0.10634820567925396, 0.05847746498667494, 0.10165271553671862, 0.02143479232929768, 0.03443402557395925, 0.08757582978320766, 0.05011994734805392, 0.07792086115594243, 0.15761640561331192, 0.0841706203484146, 0.100136621574486, 0.09546179414907419, 0.10191660334866681, 0.1082236886059823, 0.07722869186648862, 0.2728128097321766, 0.04268148707274666, 0.1820369288174326, 0.3005934928581434, 0.049208920960633784, 0.04876817263124922, 0.0925694197688377, 0.600505120990975, 0.5089481450767298, 0.5757898770451163, 0.5727754193978363, 0.5629643144100629, 0.5670668006582362, 0.5960441516357919, 0.6400858360577206, 0.5599688759991175, 0.09208398871270851, 0.11331144520057301, 0.13015092493220148, 0.1393768597819468, 0.1126496120193855, 0.1377271463219789, 0.11421654479253207, 0.11277775569246062, 0.11303739832592385, 0.17192896702557336, 0.15881361133159733, 0.17959961575833783, 0.1922621090243245, 0.26367783774405074, 0.21737266591546223, 0.2468239395561439, 0.2791923628501044, 0.3002646548687984, 0.4298980064249658, 0.2856384830721469, 0.42997037890682444, 0.4885746127345123, 0.376636775851957, 0.45067673339659264, 0.5153111587109238, 0.4175344821562412, 0.4840803134151085, 0.2586036089344548, 0.19402782213446312, 0.27568059025773195, 0.18907833765200244, 0.1860019374145504, 0.24432174968876874, 0.26291290927244526, 0.28736817548804405, 0.4005166377877184, 0.20607418920131204, 0.22358959365910025, 0.19458973157224868, 0.19493810739119177, 0.22056868463011592, 0.20575481432499887, 0.21464826019491268, 0.2192313913071865, 0.213221978519624, 0.195658408983037, 0.18099707898224116, 0.18650989699232923, 0.2185019999987864, 0.21760318144170498, 0.22028054163618827, 0.21046249150956853, 0.2450874614610281, 0.20844900412617506, 0.8807228415631424, 0.1993494395140084, 0.1611586581113994, 0.1308439459848798, 0.16529731297382422, 0.1671242937898334, 0.11858384554369783, 0.899836505445426, 0.20933662793382035, 0.1125821070599311, 0.16746073650197868, 0.11164581328396195, 0.20777571063691902, 0.15419275577435598, 0.20732429727385326, 0.20543690254847857, 0.21204467636081548, 0.7986049637191763, 0.18567233636205405, 0.20254782681688333, 0.18987114523570592, 0.1810132080489968, 0.20641534158032948, 0.1892906710781559, 0.2051122550031238, 0.19599952132921805, 0.17860660320528277, 0.1006280197541135, 0.09690548161662316, 0.09395964143030178, 0.08811116621133386, 0.09195547813734994, 0.09430487518599007, 0.09955636138801949, 0.11009273450371715, 0.07660286931556115]}, "mutation_prompt": null}
{"id": "356e049b-7efa-488b-9d09-89cd50eca2df", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(3):  # Enhanced local search frequency\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate local search by perturbing the global best more frequently to enhance exploitation.", "configspace": "", "generation": 52, "fitness": 0.3065850578182722, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8797418196797726, 0.8902492339831123, 0.8805283124478342, 0.8948677492215527, 0.8835219429845357, 0.8819451561878737, 0.8891830491600848, 0.8885406872220322, 0.7559772951003897, 0.07581299828587673, 0.7180642486065758, 0.7687421894804556, 0.7640972348936158, 0.7589799220743949, 0.06378793992394238, 0.7523867195852542, 0.7426755185378167, 9.999999999998899e-05, 0.14025691486662217, 0.1521287673947621, 0.1157750435109669, 0.12074321941075272, 0.11344610158579305, 0.10271912831499863, 0.1099478410181739, 0.1264775864156843, 0.56440890468758, 0.15438064625976344, 0.11734468074256965, 0.08751594622133818, 0.11074638557566974, 0.09073656998832302, 0.1383933998811292, 0.13800442671822943, 0.1350637447037334, 0.09699575877937239, 0.990689540093014, 0.9914247929417223, 0.9808028181507881, 0.9891828167521813, 0.9921736041940931, 0.9858478417656852, 0.9917748864563636, 0.990019603373438, 0.9949507662776803, 0.7254892275934943, 0.7367598560249106, 0.6908385340793763, 0.7124676200964855, 0.7589827521086614, 0.6791890837175489, 0.7243968047783577, 0.6894260315869359, 0.661388013335367, 0.3561398590540783, 0.37695325721865514, 0.17177197847675651, 0.21876936955114334, 0.2769170172443439, 0.19107393278935925, 0.17318909911882874, 0.175436795584336, 0.8482395646455033, 0.254719445756173, 0.1075836175491488, 0.2416114847737263, 0.1324157797001173, 0.1070242985031431, 0.2418776420037534, 0.2425283193973602, 0.29685706835695824, 0.24770834175719425, 0.13347350682689918, 0.23754962780954558, 0.11545935878240121, 0.26827374643435786, 0.27547897088603746, 0.33903930887127887, 0.27481702598399904, 0.133100964916687, 0.2264470629459533, 0.07800755452877561, 9.999999999998899e-05, 0.006644692324692558, 9.999999999998899e-05, 0.0005275715404593484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09319833470265892, 0.039544734090928846, 0.04539059681379898, 0.05618853054605866, 0.048795265054256354, 0.08991946861578093, 0.07358345246358311, 0.007863114736284427, 0.095626437747518, 0.03414285448975263, 0.08563111717961913, 0.047290221989414793, 0.07866562100140473, 0.09674277059211578, 0.07644085159556124, 0.1020968352081294, 0.09709101925457164, 0.09257059524700983, 0.20659839000917435, 0.06416396138978853, 0.27105175478904875, 0.0454343665813447, 0.09875345062542507, 0.20703510440769846, 0.0492559452754715, 0.05697018884397076, 0.10432755807709304, 0.5926358192843453, 0.5416355143755787, 0.5893289032269813, 0.5743411841627519, 0.5929200272381502, 0.6126326155204908, 0.5720368092783931, 0.6198353045806628, 0.5905745191712546, 0.10780765619347998, 0.12355354101210048, 0.11872239642832139, 0.10650557139243644, 0.12121972659215374, 0.1313820027418514, 0.11397587439488821, 0.11277775569246062, 0.13246997435065855, 0.1965971964119364, 0.26493812713198295, 0.30621089713498595, 0.15612624236241668, 0.26645386915526315, 0.15561793616855735, 0.17658548066269575, 0.16557259691461135, 0.25382585993302975, 0.44576482307585197, 0.29192365763634964, 0.2504509924899291, 0.4155861063593699, 0.3300559139990634, 0.4384193250612054, 0.4841160605265904, 0.5354011166538, 0.5384708481176406, 0.32225312148431906, 0.19544624097050467, 0.1875311764132901, 0.3156292736891798, 0.20071871775370265, 0.20089291431201328, 0.36408576741661614, 0.38206106209100754, 0.24791726834015737, 0.23007520415939742, 0.22195822704639878, 0.1945915720055552, 0.19532774593541324, 0.19675212515748952, 0.1829437840562128, 0.22381247380935532, 0.22757075051179687, 0.2571987189007745, 0.1878821470600629, 0.20391416443520383, 0.22108761478182182, 0.20398663466218225, 0.19944228200742165, 0.17884335683291208, 0.19718410237685124, 0.24563572741979312, 0.18131603802096274, 0.8951949458369594, 0.1994008833664873, 0.1624591476105539, 0.17570848619956814, 0.16532328792754902, 0.16728005779265698, 0.1676238350342072, 0.884688985733333, 0.211480389013874, 0.11279282814379077, 0.16774623828499113, 0.16671006567481217, 0.20957366803835908, 0.20796276258513235, 0.20662207521728426, 0.8055489793541937, 0.21201343443599419, 0.7846515956548329, 0.18567233636205405, 0.20254782681688333, 0.207356466208777, 0.1922018588502291, 0.19677022864531024, 0.18928810200653612, 0.20041515929180165, 0.19599483849166954, 0.17860660320528277, 0.08435149976003353, 0.10422946900816865, 0.09395723946075629, 0.10302595552100502, 0.10460542483752455, 0.1004973706451443, 0.09343431528928481, 0.09219448069658664, 0.09721070922672492]}, "mutation_prompt": null}
{"id": "d54302f8-745b-4c8e-bb6c-26f1ea7adeea", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "5bb1f563-6749-44bc-9e15-e5703def8378", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.normal(0, 0.05, self.dim)  # Gaussian perturbation\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance exploration by introducing Gaussian perturbation in local search phase to improve global convergence.", "configspace": "", "generation": 54, "fitness": 0.3214677252756986, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.890049525937057, 0.8981225312967049, 0.8916943756730935, 0.8829785760915206, 0.8347076978471535, 0.8932843186168166, 0.8920504944778396, 0.8874529965038461, 0.8862714733079066, 0.7700545984584166, 0.7386318765585752, 0.7073976984439339, 0.7470583729772264, 0.7801924571955348, 0.769370192650659, 0.7445451708123046, 0.7813139295968632, 0.05715380607345455, 0.6904547645790071, 0.12944910331364923, 0.1255788080127832, 0.15813287867251025, 0.07654773580700402, 0.12675426304912885, 0.1330760534421117, 0.12450974994289987, 0.1398191948220674, 0.08369155879941814, 0.14980440509954607, 0.1323925362172198, 0.11145321017634147, 0.09451839916895355, 0.1209469221152043, 0.11262515300478082, 0.11229176710332833, 0.10049689330430933, 0.989190186615313, 0.9897478297849105, 0.988300786958181, 0.9813432346029337, 0.993039719003633, 0.9869945822881824, 0.978556801399172, 0.9887011647283911, 0.9865697677737961, 0.7680391391643422, 0.7303689440282398, 0.7621651721067491, 0.7388213879862358, 0.7264420137446499, 0.7509684306032616, 0.5983649610173837, 0.6782238197385168, 0.7709946854609844, 0.3774106074730684, 0.3775592920546552, 0.382189690140614, 0.36887573773633453, 0.3664758471466981, 0.19242415691580195, 0.12341713296025592, 0.235950229146072, 0.23511538509523933, 0.1997477958647823, 0.24383341690308802, 0.3039394877094357, 0.2507002353615949, 0.13355836617359818, 0.24177536201504346, 0.21915383297086133, 0.24087837301957749, 0.1274894077135974, 0.24061155701620862, 0.24504510293810033, 0.2586037617855915, 0.13234768284959886, 0.19166638531854274, 0.2608167224936828, 0.10445274370264401, 0.2539235166200112, 0.1278670721053612, 9.999999999998899e-05, 9.999999999998899e-05, 0.08738897016411973, 0.10422136291176154, 9.999999999998899e-05, 0.09280405396238134, 0.0001609799751464136, 0.0027031037455946816, 0.037708929558220694, 0.10328842784825343, 0.05259041425767341, 0.1052269163909203, 0.05338939215712668, 0.05730884084631782, 0.09187181910578002, 0.04786646422109919, 0.02184567787740055, 0.05014715839184425, 0.03753678741987332, 0.0353340141244991, 0.06564699959068254, 0.07917490275592887, 0.09615920778043097, 0.11596757580971229, 0.102021040948436, 0.07509670246991895, 0.24492027041237907, 0.2021873613797356, 0.04341417093371969, 0.23988818872931383, 0.06185402421612196, 0.0386754258547386, 0.16274282401531348, 0.056982231667965455, 0.05687048791993765, 0.08242874723242544, 0.5750153702961304, 0.54901461843586, 0.5641997367405134, 0.5554929219704876, 0.5857753985891678, 0.5542769176735167, 0.6008812463050377, 0.6181194214596224, 0.5465967101557576, 0.11874127298811987, 0.09995063999219378, 0.10899742889997155, 0.12534058420421856, 0.10664489699371771, 0.13178228387005797, 0.15196462715597914, 0.165289210302207, 0.1649710566761563, 0.26353090784271593, 0.19811446359915952, 0.21830690646510498, 0.21195537094183248, 0.30975542592716754, 0.17952946084332144, 0.19438968316020333, 0.20185604152408765, 0.3097994047807169, 0.45627859153857, 0.4618565176254119, 0.5015819562885755, 0.45206055400369016, 0.3447519646354682, 0.5647488147482804, 0.6018543694670162, 0.5699475607846203, 0.6671014015485582, 0.16814502246871543, 0.25465876166950185, 0.27564403686108996, 0.24007325108300015, 0.19084287952819967, 0.28414445336874083, 0.293148083647389, 0.3904528181310447, 0.2238950433575867, 0.21568027362872444, 0.23265393372008691, 0.21960254949214375, 0.1873021184047191, 0.20829203887147685, 0.2078060261581529, 0.21855045410089302, 0.19467977591454189, 0.2090587614771443, 0.18042379415373822, 0.202589672773265, 0.21854360736378875, 0.20328097349953134, 0.802469169954159, 0.17561289330621843, 0.21843245781635912, 0.2062455982275615, 0.237779416971577, 0.17443911938613021, 0.20941829844737603, 0.12514401411211296, 0.1758108619419787, 0.18741841244107416, 0.9055911099321738, 0.15980493034679533, 0.2074303910758446, 0.8984367731791589, 0.15450238565452323, 0.16706743225489062, 0.39999259028993217, 0.21188271604070674, 0.6095598570587559, 0.7090711805200456, 0.15473110357575914, 0.2118653346532391, 0.15543129219443907, 0.21509930944782352, 0.19773467154718483, 0.18153359359211807, 0.18484563914111585, 0.19108452972939594, 0.21759304616710762, 0.18273091463354207, 0.17987023262894275, 0.19052962587765865, 0.08740988146257678, 0.1082292360350462, 0.10049086023131748, 0.11363911136138927, 0.09560550500029819, 0.09671487342131169, 0.09038627913621711, 0.08536630777745946, 0.08682714281400916]}, "mutation_prompt": null}
{"id": "917c8690-42ba-47bc-b90e-f7a78b7acf33", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            # Stochastic tunneling: perturb global best occasionally\n            if np.random.rand() < 0.05:\n                perturbation = np.random.uniform(-0.05, 0.05, self.dim)\n                perturbed_global_best = np.clip(self.global_best + perturbation, self.lower_bound, self.upper_bound)\n                perturbed_score = func(perturbed_global_best)\n                self.func_evals += 1\n                if perturbed_score < self.global_best_score:\n                    self.global_best = perturbed_global_best\n                    self.global_best_score = perturbed_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Incorporate stochastic tunneling to enhance exploration in the global search phase by occasionally perturbing the global best solution.", "configspace": "", "generation": 55, "fitness": 0.3125387160139986, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8787042293850965, 0.9078461178776506, 0.8889737873104461, 0.8878663726264677, 0.8429512102971906, 0.8808023168099732, 0.8963035036121512, 0.8857474267345006, 0.8792339830564614, 0.7512739304915066, 0.5704803908024831, 0.04204311212627998, 0.7309758105592885, 0.7550779333732798, 0.716150457740165, 0.05228334725406891, 0.8000299160064949, 0.797988350403667, 0.14060521526836578, 0.1879104059603648, 0.14133059891147548, 0.13300862195197427, 0.15722302074927064, 0.13645483270396852, 0.1412128294401055, 0.15787557478767356, 0.1514435537745361, 0.10580844688027813, 0.13413970973138878, 0.09200085575484995, 0.1543004965230308, 0.10694143404435796, 0.17006544770912246, 0.13964562984680595, 0.11127225908160943, 0.10871857511276484, 0.9827045139585951, 0.9863655686094926, 0.9784707223259854, 0.9885594512529516, 0.9937064047462807, 0.9897631105206475, 0.9845981443399003, 0.9867002547016118, 0.9893383570738908, 0.7600872239786143, 0.771760226293136, 0.7581333918854, 0.7801066746169527, 0.7290260053007693, 0.21338035050495863, 0.7231101259269785, 0.6845466288052335, 0.7348583639850751, 0.8085405345534242, 0.22490558989000842, 0.1398169808963483, 0.21062856102347527, 0.1912114392057508, 0.18821972020064304, 0.12632639019118597, 0.7592758863929395, 0.38092967226504193, 0.23481257080316265, 0.2327993473719191, 0.23357196379213596, 0.22823894285888968, 0.13068816205150446, 0.2653550741712858, 0.27571079961114686, 0.25455608004826225, 0.21777515582593254, 0.24387886026539163, 0.24659734965500002, 0.25916348169461256, 0.11549022967897604, 0.13418172354745472, 0.30196562571975927, 0.28194248994713533, 0.26395241661558655, 0.10353886571043769, 0.013250498039180991, 0.022369633424750957, 9.999999999998899e-05, 0.00028698749108568844, 9.999999999998899e-05, 0.02244615334429967, 0.00397497188530449, 0.009502212732648507, 9.999999999998899e-05, 0.03032392587601973, 0.02897479623775745, 0.057291200422831534, 0.001313217361271768, 0.04747882027736272, 0.016420894134608677, 0.03169003164152506, 0.03486253298837294, 0.09905645376562988, 0.035007893442269955, 0.03320266101295388, 0.048062167952772517, 0.07763557648006247, 0.08204877014233247, 0.21095608691805956, 0.09985836235416934, 0.22750106108932744, 0.1143987760336519, 0.08399927059974521, 0.15155495600450009, 0.08359567526673561, 0.10987152044747273, 0.038260477687919736, 0.0064933701518682385, 0.048650884996010446, 0.08221620999593238, 0.11509519474220942, 0.5398069691055697, 0.539715552682942, 0.5362597136894056, 0.5794044950888116, 0.555085785244418, 0.5826973921354136, 0.6254218317866431, 0.5827640923879914, 0.6206862496547174, 0.15240601676753462, 0.14522093099777345, 0.09613970679746031, 0.11714087804531959, 0.12134735530117158, 0.15638660492727763, 0.15717517798998415, 0.10459986881415517, 0.1260193642991515, 0.21250147531963426, 0.18385298641303016, 0.26623935743127314, 0.19881053888217814, 0.2164676753732766, 0.1552031444179176, 0.20398374584005774, 0.19406282125938557, 0.1709980505359574, 0.37375848195886496, 0.25165716890532563, 0.36998394467346785, 0.38530054937546565, 0.42890973396829457, 0.21411026993034188, 0.7181275171184295, 0.21345151991022138, 0.5394496081399509, 0.24608597600837012, 0.2340849006981992, 0.24602164812265426, 0.211523716139996, 0.23448105064989555, 0.2115287677182196, 0.48237552958531027, 0.3192559006064881, 0.4102623661354946, 0.22926701651999104, 0.22802192684988687, 0.20568062953654742, 0.2082282247109103, 0.2249330326475324, 0.2284209889776474, 0.23436632231109011, 0.210888331373967, 0.2357389001140946, 0.20559428346971154, 0.2021160810991307, 0.1735992234166862, 0.7599860724766194, 0.17539365781715388, 0.24282597978415232, 0.2203157888358317, 0.21974793394579928, 0.20089198522655016, 0.16349274730930852, 0.1654429964014671, 0.1627026829274184, 0.1919209339063026, 0.18773804138874517, 0.15497369424768948, 0.8760164159704491, 0.8958206593866019, 0.1700348636063702, 0.20688799193230611, 0.8202176881340701, 0.21033505405765485, 0.7465464272366048, 0.2106893764600366, 0.673359836672826, 0.16731426647911973, 0.20858992089782313, 0.1675329155396148, 0.19115810997140048, 0.1896652772725873, 0.20656000979991007, 0.21169446016196913, 0.19290869291103907, 0.1951350946993078, 0.1951817149867363, 0.18339577983404642, 0.1962966226229761, 0.09954208585054125, 0.1277948037851513, 0.10165507289255016, 0.10478157617743022, 0.0967860302212663, 0.09875989966274323, 0.08882132520638786, 0.14006167205899878, 0.07983472595385643]}, "mutation_prompt": null}
{"id": "bd8b0b50-fd66-4f3a-a9c1-70e1e4aad60f", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "3bfbb3aa-0b5b-4288-8070-d543cb30c227", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "66756739-e1c5-49a2-8327-f49c9ea7ad50", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            direction = np.sign(self.global_best - trial)\n                            variation = np.random.uniform(0, 0.1, self.dim) * direction\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce a directed mutation strategy in the local search phase for enhanced exploitation.", "configspace": "", "generation": 58, "fitness": 0.30667751871938836, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.9089442412220052, 0.8904080304152729, 0.8921901310815136, 0.8923241628808383, 0.8620662813953224, 0.8796405033936379, 0.8866815737345776, 0.8804224264639319, 0.8998906343996147, 0.7771508799734355, 0.7587960556007356, 0.758453101908894, 0.7647305465847568, 0.7695187014343332, 0.776765675499747, 0.6982893430053403, 0.004641265896529134, 0.7839141035278168, 0.10186726483323816, 0.18069648442573238, 0.12145332443433321, 0.1388836196409282, 0.1660018131283486, 0.1289895215448047, 0.13313825787241473, 0.13197145122916865, 0.12578961320936866, 0.13284845197359685, 0.12933794204730764, 0.10840395155806004, 0.10531650523944991, 0.11166752210688702, 0.6635109008755661, 0.1228765699436195, 0.13814020102625435, 0.10791749674104445, 0.9830318400279322, 0.9854278805220199, 0.9859313003812386, 0.9856403890001414, 0.9934921661736518, 0.9861146063013463, 0.9857310856127904, 0.9884783146066896, 0.9922188079250793, 0.7332298387632059, 0.7452917222807569, 0.7115550492561861, 0.7524451236125069, 0.746347684915192, 0.6776233987700169, 0.7507127735082896, 0.051372766337735465, 0.08750232517249168, 0.22274248377621708, 0.22549638009015627, 0.2061447812272893, 0.3681062485440232, 0.27249136794222906, 0.20565375467590963, 0.37728532171643336, 0.8367035449922855, 0.2347720601939408, 0.11827204145430192, 0.27045152720521004, 0.27414631055506933, 0.12931622189061132, 0.24142088366969183, 0.2257334091994455, 0.24372523521228773, 0.21402060773786402, 0.2437418772532749, 0.24944136030516517, 0.2670851856436164, 0.24395196209243908, 0.13075348971498713, 0.2561338035379769, 0.29837838465336575, 0.2678955744124033, 0.40035923036664856, 0.2686102377066574, 9.999999999998899e-05, 0.002783339385731942, 9.999999999998899e-05, 9.999999999998899e-05, 0.006088869774339756, 0.0030045313722996125, 0.03422126378459811, 9.999999999998899e-05, 0.13294697447561232, 0.08423431517187363, 0.04440198946316287, 0.07928646484878354, 0.009473122446474358, 0.031858612759208205, 0.024448768722427294, 0.03964107869189648, 0.018968149214593555, 0.025325268740127638, 0.03594900666205736, 0.03471314992873342, 0.07965968631736609, 0.07863656777169381, 0.1712899422668419, 0.0777107445094658, 0.09984823158963885, 0.1817118809835201, 0.07226486639069696, 0.05980695931445901, 0.039827916578377365, 9.999999999998899e-05, 0.08546681001419698, 0.05304418835109992, 0.553565280543719, 0.11810266658222468, 0.04866690417971453, 0.19560900176992224, 0.5465745252528975, 0.5484759859728598, 0.538951330212494, 0.6475167386413851, 0.6340500347237709, 0.554297977514955, 0.5665780659431269, 0.59312582899884, 0.5842365712959734, 0.08992656825528667, 0.1051084807705025, 0.10195648783258526, 0.14237190807410138, 0.11037237470548067, 0.10390863051005528, 0.06994150638839236, 0.08994355871552528, 0.15206287884749303, 0.285327143164973, 0.22564712438383983, 0.3606058930737195, 0.15971842992224228, 0.31043083463160825, 0.12343912965483939, 0.21428851195416254, 0.18927816041751178, 0.18980277652929667, 0.263085033357106, 0.3719771172043942, 0.3167644359102215, 0.45208652901301294, 0.2762030669088812, 0.31168296381488214, 0.610660940787497, 0.20753939236644903, 0.498348355300418, 0.24832583994422275, 0.2678303814133065, 0.20586523421134284, 0.17851247981472573, 0.20700434696329384, 0.2889403924906161, 0.3002442609685537, 0.20813886652413405, 0.40573630577632425, 0.20666344748006005, 0.2169630329146638, 0.23216647387338563, 0.25970154613885377, 0.18474337382075123, 0.19223598226856098, 0.24158012372231374, 0.2025117750469574, 0.2303959241238117, 0.1792665864815426, 0.22407012131623327, 0.19001580272008145, 0.21888573903765884, 0.19505081582577566, 0.22067429702181607, 0.20497762767125927, 0.20212788617150168, 0.2208118940495618, 0.15204082571936384, 0.25773977691292416, 0.1708712257335766, 0.1767679905826791, 0.16603628180162888, 0.18674357117486085, 0.18783169577998093, 0.8812572430347065, 0.16550801882640576, 0.11179442401393247, 0.20826881382014206, 0.7143624465124836, 0.20953704957791874, 0.12551186958590677, 0.223345807858502, 0.16765205210126333, 0.745220432555884, 0.1669548426531403, 0.19954738722345022, 0.2048192821574052, 0.23122208728173432, 0.18774139410085222, 0.20763478570998117, 0.17811801304096264, 0.18988300363048105, 0.19294789784058408, 0.1959832261263178, 0.09975179479099805, 0.10306136875220362, 0.12407537234853794, 0.08077339896903091, 0.08670182150191086, 0.09523520212020498, 0.0878637429704795, 0.104662474469713, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "859ae40e-2dc9-4049-9940-935107e07734", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "c420d12d-c4ed-4328-8c59-d8fa1ba37a43", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            progress = self.func_evals / self.budget\n            dynamic_f = self.f * (1 - progress) + 0.5 * progress  # Adaptive mutation scaling factor\n            mutant = np.clip(a + dynamic_f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):  \n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce adaptive mutation scaling factor in DE for enhanced exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.31905599538136603, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8978713420928649, 0.8806003547936327, 0.8840187719113365, 0.8949522731790754, 0.7295246335995134, 0.8828407230643311, 0.8969794523922521, 0.892285281230806, 0.8896035142058675, 0.7468658517449093, 0.746916878128253, 0.7294979456738866, 0.7296348540049928, 0.8014953006384484, 0.8035769982616003, 0.7969541543116491, 0.05231318253634909, 0.7719614181375616, 0.13766169360939917, 0.12659674058044057, 0.10043039302603796, 0.1353951885568968, 0.0721417651112255, 0.0719565882282297, 0.10046148020046153, 0.12343681953377927, 0.07567539410642221, 0.1536256204880727, 0.10679977941595209, 0.10922565725549016, 0.12287465808736708, 0.14075621492608026, 0.15045571190841311, 0.13977736126328655, 0.12207010989215161, 0.1123455391885615, 0.9823142106157292, 0.9854276346296819, 0.9859301303334451, 0.9867669086651053, 0.9934927546254978, 0.9861293955293946, 0.9857351551339957, 0.9884795341001942, 0.9922183477521497, 0.7759310968287347, 0.7485188203525842, 0.7657473924192053, 0.693960462318352, 0.7329296820299933, 0.684190833198095, 0.7684450909299871, 0.5266517969936437, 0.7673037003749592, 0.22171596236533742, 0.3742990072198641, 0.3775836283629731, 0.37186030844353846, 0.8605203171526965, 0.27748104898644743, 0.13300563525502762, 0.3881829453038971, 0.23316618884499019, 0.22968194694576982, 0.262281455888288, 0.2516628905090861, 0.1329952733768045, 0.2359014061381114, 0.22786461321677942, 0.23512838251189816, 0.17870799466138398, 0.23196697388033805, 0.1292733185370949, 0.23746137056527072, 0.23064277204160255, 0.2807269259090448, 0.24242624601448393, 0.2765571193674662, 0.10011615618891068, 0.25280320389438526, 0.24258014399497352, 0.003113314696721492, 9.999999999998899e-05, 9.999999999998899e-05, 0.05213103572857858, 9.999999999998899e-05, 0.05985864268029473, 0.0003946524363713788, 9.999999999998899e-05, 9.999999999998899e-05, 0.07380985968264997, 0.10252502698677979, 0.10032529826279968, 0.03647455999959637, 0.06399819542263108, 0.03205395330487859, 0.059305342519014315, 0.02529627388211353, 0.20222623483168756, 0.06684598886057924, 0.03445742840647947, 0.10828499290924243, 0.07641916404070959, 0.16406617226435205, 0.07746522828809266, 0.10333635383398576, 0.25769332899360664, 0.10514891256384129, 0.044059352030253796, 0.036712347759402464, 0.04344672149454487, 0.1319075566137371, 0.05286887754607139, 0.17793331999751316, 0.08245992882360043, 0.054865756504117735, 0.08221929528197836, 0.5888386910250331, 0.5486447541655208, 0.5618643627588158, 0.5516877958178927, 0.5624069793618536, 0.5568684300813205, 0.5677102421873277, 0.5899004498294396, 0.5936216903721054, 0.12064171616747787, 0.11337599489387662, 0.09268503269403627, 0.13485150795311274, 0.13562629556623396, 0.12557615540503664, 0.12445298856432674, 0.1338717187747981, 0.15543186882317261, 0.1584223554783779, 0.14712217083579016, 0.22852483481196095, 0.22039379936004433, 0.13720332930005552, 0.2273108583860015, 0.17430792343416324, 0.27195596789599763, 0.15831966268863928, 0.2591599033929004, 0.5356044622576382, 0.30100112796474376, 0.28205962703396625, 0.31311507143136463, 0.3839742465830648, 0.5689638404471643, 0.5459236050267541, 0.6978281960822827, 0.3340938199936937, 0.24316669001356728, 0.3209082505351605, 0.238634820256728, 0.26466427753606236, 0.17577211411538252, 0.31040522588718167, 0.2967563866742021, 0.4949408505919841, 0.3493039129574894, 0.23387550886062913, 0.21833194439139403, 0.19779138246012118, 0.23705963913150885, 0.21014170608594063, 0.2155156155456872, 0.20008626926297102, 0.23405044277974918, 0.2427660387703302, 0.20471438483700533, 0.22055952743394625, 0.6877116693089964, 0.24495063821981644, 0.2195643088026632, 0.1958191979903976, 0.201267244355674, 0.1925607714984311, 0.15171135406305858, 0.16412350420454658, 0.17745527258324034, 0.1765507635963126, 0.16585838470171854, 0.9043746266180654, 0.18772444642600195, 0.8776698264848982, 0.16351512636606513, 0.11252632124906448, 0.20452886928029035, 0.5954401118099151, 0.20849442465657786, 0.12550253434751357, 0.7477115709311535, 0.16766333893178675, 0.669107702135088, 0.1666909166311754, 0.2114231337758471, 0.18584295118371674, 0.18948615998623286, 0.17572337660978843, 0.19184602742048285, 0.22831599684448767, 0.20359800842228926, 0.1931534519969298, 0.1861842457771521, 0.08044070808921255, 0.10229167349029888, 0.13565925369212584, 0.09880528804276001, 0.09264161399395365, 0.0808599398592883, 0.0897250980671086, 0.15465658468920906, 0.08558315592966848]}, "mutation_prompt": null}
{"id": "52628901-d5e2-48c0-b57c-37e552f64562", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            random_scale = np.random.rand()  # Random scaling factor\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.velocities[i] *= random_scale\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n\n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce randomized scaling for velocities to enhance exploration, maintaining adaptive behavior from the original strategy.", "configspace": "", "generation": 61, "fitness": 0.32907982436877736, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.9185575697379137, 0.9248422457670619, 0.9118675889385961, 0.9299893021401706, 0.912901837329247, 0.9183211013281678, 0.912585180946557, 0.9182163412167784, 0.9156071549773772, 0.8143166665427173, 0.8369099692360863, 0.8349755517895476, 0.7688298295932547, 0.843272124451615, 0.8423894692323279, 0.814773305466697, 0.7736258086656489, 0.8056428435890318, 0.14252369762192196, 0.18346914105787993, 0.14323670842855263, 0.13030001556406823, 0.13279596761635748, 0.15944271672643806, 0.17958598868179798, 0.10952757716421568, 0.17643272248093866, 0.10975831238618194, 0.08823886812754078, 0.07945955192434595, 0.10353794987327969, 0.14039709441622017, 0.10800208149275381, 0.12294618274054969, 0.0909550834930456, 0.0778080390750211, 0.9614892630145642, 0.9547094543338662, 0.9763264469201902, 0.9614026809518291, 0.982295829862457, 0.9864618660548784, 0.9691675384450547, 0.9804573182022602, 0.9592279111716244, 0.49092029333507325, 0.3818734444672217, 0.6784166034825496, 0.7763919023387178, 0.6176277151648262, 0.6035699395862719, 0.7004741189753493, 0.7315698779945738, 0.76995363314649, 0.9303953093316262, 0.8970364666529801, 0.16998415863851957, 0.27757968826152835, 0.16054891090175238, 0.2105699378935285, 0.14628456168780324, 0.21991880646166595, 0.35615473905505013, 0.12894579512448867, 0.2731710863502238, 0.20582732347171773, 0.1620707082308832, 0.19306828648081686, 0.17645746767234782, 0.13546938873164183, 0.18851460902219974, 0.20049371339519462, 0.1868329115752132, 0.1448331942290655, 0.13152301673256628, 0.21447592217579847, 0.18053782757156278, 0.13172891918078444, 0.2496957490114713, 0.2764978421725608, 0.22722796074614793, 0.006156077574602348, 0.042037391319644346, 0.019704293090016423, 0.009617446566765997, 0.036588507399128334, 0.050630384180237575, 0.1206500775693281, 0.004069519989762016, 0.016391524924304957, 0.09695982783937529, 0.13915362271759857, 0.10751460579261096, 0.0358250376485898, 0.020125656688985916, 0.023315858406506962, 0.06628134261119611, 0.09436907142417972, 0.10570999067525155, 0.14757710557314585, 0.05869446576463311, 0.19395584095193552, 0.09330408828198833, 0.1500255322293793, 0.08403204587198798, 0.1392387998452923, 0.2295503048360702, 0.16989781465966258, 0.1616112647951886, 0.2855448253966749, 0.32649445618714656, 0.15269880031292726, 0.0688862815084127, 0.0636077359334255, 0.12688039149297525, 0.0875760999607248, 0.21267691890520357, 0.48264172036466957, 0.5073618947319442, 0.5651225144642269, 0.5425412186337053, 0.4953604316653446, 0.6229640246276007, 0.6197623063772765, 0.5217043974842908, 0.5957622843014088, 0.1040960778033474, 0.12598614086457816, 0.18065105379490798, 0.14872670123964982, 0.13074183952024665, 0.06988459855561757, 0.10476095201454716, 0.104306728669465, 0.09208210557840868, 0.15009155035762745, 0.22263978121421024, 0.2225539062924794, 0.2550799731855127, 0.17711228799781242, 0.18429343377234175, 0.21709238450791657, 0.1561531429917753, 0.35174147593240945, 0.38145134745531795, 0.461993037004939, 0.4508813536977354, 0.39897446127052816, 0.2896197688483668, 0.26131186844595633, 0.6441778897874264, 0.4477214694520062, 0.5123403762550985, 0.1361263363301738, 0.2302671806161697, 0.19133710865030984, 0.27747760898598695, 0.2210733831556353, 0.36446826751344485, 0.08542265830501605, 0.2600803874992186, 0.31129849322636094, 0.24289835275615035, 0.23391844187228017, 0.20756818318362358, 0.24153366660978948, 0.3062385672248984, 0.22057654457237275, 0.27769948084137863, 0.19511754371634504, 0.24382225340668895, 0.21032336079034653, 0.18602470562310147, 0.19991215207381752, 0.19552320869793405, 0.1769225137890016, 0.194462320912695, 0.21129154931490657, 0.21013131929606077, 0.2116498431862418, 0.8170274793970657, 0.1876335216877446, 0.17659592306853733, 0.9095430333450721, 0.14147002723292257, 0.8623293744109491, 0.8559789866901892, 0.16187619577927326, 0.16711468558369091, 0.5616927153699375, 0.49572287381275937, 0.7022364277726117, 0.2099418669401535, 0.21250546813100468, 0.5340454362085045, 0.16843466682849972, 0.35835141084266475, 0.16695197945862295, 0.21876392195247585, 0.19558769504093865, 0.1817327978811344, 0.19039051497802784, 0.19402252282200838, 0.20042572837139927, 0.18163940658753652, 0.18788926419377927, 0.19907345608803761, 0.09459159685806795, 0.11540803950014156, 0.09988412170707439, 0.10373423353958477, 0.09692790027867637, 0.0847418058550955, 0.09018992353484445, 0.14185363525781214, 0.09050675838671163]}, "mutation_prompt": null}
{"id": "7b3c80a8-15bb-4c0a-b44f-0bc3ccece507", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f_initial = 0.8\n        self.f = self.f_initial\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n            self.f = self.f_initial * (1 - progress) + 0.6 * progress  # Adaptive mutation factor\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate limited adaptive mutation scaling factor adjustment in DE to enhance diversity and convergence.", "configspace": "", "generation": 62, "fitness": 0.3272302283566723, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8915127079563058, 0.8862014949332553, 0.8821871698353256, 0.9017603647776017, 0.8563219310218342, 0.8868061665385503, 0.8893406383456768, 0.8942410615059373, 0.8847168163926507, 0.7536096506564484, 0.7701046131281788, 0.706015994674185, 0.7531789895614591, 0.7849497586138745, 0.7814939230286214, 0.755225654539732, 0.05218883060019763, 0.7429422307760498, 0.6488549284294642, 0.11887129515992634, 0.141180154567206, 0.1135274657559574, 0.07114124160335245, 0.11160011694579464, 0.17505296827825112, 0.1780981647006734, 0.15130832001771977, 0.09155070263156562, 0.10583620960604745, 0.0998840026665393, 0.15596900407176384, 0.1358579701440118, 0.12878504031289917, 0.11761120052861662, 0.13973428722307812, 0.1253261903236227, 0.9823416804683921, 0.985427790414966, 0.9859307439177541, 0.9856402350458622, 0.9934928785529811, 0.986129749206217, 0.9857350560999298, 0.9884795739028893, 0.992218922326036, 0.734571404511545, 0.7040137622476419, 0.7340576126488698, 0.7125387778781678, 0.751638315751876, 0.758748093299364, 0.7484414976735054, 0.6193452343659248, 0.7636001415802254, 0.1559819060316331, 0.2262629074285344, 0.15446770381927033, 0.35058290742878806, 0.8780400955428341, 0.3558123354055317, 0.12217917011034063, 0.8834988543950772, 0.763766151685373, 0.12701772176146875, 0.13113459248625037, 0.25168469476925415, 0.13345442940937047, 0.25793070957269293, 0.24567280624112153, 0.22337495362345627, 0.1850071782150372, 0.23950893304047882, 0.22891218350340092, 0.23600106221548856, 0.24343015224653552, 0.3978943712936115, 0.2631539156091346, 0.2478419572726671, 0.09767596869337392, 0.20562899400381984, 0.23450966455356415, 9.999999999998899e-05, 9.999999999998899e-05, 0.005190051344390434, 0.04307063910597175, 9.999999999998899e-05, 0.057066438641705464, 0.00041315886421322556, 9.999999999998899e-05, 9.999999999998899e-05, 0.09055740521428401, 0.11931702788462895, 0.10280901077008586, 0.03859514890223559, 0.05626983666230012, 0.01684517383745987, 0.11104930072802999, 0.018884878925253368, 0.088395997525331, 0.06698829223187053, 0.034833285576374884, 0.10708596756657696, 0.07571646568600632, 0.15740007663424804, 0.07923587549027156, 0.10470106966701187, 0.21789075737928565, 0.07284731454379034, 0.049162800959610786, 0.04391997502416001, 0.04243092426273942, 0.07138189366705405, 0.05042656407677093, 0.32553380601538284, 0.08238820398663771, 0.05366338417642125, 0.08215354327881286, 0.5480604094663724, 0.555558854683487, 0.5462266057909477, 0.5687373727354814, 0.5793785296941605, 0.5387478926495344, 0.6091760026325537, 0.5870489462117798, 0.6003942463192506, 0.11192784297771852, 0.10298305102885896, 0.09023427896438407, 0.09642559475777757, 0.12114501030270985, 0.10072771176671214, 0.08808793707772289, 0.1072248724572874, 0.1559153062926547, 0.1845259628826853, 0.18867982794380922, 0.1705797950853939, 0.23065622102317374, 0.26085156417907396, 0.24861948138394363, 0.15560390051467, 0.30833460711156313, 0.1544012671508983, 0.2582825057962773, 0.37692012945252196, 0.4109223850222439, 0.4018120630814521, 0.5231214965938491, 0.279196998707711, 0.40879876132930315, 0.2840342753282593, 0.6935802801266981, 0.2748936326571111, 0.3099854350741694, 0.3438819565635223, 0.1944837055425388, 0.33381787597326096, 0.31834290646261654, 0.35029065429249495, 0.29864604948715523, 0.21224907666507786, 0.22855660836607838, 0.21498885009376367, 0.24939038177637618, 0.22517009912812558, 0.22303122500904804, 0.19678454154281566, 0.2013022197484582, 0.21219455352137417, 0.22829092723556677, 0.22005664156301308, 0.21158806856460066, 0.7402380450471506, 0.7735690391496557, 0.22045937268941085, 0.19742285499377843, 0.1884273995761947, 0.24507288219924173, 0.20671262260071988, 0.15171837820424539, 0.16412940721129887, 0.17718050471117552, 0.1765695031412835, 0.16585610231329262, 0.9008932602891688, 0.18762150559225943, 0.8843187775442773, 0.16346921077554266, 0.11252357003269897, 0.20799402928294697, 0.1673741044528928, 0.2083043819450191, 0.7075410728685447, 0.7021169989007872, 0.1676517231487209, 0.8063505376062884, 0.1683279471126411, 0.18475934283743267, 0.2007393372814672, 0.20278101717720376, 0.20349795132062443, 0.1890950687102959, 0.19096271302189194, 0.19136610434319923, 0.18833932557584288, 0.1840758001640329, 0.09394872654483077, 0.09421099402788913, 0.1345423973356712, 0.08660951039998344, 0.10720470782105218, 0.08349104020033116, 0.09227908508892979, 0.07174753376479015, 0.09287872151487642]}, "mutation_prompt": null}
{"id": "a3782486-07b3-4ee0-88b6-be29aee689ea", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        successful_mutations = 0\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n            self.f = 0.8 + 0.2 * (successful_mutations / (self.func_evals + 1))  # Adaptive mutation factor\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    successful_mutations += 1\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate a success-based adaptive mutation factor for enhanced adaptability and convergence efficiency.", "configspace": "", "generation": 63, "fitness": 0.3260666238663748, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8938380532855232, 0.8784476120786084, 0.8906244388106739, 0.8896366700609445, 0.8812701295113241, 0.8915274849467296, 0.8926748426436684, 0.8821538813071942, 0.8759432454099124, 0.746256371066855, 9.999999999998899e-05, 0.7560666386835707, 0.7151040711075471, 0.7035058707825685, 0.7894747772751165, 0.7517699556335935, 0.7791907005754574, 0.7549642780936323, 0.09815239908085949, 0.13913754951542345, 0.1367917011271722, 0.07417445513119825, 0.15086379594544264, 0.1818727045788464, 0.132524161583646, 0.13700941657858334, 0.06690835473295975, 0.09686513630900084, 0.1371251643207161, 0.11872627158335558, 0.13589863580335038, 0.11686593301370996, 0.1543173890382259, 0.12970938349506778, 0.13819708880410075, 0.6451644801060412, 0.9817369597679176, 0.985436897160633, 0.9859706647913332, 0.9856402350458622, 0.9934827067479461, 0.9861777692216372, 0.985726918915188, 0.988539026884355, 0.992218922326036, 0.7816059819862723, 0.7654873346153082, 0.6989263758736853, 0.7604927073722407, 0.6976892352297452, 0.6272730385743608, 0.7682788503851239, 0.7410759304866111, 0.7240052069816444, 0.8234434732381556, 0.22759102574248813, 0.3573777801908433, 0.21786233538026567, 0.2111555360660462, 0.8911290639066041, 0.23140277319527291, 0.7499586694207576, 0.7014245726753159, 0.3619149707023568, 0.13412409188103125, 0.13335860557067702, 0.25931045445308076, 0.24419151501419778, 0.13131054876359483, 0.12895635611796186, 0.23342948180784828, 0.21157758911920066, 0.23975761164917764, 0.3100508596458983, 0.2469276367966433, 0.1313003850968949, 0.27681612490843177, 0.28303966306149764, 0.14283334741056164, 0.1938786904198696, 0.25152385267152433, 0.008459566155526566, 0.0031978256519421544, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05818866419171498, 0.0015521450361205558, 0.001266828114417362, 0.02937179074804952, 0.08100051541448627, 0.07284523814417332, 0.05449394833708032, 0.017009761244192845, 0.018525727727404906, 0.02581328716898934, 0.07498015969760619, 0.05328230557799962, 0.04019034064438132, 0.08661251374198442, 0.035569954588386965, 0.10069279883350524, 0.07814478776098555, 0.13292694939355154, 0.07755462441510697, 0.09980452718655508, 0.28320104385730616, 0.108086885524742, 0.11450100894018433, 0.1065578062795357, 0.043074202171491716, 0.12521192055945685, 0.09859170568525555, 0.14020984416044235, 0.21891818045519973, 0.048108060715561285, 0.08318842941616089, 0.535468813516165, 0.5458556898024027, 0.5432683554143037, 0.576686413989187, 0.544435554855236, 0.5991361025634736, 0.6214015354728184, 0.5669422262134174, 0.5959733911852352, 0.08199172402836141, 0.11037555583677217, 0.08991163067911023, 0.09777518556919984, 0.10706729681797222, 0.15721114241188971, 0.1395671347144578, 0.12566633756225598, 0.13143459999680707, 0.21874961728440023, 0.20553612637335383, 0.1646117282631494, 0.21373324188845677, 0.1141633942098248, 0.19219239490897166, 0.16588183337944773, 0.1466418707303404, 0.2643864459944689, 0.25724793294447923, 0.39846431096226975, 0.553268617609207, 0.2013878910859861, 0.3207507163093428, 0.5131388279874707, 0.7073755118676669, 0.5101087274641751, 0.7498711036660367, 0.2446804235810055, 0.179503363752475, 0.26481602742394084, 0.1769582225799059, 0.25549184707731853, 0.25409153776625804, 0.18717038814885167, 0.2839352671362717, 0.3169098216114138, 0.22865920177419652, 0.25850506794242023, 0.24827166032071402, 0.2391256578757004, 0.2098306348121345, 0.22440257608590175, 0.2593542197237314, 0.19487587248906735, 0.20313170351098098, 0.19613086428031334, 0.2077093837916254, 0.219589189955132, 0.22426936807788866, 0.2008285915355391, 0.1857971532866427, 0.17491456444969478, 0.22343345141189253, 0.19802495602176218, 0.14548472588690198, 0.8443033511074297, 0.21065248599612862, 0.1766314221439219, 0.18631890495868553, 0.19900663776068217, 0.8545115208275132, 0.16480825599522653, 0.16785427083028648, 0.11186787093059103, 0.6890233578228304, 0.6294908656517393, 0.1645711943868311, 0.20649082684869946, 0.7436654474619819, 0.16843058588538573, 0.719251502775907, 0.1677737161079481, 0.2066902194991227, 0.1811577029179301, 0.1870157323925561, 0.2217818816045427, 0.17867297626304568, 0.1867723681390997, 0.22567125990783143, 0.2177629931087598, 0.18163331185859077, 0.0943247635234673, 0.09610394985064963, 0.12516487706447077, 0.09584181680080184, 0.11837780705933654, 0.10101092723285288, 0.08581955989152235, 0.09686830853348716, 0.0917951892970974]}, "mutation_prompt": null}
{"id": "8b9c6d07-9743-41d7-b4d4-c142ecae2d48", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        radius = 0.1 * (1 - progress) + 0.01 * progress  # Adaptive local search radius\n                        for _ in range(2):  # Minor modification with an adaptive radius\n                            variation = np.random.uniform(-radius, radius, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce adaptive local search radius based on progress to enhance fine-tuning during late optimization stages.", "configspace": "", "generation": 64, "fitness": 0.33205352797927473, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8867506413566514, 0.8754155148018473, 0.8867044955870327, 0.8961311156999464, 0.8657591404576505, 0.8961080979741927, 0.8927689906062025, 0.8749936705823582, 0.8658939465129463, 0.7599239962089585, 0.6949315469858066, 0.7551942740049443, 0.7139848880702409, 0.7467653500771447, 0.7920433651532842, 0.7671051006164531, 0.720470575206166, 0.7689677796975051, 0.1523148993441339, 0.13566815529356557, 0.17719686047903083, 0.14850397650659797, 0.06749804140250748, 0.06903657929093165, 0.18130163632012997, 0.13197145122916865, 0.17888419414305867, 0.11141932127908127, 0.13463144758840118, 0.1069067314051132, 0.10472664898043116, 0.16252520990739738, 0.6635109008755661, 0.14035984464794804, 0.12291293938282832, 0.15148357613815533, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.986131414155067, 0.9857345694842464, 0.9884791344612078, 0.992218922326036, 0.7584482986193819, 0.7693448064888315, 0.6683378600642462, 0.746840086181524, 0.5601053985394482, 0.73908891366187, 0.7308769719620627, 0.6537931262213161, 0.7567179813974988, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8930847412651977, 0.8813986727896248, 0.27660219001871666, 0.1483570356005086, 0.40233729229822834, 0.2331856321587661, 0.2743827203427135, 0.25690714736333, 0.24917324789925765, 0.13402409925154501, 0.2519334118104305, 0.23702764982715008, 0.1325615408917311, 0.2428047561343617, 0.2437418772532749, 0.1299663007646008, 0.22795197765095077, 0.24624005430463036, 0.34816979059652997, 0.28105808551610567, 0.26743277954182065, 0.10246241091215702, 0.23350379049722192, 0.24102682451140134, 0.017472549265993065, 0.002783339385731942, 0.006928058334827458, 0.03634640281670165, 9.999999999998899e-05, 0.05838434835876383, 0.0008221535626975474, 9.999999999998899e-05, 0.005181472463803183, 0.08423431517187363, 0.05844268434715394, 0.09473856189059238, 0.01318081861656395, 0.030085025837827795, 0.034181311044249596, 0.057580241039387525, 0.024074975666908527, 0.06400055375300395, 0.06628987326888058, 0.035626180804052665, 0.11509229045039593, 0.07643908694264556, 0.15606513785244913, 0.07690411856740997, 0.10438333079473927, 0.248041811712581, 0.09817507157517424, 0.043432286381832275, 0.03784384577708555, 0.051790600993307234, 0.07417222856038874, 0.05304418835109992, 0.11264844606044933, 0.0822400181196592, 0.06281424821627146, 0.08226114790957995, 0.5786253650785405, 0.6347411522793651, 0.5465037670313606, 0.5919253515096359, 0.5806369138171603, 0.5711211130046341, 0.6097662027807593, 0.59312625647154, 0.5842368507787155, 0.10394945286843449, 0.1051084807705025, 0.08282174894614691, 0.1406814852446845, 0.12099738045639952, 0.12353172689785064, 0.06994150638839236, 0.1547500097912038, 0.13770086526723757, 0.28533002297655397, 0.23700435310101642, 0.17134858483682058, 0.22008813522578852, 0.3055848397000003, 0.15983412325070911, 0.16639047535889184, 0.18928643335660922, 0.16234232686530048, 0.2587481846215526, 0.37198285438306333, 0.43366732229039695, 0.3498048979267976, 0.37502754397644467, 0.3699522051787131, 0.5455421934552137, 0.15587339279624324, 0.4445230199850203, 0.35639152317659095, 0.23079288871873183, 0.2401575101112159, 0.16031610223387305, 0.3080739328314307, 0.27803418370517907, 0.2590064961624199, 0.3024626165831862, 0.36895864352083096, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.22164221882039215, 0.26687765594675095, 0.2003627156236324, 0.2432406397957474, 0.20281553101710392, 0.19664029678431771, 0.2421608368968261, 0.2065729695942412, 0.7154816025180495, 0.2037588783852463, 0.22355102372778501, 0.19262593329530986, 0.1530460717920581, 0.16360169425481985, 0.1743753303728971, 0.17676898246267503, 0.2055480316180165, 0.8987794568337577, 0.7918182756126871, 0.8794350163267188, 0.8249577792169793, 0.6391894382736587, 0.20802579871658178, 0.16750346637405422, 0.20877441403222297, 0.7259474360469551, 0.704989636813788, 0.167652654772787, 0.7203532048937495, 0.16841754251506302, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "c77f4378-32f4-44ec-ba41-926414fb8aa9", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n            # Fitness-based parameter adjustment\n            if self.func_evals < self.budget and self.global_best_score < np.mean(self.personal_best_scores):\n                self.f *= 1.02  # Slightly emphasize exploration\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce fitness-based adaptive parameter tuning for improved balance between exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.31232895093737006, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.884556935112375, 0.8760121479737203, 0.8815441588374339, 0.8991725573152077, 0.8568588322388555, 0.9075824124433012, 0.8997376478034413, 0.8936210957305628, 0.895332637882685, 0.6090043919775667, 0.07644232434031184, 0.7797518659225116, 9.999999999998899e-05, 0.7533127242058466, 0.7774891072565383, 0.7525147492161328, 0.053013289850963874, 0.7678547717247034, 0.6370242330925808, 0.11423667262520354, 0.13835015524043992, 0.15504584739051985, 0.13910724982444722, 0.177885486430018, 0.15150245722724975, 0.14086811034887814, 0.15356254631896427, 0.12310488271782738, 0.08987683343835107, 0.11004705945348414, 0.1316884340038188, 0.13710371661831666, 0.10612558422297458, 0.1372994824908763, 0.14111028520523672, 0.10460681752459755, 0.9817216544587497, 0.985433318647441, 0.9859470382982191, 0.9856402350458622, 0.9934908813580818, 0.9861657650967918, 0.9857334396030354, 0.9884716855912177, 0.992218922326036, 0.6782308015900986, 0.7188901602578588, 0.7139444062438138, 0.6242366624277341, 0.6810409517979912, 0.569962581372005, 0.7506591809664129, 0.6365153896049854, 0.7050503765068157, 0.2803019485903503, 0.8023361206311013, 0.22438964247480675, 0.8212511795550157, 0.3694327442645666, 0.2723653925880196, 0.22252599335541667, 0.26764585261323515, 0.23382600166024703, 0.19791977958638984, 0.2413761583853694, 0.216433325071419, 0.12970569315770075, 0.21272784898988428, 0.17424712895742722, 0.13203799300316588, 0.1265499039528447, 0.21084394970869202, 0.13034678730218963, 0.21291348844536784, 0.21789303949358407, 0.26720242639534386, 0.23749867940682579, 0.21949055790483984, 0.14581621484931895, 0.12594392612644079, 0.21823829169874387, 0.0724459690086956, 9.999999999998899e-05, 0.004003798711050721, 0.0817759525821371, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006078344236323585, 0.049347079091469404, 0.0559559972389434, 0.07056562062888805, 0.028982631136425185, 0.06616971757002288, 0.05453063556522808, 0.07962224885931868, 0.023892475388898826, 0.08903404616297939, 0.04468748529475708, 0.035214212586574645, 0.09091357810975009, 0.07622842534493046, 0.18266966631339987, 0.1142595446355048, 0.10944293777748915, 0.20581337199622718, 0.08334617339856099, 0.10159381375945153, 0.06822796029483524, 0.04214768482751785, 0.08039662786143076, 0.07888853357041148, 0.06609714877344774, 0.08325015784234657, 0.047734437490916215, 0.081911273998168, 0.5424744917655161, 0.5712774636260738, 0.5449625965257665, 0.5669092766893544, 0.5305015791089814, 0.575118403835418, 0.5840358609002054, 0.5778832078904695, 0.558992349064604, 0.08406864666116598, 0.1028774169605986, 0.0982754089390564, 0.14514155950705665, 0.11252189886398645, 0.12731163690884473, 0.13774120939459367, 0.13377798902847648, 0.11766211822075168, 0.20690143240064018, 0.28892793755127955, 0.14251118347487468, 0.20602210043602454, 0.21220317037077496, 0.19328865032238118, 0.19849922230406125, 0.14275867349832205, 0.3317627240755664, 0.2859483284519274, 0.3174018601553835, 0.4623990477727987, 0.4561616812729501, 0.4170578648821177, 0.31824743180539794, 0.4983799223008557, 0.457901123505122, 0.524168560791199, 0.22780780501350228, 0.3243707081772029, 0.17055391468748804, 0.22078653294759043, 0.18819157598641423, 0.2972341773323871, 0.2911661590764797, 0.2075413076137781, 0.3946291990427777, 0.21552970877011712, 0.20636274664691312, 0.2537351956704468, 0.22653808881622894, 0.21639618825703444, 0.2387348970465698, 0.18800408623321696, 0.2281169630779516, 0.2069450412127518, 0.21630633405041444, 0.2036098746152275, 0.2182634247689743, 0.20343697944606787, 0.17368956442852213, 0.21352149896007055, 0.7635364276160297, 0.22235335438335146, 0.18803245760008247, 0.14242068142978492, 0.16970834337725427, 0.1728598781105164, 0.17698611323122948, 0.17548682747624733, 0.920621846114138, 0.1849726169505218, 0.20488897085282298, 0.8686478609243168, 0.16509221097603533, 0.4304952761581844, 0.5191902300452339, 0.6633255568798513, 0.8144467447827808, 0.6926556298054227, 0.1677326714112536, 0.12732535778647902, 0.16746565371185096, 0.18936615788027866, 0.17685647125168036, 0.18864821063939063, 0.20434022993074774, 0.18538790286727536, 0.19508570320183716, 0.1874099395745621, 0.19313734285303963, 0.18031989019477102, 0.08912612236315987, 0.08376124525824202, 0.1192387226262277, 0.09345632989365915, 0.10444549125307945, 0.12555857410494042, 0.09084400856223418, 0.1168593338923305, 0.09463244193685527]}, "mutation_prompt": null}
{"id": "7b452f07-c53f-4e0d-9540-487f2f4b9cec", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                    # Local search phase\n                    for _ in range(3):  # Improved local search\n                        if self.func_evals >= self.budget:\n                            break\n                        variation = np.random.uniform(-0.05, 0.05, self.dim)  # Adaptive variation scale\n                        candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate)\n                        self.func_evals += 1\n                        if candidate_score < self.global_best_score:\n                            self.global_best = candidate\n                            self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate local search adaptively when updating personal bests to boost local exploitation.", "configspace": "", "generation": 66, "fitness": 0.3091200302739174, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8732138652543092, 0.8597978443704879, 0.868367646885662, 0.8728790792108821, 0.8626520479326671, 0.8563450517814389, 0.8518591667877843, 0.8682036789851075, 0.8542445005214218, 0.7246914224020651, 0.7293978649941573, 0.7018649701319448, 0.5864460513767749, 0.06414589237903001, 0.6841046499689666, 0.7575082364438604, 0.6611320345550473, 0.7287944701289637, 0.11951798113795287, 0.09746373093992222, 0.17667745301032634, 0.15436337039247738, 0.17196168631743258, 0.11537941962137843, 0.1269055769582661, 0.1282154689547942, 0.13743917387832627, 0.13475272916235448, 0.13241180313824186, 0.1240203471141742, 0.024491361880132123, 0.09082589764658366, 0.10914475105593102, 0.14442613334821142, 0.14196790789646352, 0.10307596122528706, 0.9771724942835587, 0.9865003418072544, 0.9787802935945791, 0.9685904763441684, 0.9858861582783592, 0.9709784537316776, 0.9792634872095972, 0.9717935052068707, 0.9745597698273689, 0.7094783107559346, 0.6958542953514955, 0.7310103279324507, 0.7240190925404135, 0.6858798580049947, 0.6913485371978962, 0.6273531387912348, 0.6611021099235881, 0.6280478524144953, 0.21900478057729078, 0.19882259532074664, 0.8673552895506021, 0.19230862648171465, 0.21592947804671347, 0.18929888204087297, 0.24141246496510227, 0.146503213256729, 0.8516084629832402, 0.10604207861814308, 0.22920559849089872, 0.2187894223734207, 0.1308493414194125, 0.12899682222208142, 0.129442264433544, 0.2218724572789812, 0.21660742069302086, 0.22682046824285418, 0.2239047137843002, 0.11859536201168885, 0.13074009330249314, 0.24940581960674024, 0.3814998563616032, 0.2534366537383834, 0.13380636268172819, 0.24562917337991608, 0.3019113767213245, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023866830663011873, 0.0034315444132545503, 0.058415100565298084, 0.030591876249596694, 0.011711904836104292, 9.999999999998899e-05, 9.999999999998899e-05, 0.04259348562966703, 0.048159254320898404, 0.08703945063333918, 0.006306067770785018, 0.057156216071231, 0.14042157792132637, 0.08597094387943338, 0.09370369904004294, 0.12517240563318033, 0.19058583346185898, 0.033050821179129386, 0.047496393245294755, 0.09472343127615201, 0.07552633005126408, 0.09595327625318661, 0.09751469750222641, 0.107789160485116, 0.07569076348870918, 0.12832546237758247, 0.12590164630876932, 0.15139391550089387, 0.08076232801060101, 0.1602276059155021, 0.09868602344731248, 0.07296032755259751, 0.05757414126300242, 0.0833585965147704, 0.509970751395351, 0.5403249083594124, 0.5541635946394968, 0.5515782761998426, 0.5570979820772091, 0.5647442542345811, 0.5471682770315867, 0.5584890202957743, 0.5613643624113301, 0.06295533087277816, 0.08391943044223737, 0.09378254324795521, 0.10635073825180497, 0.13799766441097527, 0.7319586900015496, 0.11817805264500181, 0.1536723110811825, 0.10982252397324577, 0.26865261716397515, 0.19269607570752278, 0.21317175540696276, 0.26268037853519133, 0.2027162679990253, 0.17131407847959146, 0.391434478319614, 0.17207757479819996, 0.16873398674911677, 0.6397795596649494, 0.2386735626590356, 0.24978664809728945, 0.22842811455205736, 0.3039438283915873, 0.38801570346071124, 0.5201798135204376, 0.3794115501210392, 0.3751373818898902, 0.23553457258939925, 0.17778004050397467, 0.1954230654594009, 0.2006797615671715, 0.25462280018366246, 0.37192098577958177, 0.25617084510228616, 0.16619656764348711, 0.31532120775956785, 0.2236599618453633, 0.22392901970727286, 0.2302109222873301, 0.18591322757504158, 0.1969053144563312, 0.2021624347664499, 0.25747586041793535, 0.202751158803692, 0.20719413263661157, 0.7546158914960571, 0.19873197496240314, 0.7522986270670384, 0.19097808219206047, 0.19913044850501982, 0.6847201588552603, 0.1969415594120515, 0.1898111851752542, 0.20153029905844222, 0.17518288904263757, 0.1341211348110104, 0.15083737051095103, 0.8674783612560035, 0.18528553934609038, 0.16273822260881954, 0.16691174355832905, 0.11771999828033619, 0.8402459924371339, 0.16610045625228553, 0.15109858695523437, 0.11016142654158467, 0.16664000113120347, 0.16390851850460642, 0.6237694594681323, 0.20922900511995846, 0.20220456139436394, 0.21075398201832518, 0.21004444654145604, 0.18580248046455583, 0.18692093370605578, 0.19216381172232855, 0.20599493691191084, 0.20104075491531515, 0.20087873703415537, 0.20397276712419654, 0.18874377167449885, 0.09244481779781055, 0.093150915641945, 0.09503228114114226, 0.1349806364686419, 0.09275709560487777, 0.09357680518114464, 0.09509273443291755, 0.09467895578081842, 0.08819244145697391]}, "mutation_prompt": null}
{"id": "74906f3f-2ddd-40ed-a9e6-97b34d9deb50", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "6bebc9f1-35e1-48c4-8abb-b3e0dbfc3437", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n            # Stochastic tunneling for perturbing global best exploration\n            if np.random.rand() < 0.1:\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(self.global_best + perturbation, self.lower_bound, self.upper_bound)\n                candidate_score = func(candidate)\n                self.func_evals += 1\n                if candidate_score < self.global_best_score:\n                    self.global_best = candidate\n                    self.global_best_score = candidate_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate stochastic tunneling to improve exploration in PSO_DE by perturbing global best solutions.", "configspace": "", "generation": 68, "fitness": 0.3224367940935189, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8811924475023957, 0.889824565874486, 0.8895039969271308, 0.8926581712709935, 0.8589885843898512, 0.9024271414377352, 0.8876131152807154, 0.8783304985242473, 0.8990758342977507, 0.7599728768004864, 0.7175328466662936, 0.7352633712214198, 0.7891341874826587, 0.7787164984279167, 0.7444537370996793, 0.7679259730724258, 0.7591770482372768, 0.7033360770000315, 0.12896291998340514, 0.1153953852509898, 0.1398838995259457, 0.14623700509940796, 0.18051465562349345, 0.1834838019131545, 0.1290411529428307, 0.13889594822238283, 0.17763066836457586, 0.12857878434419234, 0.08695891260887334, 0.08304485780233684, 0.14291168286647715, 0.14804606976271206, 0.12010544405834367, 0.10704842640853951, 0.10423432879998673, 0.1136393237778075, 0.9816240243697031, 0.985969769522846, 0.985931454102837, 0.9853997621535333, 0.9935191055069, 0.9891410151390388, 0.9849645791090935, 0.9869335057240195, 0.993102149924095, 0.7724859520377325, 0.7743696388140328, 0.7417602195042647, 0.763101533601799, 0.7351327228311952, 0.7680334566862858, 0.7487035101484967, 0.6694343227030197, 0.719964203379194, 0.7792615485093471, 0.8002020479487804, 0.3721678107627593, 0.37641771625360576, 0.759581448485642, 0.21188948236864302, 0.17544570447506325, 0.23080374609545007, 0.3944083870145393, 0.24202960973734544, 0.2731786898048515, 0.24660293315191606, 0.12067878554919975, 0.128764381049723, 0.23578481393061246, 0.13023371086392, 0.24160363135924845, 0.12376267699481958, 0.21518709943588887, 0.23894479810648617, 0.24368071426503757, 0.157296456252924, 0.2632868814806478, 0.23477037589208982, 0.13386591719640872, 0.25902159370217837, 0.27024948933763826, 0.0010197041256387873, 0.008830854931540122, 0.011594532296507531, 0.0067798222533225205, 9.999999999998899e-05, 0.053090504478567, 0.009485696356417828, 0.007554199161943664, 9.999999999998899e-05, 0.05504420150749556, 0.05602301704452062, 0.1747675038402493, 0.015659190842268633, 0.016668705007863882, 0.03661691214210727, 0.0494454050835349, 0.015114647310078944, 0.0816513081136403, 0.23560566544795047, 0.046452177264040606, 0.036039218109459425, 0.07594733561806466, 0.2133802904031994, 0.07865511139625503, 0.10032959593991797, 0.10009107802919848, 0.07181722443658034, 0.09955040187594133, 0.13674164314993564, 0.09137999358738413, 0.054647795349396566, 0.07037960646054309, 0.4512590656454184, 0.08209991584778331, 0.08034087937999634, 0.08275604616985877, 0.5718965399474709, 0.5179111251386074, 0.5576117044065058, 0.5686734926792645, 0.5679167030981866, 0.5825095245738818, 0.5693119452315973, 0.5772365536117746, 0.5853328618453004, 0.11281200416165138, 0.09059727999653333, 0.08412963849417587, 0.14222919242753274, 0.13488479352297567, 0.12737675488153366, 0.06700014380062169, 0.09401069092494052, 0.15292299893020267, 0.22340138650801578, 0.21730077090960653, 0.17274925534393082, 0.2224042391572858, 0.20482830961390208, 0.2671679178382973, 0.1919597609899233, 0.17671497245009848, 0.21994404721231975, 0.44258144097252794, 0.2586046905550472, 0.3242846754401827, 0.2292187067755207, 0.38405639922574164, 0.3092899778257312, 0.4996526985139368, 0.17062906306216696, 0.6039554306036874, 0.24157230117143913, 0.273844295213031, 0.20991221147762018, 0.278895607028238, 0.37720167556021766, 0.4108217434612187, 0.13635256903300486, 0.2791112796472448, 0.23899781466225745, 0.1842316085676029, 0.20590440858978598, 0.24617288712695395, 0.2138572219606596, 0.1889960900880293, 0.19731580926659342, 0.2225732887236086, 0.2166834785056081, 0.2054048444954325, 0.19456413047659749, 0.22094980370989292, 0.1987359228862915, 0.211214629165988, 0.18348215836890536, 0.18111430402638884, 0.24675610767721168, 0.2019889438263781, 0.1975088032863267, 0.17158680616618094, 0.18372528573856894, 0.17512661963569576, 0.1774457182660064, 0.16475052116645839, 0.9152500172005064, 0.9206459066404665, 0.14749366320336832, 0.16504027713338187, 0.11198172092320113, 0.8146602687366012, 0.7369109592806173, 0.20969529495147743, 0.7770673311653015, 0.20977672072231768, 0.16772948932570741, 0.2111442263776936, 0.1651937957057662, 0.19227180661618737, 0.19480578012801186, 0.18165057140574514, 0.17244773366090826, 0.18432444596661357, 0.18963571441403893, 0.23870821962196498, 0.19889798547665538, 0.19435841259213393, 0.08933344027440615, 0.11222618842078569, 0.08483599657106877, 0.09177517158453741, 0.0973662395968522, 0.10141659960832416, 0.07743248017848514, 0.09434973211867637, 0.08256389219375071]}, "mutation_prompt": null}
{"id": "03c1d28e-0935-4c6b-9a98-202234e4404d", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr_initial = 0.9  # Changed line\n        self.cr = self.cr_initial\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            self.cr = self.cr_initial * (1 - self.func_evals / self.budget) # Added line\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce dynamic crossover rate adjustment in DE based on func_evals progress to balance exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.3184310453878336, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8722889017879818, 0.8742692230473695, 0.8868936774240117, 0.8893882798321227, 0.8869234588053995, 0.8933786126136807, 0.8836805293867933, 0.8814373505953547, 0.8948476661660686, 0.7249420471893517, 0.6899044390998408, 0.7513843089664569, 0.7457804887367763, 0.7869099144641678, 0.7433410696239233, 0.7594068443503468, 0.05243822894172523, 0.7394287444058181, 0.1368401350096461, 0.13948122504894833, 0.1786262910164793, 0.15686184619508636, 0.1310647305003655, 0.07305982597432303, 0.17834050316562766, 0.12347463059557517, 0.16733177615742156, 0.11198115295364985, 0.13729099622741991, 0.09676138631098452, 0.13450471361827454, 0.11415833657520813, 0.13829072352717398, 0.12259412867447605, 0.11598447427140546, 0.13006611737625318, 0.9817205086326367, 0.9854247756744754, 0.9859544635803641, 0.9856549237025379, 0.9934927733958694, 0.9861314847609204, 0.9860537741650754, 0.9871126259732087, 0.992218922326036, 0.7711038384067487, 0.694024037829817, 0.6564635422525804, 0.7637937667938812, 0.7804723301994468, 0.15191599376522413, 0.7662866892857876, 0.6816528952737739, 0.7713065080544794, 0.2180236885194623, 0.7782619071814806, 0.3582490718746454, 0.2083093422509703, 0.3807393278500104, 0.277007002884735, 0.8265767214532832, 0.8759432507576312, 0.23072055516363366, 0.22798431725315838, 0.23341851112607903, 0.2238108399039821, 0.22851214631476235, 0.13252246211220353, 0.2147161894283971, 0.2226019011018343, 0.22543670363751733, 0.22930794313421188, 0.1309366647607807, 0.23111948890226863, 0.22202810081737134, 0.26006400839655697, 0.22639984648214595, 0.25628712526532593, 0.10042347827597042, 0.2178861917820465, 0.22362686470638227, 9.999999999998899e-05, 9.999999999998899e-05, 0.11521326069255733, 0.030267167386667126, 9.999999999998899e-05, 0.043999914825684217, 9.999999999998899e-05, 0.0036355650776853654, 9.999999999998899e-05, 0.03223507797351999, 0.07041778045312896, 0.1585881881750254, 0.003776780944978242, 0.0579609350797069, 0.0021217685514364204, 0.0542971690724009, 0.017337171794075457, 0.0824572419872166, 0.0702718697912258, 0.03547254193249594, 0.11819280112458286, 0.07836137959159473, 0.15869798334028906, 0.07806642868345881, 0.0991922595533804, 0.2702566734743461, 0.07163317521747814, 0.05311507431366702, 0.042397481259958125, 0.042319872592815, 0.059305703623247275, 0.054873534127131474, 0.12387971427380451, 0.08169497583676744, 0.05729199538374263, 0.08356771984942168, 0.5453803338718508, 0.5517630194383141, 0.5320341459637796, 0.5662760493915067, 0.5574245101271218, 0.5824451695004144, 0.5623473082763941, 0.5618263844582757, 0.5926210540327354, 0.1341769911909283, 0.09035120022211418, 0.09707967633685533, 0.11667015018561977, 0.12137964558219683, 0.12367769790451733, 0.09613620561980407, 0.12772700368294032, 0.18387353362574133, 0.30294958514302794, 0.1849373788180082, 0.16993946240286917, 0.1940779097212576, 0.2672293555280171, 0.18086434315986277, 0.2047979240588822, 0.15951539257368874, 0.27798253119668803, 0.43048355199221655, 0.3290273181659229, 0.35507914357367387, 0.22755226310769017, 0.30907786830073514, 0.4022535814023416, 0.5827155049805016, 0.4418339642631468, 0.6971056038643857, 0.402502503510324, 0.25473896002442853, 0.23346381892445445, 0.1777071393940085, 0.2550302900784307, 0.2421594681052689, 0.32877367483413755, 0.21830705452066845, 0.25588739003463434, 0.21346157121749032, 0.21688577816066534, 0.21812518257195912, 0.2295717446384541, 0.2059747350900767, 0.21493065516858623, 0.28012780241107416, 0.2291171614302948, 0.21126023465803145, 0.18822991018704838, 0.18754443459072223, 0.21974731073418097, 0.2068184477506413, 0.19050473042651472, 0.22425663787662553, 0.2046962453707617, 0.2031342025556211, 0.1930096952575313, 0.15204299280203337, 0.167276375488988, 0.1738886914990473, 0.17657996443154056, 0.1749180816869912, 0.8920315668240618, 0.8667735532551544, 0.14746487557620347, 0.16523823454630915, 0.5650213914764742, 0.20797538999578513, 0.1673544415639151, 0.20734457120642946, 0.7594609815306431, 0.6977895959136533, 0.1677402581463444, 0.7377865284828, 0.16841121321252828, 0.1887374881945738, 0.19484209612125947, 0.19644882677756237, 0.19217302075176845, 0.18876529516121365, 0.19610332897813332, 0.1848306711658957, 0.1881135997924589, 0.19280569431926764, 0.10435972663093884, 0.09402042456648685, 0.11692341632113679, 0.1025332252860115, 0.14444709788894938, 0.09287299797582615, 0.0853603350674812, 0.08769509846411383, 0.0919417214547128]}, "mutation_prompt": null}
{"id": "1f224877-a3bc-4b25-9f30-138918f702b9", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            dynamic_f = self.f + (0.1 * (self.func_evals / self.budget))  # Dynamic mutation factor\n            mutant = np.clip(a + dynamic_f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate a dynamic mutation strategy in the differential evolution phase to enhance exploration capabilities.", "configspace": "", "generation": 70, "fitness": 0.33167251769456635, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.30.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8864177453916042, 0.8835494361090791, 0.8663380883846941, 0.8959795541958439, 0.8683612160305736, 0.8912725940022743, 0.8872914003159318, 0.8860101583108988, 0.8715616540007646, 0.7819049343672511, 0.7600595146403695, 0.685009131871137, 0.7798486029844136, 0.7758485685648996, 0.77139081014608, 0.7584474400378457, 0.05298718252814982, 0.7693644291178332, 0.13967984404665312, 0.12126918656097607, 0.1783289676690163, 0.17089194433661692, 0.07177427512354628, 0.07186273583996139, 0.17201752805286252, 0.13141982327221136, 0.11732375413137508, 0.11844059740655977, 0.09260499999799698, 0.10149093127300512, 0.15451381966783517, 0.13651624997433087, 0.14657057529640227, 0.14913914716134435, 0.11631280152531054, 0.11046602438690734, 0.9817207922339803, 0.985428176344376, 0.9859318995212593, 0.9856402806421544, 0.9934927798867312, 0.9861321845819745, 0.985734407305008, 0.9884790033120172, 0.9922191152412982, 0.7414346484704926, 0.7100256906878978, 0.6988883462831799, 0.7499426003674152, 0.7092015105168732, 0.731795682392625, 0.7536864611031511, 0.6882743085877316, 0.750801805089423, 0.36480000920959554, 0.22626255280558216, 0.2168245234080428, 0.8719818780483903, 0.381770659595812, 0.2100653971643177, 0.1274947624646955, 0.8893437378154402, 0.2347333854357978, 0.27646845000297904, 0.25719586231952807, 0.2401221798161569, 0.13403148575842028, 0.2493064433844746, 0.22950646880746595, 0.13269416238179765, 0.23514024408729872, 0.23497817514371644, 0.13014348071235604, 0.24378758301303338, 0.24193033117365403, 0.29488619075317324, 0.28226076323004934, 0.34158729968929635, 0.09859828795539438, 0.2588120717769, 0.24354035731036827, 0.00012196781018569691, 0.0017015203358212716, 0.016820961089711317, 0.04527975585614208, 9.999999999998899e-05, 0.05850780660159416, 0.0013707088497201259, 9.999999999998899e-05, 0.0058942642131871725, 0.07662251676727883, 0.044234464159146, 0.11172035755856613, 0.04564548517146794, 0.03141915064507084, 0.06310235318835244, 0.05872239044161465, 0.01514489776696537, 0.06745992685216495, 0.06699813509928865, 0.034637036208571725, 0.11198394716059479, 0.07784671133237586, 0.1647701562261915, 0.07950227197497028, 0.10407423682797978, 0.2503483280887483, 0.07256364209209265, 0.04350017819704166, 0.031722007047114475, 0.04951457396928094, 0.10112969321477538, 0.05325233929666773, 0.06807006654845482, 0.08209054430316098, 0.062318015640997926, 0.08216399219957349, 0.573841512566102, 0.5963854996800093, 0.5649432236007746, 0.6582066203856756, 0.5572414555742935, 0.59229174368957, 0.593604617088531, 0.5846316326453871, 0.6345179319818914, 0.12254738946052224, 0.08829303886184536, 0.13732501442946943, 0.1030834041351163, 0.11638233031455003, 0.14059404128875141, 0.06926321379252098, 0.13221244483863503, 0.1219304418727637, 0.6116625262766071, 0.1766083631577703, 0.15533746110882363, 0.2198249498575433, 0.1305764259059068, 0.18320380236172829, 0.20376801728422422, 0.18868208128902475, 0.18424597778904217, 0.40724852267346046, 0.37548228821541296, 0.4069124566946323, 0.28720078429920537, 0.36130628057356884, 0.508650717284316, 0.45610815948702343, 0.16219449712395617, 0.7079940740576365, 0.3339483689176832, 0.2517194795595781, 0.29022685712250385, 0.16944843276775134, 0.23377406323334948, 0.21037144262094531, 0.3049204450583869, 0.1848416883429419, 0.2500312174458891, 0.2239842998047087, 0.22576859798039906, 0.20243442851786353, 0.2085356034064343, 0.22753135404244884, 0.20224413822115017, 0.23023673597799144, 0.24709342527431577, 0.21744498837013848, 0.760074917860332, 0.207646196349334, 0.19370879606911806, 0.21816406678834843, 0.2067965134612102, 0.17171237918596216, 0.6718060612094303, 0.22222069322702442, 0.1901557558618855, 0.15301808834879427, 0.163595677951341, 0.17465515431907064, 0.17677402545136467, 0.16627066267659096, 0.897613041361239, 0.819755921439546, 0.8930298193308722, 0.8375520191895398, 0.6180701479755171, 0.20492115440611847, 0.1670109144726455, 0.20876768412567515, 0.8134359242745981, 0.745176985788755, 0.1676480087318578, 0.7925730280407436, 0.16840265835744195, 0.20811874479151882, 0.1890373386138131, 0.19687296510500407, 0.20391218400137967, 0.21121977390905222, 0.19789232898147813, 0.1810542438527183, 0.1877271243371652, 0.21218803057225433, 0.09218446700649441, 0.0796575903272847, 0.1361742346883037, 0.10429176001483886, 0.12274329189251387, 0.08377383757449419, 0.08801760525009905, 0.10018666010640032, 0.08698033114764891]}, "mutation_prompt": null}
{"id": "fd7823b1-164f-43aa-9fac-01bd09c54b03", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "fbe4f5d8-b054-4e4e-bd41-c9192a737cce", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n                        # Secondary local search\n                        secondary_variation = np.random.uniform(-0.05, 0.05, self.dim)\n                        secondary_candidate = np.clip(trial + secondary_variation, self.lower_bound, self.upper_bound)\n                        secondary_candidate_score = func(secondary_candidate)\n                        self.func_evals += 1\n                        if secondary_candidate_score < self.global_best_score:\n                            self.global_best = secondary_candidate\n                            self.global_best_score = secondary_candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce a secondary local search method for further refinement upon finding a new global best.", "configspace": "", "generation": 72, "fitness": 0.30759520071367014, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8797415907730891, 0.8902492339831123, 0.8756467051975371, 0.8948677492215527, 0.873346507490107, 0.8819451561878737, 0.8903552011404191, 0.8884143071215216, 0.8249119687617288, 0.7206431340222185, 0.7180642486065758, 0.7687421894804556, 0.7640972348936158, 0.7751281086305777, 0.06378793992394238, 0.7523867195852542, 0.7388268768212837, 9.999999999998899e-05, 0.14025691486662217, 0.15467236132244888, 0.1157750435109669, 0.1322074237743045, 0.11087387009734484, 0.10271912831499863, 0.1099478410181739, 0.11837622409917714, 0.115571014305624, 0.15438064625976344, 0.11734468074256965, 0.127305069279242, 0.12600548546085266, 0.1685516116202771, 0.12777026035817618, 0.1380793426304825, 0.15733530458823242, 0.09699575877937239, 0.990689540093014, 0.9914247848146899, 0.9808028055827995, 0.9891796425330149, 0.9921698769163425, 0.9858478334689661, 0.9917748864563636, 0.9900098017038023, 0.9949506933493911, 0.7281776973349972, 0.7451003903787105, 0.6740011918170556, 0.7124676200964855, 0.761783951374878, 0.6916403210692799, 0.7243968047783577, 0.6704222539326296, 0.7024994452609441, 0.3561398590540783, 0.22313335841491477, 0.17177197847675651, 0.21228348076204462, 0.2769170172443439, 0.19118118183454058, 0.17318909911882874, 0.175436795584336, 0.8482395646455033, 0.23866852872101652, 0.1042759616293264, 0.2416114847737263, 0.1324157797001173, 0.20723592976938465, 0.13006451237279926, 0.13253324519664889, 0.12965128968881323, 0.23716180923932206, 0.13347350682689918, 0.23754962780954558, 0.11545935878240121, 0.25055734109208083, 0.252162427560225, 0.28587491560776646, 0.2702757173124559, 0.133100964916687, 0.26436933632676707, 0.07706446369518749, 9.999999999998899e-05, 0.05852097428041236, 9.999999999998899e-05, 0.0005275715404593484, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1516180132821917, 0.039789615198311035, 0.04539059681379898, 0.05618853054605866, 0.02328085680914027, 0.10634820567925396, 0.07358345246358311, 0.011191678884414746, 0.095626437747518, 0.029241093595707035, 0.08563111717961913, 0.04876500688476848, 0.07866562100140473, 0.11675676139636815, 0.07644085159556124, 0.1020968352081294, 0.09753193119602033, 0.07794288810655636, 0.1082236886059823, 0.17357803506147373, 0.2728128097321766, 0.08565087098834934, 0.10081104820183884, 0.17599456265069235, 0.0535767925206424, 0.056893163773067856, 0.10432755807709304, 0.592634601184022, 0.5109411406142543, 0.5893285663825618, 0.5590602701343641, 0.5835377464115497, 0.6126326155204908, 0.5720365181414513, 0.6198347897182666, 0.5905745191712546, 0.09941534958813447, 0.06629977758095118, 0.11872239642832139, 0.14627806896196194, 0.0950216575215016, 0.12829886586748107, 0.11397587439488821, 0.11277775569246062, 0.12544108392232378, 0.19659519606853648, 0.2649381523805008, 0.17959796426663344, 0.19985230157125655, 0.26645386915526315, 0.24701600660189416, 0.17942722413364665, 0.17777281450731808, 0.2750066554764923, 0.3615244984406457, 0.24662488309080943, 0.2556383475613807, 0.5817033263516329, 0.376636775851957, 0.43841822158863797, 0.5720150180677519, 0.4845357460913531, 0.5309222966101631, 0.32224796954853874, 0.19544624097050467, 0.21439253411917114, 0.33306789014648486, 0.20071871775370265, 0.2008913935502037, 0.45650544232868506, 0.3024631214253576, 0.3581860845341859, 0.2300759315738986, 0.22195822704639878, 0.19458932282835106, 0.23136901651970554, 0.1967541490873601, 0.1988978312442008, 0.21984983671427427, 0.23574385613153614, 0.2571987189007745, 0.1878821470600629, 0.19074842242377232, 0.22108761478182182, 0.20398663466218225, 0.19577173050878283, 0.19621706983812648, 0.19718410237685124, 0.24563572741979312, 0.18131603802096274, 0.8964785835532967, 0.19939931636626385, 0.16148290678813826, 0.13057556541595894, 0.16532142056530752, 0.16716020168872547, 0.11902508630276731, 0.899836956316792, 0.2120518824702542, 0.11279282814379077, 0.1677509960271274, 0.1666710439256649, 0.20957363779372784, 0.15419311592391527, 0.20729859236326542, 0.8055489654710578, 0.20978093725971558, 0.817015023240658, 0.18567233636205405, 0.20254782681688333, 0.20735423526765828, 0.22726832935216945, 0.19677022864531024, 0.18928810200653612, 0.20040919200866403, 0.19599483849166954, 0.17860660320528277, 0.08993636654102699, 0.09387957360115329, 0.09395911309450289, 0.10302595552100502, 0.10460542483752455, 0.08580323054914729, 0.09023547176498303, 0.09219448069658664, 0.09721082019803817]}, "mutation_prompt": null}
{"id": "ea402edd-c698-46f7-8665-ca9f819ce40e", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n        self.memory = np.zeros((self.population_size, self.dim))  # Added memory for mutation\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c) + self.memory[i], self.lower_bound, self.upper_bound)  # Use memory for mutation\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n                            self.memory[i] = variation  # Update memory with the variation\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce a memory-based mutation strategy in DE phase to enhance exploration without exceeding the 2% code modification limit.", "configspace": "", "generation": 73, "fitness": 0.32374301656213994, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8879581621666043, 0.8800507001216678, 0.8903558160770697, 0.8983756162349587, 0.8584673876704456, 0.871814145015994, 0.894469389315062, 0.9056782044208009, 0.8753827998095605, 0.796909779835951, 0.7502366263834082, 0.715948743120304, 0.7424104883419488, 0.7325081450464007, 0.7691975066050118, 0.7131214776702159, 0.543190288080154, 0.7587085787320225, 0.15345398659897946, 0.17025093399522484, 0.15300741614720914, 0.07439308832957525, 0.07364305347617661, 0.1494859103705266, 0.15194661909485618, 0.18133546845843684, 0.14432093618445174, 0.17678908903194646, 0.09733810271357723, 0.1528719106349541, 0.10816930099699185, 0.12394653614801632, 0.11522720788800289, 0.12240302913963186, 0.10941713881281756, 0.16988642009188115, 0.9817205046788523, 0.9854280397106265, 0.9859261260792322, 0.9856402350458622, 0.9934927733958694, 0.9861315012472344, 0.9857355352074184, 0.9884773543957677, 0.992218922326036, 0.7209375911378371, 0.7259848545232921, 0.6801653405058257, 0.7063658579044809, 0.7542447056244668, 0.637652716552447, 0.734130508876379, 0.7230983796857643, 0.7496161404346655, 0.22452690721979285, 0.2260817742166391, 0.7901324574682607, 0.2710336055656989, 0.3811709824180213, 0.2731852757505745, 0.12135919545499696, 0.1378114880272442, 0.23451557606984663, 0.2711711864431503, 0.22585460665298984, 0.21867075357313936, 0.1340491976395306, 0.20927018836331923, 0.20535839644332377, 0.13252704006454163, 0.21208882027088283, 0.21256554763766422, 0.16486694578184924, 0.21086053718081066, 0.22281369381521587, 0.3776423545030356, 0.2550261614479563, 0.22163205023106747, 0.10231873262067515, 0.128267479306433, 0.22792052928917106, 9.999999999998899e-05, 0.0013314065363787542, 0.009960720908210763, 0.052893599950950554, 9.999999999998899e-05, 0.0466140419676232, 9.999999999998899e-05, 9.999999999998899e-05, 0.03316843930261293, 0.07928814774292259, 0.05328172609018422, 0.09014057294011579, 0.010315778430205147, 0.02250738016862419, 0.05639770982149639, 0.06874450199043236, 0.02105757706675626, 0.08184447844805942, 0.07172217192156827, 0.035681649731435616, 0.13080003118455674, 0.0789657251597673, 0.158673936177537, 0.07952820989729081, 0.1023841763866501, 0.36651243014127344, 0.07243113537928858, 0.04478320714744555, 0.04432667583317873, 0.04242586241523716, 0.04379660109292194, 0.052993616585617964, 0.2627121645024352, 0.09372291567477609, 0.0487268960121261, 0.08263489347119335, 0.5982984298117444, 0.5160452219532368, 0.5722229632925168, 0.5331471007089233, 0.5897912061207247, 0.6048265673703689, 0.5933235033329047, 0.539531688489151, 0.572645052110663, 0.09688589639012901, 0.11751596672266462, 0.06470536310322916, 0.1026687279502072, 0.11231027245084535, 0.13780714812989814, 0.05581398208270971, 0.1567640818477043, 0.1482036833555539, 0.3064712448168704, 0.17682495730415249, 0.16999434689293758, 0.2199102600734616, 0.19795436025091784, 0.2230935955954566, 0.15684464866997427, 0.18871182982906476, 0.16654317109924832, 0.29746227811812265, 0.2812420715083165, 0.2707512194266073, 0.3026944568286525, 0.38993124912166177, 0.4665737283617588, 0.394202028584383, 0.4710560464605188, 0.6302900543316513, 0.21578720329678558, 0.23371063523627011, 0.2626760597657004, 0.2295540544183432, 0.20761614078751256, 0.19978483795746083, 0.3648352747713548, 0.3001484600476526, 0.32830201722352237, 0.21571945542368298, 0.21088052503496768, 0.220044514827065, 0.21992550283312862, 0.20949821447821082, 0.26093184925204393, 0.18978377408214753, 0.25642821309857067, 0.24203514480593924, 0.7547181320212899, 0.19804170433965496, 0.2498440464277628, 0.18113923732677395, 0.20119041335978471, 0.24495156409301777, 0.19010222697160273, 0.20956168820086873, 0.18417374960792987, 0.15313211512403901, 0.1574835483313065, 0.1744632905319511, 0.1765392082988193, 0.2063067557531113, 0.9032145911278652, 0.7679800043060357, 0.8745241453251686, 0.8202058359124218, 0.6942506537303645, 0.2077579039297649, 0.7064879776141837, 0.20805818545439103, 0.7853478727093768, 0.7132907461375871, 0.16768110726780017, 0.12701527773309373, 0.16842844142593127, 0.19311831378198974, 0.20400492493309796, 0.1861820408924666, 0.19194642625606229, 0.18732491717473898, 0.18681452783263952, 0.21445259834406571, 0.2073087471878191, 0.19414157425358658, 0.09353778497283816, 0.1172526915100649, 0.09457611087351836, 0.09044048800210658, 0.12689694681107944, 0.08757017076313256, 0.10068447766260924, 0.08262697157840115, 0.08987420806521784]}, "mutation_prompt": null}
{"id": "3bbf506c-633d-4582-8f5f-58c387669bf2", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "f819e99a-694f-4c31-9b9b-c169862498e9", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            adaptive_f = self.f * (1 - 0.5 * (self.func_evals / self.budget))  # Adaptive scaling factor\n            mutant = np.clip(a + adaptive_f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce an adaptive scaling factor in the differential evolution phase for enhanced local search capabilities.", "configspace": "", "generation": 75, "fitness": 0.3307276864003632, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8775970197419601, 0.876242478432069, 0.8803678295322006, 0.8915902450094395, 0.8556753200607481, 0.8930696772192582, 0.901445925922524, 0.8999676807206334, 0.8994007159185219, 0.7698477099544835, 0.7637624358739457, 0.7630096616817721, 0.7356320959465068, 0.7616881299438267, 0.7827367155793427, 0.018316082927927524, 0.5873841988173513, 0.7672877585016253, 0.17475202630342268, 0.16013619027369008, 0.10038791805828007, 0.15216039132484727, 0.07390369122337748, 0.07186961953880056, 0.11360597566525288, 0.1766179329143439, 0.0626693726708325, 0.14677137699395448, 0.6325853049332175, 0.09262317318738189, 0.10614470559304812, 0.11286560822231295, 0.14827738875275953, 0.13045040812984676, 0.11469673673995495, 0.17277488440489397, 0.9822985185984799, 0.9854275012047206, 0.985929693202049, 0.9867673356664995, 0.9934927486024009, 0.9861287025008786, 0.9857353423331451, 0.9884796693839042, 0.992218157587406, 0.7635572328307949, 0.7405561734016279, 0.7512649354980729, 0.7204595359171131, 0.7638691753775129, 0.7296061474821951, 0.7225440324199415, 0.6281355162164503, 0.7659699777625383, 0.2322768388482126, 0.3812542535286766, 0.20257871192321808, 0.4738032502420937, 0.8989587596789317, 0.8779949057862574, 0.22399381745353908, 0.24444522476286368, 0.8177487097093796, 0.11698980475435783, 0.24720220379822277, 0.2572070640941295, 0.13228213354481833, 0.2578517201597529, 0.2467794715074303, 0.21694055080944918, 0.17736361141841372, 0.23779542027057055, 0.13082983961983496, 0.24275697800516227, 0.2319863474472017, 0.3007673767024608, 0.24508145413611582, 0.23191086321602128, 0.09936556785833162, 0.26388103671656704, 0.2389223427305711, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025902576077978523, 0.02727829624196365, 9.999999999998899e-05, 0.060022939593978086, 0.0013023093067900948, 9.999999999998899e-05, 0.011511525047973592, 0.0753951877843263, 0.09310579144175468, 0.11294055083744448, 0.01404180377413744, 0.03959054503509851, 0.01791940807349124, 0.04304655379312461, 0.014199434910377784, 0.07439445760549512, 0.06823559468979001, 0.02886397610527036, 0.14068967079691796, 0.07599675678424811, 0.16268819472796114, 0.07866570702463538, 0.10221841804396503, 0.30363569364791354, 0.10829818622030729, 0.04240974411274656, 0.04385383391366382, 0.04339138602374659, 0.15208006073664238, 0.06023212767470554, 0.17723444174363334, 0.08231328732448506, 0.048436025706083075, 0.08198124727864231, 0.6026569252301435, 0.5418818601898674, 0.5984687830442824, 0.5740961615780135, 0.5697984895527954, 0.6235012427981641, 0.5847225129360688, 0.5719369732654893, 0.598228345994799, 0.12104997859308964, 0.10289321641280635, 0.08161584640742492, 0.10405085881486953, 0.11951313538821873, 0.08459429480045089, 0.11587128234644295, 0.10532226786950616, 0.11415670699405289, 0.2686933412301582, 0.2901943423599572, 0.22582315359331628, 0.21766691289406948, 0.19281237405770657, 0.22181667226685786, 0.17988070085410834, 0.12613210971027078, 0.24154630551342382, 0.3222741140187526, 0.2844222033241831, 0.28840449743335994, 0.6115084358634344, 0.40082554011078153, 0.31087861462920763, 0.41361712316608457, 0.4148645681759373, 0.5451057151191676, 0.36565980450057245, 0.28240508644110185, 0.29000223889420373, 0.17419750276049217, 0.3525141856693056, 0.2290368427245545, 0.10684438470444402, 0.28959916324214285, 0.2727999800157189, 0.2103202746887829, 0.23838328070463455, 0.2428157852138605, 0.2531226444386996, 0.17687128302156485, 0.20778065230445586, 0.21610852097469702, 0.23746346416103814, 0.21231538786778736, 0.7481876792513816, 0.21849316708788413, 0.2032460671412163, 0.21984021781116148, 0.2188276611367843, 0.2178309467800592, 0.20475169048178188, 0.22067324649372444, 0.18872195237879363, 0.15092436373403484, 0.1674606746320877, 0.8493788816164325, 0.17652443278772156, 0.1657569175005843, 0.9143657250468561, 0.8036034590395041, 0.9002000362693715, 0.16352655712745912, 0.11253603617296082, 0.2045665843443878, 0.45261339767508146, 0.20851298755250447, 0.2010235630895818, 0.7380869364421276, 0.16766340396083235, 0.8144900396676624, 0.16787140442367565, 0.19621891782920997, 0.18974269378207131, 0.19159254322641195, 0.19164714104183578, 0.18910154423858105, 0.18955007475792696, 0.2164017134260382, 0.22395826715401346, 0.19146908252001937, 0.09934665004050836, 0.08889068161647684, 0.13655694347261105, 0.09818460405473395, 0.14229110236213438, 0.06630939900396993, 0.08468546979714486, 0.1543888987816333, 0.09941396183038653]}, "mutation_prompt": null}
{"id": "945a8a40-d8b6-42e0-b44a-a9292e4653c2", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n            self.f = 0.8 + 0.2 * np.linalg.norm(self.swarm - self.global_best, axis=1).mean() / np.sqrt(self.dim * 10)  # Dynamic mutation scaling\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce dynamic mutation scaling based on current global best distance to enhance exploration capabilities.", "configspace": "", "generation": 76, "fitness": 0.31635624471631013, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.87431146408948, 0.883273907111663, 0.8856980884767288, 0.8811012516752963, 0.8696365798402121, 0.8893437789279448, 0.8960977637805445, 0.8976195579313615, 0.883601058266699, 0.7649355179493491, 9.999999999998899e-05, 9.999999999998899e-05, 0.7474460433801009, 9.999999999998899e-05, 0.7817135242894756, 0.759331922572904, 0.6468450505075685, 0.7705730993983985, 0.15541403863979253, 0.17934411476659007, 0.13458100019972896, 0.14779926465103288, 0.07344661876092962, 0.13620430640567138, 0.6705753274524472, 0.1526044354163718, 0.14252688679972503, 0.12743735730641692, 0.18071149750493076, 0.11381953631164365, 0.13730989998374676, 0.10632332977670433, 0.10847475443662002, 0.11148256055289818, 0.1062232372725328, 0.14817140925852856, 0.9818789315427855, 0.9877696534262707, 0.9859758462460061, 0.9862032222277506, 0.9934621788274179, 0.9864193533409953, 0.9863214905326102, 0.9880740203894812, 0.992218922326036, 0.7678934772649989, 0.7394257491214817, 0.7234671439060711, 0.7712019985217433, 0.7301903317424421, 0.7146122994382653, 0.747400835589429, 0.7395154315954379, 0.7095885901610688, 0.22326691374363217, 0.7753052456516698, 0.37540541847069175, 0.3712199197293006, 0.2671129983005953, 0.21067299127111672, 0.13922677879761325, 0.8309994993282348, 0.8270778157133577, 0.13233208274627017, 0.13046452414188203, 0.25649469707993566, 0.2764789488213826, 0.24209608722602294, 0.24471093262278132, 0.2512179819745606, 0.24652203251385907, 0.24556531101877455, 0.11103670704963353, 0.3427286708248831, 0.23083939759369188, 0.2734758315856226, 0.13364908361457473, 0.2493294478744842, 0.0337607018066286, 0.10135693951583868, 0.25944185043384416, 0.004511974322450096, 9.999999999998899e-05, 0.0025802657116239525, 0.011180228767046496, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015076174976067502, 9.999999999998899e-05, 0.059299928953693404, 0.07420427654206119, 0.04039383084721526, 0.06211348584843235, 0.0563485988387985, 0.06275497666167484, 0.04805029107606318, 0.04777284619535205, 0.04552757235601024, 0.043746069981197566, 0.05406727710621362, 0.0981735613791187, 0.10075688339740496, 0.07945611316273682, 0.09723257064677238, 0.07866201180161969, 0.10080682926667073, 0.09796548960729545, 0.10128797625389563, 0.10403547121026391, 0.04379661261452672, 0.0383901368035211, 0.04313784477594196, 0.10934747333726558, 0.08581167668339984, 0.09548224988934306, 0.10994967465662997, 0.20591591174439905, 0.6147193077735034, 0.5755237585841966, 0.5464418218261655, 0.5789210194635157, 0.5632685209909105, 0.5925626521489074, 0.6508077412811006, 0.5873772165789618, 0.6098247053401418, 0.07083638279788995, 0.10864456371892905, 0.09725129434043722, 0.10453989877590975, 0.09381346129958201, 0.12470184470568424, 0.10171917771842653, 0.13782542508996154, 0.09104266630490399, 0.2524534765917855, 0.1551421023689079, 0.2155931509073552, 0.303885307520639, 0.25435686831107807, 0.20813894417597145, 0.16751961947357685, 0.16956852450975202, 0.22815651369899614, 0.4450065584065964, 0.3479988676143676, 0.2501432885036132, 0.22631365200637, 0.42379346472916846, 0.4136397880069774, 0.5215607551185946, 0.40872812349554655, 0.3214702439600816, 0.3539852233720868, 0.29986105408917896, 0.20249895679682073, 0.23003601495150594, 0.28396268492944665, 0.18870202572036343, 0.36560770242861285, 0.21053103473587775, 0.16537204305703113, 0.21015003940335208, 0.2225574444803895, 0.21789958261490483, 0.19729564720920567, 0.202857295226456, 0.2233589127093235, 0.2166806531081945, 0.25737166469411044, 0.21566682980978735, 0.24083551405065973, 0.19531465443415474, 0.797096445843803, 0.21722158179462936, 0.1939964525294533, 0.20299572589210424, 0.20446411469247927, 0.24033223033923812, 0.24499008014984136, 0.19258119482761027, 0.14160333381793166, 0.18524825536995126, 0.184502822956629, 0.18632971101079898, 0.9229369030110449, 0.9262051805359355, 0.20893575700576683, 0.16564972202555328, 0.20974679141035824, 0.8033039125593845, 0.16779090993828538, 0.20873596551229479, 0.6100803036252285, 0.8326183589821794, 0.16736277627328489, 0.12746891531324112, 0.1646332407665927, 0.18220942735213164, 0.2129443989420825, 0.1990743057713037, 0.19524295847665485, 0.18714747059750259, 0.1811711130405601, 0.20056188316966905, 0.1954355665738432, 0.20613039036380654, 0.08642604661724085, 0.11765366766114171, 0.09459062967207088, 0.1003455005347278, 0.13330848763429637, 0.0982687506050588, 0.10726721038790477, 0.09107024011702813, 0.09108024178091378]}, "mutation_prompt": null}
{"id": "e7e25d3e-c383-4309-a835-e9a16c33650b", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def levy_flight(self, L=1.5):\n        # Implements Levy flight for local search\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1 / L)\n        return step * 0.01  # Scale down for minor local adjustments\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase using Levy flight\n                        levy_step = self.levy_flight()\n                        candidate = np.clip(trial + levy_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate)\n                        self.func_evals += 1\n                        if candidate_score < self.global_best_score:\n                            self.global_best = candidate\n                            self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Integrate local search phase based on Levy flights to enhance local exploration capabilities.", "configspace": "", "generation": 77, "fitness": 0.3223701567265526, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.29.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8805262894728736, 0.9071085517389053, 0.8929937452763627, 0.9067072825827734, 0.8432814216743315, 0.8836541433080366, 0.8734323610809038, 0.8921986789826415, 0.8764321857339421, 0.7821254609189126, 0.7581373852673878, 0.7664135296048299, 0.7770605097948126, 0.7823611488410469, 0.7554772989556918, 0.7663977669762972, 0.05800188330718026, 0.774792829988933, 0.17192367044495516, 0.12671606799351298, 0.11849335175098763, 0.15340198777353975, 0.14117898062286238, 0.6435029121061893, 0.15668734811973228, 0.18146780620692649, 0.11019816255723669, 0.12015655816670301, 0.1200837316430774, 0.13010009684455048, 0.1048989613967376, 0.09267210783952928, 0.14425144456770234, 0.1297279313729719, 0.1478249417626757, 0.11166440612213158, 0.9896703402524792, 0.9901170788291893, 0.989063300215263, 0.9820200508835386, 0.9933162394008622, 0.9874695819784816, 0.9888109437786087, 0.9869407999147807, 0.9871525345168527, 0.7732853127181172, 0.7548609908647161, 0.7720787926231527, 0.7621081925742182, 0.7496874119747043, 0.7476992113393541, 0.5684458911278594, 0.645115495876689, 0.6801925132376936, 0.23763423730608169, 0.840014243980472, 0.3689256981402538, 0.191905023497131, 0.27720369588558547, 0.2179390173935456, 0.10552620462517792, 0.23071359079587872, 0.23508494941619384, 0.12853956835270564, 0.12809696429623418, 0.24461609139382412, 0.2516001420660504, 0.215104792637123, 0.24108073444717448, 0.2251077131811018, 0.2451644412147138, 0.2182801907269516, 0.24041218088637206, 0.2489309012313078, 0.2129942377633781, 0.25991965038785614, 0.27572573027408576, 0.25585955460147514, 0.10643343165890928, 0.2317859111655145, 0.2638088499926998, 0.05584804037203417, 0.028832464644267697, 0.06325964408347828, 0.032976338449872356, 9.999999999998899e-05, 9.999999999998899e-05, 0.00289367355595771, 0.0037634620084979753, 0.054503483602569736, 0.10086312667948205, 0.07758012961262084, 0.0437464600505274, 0.031173054190397176, 0.03141563435061201, 0.08936502268781754, 0.04149060848831465, 0.05977739061653231, 0.05797594202352485, 0.03714792713530879, 0.036085740658206134, 0.04684588306332482, 0.07593663305476317, 0.10212168726361648, 0.3638975113364663, 0.1376221995689202, 0.07399955205842856, 0.30153760664967033, 0.07781238356235043, 0.04952537133962853, 0.12402352045860898, 0.03628431165413892, 0.03927417683648182, 0.12053914749601302, 0.04853952266552952, 0.08280387839357883, 0.08452138912505469, 0.6016205741523968, 0.5390563885414437, 0.5366766547458254, 0.5618813478750546, 0.6120277337823139, 0.5471599920236476, 0.5550178465908773, 0.5709237663737177, 0.5775278974683404, 0.1134782009389117, 0.1085588089101166, 0.09345900531986884, 0.11470074003341013, 0.10761803738611109, 0.1058171639033737, 0.1354832505842125, 0.11589404566489026, 0.10709459455064407, 0.3196967517360927, 0.15854416155648265, 0.21410735380297286, 0.22175905920943373, 0.19901957663537106, 0.1891532412704372, 0.20955388052448798, 0.20207315496234413, 0.34804419259477803, 0.41376221380243816, 0.40694092371709945, 0.6780506682021489, 0.37085584832569585, 0.4453880928556335, 0.2839515891578439, 0.59395737395126, 0.3782552994547441, 0.499690892961308, 0.2187533404727413, 0.28213705760427277, 0.4264564344873849, 0.18956500280293354, 0.2081426965025266, 0.19510898994159187, 0.32862367815893245, 0.2505557674545297, 0.30204263931988506, 0.20520162546470533, 0.21924844764590878, 0.23557247699814365, 0.18792112076251244, 0.23217539969023204, 0.1907923587151693, 0.2222079986544856, 0.2034218499185585, 0.19575953991769424, 0.20994878729659583, 0.19456314236490946, 0.7595192158077523, 0.197131545820733, 0.19470275444660323, 0.19457959074534714, 0.1954155564826, 0.219734640391826, 0.21508569580293246, 0.8565583738100686, 0.20795244621880915, 0.12406609279520397, 0.17573324192568507, 0.18615505418902734, 0.8959603841574507, 0.14389888865486777, 0.16571466300502413, 0.9139155933418605, 0.15437591667914863, 0.16739724334716044, 0.21123247737542672, 0.16565592168442456, 0.794277317758502, 0.7398339655138094, 0.1508690459502814, 0.21083305448274192, 0.1554694908704476, 0.19253879254745754, 0.18057174136597332, 0.1889843177572612, 0.18947088423147662, 0.19545021628296455, 0.19468415027256292, 0.19180918296771154, 0.20810596926832103, 0.17952057833607704, 0.09546161551807053, 0.09222145479412991, 0.09471476557850889, 0.10040451304764098, 0.09481692912783457, 0.09104958521073292, 0.09539035595173662, 0.08059427918072992, 0.09241938454015941]}, "mutation_prompt": null}
{"id": "676dffc9-9f33-48f4-884c-0f85820983b7", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            # Stochastic dynamic inertia weight adaptation\n            self.w = 0.5 * (1 - progress) + np.random.uniform(0.3, 0.5) * progress\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        for _ in range(2):\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduced stochastic dynamic inertia weight adaptation to improve exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.3164168034944048, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.878037193894639, 0.892007741127015, 0.8778801178475271, 0.8808597616705262, 0.829634722372059, 0.8873996374557741, 0.8978225407252736, 0.8823352725995312, 0.8779880905954899, 0.7835296009604534, 9.999999999998899e-05, 0.6061074738618135, 0.7631083826613053, 0.7546658571757384, 0.7590399374351025, 0.6949702597914291, 0.7752515851129792, 0.7351703956536122, 0.15185957868919053, 0.6597699163037282, 0.12776017688483066, 0.0984678765522835, 0.17841112180454022, 0.6977392079860001, 0.1489130268131852, 0.13212553398234594, 0.12466595504560751, 0.11452545571328554, 0.11740477587942555, 0.133745043521298, 0.17336741732010819, 0.11177227686050262, 0.15199719540460754, 0.11213272627499082, 0.1397783792593147, 0.1317725100896081, 0.9890614076352138, 0.9870514336245985, 0.9862028226946711, 0.9831663138252043, 0.987156853530469, 0.986263018970965, 0.9851936453036765, 0.9842901897556118, 0.993102149924095, 0.7313654373061449, 0.7228692924911823, 0.7370472854687975, 0.5617624456486039, 0.7377347479951236, 0.32269764109092114, 0.6639587381051739, 0.730398674505798, 0.706456153956454, 0.16667754540152324, 0.22049917473770908, 0.21937776221407157, 0.33474524665106364, 0.20571454970143777, 0.20216085568418674, 0.23241805095425505, 0.1753368776308878, 0.8589178697482052, 0.24313704171544792, 0.245231790667099, 0.25748057717962014, 0.21924330739280928, 0.24384973938738763, 0.23042721845899516, 0.1302421320148407, 0.13376855485452488, 0.24801497676800366, 0.23525187223741928, 0.10930082118265216, 0.2517737529176888, 0.30322798305145415, 0.2553056959999921, 0.28758746979747385, 0.24512717063675105, 0.2778549576987027, 0.2868011140603982, 0.02284198723796471, 9.999999999998899e-05, 0.08086642513429088, 9.999999999998899e-05, 0.0002861666968417831, 9.999999999998899e-05, 0.00304226147960851, 0.00526113730236033, 9.999999999998899e-05, 0.08226221994852678, 0.07977597001953896, 0.10303524925439211, 0.12298190565714684, 0.06242923868760897, 0.053478152238370935, 0.09163765261516932, 0.10444249241597259, 0.09420813346335877, 0.024549276135987785, 0.17982768211749023, 0.047623789737547884, 0.14150347289952625, 0.2771532768001628, 0.10401457369696887, 0.09863101790630213, 0.1018858390264239, 0.10149120584976334, 0.03708018727002904, 0.046349585146973515, 0.042606484299402614, 0.037438988557552344, 0.13100204080985334, 0.21759191632860275, 0.08991374378574202, 0.1700524527093321, 0.08292013255827801, 0.5759783524173805, 0.5585875438953836, 0.5493527558948417, 0.6121074271732011, 0.5653927012296482, 0.5899413133323121, 0.5784253099168033, 0.617682426213765, 0.5922255203522778, 0.13137120891522913, 0.1244866935865181, 0.10098345034031497, 0.13702115867906617, 0.0851450394200236, 0.12462524300491928, 0.11900825930550041, 0.1172559116882218, 0.12674491994087034, 0.27349370009662766, 0.16273323507671322, 0.20581822460945765, 0.219462691317858, 0.15945157234305574, 0.1870495074213816, 0.1647747049112962, 0.21590779759299106, 0.2586386952640537, 0.24266238994689515, 0.5376735640258021, 0.4568506134429774, 0.33622299786931265, 0.22538587609478067, 0.4338995724895589, 0.4583692128289616, 0.6009333035594392, 0.5354851392477533, 0.2087300440383688, 0.273915289743879, 0.3257498472953989, 0.19504426212253645, 0.40826818369738505, 0.34533931743917146, 0.2554184677726825, 0.34980754102417644, 0.2331688336631259, 0.23489570135312177, 0.23216980546062993, 0.22618749095431223, 0.19112993978221526, 0.2297408779876584, 0.22263947591878608, 0.21778814914975086, 0.2023493223885494, 0.21311355554819789, 0.20846860710978476, 0.2246840187655007, 0.22136338681859347, 0.1914333164334927, 0.24158799640941042, 0.20765703991130913, 0.24591882585371871, 0.20701156814003674, 0.22122377670318571, 0.18671712830056097, 0.15095602586282963, 0.1607925346138077, 0.16543819654624203, 0.185415583290374, 0.1763959337047738, 0.13014032088438288, 0.19780573565315562, 0.17773477644655655, 0.20527325660265483, 0.6627181403499656, 0.8201124103614943, 0.20729722599488343, 0.7553775587511579, 0.2119797607674586, 0.21008302708909854, 0.6998783080872222, 0.1688122247456484, 0.19702158095899913, 0.18410123662246636, 0.1863585630400686, 0.21163975278661662, 0.1859022632616516, 0.20458870534643991, 0.1961861802155932, 0.19474738809071368, 0.20102048709709475, 0.09362212357107513, 0.11687642304833556, 0.09967335162862034, 0.088675704126008, 0.08107714979472713, 0.10269428794253166, 0.08924995352819665, 0.09242125765771614, 0.0953385594026307]}, "mutation_prompt": null}
{"id": "b74a8b0c-85a2-4506-8d8c-79565bb51e9c", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "2e9f9f73-ffe0-4a69-9579-968669d349cc", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification with Gaussian perturbation\n                            variation = np.random.normal(0, 0.05, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Improve local search by introducing Gaussian perturbation instead of uniform for refinement.", "configspace": "", "generation": 80, "fitness": 0.3214677252756986, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.890049525937057, 0.8981225312967049, 0.8916943756730935, 0.8829785760915206, 0.8347076978471535, 0.8932843186168166, 0.8920504944778396, 0.8874529965038461, 0.8862714733079066, 0.7700545984584166, 0.7386318765585752, 0.7073976984439339, 0.7470583729772264, 0.7801924571955348, 0.769370192650659, 0.7445451708123046, 0.7813139295968632, 0.05715380607345455, 0.6904547645790071, 0.12944910331364923, 0.1255788080127832, 0.15813287867251025, 0.07654773580700402, 0.12675426304912885, 0.1330760534421117, 0.12450974994289987, 0.1398191948220674, 0.08369155879941814, 0.14980440509954607, 0.1323925362172198, 0.11145321017634147, 0.09451839916895355, 0.1209469221152043, 0.11262515300478082, 0.11229176710332833, 0.10049689330430933, 0.989190186615313, 0.9897478297849105, 0.988300786958181, 0.9813432346029337, 0.993039719003633, 0.9869945822881824, 0.978556801399172, 0.9887011647283911, 0.9865697677737961, 0.7680391391643422, 0.7303689440282398, 0.7621651721067491, 0.7388213879862358, 0.7264420137446499, 0.7509684306032616, 0.5983649610173837, 0.6782238197385168, 0.7709946854609844, 0.3774106074730684, 0.3775592920546552, 0.382189690140614, 0.36887573773633453, 0.3664758471466981, 0.19242415691580195, 0.12341713296025592, 0.235950229146072, 0.23511538509523933, 0.1997477958647823, 0.24383341690308802, 0.3039394877094357, 0.2507002353615949, 0.13355836617359818, 0.24177536201504346, 0.21915383297086133, 0.24087837301957749, 0.1274894077135974, 0.24061155701620862, 0.24504510293810033, 0.2586037617855915, 0.13234768284959886, 0.19166638531854274, 0.2608167224936828, 0.10445274370264401, 0.2539235166200112, 0.1278670721053612, 9.999999999998899e-05, 9.999999999998899e-05, 0.08738897016411973, 0.10422136291176154, 9.999999999998899e-05, 0.09280405396238134, 0.0001609799751464136, 0.0027031037455946816, 0.037708929558220694, 0.10328842784825343, 0.05259041425767341, 0.1052269163909203, 0.05338939215712668, 0.05730884084631782, 0.09187181910578002, 0.04786646422109919, 0.02184567787740055, 0.05014715839184425, 0.03753678741987332, 0.0353340141244991, 0.06564699959068254, 0.07917490275592887, 0.09615920778043097, 0.11596757580971229, 0.102021040948436, 0.07509670246991895, 0.24492027041237907, 0.2021873613797356, 0.04341417093371969, 0.23988818872931383, 0.06185402421612196, 0.0386754258547386, 0.16274282401531348, 0.056982231667965455, 0.05687048791993765, 0.08242874723242544, 0.5750153702961304, 0.54901461843586, 0.5641997367405134, 0.5554929219704876, 0.5857753985891678, 0.5542769176735167, 0.6008812463050377, 0.6181194214596224, 0.5465967101557576, 0.11874127298811987, 0.09995063999219378, 0.10899742889997155, 0.12534058420421856, 0.10664489699371771, 0.13178228387005797, 0.15196462715597914, 0.165289210302207, 0.1649710566761563, 0.26353090784271593, 0.19811446359915952, 0.21830690646510498, 0.21195537094183248, 0.30975542592716754, 0.17952946084332144, 0.19438968316020333, 0.20185604152408765, 0.3097994047807169, 0.45627859153857, 0.4618565176254119, 0.5015819562885755, 0.45206055400369016, 0.3447519646354682, 0.5647488147482804, 0.6018543694670162, 0.5699475607846203, 0.6671014015485582, 0.16814502246871543, 0.25465876166950185, 0.27564403686108996, 0.24007325108300015, 0.19084287952819967, 0.28414445336874083, 0.293148083647389, 0.3904528181310447, 0.2238950433575867, 0.21568027362872444, 0.23265393372008691, 0.21960254949214375, 0.1873021184047191, 0.20829203887147685, 0.2078060261581529, 0.21855045410089302, 0.19467977591454189, 0.2090587614771443, 0.18042379415373822, 0.202589672773265, 0.21854360736378875, 0.20328097349953134, 0.802469169954159, 0.17561289330621843, 0.21843245781635912, 0.2062455982275615, 0.237779416971577, 0.17443911938613021, 0.20941829844737603, 0.12514401411211296, 0.1758108619419787, 0.18741841244107416, 0.9055911099321738, 0.15980493034679533, 0.2074303910758446, 0.8984367731791589, 0.15450238565452323, 0.16706743225489062, 0.39999259028993217, 0.21188271604070674, 0.6095598570587559, 0.7090711805200456, 0.15473110357575914, 0.2118653346532391, 0.15543129219443907, 0.21509930944782352, 0.19773467154718483, 0.18153359359211807, 0.18484563914111585, 0.19108452972939594, 0.21759304616710762, 0.18273091463354207, 0.17987023262894275, 0.19052962587765865, 0.08740988146257678, 0.1082292360350462, 0.10049086023131748, 0.11363911136138927, 0.09560550500029819, 0.09671487342131169, 0.09038627913621711, 0.08536630777745946, 0.08682714281400916]}, "mutation_prompt": null}
{"id": "932110cb-3fb9-48db-8619-cba768c2172d", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "a411818b-62ca-4ec8-9b0f-aa87a828503e", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            # Mutation-based local search\n            if np.random.rand() < 0.1:  # Mutation chance\n                mutation_vector = np.random.normal(0, 0.1, self.dim)\n                trial = np.clip(trial + mutation_vector, self.lower_bound, self.upper_bound)\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce a mutation-based local search phase during the differential evolution process to enhance diversity.", "configspace": "", "generation": 82, "fitness": 0.3216067454843394, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8920837136193718, 0.872608244787438, 0.9058639181274821, 0.8885675986634873, 0.8843071578697924, 0.8902835690366222, 0.8963831042915569, 0.894124938730256, 0.8606643795215086, 0.7819498717413919, 0.6741036206543805, 0.7373674047476939, 0.7589998430463598, 0.7705828312460589, 0.7463554261042233, 0.7374147467479596, 0.7650419137973763, 0.05835295550493158, 0.14083961773752873, 0.12401169491860597, 0.151073681019524, 0.1165783982077121, 0.1311147136195232, 0.17458706880104768, 0.1305523502056416, 0.1542990540280933, 0.18203908711351724, 0.11377899430049132, 0.1278810880144129, 0.11184115344021461, 0.1270706562383217, 0.10491129513560149, 0.1246536220209431, 0.10630314657780127, 0.10628943057272466, 0.1304791215607154, 0.9861139054610704, 0.9898734963027812, 0.9897892585399073, 0.9817027737026931, 0.9953242075024459, 0.9810124813188289, 0.9865126955570475, 0.9868578196369542, 0.9906630061205799, 0.7498896397139294, 0.6823832497272158, 0.7900603651123607, 0.7456191676660737, 0.7461138055701211, 0.7660373052454297, 0.711489833981499, 0.7717373241562029, 0.7192724716983967, 0.22235756578488075, 0.16991813699398228, 0.3596676089848584, 0.21087780581546645, 0.19182327685182654, 0.21025617861832002, 0.3895384073975613, 0.35306619632958114, 0.8660237027258919, 0.24335360157895525, 0.27617204770489523, 0.2501501027382784, 0.23989167636129816, 0.23523969997352012, 0.2479864067333052, 0.2501523242101614, 0.1328541121127058, 0.2448830264438866, 0.23480038630753397, 0.24842857644885585, 0.26329016161272667, 0.23490939356856289, 0.11224631717044775, 0.2283236540595156, 0.24741364249965525, 0.2503961569812042, 0.1285070667206053, 0.08195123570314444, 0.0030402035717701503, 0.14805603756112728, 9.999999999998899e-05, 0.04242952115839527, 9.999999999998899e-05, 0.0015412295775014684, 9.999999999998899e-05, 0.04007580360463603, 0.06504064094018991, 0.03825666510777048, 0.0827895867327969, 0.2166301391257217, 0.08803510755748334, 0.06440468014481504, 0.030517662270843182, 0.11933113565392017, 0.11806218781404076, 0.050548157793644743, 0.4954151370491887, 0.049196634151448926, 0.07794701755275268, 0.08214074051633358, 0.105776330490442, 0.0983595095550781, 0.11186609243764689, 0.22277074927971718, 0.05611895057449967, 0.06807997708690705, 0.24442897697082866, 0.17410732309923826, 0.053599542859304905, 0.1281357856565053, 0.05809037965198893, 0.04894806502735005, 0.05675244041594574, 0.6092912644016235, 0.5356859178049984, 0.5559344309133245, 0.5654163570716739, 0.5472521338671715, 0.5810536974061525, 0.5838116645226481, 0.5710096294653204, 0.5824039336329769, 0.1321197940686878, 0.1173365647633291, 0.07671446222859157, 0.10694090003553425, 0.12334514483111414, 0.14532487617145984, 0.10459258276756733, 0.10656405216184217, 0.08543207361392291, 0.32627189936550394, 0.1922424899111117, 0.21334650227076712, 0.1951389098022901, 0.2111479863247232, 0.1742508985869694, 0.20899232163690895, 0.1980931676505857, 0.31916739950886797, 0.21489814855469458, 0.3623453577965512, 0.3104822937067686, 0.3780820915672298, 0.21467485454383606, 0.3468363706473385, 0.5404600216850908, 0.587970259688242, 0.4243212602990789, 0.24855183357683563, 0.3409043698020059, 0.36283717256290426, 0.17703663657042068, 0.21141786846551835, 0.2060823701077571, 0.28166822020734994, 0.16994482151490575, 0.21577181884980612, 0.24165287554444714, 0.18295595982950352, 0.2316026976749641, 0.21480752343513076, 0.24439618256076534, 0.1997679653513591, 0.21554493974322586, 0.21041302719879285, 0.20480427802365242, 0.22129251452494247, 0.19211090448174073, 0.23985377381883788, 0.7214475022630016, 0.22168313001316842, 0.20807879537263174, 0.18239134183068684, 0.21914549392379978, 0.1955258748605132, 0.19589488716186676, 0.8463844571915904, 0.1647763766551883, 0.8466893000578777, 0.17601225004762966, 0.16656683204895617, 0.8583167689322306, 0.8897069341511833, 0.14217473653803003, 0.11262482370235716, 0.16667898879437415, 0.16783868886486286, 0.1671438225520302, 0.21034042070293113, 0.16387676366259896, 0.797961058878105, 0.15343688292984792, 0.206547010839764, 0.21354257547489797, 0.19415182869483805, 0.20074155209167677, 0.19163022963521348, 0.19324947924075375, 0.19332779732127037, 0.18741998885622513, 0.1983967580077719, 0.19323663547082237, 0.09440014858381729, 0.08901256295746696, 0.08946113150896473, 0.09210436513230702, 0.10149897918921347, 0.11213118000081979, 0.09207491191487516, 0.08787262797216988, 0.090108565284307]}, "mutation_prompt": null}
{"id": "7b15462f-6efe-4352-afbb-a358bd5b56c6", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n        self.stagnation_counter = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        self.stagnation_counter = 0  # Reset stagnation counter\n                        for _ in range(2):  # Local search phase\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n                else:\n                    self.stagnation_counter += 1\n                    if self.stagnation_counter > (self.budget * 0.01):  # Reinitialize particles\n                        self.swarm[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        self.stagnation_counter = 0\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance diversity and convergence by introducing random reinitialization of particles when stagnation is detected.", "configspace": "", "generation": 83, "fitness": 0.31057825004818485, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8794530115405409, 0.8569092049571174, 0.8932457066149855, 0.8692375871480307, 0.8710627879204025, 0.8912272156115116, 0.8855820329235174, 0.8777736599204465, 0.8815764234754754, 0.7575765329773845, 0.717224406995125, 0.722598225090022, 0.7308416035852854, 0.6402387983562889, 0.7317806640955773, 0.7378230182613994, 0.05304025085479658, 0.7876048910075162, 0.15558643842221387, 0.14876694167738602, 0.3498324451666541, 0.1469832167909232, 0.07536218273597972, 0.17561531763593086, 0.14899828570380924, 0.11789866490542422, 0.07109886798557674, 0.1280343403512224, 0.12950267678066008, 0.10658404866034021, 0.1366628656375527, 0.1366120617552664, 0.1326143515525844, 0.14386870859386858, 0.1421771788101125, 0.10013743052110335, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7067161611318253, 0.6681768041050054, 0.26475247153082204, 0.6956774965808642, 0.1583171826347074, 0.6956997716590726, 0.6520044192995068, 0.6316210642886091, 0.6660576822698665, 0.6139137779642463, 0.24654856425316773, 0.34260162560803586, 0.2686416817100219, 0.368782117623243, 0.27613064519165276, 0.20953365781046396, 0.9022732299321677, 0.35027821136238213, 0.24693056722695794, 0.20713576010016543, 0.1298547315590567, 0.1337802912580377, 0.22856710081752307, 0.12979109793535626, 0.21924458272147607, 0.22795880196777896, 0.2205209690940726, 0.23811658222003895, 0.22721179341574704, 0.23036240545629716, 0.24038882855150767, 0.25596485142040915, 0.2845472896431753, 0.10079126800220328, 0.24127926559877866, 0.2531129170923878, 9.999999999998899e-05, 0.0001193857167610668, 0.0007617266589382554, 9.999999999998899e-05, 9.999999999998899e-05, 0.059240097817207626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06493688780619722, 0.03885486577553077, 0.12518850188832786, 0.056586779821805044, 0.06434991281175573, 0.06438640577579735, 0.039352102676359246, 0.020959794114625785, 0.0989633065302209, 0.09985797262206364, 0.028592115656070338, 0.03709025352128559, 0.07796567820782241, 0.17243129920000888, 0.07809620194706857, 0.08993914499628519, 0.23341498569443364, 0.09974827550464183, 0.04472332243196164, 0.04251596621748033, 0.0417391715150518, 0.0869854587757265, 0.06369903257966403, 0.11052121404593473, 0.08161661616720883, 0.06945928195031015, 0.08239269434648744, 0.5415215554314462, 0.5640328836497128, 0.5140793507009236, 0.5620869217421856, 0.5456986663770813, 0.5365100741843785, 0.5476240897832461, 0.5447510211368506, 0.6115143624500772, 0.13759092311892995, 0.11873126137198964, 0.119134110790456, 0.13742947720515009, 0.11272254564760864, 0.13781045561395533, 0.08116980573635268, 0.11467367700040543, 0.0976988847581961, 0.39791386875439827, 0.23528673545183876, 0.17113458488791822, 0.2356431269021566, 0.23247040583061085, 0.2850741255500484, 0.2409220878335715, 0.16108849822693116, 0.18903305471509757, 0.2425719485754998, 0.31781253319324587, 0.5278989602180699, 0.21371275119164945, 0.4821190384649189, 0.27884549005025705, 0.5082226335754643, 0.21653520628040146, 0.5599066736439589, 0.2718374699751389, 0.3051512104869055, 0.21799805639085257, 0.20942718108516922, 0.3500983300272603, 0.28665608676478516, 0.40076653702490117, 0.2519060692581152, 0.2321453033012132, 0.233194342044451, 0.20930027004967733, 0.2154311440823904, 0.2721656530559535, 0.20358724573384723, 0.22914001001106343, 0.20082475802637678, 0.2137909353147185, 0.19039841134004365, 0.19374447178190013, 0.2051164383140609, 0.20197954012436548, 0.21747064585503406, 0.21971127628723697, 0.19307091140303023, 0.24018673928975542, 0.20738236874313853, 0.210255672314124, 0.14536235475824966, 0.16378110585615102, 0.17654157558503025, 0.1765935757136543, 0.16589412180106633, 0.8957749375024733, 0.1849347700170093, 0.9047811596929114, 0.1661043511394994, 0.6015786481404123, 0.2086580244365609, 0.16748159311887834, 0.2082596488512538, 0.6267479845785684, 0.7039744861962679, 0.1673244135673766, 0.7808041200621436, 0.16840605315204993, 0.19378958180824157, 0.19022579480007318, 0.19355191822943685, 0.1989417974855031, 0.19125099456425076, 0.20294910822397083, 0.2250103126231151, 0.18624821641686307, 0.1997299133907704, 0.09774797240586208, 0.11389627059994745, 0.10091194555521721, 0.1051678619039027, 0.07871759130688549, 0.0840239110754879, 0.0953107574430021, 0.09578914776753578, 0.0906438091235866]}, "mutation_prompt": null}
{"id": "c94d0404-db90-4189-96ba-ac893f06794d", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "5eeec2cf-4a25-4667-809b-9ae4c83e1fbe", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "c7daf305-dad8-498f-9b43-9120b242e078", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f_initial = 0.8\n        self.f = self.f_initial\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n            self.f = self.f_initial * (0.9 + 0.1 * np.sin(np.pi * progress))  # Variable mutation scaling\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce variable mutation scaling in DE to enhance exploration-exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.3090065098897719, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.885040621560799, 0.8834267533110952, 0.8926493733774464, 0.8799763584917585, 0.8939447734726739, 0.8894591132225108, 0.8827117702579546, 0.8737042672584403, 0.8884368922013195, 0.7578849179732812, 0.7228893981079031, 0.7711491194615999, 0.7526626255087994, 0.7915198426829062, 0.7658063508674823, 0.6197576190702068, 0.017973960984146053, 0.762016803499521, 0.14202265314239393, 0.1290153930382517, 0.15922000544309833, 0.16819577721870027, 0.07340421443061818, 0.1299057444504369, 0.17761923168501403, 0.12965256778026613, 0.14016376600243963, 0.09838276670789581, 0.15127426345467632, 0.12094764225060883, 0.09416656682679381, 0.13192081783027043, 0.10763148340119655, 0.12742937722813474, 0.11266593549483295, 0.13670227210048236, 0.9847936236736947, 0.9854272417309735, 0.9801660340387922, 0.9867556101077702, 0.993482040185221, 0.9862796833959296, 0.9877317392632319, 0.9870618318373032, 0.9909533981572075, 0.7597548131119892, 0.7726907009761936, 0.7376869018255012, 0.7151728193953589, 0.726983220097458, 0.6239818898166769, 0.7609255669415622, 0.7043783214810952, 0.7514187329956505, 0.21130292934536943, 0.22053353208772708, 0.22428977526467875, 0.2120684224033449, 0.26871612659416366, 0.20374436063017598, 0.13925117967959, 0.23348508809088064, 0.38029337730271406, 0.26451727947582415, 0.23004505872861214, 0.23451649553619058, 0.13111962589956694, 0.24610686330897746, 0.13055764051519259, 0.2384707225543441, 0.13190429588005104, 0.2509259654097483, 0.24226098558485332, 0.2347011778479, 0.24808183573618048, 0.1961269589593715, 0.1822707169332618, 0.31716636394328956, 0.1287119278989739, 0.21923754612360025, 0.2518680274153686, 0.0003776855087881392, 0.004649317938645092, 0.044796696970052285, 9.999999999998899e-05, 9.999999999998899e-05, 0.04693910182238048, 0.06258564145199796, 0.001389097812071638, 9.999999999998899e-05, 0.043875833185423985, 0.142409330176961, 0.0925326319262425, 0.024844080752934095, 0.07461157265905471, 0.06090574211147892, 0.11105056984226047, 0.04733517505430285, 0.09818480847187949, 0.32701637919243687, 0.035341545921728224, 0.03482943885335554, 0.07655629638548778, 0.10602178056222966, 0.09720480878697813, 0.10549475437164924, 0.24991136803861358, 0.0713163279709399, 0.04358699916183362, 0.09371495419797715, 0.02772295332935648, 0.19887402330038118, 0.1021270631804202, 0.08533837017632373, 0.30008733641019103, 0.049114999623751876, 0.1528856778787755, 0.5736544829064472, 0.5311030836488057, 0.5461601599292399, 0.566707089509042, 0.606298652044019, 0.6638464207948012, 0.5778185857275373, 0.6243182989855652, 0.5858249315346521, 0.10339075926276586, 0.06207345838198686, 0.08152775739070073, 0.14688183334706117, 0.1552967523169746, 0.09171333403486603, 0.1111110524236536, 0.1308197494686114, 0.15708898888868916, 0.20628875533463653, 0.27478948803809267, 0.3267825999794852, 0.23105400420643185, 0.15142044556559686, 0.1695510955113143, 0.17917875404736827, 0.18223955249821244, 0.19314223241299622, 0.5200617321414331, 0.25286572405224406, 0.4981383364228176, 0.470906929943391, 0.4554594126524233, 0.3790076876544669, 0.28595647789461864, 0.17529536955050284, 0.5296369647741384, 0.2729845307328477, 0.24476764893686564, 0.2490477755606374, 0.19801553640541347, 0.2542385079402548, 0.26487067322468283, 0.3167175163994833, 0.17398851146664707, 0.21107797876736178, 0.24826107600268743, 0.22429721091142618, 0.24362122984923706, 0.20367487680013752, 0.2215243959425096, 0.21410880813024047, 0.22309946824379345, 0.20525495284108242, 0.21841672718616367, 0.21710055113993765, 0.24373479114148655, 0.19662392028428277, 0.2064923513820427, 0.16911495531172893, 0.22492735974296485, 0.19403046536801194, 0.22387319463392719, 0.19732663871575928, 0.18558679587919868, 0.17193751891560316, 0.17645382686039213, 0.16633505128394677, 0.1454790590527415, 0.9010205825771066, 0.8975389354783417, 0.12652148193623647, 0.1706510417125059, 0.7351171093112812, 0.12565716953720873, 0.7430723001226992, 0.20911569144140363, 0.10972598403114386, 0.153684629232979, 0.21281808247008294, 0.12716764243129453, 0.1665178846702554, 0.21050057680123901, 0.20942005398310815, 0.18779001279015461, 0.20974285412345084, 0.19143344597832113, 0.22077631939542275, 0.18417018261755624, 0.21266395966203666, 0.18387273060077858, 0.0848968448345595, 0.10374309934274972, 0.10501590633262403, 0.09206082896733603, 0.09369140961164557, 0.09243091727889641, 0.09819367604036855, 0.09314933362211908, 0.10566873992233539]}, "mutation_prompt": null}
{"id": "1dd66d2a-a58b-4b37-932e-699343ad1144", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "2d35e21c-242d-465a-9e5b-8dd58628dcd8", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Enhance global convergence by introducing adaptive weight adjustment based on func_evals progress.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8708248634056259, 0.8757755407180098, 0.8969563941360151, 0.8874770402857083, 0.8726362288609658, 0.7633669574323855, 0.7346340980167152, 0.7448055580346481, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7670167498535639, 0.7856123883226533, 0.6650131313352471, 0.7494064333309662, 0.33625181238584423, 0.7387000514127161, 0.7307021270099281, 0.6758991590933641, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.1483570356005086, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.25581157206460403, 0.2567310946951594, 0.1339964074018215, 0.2520099655871212, 0.2544721695639768, 0.1325615408917311, 0.24222328537352178, 0.2437418772532749, 0.13008247321200106, 0.22795197765095077, 0.23695229487661906, 0.34816979059652997, 0.28105808551610567, 0.2564876665938316, 0.10246095747001582, 0.2464544860342418, 0.24101521789684444, 0.03446515139620665, 0.002783339385731942, 0.020982522528104508, 0.03539094820494648, 9.999999999998899e-05, 0.059265005126531656, 0.00010348159132123058, 9.999999999998899e-05, 0.0011939935255695922, 0.08423431517187363, 0.05844268434715394, 0.15145931397501222, 0.01318081861656395, 0.029464350469353806, 0.06881579657210135, 0.057580241039387525, 0.022450028614885542, 0.06400055375300395, 0.0685050876365072, 0.03560279871297467, 0.11509229045039593, 0.07715451903215431, 0.16056994158649018, 0.07690411856740997, 0.10570426912304809, 0.248041811712581, 0.0731925498318875, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.05304418835109992, 0.11687108796291523, 0.08233355887168237, 0.059591475145035155, 0.0822835362793114, 0.553656102104501, 0.5756549315377582, 0.5496358255240157, 0.5919253515096359, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.23958949154787867, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.18618465782410398, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37198285438306333, 0.4138567079190454, 0.3498048979267976, 0.2873006578077808, 0.45806898129418794, 0.546928410495917, 0.1558664746264049, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625025009985893, 0.3621308081361877, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.42432691875395356, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7659743161615168, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281544362985772, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.1743753303728971, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.2087807722710633, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729622383605, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "ac1769d8-fb8b-4ccd-a339-f586f8bddb23", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutation_vector = np.random.normal(scale=0.1, size=self.dim)  # Stochastic perturbation\n            mutant = np.clip(a + self.f * (b - c) + mutation_vector, self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce stochastic perturbations in DE mutation strategy to enhance exploration while maintaining convergence.", "configspace": "", "generation": 89, "fitness": 0.29695698192417974, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.8775504383145737, 0.8837612342354583, 0.8837662361683567, 0.8868610396942808, 0.8843766204325155, 0.8843534387238684, 0.8890607810711004, 0.8791427732140366, 0.892442918439553, 0.7183088879417794, 0.7730311580731326, 0.6925035582181769, 0.4103179354851695, 0.717658027597516, 0.5585765029276053, 0.6267195081806138, 0.7921422895398056, 0.29028400723402026, 0.1535831223167774, 0.7387793079892966, 0.14856302597686677, 0.13615431149824786, 0.15057158516224134, 0.12635211191705653, 0.14036078300976984, 0.11570183186581329, 0.17218059859506452, 0.08581778253092431, 0.15028179338822523, 0.11264409200881476, 0.12159198845296693, 0.11652285426402398, 0.11603549876277552, 0.13572327806005813, 0.10884047351313053, 0.17248309521247918, 0.984967919455382, 0.9895646031263946, 0.9856143740999119, 0.9821449643730618, 0.9841556166512919, 0.9883242110901098, 0.9864541600268472, 0.9897881388154763, 0.9898149629143611, 0.6214128817648967, 0.7238330143732985, 0.6258343851802732, 0.6582376860671032, 0.4068641303885162, 0.500623680084628, 0.725006443042255, 0.7484288652635862, 0.45864056752734605, 0.21002818463756312, 0.5159340457824241, 0.1711426222444663, 0.193070295068262, 0.21072399739286352, 0.20724353900507675, 0.17539957310467957, 0.8701493706777695, 0.1471434074675808, 0.12912729631597508, 0.21394739996417844, 0.17122197823647234, 0.09916810440807222, 0.12754117118437103, 0.17129384360765343, 0.18746067543571998, 0.20299060895650256, 0.3668799279837701, 0.11900281963104353, 0.12253697776014472, 0.20552461619181694, 0.12610149644489976, 0.15671405651246018, 0.2950489209801207, 0.24839778820951108, 0.2427695290662144, 0.23356188135577172, 0.08125874518070708, 9.999999999998899e-05, 9.999999999998899e-05, 0.03502719034999058, 9.999999999998899e-05, 0.0765969221448275, 0.00015806377337490574, 9.999999999998899e-05, 9.999999999998899e-05, 0.0710286663594839, 0.09417673797726767, 0.06275780234541273, 0.05770803815773107, 0.01236937915370695, 0.04285191670984145, 0.05936843739237718, 0.0658250693373611, 0.007304961922101061, 0.03627902373290437, 0.05339840320031364, 0.10258644253957339, 0.07825724819037694, 0.09621960695433318, 0.09523809725256671, 0.09796989505694598, 0.07255608442815797, 0.10155859726610639, 0.17117014695580912, 0.2369518873206512, 0.05503100820762119, 0.13182418750979719, 0.10363626239667412, 0.06791866327133389, 0.08468947580447717, 0.05688628941143492, 0.10083457485322234, 0.5014241953329185, 0.49497252128772073, 0.5478666452970555, 0.5379431200608512, 0.5163930004075834, 0.4929567921150648, 0.5585034862961884, 0.5470316537978757, 0.5832177931051858, 0.1062218865220832, 0.12889531849974867, 0.12302482977239959, 0.10867910327448538, 0.12796273934774494, 0.15383178814301768, 0.15702382066285703, 0.1020924992776665, 0.08649004957985884, 0.3019189412149639, 0.18814846619459324, 0.30826175350581086, 0.18253249591018628, 0.2647493947356421, 0.20092041651652937, 0.14769150687215427, 0.23616510312369776, 0.2281219622760302, 0.30097891168175195, 0.2880566236479404, 0.35669319194074445, 0.37313945039596574, 0.2178420900843142, 0.3940541132854799, 0.2988604534042767, 0.26677915065614355, 0.5600664678388176, 0.2506067652871077, 0.22888338139900233, 0.13871158672830042, 0.2758350564425882, 0.19780848466773582, 0.22849733229532743, 0.21235651588146265, 0.25442199269889854, 0.09230258306767558, 0.23308805001954536, 0.23035769601605338, 0.19124252457552215, 0.20813325789115733, 0.2084304468673287, 0.21872664818640064, 0.25180607297547886, 0.22204695348779036, 0.21114033218756656, 0.24254391851277357, 0.2106293389089674, 0.220744594274358, 0.22472264158034572, 0.7183353241509866, 0.19607152402188854, 0.21810743301256874, 0.24256182579324226, 0.2067335678492731, 0.19657458176696996, 0.9098225351049142, 0.1604327353127314, 0.17793498189616952, 0.20933445706594744, 0.1985667995014757, 0.1993278205740744, 0.8692443401450559, 0.17152578997151213, 0.15291820801745237, 0.16824162054463976, 0.20864870736518004, 0.168138712157066, 0.20824696734185033, 0.20901426632543474, 0.21145393670102985, 0.15451427159356268, 0.15543619469292158, 0.183880871098549, 0.23023907675361865, 0.18394681674410396, 0.19085225347133306, 0.2143725719973354, 0.2179941792565585, 0.19242748993566505, 0.199336578170224, 0.21987289848939728, 0.07760280719062518, 0.09024340315493262, 0.08638106295370251, 0.10164808525014046, 0.0975260136581323, 0.0977654689231986, 0.08918028683704848, 0.10607787849418104, 0.08680839527869777]}, "mutation_prompt": null}
{"id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 90, "fitness": 0.3389459528587487, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.30.", "error": "", "parent_id": "85ecb6c6-28fb-417c-a548-3e30f63962f9", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "aaa947ea-522f-4a3f-993e-d7dac097a0e7", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            perturbation = np.random.normal(0, 0.1, self.dim)  # Stochastic perturbation\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social + perturbation\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Implement a stochastic perturbation mechanism during velocity update to enhance exploration.", "configspace": "", "generation": 91, "fitness": 0.2174912351064803, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.4256828843522188, 0.4148909498044556, 0.4319670052562634, 0.41581292767210265, 0.3906263389455348, 0.41335829925983403, 0.40973865444235336, 0.4326257245319527, 0.41481872063717506, 0.022354738779320038, 0.026952121288516206, 0.0398617346031519, 0.002396341257171697, 0.04538729660565188, 0.058373947193398945, 0.04107902146935316, 0.03505335780128371, 0.01971159254958621, 0.1152272885534752, 0.11239802345770655, 0.09607012203444554, 0.07000950195876177, 0.10775120055762777, 0.10887343827506701, 0.12612156777063666, 0.10671358912292073, 0.10833182053592882, 0.09344029019278277, 0.1079474876779708, 0.09824445953709815, 0.10564526377598216, 0.10953624256796246, 0.12724709950345392, 0.09052580050323145, 0.08612514350758504, 0.10274115038168707, 0.9882226644350723, 0.989082036605801, 0.9860800248239737, 0.9822440327737358, 0.9924718665382823, 0.9852693232732888, 0.9855877113517958, 0.9892485459668511, 0.9861680833033207, 0.26552293670153704, 0.28383331657179, 0.2716987988453342, 0.2806442855648523, 0.27737474342310087, 0.2642903395563424, 0.3084063732116893, 0.2540790309209423, 0.25359691496144665, 0.30649489484756187, 0.31956719936350264, 0.30823152080761973, 0.15960996043624232, 0.24309061593137904, 0.28595264361186257, 0.24245297284494438, 0.3195141513426074, 0.33701482519320247, 0.1564670881360638, 0.14937903074461978, 0.16949221535837478, 0.11497682040198831, 0.12416825047705715, 0.15307296103144075, 0.170191771318429, 0.14365008396630274, 0.149043757561798, 0.14635615829148685, 0.15466125209440273, 0.16628200383952385, 0.13405206941140935, 0.1522750557192203, 0.15984288446206663, 0.1494914697687485, 0.14964468032561384, 0.1208926009378174, 0.08029406590496635, 0.002898062200610396, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.048632945459010646, 9.999999999998899e-05, 9.999999999998899e-05, 0.07974052290470313, 0.09697298344130978, 0.07108607348711116, 0.02281709998032022, 0.011760619039220876, 0.01851698058674478, 0.11672708499332451, 0.018513866129901357, 0.08263420119770437, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07890396095842589, 0.04409886681734532, 0.09420319672029032, 0.06292428008359585, 0.062661092939025, 0.08910475494943526, 0.08663770886934341, 0.05311655558811634, 0.08825081594493478, 0.4011809414752293, 0.37642309673804064, 0.4107196370073689, 0.40834885261917864, 0.3680445941540049, 0.38406633543388824, 0.38326997935359053, 0.3657899613195593, 0.40028869519820387, 0.10624785173462492, 0.1061480250273995, 0.10615949812355485, 0.09811015505481191, 0.10266189194442576, 0.10869318309441056, 0.12190238910873619, 0.13795955732224374, 0.12460699816738474, 0.2570220808183965, 0.24344805874483244, 0.23195514974993703, 0.16968647415087323, 0.17171064758687404, 0.12996473729393565, 0.24573365099567768, 0.1861875275577427, 0.20034570337258328, 0.29443239895756124, 0.27108982897241163, 0.29087075520116523, 0.20384371059194983, 0.2884689024920313, 0.2757168046808218, 0.27693488530631605, 0.2653325680160583, 0.28265805320272364, 0.22374560813206823, 0.21257600320394887, 0.24926434034155132, 0.17843891004647017, 0.2104005636246934, 0.19842674999807153, 0.2281915094021837, 0.22230564447182866, 0.17595385118430784, 0.19473598529717984, 0.21637296666912442, 0.21094644197983337, 0.23378357260061888, 0.20050623655874122, 0.20596030948347255, 0.21563735546193052, 0.22080753749175297, 0.1942308024292987, 0.19902150503463445, 0.21744231007416648, 0.2072980344912584, 0.20579600945863363, 0.21425093849794474, 0.20115984800383024, 0.23656909215585842, 0.2279435236668197, 0.1961044361540849, 0.20864614492393363, 0.17071560732695912, 0.15332893438233897, 0.17830733152601774, 0.5828243338242738, 0.5726943552108525, 0.5971346883279244, 0.18591236470338468, 0.5801920152983868, 0.5381968330670432, 0.43193045290213006, 0.2097310418689491, 0.2063825635998202, 0.21002535010580525, 0.5894954253821314, 0.5515853875412069, 0.12675004780580623, 0.16818732238064915, 0.18046884332402768, 0.1899127268838251, 0.1814428368208001, 0.18561984824175748, 0.19043315538695227, 0.1807877460699745, 0.1900736296136435, 0.182052088897094, 0.19633282570031085, 0.0808669902925514, 0.11704728013120225, 0.0817557017426811, 0.08781632743590218, 0.0871377169156261, 0.08667249289531576, 0.08150117504247067, 0.09128167316529712, 0.07564300616631225]}, "mutation_prompt": null}
{"id": "d069bd0f-8e57-4cd0-9623-b4fd6bedaafb", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "821af82e-e0a8-453e-9c5b-85d93fd36e68", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "7e6f4f1b-552f-43fb-9073-f0c789289291", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr_initial = 0.9  # Initial crossover probability\n        self.cr = self.cr_initial\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n            self.cr = self.cr_initial * (1 - progress) + 0.7 * progress  # Dynamic crossover adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce dynamic crossover probability adjustment in DE based on progress for better exploration-exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.3302601087536453, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.877648512830044, 0.8803625088459752, 0.8828059195964244, 0.8973790905648935, 0.6784930614968913, 0.8701831417583464, 0.8966515698152857, 0.8827640360466252, 0.8717269039393943, 0.7986310112677071, 0.6622249209616258, 0.7561893955128975, 0.7221076844679012, 0.764701229030976, 0.7807526345086645, 0.7523939838073654, 0.7119673652423912, 0.7439574731374458, 0.10847069564323575, 0.1277876571605735, 0.14203053831639245, 0.12301025798731224, 0.07335296327147767, 0.06903657948732411, 0.1462008853411484, 0.15530043143158312, 0.11321581443335438, 0.10629510379706841, 0.11066297582238727, 0.11209305656554702, 0.028703833796098532, 0.12386150302353616, 0.6401165388218507, 0.13972385553619793, 0.11644642236128477, 0.11323981984697506, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7129165339654788, 0.7456495252923433, 0.724618228140165, 0.7214431862114459, 0.23270495865043184, 0.6872438325984477, 0.7461716165220696, 0.6091724152277409, 0.7430026240770844, 0.2192121898634658, 0.2262993875145911, 0.22083441344991883, 0.8833944812134432, 0.9013005283116283, 0.8761964949978097, 0.11943837396130852, 0.36073361303009877, 0.23305344939626582, 0.12496164239620944, 0.27061479057724935, 0.23741177470998698, 0.13424870556938728, 0.2508993125868312, 0.2447691816102362, 0.13266445677715888, 0.2369090093179268, 0.23222999086805407, 0.13040945873712262, 0.23918689770958046, 0.23156156249452464, 0.3684498605490223, 0.2795318816697261, 0.2547611476627114, 0.10144851685393164, 0.26226590247795944, 0.24424130884259276, 0.00016054721960168106, 0.049107862110597256, 0.06015147207660665, 0.00010964901058119203, 9.999999999998899e-05, 0.0587182766227925, 0.00021468340923203044, 9.999999999998899e-05, 0.0025075853626851385, 0.07217647142393746, 0.08253721294010152, 0.10004333339073201, 0.018000475952479555, 0.021805738010802656, 0.045369364211163554, 0.05620922868470857, 0.021336962375421042, 0.09050168598179376, 0.07457662420066213, 0.03548844625414316, 0.07877730177537556, 0.0772099972772543, 0.158501399893752, 0.07778426251068304, 0.10563533203612374, 0.28036148710003417, 0.07223242500422744, 0.04285094447162752, 0.036495319259878145, 0.041952856905387526, 0.06072555441429084, 0.053708659428305716, 0.12357036016033707, 0.08220575121852602, 0.06613737730621683, 0.08228042251308221, 0.6432116137220201, 0.5567993274777927, 0.5424215529298952, 0.5852722723409965, 0.5601637624454379, 0.6333951410880321, 0.5750890003275655, 0.6129152012569903, 0.6146005001685511, 0.13524251098835816, 0.10362894678938861, 0.08299507210369195, 0.13142365858330518, 0.12070709771277666, 0.12379049175371915, 0.06723192870605854, 0.7229997214714494, 0.11264904323214464, 0.5465783439608991, 0.23414932480634365, 0.19050085806482653, 0.2181669061470669, 0.2666383427242526, 0.22794972336205432, 0.16295778258683025, 0.20988975744511396, 0.16273392680215004, 0.4710427025981676, 0.3860706859858639, 0.4341176152105717, 0.3994792697699705, 0.28643757789140367, 0.30251359861783367, 0.5535216525833989, 0.5610482593877539, 0.5138122689005353, 0.4485926446251738, 0.25886625071550673, 0.23813380420693053, 0.16831315158302007, 0.31294195125302293, 0.20891434452171598, 0.26248501401004143, 0.2183257793210257, 0.30847114522232066, 0.2666227635440346, 0.2433507256381494, 0.2186132524211768, 0.18986057825641567, 0.1850096053030058, 0.22282633892500303, 0.3202623990911758, 0.21842241578336785, 0.1841327574831938, 0.20831914115161643, 0.19030791838997252, 0.19643470981455236, 0.2240834129717263, 0.21325428433769744, 0.2144544352783735, 0.1900835931789302, 0.2472104520851659, 0.20762548060840502, 0.15304411065005386, 0.16359966312810326, 0.1744853560123163, 0.17663936165712202, 0.20545426692614588, 0.8946789509388946, 0.7987115508955205, 0.14734593920059047, 0.8376476152660135, 0.5961751854799132, 0.16620456910771586, 0.16750529187881602, 0.20832144376373085, 0.7199399351294231, 0.7982828333265538, 0.1676523569967292, 0.7242267406350992, 0.16841410558152659, 0.1877549970236071, 0.2048192821574052, 0.17792770611387876, 0.1877441588430564, 0.17981662448236746, 0.18867610868591322, 0.1812846593558396, 0.19925199324292764, 0.19175496077700716, 0.0987486342926217, 0.10440652019310237, 0.09427965334991717, 0.1036595139786809, 0.12705897920075915, 0.10615309143403051, 0.08309545504967841, 0.10338542069007506, 0.09510981930450146]}, "mutation_prompt": null}
{"id": "5ea29e81-5a96-4725-a9bf-229083518300", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutation_scale = self.f * (1 - (self.func_evals / self.budget))  # Dynamic mutation scaling\n            mutant = np.clip(a + mutation_scale * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce dynamic mutation scaling in DE to better adapt exploration and exploitation phases.", "configspace": "", "generation": 95, "fitness": 0.31043608547472346, "feedback": "The algorithm PSO_DE_Optimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.28.", "error": "", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.8792429448263914, 0.8836899687869716, 0.8905610219025328, 0.8931366449471085, 0.8334499773584108, 0.8832302062419527, 0.8813066158742326, 0.895083412697638, 0.9024543532841552, 0.7720720797926958, 9.999999999998899e-05, 9.999999999998899e-05, 0.6852024488417171, 0.7816727594539181, 0.7679495541152042, 0.7532414798389265, 0.053665128171085597, 0.7700563031858705, 0.18015050880506478, 0.17589963006308296, 0.15140798300621505, 0.10986861445815976, 0.07289274245054334, 0.0642816677130944, 0.18224414701460467, 0.6993206692874427, 0.07243853797345379, 0.10298951390158473, 0.1229516616242472, 0.09397171546753669, 0.1238378897449236, 0.12568048239295715, 0.17353567552748406, 0.13908898877048392, 0.1080616278982176, 0.11641455484758967, 0.9822624453296741, 0.9854269754779112, 0.9859279650163176, 0.9867691128911427, 0.9934927256754976, 0.9861259470722423, 0.9857360920888296, 0.988480220930803, 0.9922174034931537, 0.773412079956606, 0.7401642318210293, 0.7932964926490064, 0.7579656860763557, 0.7564557857919987, 0.723828956755379, 0.7827534446827117, 0.6004761165201031, 0.7670716348746718, 0.16748820283306542, 0.37504700057808904, 0.2314766010509689, 0.191561482707706, 0.3797646024083199, 0.21965192506029907, 0.11658263413145464, 0.22524727179620674, 0.2341725593858457, 0.2627732853965018, 0.24954362612422698, 0.24617304630571857, 0.13136594718312922, 0.24272590295495866, 0.25689213898707686, 0.26190514693683764, 0.21259270088512006, 0.20677679522670545, 0.13068625991688365, 0.23324543704749923, 0.23754966114592524, 0.28359141796971143, 0.28310192195863426, 0.2635499442647702, 9.999999999998899e-05, 0.12923971695555936, 0.24877030287905755, 0.0021615678693457374, 0.06108922668283123, 0.05472645941903409, 0.04001755734302459, 9.999999999998899e-05, 0.045090016532066124, 0.001331927837623148, 9.999999999998899e-05, 9.999999999998899e-05, 0.07035477596517625, 0.08927016614185646, 0.0751345238026151, 0.0157248113791707, 0.01879169383766366, 0.015865895921678752, 0.055846004035913555, 0.02239922157051788, 0.09342601274389306, 0.09167398279394545, 0.03480053839634678, 0.14447549774106427, 0.08031683799555389, 0.16318681204660446, 0.0781027390977086, 0.101054100588586, 0.21446841261659277, 0.1079199028153709, 0.04329823475823358, 0.05269374637878499, 0.04179095218742024, 0.09113093910628889, 0.03827377425326506, 0.20421815811125954, 0.08593509373824759, 0.05657225557420098, 0.08182195526817015, 0.5928357580348208, 0.5497984634767471, 0.6066481056154802, 0.5760807590836399, 0.6031984853403513, 0.6045834628438942, 0.562676017824115, 0.5795035156968646, 0.5889953230759628, 0.11106097704647089, 0.10929998894093573, 0.08549564349488281, 0.1090374569832886, 0.12404209331982907, 0.12265939613034393, 0.07722983137587258, 0.16530658957494215, 0.15074334560395075, 0.16141996670097092, 0.401538402374259, 0.17923292612564967, 0.28551709683159165, 0.22747589640500754, 0.2024466979017605, 0.2436088283184692, 0.19623280151860234, 0.3894477211539127, 0.237890853530497, 0.39548885153685964, 0.4556624667572198, 0.25710160930005155, 0.37107534889134564, 0.33118238167807457, 0.5191199849528816, 0.1512265042234905, 0.5703984797161623, 0.28684505013240846, 0.2897380362773522, 0.254354959447585, 0.1993111677149796, 0.26165469664117347, 0.28025194948748244, 0.09298504466214108, 0.27472323525926445, 0.324444542698506, 0.2129885965141466, 0.2502100405176694, 0.21045276046356964, 0.3254319294042127, 0.2454540597271858, 0.2081725048016405, 0.20753679647328893, 0.2190552212699366, 0.22870589481341508, 0.24311811246267745, 0.22294175645917613, 0.2479315666918932, 0.24316268446879208, 0.18332706679273447, 0.2004324697316765, 0.22028342207916185, 0.1838839376244834, 0.22153018525180657, 0.15124025572823685, 0.16749341103012627, 0.8163367762310358, 0.17684863231644488, 0.16558889888621375, 0.8964443155380855, 0.8390015992219962, 0.9203862740229054, 0.1630744340347171, 0.5661806570824695, 0.205189592246656, 0.16659901517702425, 0.2083195238717378, 0.20265931479640742, 0.6453461876760285, 0.1676778342024352, 0.12701391229828374, 0.16772459797827, 0.1892853524136573, 0.18696942922363835, 0.19595420606618874, 0.19180336648984952, 0.21091156273029432, 0.21759238058112473, 0.20539690040635827, 0.1974519368090938, 0.1894656264701846, 0.09261860026606994, 0.09261248042052861, 0.14831996366522437, 0.09285346229842306, 0.13987159994457432, 0.11985183081554729, 0.09681356747500613, 0.096693053790743, 0.08446003707787098]}, "mutation_prompt": null}
{"id": "2fc64536-b26f-4387-9701-bc16d1e79232", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "fc4ae318-dace-4ea8-96a9-76107782c5d3", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "6b3b2830-4632-49d8-9ba2-d9174a58e741", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
{"id": "f78e0ed2-5027-45a5-ab78-498a2b1ce7ea", "solution": "import numpy as np\n\nclass PSO_DE_Optimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 20\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1 = self.c1_initial\n        self.c2 = self.c2_initial\n        self.w = 0.5\n        self.f = 0.8\n        self.cr = 0.9\n        \n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.swarm = None\n        self.personal_best = None\n        self.global_best = None\n        self.velocities = None\n        self.func_evals = 0\n\n    def initialize(self):\n        self.swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best = self.swarm.copy()\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_score = np.inf\n\n    def update_velocities_and_positions(self):\n        for i in range(self.population_size):\n            r1 = np.random.rand(self.dim)\n            r2 = np.random.rand(self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best[i] - self.swarm[i])\n            social = self.c2 * r2 * (self.global_best - self.swarm[i])\n            self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n            self.swarm[i] += self.velocities[i]\n            self.swarm[i] = np.clip(self.swarm[i], self.lower_bound, self.upper_bound)\n\n    def differential_evolution(self):\n        for i in range(self.population_size):\n            indices = [idx for idx in range(self.population_size) if idx != i]\n            a, b, c = self.swarm[np.random.choice(indices, 3, replace=False)]\n            mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n            crossover = np.random.rand(self.dim) < self.cr\n            if not np.any(crossover):\n                crossover[np.random.randint(0, self.dim)] = True\n            trial = np.where(crossover, mutant, self.swarm[i])\n            yield i, trial\n\n    def __call__(self, func):\n        self.initialize()\n        \n        while self.func_evals < self.budget:\n            progress = self.func_evals / self.budget\n            self.c1 = self.c1_initial * (1 - progress) + 1.0 * progress\n            self.c2 = self.c2_initial * progress + 1.0 * (1 - progress)\n            self.w = 0.5 * (1 - progress) + 0.3 * progress  # Adaptive weight adjustment\n\n            for i, trial in self.differential_evolution():\n                if self.func_evals >= self.budget:\n                    break\n                trial_score = func(trial)\n                self.func_evals += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = trial\n                    self.personal_best_scores[i] = trial_score\n                    if trial_score < self.global_best_score:\n                        self.global_best = trial\n                        self.global_best_score = trial_score\n                        # Local search phase\n                        for _ in range(2):  # Minor modification within 2.0% change\n                            variation = np.random.uniform(-0.1, 0.1, self.dim)\n                            candidate = np.clip(trial + variation, self.lower_bound, self.upper_bound)\n                            candidate_score = func(candidate)\n                            self.func_evals += 1\n                            if candidate_score < self.global_best_score:\n                                self.global_best = candidate\n                                self.global_best_score = candidate_score\n\n            self.update_velocities_and_positions()\n\n            # Periodic re-evaluation of personal best\n            if self.func_evals % (self.budget // 10) == 0:\n                for i in range(self.population_size):\n                    if self.func_evals >= self.budget:\n                        break\n                    reeval_score = func(self.personal_best[i])\n                    self.func_evals += 1\n                    if reeval_score < self.personal_best_scores[i]:\n                        self.personal_best_scores[i] = reeval_score\n                        if reeval_score < self.global_best_score:\n                            self.global_best = self.personal_best[i]\n                            self.global_best_score = reeval_score\n\n            for i in range(self.population_size):\n                if self.func_evals >= self.budget:\n                    break\n                current_score = func(self.swarm[i])\n                self.func_evals += 1\n                if current_score < self.personal_best_scores[i]:\n                    self.personal_best[i] = self.swarm[i]\n                    self.personal_best_scores[i] = current_score\n                    if current_score < self.global_best_score:\n                        self.global_best = self.swarm[i]\n                        self.global_best_score = current_score\n\n        return self.global_best", "name": "PSO_DE_Optimizer", "description": "Introduce periodic re-evaluation refinement to reduce premature convergence in complex landscapes.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "cdb38d30-8e63-4cbd-b354-09017fefed2d", "metadata": {"aucs": [0.889109966314952, 0.8676082530770101, 0.878634210051618, 0.8755549423324616, 0.8704929720775518, 0.8757755407180098, 0.8968083456837191, 0.8871440710275295, 0.8726362288609658, 0.7598203790889253, 0.742407653694418, 0.7348149652894891, 0.7328577443282833, 0.7623591691442987, 0.7860735278477804, 0.7821969705897507, 0.720470575206166, 0.7614060616652569, 0.1523148993441339, 0.13922179704492332, 0.15460971660477207, 0.13678115622008058, 0.07337821285114987, 0.06903657929093165, 0.1520336727209931, 0.13197145122916865, 0.1785665441411446, 0.11141932127908127, 0.13463144758840118, 0.10699629127131394, 0.10472664898043116, 0.1155047388924062, 0.6635109008755661, 0.13960933146434307, 0.12290274214727726, 0.11324074476797019, 0.9817205086326367, 0.9854280397106265, 0.985931454102837, 0.9856402350458622, 0.9934927733958694, 0.9861314847609204, 0.9857345941165384, 0.9884791344612078, 0.992218922326036, 0.7518890898095072, 0.7856123883226533, 0.6646737264204114, 0.7494064333309662, 0.4188685996161866, 0.7387000514127161, 0.7307021270099281, 0.6800200788320715, 0.7761790352732566, 0.22274248377621708, 0.22631511315549813, 0.20490058710953507, 0.8846806637345124, 0.8813986727896248, 0.8176604579233837, 0.14832947424930332, 0.9143509176532697, 0.23300695474098854, 0.2783126784673968, 0.2627559204565887, 0.2566794213888369, 0.1339964074018215, 0.2520099655871212, 0.24971267464200353, 0.1325615408917311, 0.24222328537352178, 0.2432029523138033, 0.13008233852901174, 0.22795197765095077, 0.23695229487661906, 0.3451042210867846, 0.2811917490659879, 0.2564876665938316, 0.10246095747001582, 0.24723249392265934, 0.24101521789684444, 0.006927872414315583, 0.0023998639507383235, 0.019456353389791348, 0.03550171866467078, 9.999999999998899e-05, 0.05927543302969185, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015610764536074795, 0.08424835756129523, 0.06250650682908088, 0.15145931397501222, 0.013161785445148566, 0.02932839992186842, 0.06881579657210135, 0.057580241039387525, 0.022327593732786033, 0.06400055375300395, 0.0685050876365072, 0.0356027986900217, 0.11508949255380052, 0.07715451903215431, 0.16056994158649018, 0.07690411850295298, 0.1057030116173, 0.24804065815147203, 0.07318546148522476, 0.04342393400787892, 9.999999999998899e-05, 0.04236035236086677, 0.07588652818215924, 0.053044175996642684, 0.11687108796291523, 0.08233355887168237, 0.05959822766820311, 0.0822835362793114, 0.5535027398399602, 0.5756549315377582, 0.5496358255240157, 0.5952393075331098, 0.5950640518054391, 0.5843550673689331, 0.5796218143591869, 0.59312625647154, 0.5842368507787155, 0.11435472520928036, 0.1051084807705025, 0.07646441433982276, 0.13128339775438014, 0.12099738045639952, 0.12379089378647701, 0.06994150638839236, 0.15442045287695383, 0.1384812428828167, 0.28533002297655397, 0.2402675202948954, 0.17134858483682058, 0.22008813522578852, 0.3665216750732021, 0.1861750728987358, 0.16639047535889184, 0.18928643335660922, 0.17177997712231174, 0.25241075070820906, 0.37197321824684926, 0.4138567079190454, 0.34980522417326454, 0.2873006578077808, 0.45806898129418794, 0.5465715295186484, 0.1558664571198084, 0.4611397479892435, 0.417638097709765, 0.22952776820148013, 0.2401575101112159, 0.15625024996958203, 0.3652963402794367, 0.28313090288120524, 0.2507660592384856, 0.3024626165831862, 0.4224489930060228, 0.20666395405424753, 0.21696622412290512, 0.21824413317298508, 0.25970255435645084, 0.18475252614349558, 0.21803743445172263, 0.21075894785762062, 0.26687765594675095, 0.2003627156236324, 0.2172630096615481, 0.20436011106561414, 0.19645048192965375, 0.7600497171775684, 0.2065729695942412, 0.7151003667660847, 0.20384552138439493, 0.22281071254411322, 0.19262593329530986, 0.15305005380891612, 0.16360670557243007, 0.17437493157145711, 0.17676898246267503, 0.20554496495816532, 0.896573498348424, 0.7845519242548437, 0.8858528779782071, 0.8353197096515057, 0.5468802090617695, 0.1662051113340729, 0.1675052627464031, 0.20878076512682997, 0.7476583455557968, 0.7290904619960099, 0.167652654772787, 0.7363232342816404, 0.16841729614011436, 0.19954738722345022, 0.2048192821574052, 0.184265845199153, 0.1877441588430564, 0.20763478570998117, 0.19171698833610729, 0.18988678727607622, 0.1993198822625275, 0.1959832261263178, 0.09292854774862169, 0.10306136875220362, 0.12407537234853794, 0.10622034098428923, 0.1332906267937527, 0.08549403287252422, 0.08703834725771176, 0.08679882140864681, 0.08347611147560963]}, "mutation_prompt": null}
