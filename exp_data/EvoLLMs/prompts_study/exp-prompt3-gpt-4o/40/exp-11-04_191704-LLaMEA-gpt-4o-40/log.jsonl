{"id": "17963cac-50bc-4736-90ff-2963e07eb7d2", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.k = 0.729  # constriction factor\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            # Evaluate current positions\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            # Update personal bests\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            # Update global best\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            # Adaptive inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n            \n            # Enforce bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            iteration += 1\n            \n        return self.global_best_position, self.global_best_score", "name": "AdaptivePSO", "description": "An adaptive particle swarm optimization algorithm with dynamic inertia and constriction coefficients to balance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.25193044613350785, "feedback": "The algorithm AdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6749811545714608, 0.7175436270929726, 0.8280514840963559, 0.8877716026316812, 0.18966040316630328, 0.16384286446246044, 0.8732480806830685, 0.18288760070460963, 0.8742524617503343, 0.43912053625442327, 0.5603608567837607, 9.999999999998899e-05, 0.7124507368396299, 0.06951647630147795, 0.7377670521383586, 0.6799107099866417, 0.017140090138241804, 9.999999999998899e-05, 0.11780705973256356, 0.12484716490524317, 0.07097408456503163, 0.38140101346426536, 0.050635153349679385, 0.16486014357661405, 0.12370320988787042, 0.05288343000429285, 0.1446127912700158, 0.12540744202794463, 0.07186340325982365, 0.09256932975994969, 0.0945315528433952, 0.17967503699166243, 0.08166123839195716, 0.09120589284459402, 0.13836283437200725, 0.12125674585071755, 0.9913527248014871, 0.9908761553149682, 0.9912248090902532, 0.9861151983832548, 0.9835649954274381, 0.9836407382005312, 0.9899526386822397, 0.9891030136498958, 0.9909787638597869, 0.06005985659710844, 0.050026748083702666, 0.7226026737777317, 0.15367291310830988, 0.1519809585039229, 0.15089579901695904, 0.12555598586097927, 0.05761631843386383, 0.6409633969254092, 0.7589358859801209, 0.2117275500508985, 0.20121169274986128, 0.2731343962471383, 0.3616171412827428, 0.19165842896473828, 0.06981098524338014, 0.1313523557709384, 0.11699742884880393, 0.36926185345112883, 0.02182622471223805, 0.19117452547859426, 0.10175363212304689, 0.21111010259872554, 0.10489377675997436, 0.17771131356208258, 0.18209710047385375, 0.1385019949937334, 0.20681064152276096, 0.11538957805872085, 0.12582631616999862, 0.13074002642931715, 0.19123952779265752, 0.2376295717207052, 0.11065767940437055, 0.03378277643763539, 0.15768436329049074, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003012859111654054, 9.999999999998899e-05, 0.03639283458495424, 0.002921705981669187, 0.01775307785729674, 9.999999999998899e-05, 9.999999999998899e-05, 0.09263529639584445, 0.07350615135937155, 0.09571244442394855, 0.09335334680314167, 0.04362654905822405, 9.999999999998899e-05, 0.13151610961054794, 0.05514134327019493, 0.049756304730597, 0.09680242217535162, 9.999999999998899e-05, 9.999999999998899e-05, 0.06586409204682664, 0.03711273650003255, 9.999999999998899e-05, 0.17997313675019144, 0.1481644260896655, 0.06415254001226878, 0.0726807402876346, 9.999999999998899e-05, 0.2358530500103222, 0.12702594921391153, 0.00631112504143494, 0.21999198494266603, 0.07091996840195913, 0.08190509948218239, 0.08016986736093257, 0.5666506096700616, 0.5801186093715753, 0.5113388546354093, 0.2896700301051396, 0.6131191993545231, 0.20822817755201017, 0.4864706565388759, 0.5409029455597425, 0.5693615994020802, 0.08117095572811417, 0.0831517828513435, 0.0963795362970774, 0.10295651577039444, 0.07089071877616937, 0.10246779040133247, 0.13705705049886596, 0.07550240755774051, 0.0838506821824212, 0.1779881277269698, 0.19155177327580664, 0.21638672720141272, 0.22135736183880173, 0.2036479508249054, 0.1603464051879946, 0.15715623614227392, 0.188236476157999, 0.15214919402176363, 0.3441950284754479, 0.22703950235277337, 0.323346351686584, 0.5434234945516425, 0.1883150674271149, 0.33202937819699896, 0.17483907590392378, 0.3170314847548238, 0.17827632910113667, 0.3224154355064758, 0.2411572530440801, 0.2548322941962823, 0.14290309998201278, 0.20841107760267474, 0.18778098488323114, 0.23247533811291088, 0.3489421791993471, 0.24691891762363116, 0.20416382377730613, 0.13630837908987292, 0.21120363121049124, 0.24404882891251678, 0.2101392578624084, 0.1976799735243484, 0.2292825735283045, 0.1781542842794357, 0.20910141482647482, 0.22605408711943065, 0.18641386151936234, 0.1925771999561965, 0.16671270836832097, 0.23260241703220585, 0.18990897035281906, 0.25094056722297753, 0.15838581023193077, 0.2152011401258942, 0.810229519471674, 0.18685683040837386, 0.15208024833461675, 0.17276030138219156, 0.20029184431011104, 0.18400314463988499, 0.1299688919591394, 0.17028856985778706, 0.8746569498132486, 0.7969765384013331, 0.1554848862037843, 0.17506868966380584, 0.7554823281264103, 0.21050402992429806, 0.8230673931795314, 0.10426482533737491, 0.751687469808077, 0.764589859138602, 0.17738300915061278, 0.19397177263395615, 0.1995147392468548, 0.18190682447838358, 0.17817134093191056, 0.20101427900670243, 0.20402026611513124, 0.18706215679744997, 0.2113815343062675, 0.07276785526082907, 0.09645533790374916, 0.0822444812500377, 0.0813282771482754, 0.08664841803035328, 0.09285679036900052, 0.10236508660455035, 0.07926800629005681, 0.09680686234289837]}, "mutation_prompt": null}
{"id": "872bdb0b-0f1e-4367-b4b7-0cde3122a624", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.k = 0.729  # constriction factor\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            # Evaluate current positions\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            # Update personal bests\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            # Update global best\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            # Adaptive inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n            \n            # Enforce bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            iteration += 1\n            \n        return self.global_best_position, self.global_best_score", "name": "AdaptivePSO", "description": "An adaptive particle swarm optimization algorithm with dynamic inertia and constriction coefficients to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "17963cac-50bc-4736-90ff-2963e07eb7d2", "metadata": {"aucs": [0.6749811545714608, 0.7175436270929726, 0.8280514840963559, 0.8877716026316812, 0.18966040316630328, 0.16384286446246044, 0.8732480806830685, 0.18288760070460963, 0.8742524617503343, 0.43912053625442327, 0.5603608567837607, 9.999999999998899e-05, 0.7124507368396299, 0.06951647630147795, 0.7377670521383586, 0.6799107099866417, 0.017140090138241804, 9.999999999998899e-05, 0.11780705973256356, 0.12484716490524317, 0.07097408456503163, 0.38140101346426536, 0.050635153349679385, 0.16486014357661405, 0.12370320988787042, 0.05288343000429285, 0.1446127912700158, 0.12540744202794463, 0.07186340325982365, 0.09256932975994969, 0.0945315528433952, 0.17967503699166243, 0.08166123839195716, 0.09120589284459402, 0.13836283437200725, 0.12125674585071755, 0.9913527248014871, 0.9908761553149682, 0.9912248090902532, 0.9861151983832548, 0.9835649954274381, 0.9836407382005312, 0.9899526386822397, 0.9891030136498958, 0.9909787638597869, 0.06005985659710844, 0.050026748083702666, 0.7226026737777317, 0.15367291310830988, 0.1519809585039229, 0.15089579901695904, 0.12555598586097927, 0.05761631843386383, 0.6409633969254092, 0.7589358859801209, 0.2117275500508985, 0.20121169274986128, 0.2731343962471383, 0.3616171412827428, 0.19165842896473828, 0.06981098524338014, 0.1313523557709384, 0.11699742884880393, 0.36926185345112883, 0.02182622471223805, 0.19117452547859426, 0.10175363212304689, 0.21111010259872554, 0.10489377675997436, 0.17771131356208258, 0.18209710047385375, 0.1385019949937334, 0.20681064152276096, 0.11538957805872085, 0.12582631616999862, 0.13074002642931715, 0.19123952779265752, 0.2376295717207052, 0.11065767940437055, 0.03378277643763539, 0.15768436329049074, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003012859111654054, 9.999999999998899e-05, 0.03639283458495424, 0.002921705981669187, 0.01775307785729674, 9.999999999998899e-05, 9.999999999998899e-05, 0.09263529639584445, 0.07350615135937155, 0.09571244442394855, 0.09335334680314167, 0.04362654905822405, 9.999999999998899e-05, 0.13151610961054794, 0.05514134327019493, 0.049756304730597, 0.09680242217535162, 9.999999999998899e-05, 9.999999999998899e-05, 0.06586409204682664, 0.03711273650003255, 9.999999999998899e-05, 0.17997313675019144, 0.1481644260896655, 0.06415254001226878, 0.0726807402876346, 9.999999999998899e-05, 0.2358530500103222, 0.12702594921391153, 0.00631112504143494, 0.21999198494266603, 0.07091996840195913, 0.08190509948218239, 0.08016986736093257, 0.5666506096700616, 0.5801186093715753, 0.5113388546354093, 0.2896700301051396, 0.6131191993545231, 0.20822817755201017, 0.4864706565388759, 0.5409029455597425, 0.5693615994020802, 0.08117095572811417, 0.0831517828513435, 0.0963795362970774, 0.10295651577039444, 0.07089071877616937, 0.10246779040133247, 0.13705705049886596, 0.07550240755774051, 0.0838506821824212, 0.1779881277269698, 0.19155177327580664, 0.21638672720141272, 0.22135736183880173, 0.2036479508249054, 0.1603464051879946, 0.15715623614227392, 0.188236476157999, 0.15214919402176363, 0.3441950284754479, 0.22703950235277337, 0.323346351686584, 0.5434234945516425, 0.1883150674271149, 0.33202937819699896, 0.17483907590392378, 0.3170314847548238, 0.17827632910113667, 0.3224154355064758, 0.2411572530440801, 0.2548322941962823, 0.14290309998201278, 0.20841107760267474, 0.18778098488323114, 0.23247533811291088, 0.3489421791993471, 0.24691891762363116, 0.20416382377730613, 0.13630837908987292, 0.21120363121049124, 0.24404882891251678, 0.2101392578624084, 0.1976799735243484, 0.2292825735283045, 0.1781542842794357, 0.20910141482647482, 0.22605408711943065, 0.18641386151936234, 0.1925771999561965, 0.16671270836832097, 0.23260241703220585, 0.18990897035281906, 0.25094056722297753, 0.15838581023193077, 0.2152011401258942, 0.810229519471674, 0.18685683040837386, 0.15208024833461675, 0.17276030138219156, 0.20029184431011104, 0.18400314463988499, 0.1299688919591394, 0.17028856985778706, 0.8746569498132486, 0.7969765384013331, 0.1554848862037843, 0.17506868966380584, 0.7554823281264103, 0.21050402992429806, 0.8230673931795314, 0.10426482533737491, 0.751687469808077, 0.764589859138602, 0.17738300915061278, 0.19397177263395615, 0.1995147392468548, 0.18190682447838358, 0.17817134093191056, 0.20101427900670243, 0.20402026611513124, 0.18706215679744997, 0.2113815343062675, 0.07276785526082907, 0.09645533790374916, 0.0822444812500377, 0.0813282771482754, 0.08664841803035328, 0.09285679036900052, 0.10236508660455035, 0.07926800629005681, 0.09680686234289837]}, "mutation_prompt": null}
{"id": "e3d66141-9d22-4f79-8788-4bb2fb5f2811", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.w_min = 0.4\n        self.w_max = 0.9\n        self.k = 0.729  # constriction factor\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            # Evaluate current positions\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            # Update personal bests\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            # Update global best\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            # Adaptive inertia weight\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            \n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n            \n            # Enforce bounds\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n            iteration += 1\n            \n        return self.global_best_position, self.global_best_score", "name": "AdaptivePSO", "description": "An adaptive particle swarm optimization algorithm with dynamic inertia and constriction coefficients to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "17963cac-50bc-4736-90ff-2963e07eb7d2", "metadata": {"aucs": [0.6749811545714608, 0.7175436270929726, 0.8280514840963559, 0.8877716026316812, 0.18966040316630328, 0.16384286446246044, 0.8732480806830685, 0.18288760070460963, 0.8742524617503343, 0.43912053625442327, 0.5603608567837607, 9.999999999998899e-05, 0.7124507368396299, 0.06951647630147795, 0.7377670521383586, 0.6799107099866417, 0.017140090138241804, 9.999999999998899e-05, 0.11780705973256356, 0.12484716490524317, 0.07097408456503163, 0.38140101346426536, 0.050635153349679385, 0.16486014357661405, 0.12370320988787042, 0.05288343000429285, 0.1446127912700158, 0.12540744202794463, 0.07186340325982365, 0.09256932975994969, 0.0945315528433952, 0.17967503699166243, 0.08166123839195716, 0.09120589284459402, 0.13836283437200725, 0.12125674585071755, 0.9913527248014871, 0.9908761553149682, 0.9912248090902532, 0.9861151983832548, 0.9835649954274381, 0.9836407382005312, 0.9899526386822397, 0.9891030136498958, 0.9909787638597869, 0.06005985659710844, 0.050026748083702666, 0.7226026737777317, 0.15367291310830988, 0.1519809585039229, 0.15089579901695904, 0.12555598586097927, 0.05761631843386383, 0.6409633969254092, 0.7589358859801209, 0.2117275500508985, 0.20121169274986128, 0.2731343962471383, 0.3616171412827428, 0.19165842896473828, 0.06981098524338014, 0.1313523557709384, 0.11699742884880393, 0.36926185345112883, 0.02182622471223805, 0.19117452547859426, 0.10175363212304689, 0.21111010259872554, 0.10489377675997436, 0.17771131356208258, 0.18209710047385375, 0.1385019949937334, 0.20681064152276096, 0.11538957805872085, 0.12582631616999862, 0.13074002642931715, 0.19123952779265752, 0.2376295717207052, 0.11065767940437055, 0.03378277643763539, 0.15768436329049074, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003012859111654054, 9.999999999998899e-05, 0.03639283458495424, 0.002921705981669187, 0.01775307785729674, 9.999999999998899e-05, 9.999999999998899e-05, 0.09263529639584445, 0.07350615135937155, 0.09571244442394855, 0.09335334680314167, 0.04362654905822405, 9.999999999998899e-05, 0.13151610961054794, 0.05514134327019493, 0.049756304730597, 0.09680242217535162, 9.999999999998899e-05, 9.999999999998899e-05, 0.06586409204682664, 0.03711273650003255, 9.999999999998899e-05, 0.17997313675019144, 0.1481644260896655, 0.06415254001226878, 0.0726807402876346, 9.999999999998899e-05, 0.2358530500103222, 0.12702594921391153, 0.00631112504143494, 0.21999198494266603, 0.07091996840195913, 0.08190509948218239, 0.08016986736093257, 0.5666506096700616, 0.5801186093715753, 0.5113388546354093, 0.2896700301051396, 0.6131191993545231, 0.20822817755201017, 0.4864706565388759, 0.5409029455597425, 0.5693615994020802, 0.08117095572811417, 0.0831517828513435, 0.0963795362970774, 0.10295651577039444, 0.07089071877616937, 0.10246779040133247, 0.13705705049886596, 0.07550240755774051, 0.0838506821824212, 0.1779881277269698, 0.19155177327580664, 0.21638672720141272, 0.22135736183880173, 0.2036479508249054, 0.1603464051879946, 0.15715623614227392, 0.188236476157999, 0.15214919402176363, 0.3441950284754479, 0.22703950235277337, 0.323346351686584, 0.5434234945516425, 0.1883150674271149, 0.33202937819699896, 0.17483907590392378, 0.3170314847548238, 0.17827632910113667, 0.3224154355064758, 0.2411572530440801, 0.2548322941962823, 0.14290309998201278, 0.20841107760267474, 0.18778098488323114, 0.23247533811291088, 0.3489421791993471, 0.24691891762363116, 0.20416382377730613, 0.13630837908987292, 0.21120363121049124, 0.24404882891251678, 0.2101392578624084, 0.1976799735243484, 0.2292825735283045, 0.1781542842794357, 0.20910141482647482, 0.22605408711943065, 0.18641386151936234, 0.1925771999561965, 0.16671270836832097, 0.23260241703220585, 0.18990897035281906, 0.25094056722297753, 0.15838581023193077, 0.2152011401258942, 0.810229519471674, 0.18685683040837386, 0.15208024833461675, 0.17276030138219156, 0.20029184431011104, 0.18400314463988499, 0.1299688919591394, 0.17028856985778706, 0.8746569498132486, 0.7969765384013331, 0.1554848862037843, 0.17506868966380584, 0.7554823281264103, 0.21050402992429806, 0.8230673931795314, 0.10426482533737491, 0.751687469808077, 0.764589859138602, 0.17738300915061278, 0.19397177263395615, 0.1995147392468548, 0.18190682447838358, 0.17817134093191056, 0.20101427900670243, 0.20402026611513124, 0.18706215679744997, 0.2113815343062675, 0.07276785526082907, 0.09645533790374916, 0.0822444812500377, 0.0813282771482754, 0.08664841803035328, 0.09285679036900052, 0.10236508660455035, 0.07926800629005681, 0.09680686234289837]}, "mutation_prompt": null}
{"id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce mutation for diversity\n            if iteration % 10 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, 0.1, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "A dynamic multi-swarm particle swarm optimization algorithm with adaptive learning coefficients and mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.2844201254609133, "feedback": "The algorithm DynamicMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "17963cac-50bc-4736-90ff-2963e07eb7d2", "metadata": {"aucs": [0.7825311251595042, 0.8027389850225577, 0.7345141470650434, 0.8231611046457792, 0.882555637833252, 0.2594994456442691, 0.8731610758880455, 0.8937198111796895, 0.8529864347601847, 0.6877857872050579, 9.999999999998899e-05, 0.07543867085527878, 0.7464608879032346, 0.6972924542255868, 0.6176423231025103, 0.749624940363405, 0.7511978132629811, 0.6006037296041866, 0.15085426659586954, 0.11306240729212547, 0.061360738165634254, 0.315969551816207, 0.08787763802831627, 0.1399732988350032, 0.16778090500749532, 0.17258165454893282, 0.15893060030300965, 0.13577304310959193, 0.13303465108615675, 0.1074140831266106, 0.053515916011643405, 0.08197555347835062, 0.09570446194299331, 0.14714766516857125, 0.1383560611519129, 0.10193744252887194, 0.985713272944462, 0.9895319047354983, 0.9887151339044237, 0.9807661869700857, 0.978509277376182, 0.9790096404879073, 0.9836157729815498, 0.9836316716084361, 0.9860084815414542, 0.652720882193496, 0.6439840691316048, 0.7438004864000778, 0.5560742749964045, 0.6601413848813119, 0.6429943071671034, 0.6048405432620831, 0.5129329704467973, 0.6811310414503582, 0.22904128382762412, 0.21316805813513373, 0.29086474913522975, 0.2759358581387992, 0.3523780450391587, 0.19313515924500602, 0.13933722843137397, 0.23665102162715412, 0.33876335277143343, 0.07779904750314726, 0.2217597493686262, 0.20597518179377472, 0.15224865895771145, 0.18982681452576144, 0.13201499384608784, 0.353615439830145, 0.12694196427804605, 0.2102009800728325, 0.27254372784506886, 0.09925117219778945, 0.19877711384440444, 0.1278424352681301, 0.11631198091657313, 0.1612066700367044, 0.24665295133526077, 0.23545104997033972, 0.001842285124785903, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293219794543879, 9.999999999998899e-05, 9.999999999998899e-05, 0.036654477165878774, 0.007884924016374528, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699551956862669, 0.026934620437008006, 0.030346223836814512, 0.050956551489677815, 0.016077085384804235, 0.0001547964571633198, 0.09081032277116696, 0.06608490120341504, 0.04132158881253112, 0.049106234636626334, 0.03581738013660629, 0.1513816388206315, 0.04080287017475692, 0.00791404314767874, 0.08359648586388557, 0.10770924079613686, 0.06801887749915336, 0.07093000940810434, 0.1106799894249072, 0.0912282153082522, 0.07343004500226924, 0.16109206208579474, 0.09434175457112992, 0.08787533298399575, 0.20627995199659, 0.08316132183498592, 0.07793986840678335, 0.5520713965678614, 0.5021941188383807, 0.4981478128289325, 0.6432546029843413, 0.5497467377331964, 0.45990625283237363, 0.5441086313274186, 0.560789356855043, 0.2895555840076377, 0.14776941074224126, 0.06382869362791188, 0.07998602391182452, 0.1308398709927353, 0.11842355641467095, 0.1272605927067436, 0.07596190263561953, 0.09057636543851455, 0.09424224453623387, 0.26683264166819065, 0.2613091474150935, 0.1713283197365254, 0.19005819386834732, 0.1462161953267037, 0.18844888849000652, 0.19967245322794147, 0.2156163075341394, 0.1497284103050317, 0.29837224371490556, 0.43469216355526363, 0.2972424556566047, 0.2479488139208723, 0.37499144781921634, 0.4169358938905229, 0.4968169511396271, 0.508751825513319, 0.3507570935752601, 0.1743752591561495, 0.41845991346326894, 0.2688826851401189, 0.25060463633562535, 0.1721799527131661, 0.24400374205636322, 0.2610123172885752, 0.2730839141031175, 0.15755402040489408, 0.24244278118323137, 0.21079210133482085, 0.21689564407200745, 0.20522024977648434, 0.21628809851447672, 0.2155179219601322, 0.27018901016497077, 0.19905423093708274, 0.2060324864384503, 0.21973619317655568, 0.22433035987680505, 0.22017146922793562, 0.22113703168274346, 0.20614693499285408, 0.4644815219549284, 0.20415794002110432, 0.19450461092508642, 0.18306772189249088, 0.1874148261101889, 0.1880837342523639, 0.1510303415303903, 0.9154046047346237, 0.20180468328249346, 0.20033519223197604, 0.11526767285117134, 0.17017313471257678, 0.6522575060993102, 0.7387440612289078, 0.15736338487401957, 0.1912942626255415, 0.31680803043768146, 0.3077818598353138, 0.206566683741775, 0.10513845647492237, 0.10461866688571186, 0.6820335102715923, 0.20084070167155765, 0.17445916698275377, 0.20484652952860383, 0.2049059196974532, 0.21143533056760377, 0.1957969513087795, 0.17993867991829504, 0.18878952912439328, 0.18518562902152014, 0.11782301136520545, 0.068774350991053, 0.08838181251482746, 0.07368194209090073, 0.08591506909302948, 0.0956853871629808, 0.0862452115886968, 0.08901937417619088, 0.0992154217897887]}, "mutation_prompt": null}
{"id": "5c6816bb-5f37-4c78-8018-5c88a3da138a", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce mutation for diversity\n            if iteration % 10 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, 0.1, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "A dynamic multi-swarm particle swarm optimization algorithm with adaptive learning coefficients and mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7825311251595042, 0.8027389850225577, 0.7345141470650434, 0.8231611046457792, 0.882555637833252, 0.2594994456442691, 0.8731610758880455, 0.8937198111796895, 0.8529864347601847, 0.6877857872050579, 9.999999999998899e-05, 0.07543867085527878, 0.7464608879032346, 0.6972924542255868, 0.6176423231025103, 0.749624940363405, 0.7511978132629811, 0.6006037296041866, 0.15085426659586954, 0.11306240729212547, 0.061360738165634254, 0.315969551816207, 0.08787763802831627, 0.1399732988350032, 0.16778090500749532, 0.17258165454893282, 0.15893060030300965, 0.13577304310959193, 0.13303465108615675, 0.1074140831266106, 0.053515916011643405, 0.08197555347835062, 0.09570446194299331, 0.14714766516857125, 0.1383560611519129, 0.10193744252887194, 0.985713272944462, 0.9895319047354983, 0.9887151339044237, 0.9807661869700857, 0.978509277376182, 0.9790096404879073, 0.9836157729815498, 0.9836316716084361, 0.9860084815414542, 0.652720882193496, 0.6439840691316048, 0.7438004864000778, 0.5560742749964045, 0.6601413848813119, 0.6429943071671034, 0.6048405432620831, 0.5129329704467973, 0.6811310414503582, 0.22904128382762412, 0.21316805813513373, 0.29086474913522975, 0.2759358581387992, 0.3523780450391587, 0.19313515924500602, 0.13933722843137397, 0.23665102162715412, 0.33876335277143343, 0.07779904750314726, 0.2217597493686262, 0.20597518179377472, 0.15224865895771145, 0.18982681452576144, 0.13201499384608784, 0.353615439830145, 0.12694196427804605, 0.2102009800728325, 0.27254372784506886, 0.09925117219778945, 0.19877711384440444, 0.1278424352681301, 0.11631198091657313, 0.1612066700367044, 0.24665295133526077, 0.23545104997033972, 0.001842285124785903, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293219794543879, 9.999999999998899e-05, 9.999999999998899e-05, 0.036654477165878774, 0.007884924016374528, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699551956862669, 0.026934620437008006, 0.030346223836814512, 0.050956551489677815, 0.016077085384804235, 0.0001547964571633198, 0.09081032277116696, 0.06608490120341504, 0.04132158881253112, 0.049106234636626334, 0.03581738013660629, 0.1513816388206315, 0.04080287017475692, 0.00791404314767874, 0.08359648586388557, 0.10770924079613686, 0.06801887749915336, 0.07093000940810434, 0.1106799894249072, 0.0912282153082522, 0.07343004500226924, 0.16109206208579474, 0.09434175457112992, 0.08787533298399575, 0.20627995199659, 0.08316132183498592, 0.07793986840678335, 0.5520713965678614, 0.5021941188383807, 0.4981478128289325, 0.6432546029843413, 0.5497467377331964, 0.45990625283237363, 0.5441086313274186, 0.560789356855043, 0.2895555840076377, 0.14776941074224126, 0.06382869362791188, 0.07998602391182452, 0.1308398709927353, 0.11842355641467095, 0.1272605927067436, 0.07596190263561953, 0.09057636543851455, 0.09424224453623387, 0.26683264166819065, 0.2613091474150935, 0.1713283197365254, 0.19005819386834732, 0.1462161953267037, 0.18844888849000652, 0.19967245322794147, 0.2156163075341394, 0.1497284103050317, 0.29837224371490556, 0.43469216355526363, 0.2972424556566047, 0.2479488139208723, 0.37499144781921634, 0.4169358938905229, 0.4968169511396271, 0.508751825513319, 0.3507570935752601, 0.1743752591561495, 0.41845991346326894, 0.2688826851401189, 0.25060463633562535, 0.1721799527131661, 0.24400374205636322, 0.2610123172885752, 0.2730839141031175, 0.15755402040489408, 0.24244278118323137, 0.21079210133482085, 0.21689564407200745, 0.20522024977648434, 0.21628809851447672, 0.2155179219601322, 0.27018901016497077, 0.19905423093708274, 0.2060324864384503, 0.21973619317655568, 0.22433035987680505, 0.22017146922793562, 0.22113703168274346, 0.20614693499285408, 0.4644815219549284, 0.20415794002110432, 0.19450461092508642, 0.18306772189249088, 0.1874148261101889, 0.1880837342523639, 0.1510303415303903, 0.9154046047346237, 0.20180468328249346, 0.20033519223197604, 0.11526767285117134, 0.17017313471257678, 0.6522575060993102, 0.7387440612289078, 0.15736338487401957, 0.1912942626255415, 0.31680803043768146, 0.3077818598353138, 0.206566683741775, 0.10513845647492237, 0.10461866688571186, 0.6820335102715923, 0.20084070167155765, 0.17445916698275377, 0.20484652952860383, 0.2049059196974532, 0.21143533056760377, 0.1957969513087795, 0.17993867991829504, 0.18878952912439328, 0.18518562902152014, 0.11782301136520545, 0.068774350991053, 0.08838181251482746, 0.07368194209090073, 0.08591506909302948, 0.0956853871629808, 0.0862452115886968, 0.08901937417619088, 0.0992154217897887]}, "mutation_prompt": null}
{"id": "8100823e-e5ba-4706-8573-e74033ac6535", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        neighborhood_radius = 0.1  # New parameter for local search\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Neighborhood-based local search\n            for i, pos in enumerate(self.positions):\n                candidate = pos + np.random.normal(0, neighborhood_radius, self.dim)\n                candidate_score = func(candidate)\n                self.evaluations += 1\n                if candidate_score < scores[i]:\n                    self.positions[i] = candidate\n                    scores[i] = candidate_score\n\n            # Adaptive mutation strategy\n            if iteration % 5 == 0:\n                mutation_strength = np.random.uniform(0, 0.1)\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "Introduction of a neighborhood-based local search and adaptive mutation strategy to improve convergence in a multi-swarm particle swarm optimizer.", "configspace": "", "generation": 5, "fitness": 0.23748000446102838, "feedback": "The algorithm DynamicMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7569804669850879, 0.6073632037035605, 0.7246616379809849, 0.6134126128393, 0.7201270344339027, 0.4772023387666452, 0.7668606161963044, 0.4586655000034846, 0.7160042663268515, 9.999999999998899e-05, 0.33145882451892694, 0.3013111645626575, 0.3465241204138254, 0.28641347046108645, 0.395447938029737, 9.999999999998899e-05, 0.19023736308731598, 0.13262466665793615, 0.10560901510318776, 0.09622481868321897, 0.060694798488009516, 0.1140928629369008, 0.16903017646686913, 0.11015597946983857, 0.10890346365419079, 0.114150131390241, 0.10460765998328736, 0.11991867446577142, 0.11922707201550142, 0.04528296856178127, 0.09066997923136, 0.05135442787675981, 0.08116502729525221, 0.06210205094372323, 0.09176172784525594, 0.09208570727466447, 0.9677892653897527, 0.9736473127883546, 0.9688312304515078, 0.9605723311495337, 0.7465796716851654, 0.9590920989645232, 0.9697713198684315, 0.9684556800664885, 0.9694061464258878, 0.3856220930383123, 0.2957634443413144, 0.28042210283622526, 0.33219509505651734, 0.3505831650281863, 0.39978303574114604, 0.35386221557098607, 0.30961989011379465, 0.3485583723328878, 0.2213691002971967, 0.3419423753535358, 0.21207509042210626, 0.5487339769976636, 0.20885842751851813, 0.20706228075653055, 0.4084775349557407, 0.10817304481014745, 0.22413271342185803, 0.15542078918301028, 0.1351571133660645, 0.15915977394628444, 0.15633464047166123, 0.12471324277519302, 0.1922319155518628, 0.1572814937890331, 0.11740765465079583, 0.1684298215419716, 0.19463870719615195, 9.999999999998899e-05, 0.18574490493741358, 0.1727436699506396, 0.2405746725078125, 0.12737036343415997, 0.20073828468396293, 0.18212437857882424, 0.08942433028557639, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015644475069116592, 9.999999999998899e-05, 0.006152472916884699, 9.999999999998899e-05, 9.999999999998899e-05, 0.004746097722189591, 0.04717552424333993, 0.05383212180710395, 0.12753385785251448, 0.051078845401705486, 0.0357321605777432, 9.999999999998899e-05, 0.07640461736514936, 0.09294052601096459, 0.04839546830947161, 9.999999999998899e-05, 0.021357504227902613, 0.14319498485736348, 0.05788806853181738, 0.017260242027893447, 0.06557235602823808, 0.18083385815645847, 0.05896606462804155, 0.02512681703918429, 0.06473964273271138, 0.08979118216629811, 0.08736054729484244, 0.04464726284910958, 0.1743045343596772, 0.06834577771850459, 0.05729389659757833, 0.054594400123674, 0.07976400050757548, 0.4489700624251276, 0.4565105917271022, 0.4695144453017177, 0.465034825167697, 0.4736015896284903, 0.4572012022957942, 0.4680082712703083, 0.47139056775632926, 0.4133875975117589, 0.1110443492197184, 0.07743676557571655, 0.08911626512121418, 0.09790331647067363, 0.07500763050311665, 0.07235469735119093, 0.0950527841138692, 0.09387062544106406, 0.060361353498616155, 0.2742055512750149, 0.17448099644066095, 0.16422025102054538, 0.1854058047363174, 0.33914580503158653, 0.1656320397374479, 0.3877481855044953, 0.2061683074622671, 0.1363655090452206, 0.23353524736734987, 0.2921749833053846, 0.35606613557949773, 0.30027593621696436, 0.31780907835323347, 0.2809849279149077, 0.35694961806352954, 0.30174873854018913, 0.32820550607420107, 0.20529903003104444, 0.22960609455893932, 0.20251460219313755, 0.18194196660366058, 0.19153925165026264, 0.2099402641412117, 0.2324922720799648, 0.24163635308712617, 0.2344910012496989, 0.20866253701362603, 0.1575852652671199, 0.18902149508302313, 0.18191771300638115, 0.2157177359140937, 0.17742071487837308, 0.23564901854421794, 0.1934830438975359, 0.18578440086577397, 0.18589387536246593, 0.4794543518166108, 0.21315034739973893, 0.1970688667111954, 0.2155197330405939, 0.20572038732119813, 0.16940386751194325, 0.19235479468732897, 0.20226627052234558, 0.18596507949139784, 0.1866041910698154, 0.15336022288986673, 0.8422483848916382, 0.19942743586322964, 0.19840962849481336, 0.11077251954745826, 0.16787783126511635, 0.21117076801945112, 0.8082955523668134, 0.17888909694238997, 0.48979501542105686, 0.20402318802266206, 0.3158150087149545, 0.20752814601821146, 0.10458473044853622, 0.10306808598272599, 0.5396122288320462, 0.18209722746397217, 0.21150764910655984, 0.17277101608070422, 0.18391257425801044, 0.1823443955577, 0.19405307638224734, 0.20280278875975155, 0.2108527726070043, 0.18397569999355678, 0.09001225577160532, 0.07010099855856422, 0.08064090026619486, 0.08257792892268312, 0.0685807625107906, 0.0815590527610418, 0.0852798489605493, 0.09280836942825177, 0.08494786941462085]}, "mutation_prompt": null}
{"id": "f53b846e-870c-4fc9-99d0-db60bf617cac", "solution": "import numpy as np\n\nclass AdaptiveEvoMultiSwarm:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce genetic crossover\n            if iteration % 5 == 0:\n                for i in range(0, self.swarm_size, 2):\n                    if i + 1 < self.swarm_size:\n                        crossover_point = np.random.randint(1, self.dim)\n                        self.positions[i, :crossover_point], self.positions[i+1, :crossover_point] = (\n                            self.positions[i+1, :crossover_point], self.positions[i, :crossover_point].copy())\n                \n            # Enhanced mutation for diversity\n            if iteration % 8 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.uniform(-0.2, 0.2, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveEvoMultiSwarm", "description": "An adaptive evolutionary multi-swarm optimization algorithm that integrates genetic crossover and mutation to dynamically enhance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.2674736870386082, "feedback": "The algorithm AdaptiveEvoMultiSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7496242031230498, 0.5306519751121199, 0.7995402049561776, 0.8818151337730202, 0.8237582108432724, 0.17029909642539587, 0.7786070379380414, 0.8433728929505648, 0.6155015491033639, 0.18768023578697657, 0.03993138896648052, 0.4537987487006191, 0.46077934418484634, 0.04042351048017512, 0.011556923905243655, 0.6098603455917263, 0.25929774921773474, 0.5828708053852216, 0.13675172035754368, 0.10049456697620351, 0.11713124476334502, 0.1684477158600064, 0.13279538580468964, 0.06526729737664194, 0.1654138741513359, 0.04093764564343949, 0.05796212295235914, 0.11583525864305133, 0.14206651172919715, 0.13256031624718034, 0.10892009521725576, 0.13533133141835574, 0.05293880874352963, 0.13509783823240173, 0.13764099907156302, 0.12743827550689202, 0.9860043254200049, 0.9888395366716788, 0.9887853765616825, 0.9838910706593448, 0.9715785660668742, 0.9810482942189982, 0.9839114780720747, 0.9802493726865108, 0.9884114324181511, 0.5906949055232341, 0.5064440408321755, 0.617972386606118, 0.5735641373875064, 0.4024374503721607, 0.5039720164908352, 0.5638651653034178, 0.4722467972687555, 0.45488917387400274, 0.13706777296424622, 0.19002383841903359, 0.18503073754089527, 0.2808267736239296, 0.2164480480310773, 0.2177672776875702, 0.1364919552157633, 0.7359660976915874, 0.644172996919292, 0.20476099417811067, 0.1902700677446134, 0.19057391984902172, 0.13112023330904377, 0.17445370634707957, 0.1550604309452439, 0.19616305262423028, 0.14958468881939302, 0.20879101607951023, 0.17170634412241415, 0.10778757952428752, 0.21308834916384223, 0.16103298487322792, 0.28324359924876774, 0.19525412841829826, 0.23341845790858007, 9.999999999998899e-05, 0.1749919908419788, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026864281828905767, 0.005040327968954039, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03904301838600077, 0.06471709959384775, 0.04357302839857713, 0.05427447482784953, 0.08204795838166701, 9.999999999998899e-05, 0.003935989377691795, 0.11697978277127619, 0.11014790445437772, 0.04302140454547809, 0.04799142743134832, 0.03317480415785834, 0.04539210568593899, 0.03355896077725962, 0.07047158552624655, 0.06223957809104852, 0.14781499414693522, 0.0674276167192005, 0.06455036602690001, 0.09503992358671787, 0.04175187718920026, 0.20391674790879055, 0.1380146396939721, 0.020227196524181257, 0.14116086479018342, 0.09019412719783304, 0.05282145373202618, 0.08268738440080137, 0.49299361922599383, 0.36800648749809495, 0.4740524941854257, 0.47423413705644046, 0.5261497993566733, 0.5521313821264882, 0.5166301979584093, 0.4894953170035603, 0.5437983933677859, 0.06305084215274581, 0.07497128323264679, 0.07377510179842606, 0.07718128570958283, 0.0950494835453437, 0.14970943937263348, 0.10198345748802129, 0.09811734818061957, 0.27114000041931574, 0.14704055947551298, 0.15716898093975018, 0.22606398338076883, 0.25923866172737287, 0.23613234508625558, 0.26286816661553425, 0.1444449179036319, 0.22874925672764235, 0.253064427318504, 0.2708468890035556, 0.2539722965412391, 0.2187916721650699, 0.4429559252209583, 0.20916900181385256, 0.2401388935773836, 0.4006487458087088, 0.43724098838192926, 0.35497183143834476, 0.1664657927931803, 0.15533088303646836, 0.24099268437683452, 0.2879305486739565, 0.24869558180625517, 0.2989275464864629, 0.31843834433359275, 0.3425147313092044, 0.23788787452260518, 0.20642957309093612, 0.1668276878988434, 0.1859567438976103, 0.21207331915524952, 0.20186467949247522, 0.2219462577346012, 0.20374576216190166, 0.19813181140750769, 0.24212309098920226, 0.24109202836467292, 0.21056361395577372, 0.23897843984924005, 0.2172143943339262, 0.21889282718145686, 0.5200812559155449, 0.20887761838812346, 0.18706905790895345, 0.2254398919141446, 0.879464102012423, 0.805434874104058, 0.15421532027274898, 0.870872485218593, 0.20101794709802645, 0.19897941210248804, 0.1424885581511286, 0.17017722401229962, 0.20700152600960342, 0.554132570171953, 0.15719810621321173, 0.43453345819675615, 0.20882684114627692, 0.20976570469684297, 0.2095784295323868, 0.2074696660120432, 0.10468528633654073, 0.6755897779251351, 0.18432182785471596, 0.18273780705643272, 0.1688910723542718, 0.17829039864493335, 0.17681742952008295, 0.18543112479061397, 0.19297774423980885, 0.1779195176952919, 0.18729192437402398, 0.09813784195759745, 0.09302843458698717, 0.07938538714470911, 0.08541855468872395, 0.10264495358349746, 0.0774738756198542, 0.07142311156918002, 0.09477135332209419, 0.09026924055643726]}, "mutation_prompt": null}
{"id": "d8306674-5b45-4e40-a25e-167281e8c818", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce mutation for diversity\n            if iteration % 10 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, 0.1, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "A dynamic multi-swarm particle swarm optimization algorithm with adaptive learning coefficients and mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7825311251595042, 0.8027389850225577, 0.7345141470650434, 0.8231611046457792, 0.882555637833252, 0.2594994456442691, 0.8731610758880455, 0.8937198111796895, 0.8529864347601847, 0.6877857872050579, 9.999999999998899e-05, 0.07543867085527878, 0.7464608879032346, 0.6972924542255868, 0.6176423231025103, 0.749624940363405, 0.7511978132629811, 0.6006037296041866, 0.15085426659586954, 0.11306240729212547, 0.061360738165634254, 0.315969551816207, 0.08787763802831627, 0.1399732988350032, 0.16778090500749532, 0.17258165454893282, 0.15893060030300965, 0.13577304310959193, 0.13303465108615675, 0.1074140831266106, 0.053515916011643405, 0.08197555347835062, 0.09570446194299331, 0.14714766516857125, 0.1383560611519129, 0.10193744252887194, 0.985713272944462, 0.9895319047354983, 0.9887151339044237, 0.9807661869700857, 0.978509277376182, 0.9790096404879073, 0.9836157729815498, 0.9836316716084361, 0.9860084815414542, 0.652720882193496, 0.6439840691316048, 0.7438004864000778, 0.5560742749964045, 0.6601413848813119, 0.6429943071671034, 0.6048405432620831, 0.5129329704467973, 0.6811310414503582, 0.22904128382762412, 0.21316805813513373, 0.29086474913522975, 0.2759358581387992, 0.3523780450391587, 0.19313515924500602, 0.13933722843137397, 0.23665102162715412, 0.33876335277143343, 0.07779904750314726, 0.2217597493686262, 0.20597518179377472, 0.15224865895771145, 0.18982681452576144, 0.13201499384608784, 0.353615439830145, 0.12694196427804605, 0.2102009800728325, 0.27254372784506886, 0.09925117219778945, 0.19877711384440444, 0.1278424352681301, 0.11631198091657313, 0.1612066700367044, 0.24665295133526077, 0.23545104997033972, 0.001842285124785903, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293219794543879, 9.999999999998899e-05, 9.999999999998899e-05, 0.036654477165878774, 0.007884924016374528, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699551956862669, 0.026934620437008006, 0.030346223836814512, 0.050956551489677815, 0.016077085384804235, 0.0001547964571633198, 0.09081032277116696, 0.06608490120341504, 0.04132158881253112, 0.049106234636626334, 0.03581738013660629, 0.1513816388206315, 0.04080287017475692, 0.00791404314767874, 0.08359648586388557, 0.10770924079613686, 0.06801887749915336, 0.07093000940810434, 0.1106799894249072, 0.0912282153082522, 0.07343004500226924, 0.16109206208579474, 0.09434175457112992, 0.08787533298399575, 0.20627995199659, 0.08316132183498592, 0.07793986840678335, 0.5520713965678614, 0.5021941188383807, 0.4981478128289325, 0.6432546029843413, 0.5497467377331964, 0.45990625283237363, 0.5441086313274186, 0.560789356855043, 0.2895555840076377, 0.14776941074224126, 0.06382869362791188, 0.07998602391182452, 0.1308398709927353, 0.11842355641467095, 0.1272605927067436, 0.07596190263561953, 0.09057636543851455, 0.09424224453623387, 0.26683264166819065, 0.2613091474150935, 0.1713283197365254, 0.19005819386834732, 0.1462161953267037, 0.18844888849000652, 0.19967245322794147, 0.2156163075341394, 0.1497284103050317, 0.29837224371490556, 0.43469216355526363, 0.2972424556566047, 0.2479488139208723, 0.37499144781921634, 0.4169358938905229, 0.4968169511396271, 0.508751825513319, 0.3507570935752601, 0.1743752591561495, 0.41845991346326894, 0.2688826851401189, 0.25060463633562535, 0.1721799527131661, 0.24400374205636322, 0.2610123172885752, 0.2730839141031175, 0.15755402040489408, 0.24244278118323137, 0.21079210133482085, 0.21689564407200745, 0.20522024977648434, 0.21628809851447672, 0.2155179219601322, 0.27018901016497077, 0.19905423093708274, 0.2060324864384503, 0.21973619317655568, 0.22433035987680505, 0.22017146922793562, 0.22113703168274346, 0.20614693499285408, 0.4644815219549284, 0.20415794002110432, 0.19450461092508642, 0.18306772189249088, 0.1874148261101889, 0.1880837342523639, 0.1510303415303903, 0.9154046047346237, 0.20180468328249346, 0.20033519223197604, 0.11526767285117134, 0.17017313471257678, 0.6522575060993102, 0.7387440612289078, 0.15736338487401957, 0.1912942626255415, 0.31680803043768146, 0.3077818598353138, 0.206566683741775, 0.10513845647492237, 0.10461866688571186, 0.6820335102715923, 0.20084070167155765, 0.17445916698275377, 0.20484652952860383, 0.2049059196974532, 0.21143533056760377, 0.1957969513087795, 0.17993867991829504, 0.18878952912439328, 0.18518562902152014, 0.11782301136520545, 0.068774350991053, 0.08838181251482746, 0.07368194209090073, 0.08591506909302948, 0.0956853871629808, 0.0862452115886968, 0.08901937417619088, 0.0992154217897887]}, "mutation_prompt": null}
{"id": "cee50432-f9f4-44e3-a062-ae947af3989f", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce mutation for diversity\n            if iteration % 10 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, 0.1, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "A dynamic multi-swarm particle swarm optimization algorithm with adaptive learning coefficients and mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7825311251595042, 0.8027389850225577, 0.7345141470650434, 0.8231611046457792, 0.882555637833252, 0.2594994456442691, 0.8731610758880455, 0.8937198111796895, 0.8529864347601847, 0.6877857872050579, 9.999999999998899e-05, 0.07543867085527878, 0.7464608879032346, 0.6972924542255868, 0.6176423231025103, 0.749624940363405, 0.7511978132629811, 0.6006037296041866, 0.15085426659586954, 0.11306240729212547, 0.061360738165634254, 0.315969551816207, 0.08787763802831627, 0.1399732988350032, 0.16778090500749532, 0.17258165454893282, 0.15893060030300965, 0.13577304310959193, 0.13303465108615675, 0.1074140831266106, 0.053515916011643405, 0.08197555347835062, 0.09570446194299331, 0.14714766516857125, 0.1383560611519129, 0.10193744252887194, 0.985713272944462, 0.9895319047354983, 0.9887151339044237, 0.9807661869700857, 0.978509277376182, 0.9790096404879073, 0.9836157729815498, 0.9836316716084361, 0.9860084815414542, 0.652720882193496, 0.6439840691316048, 0.7438004864000778, 0.5560742749964045, 0.6601413848813119, 0.6429943071671034, 0.6048405432620831, 0.5129329704467973, 0.6811310414503582, 0.22904128382762412, 0.21316805813513373, 0.29086474913522975, 0.2759358581387992, 0.3523780450391587, 0.19313515924500602, 0.13933722843137397, 0.23665102162715412, 0.33876335277143343, 0.07779904750314726, 0.2217597493686262, 0.20597518179377472, 0.15224865895771145, 0.18982681452576144, 0.13201499384608784, 0.353615439830145, 0.12694196427804605, 0.2102009800728325, 0.27254372784506886, 0.09925117219778945, 0.19877711384440444, 0.1278424352681301, 0.11631198091657313, 0.1612066700367044, 0.24665295133526077, 0.23545104997033972, 0.001842285124785903, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293219794543879, 9.999999999998899e-05, 9.999999999998899e-05, 0.036654477165878774, 0.007884924016374528, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699551956862669, 0.026934620437008006, 0.030346223836814512, 0.050956551489677815, 0.016077085384804235, 0.0001547964571633198, 0.09081032277116696, 0.06608490120341504, 0.04132158881253112, 0.049106234636626334, 0.03581738013660629, 0.1513816388206315, 0.04080287017475692, 0.00791404314767874, 0.08359648586388557, 0.10770924079613686, 0.06801887749915336, 0.07093000940810434, 0.1106799894249072, 0.0912282153082522, 0.07343004500226924, 0.16109206208579474, 0.09434175457112992, 0.08787533298399575, 0.20627995199659, 0.08316132183498592, 0.07793986840678335, 0.5520713965678614, 0.5021941188383807, 0.4981478128289325, 0.6432546029843413, 0.5497467377331964, 0.45990625283237363, 0.5441086313274186, 0.560789356855043, 0.2895555840076377, 0.14776941074224126, 0.06382869362791188, 0.07998602391182452, 0.1308398709927353, 0.11842355641467095, 0.1272605927067436, 0.07596190263561953, 0.09057636543851455, 0.09424224453623387, 0.26683264166819065, 0.2613091474150935, 0.1713283197365254, 0.19005819386834732, 0.1462161953267037, 0.18844888849000652, 0.19967245322794147, 0.2156163075341394, 0.1497284103050317, 0.29837224371490556, 0.43469216355526363, 0.2972424556566047, 0.2479488139208723, 0.37499144781921634, 0.4169358938905229, 0.4968169511396271, 0.508751825513319, 0.3507570935752601, 0.1743752591561495, 0.41845991346326894, 0.2688826851401189, 0.25060463633562535, 0.1721799527131661, 0.24400374205636322, 0.2610123172885752, 0.2730839141031175, 0.15755402040489408, 0.24244278118323137, 0.21079210133482085, 0.21689564407200745, 0.20522024977648434, 0.21628809851447672, 0.2155179219601322, 0.27018901016497077, 0.19905423093708274, 0.2060324864384503, 0.21973619317655568, 0.22433035987680505, 0.22017146922793562, 0.22113703168274346, 0.20614693499285408, 0.4644815219549284, 0.20415794002110432, 0.19450461092508642, 0.18306772189249088, 0.1874148261101889, 0.1880837342523639, 0.1510303415303903, 0.9154046047346237, 0.20180468328249346, 0.20033519223197604, 0.11526767285117134, 0.17017313471257678, 0.6522575060993102, 0.7387440612289078, 0.15736338487401957, 0.1912942626255415, 0.31680803043768146, 0.3077818598353138, 0.206566683741775, 0.10513845647492237, 0.10461866688571186, 0.6820335102715923, 0.20084070167155765, 0.17445916698275377, 0.20484652952860383, 0.2049059196974532, 0.21143533056760377, 0.1957969513087795, 0.17993867991829504, 0.18878952912439328, 0.18518562902152014, 0.11782301136520545, 0.068774350991053, 0.08838181251482746, 0.07368194209090073, 0.08591506909302948, 0.0956853871629808, 0.0862452115886968, 0.08901937417619088, 0.0992154217897887]}, "mutation_prompt": null}
{"id": "2cdf107a-b33a-423c-b36d-259a5f6829fc", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        chaos_coefficient = 0.1  # Hyperparameter for chaos-enhanced mutation\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = np.linspace(self.c1_min, self.c1_max, self.num_swarms)[iteration % self.num_swarms]\n            c2 = np.linspace(self.c2_max, self.c2_min, self.num_swarms)[iteration % self.num_swarms]\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            if iteration % 7 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                chaos = np.random.rand(len(mutation_indices), self.dim)\n                self.positions[mutation_indices] += chaos_coefficient * chaos * (np.sin(chaos * 12.9898 + 78.233) * 43758.5453123 % 1)\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveSwarmPSO", "description": "A hybrid adaptive multi-swarm PSO with dynamic grouping and chaos-enhanced mutation for improved convergence in diverse landscapes.", "configspace": "", "generation": 9, "fitness": 0.24081969304696335, "feedback": "The algorithm HybridAdaptiveSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.25.", "error": "", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.5397557546960493, 0.5992574799966301, 0.8146178141657211, 0.16551877501377077, 0.7860900001219993, 0.7447999598565327, 0.7732484214919716, 0.8090840607845824, 0.8335223997833642, 0.03922155517181547, 0.03359435397828425, 0.07069268357737235, 0.5479668227923358, 0.5633057885134585, 0.5272178996630661, 9.999999999998899e-05, 0.6615021047772685, 0.04062573410545156, 0.10662713678659674, 0.11848742640787224, 0.14913521854430511, 0.10716419131468813, 0.11855656103618495, 0.06448203428334198, 0.16573598481583163, 0.048315465590296314, 0.05614755885599043, 0.14570651846280502, 0.15142302694138166, 0.13021236197160635, 0.09599903127358589, 0.11587899147104053, 0.11825832946224124, 0.053290250683724505, 0.11302167751218573, 0.1217050905674314, 0.9891828745844381, 0.9913995030236993, 0.992024502717308, 0.9810933955608859, 0.9848185132003289, 0.9811145315463273, 0.9915104386865305, 0.9865144211586362, 0.9909484323842863, 0.5690773475088524, 0.501098090936074, 0.6959066562108642, 0.5431349319858901, 0.5417852448242416, 0.20356522702478141, 0.08440549137463438, 0.08882134443117662, 0.08827730012679424, 0.21819459893234072, 0.22390908848009017, 0.22677113838763174, 0.2001529858286355, 0.20055350369235225, 0.18440435409210798, 0.12444734637104993, 0.12781935964821756, 0.11597831423437488, 0.22307397449582955, 0.20626214024644018, 0.17564395533661858, 0.20406203981564308, 0.2035656820806795, 0.12557974944064476, 0.12210851586895988, 0.1545953745266625, 0.07763750877248221, 0.19253037809920048, 0.014901093789245867, 0.16621140231954612, 0.27164147321167, 0.2408376081146142, 0.27418808362966474, 0.18666267467935627, 9.999999999998899e-05, 0.23126316831602622, 0.001999810361980603, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016397523311200035, 9.999999999998899e-05, 0.008149417784961033, 0.0036805455068499304, 0.05448141786018823, 0.03461839252858623, 0.020769686088482064, 0.051395373081055684, 0.00408192275303132, 0.002795427211720214, 0.06101641722081874, 0.05049879611639918, 0.0900855669858196, 0.046181709005351124, 0.07495638958249817, 0.028504014230536612, 9.999999999998899e-05, 9.999999999998899e-05, 0.13624295337554526, 0.08872268307062003, 0.07113331367954756, 0.03981111539429116, 0.03010910049309301, 0.039484589102713796, 0.033421548649856025, 0.020585309517548778, 0.036936935436764906, 9.999999999998899e-05, 0.08175867985297569, 0.0769866448998251, 0.08196812409642784, 0.4736134166207625, 0.47108751992993414, 0.5257894458092294, 0.5394326952821429, 0.5445099425201971, 0.20915573994378212, 0.5572069497407752, 0.48599742859219763, 0.28259850791289187, 0.10249069864574123, 0.07378915309564749, 0.08031058296207372, 0.04931100024500357, 0.03683437801473233, 0.09496144265152962, 0.09619449738000108, 0.162283915491653, 0.09478339175583028, 0.4476179986337273, 0.17703035228536845, 0.15829212581785157, 0.14815890524099018, 0.4846920170245841, 0.1932561476848258, 0.13725718768916173, 0.13107984245511728, 0.22073757625258406, 0.23066050159431917, 0.24941084274993408, 0.27895735894712526, 0.30145550660759424, 0.35704628507720426, 0.39188570082364005, 0.40478055421361825, 0.5258246562363662, 0.2683805279923268, 0.23590655642483305, 0.24320844318467993, 0.1993958169750314, 0.16840006581010514, 0.15297572813118765, 0.2322773596684813, 0.23840548792460092, 0.280996536315813, 0.12939242647956584, 0.20219713003850692, 0.14068843719689794, 0.20982693779511663, 0.19955775886628657, 0.18485254658916217, 0.1915508452964162, 0.20992078416126592, 0.1664860316291954, 0.2022682427454804, 0.18569995673153472, 0.4762236396340701, 0.21329184788914635, 0.190426998763097, 0.201699299530551, 0.20019460563954972, 0.2513468184408776, 0.199788538354996, 0.17593691343057472, 0.580532416658488, 0.1856136491042233, 0.11511282442736215, 0.86490467092206, 0.19962793668189494, 0.16911023324138097, 0.12383888555380307, 0.17042335116062568, 0.20878107221615994, 0.7215721116577475, 0.11750873939622763, 0.15113512254606232, 0.20621951397191196, 0.22052717450143133, 0.21074261770378866, 0.10429335054574151, 0.10388032247358858, 0.7533645503697018, 0.18834830480720188, 0.18293725273869965, 0.19174774832468, 0.18654701778198668, 0.2197382201611512, 0.18657582493915548, 0.17490361695770784, 0.20455240149534315, 0.19192315760671452, 0.09556760012794763, 0.08639979134190323, 0.058554945910217815, 0.08562495745920773, 0.06381416382314564, 0.08853527428096053, 0.0717010975019251, 0.10304571594017653, 0.04394188488096895]}, "mutation_prompt": null}
{"id": "6673ec1a-599d-410e-9c78-0e77f73679f8", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce mutation for diversity\n            if iteration % 10 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, 0.1, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "A dynamic multi-swarm particle swarm optimization algorithm with adaptive learning coefficients and mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7825311251595042, 0.8027389850225577, 0.7345141470650434, 0.8231611046457792, 0.882555637833252, 0.2594994456442691, 0.8731610758880455, 0.8937198111796895, 0.8529864347601847, 0.6877857872050579, 9.999999999998899e-05, 0.07543867085527878, 0.7464608879032346, 0.6972924542255868, 0.6176423231025103, 0.749624940363405, 0.7511978132629811, 0.6006037296041866, 0.15085426659586954, 0.11306240729212547, 0.061360738165634254, 0.315969551816207, 0.08787763802831627, 0.1399732988350032, 0.16778090500749532, 0.17258165454893282, 0.15893060030300965, 0.13577304310959193, 0.13303465108615675, 0.1074140831266106, 0.053515916011643405, 0.08197555347835062, 0.09570446194299331, 0.14714766516857125, 0.1383560611519129, 0.10193744252887194, 0.985713272944462, 0.9895319047354983, 0.9887151339044237, 0.9807661869700857, 0.978509277376182, 0.9790096404879073, 0.9836157729815498, 0.9836316716084361, 0.9860084815414542, 0.652720882193496, 0.6439840691316048, 0.7438004864000778, 0.5560742749964045, 0.6601413848813119, 0.6429943071671034, 0.6048405432620831, 0.5129329704467973, 0.6811310414503582, 0.22904128382762412, 0.21316805813513373, 0.29086474913522975, 0.2759358581387992, 0.3523780450391587, 0.19313515924500602, 0.13933722843137397, 0.23665102162715412, 0.33876335277143343, 0.07779904750314726, 0.2217597493686262, 0.20597518179377472, 0.15224865895771145, 0.18982681452576144, 0.13201499384608784, 0.353615439830145, 0.12694196427804605, 0.2102009800728325, 0.27254372784506886, 0.09925117219778945, 0.19877711384440444, 0.1278424352681301, 0.11631198091657313, 0.1612066700367044, 0.24665295133526077, 0.23545104997033972, 0.001842285124785903, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293219794543879, 9.999999999998899e-05, 9.999999999998899e-05, 0.036654477165878774, 0.007884924016374528, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699551956862669, 0.026934620437008006, 0.030346223836814512, 0.050956551489677815, 0.016077085384804235, 0.0001547964571633198, 0.09081032277116696, 0.06608490120341504, 0.04132158881253112, 0.049106234636626334, 0.03581738013660629, 0.1513816388206315, 0.04080287017475692, 0.00791404314767874, 0.08359648586388557, 0.10770924079613686, 0.06801887749915336, 0.07093000940810434, 0.1106799894249072, 0.0912282153082522, 0.07343004500226924, 0.16109206208579474, 0.09434175457112992, 0.08787533298399575, 0.20627995199659, 0.08316132183498592, 0.07793986840678335, 0.5520713965678614, 0.5021941188383807, 0.4981478128289325, 0.6432546029843413, 0.5497467377331964, 0.45990625283237363, 0.5441086313274186, 0.560789356855043, 0.2895555840076377, 0.14776941074224126, 0.06382869362791188, 0.07998602391182452, 0.1308398709927353, 0.11842355641467095, 0.1272605927067436, 0.07596190263561953, 0.09057636543851455, 0.09424224453623387, 0.26683264166819065, 0.2613091474150935, 0.1713283197365254, 0.19005819386834732, 0.1462161953267037, 0.18844888849000652, 0.19967245322794147, 0.2156163075341394, 0.1497284103050317, 0.29837224371490556, 0.43469216355526363, 0.2972424556566047, 0.2479488139208723, 0.37499144781921634, 0.4169358938905229, 0.4968169511396271, 0.508751825513319, 0.3507570935752601, 0.1743752591561495, 0.41845991346326894, 0.2688826851401189, 0.25060463633562535, 0.1721799527131661, 0.24400374205636322, 0.2610123172885752, 0.2730839141031175, 0.15755402040489408, 0.24244278118323137, 0.21079210133482085, 0.21689564407200745, 0.20522024977648434, 0.21628809851447672, 0.2155179219601322, 0.27018901016497077, 0.19905423093708274, 0.2060324864384503, 0.21973619317655568, 0.22433035987680505, 0.22017146922793562, 0.22113703168274346, 0.20614693499285408, 0.4644815219549284, 0.20415794002110432, 0.19450461092508642, 0.18306772189249088, 0.1874148261101889, 0.1880837342523639, 0.1510303415303903, 0.9154046047346237, 0.20180468328249346, 0.20033519223197604, 0.11526767285117134, 0.17017313471257678, 0.6522575060993102, 0.7387440612289078, 0.15736338487401957, 0.1912942626255415, 0.31680803043768146, 0.3077818598353138, 0.206566683741775, 0.10513845647492237, 0.10461866688571186, 0.6820335102715923, 0.20084070167155765, 0.17445916698275377, 0.20484652952860383, 0.2049059196974532, 0.21143533056760377, 0.1957969513087795, 0.17993867991829504, 0.18878952912439328, 0.18518562902152014, 0.11782301136520545, 0.068774350991053, 0.08838181251482746, 0.07368194209090073, 0.08591506909302948, 0.0956853871629808, 0.0862452115886968, 0.08901937417619088, 0.0992154217897887]}, "mutation_prompt": null}
{"id": "5722f46d-639f-4382-b301-0e9166855eeb", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Introduce mutation for diversity\n            if iteration % 10 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, 0.1, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "A dynamic multi-swarm particle swarm optimization algorithm with adaptive learning coefficients and mutation strategy for enhanced exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.7825311251595042, 0.8027389850225577, 0.7345141470650434, 0.8231611046457792, 0.882555637833252, 0.2594994456442691, 0.8731610758880455, 0.8937198111796895, 0.8529864347601847, 0.6877857872050579, 9.999999999998899e-05, 0.07543867085527878, 0.7464608879032346, 0.6972924542255868, 0.6176423231025103, 0.749624940363405, 0.7511978132629811, 0.6006037296041866, 0.15085426659586954, 0.11306240729212547, 0.061360738165634254, 0.315969551816207, 0.08787763802831627, 0.1399732988350032, 0.16778090500749532, 0.17258165454893282, 0.15893060030300965, 0.13577304310959193, 0.13303465108615675, 0.1074140831266106, 0.053515916011643405, 0.08197555347835062, 0.09570446194299331, 0.14714766516857125, 0.1383560611519129, 0.10193744252887194, 0.985713272944462, 0.9895319047354983, 0.9887151339044237, 0.9807661869700857, 0.978509277376182, 0.9790096404879073, 0.9836157729815498, 0.9836316716084361, 0.9860084815414542, 0.652720882193496, 0.6439840691316048, 0.7438004864000778, 0.5560742749964045, 0.6601413848813119, 0.6429943071671034, 0.6048405432620831, 0.5129329704467973, 0.6811310414503582, 0.22904128382762412, 0.21316805813513373, 0.29086474913522975, 0.2759358581387992, 0.3523780450391587, 0.19313515924500602, 0.13933722843137397, 0.23665102162715412, 0.33876335277143343, 0.07779904750314726, 0.2217597493686262, 0.20597518179377472, 0.15224865895771145, 0.18982681452576144, 0.13201499384608784, 0.353615439830145, 0.12694196427804605, 0.2102009800728325, 0.27254372784506886, 0.09925117219778945, 0.19877711384440444, 0.1278424352681301, 0.11631198091657313, 0.1612066700367044, 0.24665295133526077, 0.23545104997033972, 0.001842285124785903, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293219794543879, 9.999999999998899e-05, 9.999999999998899e-05, 0.036654477165878774, 0.007884924016374528, 9.999999999998899e-05, 9.999999999998899e-05, 0.04699551956862669, 0.026934620437008006, 0.030346223836814512, 0.050956551489677815, 0.016077085384804235, 0.0001547964571633198, 0.09081032277116696, 0.06608490120341504, 0.04132158881253112, 0.049106234636626334, 0.03581738013660629, 0.1513816388206315, 0.04080287017475692, 0.00791404314767874, 0.08359648586388557, 0.10770924079613686, 0.06801887749915336, 0.07093000940810434, 0.1106799894249072, 0.0912282153082522, 0.07343004500226924, 0.16109206208579474, 0.09434175457112992, 0.08787533298399575, 0.20627995199659, 0.08316132183498592, 0.07793986840678335, 0.5520713965678614, 0.5021941188383807, 0.4981478128289325, 0.6432546029843413, 0.5497467377331964, 0.45990625283237363, 0.5441086313274186, 0.560789356855043, 0.2895555840076377, 0.14776941074224126, 0.06382869362791188, 0.07998602391182452, 0.1308398709927353, 0.11842355641467095, 0.1272605927067436, 0.07596190263561953, 0.09057636543851455, 0.09424224453623387, 0.26683264166819065, 0.2613091474150935, 0.1713283197365254, 0.19005819386834732, 0.1462161953267037, 0.18844888849000652, 0.19967245322794147, 0.2156163075341394, 0.1497284103050317, 0.29837224371490556, 0.43469216355526363, 0.2972424556566047, 0.2479488139208723, 0.37499144781921634, 0.4169358938905229, 0.4968169511396271, 0.508751825513319, 0.3507570935752601, 0.1743752591561495, 0.41845991346326894, 0.2688826851401189, 0.25060463633562535, 0.1721799527131661, 0.24400374205636322, 0.2610123172885752, 0.2730839141031175, 0.15755402040489408, 0.24244278118323137, 0.21079210133482085, 0.21689564407200745, 0.20522024977648434, 0.21628809851447672, 0.2155179219601322, 0.27018901016497077, 0.19905423093708274, 0.2060324864384503, 0.21973619317655568, 0.22433035987680505, 0.22017146922793562, 0.22113703168274346, 0.20614693499285408, 0.4644815219549284, 0.20415794002110432, 0.19450461092508642, 0.18306772189249088, 0.1874148261101889, 0.1880837342523639, 0.1510303415303903, 0.9154046047346237, 0.20180468328249346, 0.20033519223197604, 0.11526767285117134, 0.17017313471257678, 0.6522575060993102, 0.7387440612289078, 0.15736338487401957, 0.1912942626255415, 0.31680803043768146, 0.3077818598353138, 0.206566683741775, 0.10513845647492237, 0.10461866688571186, 0.6820335102715923, 0.20084070167155765, 0.17445916698275377, 0.20484652952860383, 0.2049059196974532, 0.21143533056760377, 0.1957969513087795, 0.17993867991829504, 0.18878952912439328, 0.18518562902152014, 0.11782301136520545, 0.068774350991053, 0.08838181251482746, 0.07368194209090073, 0.08591506909302948, 0.0956853871629808, 0.0862452115886968, 0.08901937417619088, 0.0992154217897887]}, "mutation_prompt": null}
{"id": "d2157bff-39c8-475d-8062-66a0117d90cb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n        self.elite_fraction = 0.2  # Fraction of particles considered elite\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = 0.729 * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Periodic regrouping and selection of elite particles\n            if iteration % 5 == 0:\n                elite_count = int(self.elite_fraction * self.swarm_size)\n                elite_indices = np.argsort(self.personal_best_scores)[:elite_count]\n                self.positions = np.concatenate((self.personal_best_positions[elite_indices], \n                                                np.random.uniform(self.lower_bound, self.upper_bound, \n                                                                  (self.swarm_size - elite_count, self.dim))))\n                self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveMultiSwarmPSO", "description": "An enhanced adaptive multi-swarm PSO with periodic regrouping and elite selection for improved convergence and diversity.", "configspace": "", "generation": 12, "fitness": 0.19565177842318454, "feedback": "The algorithm EnhancedAdaptiveMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.3751183692551512, 0.38660898257950727, 0.3999592977298667, 0.37766030273429085, 0.4170007475443749, 0.38424541086160025, 0.4061787357060591, 0.4173893514749125, 0.3984518253461178, 0.010421029954341021, 0.0029270499411572226, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00022260716539568293, 0.02280221261255433, 9.999999999998899e-05, 0.08894548602526231, 0.05488141285248471, 0.08582690737856902, 0.08175527473947841, 0.06030667971506032, 0.0914530348746384, 0.06601739846180665, 0.08561761913710375, 0.09754305081802395, 0.07228685636472276, 0.08239607687333339, 0.08501895232018875, 0.046464339185265824, 0.0768588293303224, 0.0845157534689488, 0.08396371705864936, 0.08513350101707562, 0.08893727791107264, 0.9878665469952861, 0.9883636552166836, 0.9781985441729453, 0.9815241268658317, 0.9881823871023627, 0.9836567485211369, 0.9864365640208015, 0.9816954465531031, 0.9774200437961295, 0.2779570669246475, 0.24441874675754383, 0.26956236817845947, 0.2744093841551407, 0.2675358921077783, 0.24353700537540302, 0.2210608866788154, 0.25658661441958874, 0.2818904111021242, 0.308081659949931, 0.22917648081714148, 0.2986955275987573, 0.18764812926978025, 0.21996110315664696, 0.19093328418878652, 0.12691764347252743, 0.29895376499936366, 0.30380762948388196, 0.12451681717125507, 0.12783549370163783, 0.1347058332951343, 0.09431803661149096, 0.14364103724771593, 0.11900569577050979, 0.12533084006750284, 0.14692016494160254, 0.13702921887062747, 0.15388895015470683, 0.09824972674639487, 0.11251980659668992, 0.13269826668491935, 0.11029900576801333, 0.1282345472521914, 0.14047591823244077, 0.11558406613382433, 0.10794400214336419, 0.008108693279681556, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05483566008215712, 0.009814919354426799, 0.07603097976301398, 0.08316382809106848, 0.038150040943809804, 0.051433770694850445, 0.02293160344834122, 0.04439046335553998, 0.11748668953592567, 9.999999999998899e-05, 0.00018143756397270838, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07094161843970126, 0.009167064820892135, 0.0802151332771085, 0.07116961682149392, 0.06032202171207279, 0.07993316208419343, 0.08667829911626035, 0.07199197814649327, 0.0564443319624941, 0.34864929988789806, 0.3715964264122287, 0.3515243622332962, 0.3659230156683667, 0.3770959728007306, 0.2119743211170927, 0.3814587957359924, 0.3718242773721674, 0.3669588697828827, 0.10486595994628656, 0.06537637679010877, 0.06625253991232238, 0.10424705471735052, 0.10227631517008795, 0.08317440362898831, 0.10660977658341331, 0.09092238525369245, 0.10152780703714093, 0.13876048329091262, 0.1452421202075811, 0.2660543512625896, 0.13130364740932143, 0.17312627998853292, 0.252820494750152, 0.19137399185359283, 0.16966175320677435, 0.1931080943883009, 0.2744044606741741, 0.254488807817542, 0.19184168070948004, 0.23095590551974654, 0.27043469739452664, 0.26676674916478527, 0.22033216071248318, 0.2691961220122131, 0.26439315335741964, 0.1621404861891329, 0.18537349569880235, 0.1956813659097324, 0.20334035337743916, 0.19095311375780033, 0.13698003010702864, 0.13987168362434454, 0.19462249104116514, 0.20507642660567205, 0.18616780721197557, 0.1652610734648977, 0.19258866080005566, 0.17055614677670783, 0.16471558931208108, 0.2140928628931662, 0.2062283736769398, 0.18560254046794533, 0.23974342828742734, 0.186166463957964, 0.1742102779251834, 0.1955777941543576, 0.18907472143813897, 0.1727382772154923, 0.18230788906271422, 0.16222336028532414, 0.16919578763515042, 0.17603762129616785, 0.19937134242160703, 0.19795170491454095, 0.15219197361225012, 0.39525571608871257, 0.19799018893647324, 0.37965161468298614, 0.3043117661470306, 0.17268595169888756, 0.6063368807435806, 0.43507994288661966, 0.16522167776952323, 0.5179933284715657, 0.4374694740960965, 0.33876082858633694, 0.29096847791817404, 0.16957842966902392, 0.15582283964098065, 0.22008593717310287, 0.17183760969809225, 0.2062317262415586, 0.18298677539762198, 0.18551919197598887, 0.20314456168230488, 0.1804193440643509, 0.18898715726898985, 0.18123481605234493, 0.19302511514264276, 0.07163059813033146, 0.07174901078580365, 0.08935377105801723, 0.0787526085553103, 0.052019564265270546, 0.0896064020646603, 0.08229957358848805, 0.07376428709140803, 0.07836842274274736]}, "mutation_prompt": null}
{"id": "60b39806-256c-4086-ada9-be96f5a715c0", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 13, "fitness": 0.3006621652412921, "feedback": "The algorithm RefinedDynamicMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e2d73e05-fbf5-4200-8e13-29432bfaeeb8", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "9f6aa774-4301-41b4-ae52-945a176f2b65", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "bc4d45a0-0168-4bcc-94a0-82f6c0e8db87", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "987c81c1-1363-4544-b586-db7706b55f41", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "ffe0ebb8-c441-407b-90d8-e84a34fc74ea", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "5d116ce9-5fc2-488e-ae1c-428fafb141dd", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "16eaab70-013b-44c8-8c1b-89b51b26065d", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "b0c0f75a-8f6c-4fd1-88c5-ee5fa2a11c05", "solution": "import numpy as np\n\nclass EnhancedDualPhasePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.2, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        phase_switch = self.budget // (2 * self.swarm_size)\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            if iteration < phase_switch:\n                w = self.w_min + ((self.w_max - self.w_min) * iteration / phase_switch)\n                c1, c2 = self.c1_min, self.c2_max\n            else:\n                w = self.w_max - ((self.w_max - self.w_min) * (iteration - phase_switch) / phase_switch)\n                c1, c2 = self.c2_min, self.c1_max\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n\n            self.positions += self.velocities\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            if iteration % 15 == 0:\n                mutation_strength = 0.1 + 0.4 * np.random.rand()\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                directions = np.random.choice([-1, 1], (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] += directions * mutation_strength\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedDualPhasePSO", "description": "Enhance convergence by incorporating a dual-phase exploration-exploitation strategy with multi-directional search and adaptive inertia.", "configspace": "", "generation": 20, "fitness": 0.28141355749385566, "feedback": "The algorithm EnhancedDualPhasePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.9393095445509229, 0.9359441003532285, 0.9528502800775029, 0.9623554583260916, 0.9556522245706327, 0.8837499446172502, 0.9423239740104224, 0.8768922379940731, 0.9522468607608361, 0.7873855669670509, 9.999999999998899e-05, 0.4133726322707586, 0.6292662478451305, 0.6504380776077212, 0.6117626262656289, 0.5095820098064806, 0.8213517633306522, 0.43842506711766216, 0.1281932236353348, 0.15561409400539672, 0.06281491109233939, 0.09855194904394027, 0.08043216530921449, 0.10667282314710524, 0.07874612166414297, 0.08343869641764945, 0.09760392920623495, 0.061641673483941894, 0.10427268728335715, 0.05445534917072803, 0.08408293345540441, 0.053624362654542734, 0.08042278015560556, 0.08392667203932724, 0.04604714935056542, 0.0831068629121321, 0.9839239978769462, 0.9901543324713715, 0.990348413923521, 0.9852611001341254, 0.9882067308379269, 0.9524725167131817, 0.987930013315541, 0.9864813495222341, 0.9708860394284259, 0.6233165653371552, 0.5156281000204075, 0.5233068879629146, 0.5322301132822739, 0.7961154887218409, 0.3291763600735115, 0.7591580529626611, 0.576356267275725, 0.6698890654259184, 0.23148136764084215, 0.11688730496605693, 0.20406504363027644, 0.21923585131568357, 0.21292130980026203, 0.37774344038533425, 0.17870880233078112, 0.12955142473644354, 0.18547096509132321, 0.20137738485868462, 0.20778210205516423, 0.17961022047242314, 0.2197097955061097, 0.13658839785832622, 0.21216636499741737, 0.20378856442993898, 0.1328195093939345, 0.13781781803517357, 0.1853233198230846, 0.13317033203462147, 0.21568393609850212, 0.13734648417728512, 9.999999999998899e-05, 0.22589349986328522, 0.09267448160289948, 0.09335463805065902, 0.08112008053110875, 9.999999999998899e-05, 0.00585745166203433, 9.999999999998899e-05, 0.004581187353792315, 9.999999999998899e-05, 0.0096535822662972, 9.999999999998899e-05, 9.999999999998899e-05, 0.05286886782224942, 0.08354037420259008, 0.02099463756846376, 0.08818589762436291, 0.07152068087843366, 0.0057218696835752425, 0.016498541831428182, 0.11630578606393882, 0.03449709054444461, 0.04859085769960725, 0.05750639735349394, 0.03890872334515838, 0.20414824403652387, 0.08738343468565313, 0.10496545969932902, 0.09290288979486672, 0.41685800026708864, 0.15974422083446993, 0.08049083736794349, 0.09395656811060549, 0.04507136998747607, 0.19426258357913417, 0.0794075942788881, 0.0067919617058274095, 0.2768444248023083, 0.13237177131705335, 0.04982187619991274, 0.08659460523195217, 0.5349273681472132, 0.5608233138328775, 0.5580486714220516, 0.6347943644139149, 0.539827279369887, 0.5332475075308689, 0.5493105490888093, 0.5554043670966604, 0.5828355261909443, 0.0975549475324835, 0.07371310510269091, 0.07844870170343454, 0.11047649431760875, 0.07319122881971218, 0.1397110010173428, 0.0808042678562968, 0.0837729898539803, 0.11945520161749279, 0.36150913438160304, 0.28574593693705885, 0.19676627849551365, 0.22443678062792016, 0.28041332486522574, 0.23695316560530277, 0.2639939801518131, 0.15479250641763664, 0.26115005884082343, 0.24994269307980232, 0.3567176208287153, 0.1771143314228315, 0.32864383882538595, 0.17597453940696783, 0.3809129475689361, 0.299471717889053, 0.2897788240752299, 0.2628517998543357, 0.160279561495686, 0.26863425934195995, 0.24069284098882393, 0.14053270720104105, 0.10365476715021993, 0.222873147464282, 0.20143637082355348, 0.3524513425516005, 0.19767128882268603, 0.23419995870685173, 0.15357095666025522, 0.178340474232334, 0.21965277319294385, 0.2140389040176256, 0.1978776744557973, 0.23391710681570677, 0.20634640830641326, 0.21905141823916952, 0.18290056865304816, 0.2191484355373048, 0.20547323859316746, 0.25854003553726923, 0.17424121100571466, 0.20012108660908434, 0.21404524159083016, 0.22817500036245908, 0.1804196838510176, 0.1874977171340273, 0.1268745231585946, 0.1417758568330617, 0.1736074922141443, 0.20229051128243936, 0.20170426939491104, 0.13208566958097323, 0.1704592737300913, 0.21476638718288932, 0.6650688188160367, 0.1576521262195325, 0.11146944568246675, 0.8973768908339868, 0.6855259441368324, 0.5789261035519111, 0.10546147358305114, 0.10544347239906438, 0.6838849462937344, 0.21012118564084215, 0.1988307401364393, 0.2202783460563451, 0.18767301663864078, 0.19222572573258734, 0.20484572075158003, 0.19042808447384396, 0.19461384769614676, 0.2520893481546572, 0.08420949052377091, 0.10051648950479686, 0.07691143701139425, 0.06449082316434962, 0.06075172895458347, 0.09060282011772847, 0.08026104581564286, 0.057033190457627114, 0.08853300614961312]}, "mutation_prompt": null}
{"id": "3be2d115-04c5-4b78-905a-d41a87327d15", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "eeeadb52-5893-434a-8901-df13594a7f84", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "d5d1759b-7924-4f72-85ef-d2cbdd3114c7", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "cfac47e6-1a49-4f92-87a8-7cd4714126b6", "solution": "import numpy as np\n\nclass RefinedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive mutation based on leader-follower strategy\n            if iteration % 10 == 0:\n                mutation_strength = 0.05 + 0.45 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 5, replace=False)\n                self.positions[mutation_indices] += np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedDynamicMultiSwarmPSO", "description": "Introduce adaptive mutation and leader-follower strategy in multi-swarm PSO to enhance convergence and exploration balance.", "configspace": "", "generation": 14, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.8262836765046121, 0.795789985170936, 0.8127565591420577, 0.5839809081604633, 0.8791814024092514, 0.8502351031148266, 0.8804212525631989, 0.8896639738538109, 0.8752110907174264, 0.6230510643357735, 0.41588960158043164, 0.7049911058966345, 0.6830827619951712, 0.6906210475581503, 0.6539604322902327, 0.6614061072128834, 0.36786653818855575, 0.6273188532547815, 0.3467945616954795, 0.1443025097137286, 0.07308172603910701, 0.11981808870301336, 0.11961400922250265, 0.17186590733546747, 0.12746231567251376, 0.06989176662671726, 0.11241042899332387, 0.13561399709517097, 0.13000522375875767, 0.060679233488836526, 0.1199640977283507, 0.11169456499952557, 0.10113494327126404, 0.09591863911734055, 0.12446715787027429, 0.1211589368120467, 0.9843832239257605, 0.9895374979572322, 0.9887098514378037, 0.969171632808387, 0.9785165245645321, 0.9790920542664734, 0.9836168498204698, 0.9835349762307913, 0.9860084815414542, 0.6993326065681607, 0.7080942672460967, 0.7011191723436092, 0.42636828437502217, 0.608445043378633, 0.6794787825452918, 0.6505367837046898, 0.5090408642469217, 0.5856569507563401, 0.22463182248753222, 0.19832871524868634, 0.24241547943257447, 0.25657612985021605, 0.19438306890056123, 0.19306913561245742, 0.23451681287804427, 0.23663549102434744, 0.832670360604632, 0.16341007787965445, 0.1824119846346789, 0.20236224518059254, 0.19856288491491736, 0.21060134762272742, 0.1427841144164944, 0.19344875244954607, 0.1423251038382014, 0.2055180029318967, 0.237991542596097, 0.11801983827117513, 0.20790409169122204, 0.2057477626414278, 0.4042406350431009, 0.33250034568607845, 0.23356973505000744, 0.22463245081648742, 0.1440414782735997, 9.999999999998899e-05, 9.999999999998899e-05, 0.023332909882444297, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06929915162947997, 0.047712511356369225, 0.0498785391135681, 0.18803636156521952, 0.06108184671275452, 0.030497918819186287, 0.004162294854891835, 0.08829115322037173, 0.07227786427312166, 0.008293421266204914, 0.048543655397500385, 0.033868382720912305, 0.0492319238944019, 0.06039091528724527, 0.07092864117931219, 0.07413402847256911, 0.09172727105365941, 0.08384099773471132, 9.999999999998899e-05, 0.11802577971680583, 0.05261189379554432, 0.19050486647039389, 0.0788456307888693, 0.20164730785909846, 0.11010688971317395, 0.22632813048475764, 0.0457347049645932, 0.08062625040290228, 0.5631141565404113, 0.5686388921063124, 0.5222570211553373, 0.5330848174874838, 0.5510808585550867, 0.5679903051655832, 0.557900496339225, 0.581346925073951, 0.4856336569051132, 0.058962917925717395, 0.07611572831424052, 0.06690303465847935, 0.14910617417063732, 0.12807953670357142, 0.15492921172940566, 0.11219888621834229, 0.14090932328897687, 0.1340114149915782, 0.18842759927101327, 0.29015753232669683, 0.23653747282870408, 0.22812608017476999, 0.14547248109827082, 0.22302635918687397, 0.1894075645155674, 0.2006771862485821, 0.2168361628690817, 0.4115177089662647, 0.3347208293395859, 0.273641785386872, 0.26603331288872356, 0.3462768475269776, 0.510335592517132, 0.2840556136011707, 0.32874344550479395, 0.32645364727337955, 0.2655621082976021, 0.19744859281125726, 0.24947274315633872, 0.16459490743899952, 0.17805434702180556, 0.2526783651753932, 0.26630826998569923, 0.28452658964488897, 0.28698962587348487, 0.20376323292209153, 0.21356533169794356, 0.24098248397978828, 0.22402013923093322, 0.18282881923633842, 0.2081631734284085, 0.23898527610598785, 0.1864804590236281, 0.21590307312031332, 0.2203924785684589, 0.23848452553402988, 0.2416751105903454, 0.21824815656572705, 0.19576887256415343, 0.5504558220908313, 0.24471114809737726, 0.23766832720226794, 0.22619842429657877, 0.1821769676903704, 0.18714662940677995, 0.1510228135282412, 0.8828106794533856, 0.20086847940301522, 0.20004998206706226, 0.12163247034643843, 0.16999851262301324, 0.8519272557737536, 0.6957976286389874, 0.15688330164476227, 0.593786885237398, 0.8106900702530441, 0.5998371514829628, 0.21307021387582836, 0.10520557002961628, 0.10447453703241993, 0.6288443238236763, 0.1749487982224015, 0.1840621272655466, 0.2124998782496914, 0.18780491458875936, 0.19521865128257498, 0.1925570002871978, 0.1995804806922128, 0.18006209055006606, 0.21151930859778523, 0.10498127077674324, 0.08427259108940521, 0.07534538982580485, 0.07669323530414329, 0.09385592637107942, 0.09733527834634459, 0.12625367632098528, 0.08111657166345398, 0.07976197544224706]}, "mutation_prompt": null}
{"id": "34a63247-564f-467a-9a6b-d24e49fba223", "solution": "import numpy as np\n\nclass EnhancedDynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1 = 1.5\n        self.c2 = 2.5\n        self.w_max, self.w_min = 0.9, 0.4\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.sub_swarm_best_positions = np.zeros((self.num_swarms, self.dim))\n        self.sub_swarm_best_scores = np.full(self.num_swarms, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        swarm_indices = np.array_split(np.arange(self.swarm_size), self.num_swarms)\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            for i, idx in enumerate(swarm_indices):\n                sub_scores = scores[idx]\n                sub_best_particle = np.argmin(sub_scores)\n                if sub_scores[sub_best_particle] < self.sub_swarm_best_scores[i]:\n                    self.sub_swarm_best_scores[i] = sub_scores[sub_best_particle]\n                    self.sub_swarm_best_positions[i] = self.positions[idx[sub_best_particle]]\n\n            if np.min(self.sub_swarm_best_scores) < self.global_best_score:\n                best_swarm_index = np.argmin(self.sub_swarm_best_scores)\n                self.global_best_score = self.sub_swarm_best_scores[best_swarm_index]\n                self.global_best_position = self.sub_swarm_best_positions[best_swarm_index]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (iteration / (self.budget // self.swarm_size)))\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Dynamic interaction among sub-swarms\n            if iteration % 5 == 0:\n                for i, indices in enumerate(swarm_indices):\n                    if np.random.rand() < 0.3:\n                        self.positions[indices] += np.random.normal(0, 0.1, self.positions[indices].shape)\n                        self.positions[indices] = np.clip(self.positions[indices], self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedDynamicMultiSwarmPSO", "description": "Enhance multi-swarm PSO utilizing dynamic sub-swarm interactions and adaptive inertia weight for improved convergence and exploration.", "configspace": "", "generation": 25, "fitness": 0.1948595351691382, "feedback": "The algorithm EnhancedDynamicMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.5167145628231093, 0.4810129353202013, 0.4758591095853113, 0.4849733515946364, 0.5143279640426128, 0.46468670827308656, 0.4396883525080417, 0.44597923740483836, 0.4753767666895852, 0.045590485686280546, 0.026787224945499122, 9.999999999998899e-05, 9.999999999998899e-05, 0.16845540744163012, 0.023255070866912364, 0.017419995908223962, 0.008768558822324302, 0.06124623604209756, 0.09031669611407911, 0.12127656071615134, 0.06836669136523121, 0.058580969045953446, 0.0670466558111692, 0.11671120824277736, 0.10240151858957292, 0.118238730756143, 0.11104891490794178, 0.1059967423849748, 0.10263501005471265, 0.09242334777772598, 0.09407198379158066, 0.096440161900617, 0.09465148788649436, 0.10044219131478871, 0.05088833209750432, 0.08990592359959282, 0.9921874684286074, 0.9943529539757129, 0.9942880143706381, 0.9812619998816684, 0.9891270310231433, 0.9001399597593605, 0.994047003165897, 0.992672194168206, 0.9924469872066783, 0.244374325934131, 0.2350711856631308, 0.2442317605825629, 0.22708435924153592, 0.21607592576775536, 0.22822468125443784, 0.19401637272923555, 0.2160242915269942, 0.19710675843353875, 0.2784212845379722, 0.18864308735104796, 0.2374984807960836, 0.5754197276744802, 0.19104808407471163, 0.22393663295203714, 0.1252156223985037, 0.1854470691699024, 0.1130876591784028, 0.1393277008738325, 0.06634535818471232, 0.08549223587851007, 0.10202548937521061, 0.11403059698762341, 0.09121838272556304, 0.11759330519350497, 0.11201956377170552, 0.12183232481474426, 0.11857511074733795, 0.09496124154882124, 0.162055741743935, 0.1480111357558419, 0.1024691614347919, 0.1195485656859262, 0.16605311845765058, 9.999999999998899e-05, 0.1405690883115711, 0.027345846367945903, 9.999999999998899e-05, 0.03653830577913142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0033805693155926075, 9.999999999998899e-05, 9.999999999998899e-05, 0.03814713674131165, 0.006546323075960592, 0.0625792735190851, 0.012680959626371946, 0.011196977411702225, 0.004484818056119555, 0.03166472300927348, 0.04797237186632297, 0.027057685662352005, 0.019201657141484585, 0.018226384319560363, 0.02531454013059753, 0.03387485288542269, 0.0385359049662366, 0.0264424751231912, 0.04054175637736357, 0.054118367235623355, 0.06541742911904114, 0.029529577175980593, 0.03204537282239539, 0.005689387336847762, 0.030072605323790635, 0.003954298436438686, 0.06000879360593592, 0.057262099322262894, 0.04336909050728377, 0.0642104436129628, 0.357695398734438, 0.3775240992728972, 0.3874172499844901, 0.382687686917353, 0.379076618676779, 0.35410292947863453, 0.3900645639743149, 0.30849141814063585, 0.3707206372386693, 0.07702714165470403, 0.0722836091445721, 0.05528395932205443, 0.0845069406989234, 0.1771455636734638, 0.10209198875394654, 0.06835624639877091, 0.09512302266145656, 0.06706096255809824, 0.20036792245603552, 0.1735625021599666, 0.14358855724171005, 0.2078525465111919, 0.2558107882756736, 0.1381148820007918, 0.18124050521830104, 0.19798173896286098, 0.2237058348939156, 0.2818461328332784, 0.22835837472293385, 0.22770622083992076, 0.2649590045289314, 0.19365240265991268, 0.26167782325061284, 0.2638291804349965, 0.3062853615422447, 0.2841990085981879, 0.15651692672923834, 0.16285449751038217, 0.16256649509383592, 0.19714617003463208, 0.173355524234597, 0.19767779218961945, 0.18182845721480312, 0.21632746932810487, 0.210174587826518, 0.19637598911046583, 0.14664718391070253, 0.18848222720158114, 0.18397081383195069, 0.2658113797052932, 0.17405064577607887, 0.19538538805169026, 0.17909088470360635, 0.1933176751211756, 0.19791388535298515, 0.3082814207598238, 0.18066613033446977, 0.1936797917448806, 0.20875842306011883, 0.20806759345221748, 0.19633652917637223, 0.19405002998583043, 0.1987649970337113, 0.16099653124416657, 0.16805569200840909, 0.14536251607498274, 0.6070559204808893, 0.19468520094048913, 0.14688050436035505, 0.09801643293882711, 0.17007378386925542, 0.20411139229379172, 0.3799524816357037, 0.21019740724058233, 0.11036307044466209, 0.1674838659880432, 0.28351832224524565, 0.19748531110181888, 0.21042587041951533, 0.2095861780138022, 0.38375362922774836, 0.1840208509363046, 0.1976228393214291, 0.18331750372637812, 0.18895494416623593, 0.1810752403245025, 0.19861770527446265, 0.20948134274718, 0.20094669879452953, 0.1975240808222024, 0.06828526892233278, 0.062151044085480334, 0.07946587320770637, 0.05982701958020187, 0.07287104057791838, 0.07608177494894097, 0.08946508653744822, 0.0758425944018627, 0.06313268181744058]}, "mutation_prompt": null}
{"id": "aaedff6a-4677-41ff-804e-5b48d6d5a1bc", "solution": "import numpy as np\n\nclass HierarchicalDynamicVelocityClampedPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            if iteration % 15 == 0:  # New mutation strategy\n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "HierarchicalDynamicVelocityClampedPSO", "description": "Enhance the PSO by introducing a hierarchical topology and dynamic velocity clamping to improve exploration and exploitation phases.", "configspace": "", "generation": 26, "fitness": 0.3119036795332541, "feedback": "The algorithm HierarchicalDynamicVelocityClampedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "60b39806-256c-4086-ada9-be96f5a715c0", "metadata": {"aucs": [0.891031724426097, 0.8747545383735276, 0.8686047679056871, 0.8085998533634153, 0.810491967862091, 0.8791705227392093, 0.8222213886605623, 0.8841723767590381, 0.49756859777030427, 0.6435597623232285, 0.037542049150643075, 0.6660108277386627, 0.7332379982090464, 0.6045981018609532, 9.999999999998899e-05, 0.44150486886599005, 0.6116465153169075, 0.1931719254561136, 0.15071798723883656, 0.15703091210284748, 0.14948512434877337, 0.1409582935862045, 0.16651196771106258, 0.16024027637718186, 0.12493224070947195, 0.1470836059750451, 0.08973806809502494, 0.1525892582136077, 0.11525897258677997, 0.08963202029072614, 0.1399970343714909, 0.05230855099450893, 0.1160834661048229, 0.1264077311665608, 0.10614861146468502, 0.07770370870872323, 0.9487843214649488, 0.9468185023342091, 0.9619943642783042, 0.9466378932832633, 0.9524459533791811, 0.9498283985435468, 0.9625291662858647, 0.94585522394372, 0.9335309281388974, 0.7237682730628562, 0.4651630494149438, 0.726761367044676, 0.6488489553424404, 0.7258831038377098, 0.7441779514398923, 0.7599710971063083, 0.6862821904458878, 0.7256619889508742, 0.2282950110248929, 0.11373945727367352, 0.2115549984775451, 0.37306771799496596, 0.21347945204237273, 0.19495672607291692, 0.23349117285383347, 0.17546578605872398, 0.17937613113137973, 0.20241937071635652, 0.23471664873883424, 0.2140511346725833, 0.26297718184771435, 0.13310683909047183, 0.1975942018289486, 0.22168063184660114, 0.26285144604113075, 0.19484362879749872, 0.24030223474570245, 0.18255488721760527, 0.22552629996611773, 0.22205494320587482, 0.12960700795437607, 0.13395549518501737, 0.2573414312688136, 0.192904849200092, 0.237898825909582, 9.999999999998899e-05, 0.023648583921739186, 0.07003514783586484, 0.0517163807427643, 0.0266457702806987, 0.11550336649836812, 9.999999999998899e-05, 0.0044949660902733335, 0.09009735252557671, 0.10258324170916566, 0.07774866794960178, 0.14304969593638528, 0.07768674939662468, 0.018020971748882952, 0.04805668640612637, 0.13461803250357207, 0.09379612315940578, 0.13526411317918496, 0.05773237232966333, 0.15579237596477613, 0.22866704848862407, 0.3349706409262385, 0.12840265181530353, 0.21927139847298627, 0.09495618055121291, 0.1632826090443339, 0.07404955656062995, 0.18560244891641586, 0.035032599442937906, 0.08079185525402577, 0.07914312310860405, 0.06258145353367839, 0.10994369253246183, 0.0987719600466962, 0.09710634040711008, 0.09642662007590008, 0.5879249709128938, 0.5254670160619237, 0.5663032383648747, 0.5318528933883058, 0.5680138927337016, 0.4370726122935754, 0.5497786389426487, 0.5086484531093545, 0.5453568584801408, 0.11477889003389463, 0.09559956736924158, 0.1429319207639268, 0.11472434502431372, 0.08876837156234652, 0.10493686674233649, 0.12452010981098172, 0.14357997362762454, 0.10244346570664453, 0.5121234088577862, 0.3354715167687463, 0.20248660244992345, 0.21892468723674063, 0.34469790425912705, 0.2592349783699778, 0.173729641217787, 0.22831032157319764, 0.3094413834907085, 0.45360381034407704, 0.4149767379912379, 0.33551243758074767, 0.42723843669851236, 0.2185729544624121, 0.403287452690157, 0.5093525804215133, 0.3376496347623613, 0.4620683889245836, 0.22636713923573082, 0.2683623804806411, 0.3194294587388442, 0.287089773730694, 0.23508249255779345, 0.3248703697101041, 0.194114148576077, 0.2427432321741433, 0.19148914607667156, 0.1994004648090636, 0.2050737009017508, 0.18842393251510292, 0.22885840170795024, 0.19668667062128065, 0.2170731315182175, 0.2464939569936424, 0.22317286390598734, 0.23327295879922372, 0.1932528044980536, 0.19751794651811172, 0.22023311375520804, 0.7745201930342696, 0.22746096203286037, 0.20196342646076493, 0.24868349132725276, 0.20070912864370427, 0.21532870941753113, 0.18810775522028222, 0.12643309319711205, 0.1881096975147093, 0.17350298959612698, 0.20143048006883657, 0.9430470140346174, 0.8657860896124278, 0.9270886670706032, 0.9330267322165174, 0.6581416652221861, 0.15578304924569697, 0.7077260360264006, 0.6937673332809537, 0.16938622746203658, 0.21209276265033783, 0.5036301893258603, 0.8750170444701099, 0.16802855908500292, 0.19058227999724064, 0.19437262983996284, 0.17202055890294143, 0.1959655010186503, 0.20834522931765942, 0.19048466300613964, 0.16982044272739427, 0.19401323276145255, 0.19549632995147126, 0.09117082338487703, 0.08052967790038879, 0.09336909641872937, 0.09186638743178432, 0.08939108818979513, 0.11120692144105648, 0.06997884511316099, 0.0752522390181608, 0.08890185204838619]}, "mutation_prompt": null}
{"id": "8fdc411e-f264-4c99-8f11-ccee55b6afbb", "solution": "import numpy as np\n\nclass HierarchicalDynamicVelocityClampedPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            if iteration % 15 == 0:  # New mutation strategy\n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "HierarchicalDynamicVelocityClampedPSO", "description": "Enhance the PSO by introducing a hierarchical topology and dynamic velocity clamping to improve exploration and exploitation phases.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aaedff6a-4677-41ff-804e-5b48d6d5a1bc", "metadata": {"aucs": [0.891031724426097, 0.8747545383735276, 0.8686047679056871, 0.8085998533634153, 0.810491967862091, 0.8791705227392093, 0.8222213886605623, 0.8841723767590381, 0.49756859777030427, 0.6435597623232285, 0.037542049150643075, 0.6660108277386627, 0.7332379982090464, 0.6045981018609532, 9.999999999998899e-05, 0.44150486886599005, 0.6116465153169075, 0.1931719254561136, 0.15071798723883656, 0.15703091210284748, 0.14948512434877337, 0.1409582935862045, 0.16651196771106258, 0.16024027637718186, 0.12493224070947195, 0.1470836059750451, 0.08973806809502494, 0.1525892582136077, 0.11525897258677997, 0.08963202029072614, 0.1399970343714909, 0.05230855099450893, 0.1160834661048229, 0.1264077311665608, 0.10614861146468502, 0.07770370870872323, 0.9487843214649488, 0.9468185023342091, 0.9619943642783042, 0.9466378932832633, 0.9524459533791811, 0.9498283985435468, 0.9625291662858647, 0.94585522394372, 0.9335309281388974, 0.7237682730628562, 0.4651630494149438, 0.726761367044676, 0.6488489553424404, 0.7258831038377098, 0.7441779514398923, 0.7599710971063083, 0.6862821904458878, 0.7256619889508742, 0.2282950110248929, 0.11373945727367352, 0.2115549984775451, 0.37306771799496596, 0.21347945204237273, 0.19495672607291692, 0.23349117285383347, 0.17546578605872398, 0.17937613113137973, 0.20241937071635652, 0.23471664873883424, 0.2140511346725833, 0.26297718184771435, 0.13310683909047183, 0.1975942018289486, 0.22168063184660114, 0.26285144604113075, 0.19484362879749872, 0.24030223474570245, 0.18255488721760527, 0.22552629996611773, 0.22205494320587482, 0.12960700795437607, 0.13395549518501737, 0.2573414312688136, 0.192904849200092, 0.237898825909582, 9.999999999998899e-05, 0.023648583921739186, 0.07003514783586484, 0.0517163807427643, 0.0266457702806987, 0.11550336649836812, 9.999999999998899e-05, 0.0044949660902733335, 0.09009735252557671, 0.10258324170916566, 0.07774866794960178, 0.14304969593638528, 0.07768674939662468, 0.018020971748882952, 0.04805668640612637, 0.13461803250357207, 0.09379612315940578, 0.13526411317918496, 0.05773237232966333, 0.15579237596477613, 0.22866704848862407, 0.3349706409262385, 0.12840265181530353, 0.21927139847298627, 0.09495618055121291, 0.1632826090443339, 0.07404955656062995, 0.18560244891641586, 0.035032599442937906, 0.08079185525402577, 0.07914312310860405, 0.06258145353367839, 0.10994369253246183, 0.0987719600466962, 0.09710634040711008, 0.09642662007590008, 0.5879249709128938, 0.5254670160619237, 0.5663032383648747, 0.5318528933883058, 0.5680138927337016, 0.4370726122935754, 0.5497786389426487, 0.5086484531093545, 0.5453568584801408, 0.11477889003389463, 0.09559956736924158, 0.1429319207639268, 0.11472434502431372, 0.08876837156234652, 0.10493686674233649, 0.12452010981098172, 0.14357997362762454, 0.10244346570664453, 0.5121234088577862, 0.3354715167687463, 0.20248660244992345, 0.21892468723674063, 0.34469790425912705, 0.2592349783699778, 0.173729641217787, 0.22831032157319764, 0.3094413834907085, 0.45360381034407704, 0.4149767379912379, 0.33551243758074767, 0.42723843669851236, 0.2185729544624121, 0.403287452690157, 0.5093525804215133, 0.3376496347623613, 0.4620683889245836, 0.22636713923573082, 0.2683623804806411, 0.3194294587388442, 0.287089773730694, 0.23508249255779345, 0.3248703697101041, 0.194114148576077, 0.2427432321741433, 0.19148914607667156, 0.1994004648090636, 0.2050737009017508, 0.18842393251510292, 0.22885840170795024, 0.19668667062128065, 0.2170731315182175, 0.2464939569936424, 0.22317286390598734, 0.23327295879922372, 0.1932528044980536, 0.19751794651811172, 0.22023311375520804, 0.7745201930342696, 0.22746096203286037, 0.20196342646076493, 0.24868349132725276, 0.20070912864370427, 0.21532870941753113, 0.18810775522028222, 0.12643309319711205, 0.1881096975147093, 0.17350298959612698, 0.20143048006883657, 0.9430470140346174, 0.8657860896124278, 0.9270886670706032, 0.9330267322165174, 0.6581416652221861, 0.15578304924569697, 0.7077260360264006, 0.6937673332809537, 0.16938622746203658, 0.21209276265033783, 0.5036301893258603, 0.8750170444701099, 0.16802855908500292, 0.19058227999724064, 0.19437262983996284, 0.17202055890294143, 0.1959655010186503, 0.20834522931765942, 0.19048466300613964, 0.16982044272739427, 0.19401323276145255, 0.19549632995147126, 0.09117082338487703, 0.08052967790038879, 0.09336909641872937, 0.09186638743178432, 0.08939108818979513, 0.11120692144105648, 0.06997884511316099, 0.0752522390181608, 0.08890185204838619]}, "mutation_prompt": null}
{"id": "2e5b4bed-e2d9-42b5-add6-501575c211c9", "solution": "import numpy as np\n\nclass AdaptiveInertiaDynamicSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.0, 3.0\n        self.c2_min, self.c2_max = 1.0, 3.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n        self.w_initial, self.w_final = 0.9, 0.4\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_initial - (self.w_initial - self.w_final) * (iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            if iteration % 10 == 0:  # Dynamic swarm regrouping\n                regroup_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                self.positions[regroup_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(regroup_indices), self.dim))\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveInertiaDynamicSwarmPSO", "description": "Introduce adaptive inertia weights and dynamic swarm regrouping to enhance exploration and convergence in PSO.", "configspace": "", "generation": 28, "fitness": 0.21214148166309932, "feedback": "The algorithm AdaptiveInertiaDynamicSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "aaedff6a-4677-41ff-804e-5b48d6d5a1bc", "metadata": {"aucs": [0.38470978097387054, 0.3780778566095556, 0.38841708075304227, 0.3877132439634472, 0.4064087064583384, 0.3949431091195714, 0.403784523048766, 0.36704731400901147, 0.4566717733852884, 0.06365346936091099, 0.06259591453525704, 0.04783487088481575, 0.04711825153754268, 0.0015462821681868633, 0.04527137340026732, 0.015361483666414988, 0.13058149799748076, 0.08886623951841488, 0.113708949849746, 0.09813044558286799, 0.08564051628395686, 0.06715386016323499, 0.10721739411023534, 0.09790167174752518, 0.1117101073694472, 0.11417089736161234, 0.11573485911382109, 0.08683086572952126, 0.07329961558890774, 0.08824012661989877, 0.08062653933256769, 0.08266124632137695, 0.08143155148046421, 0.09533825157693976, 0.08192808964404319, 0.09210076583631943, 0.9723388918183947, 0.9562994896399895, 0.9716264180280555, 0.9570475224782353, 0.9643707878565612, 0.9669498212119279, 0.9649979702133417, 0.958997228899434, 0.9485307975670735, 0.24771050639310177, 0.2585585777309266, 0.2300248641512861, 0.22658283974177906, 0.256943655025901, 0.234343579905125, 0.2335304628734618, 0.24581419941089344, 0.21846111964664328, 0.3237190552563508, 0.27803163180743384, 0.22889223785384716, 0.20140614373222343, 0.25242157261556575, 0.19524941100332982, 0.30772768403819206, 0.2892659558880323, 0.2861690081260836, 0.1310278718793796, 0.12821968483288293, 0.14421743211368465, 0.14579937734903414, 0.11852694872044756, 0.1601791742907297, 0.13447182930704527, 0.1621713166785046, 0.15135743416584924, 0.13033249011702608, 0.15428207627035861, 0.12975699717347833, 0.1336056610215779, 0.11717374850629125, 0.12847190874380776, 0.14451964272364726, 0.15643302180212926, 0.11364407822697908, 0.00012545180924594668, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009137097490720003, 9.999999999998899e-05, 0.03648031612089331, 0.010427189556539762, 9.999999999998899e-05, 0.1154095209188627, 0.09144281597274961, 0.17175046076578926, 0.09103238127560087, 0.020740324638397256, 0.06782114328561206, 0.16107268164226318, 0.08603692017076214, 0.1231517972289754, 9.999999999998899e-05, 0.01115846629941497, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028925007328740815, 9.999999999998899e-05, 0.07200366369411093, 0.08392172864127556, 0.050954204091352207, 0.08579317205200476, 0.0014923824178536549, 0.040405732834924546, 0.07517297632326825, 0.05023715109324878, 0.061726092466779514, 0.3454399436721396, 0.40685132391745693, 0.3447478212480224, 0.3618334410674945, 0.3485774938552446, 0.34162169141441756, 0.3452162833159069, 0.3297012797106471, 0.4109304268580749, 0.08388892048455476, 0.08499738298388726, 0.12351223649422483, 0.1024721253039923, 0.12844163858208157, 0.10057940375763352, 0.10270712651002889, 0.10399980438217338, 0.08129245308666211, 0.15432013712560633, 0.1658101922005688, 0.17661531971167355, 0.19753702605542944, 0.18637257387346917, 0.1804647801452931, 0.16110727697174754, 0.17728486843877778, 0.1540339258693626, 0.24201380386985272, 0.25094089444626855, 0.26592528859078035, 0.2535818843446297, 0.2375107274295093, 0.2548834062843013, 0.23715717587965124, 0.24355381480515748, 0.2670932415258451, 0.1841215598065371, 0.1753189482387878, 0.21542198656036116, 0.18505007545964214, 0.17301873750991958, 0.19358556254087755, 0.1797952771173008, 0.19253213665953572, 0.179364846524795, 0.22178770052311236, 0.22367035318708017, 0.23492795101305297, 0.21824981856336034, 0.23765074776963835, 0.25989768968815874, 0.20089301999316045, 0.2294157613843002, 0.2150498366371898, 0.1893592512797454, 0.19154952031498518, 0.21330969728778948, 0.19509580191881537, 0.20804318851533465, 0.18567088553045175, 0.18463286079511632, 0.1793383541230119, 0.20609671730909662, 0.47987360576002036, 0.4626316868255983, 0.18682339831503658, 0.6683058622254917, 0.20880722802728946, 0.5917994011956158, 0.5020419667431155, 0.1687378651315412, 0.5743136733018024, 0.47243904859230934, 0.4344497718211757, 0.20277305217490438, 0.20634343581533798, 0.5176855800809055, 0.20976498024334866, 0.43841099785000637, 0.22866483402925442, 0.42251600953327284, 0.1824275167664574, 0.18992910853513623, 0.18158645603379775, 0.18876522728737843, 0.18796226427683382, 0.19948233347430344, 0.1937956172367934, 0.19565231102778813, 0.19129258319089903, 0.10103732154520384, 0.07835399222767592, 0.06784217519476987, 0.08624005318711137, 0.09152772610171289, 0.07490431761247707, 0.08713213108297446, 0.08278046401140238, 0.08735129224889093]}, "mutation_prompt": null}
{"id": "2ec55853-d410-494a-ba98-d1cdee95253f", "solution": "import numpy as np\n\nclass HierarchicalDynamicVelocityClampedPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            if iteration % 15 == 0:  # New mutation strategy\n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "HierarchicalDynamicVelocityClampedPSO", "description": "Enhance the PSO by introducing a hierarchical topology and dynamic velocity clamping to improve exploration and exploitation phases.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aaedff6a-4677-41ff-804e-5b48d6d5a1bc", "metadata": {"aucs": [0.891031724426097, 0.8747545383735276, 0.8686047679056871, 0.8085998533634153, 0.810491967862091, 0.8791705227392093, 0.8222213886605623, 0.8841723767590381, 0.49756859777030427, 0.6435597623232285, 0.037542049150643075, 0.6660108277386627, 0.7332379982090464, 0.6045981018609532, 9.999999999998899e-05, 0.44150486886599005, 0.6116465153169075, 0.1931719254561136, 0.15071798723883656, 0.15703091210284748, 0.14948512434877337, 0.1409582935862045, 0.16651196771106258, 0.16024027637718186, 0.12493224070947195, 0.1470836059750451, 0.08973806809502494, 0.1525892582136077, 0.11525897258677997, 0.08963202029072614, 0.1399970343714909, 0.05230855099450893, 0.1160834661048229, 0.1264077311665608, 0.10614861146468502, 0.07770370870872323, 0.9487843214649488, 0.9468185023342091, 0.9619943642783042, 0.9466378932832633, 0.9524459533791811, 0.9498283985435468, 0.9625291662858647, 0.94585522394372, 0.9335309281388974, 0.7237682730628562, 0.4651630494149438, 0.726761367044676, 0.6488489553424404, 0.7258831038377098, 0.7441779514398923, 0.7599710971063083, 0.6862821904458878, 0.7256619889508742, 0.2282950110248929, 0.11373945727367352, 0.2115549984775451, 0.37306771799496596, 0.21347945204237273, 0.19495672607291692, 0.23349117285383347, 0.17546578605872398, 0.17937613113137973, 0.20241937071635652, 0.23471664873883424, 0.2140511346725833, 0.26297718184771435, 0.13310683909047183, 0.1975942018289486, 0.22168063184660114, 0.26285144604113075, 0.19484362879749872, 0.24030223474570245, 0.18255488721760527, 0.22552629996611773, 0.22205494320587482, 0.12960700795437607, 0.13395549518501737, 0.2573414312688136, 0.192904849200092, 0.237898825909582, 9.999999999998899e-05, 0.023648583921739186, 0.07003514783586484, 0.0517163807427643, 0.0266457702806987, 0.11550336649836812, 9.999999999998899e-05, 0.0044949660902733335, 0.09009735252557671, 0.10258324170916566, 0.07774866794960178, 0.14304969593638528, 0.07768674939662468, 0.018020971748882952, 0.04805668640612637, 0.13461803250357207, 0.09379612315940578, 0.13526411317918496, 0.05773237232966333, 0.15579237596477613, 0.22866704848862407, 0.3349706409262385, 0.12840265181530353, 0.21927139847298627, 0.09495618055121291, 0.1632826090443339, 0.07404955656062995, 0.18560244891641586, 0.035032599442937906, 0.08079185525402577, 0.07914312310860405, 0.06258145353367839, 0.10994369253246183, 0.0987719600466962, 0.09710634040711008, 0.09642662007590008, 0.5879249709128938, 0.5254670160619237, 0.5663032383648747, 0.5318528933883058, 0.5680138927337016, 0.4370726122935754, 0.5497786389426487, 0.5086484531093545, 0.5453568584801408, 0.11477889003389463, 0.09559956736924158, 0.1429319207639268, 0.11472434502431372, 0.08876837156234652, 0.10493686674233649, 0.12452010981098172, 0.14357997362762454, 0.10244346570664453, 0.5121234088577862, 0.3354715167687463, 0.20248660244992345, 0.21892468723674063, 0.34469790425912705, 0.2592349783699778, 0.173729641217787, 0.22831032157319764, 0.3094413834907085, 0.45360381034407704, 0.4149767379912379, 0.33551243758074767, 0.42723843669851236, 0.2185729544624121, 0.403287452690157, 0.5093525804215133, 0.3376496347623613, 0.4620683889245836, 0.22636713923573082, 0.2683623804806411, 0.3194294587388442, 0.287089773730694, 0.23508249255779345, 0.3248703697101041, 0.194114148576077, 0.2427432321741433, 0.19148914607667156, 0.1994004648090636, 0.2050737009017508, 0.18842393251510292, 0.22885840170795024, 0.19668667062128065, 0.2170731315182175, 0.2464939569936424, 0.22317286390598734, 0.23327295879922372, 0.1932528044980536, 0.19751794651811172, 0.22023311375520804, 0.7745201930342696, 0.22746096203286037, 0.20196342646076493, 0.24868349132725276, 0.20070912864370427, 0.21532870941753113, 0.18810775522028222, 0.12643309319711205, 0.1881096975147093, 0.17350298959612698, 0.20143048006883657, 0.9430470140346174, 0.8657860896124278, 0.9270886670706032, 0.9330267322165174, 0.6581416652221861, 0.15578304924569697, 0.7077260360264006, 0.6937673332809537, 0.16938622746203658, 0.21209276265033783, 0.5036301893258603, 0.8750170444701099, 0.16802855908500292, 0.19058227999724064, 0.19437262983996284, 0.17202055890294143, 0.1959655010186503, 0.20834522931765942, 0.19048466300613964, 0.16982044272739427, 0.19401323276145255, 0.19549632995147126, 0.09117082338487703, 0.08052967790038879, 0.09336909641872937, 0.09186638743178432, 0.08939108818979513, 0.11120692144105648, 0.06997884511316099, 0.0752522390181608, 0.08890185204838619]}, "mutation_prompt": null}
{"id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 30, "fitness": 0.3122584068938372, "feedback": "The algorithm AdaptiveHybridMutationPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "aaedff6a-4677-41ff-804e-5b48d6d5a1bc", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "467783a2-667c-44e6-8af4-bf0992176466", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "08ce181a-bf35-4b16-bd46-c7855c649ac4", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "325249af-add4-4e01-8425-c7bb520e602e", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "d29ff91f-1396-40fa-b9f6-51f579952f7b", "solution": "import numpy as np\n\nclass AdaptiveSelfAdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n        self.inertia_weights = np.random.uniform(0.4, 0.9, self.swarm_size)\n        self.cognitive_factors = np.random.uniform(1.5, 2.5, self.swarm_size)\n        self.social_factors = np.random.uniform(1.5, 2.5, self.swarm_size)\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            # Self-adaptive parameters\n            self.inertia_weights += np.random.normal(0, 0.1, self.swarm_size)\n            self.cognitive_factors += np.random.normal(0, 0.1, self.swarm_size)\n            self.social_factors += np.random.normal(0, 0.1, self.swarm_size)\n            self.inertia_weights = np.clip(self.inertia_weights, 0.4, 0.9)\n            self.cognitive_factors = np.clip(self.cognitive_factors, 1.5, 2.5)\n            self.social_factors = np.clip(self.social_factors, 1.5, 2.5)\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.cognitive_factors[:, None] * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.social_factors[:, None] * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.inertia_weights[:, None] * (self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Adaptive topology and mutation strategy\n            if iteration % 10 == 0:\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / np.random.randint(1, 5))\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        self.inertia_weights[i] = 0.7\n\n            if iteration % 15 == 0:\n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + gaussian_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveSelfAdaptivePSO", "description": "Combine adaptive topology, hybrid mutation, and self-adaptive swarm dynamics in PSO to enhance exploration and convergence in black box optimization.", "configspace": "", "generation": 34, "fitness": 0.29788210697463746, "feedback": "The algorithm AdaptiveSelfAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.9164716685673566, 0.8671353759443652, 0.8691472012903676, 0.8958632617810779, 0.8319055800741211, 0.7325492517464605, 0.8640473499494186, 0.8198205656775962, 0.818443453983359, 0.3318110387383567, 0.3297179234113642, 0.27129160989472434, 0.5101534740487389, 0.44031866452464363, 0.5384827253087372, 0.5124437936510109, 0.49910411522828524, 0.28301947567507446, 0.12046002502745867, 0.11027970252606611, 0.1294864268473197, 0.11784160499914209, 0.12257169835156234, 0.14485020575327834, 0.08499753566889634, 0.19311677083006606, 0.14663048788287036, 0.12058077026393221, 0.12901390368961674, 0.11228989829341463, 0.11891309651306836, 0.12409647014871805, 0.10606313986176852, 0.1247675664930501, 0.09796432997785143, 0.14567370459165374, 0.9672691159206841, 0.9693755575629746, 0.9633208187771501, 0.9567325275955362, 0.9697791719642066, 0.970085906835042, 0.9701097878668221, 0.9650855681430083, 0.9647367810556058, 0.5650344089199717, 0.5062195135930901, 0.44584685641144295, 0.7039049984556046, 0.603517838265154, 0.4764263303319465, 0.6166519672202238, 0.442504309980444, 0.581920100592868, 0.7611685432035734, 0.17183377152226076, 0.2233690167466017, 0.3551983542977031, 0.4469556623618274, 0.21810805180933024, 0.3421943683813631, 0.2286771062153482, 0.2203504910551547, 0.2392249711749348, 0.13464444459571656, 0.20766000896501924, 0.21162571018465637, 0.17928274842350678, 0.31833092074897973, 0.20935006040442672, 0.26008911010201763, 0.1952403326942712, 0.2295158291019388, 0.23921920492323234, 0.19417987784520963, 0.13550378207798475, 0.21421964286341633, 0.22095694902786123, 0.2417434363726414, 0.22531333341371906, 0.3831368709270334, 0.03494987524601423, 9.999999999998899e-05, 0.07823058444610109, 0.03477980454631291, 0.006116490796529095, 0.02368218753802176, 0.00855556336785046, 9.999999999998899e-05, 0.004804034729356643, 0.08090825309124827, 0.06425559653529145, 0.11939811286034419, 0.08436446343847437, 0.05353850115935077, 0.015775998501849076, 0.14608350619189736, 0.12790814042080512, 0.08890936947055583, 0.1398407958084763, 0.3078947507401617, 0.1645904332094713, 0.13787942998840153, 0.30153524747920757, 0.2121317971688429, 0.055753817129646444, 0.13640425307370674, 0.08231730430970219, 0.15809218527634095, 0.0853194220987149, 0.1947295827667449, 0.1562254965535239, 0.047914035357207285, 0.1360048686772778, 0.12449046634454841, 0.1639217306157128, 0.07150922445903252, 0.5050619286661975, 0.5082676163805323, 0.500255825065471, 0.5588085474417099, 0.5284259148398285, 0.519587521565521, 0.5125948058052567, 0.5223755258958911, 0.5436374667084976, 0.0762731782375855, 0.08700754625810736, 0.15934294635426216, 0.1578002715916509, 0.0956370168440479, 0.13714003870065572, 0.08911541974092396, 0.15239782027214444, 0.1152014465029979, 0.2653182124207585, 0.32438696340912565, 0.2368285460552887, 0.32395581230293025, 0.33592016946913017, 0.18918748468136537, 0.20578012124311662, 0.4489677003163738, 0.3217963563415145, 0.2952371759233059, 0.376180519701226, 0.2624458423363901, 0.28499338499205806, 0.296694833893697, 0.358404152387351, 0.4801932951708986, 0.4108277194714167, 0.26984112019782247, 0.2651678092922102, 0.248240406253612, 0.23207700086708227, 0.250355890722309, 0.1845488813088476, 0.33669144428021425, 0.22146640713250076, 0.35125760928153027, 0.21814304617590263, 0.21858596856896872, 0.233505587748428, 0.221384861544778, 0.2934191106093713, 0.23984305978366627, 0.22724643338475425, 0.2356194220713691, 0.25637626731708374, 0.22059134765600563, 0.20736526110382825, 0.21386755042747418, 0.2107059398856017, 0.23042733179958785, 0.21448340745224426, 0.23329530116547603, 0.20907427499331233, 0.19651598238767998, 0.19670192242193563, 0.12525566978372593, 0.12670540096738026, 0.18777759127729787, 0.1732030367420213, 0.20179165226556783, 0.20008114352853068, 0.9037280909440416, 0.16995658924503587, 0.16858656396321492, 0.6478778556689777, 0.15748146638897376, 0.6894052162416099, 0.2113273867981087, 0.16916712235255782, 0.8299859202736607, 0.10512295291103024, 0.16559308875827083, 0.6684325294495514, 0.19715620852420712, 0.18542946877985889, 0.23163723278340176, 0.1896861773481946, 0.185004848900566, 0.21652388333987005, 0.2292052184001292, 0.18883960201140215, 0.22795382927234364, 0.08305928382112893, 0.10290725663600775, 0.11530628321237413, 0.09902465151493456, 0.09375906301295289, 0.10440796054445822, 0.08913392088692074, 0.1145300524748929, 0.0886897651346431]}, "mutation_prompt": null}
{"id": "046762df-ec95-4c61-9dd4-fc61a53e1d51", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "a4e1bd8c-353b-48ee-9fc8-6d6696eb8ca2", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "8d0637b4-fa75-4891-b2bc-4564f9e4e4fb", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "d773a12c-c19c-41b4-8a6c-2292686f1991", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "ad2dd4e3-acca-4c20-a16c-85613672b49e", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "9280f21f-4c74-4e3f-8b54-f22c1268fd6a", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "0c370963-8d5d-48fe-9ff3-e43bf5ead86c", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "f6e51e5f-5239-435f-a76e-c951c40c6eed", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "9ee29d6f-adc0-4485-8237-e7a2018220e6", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "6dca1329-09a8-4abf-96b5-cecc9bfe15dd", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "c5d33ca6-2cc5-4779-a373-6c434d235562", "solution": "import numpy as np\n\nclass EnhancedMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 4  # Increase diversity with more sub-swarms\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1, self.c2 = 2.0, 2.0  # Fix cognitive and social coefficients for simplicity\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = np.exp(-0.5 * (iteration / (self.budget // self.swarm_size)))  # Adaptive inertia weight\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Multi-swarm strategy\n            if iteration % 5 == 0:\n                swarms = np.array_split(np.arange(self.swarm_size), self.num_swarms)\n                for swarm in swarms:\n                    swarm_scores = scores[swarm]\n                    swarm_best_idx = swarm[np.argmin(swarm_scores)]\n                    if scores[swarm_best_idx] < self.global_best_score:\n                        self.global_best_score = scores[swarm_best_idx]\n                        self.global_best_position = self.positions[swarm_best_idx]\n\n            # Lévy flight mutation\n            if iteration % 20 == 0:\n                mutation_strength = np.random.standard_cauchy((self.swarm_size, self.dim)) * 0.1\n                self.positions += mutation_strength\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiSwarmPSO", "description": "Enhance PSO with multi-swarm strategy, adaptive inertia, and Lévy flight mutation to improve convergence and exploration.", "configspace": "", "generation": 45, "fitness": 0.22149557440097617, "feedback": "The algorithm EnhancedMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.5343227065927703, 0.41835554638069194, 0.5073039342880057, 0.43897240027315254, 0.456078147536381, 0.44764716436997454, 0.4666677379057038, 0.4600963223467628, 0.4235369222061035, 0.06462984004286587, 0.05119106407349938, 0.07972211726088485, 0.0064589873783222895, 0.04612605213280008, 9.999999999998899e-05, 9.999999999998899e-05, 0.014491942193185392, 0.139833027191672, 0.11425766395867198, 0.1031646189294162, 0.1252011599480678, 0.10316387177618602, 0.11023240347661689, 0.14143999150481978, 0.11139610636828545, 0.11438497274449166, 0.12081246465853479, 0.0737621232245147, 0.061339100124235824, 0.09277025133586758, 0.1047929184917683, 0.06492828598677902, 0.09991078247469143, 0.10160784060754702, 0.08129095130238384, 0.09056668532785006, 0.9540373982723344, 0.9680096070010421, 0.963970714891773, 0.957126694155336, 0.9642487086627811, 0.9695585119512724, 0.9732531476385042, 0.9533955493443096, 0.9669835748308965, 0.3394140829352621, 0.20285646419389447, 0.3067949774297801, 0.20999741734790345, 0.31369062076622023, 0.32078252122945705, 0.3268284013368431, 0.16728114181902676, 0.30356056974982515, 0.36736263016198845, 0.13959214964040179, 0.3456558471208181, 0.3758882291663751, 0.3220662906312327, 0.26994380970255616, 0.13115787004359203, 0.1311681976368423, 0.3730706148376839, 0.15959588525756552, 0.12676827278568126, 0.15576130480796324, 0.13457411897766558, 0.14718153691463376, 0.153620135333846, 0.15370882947430686, 0.15401418005734846, 0.1597245971218757, 0.16204209873947006, 0.16101949417991124, 0.1377275990424247, 0.14424546816885608, 0.13425824471732506, 0.13692803531079623, 0.15567410398853587, 0.12848673698610058, 0.18169705971495986, 9.999999999998899e-05, 9.999999999998899e-05, 0.017253975825321732, 0.04262481867553036, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07729731887898184, 0.0626523926758884, 0.0575575497664913, 0.09119943270099862, 0.027523283670810583, 0.042351668487755734, 0.01996869632421605, 0.09346741022370209, 0.06303158581560564, 0.07267135863212393, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10694054770764483, 0.0654533441027565, 0.09278850538772154, 0.08600392245401489, 0.09333770922082185, 0.05302057381574543, 0.054990789855903, 0.0687451600992901, 0.11681883765301515, 0.3413548700052417, 0.43920752707693267, 0.35809638185367954, 0.3993783106245774, 0.4319889182609836, 0.44597326024120854, 0.38473221634447197, 0.41369814602106114, 0.3842173040360859, 0.11313180208029994, 0.12701285532893458, 0.07753505518494697, 0.1062142005750547, 0.10659603340712076, 0.0887480389685068, 0.09734651195721744, 0.12606887092765284, 0.08176457804150072, 0.1683932030518276, 0.11786289991129362, 0.24488191184241204, 0.20963860122590705, 0.21219775402097307, 0.21765445959159502, 0.2889353815548301, 0.22407106009984057, 0.2407175511466645, 0.33692799287747477, 0.24082831708843633, 0.2660086201233315, 0.2705843312601115, 0.23382325281023875, 0.3248937664003472, 0.2423338342269855, 0.24234320201964865, 0.23910484109028496, 0.1893093075406418, 0.22081059439979267, 0.26595793241115184, 0.1829813099624159, 0.18295692015881948, 0.26048936104644504, 0.17295387844761811, 0.24938899289005179, 0.15810132386774367, 0.21109956700597376, 0.1857220385571594, 0.13345086981233123, 0.22137956360744693, 0.224607081540395, 0.21449431041946077, 0.2068750840885002, 0.17374451830961735, 0.2053901346102356, 0.21668667028664446, 0.17199932356490644, 0.19444713830428306, 0.2899066312302503, 0.20977143625087258, 0.18758566792801845, 0.2213366910581125, 0.235624139933455, 0.23956571466962573, 0.6880401775355705, 0.12407636120337195, 0.14691349748030758, 0.739372850670984, 0.20102011449470303, 0.1999978220069003, 0.7599504533471546, 0.6608490425334698, 0.4570987647390078, 0.45657881696698954, 0.148405040229597, 0.5153067323859115, 0.6134792387412444, 0.1540210068189517, 0.21224528086281458, 0.1052044359883414, 0.16827369962781324, 0.522144508775702, 0.19325646051151857, 0.17670512811383776, 0.18511872400576845, 0.1861054876980155, 0.1861341737313683, 0.17169796183030195, 0.18996628826535733, 0.19116054910566604, 0.16601485829740936, 0.08805035240275794, 0.08945557756558997, 0.08440928852403395, 0.08808935910062443, 0.07642850818852243, 0.07288238424687499, 0.0912716324598859, 0.08518542964056064, 0.09465356886921394]}, "mutation_prompt": null}
{"id": "16423765-81e9-463f-b455-bc0a3315980c", "solution": "import numpy as np\n\nclass RefinedAdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1, self.c2 = 2.0, 2.0\n        self.w_min, self.w_max = 0.5, 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            if scores[best_particle] < self.global_best_score:\n                self.global_best_score = scores[best_particle]\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (iteration / (self.budget // self.swarm_size)))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Neighborhood-based updating\n            if iteration % 5 == 0:\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / 4)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        self.velocities[i] *= 0.8 \n                    else:\n                        self.velocities[i] *= 1.2 \n\n            # Dynamic mutation strategy\n            if iteration % 10 == 0: \n                mutation_strength = 0.1 + 0.3 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + gaussian_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "RefinedAdaptivePSO", "description": "Enhance exploration and exploitation balance in PSO through strategic neighborhood-based updating and dynamic mutation hybridity.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation minimum which has no identity').", "error": "ValueError('zero-size array to reduction operation minimum which has no identity')", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {}, "mutation_prompt": null}
{"id": "807bfc2c-79f8-465a-9166-7049a8f76c6e", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "ceed1481-4a6a-42a2-9a8e-305464aa0c32", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "50b1e761-e5e7-40b9-9753-8eee2336f77b", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "cfea6608-a417-43c9-af06-017509bc4b91", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "9ebff59c-e0ce-431a-9e84-37965e82fb62", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "84ec50f4-ecfc-46d3-9aa9-0297f7a09f45", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "25d37b62-a13c-47c5-9d9e-d181776ad93e", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "3d4e3a46-5bc9-4446-b75b-f0561ae946fa", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "a1ddb126-7e06-4b7b-a12d-a35d36845bd1", "solution": "import numpy as np\n\nclass EnhancedPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_base, self.c2_base = 2.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            if scores[best_particle] < self.global_best_score:\n                self.global_best_score = scores[best_particle]\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (self.evaluations / self.budget))\n            c1 = self.c1_base * (0.5 + 0.5 * np.random.rand())\n            c2 = self.c2_base * (0.5 + 0.5 * np.random.rand())\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Swarm diversity control\n            diversity = np.mean(np.std(self.positions, axis=0))\n            if diversity < 1e-3:\n                self.positions += np.random.uniform(-0.1, 0.1, self.positions.shape)\n\n            # Dynamic mutation strategy\n            if iteration % 20 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                mutation_strength = (0.05 + 0.45 * np.exp(-1.0 * (iteration / (self.budget // self.swarm_size))))\n                mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedPSO", "description": "Integrate swarm diversity control and dynamic learning coefficients in PSO to balance exploration and exploitation effectively.", "configspace": "", "generation": 55, "fitness": 0.2574840232972705, "feedback": "The algorithm EnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.5825823963550756, 0.5037676175040764, 0.5834657375344217, 0.5694601468867048, 0.5687920095336754, 0.5868213744661528, 0.5476433379038124, 0.5845408832670099, 0.5490472646361186, 0.23491295102529952, 0.2720634739261869, 0.25534320638638797, 0.1364941365746707, 0.19575577928379528, 0.20461212520731886, 0.22610184534687783, 0.18494498272355153, 0.1646159326206682, 0.14083294559178794, 0.1143430212022204, 0.13068197767146972, 0.2255296139202384, 0.13668462437554063, 0.11341387663514158, 0.14916059422869676, 0.19160102288322078, 0.14548818283316856, 0.13138095266236938, 0.09361711204398038, 0.10490145368908199, 0.12090449875218112, 0.10760169900604855, 0.11013773028642315, 0.10127465086435294, 0.10466542320467054, 0.09895710757936793, 0.9696305950702954, 0.9700906683505027, 0.9672750830308964, 0.9629192374446418, 0.9724957932880002, 0.9628620217791745, 0.9731411975136519, 0.961689695868041, 0.9731710281630653, 0.34244752805169465, 0.31789896505240045, 0.38284435877512146, 0.32564738775302626, 0.350180114451911, 0.33216120759914014, 0.3532328949600704, 0.3541245746409015, 0.34333995809295026, 0.4994744573258244, 0.40854156698777644, 0.38873256373993204, 0.3234508777235514, 0.24801363185796976, 0.24493852836241858, 0.36129962809107075, 0.19582606681236103, 0.59650150644676, 0.18453479157257557, 0.17567215343340503, 0.15363260244786814, 0.19241359343466102, 0.15029155365388047, 0.16081926611763753, 0.17509070536902271, 0.14111019931668378, 0.15604368744878283, 0.18546549175093563, 0.13919389003795035, 0.17695679014224863, 0.14806968323063174, 0.16651239886107105, 0.15073732897127323, 0.1864364636105995, 0.1803657855740297, 0.21336001443830177, 9.999999999998899e-05, 0.026526845479229455, 0.03492796501397932, 0.001864786057408696, 0.0035094128563856186, 0.02131643864798194, 0.056101256927033716, 9.999999999998899e-05, 0.002215986964415384, 0.1928133543770113, 0.056590994450231635, 0.10140429333217449, 0.15199584297154323, 0.0433798165682725, 0.040724560556141154, 0.11205270080487939, 0.10037201352498981, 0.08719784476819237, 0.04825732171064079, 0.06982695877644929, 0.05850445513975866, 0.03542060080987808, 0.048064851042275536, 0.05984485402946316, 0.03872956795676086, 0.08175882123002176, 0.03263631728714478, 0.13330012565437266, 0.07646481487578827, 0.11418261665253904, 0.1504443726964273, 0.09400354057914717, 0.10156824417932198, 0.14299075473982104, 0.14507721000755247, 0.12239043193950017, 0.43632267250866286, 0.4121368068526351, 0.4547891055401181, 0.415552752788512, 0.43886568075620314, 0.42940207947318143, 0.46045468106383247, 0.4448699308037495, 0.4130928966609819, 0.1163174970323484, 0.15426661403585584, 0.1248810013266437, 0.12458510159691938, 0.10579519464047649, 0.12390085041794341, 0.11656755177103728, 0.14028969516987422, 0.1090107341378369, 0.31509761187932894, 0.27672749560864496, 0.19857790279661625, 0.25831645529598546, 0.3184474149158556, 0.3026138663878388, 0.2864883526684192, 0.23557250466509527, 0.2611305478312306, 0.3041443078180359, 0.3107126192090658, 0.3482047230913943, 0.32343684348871415, 0.21893790980217342, 0.2983373586829906, 0.3534557901020653, 0.3526889728470789, 0.3344973559302197, 0.2694275706421356, 0.23358699282178264, 0.2135545029486139, 0.272025659862568, 0.2259258907256929, 0.22976112495263556, 0.22802187457278156, 0.18045623173837266, 0.2241229121226458, 0.19370275034194728, 0.17541567738877073, 0.2470643842983693, 0.25341535675034355, 0.23682284112031415, 0.21899248407820449, 0.26120614086990224, 0.22932271304306406, 0.2473307082236701, 0.20717626748295281, 0.23172035435271132, 0.2117562976531141, 0.2102274745315792, 0.21336868631448025, 0.36326563861965633, 0.2029980496520325, 0.2172447274019622, 0.18666483480356078, 0.18593098219371573, 0.12436830365476126, 0.18588765957851883, 0.7440144989570261, 0.19876772605220272, 0.19945526230418997, 0.6460726590303925, 0.16959902398007487, 0.7129400671845607, 0.5671599999140222, 0.15551382790379975, 0.5329750615702995, 0.5395461555780432, 0.1503609462589648, 0.20819024091356853, 0.5481385482940491, 0.16702499666393034, 0.5034417336231266, 0.1899820581420102, 0.18316475676619015, 0.1971000516733472, 0.18128993321803066, 0.19424859590496224, 0.2219367240304685, 0.1819922362971208, 0.20072648164943196, 0.18652559472033647, 0.09550868627729558, 0.08895584769273157, 0.09428784017769654, 0.09418326209700623, 0.09860037229675056, 0.09395000807366427, 0.09297828403638053, 0.11495396231329724, 0.0862704184138261]}, "mutation_prompt": null}
{"id": "8166d95b-b417-406f-980b-0580bf8d4990", "solution": "import numpy as np\n\nclass DynamicResourcePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1 = 2.0  # Cognitive coefficient\n        self.c2 = 2.0  # Social coefficient\n        self.w = 0.7   # Inertia weight\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_threshold = 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Dynamic resource allocation\n            if iteration % 5 == 0:\n                exploration_factor = np.random.uniform(0.1, 0.9)\n                mask = np.random.rand(self.swarm_size) < exploration_factor\n                self.positions[mask] = np.random.uniform(self.lower_bound, self.upper_bound, (np.sum(mask), self.dim))\n\n            # Enhanced interaction mechanism\n            if iteration % 10 == 0:\n                adaptive_social = np.random.uniform(0.1, 1.0, self.swarm_size)\n                for i in range(self.swarm_size):\n                    if np.random.rand() < adaptive_social[i]:\n                        neighbor_idx = np.random.choice(self.swarm_size, 1)\n                        self.positions[i] = 0.5 * (self.positions[i] + self.positions[neighbor_idx])\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicResourcePSO", "description": "Leverage dynamic resource allocation and enhanced interaction to optimize PSO's exploration-exploitation balance with adaptive strategies.", "configspace": "", "generation": 56, "fitness": 0.19221579676974918, "feedback": "The algorithm DynamicResourcePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.3175048200200482, 0.34352818106280847, 0.3310316704239523, 0.31989271486696624, 0.3155313930864043, 0.32635858707201515, 0.31510881186147743, 0.35319046290334977, 0.2960367504328256, 9.999999999998899e-05, 0.0349187787763342, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09789687035647532, 0.09292959035920234, 0.09600264533159497, 0.10393731326628275, 0.10865016812517592, 0.08042606323704726, 0.10568216379662176, 0.08027150085061163, 0.0844983789752437, 0.08686501379488987, 0.07951101429992014, 0.08006218252754194, 0.07361698894940127, 0.10300410407106542, 0.08654227240788337, 0.09886308544072964, 0.07621321674231041, 0.07554209115299493, 0.9689373902547336, 0.9727903690216441, 0.9476933169036048, 0.9516699652035381, 0.9453950120919701, 0.9448850315758919, 0.9616046798403397, 0.9618402888353739, 0.9303705335734226, 0.22691633132709055, 0.2333737870252044, 0.19783074171667414, 0.20965922681664828, 0.20000135302017608, 0.17577787674871947, 0.18560370153848604, 0.22715482276518073, 0.1970948181353409, 0.2936912976862883, 0.2055540026830679, 0.2272302820629547, 0.21061954281996897, 0.2422004880562888, 0.1971059055931963, 0.20878097212681412, 0.2632813325309932, 0.23320599736467307, 0.0564026512350807, 0.13054230812378886, 0.10423949037504132, 0.10481128836722675, 0.12063694534197733, 0.14613983870668146, 0.12242507928948776, 0.11098728579018458, 0.11865113695130836, 0.12240515587982004, 0.12110904971711367, 0.11994337458725479, 0.12084861775928746, 0.11525576544908878, 0.1499738276002507, 0.13533190937047745, 0.13390026287358592, 0.12551428949390853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15250313695520146, 0.11900469138077263, 0.09487025314014785, 0.09717704572385955, 0.08327430088310483, 0.07657944651657056, 0.12090611638206517, 0.1032844930103507, 0.11562102574110666, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03856492560589453, 0.0626639244812619, 0.041822034489991555, 0.056495507494271235, 0.05173150774778801, 0.05412525090686382, 0.03491728699917962, 0.0497274237293166, 0.051300658406701616, 0.3552918783251121, 0.3138618150374699, 0.3891019471819084, 0.3159731900717625, 0.31156002310136577, 0.3071450316436346, 0.30490563028706275, 0.33931557452993033, 0.33142492120880784, 0.07256574870716792, 0.09135240217413432, 0.09286573477811322, 0.09024623314737235, 0.07271123437441551, 0.08193260809765701, 0.09563906413877599, 0.08867481671233579, 0.11251271595402124, 0.16119719315465408, 0.1918680188941757, 0.1473315740598875, 0.13143942924181318, 0.19322867390333232, 0.13437370295881734, 0.1579617270034811, 0.17705633173585644, 0.16292491183343505, 0.22865668469701705, 0.24242812076913833, 0.23273444616326966, 0.24427369292963463, 0.2324813234348968, 0.244598254819969, 0.22460733604749117, 0.23859387096536688, 0.19626931577358508, 0.17428571445288066, 0.17576755660529764, 0.15642306798700933, 0.17884477499708518, 0.1920157797277685, 0.1808938725746937, 0.19422826984367714, 0.1829934220664281, 0.1721986410282187, 0.20402912487173475, 0.19836845277135084, 0.2249484860873161, 0.23102780906107312, 0.2170622647038204, 0.19742761153508503, 0.22183090941183148, 0.2453965724665078, 0.21540452522146403, 0.1818726748816748, 0.17619157805240027, 0.17156091567296317, 0.18056292391379325, 0.18309919524188978, 0.18457247837005697, 0.18569818569643215, 0.1877370021875845, 0.18261220857610339, 0.18746589406945258, 0.4428927362598475, 0.18157780898608067, 0.5033465173848997, 0.19451347334942515, 0.4120383261064443, 0.2506691061695763, 0.48668820377654787, 0.4176929997660602, 0.3662674472572608, 0.40032283384448164, 0.3901007618793332, 0.43203281389097714, 0.21997783927429182, 0.24382237969876008, 0.14422992311603067, 0.3049299306255392, 0.26052337245183743, 0.18943638122522355, 0.18316839752156944, 0.18335130171582936, 0.1771623986847004, 0.21881486552960094, 0.19533360790581245, 0.18360021939537752, 0.1812713048843675, 0.1931937976395931, 0.10070010190720968, 0.11825700754605006, 0.0853827703497384, 0.0909475326555641, 0.0771404294843342, 0.08664060136629781, 0.08678482023347911, 0.07891716159611628, 0.09308463083963237]}, "mutation_prompt": null}
{"id": "4aa95584-1687-4403-b876-6705e44457c6", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "301582c1-ae27-4fca-aa33-ac2e4f78ec0d", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "e5cf1584-6853-4a21-925e-f9c68fcc750c", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "a674c8a5-4b09-43a1-a8a0-b1270b992f92", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "445ca933-9538-4e17-951e-2d2658c547ff", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "eb6d2109-57cf-4001-8f39-77afa25aeee1", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1, self.c2 = 1.5, 2.5\n        self.w = 0.7\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n        self.num_groups = 3\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            if iteration % 10 == 0:\n                self.num_groups = np.random.randint(2, 5)\n                for i in range(self.swarm_size):\n                    group_id = i % self.num_groups\n                    local_best = np.min(scores[group_id::self.num_groups])\n                    if local_best < scores[i]:\n                        self.velocities[i] *= 0.7\n\n            if iteration % 15 == 0:\n                mutation_strength = 0.05 + 0.3 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiSwarmPSO", "description": "Introduce a dynamic multi-swarm strategy with localized learning and adaptive mutation to enhance problem solving efficiency and robustness.", "configspace": "", "generation": 62, "fitness": 0.25218970984821687, "feedback": "The algorithm DynamicMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.6227304856705231, 0.616669846884081, 0.5553128100828846, 0.5288621604474726, 0.6009281788566025, 0.530717390976876, 0.5440377655423174, 0.5825842145595629, 0.5396340313171222, 0.1785489921722916, 0.3062184193816482, 0.12297345825631512, 0.12617014944174276, 0.09170462073154284, 0.07708626968366838, 0.10229414137377002, 0.13746256965240644, 0.17812141186774622, 0.14871693697702304, 0.14408758150520984, 0.151653162667447, 0.12826027196405487, 0.17914290053131043, 0.1139352030110462, 0.13381467566963745, 0.13047617541796885, 0.14250533362996554, 0.10227947346410071, 0.11877827992314183, 0.1384528300939354, 0.10811125295790225, 0.11710392367924283, 0.136405603731531, 0.1162234178285505, 0.11491005419706724, 0.13098927862998588, 0.9618918899216637, 0.9645513389097363, 0.9695725427716249, 0.9596078585748415, 0.9650536545219778, 0.9563056095379873, 0.9568188452972377, 0.9583127828739314, 0.9590783484322943, 0.35398807218838335, 0.35597886248254496, 0.33609714655756406, 0.3316146081554512, 0.3476717721884516, 0.3532615424906843, 0.3163113589188704, 0.339971115573507, 0.3208043467390216, 0.5765443196017871, 0.16481368527706997, 0.38779542819025914, 0.25763670034223873, 0.35549349108281403, 0.2610068862050181, 0.32179882273751725, 0.17677518233176193, 0.3867339657800619, 0.21957568025478613, 0.12427362583970103, 0.16766609245969843, 0.16390877245812518, 0.16651163422176174, 0.1750819884480569, 0.1890553965095596, 0.1327501997348327, 0.16470087301045477, 0.18509704748498568, 0.18059741908559424, 0.18301045418485173, 0.16426586971899615, 0.20728448604207728, 0.12844351252393094, 0.1838442196274641, 0.18561965549397963, 0.13010994883061777, 0.0007708500297145537, 0.00026576109840392714, 0.0653062187506086, 0.01967815696813835, 0.013624853924008695, 0.057906959485467424, 0.00010596446167909779, 9.999999999998899e-05, 0.12080204044400922, 0.11579560374430553, 0.06327545163449666, 0.06524088235871006, 0.0650184411172735, 0.02535825675677028, 0.05107165862087493, 0.14928185239671965, 0.10591398749818781, 0.11234120205560794, 0.047203336567934406, 0.0555677843571184, 0.025919386160939584, 0.045500268750117145, 0.05946906082442405, 0.011934918420611784, 0.03372100389658461, 0.027964370149689555, 0.01860022916124815, 0.0628484428495254, 0.07775649558985664, 0.17636339568647907, 0.11863229757246097, 0.08514935891636355, 0.13373418226046363, 0.1250687119089713, 0.13371697409464756, 0.12024667329771532, 0.43221366040658826, 0.43423185065841075, 0.42302579552328945, 0.4778658062730743, 0.46851093607834315, 0.4477549049735118, 0.45929667969037546, 0.45679033000612557, 0.43357529104656045, 0.09429198589014398, 0.0868315746963857, 0.08675425903440903, 0.13163057324037908, 0.08535238612729468, 0.1208775318233164, 0.12409718905768097, 0.14000877742566975, 0.08905061219422439, 0.2905103203743189, 0.23491557491646686, 0.3013593480532727, 0.27173532196447303, 0.2612512021529074, 0.187223673609075, 0.2892789639548109, 0.31431374353550223, 0.31184172749397754, 0.2970264102457705, 0.32619452810715377, 0.31158071748525695, 0.3464506919967273, 0.3546283518675366, 0.330643623264825, 0.25665766864164474, 0.31277326731169974, 0.24596342610411048, 0.2366149040117541, 0.2402113926023921, 0.1971405785848922, 0.300905538112764, 0.17567260944843965, 0.24295582099709678, 0.20959150958445616, 0.23238637684480368, 0.253835982272571, 0.2077472902820644, 0.1958826816242789, 0.23756157230395225, 0.20981208943395324, 0.23853345307673257, 0.23580093156726845, 0.23432352452634964, 0.22690001925251857, 0.24104871096324731, 0.19686059917145204, 0.23488090272787754, 0.2164136889145396, 0.2426636238463188, 0.20922994963427288, 0.18898476788747043, 0.2327475256694994, 0.213989142895172, 0.1963930444656704, 0.12500403160432705, 0.17602638972721563, 0.18670100237706078, 0.17345283356573604, 0.20069118387041218, 0.20004818337462926, 0.8543510057539979, 0.8696504476215636, 0.7694291167915852, 0.5671492966140317, 0.15647399179674215, 0.5002159934851746, 0.4627574419791297, 0.1689284456801159, 0.21142165327189077, 0.4775950249601272, 0.16834408884292384, 0.41320483478434666, 0.19612277434260883, 0.18771763916278084, 0.20768336470596938, 0.20544652899315075, 0.18557938768812854, 0.2433837792711192, 0.18701015036735857, 0.2136974251906859, 0.1866321568525252, 0.0882656013007509, 0.08911025917403181, 0.07335564503901593, 0.09706989482750539, 0.0912678084107259, 0.12292344887530893, 0.11199286281138798, 0.09679756916846549, 0.08543377080359515]}, "mutation_prompt": null}
{"id": "581ad7b1-3ed9-44ac-ac48-93dff6c7ff44", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "68cb1736-3b48-4295-89ef-6082a80e6474", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "a8ea7254-71f0-4a1e-a5cc-a6add352fd94", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "a440995e-93d9-4340-8a38-d5df0fd142ae", "solution": "import numpy as np\n\nclass DynamicChaosEnhancedPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        chaos_factor = np.random.uniform(0, 1)\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * (self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Dynamic adaptive topology not needed\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                chaos_factor = 4 * chaos_factor * (1 - chaos_factor)  # Logistic map for chaos\n                chaos_mutation = np.random.normal(0, chaos_factor * mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + chaos_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicChaosEnhancedPSO", "description": "Introduce a dynamic adaptive learning rate and chaos-enhanced mutation strategy in PSO for improved convergence and exploration.", "configspace": "", "generation": 66, "fitness": 0.2945992092623711, "feedback": "The algorithm DynamicChaosEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.6351752608837662, 0.6531316079130616, 0.6888311060162604, 0.6654058051277716, 0.6399591505664266, 0.6648303961150586, 0.7002847673882268, 0.64065464498726, 0.6533165795771735, 0.40594397333617516, 0.4244558881348648, 0.3819474870812807, 0.3860258707709201, 0.42307577574596944, 0.414035638695327, 0.322890804667896, 0.29397378546353015, 0.35402370846250286, 0.39639521770545516, 0.14745689667431072, 0.1480114824817842, 0.12578188083080732, 0.15200405221850655, 0.37468422838484494, 0.10763762680183886, 0.15436598644629063, 0.1581188898111412, 0.13457320058476885, 0.10735141162134754, 0.12362165218297994, 0.14237693698701626, 0.12712378541878389, 0.15681049860866803, 0.11377226671250207, 0.11257484988208999, 0.10645563907461819, 0.9673958229548216, 0.960302998544727, 0.9574960151211456, 0.9624384492437087, 0.9562865893213024, 0.9624638970298425, 0.9700175849254911, 0.9561687298749433, 0.9722563529944355, 0.5016540344642182, 0.477014803894123, 0.44777786789872154, 0.4958640867843439, 0.5190228520593134, 0.5241282773956603, 0.4852069992671528, 0.5056640938941912, 0.46264856476552474, 0.3094171263951122, 0.6832016145181901, 0.6590387178804129, 0.68800744654827, 0.267679746652293, 0.2619967699676604, 0.22565884990675933, 0.6900869947195768, 0.5889148437119163, 0.17869880730265741, 0.1852637164019455, 0.18774126253681112, 0.1767992729561083, 0.17364566356688793, 0.1286407592557367, 0.16794756703342772, 0.18095237770556416, 0.17125661883623688, 0.1880588972929701, 0.12344772783023295, 0.188084581578419, 0.20179823415952858, 0.18154764971121884, 0.17693271640467634, 0.19998171069615778, 0.19416281728806395, 0.1887755784594598, 0.023416361369387073, 0.04948041466026676, 0.036727123917863924, 0.03865870798796733, 0.05014762517058913, 0.0031342301800807437, 0.020520382782977298, 0.030486610963545213, 0.010496196226916776, 0.1718070875059099, 0.062094433499185975, 0.09193013436595576, 0.07815245343292576, 0.034020149948034706, 0.03709066628731472, 0.1382910570409387, 0.05300342991165474, 0.09829338885099825, 0.21901019183230896, 0.1282356466392912, 0.12313732497453678, 0.11037535526132158, 0.07278322538564586, 0.09801498218133786, 0.14261914332513992, 0.16175999569238575, 0.025835553050183258, 0.15700414844892474, 0.09553988004333569, 0.16852051012039515, 0.08305705232664096, 0.07057994149703684, 0.11380448941122434, 0.142019785366424, 0.21502834431914308, 0.11699943648129452, 0.46361055115139027, 0.49119622858837897, 0.4637015713768937, 0.4809756251463918, 0.4753882524203912, 0.4615883179508178, 0.4879460518360774, 0.48240504139051543, 0.5033523909466654, 0.10720274193671864, 0.11816704642095777, 0.13931826041843032, 0.11766404413535825, 0.12877914120675216, 0.10440848044637097, 0.11574575532966513, 0.11313015394384729, 0.12381942057410489, 0.37713774433986136, 0.3063955670094508, 0.2092453296332839, 0.1982048587417753, 0.23978747196959138, 0.26085504088712874, 0.2082028004920553, 0.2237239037605494, 0.2845426876995042, 0.32104236407683373, 0.33837960756693697, 0.3899481780178783, 0.3270140041292088, 0.37283229530578643, 0.30848406407162055, 0.37717088129107046, 0.3914065516788624, 0.397236453507291, 0.2911658337320284, 0.29478770124321896, 0.28818624284093797, 0.25388714774369714, 0.2214789702198896, 0.3117709155269779, 0.1756950726182367, 0.24223832026961367, 0.23648870377134446, 0.22410912884562872, 0.21237061991778894, 0.21941146348862772, 0.2378821908333435, 0.22935635346940153, 0.20797409042624193, 0.2280955273691968, 0.25993195309949135, 0.2233281209620629, 0.20240784621249397, 0.23187738508311218, 0.21067942242577742, 0.23588249434394926, 0.5663519571817144, 0.5025463651679302, 0.20194971281411223, 0.2138389444727612, 0.21399184162973317, 0.1870213285901995, 0.12515134403373962, 0.14608219144234658, 0.17293566198867028, 0.19753390433091578, 0.763660938320531, 0.8025029234049158, 0.1692063898667242, 0.7760355443998301, 0.7219938245984518, 0.15539826191181816, 0.6553702440388275, 0.20524969024638462, 0.15426235928236842, 0.2064476709462144, 0.6789009910577859, 0.7054037536762818, 0.1674030306494393, 0.19556249888425348, 0.18691468738792172, 0.19339869179314595, 0.19601570851192063, 0.19189563375479501, 0.21411261495951417, 0.18139256896239608, 0.19492196474303647, 0.20135992511881073, 0.09238925172075685, 0.09295015234377302, 0.10880074770917614, 0.09703236733790344, 0.09111492146685674, 0.08377849436991769, 0.09329820601555494, 0.11879585598250797, 0.10074134814646529]}, "mutation_prompt": null}
{"id": "67a6f439-30ea-4c5e-804c-451be480f2f4", "solution": "import numpy as np\n\nclass AdaptiveLevyPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def levy_flight(self, size, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, size)\n        v = np.random.normal(0, 1, size)\n        step = u / np.abs(v) ** (1 / beta)\n        return step\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_min + ((self.w_max - self.w_min) * np.random.rand())\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Levy flight\n            if iteration % 10 == 0:\n                levy_jumps = self.levy_flight((self.swarm_size, self.dim))\n                levy_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                self.positions[levy_indices] += levy_jumps[levy_indices]\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveLevyPSO", "description": "Implement adaptive inertia weight and Levy flight in PSO to enhance exploration and exploitation balance for robust optimization.", "configspace": "", "generation": 67, "fitness": 0.22033947346024457, "feedback": "The algorithm AdaptiveLevyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.40995502559043084, 0.38208790741658993, 0.3862281505078349, 0.44094317514264425, 0.3922404257292621, 0.4438703032949006, 0.5145318695080963, 0.43987571320993835, 0.41017169837366674, 0.13137498369976452, 9.999999999998899e-05, 9.999999999998899e-05, 0.02920202816494477, 9.999999999998899e-05, 9.999999999998899e-05, 0.1012094641884751, 9.999999999998899e-05, 0.0756929351437291, 0.06669804312758498, 0.1459037461911481, 0.1073645832439537, 0.11985837427634927, 0.07690403088939601, 0.10632381092266385, 0.09141928278405809, 0.11565101053073956, 0.1275078333356625, 0.08729249023984254, 0.10990456328701981, 0.10314103752786774, 0.10812187401689222, 0.09203122812509268, 0.09561748579933571, 0.08836289141206399, 0.1044443571392476, 0.08488525587722129, 0.9646412069349742, 0.9458618487793843, 0.9652292220723447, 0.94341335556888, 0.9642784405517069, 0.9441900531772257, 0.9690426725158188, 0.9458489672660031, 0.9691530441008002, 0.2596215095647605, 0.2493877199580995, 0.2717962724912574, 0.2296457238821752, 0.24535989806401515, 0.3231217352423087, 0.3342059171945766, 0.33346267822793796, 0.21964121724060415, 0.22885077056878267, 0.3355791605062448, 0.19595303421145938, 0.8716006385604572, 0.27581204005271953, 0.23276235521543054, 0.2463882227898656, 0.1512280783998502, 0.24193290300117887, 0.1711904765534209, 0.12417876855205212, 0.12974317542468194, 0.18987805117949452, 0.11516083806507138, 0.143021632304987, 0.13755384934787673, 0.12126656965320248, 0.1217056130759665, 0.12774041810365122, 0.15011836937068723, 0.17024295964082725, 0.12529598592623292, 0.15774268441207573, 0.14644092632609917, 0.23223484403513162, 0.10288704318972086, 0.15195619308140396, 9.999999999998899e-05, 9.999999999998899e-05, 0.011556413311286429, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025984070393982428, 9.999999999998899e-05, 0.036130853616132885, 0.20564439809178325, 0.09821123193763248, 0.10306487981477896, 0.04937570477607078, 9.999999999998899e-05, 0.05442002279118152, 0.11806569081648721, 0.12739431518137223, 0.0780361947795769, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04662484030119651, 0.079761074306411, 0.0680899614109034, 0.1026162727076324, 0.028456195351798663, 0.042333601467165916, 0.07663987598532263, 0.14484763895669517, 0.05925416726721944, 0.4965717281351939, 0.4015731580138058, 0.35815237103058173, 0.407521528867021, 0.48420333705666163, 0.42682819071098654, 0.3310238477804631, 0.34940642850068293, 0.431787798523399, 0.06524282975237672, 0.10997382487119889, 0.10710908966562949, 0.11486076560240721, 0.1336765024683998, 0.11649473469591265, 0.05467939555995183, 0.11978437034248723, 0.07211536958941689, 0.25525468557369146, 0.1817653783395191, 0.14967215910066478, 0.262346658975938, 0.21637106888377888, 0.37597745320076714, 0.1731984967473682, 0.18612913758839544, 0.25209851041032405, 0.22190313850790389, 0.2998584503893903, 0.21665004277273725, 0.2579748695272984, 0.2737653899698814, 0.24578388360006231, 0.2245679106522438, 0.267844478372983, 0.28495168469022125, 0.2357827084323567, 0.1776393548154157, 0.16894568182000225, 0.22065134531481356, 0.2044715750142324, 0.27926073021493136, 0.16976187743733318, 0.19533122065951636, 0.1921629079489292, 0.21265435786238607, 0.17819644145307523, 0.20107882712400427, 0.18796709745611972, 0.22573917067904403, 0.20203016042347322, 0.18689262136286866, 0.21789126380335533, 0.2509234762515622, 0.28230585710315204, 0.2249435634615491, 0.18498862756426027, 0.20057543757185536, 0.19433439253132412, 0.17147391043570004, 0.19980778932226695, 0.26392578473087414, 0.15945300162705933, 0.683393537400998, 0.1818906070571682, 0.17336902318919967, 0.49000141683175513, 0.19291520345110502, 0.5826023240894715, 0.762219258166825, 0.16682167541658532, 0.6365064330521806, 0.36153922342421385, 0.15618709540025721, 0.342570124205854, 0.521030204010541, 0.1640564167927947, 0.20216916935608908, 0.3159583819666908, 0.1560803163504092, 0.4089847067231155, 0.1897055821714425, 0.1748562452934539, 0.2077849594064779, 0.19693466133666115, 0.1733534782697791, 0.1850358071988557, 0.18910500802780528, 0.1994323409556661, 0.2098898669979179, 0.1016324584887327, 0.0923234912798333, 0.07836228022661673, 0.09129725844617309, 0.09379831373477787, 0.10303319760048002, 0.11515414227558973, 0.0771771206482541, 0.07605702093536126]}, "mutation_prompt": null}
{"id": "3ff5b761-dc7c-49e7-999d-7e3f630c09bf", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "a08888ec-bfe9-404b-a68e-c0c388982494", "solution": "import numpy as np\n\nclass DualSwarmAdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n        secondary_swarm = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        secondary_velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            secondary_scores = np.array([func(pos) for pos in secondary_swarm])\n            self.evaluations += self.swarm_size * 2\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // (self.swarm_size * 2)))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // (self.swarm_size * 2)))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // (self.swarm_size * 2)))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            sec_cognitive_velocity = c1 * r1 * (self.personal_best_positions - secondary_swarm)\n            sec_social_velocity = c2 * r2 * (self.global_best_position - secondary_swarm)\n            secondary_velocities = w * secondary_velocities + sec_cognitive_velocity + sec_social_velocity\n            secondary_velocities = np.clip(secondary_velocities, -velocity_clamp, velocity_clamp)\n            secondary_swarm += secondary_velocities\n\n            if iteration % 20 == 0: \n                mutation_strength = 0.05 + 0.3 * (1 - (iteration / (self.budget // (self.swarm_size * 2))))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 2, replace=False)\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + gaussian_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DualSwarmAdaptivePSO", "description": "Introduce dual-swarm synergy with self-adaptive velocity and mutation strategy to enhance global and local search balance.", "configspace": "", "generation": 69, "fitness": 0.2208618916210504, "feedback": "The algorithm DualSwarmAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.4430835416348191, 0.45189579100348576, 0.45421299605017973, 0.4465522501189567, 0.42817103598113837, 0.4322656086740382, 0.4067394509002369, 0.4526216025777312, 0.4429447280104435, 0.04907130370995527, 0.06155216433853716, 0.047702565659201945, 0.08209324687109965, 0.09569637917586693, 0.043898275481484395, 0.03222341850399424, 0.049018694276102726, 0.023916939767070988, 0.10049663787010954, 0.11811716533855432, 0.13433347812915786, 0.11066165057419508, 0.1160225483954973, 0.10223804313998408, 0.09454897604275336, 0.09705773135624185, 0.1335414628292929, 0.09725713207656628, 0.10046820125308076, 0.09235646290128474, 0.11045296701643981, 0.0895282548236711, 0.09612047902360576, 0.08300216513284908, 0.10253559652823518, 0.091116780266294, 0.9406382327614605, 0.9494627675900085, 0.9241738945321791, 0.9199262487420563, 0.9416546983334265, 0.9348367494143711, 0.9467403283034548, 0.9320815179935481, 0.9141314029394747, 0.269916571685354, 0.2827524333330327, 0.25822416423713346, 0.28596964468121044, 0.24902748546706555, 0.2555304129516873, 0.2482880073924718, 0.2671799882347281, 0.24308644304682325, 0.47442829022934097, 0.3819964826185941, 0.5188859811553175, 0.3105310414262794, 0.24857000146199748, 0.2351151933721891, 0.24031356188602782, 0.34455223840676974, 0.514929948545368, 0.12369679720707905, 0.1299351548565817, 0.15956895026234963, 0.14759131429520111, 0.15162460596430427, 0.11455851535193573, 0.13362164378372576, 0.1426376668986442, 0.15034010775583884, 0.12062126678098406, 0.15236181582975783, 0.15135194011593722, 0.1379425042527722, 0.13853533034898224, 0.12331726042228564, 0.14578686383837192, 0.09224961067403892, 0.1697226132265498, 0.0222719745272274, 0.0030380519222704683, 0.016873840882452917, 0.017048711860265797, 0.01545920299849135, 9.999999999998899e-05, 0.06092291860074217, 9.999999999998899e-05, 9.999999999998899e-05, 0.148966732864675, 0.0899382476153271, 0.12636132659249943, 0.06338196858631728, 0.022478175295708724, 0.036753802834116556, 0.11649317106275725, 0.09753205505534046, 0.07060058769745159, 0.024084363829838695, 0.023765506778126277, 0.023025984925981513, 0.022852606218020655, 0.00820992090312489, 0.004642694470281983, 0.0419299538529021, 0.009625239393904694, 0.0014494293432090188, 0.09136476661134929, 0.0920923107756556, 0.0776151990192735, 0.10184968648824, 0.06700268813777654, 0.07783476510202547, 0.05428722389092544, 0.10566092214276235, 0.09359304383049272, 0.3878479081161068, 0.474637924183937, 0.39881113537170254, 0.4045718475301213, 0.3866050002185747, 0.38308432646704615, 0.3842793106082112, 0.396395094526775, 0.37255246064169656, 0.10928683030668618, 0.11180965739508975, 0.11106854501323216, 0.12478892832615252, 0.08213514652854303, 0.14724628449050192, 0.10174627812588044, 0.12587310728286816, 0.11539765126572388, 0.18568861187772578, 0.2337084809208687, 0.24263210801363644, 0.2121360645953968, 0.22139637848213345, 0.21812711740815816, 0.2197494525715833, 0.17658507434848547, 0.17771075212002285, 0.23326727751291354, 0.29587878779153165, 0.27678610737962694, 0.26036574011635294, 0.24736743327885302, 0.2784173842920872, 0.2474446394975629, 0.2975361964508244, 0.27179803555974236, 0.17176344787757702, 0.23108607538543458, 0.22020715401175517, 0.21114187075644264, 0.20714697593184495, 0.2015878822500219, 0.18898904550501672, 0.21072182443301402, 0.20832095828374553, 0.2375032059690505, 0.22138024808934698, 0.2154786064654528, 0.24638648048967693, 0.19662192575007653, 0.23578817863847812, 0.20262727191137564, 0.22378683432355617, 0.20595527967546534, 0.20670182937721504, 0.24266568371412345, 0.19640527363249805, 0.21787588621893172, 0.19831059469962908, 0.20429497672143693, 0.20023572981112725, 0.20667999085811084, 0.20004792927588233, 0.18644151618134752, 0.17188397097800967, 0.14953747362024483, 0.1707457211286335, 0.19550629275513698, 0.5553515507825646, 0.6433779672354265, 0.16692290237857377, 0.5646171308196161, 0.508772294485315, 0.3945125144249193, 0.4973601028880037, 0.20248534096515247, 0.14929888296280447, 0.1952151353899626, 0.3879632019818282, 0.3730491895879333, 0.33228379874903335, 0.19458228417520518, 0.19543688362667733, 0.18817358254298222, 0.20183645603281475, 0.19082637911212075, 0.2052064211357768, 0.1881652303629492, 0.1966438535038948, 0.18641345437628276, 0.08573045502709065, 0.09152702615552666, 0.09613552962691285, 0.09042436561215439, 0.08610743770311546, 0.09457283082946433, 0.11049674656690933, 0.09488368004986991, 0.07800625557159513]}, "mutation_prompt": null}
{"id": "9ab134b5-30d9-4f11-a039-f2b132adf70c", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "cb568221-7461-4ab8-a85c-7ef654aa0864", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "69813b91-1048-459e-8039-7f49d8375295", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.2, 2.8  # Adjusted for exploration/exploitation balance\n        self.c2_min, self.c2_max = 1.2, 2.8\n        self.w_min, self.w_max = 0.3, 1.0  # Wider range for inertia weight\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * (iteration % (self.budget // (2 * self.swarm_size)) / (self.budget // (2 * self.swarm_size))))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(2, 6)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.8\n                    else:\n                        adaptive_factor[i] = 0.2\n\n            if iteration % 15 == 0: \n                mutation_strength = 0.05 + 0.35 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.3, 0.3, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            if iteration % 20 == 0:\n                best_positions = self.personal_best_positions[np.argsort(self.personal_best_scores)[:3]]\n                for i in range(self.swarm_size):\n                    if np.random.rand() < 0.1:\n                        self.positions[i] = best_positions[np.random.choice(3)]\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveHybridMutationPSO", "description": "Enhanced Adaptive Hybrid Mutation PSO with Dynamic Velocity and Multi-Swarm Communication to improve convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('zero-size array to reduction operation minimum which has no identity').", "error": "ValueError('zero-size array to reduction operation minimum which has no identity')", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {}, "mutation_prompt": null}
{"id": "9163a77e-469f-45e0-bb09-f07b3f85b769", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "e18f7414-d563-4802-8b87-ec89a2afbe25", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "ea38a9d9-7ed9-4633-8f7f-8d0c056b93c2", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "aa84a337-02c3-4f3e-945e-19e3e49da43f", "solution": "import numpy as np\n\nclass EnhancedDynamicSwarmPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.3, 2.7\n        self.c2_min, self.c2_max = 1.3, 2.7\n        self.w_min, self.w_max = 0.3, 0.8\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Dynamic swarm resizing\n            if iteration % 5 == 0:\n                self.swarm_size = np.random.randint(20, 40)\n                new_positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n                self.positions = np.vstack((self.positions, new_positions))[:self.swarm_size]\n                self.velocities = np.clip(self.velocities, -1, 1)[:self.swarm_size]\n                self.personal_best_positions = self.personal_best_positions[:self.swarm_size]\n                self.personal_best_scores = np.append(self.personal_best_scores, np.full(new_positions.shape[0], float('inf')))[:self.swarm_size]\n\n            # Hybrid mutation strategy\n            if iteration % 12 == 0: \n                mutation_strength = 0.01 + 0.39 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 4, replace=False)\n                uniform_mutation = np.random.uniform(-0.6, 0.6, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = 0.5 * uniform_mutation + 0.5 * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedDynamicSwarmPSO", "description": "Enhance search space exploration and convergence rate by employing dynamic swarm resizing, adaptive velocity, and hybrid mutation in an improved PSO framework.", "configspace": "", "generation": 76, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('boolean index did not match indexed array along dimension 0; dimension is 24 but corresponding boolean dimension is 37').", "error": "IndexError('boolean index did not match indexed array along dimension 0; dimension is 24 but corresponding boolean dimension is 37')", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {}, "mutation_prompt": null}
{"id": "e382c089-5574-4d59-ade5-0c9f1f32eaa0", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "1aea939b-22b4-4552-b7b2-b3ef39a72cd4", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "cdb636fc-524c-4d9a-9fc0-87db7590c3c7", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "4cdff459-6b50-4384-b64d-9787f8b18b81", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "0a7d9832-ee27-4585-a6b6-3cbf71e17c70", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "45c8b981-cd4d-4187-83f1-b69d629da474", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def levy_flight(self, dim, beta=1.5):\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) /\n                 (np.math.gamma((1 + beta) / 2) * beta * 2**((beta - 1) / 2)))**(1 / beta)\n        u = np.random.normal(0, sigma, dim)\n        v = np.random.normal(0, 1, dim)\n        step = u / abs(v)**(1 / beta)\n        return step\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = 0.5\n            c1, c2 = 1.5, 1.5\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n\n            # Dynamic neighborhood adaptation\n            if iteration % 7 == 0:\n                adj_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / np.random.randint(1, 4))\n                for i in range(self.swarm_size):\n                    neighbors = adj_matrix[i, :]\n                    if np.any(neighbors):\n                        neighbor_best = np.min(scores[neighbors])\n                        if neighbor_best < scores[i]:\n                            self.positions[i] += self.levy_flight(self.dim)\n\n            # Levy flight mutation\n            if iteration % 20 == 0:\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                for idx in mutation_indices:\n                    self.positions[idx] = np.clip(self.positions[idx] + self.levy_flight(self.dim), self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhance adaptive strategies with a dynamic neighborhood and Levy flight to improve exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.23443078159742722, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.58519091740679, 0.5130660296247285, 0.5149702460776773, 0.5457637160440247, 0.6011666654930203, 0.5889591920894056, 0.4825191913395408, 0.5276907211454537, 0.4244120259958567, 0.04816051988036529, 0.05166681499795467, 0.0614037048011542, 0.015844002860741835, 0.03244304961559896, 0.0025804202056968206, 9.999999999998899e-05, 0.02222856840674481, 0.04898967689229572, 0.10612525000896766, 0.11812846097550667, 0.1585696313747651, 0.11992488424387215, 0.11093702108003922, 0.10800032947215532, 0.15005490261677135, 0.11653929744731051, 0.09504786589196523, 0.08809752132426352, 0.11908046226560287, 0.11776468783085747, 0.11254812541541903, 0.10713102111753847, 0.10006030614972083, 0.1014358000121025, 0.12520766786678228, 0.10184326544750599, 0.9595599741864695, 0.9628197332485678, 0.9604149166844016, 0.9560612410484304, 0.9552433486450713, 0.9590780830010772, 0.9651386581430194, 0.9577068796431509, 0.9624446630531048, 0.2891405963417224, 0.33017555449364655, 0.28334221265939274, 0.27716318412911456, 0.31101373184211967, 0.3028100021162965, 0.31205636698572414, 0.2590414025670362, 0.32847874611417427, 0.7427882964681758, 0.18505172386005475, 0.17393759558115907, 0.35381465717205673, 0.21394797799184906, 0.2334814147435743, 0.1995071417784281, 0.3316449883229817, 0.2386512127816539, 0.14200635805156303, 0.1109651678328808, 0.15378606846071818, 0.1551354807851918, 0.15913292230285425, 0.14157859592832078, 0.20909464739751016, 0.16974630878131702, 0.24700463315276433, 0.16168793380330027, 0.1307871950737941, 0.13416418324727275, 0.15225939635169128, 0.19509631117411308, 0.1994053391238736, 0.2778840482948113, 0.1277674401131409, 0.19766022831530694, 0.0026634194238615017, 0.08701920785085171, 0.0030298160328364743, 0.04808724117778762, 9.999999999998899e-05, 0.007731648162130678, 0.013409798825632646, 9.999999999998899e-05, 0.03298745810210113, 0.1594587701994935, 0.08455165264403608, 0.10554002226195658, 0.08658540006710358, 0.08967665680630543, 0.02739943508521936, 0.15247364776234607, 0.1259423044109712, 0.07409666266373038, 0.0024874693044113494, 0.0467576970264898, 0.051552534637234415, 0.06627150592540365, 0.014643622268774359, 0.031132146498069058, 0.0673160358576973, 0.002082584729957482, 0.08902912124500895, 0.14436693433171277, 0.05828489564490813, 0.15332443602506995, 0.12554967518422766, 0.17960682486546153, 0.058695862267675314, 0.10840519199879639, 0.1644604911942723, 0.045543442845036974, 0.44216079044073753, 0.427302024862968, 0.4516843939006544, 0.424414576391659, 0.41538374081191043, 0.43304149191706454, 0.4482656689357757, 0.43512166258585316, 0.41844582916759543, 0.10143018645229518, 0.10559150945336793, 0.10576993914121524, 0.12688547621200197, 0.1139225828686955, 0.10811839604080797, 0.0975668737053631, 0.1121805348502809, 0.15321817524397352, 0.2269363114254873, 0.2840537260641448, 0.276141432868762, 0.24892783939862417, 0.3126405772498636, 0.16846687096965707, 0.22165712325878073, 0.17842315314515833, 0.1533545202864891, 0.2122777668002639, 0.3571305939703737, 0.27703514352795033, 0.29855591656812863, 0.27404659474980786, 0.28096469864183415, 0.3296135572212263, 0.33321059197886305, 0.3289874844618714, 0.18283833904989766, 0.21619413170801838, 0.2704655796086658, 0.25600648794450986, 0.20503970332264254, 0.21563447778598122, 0.2096479364416607, 0.23482483118820885, 0.19285107722795147, 0.22517568230871876, 0.18028058664801083, 0.20031199243613518, 0.24273444079818463, 0.20973820513262664, 0.19855004931792697, 0.24070176636534502, 0.2122524513928471, 0.19383147358837416, 0.19170350336725483, 0.19405629004735125, 0.20899448970480294, 0.1960774915567739, 0.20355818761929823, 0.2064181804892946, 0.19726404991943702, 0.20999308496118596, 0.18599102718753635, 0.17592740575995336, 0.1695949737221566, 0.1879969392979136, 0.14606748770019873, 0.2014738119696039, 0.20053447694656767, 0.11989586096477489, 0.7008747574915035, 0.6734280110861468, 0.5353171650709818, 0.5268175633200826, 0.39484862657722397, 0.48997290684538775, 0.21311831088096556, 0.21254147540024448, 0.3772825471362624, 0.42054214660731526, 0.3861435721290509, 0.18489652735639106, 0.18897446824205644, 0.1733403839410539, 0.17874968748272424, 0.1906337618169226, 0.18948472416484763, 0.18317694555946795, 0.18429348860464823, 0.18102615292959068, 0.09844856919637823, 0.10458712357373334, 0.07738169051437804, 0.08092158660546389, 0.08489000421224158, 0.08587279902176781, 0.09306752719497147, 0.06871871796949125, 0.08845121652602905]}, "mutation_prompt": null}
{"id": "e6234359-c4a2-45ea-b610-bd1c2595aac2", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "cb9925fb-29f8-4dd3-b0cf-f5ffe1708cd3", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "049d9b73-fbd1-4418-823b-f88c4339b4e4", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "f7f65961-bad8-4163-8fb3-7cc5ff073376", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "5d8cb54f-d819-45ad-8c16-a12649a553c0", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "24b806a2-82b0-438b-a026-44280980222c", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "1f8e6502-3bed-4bba-8bf4-b9f51d5ae2f4", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "952db407-1add-4c76-8720-3275a5f0b79d", "solution": "import numpy as np\n\nclass QuantumDynamicPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1, self.c2 = 2.0, 2.0\n        self.w_min, self.w_max = 0.5, 0.9\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Quantum-inspired dynamic swarms\n            if iteration % 10 == 0:\n                self.positions += 0.1 * np.sin(2 * np.pi * self.positions)\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            # Adaptive learning rate\n            if iteration % 20 == 0:\n                self.c1, self.c2 = np.random.uniform(1.5, 3.0), np.random.uniform(1.5, 3.0)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "QuantumDynamicPSO", "description": "Incorporate quantum-inspired dynamic swarms and adaptive learning rates to enhance exploration and convergence in PSO.", "configspace": "", "generation": 90, "fitness": 0.21692950359597465, "feedback": "The algorithm QuantumDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.3964639387431361, 0.3722238773438903, 0.39807783455242285, 0.3611576415471436, 0.3692796151034179, 0.36308670782173613, 0.38232686875787214, 0.40268984575025346, 0.37303393248066063, 0.022413118606255167, 0.05503348775793515, 0.05700810260383027, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015244674432773886, 9.999999999998899e-05, 0.0006828330236172686, 0.017275108127921213, 0.10431456049715793, 0.11585709946930034, 0.09809138713667964, 0.09404797460526004, 0.11050057458201934, 0.0854701336213256, 0.09086645044866382, 0.14560948996763912, 0.09085002616700766, 0.07946779353311084, 0.09132345268933972, 0.08864660600239438, 0.10717430415008877, 0.10530944586637214, 0.10444829325326632, 0.08705041994056939, 0.10644848003341323, 0.054866423569415734, 0.9697291228570514, 0.9707990348851994, 0.9696131036383933, 0.962491231228799, 0.9708054239425514, 0.9696110582053232, 0.9729180102707216, 0.9582032080078213, 0.9647760948354052, 0.25185042070167585, 0.2489314128013378, 0.2957145085582249, 0.21980420335941397, 0.23526033591012074, 0.21343844909189236, 0.2627111341153081, 0.2524279238587842, 0.2427654037155934, 0.30356440712746235, 0.22257744349800335, 0.5171158411887333, 0.3235276240547381, 0.2745300655609656, 0.5711615335068682, 0.3120976378852519, 0.2287040673147357, 0.3003282525227243, 0.14480721984904754, 0.11352228855627344, 0.15964010001759832, 0.11398776311717917, 0.13574555108168862, 0.12692151785308092, 0.12533763703001533, 0.14143622299164293, 0.15078802845762307, 0.1606352796971212, 0.12319345611390187, 0.1818070160567702, 0.1418794750711746, 0.2028836113984983, 0.1392016245386245, 0.13534991999790613, 0.12821933749200765, 0.14867130723849553, 9.999999999998899e-05, 0.01397934191024619, 0.015994441386422142, 0.00909487121161312, 0.009840474725660187, 0.0024029697396937832, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14181546756114072, 0.07289468076737626, 0.16803085428357412, 0.10211885571916268, 0.052706566886481565, 0.059730969799459355, 0.11642417716043185, 0.08875788763821879, 0.13594174494329203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08309915567290338, 0.055016475026220535, 0.08274820247788517, 0.0783979148784203, 0.09850908811851966, 0.08022258868334431, 0.06860954747753367, 0.039181764261801644, 0.07340670833982588, 0.3603579619761774, 0.4009318127803091, 0.37437594949329234, 0.3641902042202976, 0.3861678602671492, 0.3578884156102605, 0.3422112109893385, 0.33119831670601085, 0.34342694466688894, 0.09040254597062436, 0.11348180317125411, 0.11562868990115371, 0.11125047835324076, 0.07998517921987602, 0.09707907174438568, 0.10792108243695131, 0.08949280762037215, 0.09512158493492773, 0.23535094835420545, 0.18579444586385085, 0.21780901089872595, 0.1850440856283393, 0.2066832099927195, 0.16491907874744738, 0.21156417238623637, 0.19360657075037502, 0.19416198201020585, 0.28223856530546676, 0.2533036519345665, 0.282240079756386, 0.26242079044486, 0.2564294103710859, 0.2605707320336784, 0.2739170312808594, 0.2566755370837476, 0.26585248724875843, 0.15873501511916843, 0.22393507846460436, 0.23764162893799423, 0.21813966838782972, 0.19241089084437968, 0.2044814707625685, 0.21017503641355417, 0.18904109747077114, 0.1754865319331359, 0.20622105219011222, 0.18776452063826632, 0.21376591213753404, 0.23324914028839394, 0.205066595684807, 0.2503360239343341, 0.24417117969728297, 0.20685860104072207, 0.19082512067891666, 0.184793393739365, 0.21406845567337496, 0.19558128797256358, 0.21871876120312583, 0.1898510588404725, 0.1795672623743807, 0.21175710496933864, 0.2168799747771304, 0.20942025913130313, 0.12388902365706822, 0.12468165161797573, 0.15353579478460766, 0.4814767329750208, 0.1994829295753383, 0.6169745626832828, 0.6229668953253353, 0.5749319823824819, 0.5638726507713668, 0.47579935535484374, 0.15400208322969466, 0.4718293545878056, 0.4755944028320618, 0.16869096483846624, 0.5119358775444992, 0.4308860031612681, 0.39747750479002475, 0.31603492522451837, 0.19768717174738948, 0.20117189310421213, 0.17807666538032918, 0.23482139405438263, 0.20166134741183173, 0.18064627893070428, 0.18953593942701585, 0.17600696545887462, 0.1805559098991968, 0.08320460494520443, 0.0891661623473965, 0.0804028938217427, 0.08386283004960826, 0.08580788034797426, 0.0900703419684109, 0.09894011674154057, 0.09133793006425817, 0.08848856916796399]}, "mutation_prompt": null}
{"id": "3e8003be-6890-41b4-971a-dcc7a811ba80", "solution": "import numpy as np\n\nclass DynamicSwarmPSO:\n    def __init__(self, budget, dim, initial_swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.initial_swarm_size = initial_swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1, self.c2 = 2.0, 2.0\n        self.w_init, self.w_final = 0.9, 0.4\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.initial_swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.initial_swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        swarm_size = self.initial_swarm_size\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions[:swarm_size]])\n            self.evaluations += swarm_size\n\n            better_mask = scores < self.personal_best_scores[:swarm_size]\n            self.personal_best_scores[:swarm_size][better_mask] = scores[better_mask]\n            self.personal_best_positions[:swarm_size][better_mask] = self.positions[:swarm_size][better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_init - ((self.w_init - self.w_final) * self.evaluations / self.budget)\n\n            r1, r2 = np.random.rand(swarm_size, self.dim), np.random.rand(swarm_size, self.dim)\n            cognitive_velocity = self.c1 * r1 * (self.personal_best_positions[:swarm_size] - self.positions[:swarm_size])\n            social_velocity = self.c2 * r2 * (self.global_best_position - self.positions[:swarm_size])\n            self.velocities[:swarm_size] = w * self.velocities[:swarm_size] + cognitive_velocity + social_velocity\n            self.velocities[:swarm_size] = np.clip(self.velocities[:swarm_size], -velocity_clamp, velocity_clamp)\n            self.positions[:swarm_size] += self.velocities[:swarm_size]\n\n            # Dynamic swarm size adjustment\n            if iteration % 20 == 0:\n                swarm_size = int(self.initial_swarm_size * (0.5 + 0.5 * np.sin(np.pi * iteration / 50)))\n                if swarm_size < 5:\n                    swarm_size = 5\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "DynamicSwarmPSO", "description": "Introduce dynamic swarm sizes and adaptive inertia weight reduction to enhance exploration and exploitation balance in PSO.", "configspace": "", "generation": 91, "fitness": 0.28639152665595785, "feedback": "The algorithm DynamicSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.678033980936988, 0.6408286279774933, 0.6649753328970637, 0.7078858592117476, 0.6847990296036885, 0.639890319172822, 0.6643189191868137, 0.6801396899179981, 0.6414853115723725, 0.38209520033124367, 0.391975819767567, 0.39653732903501304, 0.43584700937441856, 0.40011143268946026, 0.42379975871337106, 0.37563476984190425, 0.38468120266804895, 0.4127016634623526, 0.14816749696365583, 0.14813424305014344, 0.15533105845691897, 0.15771190641505106, 0.1614932337927577, 0.12974005474897454, 0.13389059898654665, 0.1138898912491797, 0.10743464997756802, 0.12639652171061755, 0.12330666823569336, 0.11258858396871696, 0.14824758749982048, 0.10929603270759258, 0.13615478207597664, 0.11255054880408732, 0.10501182008956389, 0.09441379253742088, 0.9863655915183328, 0.9809237123606127, 0.9842171342489842, 0.976925996599979, 0.9782965893979708, 0.9699273864624602, 0.9793627767000169, 0.9794670459549029, 0.980568422285166, 0.40257018994990057, 0.36869589584444606, 0.3743185837737597, 0.3641076902900884, 0.4526116837234051, 0.3768829523994105, 0.3803935926922708, 0.4233399780020568, 0.40080844897588486, 0.5909734622256915, 0.6165679583892181, 0.6318133511415747, 0.2591158119778352, 0.2617267237709816, 0.35822054793279645, 0.6481802933730347, 0.23566433663467268, 0.2838735608970655, 0.17665849198864747, 0.12789309481953637, 0.19023911288291107, 0.16456714734958422, 0.17316070691129315, 0.21550636675370882, 0.15780272254003247, 0.17489884705213388, 0.17172061073071365, 0.18088955431045073, 0.17561859774304067, 0.19312659713418256, 0.21545182891552073, 0.13811401645937227, 0.1658748911083503, 0.19623266180065901, 0.18216439140954266, 0.11810596373626703, 0.06410354402111529, 9.999999999998899e-05, 0.05108481868464965, 0.008441380754480976, 9.999999999998899e-05, 0.03337777630557981, 0.05882180871585119, 0.0059385666751804456, 0.04959074607072833, 0.10808987734857256, 0.06757123894168415, 0.11259117720191902, 0.059078920787753675, 0.039249802877372564, 0.03140697386672875, 0.17341860767135753, 0.09120281133148878, 0.07313502425233032, 0.1528218258726729, 0.078417960995109, 0.09187474012210672, 0.05738603222934102, 0.09220303991783863, 0.14676063087424085, 0.031108422599371965, 0.0900037150837053, 0.022582434574212162, 0.14682878073057504, 0.06887883510103288, 0.10802437346753047, 0.18272140326832342, 0.13636493838874508, 0.21682367865483243, 0.08563463640711522, 0.08645555619061374, 0.11707038617520105, 0.44703842495090795, 0.4706022552640037, 0.4306230906937297, 0.4329151675626649, 0.49409414615951686, 0.4705185865421444, 0.46212607491856916, 0.4722005733207024, 0.47167899974623284, 0.10084302094417075, 0.1186646218893771, 0.14077684384018152, 0.14152064603739511, 0.11443006422124835, 0.12311187908025023, 0.10814277257374072, 0.12800208464804141, 0.08441879107656491, 0.35349947186636677, 0.21726774533280235, 0.23689621283816364, 0.23621248252663907, 0.23991896897916354, 0.2660859933574681, 0.30078241774119774, 0.27785949445555114, 0.2451657058277006, 0.30530721543198425, 0.31546156110198575, 0.24653286672651553, 0.2752289861241711, 0.3513900302209425, 0.3659166650812413, 0.26543053426927776, 0.37432922986635153, 0.38471918517418924, 0.18597984477306262, 0.2541095328617531, 0.2371289662883227, 0.25873301233195756, 0.21193829128407793, 0.24210592155511745, 0.23508185497503697, 0.28780985664251835, 0.21628858344028756, 0.2434817609599671, 0.22197636737549753, 0.23857192372376335, 0.202242154382699, 0.23577605224558007, 0.20323367778182688, 0.21841174656264173, 0.21861707453031354, 0.23799323521589333, 0.2171535940543613, 0.23478341611179854, 0.22651044704335466, 0.2302705633384481, 0.1961169754330867, 0.20491943802406087, 0.21903991402620127, 0.3634383972111451, 0.537983196369985, 0.12466922535978897, 0.17378179789338322, 0.154103056520013, 0.712232145786716, 0.19952492725062487, 0.8229584413905348, 0.7294133354753084, 0.7511303742004702, 0.7856830438330842, 0.5527879210372049, 0.15551128615725307, 0.6876115179655046, 0.20854315995298867, 0.1691422201831576, 0.6041286725030479, 0.42995858473461634, 0.10473919505470075, 0.5735407331456359, 0.18204659746964147, 0.19551920385036003, 0.18039210473370693, 0.204604708225968, 0.20372142379747182, 0.1817466895845784, 0.24514705628834965, 0.17873009573595677, 0.18737698375871525, 0.10175273171176946, 0.09414668013601912, 0.0931173982872966, 0.09116208201652531, 0.09462779890017359, 0.09633523900633323, 0.1088050029045684, 0.09785982119011583, 0.10189937775292768]}, "mutation_prompt": null}
{"id": "f77887bf-20b3-4c7c-a771-4026f64cc1dd", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "99984357-9200-4f08-bfeb-5cc6cae50fe9", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "9ac905b2-8fe5-4530-a25a-276bba099082", "solution": "import numpy as np\n\nclass HierarchicalLearningPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        hierarchical_factor = np.linspace(0.1, 0.9, self.swarm_size)\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            if iteration % 10 == 0:\n                self.positions += hierarchical_factor[:, None] * (self.global_best_position - self.positions)\n                self.positions = np.clip(self.positions, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "HierarchicalLearningPSO", "description": "Adaptive Particle Swarm Optimization with Hierarchical Learning for Robust Exploration and Exploitation.", "configspace": "", "generation": 94, "fitness": 0.30449804974924355, "feedback": "The algorithm HierarchicalLearningPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8932697530260805, 0.9246975265773856, 0.9093913428826415, 0.9085397770416919, 0.9136960342775027, 0.9263515293191147, 0.9160027865125614, 0.9163483507145079, 0.8990752364874691, 0.7782743102788812, 0.42866222851097124, 0.7881414174343105, 0.343193472394711, 0.7306706634832593, 0.7393637561628396, 0.7549662277865878, 0.8089049833416049, 0.08675406236988614, 0.1311767140911495, 0.1628669886144386, 0.09507367712834824, 0.11460094853832725, 0.17831096505511324, 0.13847653233678103, 0.11665784336068752, 0.11919253150385589, 0.6588777159984647, 0.1229659973086844, 0.11797500432925956, 0.1128086580119958, 0.09733149624487791, 0.08619841677332729, 0.09579363145731767, 0.0657722024976074, 0.07939598610106746, 0.10979381828872725, 0.9673004855763532, 0.9778932800965691, 0.9697648304811997, 0.9346126165530062, 0.949314076172538, 0.9498422806564479, 0.9605926487500384, 0.9499141806119663, 0.9621122821137871, 0.7834893889021448, 0.4979345417999641, 0.4153947648271177, 0.805053063293042, 0.8094955911867212, 0.7831874014355337, 0.7016510524656412, 0.7794835292888088, 0.5629416016028121, 0.3012501479767111, 0.14107413182837336, 0.22943938185414048, 0.28324654595276355, 0.17693494702141654, 0.21545243895180355, 0.11018175072190062, 0.15204721812444388, 0.1778806134871329, 0.19010759001281086, 0.15276890236751328, 0.12960287799362213, 0.32177956337332103, 0.17402066070989952, 0.17056679876717717, 0.18688625219467703, 0.34042144140192354, 0.15294925045190888, 0.16922166586101883, 0.008004948818502777, 0.13449529309146457, 0.16573041914713826, 0.18384847170007468, 0.259407234552276, 0.17877973236981548, 0.11605737338524702, 0.12393795374846428, 9.999999999998899e-05, 0.009396157977775377, 0.008586754498946747, 0.043312892266402, 9.999999999998899e-05, 0.02381195134735281, 0.046716422972597704, 9.999999999998899e-05, 0.0007138002858140258, 0.0931856791267377, 0.030751739382713694, 0.0813758231889915, 0.06020663677382054, 0.014330266682536563, 0.006541556899343548, 0.180168717673995, 0.06530309271991241, 0.0550447743635305, 0.15581181500322583, 0.14634046609989526, 0.13129869989537946, 0.1384263211348098, 0.13676258971420574, 0.15282704493572052, 0.12448428548301838, 0.036525979632831884, 0.10693365821316225, 0.15755357338265807, 0.23743064898287947, 0.20492175548986302, 0.09338052494718718, 0.09201373621146736, 0.11513689684179684, 0.08707113910008868, 0.11488678533397612, 0.12074364837770957, 0.5417917941744463, 0.5897087838027644, 0.5917893434607396, 0.5549366354495568, 0.6092538363165916, 0.5751145020324018, 0.5966435216876765, 0.5802907351022539, 0.6559810009222771, 0.07734281719551328, 0.09625497801537841, 0.10891516945016133, 0.09778688807607339, 0.06440368518854667, 0.10607147294319708, 0.10051559370189644, 0.12827814165999551, 0.07803808952636171, 0.6223285345102794, 0.2466020335391278, 0.23034953685746018, 0.2506415484025277, 0.3415780632008487, 0.19471161246492752, 0.23243849935968663, 0.16628746117085014, 0.19218208437535023, 0.1724825672100464, 0.473842232695067, 0.32387187036942666, 0.4755478634792911, 0.2872293786691522, 0.33999858447007614, 0.28117959800677905, 0.5185749269669949, 0.29396575890694177, 0.16764816271334426, 0.31925851227177005, 0.27159952052255154, 0.2767958957055846, 0.23942141326509658, 0.2894321391832425, 0.2554923411675277, 0.3322246590951137, 0.26835253530832426, 0.23173562247372392, 0.17141469012655175, 0.19482066511054752, 0.24916996021224824, 0.199898249628237, 0.22672534733808092, 0.24925630041237568, 0.23656827892982724, 0.2224765081105501, 0.19141749070168002, 0.2105465744652213, 0.2083658148797558, 0.21415569782773458, 0.23136737846930133, 0.22635321677028064, 0.210421766265374, 0.2467953339121416, 0.2228563479670248, 0.9374750821591357, 0.1269222029276087, 0.15417556679631084, 0.9403789661314674, 0.20187910868515935, 0.20151670844131608, 0.12280378355237043, 0.17018595628807676, 0.9294371847036152, 0.7131998429120694, 0.1577266793512585, 0.07334223602440015, 0.21291647443080153, 0.16955211162895134, 0.21285379551678085, 0.10525973636125696, 0.10529610247790155, 0.46898992019334906, 0.19829917589279722, 0.18002582765893171, 0.20537622695184732, 0.19794338846683257, 0.18553749079648063, 0.1922594109240292, 0.1980229945832258, 0.20495096877662367, 0.19240365426937456, 0.10292869864005583, 0.07245417799877618, 0.09171793628164848, 0.10250741996548418, 0.09942995960820022, 0.08575161840729872, 0.07974868876674968, 0.07887632285084178, 0.08999411736009355]}, "mutation_prompt": null}
{"id": "f7225741-7aad-47b1-8205-91cf2ed25307", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "62b73f78-4f85-4061-a3ad-f8cdd55ce351", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "3d60c073-8ac1-4cc5-9058-ac07c2822d3e", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "23d58ac4-b66f-44cf-bd00-5f681bb7f9ee", "solution": "import numpy as np\n\nclass AdaptiveHybridMutationPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.num_swarms = 3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.c1_min, self.c1_max = 1.5, 2.5\n        self.c2_min, self.c2_max = 1.5, 2.5\n        self.w_min, self.w_max = 0.4, 0.9\n        self.k = 0.729\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        velocity_clamp = (self.upper_bound - self.lower_bound) * 0.1\n        adaptive_factor = np.ones(self.swarm_size) * 0.5\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = self.w_max - ((self.w_max - self.w_min) * iteration / (self.budget // self.swarm_size))\n            c1 = self.c1_max - ((self.c1_max - self.c1_min) * iteration / (self.budget // self.swarm_size))\n            c2 = self.c2_min + ((self.c2_max - self.c2_min) * iteration / (self.budget // self.swarm_size))\n\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = self.k * (w * self.velocities + cognitive_velocity + social_velocity)\n            self.velocities = np.clip(self.velocities, -velocity_clamp, velocity_clamp)\n            self.positions += self.velocities\n            \n            # Adaptive topology\n            if iteration % 10 == 0:\n                self.num_swarms = np.random.randint(1, 5)\n                adjacency_matrix = np.random.rand(self.swarm_size, self.swarm_size) < (1.0 / self.num_swarms)\n                for i in range(self.swarm_size):\n                    neighbors = adjacency_matrix[i, :]\n                    neighbor_best = np.min(scores[neighbors])\n                    if neighbor_best < scores[i]:\n                        adaptive_factor[i] = 0.9\n                    else:\n                        adaptive_factor[i] = 0.1\n\n            # Hybrid mutation strategy\n            if iteration % 15 == 0: \n                mutation_strength = 0.02 + 0.38 * (1 - (iteration / (self.budget // self.swarm_size)))\n                mutation_indices = np.random.choice(self.swarm_size, self.swarm_size // 3, replace=False)\n                uniform_mutation = np.random.uniform(-0.5, 0.5, (len(mutation_indices), self.dim))\n                gaussian_mutation = np.random.normal(0, mutation_strength, (len(mutation_indices), self.dim))\n                hybrid_mutation = adaptive_factor[mutation_indices][:, None] * uniform_mutation + (1 - adaptive_factor[mutation_indices][:, None]) * gaussian_mutation\n                self.positions[mutation_indices] = np.clip(self.positions[mutation_indices] + hybrid_mutation, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptiveHybridMutationPSO", "description": "Introduce adaptive topology and hybrid mutation strategies in PSO to enhance search space exploration and convergence rate.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.8711818323478867, 0.8927951337144642, 0.8034719029028873, 0.9039606913047479, 0.8576948416441798, 0.7745893897475833, 0.8627034890620003, 0.8359048796016985, 0.7947075092948488, 0.5517140126137474, 0.6126722721762377, 0.6440472906073416, 0.6228137047752129, 0.5878831869860678, 0.7433208015314545, 0.6659911146534798, 0.44890405586774973, 0.6357251825534136, 0.15552405676043346, 0.1471362164830976, 0.16185824917061387, 0.1181112788545231, 0.1784345101538224, 0.1435015271052682, 0.149062272760487, 0.1436059291114199, 0.14958549696589196, 0.1208229218381155, 0.11223533597942204, 0.1396429444516447, 0.12604195553123831, 0.1114085460151093, 0.11053877241564392, 0.09633309149313718, 0.11344571541436943, 0.11329750801653315, 0.9540772911593026, 0.9528058363694131, 0.9615211182456851, 0.9472651057135587, 0.9538983462196261, 0.9467360996554889, 0.9569770208866011, 0.9537577063419084, 0.9538220508678917, 0.7085569880715821, 0.6371662677970055, 0.6057300582797663, 0.6639837704862253, 0.6612218655579472, 0.5955234483643617, 0.699572634782345, 0.6240295632341185, 0.6827869329147223, 0.23027878959942494, 0.7398877550292637, 0.17187653949549075, 0.2820906800940909, 0.27568108407459757, 0.2803101420419962, 0.17325630932894198, 0.12702364207037886, 0.23066440265025345, 0.21109166692235148, 0.25191330578497195, 0.23436883939947661, 0.20423466520287958, 0.19778320262263227, 0.21137425547270394, 0.21994361923850458, 0.2073590844570925, 0.2025256887084973, 0.2297556523791494, 0.21735971987989466, 0.19920111861666479, 0.2175624113438912, 0.21153595970588357, 0.13409455179301877, 0.23976060312373204, 0.22969218084069654, 0.21174664515598407, 0.04160596060649857, 0.006632594287103166, 0.04721631193271858, 0.045098251710881776, 0.009519124210901508, 0.10998039922006042, 0.000806125384169909, 9.999999999998899e-05, 9.999999999998899e-05, 0.11640997066315262, 0.06534744288431082, 0.10387611027839716, 0.07133174526676644, 0.023714183992311844, 0.043353826353519476, 0.13697948580788255, 0.07033016722183638, 0.0535918817039146, 0.08572773889722085, 0.11557280979921958, 0.11533714328204536, 0.14987798291206655, 0.11287534332928806, 0.2025555649118449, 0.209992422669933, 0.13498267337060865, 0.09423602731046288, 0.16070841266593583, 0.12389070313147132, 0.07957772194028345, 0.1430550412451752, 0.08568853760095263, 0.055054421354051586, 0.20107206943892086, 0.14468389353476263, 0.16409623079400348, 0.5822309603936445, 0.5062470516219784, 0.5233807503859689, 0.5995384602322015, 0.5480002252880034, 0.6124204079107674, 0.543562480966183, 0.5229516482963401, 0.5488935067316112, 0.1272360735002256, 0.07198127918957598, 0.10965243360116406, 0.13442018216066476, 0.10972077259783986, 0.12916852487587438, 0.14251346544704735, 0.16663489529124786, 0.09992709039995407, 0.28094083752586296, 0.3832347035752539, 0.1984671280746818, 0.4260014038380374, 0.2661383214315126, 0.21539723826475698, 0.21844529261192047, 0.21007564154113678, 0.23033857454525775, 0.3544798024587815, 0.4225190852378107, 0.27788504998138197, 0.415812384743812, 0.2667883119750717, 0.32548309299873457, 0.2448319680527551, 0.4719644126952428, 0.27581375427923993, 0.27145705836395495, 0.2921985859392957, 0.2637692441127516, 0.2532346749095097, 0.2394689702432412, 0.33059293348559926, 0.2575614145208901, 0.17219444621729685, 0.2253998057244334, 0.2695048602603858, 0.23922291842747634, 0.22578620526421733, 0.26619590390776005, 0.24437653061422449, 0.2388753554110774, 0.23840208157720044, 0.2607513311855214, 0.23540959779801074, 0.1886889444727905, 0.1950725292627763, 0.19837995834390276, 0.2465551565042544, 0.20398975467298486, 0.2115238416143448, 0.2517963592156258, 0.20866873837673228, 0.2060711077178694, 0.18873688447120285, 0.1263363289995041, 0.177279168188198, 0.1734451080455487, 0.20108634952956195, 0.9356462179717048, 0.8668460748523998, 0.9110300809613212, 0.9086157696069949, 0.7170021640165316, 0.15697597078904635, 0.6519287833411318, 0.21169963805584402, 0.16918383908301005, 0.21308334809780305, 0.1051646880354552, 0.10497667355903562, 0.16885546245564453, 0.22711135771392887, 0.18353848962745167, 0.21850514366733498, 0.2033671268889926, 0.2152207579614538, 0.19118417978695257, 0.2242700715684216, 0.2327933273320868, 0.2164954301462939, 0.08566449201060111, 0.09111954696115776, 0.09030814676407917, 0.0838220088832411, 0.12332336990921178, 0.08342665355571843, 0.17710826301691318, 0.09847464135068751, 0.08849425140024292]}, "mutation_prompt": null}
{"id": "93318829-a061-459c-8125-f3367977cb88", "solution": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim, swarm_size=30):\n        self.budget = budget\n        self.dim = dim\n        self.swarm_size = swarm_size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.swarm_size, self.dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_scores = np.full(self.swarm_size, float('inf'))\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_score = float('inf')\n        self.evaluations = 0\n\n    def __call__(self, func):\n        iteration = 0\n        dynamic_velocity_clamp = (self.upper_bound - self.lower_bound) * np.random.uniform(0.05, 0.15)\n\n        while self.evaluations < self.budget:\n            scores = np.array([func(pos) for pos in self.positions])\n            self.evaluations += self.swarm_size\n\n            better_mask = scores < self.personal_best_scores\n            self.personal_best_scores[better_mask] = scores[better_mask]\n            self.personal_best_positions[better_mask] = self.positions[better_mask]\n\n            best_particle = np.argmin(scores)\n            best_particle_score = scores[best_particle]\n            if best_particle_score < self.global_best_score:\n                self.global_best_score = best_particle_score\n                self.global_best_position = self.positions[best_particle]\n\n            w = 0.7 - ((0.6) * iteration / (self.budget // self.swarm_size))\n            c1 = 1.7 - ((0.2) * iteration / (self.budget // self.swarm_size))\n            c2 = 1.7 + ((0.5) * iteration / (self.budget // self.swarm_size))\n            r1, r2 = np.random.rand(self.swarm_size, self.dim), np.random.rand(self.swarm_size, self.dim)\n            cognitive_velocity = c1 * r1 * (self.personal_best_positions - self.positions)\n            social_velocity = c2 * r2 * (self.global_best_position - self.positions)\n            self.velocities = w * self.velocities + cognitive_velocity + social_velocity\n            self.velocities = np.clip(self.velocities, -dynamic_velocity_clamp, dynamic_velocity_clamp)\n            self.positions += self.velocities\n\n            if iteration % 10 == 0:\n                diversity_factor = np.std(self.positions, axis=0)\n                if np.mean(diversity_factor) < 0.1:\n                    self.positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.swarm_size, self.dim))\n\n            if iteration % 20 == 0:\n                differential_indices = np.random.choice(self.swarm_size, self.swarm_size // 2, replace=False)\n                for idx in differential_indices:\n                    partners = np.random.choice(self.swarm_size, 2, replace=False)\n                    differential_vector = (self.positions[partners[0]] - self.positions[partners[1]])\n                    self.positions[idx] = np.clip(self.positions[idx] + 0.5 * differential_vector, self.lower_bound, self.upper_bound)\n\n            iteration += 1\n\n        return self.global_best_position, self.global_best_score", "name": "EnhancedDynamicPSO", "description": "Enhance PSO with dynamic velocity scaling, adaptive swarm diversity control, and differential learning for improved convergence in complex landscapes.", "configspace": "", "generation": 99, "fitness": 0.28565436730094074, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "5d9bf088-fc5e-4462-95f4-a929f11d9b34", "metadata": {"aucs": [0.6112079016165968, 0.611216423401782, 0.5853434096273942, 0.6177434294280195, 0.6140853394841659, 0.5614467524138047, 0.5686121063673786, 0.5764379363184333, 0.5373796805787081, 0.2889495738564437, 0.25928841706993866, 0.15296331736152646, 0.3064514260439021, 0.2451339945249843, 0.2391430841954636, 0.22760398507939406, 0.2622669492078171, 0.1260831086714157, 0.18294090242120475, 0.15152089657310686, 0.1425943329134256, 0.14614339231131068, 0.1282991001050936, 0.10197791219771046, 0.1342586151156333, 0.10607409597006812, 0.15958326646456522, 0.14088263050026895, 0.12374284766146992, 0.09914744911182083, 0.11287697454221834, 0.11744541732736247, 0.1278794509259351, 0.146894984262662, 0.13638367716389876, 0.11358746897642436, 0.9726442774191117, 0.9779617645790684, 0.9365055811741325, 0.9735894276860904, 0.9686080040428694, 0.9059343665705254, 0.9751310073667825, 0.9645704092756722, 0.9168791430082273, 0.39477184366785767, 0.42329121353709964, 0.3778490527319177, 0.4230193561268002, 0.40367956452139453, 0.39751217858264176, 0.3967091320136915, 0.41306157580819125, 0.34185616567291943, 0.7990977365742733, 0.21167186714109698, 0.8109749129667034, 0.8372773732534136, 0.7093505018157504, 0.7443473600821873, 0.6827209498541957, 0.17714215111307707, 0.2286187287115713, 0.12981741493328425, 0.2608797716947545, 0.1553147844068652, 0.3642970239431046, 0.30970676251711227, 0.27922083339345827, 0.16447054265211447, 0.17629748508256493, 0.17712479187448193, 0.13328760914750581, 0.20437766658104017, 0.16242422925094857, 0.17487265641156935, 0.20866165882105092, 0.12886980383681823, 0.12758125841302403, 0.10009497060635308, 0.17109425983094895, 0.005854702304647019, 0.04548402909227811, 0.07868802102605454, 0.00706694057047863, 0.03820143718098845, 9.999999999998899e-05, 0.004680664979207494, 9.999999999998899e-05, 0.1479558121519241, 0.22868180132953853, 0.05933896405288763, 0.11218043648241294, 0.07233756322003049, 0.08930779712751213, 0.07414351600112767, 0.10358908196947758, 0.14764000723301962, 0.13660665721992682, 0.08772561570255899, 0.05942441479288596, 9.999999999998899e-05, 0.052187759271896894, 0.05159509926931827, 0.002385425616976189, 0.1681771843624158, 0.05418469448807739, 0.007671108316123498, 0.11575882640231683, 0.1998937045827469, 0.12494484616798496, 0.13903877396108733, 0.12377581831248119, 0.05217558864356031, 0.09808024412189698, 0.12669167166894058, 0.07005675348986884, 0.46268100174713755, 0.4616690897246377, 0.47417012249736623, 0.468756011723249, 0.5049246789358373, 0.43107874321783524, 0.4565041096133218, 0.47323114305167757, 0.4619228660421886, 0.10902228005150971, 0.13781680685768338, 0.0932456041311116, 0.15364973382001024, 0.10353658697296919, 0.0969884216250495, 0.13382938083890072, 0.1243177657947715, 0.11525016175998115, 0.16012852799784305, 0.2970142349849072, 0.37957934112103486, 0.18919261734487047, 0.3529681857311404, 0.21051969748982058, 0.4250379814507267, 0.2309887872574774, 0.44767321830219786, 0.2971580927988462, 0.303786303825207, 0.2647892765519787, 0.2646379704201228, 0.34883294002203147, 0.35893605023053454, 0.353943283236705, 0.3665569740535395, 0.22265162423374774, 0.20727337820123404, 0.26889835830996756, 0.2285482898804181, 0.2993871694260307, 0.20943673637877303, 0.27693448055318226, 0.2928751185542474, 0.22216104019367633, 0.1736700479647898, 0.25323922014448064, 0.2102861663283475, 0.22739916932490611, 0.28714325737616786, 0.2810164896950409, 0.24417365729806273, 0.21720984678738087, 0.22261063402638515, 0.23171996899800562, 0.3887913562027364, 0.25006938574400595, 0.18580747135234854, 0.21654301330960335, 0.19594236472988547, 0.1840917171012425, 0.4668328430230074, 0.2488202672511346, 0.2059141324026429, 0.17817774929455243, 0.12553524536584815, 0.10704470407400135, 0.8237166562276077, 0.20041189774653212, 0.8857424745928203, 0.8466753687799722, 0.16982315168381013, 0.9296394174952458, 0.6618975425088085, 0.1567814855669949, 0.11239344073112423, 0.7274554058337614, 0.21239944896014273, 0.9134945523625253, 0.1677867461148026, 0.16491141657501862, 0.729927933798372, 0.1951775598690323, 0.19302969348672772, 0.21798211329219297, 0.22612993008516247, 0.20224388218276645, 0.20021867537506466, 0.2067649799084884, 0.1895617938530959, 0.20262554375165387, 0.10576484742112113, 0.09064582438031399, 0.08507982303396933, 0.10632457072201418, 0.09922303909859109, 0.09812730282216564, 0.08801968519611525, 0.09418937091167479, 0.11005048828717567]}, "mutation_prompt": null}
