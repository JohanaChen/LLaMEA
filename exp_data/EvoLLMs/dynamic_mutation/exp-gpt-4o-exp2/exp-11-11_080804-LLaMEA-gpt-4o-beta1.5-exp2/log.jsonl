{"id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "solution": "import numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Recommended size for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5  # Mutation factor\n        self.cr = 0.9  # Crossover rate\n        self.alpha = 1.5  # Levy flight parameter\n        \n    def levy_flight(self, size):\n        # Generates steps using Levy distribution\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True  # Ensure at least one element is copied\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Apply Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                trial += step_size * self.levy_flight(self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveLevyDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Levy Flights to explore and exploit the search space efficiently.", "configspace": "", "generation": 0, "fitness": 0.1807622768396241, "feedback": "The algorithm AdaptiveLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.32116064716498194, 0.3220857404136839, 0.32128860217933397, 0.3313010878899617, 0.31116687334857285, 0.32898103275055746, 0.3138065286267345, 0.3193046642342352, 0.31990639500238804, 0.005206948990410076, 0.008926944436153827, 0.008088714115493945, 0.0025701583303306963, 0.00508493482751915, 0.007365983778751639, 0.0029082310843546733, 0.00743476823627065, 0.002724403377492468, 0.08212261841650892, 0.11413937390460083, 0.07841341920581801, 0.08376191323031212, 0.10680464456071714, 0.08988441053690499, 0.0956029225632461, 0.08445092140917354, 0.09181539577349307, 0.07066107420050105, 0.07287154515359706, 0.0776005869795876, 0.08255053670368595, 0.06922485219365748, 0.06642767626026902, 0.08132488328885157, 0.08648451550294556, 0.08544518998699002, 0.9492755868616752, 0.9423726468496557, 0.9634642170297736, 0.9531337849593216, 0.9553858466345133, 0.9316501034395107, 0.973674781074153, 0.9645439789185964, 0.9546849780615991, 0.18745025416802252, 0.19902657520930622, 0.19713169464262625, 0.17660006458706046, 0.18246020715337008, 0.18357705407969271, 0.17923143646203643, 0.18645775167205625, 0.18601098961532958, 0.23037946116214203, 0.22532970400552654, 0.27187063727028293, 0.22917720213282955, 0.22785512508719163, 0.23426739314410672, 0.2586522555898534, 0.2560944988807382, 0.26670383129330943, 0.10128499186493123, 0.10368932795565, 0.09854380400143037, 0.1165031188847031, 0.10763048845266954, 0.11102827002939664, 0.11128249539641621, 0.10774907655076116, 0.11444153680002522, 0.09924607448238143, 0.09188424774952386, 0.08981450413441738, 0.10728969394430299, 0.08941521058458934, 0.10497773943637079, 0.11707106412425661, 0.10328785721657419, 0.10908355391102509, 0.0018370124665271215, 0.0019280725193501214, 0.00322456870674237, 0.0009819674980954263, 0.003462307843471568, 0.010832872261146598, 0.001585734587806975, 0.000979298222194891, 0.00956564773472146, 0.0730147128403924, 0.0457425984717702, 0.0753526731050802, 0.10437614021589381, 0.0537822289831118, 0.03064334280860581, 0.05157910357908768, 0.09411013623706077, 0.10317212065161019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010366220333146714, 9.999999999998899e-05, 0.005901176330244784, 9.999999999998899e-05, 0.00012120830457174048, 0.04814177819461962, 0.05098082863773146, 0.040767921946167185, 0.04425372924823301, 0.042292610655382146, 0.051985114696308066, 0.05068119118861214, 0.04562404014320387, 0.043701429663313474, 0.3112241086590357, 0.3012880375099516, 0.31284899512909603, 0.30498392685273157, 0.30685460950262844, 0.3099940910551444, 0.3190951874157152, 0.31760445835593676, 0.3168535840598673, 0.09689462539669946, 0.08311797407006127, 0.08288097206191414, 0.08368683453507697, 0.08156353789751303, 0.08749658601790411, 0.09201519989005136, 0.08401262273913324, 0.09107064304491619, 0.12872628929527274, 0.12876337948141936, 0.13224941478770524, 0.13693794809662252, 0.15425629400842722, 0.19135360086262931, 0.1296988888515911, 0.1395587282730788, 0.16590887673172006, 0.23223850723933925, 0.22104110824999712, 0.23018254001310756, 0.23053573355327928, 0.23866853827899626, 0.2321231451983795, 0.2288511824051901, 0.2266791221946448, 0.2289780260501053, 0.17687606545638757, 0.18882112861971623, 0.17950273875052192, 0.18643585462742718, 0.17217183928520263, 0.16560423187359263, 0.19296399823843824, 0.1703869916539783, 0.18585148965993736, 0.1836129781557907, 0.17467679526146151, 0.1910907938946601, 0.1962017880736009, 0.18777004219974025, 0.19673512418401562, 0.2106070781298176, 0.1788057078618014, 0.19741655483859621, 0.17154565233354446, 0.17881553853896148, 0.17330251880695213, 0.17033013692987165, 0.19483275812633516, 0.17079168553929647, 0.1912789368306541, 0.17505533060417144, 0.1746058197082151, 0.16902952928632697, 0.3759148101116242, 0.18289474518976812, 0.3474641447289848, 0.3902418417971012, 0.1724001684050711, 0.31732927285350265, 0.34670759828463793, 0.3083811551986336, 0.28298709461871596, 0.18541464316815104, 0.2937091877583393, 0.24225993548796143, 0.1842191801988562, 0.3284306639341399, 0.33794619234499645, 0.15833669008559315, 0.19892407394667855, 0.20704422351402696, 0.1973617786148234, 0.19566943501262135, 0.19278796413735277, 0.1855243221019005, 0.18598091124162575, 0.19251234977939768, 0.1947474955704538, 0.19516765639789613, 0.073276916216793, 0.06952566798324022, 0.07419277140096747, 0.07937643759253132, 0.08307224526278223, 0.06919551215421793, 0.07748514439502818, 0.07117754524833164, 0.0807261132819771]}, "mutation_prompt": null}
{"id": "dcecc424-4d7c-4f46-882a-cad3d3943700", "solution": "import numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Recommended size for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5  # Mutation factor\n        self.cr = 0.9  # Crossover rate\n        self.alpha = 1.5  # Levy flight parameter\n        \n    def levy_flight(self, size):\n        # Generates steps using Levy distribution\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True  # Ensure at least one element is copied\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Apply Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                trial += step_size * self.levy_flight(self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveLevyDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Levy Flights to explore and exploit the search space efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "metadata": {"aucs": [0.32116064716498194, 0.3220857404136839, 0.32128860217933397, 0.3313010878899617, 0.31116687334857285, 0.32898103275055746, 0.3138065286267345, 0.3193046642342352, 0.31990639500238804, 0.005206948990410076, 0.008926944436153827, 0.008088714115493945, 0.0025701583303306963, 0.00508493482751915, 0.007365983778751639, 0.0029082310843546733, 0.00743476823627065, 0.002724403377492468, 0.08212261841650892, 0.11413937390460083, 0.07841341920581801, 0.08376191323031212, 0.10680464456071714, 0.08988441053690499, 0.0956029225632461, 0.08445092140917354, 0.09181539577349307, 0.07066107420050105, 0.07287154515359706, 0.0776005869795876, 0.08255053670368595, 0.06922485219365748, 0.06642767626026902, 0.08132488328885157, 0.08648451550294556, 0.08544518998699002, 0.9492755868616752, 0.9423726468496557, 0.9634642170297736, 0.9531337849593216, 0.9553858466345133, 0.9316501034395107, 0.973674781074153, 0.9645439789185964, 0.9546849780615991, 0.18745025416802252, 0.19902657520930622, 0.19713169464262625, 0.17660006458706046, 0.18246020715337008, 0.18357705407969271, 0.17923143646203643, 0.18645775167205625, 0.18601098961532958, 0.23037946116214203, 0.22532970400552654, 0.27187063727028293, 0.22917720213282955, 0.22785512508719163, 0.23426739314410672, 0.2586522555898534, 0.2560944988807382, 0.26670383129330943, 0.10128499186493123, 0.10368932795565, 0.09854380400143037, 0.1165031188847031, 0.10763048845266954, 0.11102827002939664, 0.11128249539641621, 0.10774907655076116, 0.11444153680002522, 0.09924607448238143, 0.09188424774952386, 0.08981450413441738, 0.10728969394430299, 0.08941521058458934, 0.10497773943637079, 0.11707106412425661, 0.10328785721657419, 0.10908355391102509, 0.0018370124665271215, 0.0019280725193501214, 0.00322456870674237, 0.0009819674980954263, 0.003462307843471568, 0.010832872261146598, 0.001585734587806975, 0.000979298222194891, 0.00956564773472146, 0.0730147128403924, 0.0457425984717702, 0.0753526731050802, 0.10437614021589381, 0.0537822289831118, 0.03064334280860581, 0.05157910357908768, 0.09411013623706077, 0.10317212065161019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010366220333146714, 9.999999999998899e-05, 0.005901176330244784, 9.999999999998899e-05, 0.00012120830457174048, 0.04814177819461962, 0.05098082863773146, 0.040767921946167185, 0.04425372924823301, 0.042292610655382146, 0.051985114696308066, 0.05068119118861214, 0.04562404014320387, 0.043701429663313474, 0.3112241086590357, 0.3012880375099516, 0.31284899512909603, 0.30498392685273157, 0.30685460950262844, 0.3099940910551444, 0.3190951874157152, 0.31760445835593676, 0.3168535840598673, 0.09689462539669946, 0.08311797407006127, 0.08288097206191414, 0.08368683453507697, 0.08156353789751303, 0.08749658601790411, 0.09201519989005136, 0.08401262273913324, 0.09107064304491619, 0.12872628929527274, 0.12876337948141936, 0.13224941478770524, 0.13693794809662252, 0.15425629400842722, 0.19135360086262931, 0.1296988888515911, 0.1395587282730788, 0.16590887673172006, 0.23223850723933925, 0.22104110824999712, 0.23018254001310756, 0.23053573355327928, 0.23866853827899626, 0.2321231451983795, 0.2288511824051901, 0.2266791221946448, 0.2289780260501053, 0.17687606545638757, 0.18882112861971623, 0.17950273875052192, 0.18643585462742718, 0.17217183928520263, 0.16560423187359263, 0.19296399823843824, 0.1703869916539783, 0.18585148965993736, 0.1836129781557907, 0.17467679526146151, 0.1910907938946601, 0.1962017880736009, 0.18777004219974025, 0.19673512418401562, 0.2106070781298176, 0.1788057078618014, 0.19741655483859621, 0.17154565233354446, 0.17881553853896148, 0.17330251880695213, 0.17033013692987165, 0.19483275812633516, 0.17079168553929647, 0.1912789368306541, 0.17505533060417144, 0.1746058197082151, 0.16902952928632697, 0.3759148101116242, 0.18289474518976812, 0.3474641447289848, 0.3902418417971012, 0.1724001684050711, 0.31732927285350265, 0.34670759828463793, 0.3083811551986336, 0.28298709461871596, 0.18541464316815104, 0.2937091877583393, 0.24225993548796143, 0.1842191801988562, 0.3284306639341399, 0.33794619234499645, 0.15833669008559315, 0.19892407394667855, 0.20704422351402696, 0.1973617786148234, 0.19566943501262135, 0.19278796413735277, 0.1855243221019005, 0.18598091124162575, 0.19251234977939768, 0.1947474955704538, 0.19516765639789613, 0.073276916216793, 0.06952566798324022, 0.07419277140096747, 0.07937643759253132, 0.08307224526278223, 0.06919551215421793, 0.07748514439502818, 0.07117754524833164, 0.0807261132819771]}, "mutation_prompt": null}
{"id": "da518f48-9c09-42ce-ac47-78f93e140f57", "solution": "import numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Recommended size for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5  # Mutation factor\n        self.cr = 0.9  # Crossover rate\n        self.alpha = 1.5  # Levy flight parameter\n        \n    def levy_flight(self, size):\n        # Generates steps using Levy distribution\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True  # Ensure at least one element is copied\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Apply Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                trial += step_size * self.levy_flight(self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveLevyDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Levy Flights to explore and exploit the search space efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "metadata": {"aucs": [0.32116064716498194, 0.3220857404136839, 0.32128860217933397, 0.3313010878899617, 0.31116687334857285, 0.32898103275055746, 0.3138065286267345, 0.3193046642342352, 0.31990639500238804, 0.005206948990410076, 0.008926944436153827, 0.008088714115493945, 0.0025701583303306963, 0.00508493482751915, 0.007365983778751639, 0.0029082310843546733, 0.00743476823627065, 0.002724403377492468, 0.08212261841650892, 0.11413937390460083, 0.07841341920581801, 0.08376191323031212, 0.10680464456071714, 0.08988441053690499, 0.0956029225632461, 0.08445092140917354, 0.09181539577349307, 0.07066107420050105, 0.07287154515359706, 0.0776005869795876, 0.08255053670368595, 0.06922485219365748, 0.06642767626026902, 0.08132488328885157, 0.08648451550294556, 0.08544518998699002, 0.9492755868616752, 0.9423726468496557, 0.9634642170297736, 0.9531337849593216, 0.9553858466345133, 0.9316501034395107, 0.973674781074153, 0.9645439789185964, 0.9546849780615991, 0.18745025416802252, 0.19902657520930622, 0.19713169464262625, 0.17660006458706046, 0.18246020715337008, 0.18357705407969271, 0.17923143646203643, 0.18645775167205625, 0.18601098961532958, 0.23037946116214203, 0.22532970400552654, 0.27187063727028293, 0.22917720213282955, 0.22785512508719163, 0.23426739314410672, 0.2586522555898534, 0.2560944988807382, 0.26670383129330943, 0.10128499186493123, 0.10368932795565, 0.09854380400143037, 0.1165031188847031, 0.10763048845266954, 0.11102827002939664, 0.11128249539641621, 0.10774907655076116, 0.11444153680002522, 0.09924607448238143, 0.09188424774952386, 0.08981450413441738, 0.10728969394430299, 0.08941521058458934, 0.10497773943637079, 0.11707106412425661, 0.10328785721657419, 0.10908355391102509, 0.0018370124665271215, 0.0019280725193501214, 0.00322456870674237, 0.0009819674980954263, 0.003462307843471568, 0.010832872261146598, 0.001585734587806975, 0.000979298222194891, 0.00956564773472146, 0.0730147128403924, 0.0457425984717702, 0.0753526731050802, 0.10437614021589381, 0.0537822289831118, 0.03064334280860581, 0.05157910357908768, 0.09411013623706077, 0.10317212065161019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010366220333146714, 9.999999999998899e-05, 0.005901176330244784, 9.999999999998899e-05, 0.00012120830457174048, 0.04814177819461962, 0.05098082863773146, 0.040767921946167185, 0.04425372924823301, 0.042292610655382146, 0.051985114696308066, 0.05068119118861214, 0.04562404014320387, 0.043701429663313474, 0.3112241086590357, 0.3012880375099516, 0.31284899512909603, 0.30498392685273157, 0.30685460950262844, 0.3099940910551444, 0.3190951874157152, 0.31760445835593676, 0.3168535840598673, 0.09689462539669946, 0.08311797407006127, 0.08288097206191414, 0.08368683453507697, 0.08156353789751303, 0.08749658601790411, 0.09201519989005136, 0.08401262273913324, 0.09107064304491619, 0.12872628929527274, 0.12876337948141936, 0.13224941478770524, 0.13693794809662252, 0.15425629400842722, 0.19135360086262931, 0.1296988888515911, 0.1395587282730788, 0.16590887673172006, 0.23223850723933925, 0.22104110824999712, 0.23018254001310756, 0.23053573355327928, 0.23866853827899626, 0.2321231451983795, 0.2288511824051901, 0.2266791221946448, 0.2289780260501053, 0.17687606545638757, 0.18882112861971623, 0.17950273875052192, 0.18643585462742718, 0.17217183928520263, 0.16560423187359263, 0.19296399823843824, 0.1703869916539783, 0.18585148965993736, 0.1836129781557907, 0.17467679526146151, 0.1910907938946601, 0.1962017880736009, 0.18777004219974025, 0.19673512418401562, 0.2106070781298176, 0.1788057078618014, 0.19741655483859621, 0.17154565233354446, 0.17881553853896148, 0.17330251880695213, 0.17033013692987165, 0.19483275812633516, 0.17079168553929647, 0.1912789368306541, 0.17505533060417144, 0.1746058197082151, 0.16902952928632697, 0.3759148101116242, 0.18289474518976812, 0.3474641447289848, 0.3902418417971012, 0.1724001684050711, 0.31732927285350265, 0.34670759828463793, 0.3083811551986336, 0.28298709461871596, 0.18541464316815104, 0.2937091877583393, 0.24225993548796143, 0.1842191801988562, 0.3284306639341399, 0.33794619234499645, 0.15833669008559315, 0.19892407394667855, 0.20704422351402696, 0.1973617786148234, 0.19566943501262135, 0.19278796413735277, 0.1855243221019005, 0.18598091124162575, 0.19251234977939768, 0.1947474955704538, 0.19516765639789613, 0.073276916216793, 0.06952566798324022, 0.07419277140096747, 0.07937643759253132, 0.08307224526278223, 0.06919551215421793, 0.07748514439502818, 0.07117754524833164, 0.0807261132819771]}, "mutation_prompt": null}
{"id": "2c05e107-1a2d-4498-af68-1201286dd4b0", "solution": "import numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Recommended size for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5  # Mutation factor\n        self.cr = 0.9  # Crossover rate\n        self.alpha = 1.5  # Levy flight parameter\n        \n    def levy_flight(self, size):\n        # Generates steps using Levy distribution\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True  # Ensure at least one element is copied\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Apply Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                trial += step_size * self.levy_flight(self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveLevyDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Levy Flights to explore and exploit the search space efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "metadata": {"aucs": [0.32116064716498194, 0.3220857404136839, 0.32128860217933397, 0.3313010878899617, 0.31116687334857285, 0.32898103275055746, 0.3138065286267345, 0.3193046642342352, 0.31990639500238804, 0.005206948990410076, 0.008926944436153827, 0.008088714115493945, 0.0025701583303306963, 0.00508493482751915, 0.007365983778751639, 0.0029082310843546733, 0.00743476823627065, 0.002724403377492468, 0.08212261841650892, 0.11413937390460083, 0.07841341920581801, 0.08376191323031212, 0.10680464456071714, 0.08988441053690499, 0.0956029225632461, 0.08445092140917354, 0.09181539577349307, 0.07066107420050105, 0.07287154515359706, 0.0776005869795876, 0.08255053670368595, 0.06922485219365748, 0.06642767626026902, 0.08132488328885157, 0.08648451550294556, 0.08544518998699002, 0.9492755868616752, 0.9423726468496557, 0.9634642170297736, 0.9531337849593216, 0.9553858466345133, 0.9316501034395107, 0.973674781074153, 0.9645439789185964, 0.9546849780615991, 0.18745025416802252, 0.19902657520930622, 0.19713169464262625, 0.17660006458706046, 0.18246020715337008, 0.18357705407969271, 0.17923143646203643, 0.18645775167205625, 0.18601098961532958, 0.23037946116214203, 0.22532970400552654, 0.27187063727028293, 0.22917720213282955, 0.22785512508719163, 0.23426739314410672, 0.2586522555898534, 0.2560944988807382, 0.26670383129330943, 0.10128499186493123, 0.10368932795565, 0.09854380400143037, 0.1165031188847031, 0.10763048845266954, 0.11102827002939664, 0.11128249539641621, 0.10774907655076116, 0.11444153680002522, 0.09924607448238143, 0.09188424774952386, 0.08981450413441738, 0.10728969394430299, 0.08941521058458934, 0.10497773943637079, 0.11707106412425661, 0.10328785721657419, 0.10908355391102509, 0.0018370124665271215, 0.0019280725193501214, 0.00322456870674237, 0.0009819674980954263, 0.003462307843471568, 0.010832872261146598, 0.001585734587806975, 0.000979298222194891, 0.00956564773472146, 0.0730147128403924, 0.0457425984717702, 0.0753526731050802, 0.10437614021589381, 0.0537822289831118, 0.03064334280860581, 0.05157910357908768, 0.09411013623706077, 0.10317212065161019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010366220333146714, 9.999999999998899e-05, 0.005901176330244784, 9.999999999998899e-05, 0.00012120830457174048, 0.04814177819461962, 0.05098082863773146, 0.040767921946167185, 0.04425372924823301, 0.042292610655382146, 0.051985114696308066, 0.05068119118861214, 0.04562404014320387, 0.043701429663313474, 0.3112241086590357, 0.3012880375099516, 0.31284899512909603, 0.30498392685273157, 0.30685460950262844, 0.3099940910551444, 0.3190951874157152, 0.31760445835593676, 0.3168535840598673, 0.09689462539669946, 0.08311797407006127, 0.08288097206191414, 0.08368683453507697, 0.08156353789751303, 0.08749658601790411, 0.09201519989005136, 0.08401262273913324, 0.09107064304491619, 0.12872628929527274, 0.12876337948141936, 0.13224941478770524, 0.13693794809662252, 0.15425629400842722, 0.19135360086262931, 0.1296988888515911, 0.1395587282730788, 0.16590887673172006, 0.23223850723933925, 0.22104110824999712, 0.23018254001310756, 0.23053573355327928, 0.23866853827899626, 0.2321231451983795, 0.2288511824051901, 0.2266791221946448, 0.2289780260501053, 0.17687606545638757, 0.18882112861971623, 0.17950273875052192, 0.18643585462742718, 0.17217183928520263, 0.16560423187359263, 0.19296399823843824, 0.1703869916539783, 0.18585148965993736, 0.1836129781557907, 0.17467679526146151, 0.1910907938946601, 0.1962017880736009, 0.18777004219974025, 0.19673512418401562, 0.2106070781298176, 0.1788057078618014, 0.19741655483859621, 0.17154565233354446, 0.17881553853896148, 0.17330251880695213, 0.17033013692987165, 0.19483275812633516, 0.17079168553929647, 0.1912789368306541, 0.17505533060417144, 0.1746058197082151, 0.16902952928632697, 0.3759148101116242, 0.18289474518976812, 0.3474641447289848, 0.3902418417971012, 0.1724001684050711, 0.31732927285350265, 0.34670759828463793, 0.3083811551986336, 0.28298709461871596, 0.18541464316815104, 0.2937091877583393, 0.24225993548796143, 0.1842191801988562, 0.3284306639341399, 0.33794619234499645, 0.15833669008559315, 0.19892407394667855, 0.20704422351402696, 0.1973617786148234, 0.19566943501262135, 0.19278796413735277, 0.1855243221019005, 0.18598091124162575, 0.19251234977939768, 0.1947474955704538, 0.19516765639789613, 0.073276916216793, 0.06952566798324022, 0.07419277140096747, 0.07937643759253132, 0.08307224526278223, 0.06919551215421793, 0.07748514439502818, 0.07117754524833164, 0.0807261132819771]}, "mutation_prompt": null}
{"id": "063b34f0-9ad8-4867-9e1c-7f834b2e5460", "solution": "import numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Recommended size for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5  # Mutation factor\n        self.cr_initial = 0.9  # Initial Crossover rate\n        self.alpha = 1.5  # Levy flight parameter\n        \n    def levy_flight(self, size):\n        # Generates steps using Levy distribution\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                cr = self.cr_initial * ((self.budget - evaluations) / self.budget)\n                crossover = np.random.rand(self.dim) < cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True  # Ensure at least one element is copied\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Apply Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                trial += step_size * self.levy_flight(self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveLevyDifferentialEvolution", "description": "Introduce dynamic crossover probability to enhance exploration in the early stages and exploitation in the later stages.", "configspace": "", "generation": 4, "fitness": 0.1738190879303382, "feedback": "The algorithm AdaptiveLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "metadata": {"aucs": [0.31606700883278205, 0.31021058447933725, 0.31465388516397697, 0.32243149469749965, 0.33102456804096325, 0.3164386270902253, 0.32396746444732893, 0.3493591956727634, 0.3292293965612716, 0.004249886336646358, 0.0024449193151729887, 0.0024363646465788147, 0.010748156461475977, 0.013672146359514192, 0.0012687972790861313, 0.009764189949899027, 0.0043103339337409174, 0.011500360874805993, 0.08437106944016615, 0.09975070421815779, 0.08707241945345745, 0.0807532640369153, 0.08643349910845477, 0.08387812523664961, 0.10149313482872402, 0.0847443491410822, 0.08279669704388926, 0.07931150459324399, 0.07585045012448077, 0.07195057015824546, 0.07431789655008869, 0.07497499659521889, 0.08208756604887335, 0.07353338811105314, 0.0717060721301852, 0.07054867693419054, 0.9492755868616752, 0.937378659738495, 0.9634273688804844, 0.9194091198022944, 0.9721847427743495, 0.9333673818694791, 0.973674781074153, 0.9567810122849161, 0.9629104274734415, 0.19698764867390695, 0.18086487850571642, 0.18432076226075, 0.19107261859629665, 0.1876550423407125, 0.18529175925491692, 0.1745849291407391, 0.18595794627696083, 0.18570578324150044, 0.23424260176537004, 0.21649486075248303, 0.21485729298843037, 0.22091326592136096, 0.2236186420631492, 0.21278604447596328, 0.2060978353793954, 0.21532750906129083, 0.22769205281160376, 0.10035533404638719, 0.10412513761545594, 0.11031085429491783, 0.11192750893970027, 0.09914662223808524, 0.09205620199112086, 0.11914874972649137, 0.09514857485644024, 0.10336812057468359, 0.07767740291236114, 0.0880641009560752, 0.06455564498687505, 0.09676195214335237, 0.09963003507665302, 0.10022932409249097, 0.11291176437845885, 0.1018236527552212, 0.10245113838528597, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009483823082205856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0605715683880631, 0.03612006581895966, 0.0657914150666773, 0.06789316634854936, 0.021998684991695883, 0.03755329901567506, 0.051340769788865925, 0.05352454912011584, 0.06245561831010926, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04823112144609276, 0.050476064732610904, 0.03087921757591816, 0.04574545096594007, 0.051377464008270146, 0.050110080203102925, 0.05282652949485711, 0.047571570259018925, 0.03945384518508166, 0.3105704418352806, 0.31934723253040076, 0.31205345191200873, 0.3043829553559738, 0.3119200882222595, 0.30715972249934853, 0.31471609439866677, 0.3174809644382882, 0.3015074101595474, 0.08253978531471062, 0.08180881997853451, 0.09514271647239769, 0.08390021285908733, 0.08649627084502887, 0.0936567659372779, 0.08478388729838082, 0.08954588431394017, 0.08860486612641072, 0.20016194134581222, 0.15092284939461642, 0.15879436368310396, 0.13108452191741105, 0.1280130222620144, 0.16521654870973856, 0.16346821395044897, 0.13019413352838838, 0.17477446303766486, 0.24044804776148854, 0.24016268310065003, 0.23091327401797024, 0.23658658702718416, 0.23869091591383007, 0.23302551567729635, 0.22957246171680146, 0.23960389553842942, 0.2212373806414888, 0.17083595204770896, 0.17926794158560755, 0.17246748357907693, 0.1674187192897829, 0.17137656838388227, 0.17267425861661578, 0.17659028598404858, 0.18586590635286215, 0.17728244317412523, 0.19158441402957516, 0.1766697332217223, 0.18725405038900855, 0.19229160486365304, 0.19977389126116452, 0.19948427410630964, 0.20564577768429748, 0.18366579481957823, 0.17493815956686654, 0.17925873398898207, 0.18029619774986239, 0.1748797420707311, 0.1737139407052939, 0.17297947320098916, 0.1761684170135983, 0.19333862211590702, 0.17367873186283667, 0.17964476371819404, 0.16796245736214643, 0.18850253233336023, 0.17031513352784244, 0.328885418797354, 0.24991915406341725, 0.1755046799354586, 0.26436923869813955, 0.17668382767297097, 0.30774965988004566, 0.23787989927708086, 0.18208700783283316, 0.16666537644259605, 0.1839628714634517, 0.1789603472358431, 0.2870142461726335, 0.2209444691741529, 0.14950686729586704, 0.2013072253918976, 0.19261649011548942, 0.18810467859548285, 0.19161124307348798, 0.1871075287686924, 0.1906599207259454, 0.18849555258327022, 0.19730928585203633, 0.19703814730251767, 0.20365304028149944, 0.07456368869854613, 0.08359489470671799, 0.06769042446100737, 0.06567489225027223, 0.07753483101243452, 0.07932384152655692, 0.08433029525213442, 0.07031729687841304, 0.07104895604343398]}, "mutation_prompt": null}
{"id": "5731a1aa-a181-4d2f-87c9-26399d96bfb0", "solution": "import numpy as np\n\nclass AdaptiveLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)  # Recommended size for DE\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5  # Mutation factor\n        self.cr = 0.9  # Crossover rate\n        self.alpha = 1.5  # Levy flight parameter\n        \n    def levy_flight(self, size):\n        # Generates steps using Levy distribution\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                crossover = np.random.rand(self.dim) < self.cr\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True  # Ensure at least one element is copied\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Apply Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                trial += step_size * self.levy_flight(self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveLevyDifferentialEvolution", "description": "The algorithm combines Differential Evolution with Adaptive Levy Flights to explore and exploit the search space efficiently.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "metadata": {"aucs": [0.32116064716498194, 0.3220857404136839, 0.32128860217933397, 0.3313010878899617, 0.31116687334857285, 0.32898103275055746, 0.3138065286267345, 0.3193046642342352, 0.31990639500238804, 0.005206948990410076, 0.008926944436153827, 0.008088714115493945, 0.0025701583303306963, 0.00508493482751915, 0.007365983778751639, 0.0029082310843546733, 0.00743476823627065, 0.002724403377492468, 0.08212261841650892, 0.11413937390460083, 0.07841341920581801, 0.08376191323031212, 0.10680464456071714, 0.08988441053690499, 0.0956029225632461, 0.08445092140917354, 0.09181539577349307, 0.07066107420050105, 0.07287154515359706, 0.0776005869795876, 0.08255053670368595, 0.06922485219365748, 0.06642767626026902, 0.08132488328885157, 0.08648451550294556, 0.08544518998699002, 0.9492755868616752, 0.9423726468496557, 0.9634642170297736, 0.9531337849593216, 0.9553858466345133, 0.9316501034395107, 0.973674781074153, 0.9645439789185964, 0.9546849780615991, 0.18745025416802252, 0.19902657520930622, 0.19713169464262625, 0.17660006458706046, 0.18246020715337008, 0.18357705407969271, 0.17923143646203643, 0.18645775167205625, 0.18601098961532958, 0.23037946116214203, 0.22532970400552654, 0.27187063727028293, 0.22917720213282955, 0.22785512508719163, 0.23426739314410672, 0.2586522555898534, 0.2560944988807382, 0.26670383129330943, 0.10128499186493123, 0.10368932795565, 0.09854380400143037, 0.1165031188847031, 0.10763048845266954, 0.11102827002939664, 0.11128249539641621, 0.10774907655076116, 0.11444153680002522, 0.09924607448238143, 0.09188424774952386, 0.08981450413441738, 0.10728969394430299, 0.08941521058458934, 0.10497773943637079, 0.11707106412425661, 0.10328785721657419, 0.10908355391102509, 0.0018370124665271215, 0.0019280725193501214, 0.00322456870674237, 0.0009819674980954263, 0.003462307843471568, 0.010832872261146598, 0.001585734587806975, 0.000979298222194891, 0.00956564773472146, 0.0730147128403924, 0.0457425984717702, 0.0753526731050802, 0.10437614021589381, 0.0537822289831118, 0.03064334280860581, 0.05157910357908768, 0.09411013623706077, 0.10317212065161019, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010366220333146714, 9.999999999998899e-05, 0.005901176330244784, 9.999999999998899e-05, 0.00012120830457174048, 0.04814177819461962, 0.05098082863773146, 0.040767921946167185, 0.04425372924823301, 0.042292610655382146, 0.051985114696308066, 0.05068119118861214, 0.04562404014320387, 0.043701429663313474, 0.3112241086590357, 0.3012880375099516, 0.31284899512909603, 0.30498392685273157, 0.30685460950262844, 0.3099940910551444, 0.3190951874157152, 0.31760445835593676, 0.3168535840598673, 0.09689462539669946, 0.08311797407006127, 0.08288097206191414, 0.08368683453507697, 0.08156353789751303, 0.08749658601790411, 0.09201519989005136, 0.08401262273913324, 0.09107064304491619, 0.12872628929527274, 0.12876337948141936, 0.13224941478770524, 0.13693794809662252, 0.15425629400842722, 0.19135360086262931, 0.1296988888515911, 0.1395587282730788, 0.16590887673172006, 0.23223850723933925, 0.22104110824999712, 0.23018254001310756, 0.23053573355327928, 0.23866853827899626, 0.2321231451983795, 0.2288511824051901, 0.2266791221946448, 0.2289780260501053, 0.17687606545638757, 0.18882112861971623, 0.17950273875052192, 0.18643585462742718, 0.17217183928520263, 0.16560423187359263, 0.19296399823843824, 0.1703869916539783, 0.18585148965993736, 0.1836129781557907, 0.17467679526146151, 0.1910907938946601, 0.1962017880736009, 0.18777004219974025, 0.19673512418401562, 0.2106070781298176, 0.1788057078618014, 0.19741655483859621, 0.17154565233354446, 0.17881553853896148, 0.17330251880695213, 0.17033013692987165, 0.19483275812633516, 0.17079168553929647, 0.1912789368306541, 0.17505533060417144, 0.1746058197082151, 0.16902952928632697, 0.3759148101116242, 0.18289474518976812, 0.3474641447289848, 0.3902418417971012, 0.1724001684050711, 0.31732927285350265, 0.34670759828463793, 0.3083811551986336, 0.28298709461871596, 0.18541464316815104, 0.2937091877583393, 0.24225993548796143, 0.1842191801988562, 0.3284306639341399, 0.33794619234499645, 0.15833669008559315, 0.19892407394667855, 0.20704422351402696, 0.1973617786148234, 0.19566943501262135, 0.19278796413735277, 0.1855243221019005, 0.18598091124162575, 0.19251234977939768, 0.1947474955704538, 0.19516765639789613, 0.073276916216793, 0.06952566798324022, 0.07419277140096747, 0.07937643759253132, 0.08307224526278223, 0.06919551215421793, 0.07748514439502818, 0.07117754524833164, 0.0807261132819771]}, "mutation_prompt": null}
{"id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = np.random.rand()\n                crossover = np.random.rand(self.dim) < (self.cr * crossover_prob)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm integrates Adaptive Differential Evolution with Enhanced Levy Flights using a dynamic crossover rate to improve exploration and convergence speed.", "configspace": "", "generation": 6, "fitness": 0.18743118934128233, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "fb6875f8-db18-44bb-83ee-74ca53be10e6", "metadata": {"aucs": [0.3552916143587992, 0.35372893319219323, 0.3521581248713487, 0.35295431813555156, 0.34944725243601826, 0.3609448853853885, 0.36826511957042385, 0.35509774217091783, 0.3767774132219033, 0.010874734885162773, 0.015931408270662528, 0.010579067918319529, 0.007383871246847917, 0.009201450421763568, 0.014191136344009259, 0.015490420726811505, 0.017740586616123988, 0.016677098922651235, 0.0876883132598194, 0.092721798196164, 0.08713049101524206, 0.11375697653299799, 0.09432328958138936, 0.08948503647706108, 0.08795683633734275, 0.0941834868927297, 0.09171705570214395, 0.0730379657258019, 0.0781605496490676, 0.09127821168615613, 0.08509788646499006, 0.08159813300421281, 0.0813154451858833, 0.08624329605988701, 0.08158091527333222, 0.08919841485695745, 0.9477855294822801, 0.9593848748913606, 0.9382574794064269, 0.9450555530012794, 0.9369037385775185, 0.9636905315120138, 0.9380824147338548, 0.9640629489385049, 0.9566931483920912, 0.21419793853136182, 0.21430043318693037, 0.20753376639517418, 0.2367952543031664, 0.20361807444233437, 0.20545195584046771, 0.21074932920505018, 0.2216939606321654, 0.21600686285215986, 0.25542638604857015, 0.2292457188236392, 0.28377955727761905, 0.24619311194219617, 0.2672217839210266, 0.24603869178518512, 0.2368365367931895, 0.32528826592624027, 0.23535444057177557, 0.12592324109379371, 0.1132447719366213, 0.13188029593654504, 0.12020700029985165, 0.1268586167230049, 0.12390053388456468, 0.12646859830439428, 0.11510557077157302, 0.11736531341149581, 0.11764852456725161, 0.1108756928431538, 0.11085783159471663, 0.1172385943002473, 0.12245546377601113, 0.11666219348302731, 0.119696974790521, 0.12854754708835225, 0.12017685781216192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014190079939949696, 0.0027350822312950385, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027354662474244895, 0.09651837203997726, 0.06635472458436709, 0.0693714611337598, 0.030570565681006023, 0.06854914963886438, 0.05466477181077767, 0.1182096340902905, 0.05901400631566378, 0.071967396771486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06424353974282326, 0.058182421471336454, 0.06325684183754421, 0.060701544846786026, 0.0577490742583614, 0.06303680910418064, 0.045682171258379145, 0.06056259776790396, 0.049363372904698166, 0.34027649370900237, 0.32497898048985663, 0.34156045401969026, 0.342028871314064, 0.34390463033421015, 0.36878568174769044, 0.34090437257631623, 0.3317542075397085, 0.33760830428793953, 0.08136232588386427, 0.08550736485654775, 0.09854172038410247, 0.08672809766443457, 0.08818510194506612, 0.09756501619959257, 0.08251833116721641, 0.08663501288500997, 0.08579343725158217, 0.14748726219207198, 0.16718330205662246, 0.13895192383803645, 0.14665855346561352, 0.1727498288494238, 0.13659298233222938, 0.13990707541701775, 0.1358921317350401, 0.15285436997812063, 0.23931095167786998, 0.25052187270231274, 0.23936090517523, 0.2505280193737712, 0.24868826141942502, 0.25060641621633784, 0.24968904045020768, 0.253528546802836, 0.25771077154581334, 0.18726957254983556, 0.17410010494781314, 0.1878197814304131, 0.1811238927866088, 0.17509522546686862, 0.17685476643039988, 0.1853482772500049, 0.18634935790039464, 0.1822194370269592, 0.18359592299371752, 0.19800157514224892, 0.20282417197926284, 0.20572010785999395, 0.19058546699128243, 0.19965290271847935, 0.19868091137271193, 0.18228042835331293, 0.202210041743365, 0.17481542224669888, 0.18323544918423407, 0.19126612734193515, 0.1846674303112693, 0.18479676416813473, 0.19275457584580713, 0.18606163336365, 0.17832421794333864, 0.18629060217112015, 0.4280362359080221, 0.17290914961475667, 0.1737816619413245, 0.18348760249709728, 0.41118336788974474, 0.39217217680942507, 0.16397684280751879, 0.27054087986212016, 0.1546888214020763, 0.18071566622885638, 0.19085488660994576, 0.29172490060891976, 0.2591599631599505, 0.20355562117518777, 0.2951179980107437, 0.36112274625293295, 0.14768357198762438, 0.25268496829411513, 0.18174579970310212, 0.19849941942944838, 0.18574892548742006, 0.1990588056103414, 0.18775293649540858, 0.18455703873384977, 0.17924279145867472, 0.17531561297822895, 0.19705473643392057, 0.08053093622039542, 0.08216764211809802, 0.07148263491996587, 0.07142357173158886, 0.08063956731268185, 0.0703455350605161, 0.07614000627824768, 0.06795348067721496, 0.09091640664591616]}, "mutation_prompt": null}
{"id": "258795bf-ea38-462d-bc86-97984b4a4757", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = np.random.rand()\n                crossover = np.random.rand(self.dim) < (self.cr * crossover_prob)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm integrates Adaptive Differential Evolution with Enhanced Levy Flights using a dynamic crossover rate to improve exploration and convergence speed.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "metadata": {"aucs": [0.3552916143587992, 0.35372893319219323, 0.3521581248713487, 0.35295431813555156, 0.34944725243601826, 0.3609448853853885, 0.36826511957042385, 0.35509774217091783, 0.3767774132219033, 0.010874734885162773, 0.015931408270662528, 0.010579067918319529, 0.007383871246847917, 0.009201450421763568, 0.014191136344009259, 0.015490420726811505, 0.017740586616123988, 0.016677098922651235, 0.0876883132598194, 0.092721798196164, 0.08713049101524206, 0.11375697653299799, 0.09432328958138936, 0.08948503647706108, 0.08795683633734275, 0.0941834868927297, 0.09171705570214395, 0.0730379657258019, 0.0781605496490676, 0.09127821168615613, 0.08509788646499006, 0.08159813300421281, 0.0813154451858833, 0.08624329605988701, 0.08158091527333222, 0.08919841485695745, 0.9477855294822801, 0.9593848748913606, 0.9382574794064269, 0.9450555530012794, 0.9369037385775185, 0.9636905315120138, 0.9380824147338548, 0.9640629489385049, 0.9566931483920912, 0.21419793853136182, 0.21430043318693037, 0.20753376639517418, 0.2367952543031664, 0.20361807444233437, 0.20545195584046771, 0.21074932920505018, 0.2216939606321654, 0.21600686285215986, 0.25542638604857015, 0.2292457188236392, 0.28377955727761905, 0.24619311194219617, 0.2672217839210266, 0.24603869178518512, 0.2368365367931895, 0.32528826592624027, 0.23535444057177557, 0.12592324109379371, 0.1132447719366213, 0.13188029593654504, 0.12020700029985165, 0.1268586167230049, 0.12390053388456468, 0.12646859830439428, 0.11510557077157302, 0.11736531341149581, 0.11764852456725161, 0.1108756928431538, 0.11085783159471663, 0.1172385943002473, 0.12245546377601113, 0.11666219348302731, 0.119696974790521, 0.12854754708835225, 0.12017685781216192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014190079939949696, 0.0027350822312950385, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027354662474244895, 0.09651837203997726, 0.06635472458436709, 0.0693714611337598, 0.030570565681006023, 0.06854914963886438, 0.05466477181077767, 0.1182096340902905, 0.05901400631566378, 0.071967396771486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06424353974282326, 0.058182421471336454, 0.06325684183754421, 0.060701544846786026, 0.0577490742583614, 0.06303680910418064, 0.045682171258379145, 0.06056259776790396, 0.049363372904698166, 0.34027649370900237, 0.32497898048985663, 0.34156045401969026, 0.342028871314064, 0.34390463033421015, 0.36878568174769044, 0.34090437257631623, 0.3317542075397085, 0.33760830428793953, 0.08136232588386427, 0.08550736485654775, 0.09854172038410247, 0.08672809766443457, 0.08818510194506612, 0.09756501619959257, 0.08251833116721641, 0.08663501288500997, 0.08579343725158217, 0.14748726219207198, 0.16718330205662246, 0.13895192383803645, 0.14665855346561352, 0.1727498288494238, 0.13659298233222938, 0.13990707541701775, 0.1358921317350401, 0.15285436997812063, 0.23931095167786998, 0.25052187270231274, 0.23936090517523, 0.2505280193737712, 0.24868826141942502, 0.25060641621633784, 0.24968904045020768, 0.253528546802836, 0.25771077154581334, 0.18726957254983556, 0.17410010494781314, 0.1878197814304131, 0.1811238927866088, 0.17509522546686862, 0.17685476643039988, 0.1853482772500049, 0.18634935790039464, 0.1822194370269592, 0.18359592299371752, 0.19800157514224892, 0.20282417197926284, 0.20572010785999395, 0.19058546699128243, 0.19965290271847935, 0.19868091137271193, 0.18228042835331293, 0.202210041743365, 0.17481542224669888, 0.18323544918423407, 0.19126612734193515, 0.1846674303112693, 0.18479676416813473, 0.19275457584580713, 0.18606163336365, 0.17832421794333864, 0.18629060217112015, 0.4280362359080221, 0.17290914961475667, 0.1737816619413245, 0.18348760249709728, 0.41118336788974474, 0.39217217680942507, 0.16397684280751879, 0.27054087986212016, 0.1546888214020763, 0.18071566622885638, 0.19085488660994576, 0.29172490060891976, 0.2591599631599505, 0.20355562117518777, 0.2951179980107437, 0.36112274625293295, 0.14768357198762438, 0.25268496829411513, 0.18174579970310212, 0.19849941942944838, 0.18574892548742006, 0.1990588056103414, 0.18775293649540858, 0.18455703873384977, 0.17924279145867472, 0.17531561297822895, 0.19705473643392057, 0.08053093622039542, 0.08216764211809802, 0.07148263491996587, 0.07142357173158886, 0.08063956731268185, 0.0703455350605161, 0.07614000627824768, 0.06795348067721496, 0.09091640664591616]}, "mutation_prompt": null}
{"id": "f135c872-22c3-4fa1-9655-1913452bb5ad", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = np.random.rand()\n                crossover = np.random.rand(self.dim) < (self.cr * crossover_prob)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm integrates Adaptive Differential Evolution with Enhanced Levy Flights using a dynamic crossover rate to improve exploration and convergence speed.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "metadata": {"aucs": [0.3552916143587992, 0.35372893319219323, 0.3521581248713487, 0.35295431813555156, 0.34944725243601826, 0.3609448853853885, 0.36826511957042385, 0.35509774217091783, 0.3767774132219033, 0.010874734885162773, 0.015931408270662528, 0.010579067918319529, 0.007383871246847917, 0.009201450421763568, 0.014191136344009259, 0.015490420726811505, 0.017740586616123988, 0.016677098922651235, 0.0876883132598194, 0.092721798196164, 0.08713049101524206, 0.11375697653299799, 0.09432328958138936, 0.08948503647706108, 0.08795683633734275, 0.0941834868927297, 0.09171705570214395, 0.0730379657258019, 0.0781605496490676, 0.09127821168615613, 0.08509788646499006, 0.08159813300421281, 0.0813154451858833, 0.08624329605988701, 0.08158091527333222, 0.08919841485695745, 0.9477855294822801, 0.9593848748913606, 0.9382574794064269, 0.9450555530012794, 0.9369037385775185, 0.9636905315120138, 0.9380824147338548, 0.9640629489385049, 0.9566931483920912, 0.21419793853136182, 0.21430043318693037, 0.20753376639517418, 0.2367952543031664, 0.20361807444233437, 0.20545195584046771, 0.21074932920505018, 0.2216939606321654, 0.21600686285215986, 0.25542638604857015, 0.2292457188236392, 0.28377955727761905, 0.24619311194219617, 0.2672217839210266, 0.24603869178518512, 0.2368365367931895, 0.32528826592624027, 0.23535444057177557, 0.12592324109379371, 0.1132447719366213, 0.13188029593654504, 0.12020700029985165, 0.1268586167230049, 0.12390053388456468, 0.12646859830439428, 0.11510557077157302, 0.11736531341149581, 0.11764852456725161, 0.1108756928431538, 0.11085783159471663, 0.1172385943002473, 0.12245546377601113, 0.11666219348302731, 0.119696974790521, 0.12854754708835225, 0.12017685781216192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014190079939949696, 0.0027350822312950385, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027354662474244895, 0.09651837203997726, 0.06635472458436709, 0.0693714611337598, 0.030570565681006023, 0.06854914963886438, 0.05466477181077767, 0.1182096340902905, 0.05901400631566378, 0.071967396771486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06424353974282326, 0.058182421471336454, 0.06325684183754421, 0.060701544846786026, 0.0577490742583614, 0.06303680910418064, 0.045682171258379145, 0.06056259776790396, 0.049363372904698166, 0.34027649370900237, 0.32497898048985663, 0.34156045401969026, 0.342028871314064, 0.34390463033421015, 0.36878568174769044, 0.34090437257631623, 0.3317542075397085, 0.33760830428793953, 0.08136232588386427, 0.08550736485654775, 0.09854172038410247, 0.08672809766443457, 0.08818510194506612, 0.09756501619959257, 0.08251833116721641, 0.08663501288500997, 0.08579343725158217, 0.14748726219207198, 0.16718330205662246, 0.13895192383803645, 0.14665855346561352, 0.1727498288494238, 0.13659298233222938, 0.13990707541701775, 0.1358921317350401, 0.15285436997812063, 0.23931095167786998, 0.25052187270231274, 0.23936090517523, 0.2505280193737712, 0.24868826141942502, 0.25060641621633784, 0.24968904045020768, 0.253528546802836, 0.25771077154581334, 0.18726957254983556, 0.17410010494781314, 0.1878197814304131, 0.1811238927866088, 0.17509522546686862, 0.17685476643039988, 0.1853482772500049, 0.18634935790039464, 0.1822194370269592, 0.18359592299371752, 0.19800157514224892, 0.20282417197926284, 0.20572010785999395, 0.19058546699128243, 0.19965290271847935, 0.19868091137271193, 0.18228042835331293, 0.202210041743365, 0.17481542224669888, 0.18323544918423407, 0.19126612734193515, 0.1846674303112693, 0.18479676416813473, 0.19275457584580713, 0.18606163336365, 0.17832421794333864, 0.18629060217112015, 0.4280362359080221, 0.17290914961475667, 0.1737816619413245, 0.18348760249709728, 0.41118336788974474, 0.39217217680942507, 0.16397684280751879, 0.27054087986212016, 0.1546888214020763, 0.18071566622885638, 0.19085488660994576, 0.29172490060891976, 0.2591599631599505, 0.20355562117518777, 0.2951179980107437, 0.36112274625293295, 0.14768357198762438, 0.25268496829411513, 0.18174579970310212, 0.19849941942944838, 0.18574892548742006, 0.1990588056103414, 0.18775293649540858, 0.18455703873384977, 0.17924279145867472, 0.17531561297822895, 0.19705473643392057, 0.08053093622039542, 0.08216764211809802, 0.07148263491996587, 0.07142357173158886, 0.08063956731268185, 0.0703455350605161, 0.07614000627824768, 0.06795348067721496, 0.09091640664591616]}, "mutation_prompt": null}
{"id": "f09cbab6-6dd5-49e2-afa7-2dd203fa604b", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n        self.beta = 1.0  # new parameter for adaptive mutation\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1 with adaptive mutation factor\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.f + self.beta * np.random.rand() * (best_fitness - fitness[i]) / (best_fitness + 1e-8)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = np.random.rand()\n                crossover = np.random.rand(self.dim) < (self.cr * crossover_prob)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = np.sqrt((self.budget - evaluations) / self.budget)\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm combines Enhanced Differential Evolution with Dynamic Levy Flights using adaptive mutation scaling and crossover rates for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.17350758961022003, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "metadata": {"aucs": [0.33940453155840966, 0.32781303348695423, 0.3171188371227942, 0.31533985353291527, 0.3228171821630055, 0.31036953308679227, 0.319524707300085, 0.3211488503464104, 0.31744229865510987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00018907630430187172, 0.005784924801072178, 0.0005754995471662916, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007139164158026512, 0.09076928544129836, 0.09109593927847726, 0.09081533884058679, 0.09039642751571086, 0.08565655255387883, 0.09692001032744724, 0.09046118369594391, 0.09074906835888541, 0.09962382931982139, 0.07664791636521318, 0.07414416933410461, 0.0783844830133017, 0.07626932536761488, 0.07554580291529478, 0.07587323080658448, 0.07721816067164744, 0.07282839330211732, 0.08527305136879526, 0.967660510238262, 0.9505315583806068, 0.9108161211612825, 0.9564629056980934, 0.958000563397677, 0.9616232120048627, 0.9568696378495037, 0.9549283971705098, 0.9178306919880297, 0.18217770479879525, 0.20070892699150522, 0.18601496687868602, 0.20083079632749534, 0.19206012404917905, 0.18430317557685183, 0.18766129226152217, 0.18579444308172044, 0.1807544104180795, 0.2515523650489945, 0.24104836951801178, 0.23006770363826679, 0.23165048304957858, 0.23190022182601244, 0.22728979081947598, 0.21685534197760858, 0.21489281732927235, 0.20419538309397034, 0.08922576165638352, 0.11123475405033767, 0.10067034982359524, 0.09739332323014316, 0.08244497555462038, 0.11590378578803229, 0.09031726367986936, 0.09918641094168457, 0.09420414940233968, 0.06975921664318485, 0.058239218958902716, 0.05971923830547643, 0.09225289740465936, 0.07475558012118877, 0.0772285849453872, 0.0779733100800728, 0.08664950603907218, 0.08088710347518935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034009746995282475, 0.05990797658656444, 0.027351116855317548, 0.03904747215079951, 0.034973131612454744, 0.04993966341994871, 0.04721728626216104, 0.02766862105788237, 0.053970953878038186, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04266160996129986, 0.052050868653362836, 0.042496245578469316, 0.05010641648500491, 0.04095239313795607, 0.032272207224596006, 0.04018547572262543, 0.04659784941147105, 0.0442704496920765, 0.3506073249077638, 0.3133364781617656, 0.3152168133489175, 0.3157109990404364, 0.3087154461747914, 0.306308976948365, 0.3123673198168515, 0.31348355835705244, 0.32129030665218683, 0.08002694280639133, 0.09263121961971466, 0.09757840390258044, 0.10004506624819465, 0.08292549010171368, 0.10756787335488593, 0.07043383570684492, 0.09067583045735972, 0.07555725911559164, 0.13862172873511558, 0.14066895663103174, 0.12866535703438842, 0.14213694563951917, 0.13279661935243603, 0.14920659126685898, 0.1516660827491474, 0.15034184817290752, 0.1422420020375713, 0.22774189205598927, 0.2339386077594443, 0.22796198398912926, 0.22259334518157214, 0.2306052266873101, 0.2282454297801667, 0.23610791883819948, 0.23330247090645873, 0.2369662088129869, 0.1581879684271531, 0.15557587136253748, 0.15402569207788475, 0.17271643248984292, 0.164329402200738, 0.17856110294165684, 0.16809225743419554, 0.1732730180572899, 0.1722107802235079, 0.1999726522057308, 0.19129401994872242, 0.20427007892416071, 0.21724262630675117, 0.21004033509318443, 0.19575553718534444, 0.18802365443377156, 0.19663823257490065, 0.20523434066847712, 0.1584832661876171, 0.16887182027784509, 0.1731823841379574, 0.17476368552333987, 0.17114340541020734, 0.17900536940920442, 0.17219154263005254, 0.16252650525346513, 0.17532163787928534, 0.3515848814076734, 0.2571251738090381, 0.3614119185147523, 0.175114216379458, 0.1956466412386264, 0.17407573563454626, 0.26873174492355356, 0.17059226463743837, 0.2165016318935049, 0.1800488543719353, 0.17886211790248485, 0.19613625729487671, 0.20582574259809483, 0.21929150161050048, 0.2734111327046814, 0.258285670985429, 0.30650571950261374, 0.234708754336181, 0.17652960786372862, 0.20112231986884888, 0.19143454950234684, 0.1847607819752125, 0.19738203218257855, 0.18271234345759557, 0.18582989009621698, 0.1829135241928378, 0.17493431000020332, 0.07825012917524055, 0.0722781110099997, 0.07532910884814814, 0.08592243405255973, 0.08014582826280714, 0.07042050986628479, 0.08251942948448543, 0.07768972184044487, 0.07696154260928834]}, "mutation_prompt": null}
{"id": "b9acb267-d054-4179-bf28-1a15cc65b41b", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = np.random.rand()\n                crossover = np.random.rand(self.dim) < (self.cr * crossover_prob)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm integrates Adaptive Differential Evolution with Enhanced Levy Flights using a dynamic crossover rate to improve exploration and convergence speed.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "metadata": {"aucs": [0.3552916143587992, 0.35372893319219323, 0.3521581248713487, 0.35295431813555156, 0.34944725243601826, 0.3609448853853885, 0.36826511957042385, 0.35509774217091783, 0.3767774132219033, 0.010874734885162773, 0.015931408270662528, 0.010579067918319529, 0.007383871246847917, 0.009201450421763568, 0.014191136344009259, 0.015490420726811505, 0.017740586616123988, 0.016677098922651235, 0.0876883132598194, 0.092721798196164, 0.08713049101524206, 0.11375697653299799, 0.09432328958138936, 0.08948503647706108, 0.08795683633734275, 0.0941834868927297, 0.09171705570214395, 0.0730379657258019, 0.0781605496490676, 0.09127821168615613, 0.08509788646499006, 0.08159813300421281, 0.0813154451858833, 0.08624329605988701, 0.08158091527333222, 0.08919841485695745, 0.9477855294822801, 0.9593848748913606, 0.9382574794064269, 0.9450555530012794, 0.9369037385775185, 0.9636905315120138, 0.9380824147338548, 0.9640629489385049, 0.9566931483920912, 0.21419793853136182, 0.21430043318693037, 0.20753376639517418, 0.2367952543031664, 0.20361807444233437, 0.20545195584046771, 0.21074932920505018, 0.2216939606321654, 0.21600686285215986, 0.25542638604857015, 0.2292457188236392, 0.28377955727761905, 0.24619311194219617, 0.2672217839210266, 0.24603869178518512, 0.2368365367931895, 0.32528826592624027, 0.23535444057177557, 0.12592324109379371, 0.1132447719366213, 0.13188029593654504, 0.12020700029985165, 0.1268586167230049, 0.12390053388456468, 0.12646859830439428, 0.11510557077157302, 0.11736531341149581, 0.11764852456725161, 0.1108756928431538, 0.11085783159471663, 0.1172385943002473, 0.12245546377601113, 0.11666219348302731, 0.119696974790521, 0.12854754708835225, 0.12017685781216192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014190079939949696, 0.0027350822312950385, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027354662474244895, 0.09651837203997726, 0.06635472458436709, 0.0693714611337598, 0.030570565681006023, 0.06854914963886438, 0.05466477181077767, 0.1182096340902905, 0.05901400631566378, 0.071967396771486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06424353974282326, 0.058182421471336454, 0.06325684183754421, 0.060701544846786026, 0.0577490742583614, 0.06303680910418064, 0.045682171258379145, 0.06056259776790396, 0.049363372904698166, 0.34027649370900237, 0.32497898048985663, 0.34156045401969026, 0.342028871314064, 0.34390463033421015, 0.36878568174769044, 0.34090437257631623, 0.3317542075397085, 0.33760830428793953, 0.08136232588386427, 0.08550736485654775, 0.09854172038410247, 0.08672809766443457, 0.08818510194506612, 0.09756501619959257, 0.08251833116721641, 0.08663501288500997, 0.08579343725158217, 0.14748726219207198, 0.16718330205662246, 0.13895192383803645, 0.14665855346561352, 0.1727498288494238, 0.13659298233222938, 0.13990707541701775, 0.1358921317350401, 0.15285436997812063, 0.23931095167786998, 0.25052187270231274, 0.23936090517523, 0.2505280193737712, 0.24868826141942502, 0.25060641621633784, 0.24968904045020768, 0.253528546802836, 0.25771077154581334, 0.18726957254983556, 0.17410010494781314, 0.1878197814304131, 0.1811238927866088, 0.17509522546686862, 0.17685476643039988, 0.1853482772500049, 0.18634935790039464, 0.1822194370269592, 0.18359592299371752, 0.19800157514224892, 0.20282417197926284, 0.20572010785999395, 0.19058546699128243, 0.19965290271847935, 0.19868091137271193, 0.18228042835331293, 0.202210041743365, 0.17481542224669888, 0.18323544918423407, 0.19126612734193515, 0.1846674303112693, 0.18479676416813473, 0.19275457584580713, 0.18606163336365, 0.17832421794333864, 0.18629060217112015, 0.4280362359080221, 0.17290914961475667, 0.1737816619413245, 0.18348760249709728, 0.41118336788974474, 0.39217217680942507, 0.16397684280751879, 0.27054087986212016, 0.1546888214020763, 0.18071566622885638, 0.19085488660994576, 0.29172490060891976, 0.2591599631599505, 0.20355562117518777, 0.2951179980107437, 0.36112274625293295, 0.14768357198762438, 0.25268496829411513, 0.18174579970310212, 0.19849941942944838, 0.18574892548742006, 0.1990588056103414, 0.18775293649540858, 0.18455703873384977, 0.17924279145867472, 0.17531561297822895, 0.19705473643392057, 0.08053093622039542, 0.08216764211809802, 0.07148263491996587, 0.07142357173158886, 0.08063956731268185, 0.0703455350605161, 0.07614000627824768, 0.06795348067721496, 0.09091640664591616]}, "mutation_prompt": null}
{"id": "3c6e7e6f-c710-42d4-8ebe-52a87dac6ec9", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation: DE/rand/1\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = np.random.rand()\n                crossover = np.random.rand(self.dim) < (self.cr * crossover_prob)\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm integrates Adaptive Differential Evolution with Enhanced Levy Flights using a dynamic crossover rate to improve exploration and convergence speed.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "metadata": {"aucs": [0.3552916143587992, 0.35372893319219323, 0.3521581248713487, 0.35295431813555156, 0.34944725243601826, 0.3609448853853885, 0.36826511957042385, 0.35509774217091783, 0.3767774132219033, 0.010874734885162773, 0.015931408270662528, 0.010579067918319529, 0.007383871246847917, 0.009201450421763568, 0.014191136344009259, 0.015490420726811505, 0.017740586616123988, 0.016677098922651235, 0.0876883132598194, 0.092721798196164, 0.08713049101524206, 0.11375697653299799, 0.09432328958138936, 0.08948503647706108, 0.08795683633734275, 0.0941834868927297, 0.09171705570214395, 0.0730379657258019, 0.0781605496490676, 0.09127821168615613, 0.08509788646499006, 0.08159813300421281, 0.0813154451858833, 0.08624329605988701, 0.08158091527333222, 0.08919841485695745, 0.9477855294822801, 0.9593848748913606, 0.9382574794064269, 0.9450555530012794, 0.9369037385775185, 0.9636905315120138, 0.9380824147338548, 0.9640629489385049, 0.9566931483920912, 0.21419793853136182, 0.21430043318693037, 0.20753376639517418, 0.2367952543031664, 0.20361807444233437, 0.20545195584046771, 0.21074932920505018, 0.2216939606321654, 0.21600686285215986, 0.25542638604857015, 0.2292457188236392, 0.28377955727761905, 0.24619311194219617, 0.2672217839210266, 0.24603869178518512, 0.2368365367931895, 0.32528826592624027, 0.23535444057177557, 0.12592324109379371, 0.1132447719366213, 0.13188029593654504, 0.12020700029985165, 0.1268586167230049, 0.12390053388456468, 0.12646859830439428, 0.11510557077157302, 0.11736531341149581, 0.11764852456725161, 0.1108756928431538, 0.11085783159471663, 0.1172385943002473, 0.12245546377601113, 0.11666219348302731, 0.119696974790521, 0.12854754708835225, 0.12017685781216192, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014190079939949696, 0.0027350822312950385, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027354662474244895, 0.09651837203997726, 0.06635472458436709, 0.0693714611337598, 0.030570565681006023, 0.06854914963886438, 0.05466477181077767, 0.1182096340902905, 0.05901400631566378, 0.071967396771486, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06424353974282326, 0.058182421471336454, 0.06325684183754421, 0.060701544846786026, 0.0577490742583614, 0.06303680910418064, 0.045682171258379145, 0.06056259776790396, 0.049363372904698166, 0.34027649370900237, 0.32497898048985663, 0.34156045401969026, 0.342028871314064, 0.34390463033421015, 0.36878568174769044, 0.34090437257631623, 0.3317542075397085, 0.33760830428793953, 0.08136232588386427, 0.08550736485654775, 0.09854172038410247, 0.08672809766443457, 0.08818510194506612, 0.09756501619959257, 0.08251833116721641, 0.08663501288500997, 0.08579343725158217, 0.14748726219207198, 0.16718330205662246, 0.13895192383803645, 0.14665855346561352, 0.1727498288494238, 0.13659298233222938, 0.13990707541701775, 0.1358921317350401, 0.15285436997812063, 0.23931095167786998, 0.25052187270231274, 0.23936090517523, 0.2505280193737712, 0.24868826141942502, 0.25060641621633784, 0.24968904045020768, 0.253528546802836, 0.25771077154581334, 0.18726957254983556, 0.17410010494781314, 0.1878197814304131, 0.1811238927866088, 0.17509522546686862, 0.17685476643039988, 0.1853482772500049, 0.18634935790039464, 0.1822194370269592, 0.18359592299371752, 0.19800157514224892, 0.20282417197926284, 0.20572010785999395, 0.19058546699128243, 0.19965290271847935, 0.19868091137271193, 0.18228042835331293, 0.202210041743365, 0.17481542224669888, 0.18323544918423407, 0.19126612734193515, 0.1846674303112693, 0.18479676416813473, 0.19275457584580713, 0.18606163336365, 0.17832421794333864, 0.18629060217112015, 0.4280362359080221, 0.17290914961475667, 0.1737816619413245, 0.18348760249709728, 0.41118336788974474, 0.39217217680942507, 0.16397684280751879, 0.27054087986212016, 0.1546888214020763, 0.18071566622885638, 0.19085488660994576, 0.29172490060891976, 0.2591599631599505, 0.20355562117518777, 0.2951179980107437, 0.36112274625293295, 0.14768357198762438, 0.25268496829411513, 0.18174579970310212, 0.19849941942944838, 0.18574892548742006, 0.1990588056103414, 0.18775293649540858, 0.18455703873384977, 0.17924279145867472, 0.17531561297822895, 0.19705473643392057, 0.08053093622039542, 0.08216764211809802, 0.07148263491996587, 0.07142357173158886, 0.08063956731268185, 0.0703455350605161, 0.07614000627824768, 0.06795348067721496, 0.09091640664591616]}, "mutation_prompt": null}
{"id": "7b1f6ede-b296-4680-aaec-ca49450d6514", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def stochastic_crossover_probability(self):\n        return np.tanh(np.random.rand() * self.cr)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Stochastic Crossover\n                crossover_prob = self.stochastic_crossover_probability()\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm enhances exploration and exploitation by integrating adaptive mutation scaling and stochastic crossover probabilities into the differential evolution framework with Levy Flights.", "configspace": "", "generation": 12, "fitness": 0.193701482779745, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "c1ab20b6-3f4c-43c5-b4b3-d80e6a73f903", "metadata": {"aucs": [0.3624896303721369, 0.3448627876405779, 0.359920443282415, 0.3632195464640613, 0.3691764345120526, 0.3686873020111061, 0.3533821810310044, 0.3632701941027804, 0.3606793436700074, 0.008217767595560366, 0.01568564308356668, 0.014072504310896905, 0.015121315036132676, 0.008314650530203638, 0.01528166400117803, 0.010431888004641565, 0.01598529933491477, 0.012672149342541128, 0.10970593385031169, 0.11577961283236182, 0.10568012577387853, 0.11736873524136682, 0.11008411399051132, 0.11461803444234697, 0.0987628538068942, 0.10978221178862735, 0.11391955225102923, 0.08333186503889833, 0.09501148539178506, 0.09703425737657367, 0.08130746383325982, 0.08323238252194154, 0.09252123782028521, 0.09184050310074199, 0.09414189326354683, 0.08771381256754118, 0.983153012277798, 0.9633761909000584, 0.9475527331781166, 0.9730371274185031, 0.9075214920303548, 0.9544956325266643, 0.9725334553335787, 0.9560766825788564, 0.9566924560100586, 0.21403410107228804, 0.20821704624059534, 0.20914844819798084, 0.20490473437365464, 0.21272366586886637, 0.21165011415594104, 0.20430024952124226, 0.22018041695091983, 0.20799103589277135, 0.29622004742801145, 0.2263589050832031, 0.24757254897221193, 0.27068250121836823, 0.2814979722394674, 0.2707204203474066, 0.26030712285259117, 0.29773240720990213, 0.24362284728245165, 0.15142598851087874, 0.12060981557283557, 0.12671973001974635, 0.11073942418797211, 0.12656839985297408, 0.11986761760519216, 0.1281525501206473, 0.11144461279248985, 0.12211395587897556, 0.10681948591465662, 0.11469436166537816, 0.10822279270072777, 0.1304554756801164, 0.1093326213489143, 0.11666455328066327, 0.12187046412313607, 0.1232572922859857, 0.10943039105763652, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004480110219325595, 0.0068873614717913645, 0.0015011379960334637, 9.999999999998899e-05, 9.999999999998899e-05, 0.06757047170447861, 0.05516680617851688, 0.08507318816664211, 0.06085211711938232, 0.05386465068101731, 0.05327822265239868, 0.0912881006879217, 0.0572118730892236, 0.057376450897282716, 0.0002963292690375541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009215291269180081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00045530999841592035, 0.06013638658177112, 0.06096098562145036, 0.0657792905030532, 0.06488512998504958, 0.06020692601758659, 0.0666247218333259, 0.05537086396687141, 0.05590745366579286, 0.061023133605348945, 0.35532034152792535, 0.33043772236577473, 0.3509714295953287, 0.3381577633448343, 0.3408364634754327, 0.33401089443502885, 0.3473773471078595, 0.34573073498393325, 0.33919531435559125, 0.11090381364774238, 0.10199341087354019, 0.08714455217782613, 0.09135411959467432, 0.09104695714054145, 0.09351925947489925, 0.09390060046316029, 0.09552983776266699, 0.09305210702462574, 0.14449255244027193, 0.15573421355183759, 0.1366126902874335, 0.1370020264217846, 0.14812020070153054, 0.20154710593963987, 0.13992928455156683, 0.14161264650805028, 0.13583201752048135, 0.24760018917447257, 0.2475257596262207, 0.2583753813732981, 0.2559750683080181, 0.2395144770356893, 0.24484155387747675, 0.2559916437130779, 0.2552819956121789, 0.24426511674081552, 0.1895579523579105, 0.18286746923723107, 0.18960299020145244, 0.18715446793696588, 0.1770282281167962, 0.19429493528331032, 0.18560192263391417, 0.18067244105609692, 0.18626785868330076, 0.19365766556801745, 0.1933939117510316, 0.21248884604344176, 0.20825326926737264, 0.19046210465046143, 0.19636567152273043, 0.21040034807678976, 0.20892815139671028, 0.2029936643774859, 0.19570594750051062, 0.2063315779809496, 0.19166685202715839, 0.19345309838592206, 0.1937448043157174, 0.17773131731024694, 0.18911917295435765, 0.19711009112264577, 0.1884382751158984, 0.3609126577373317, 0.3495536556571427, 0.17536077340937228, 0.42436268763702223, 0.3375871742510427, 0.40088076637663916, 0.2620881226721402, 0.17143494730146136, 0.4456641961618051, 0.21365428806904618, 0.25527797434469157, 0.24182429700582875, 0.29718266220380307, 0.2818536700018712, 0.34772571247043493, 0.3066258244781771, 0.2657615305052081, 0.19977020773353305, 0.1868222716921243, 0.18402724803619086, 0.19064569267260845, 0.1910180068591707, 0.17198847564377806, 0.18944350930375298, 0.19178846640131542, 0.18551907437669057, 0.19356401169855098, 0.07714717742030774, 0.07144283905289772, 0.08485501659866035, 0.07818174930696875, 0.07090276770417747, 0.08022106696272835, 0.07051502392455533, 0.08293902678911602, 0.07462981033801241]}, "mutation_prompt": null}
{"id": "fc8918d3-00f7-4027-9f81-49f6b991a395", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) / np.abs(np.random.normal(0, 1, size)) ** (1 / self.alpha)\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def stochastic_crossover_probability(self):\n        return np.tanh(np.random.rand() * self.cr)\n\n    def update_population_size(self, evaluations):\n        return int(self.population_size * (0.9 + 0.1 * (1 - evaluations / self.budget)))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            current_pop_size = self.update_population_size(evaluations)\n            for i in range(current_pop_size):\n                # Mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Stochastic Crossover\n                crossover_prob = self.stochastic_crossover_probability()\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduced dynamic population resizing and modified levy flight to enhance exploration and convergence speed.", "configspace": "", "generation": 13, "fitness": 0.18169111210048683, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "7b1f6ede-b296-4680-aaec-ca49450d6514", "metadata": {"aucs": [0.34510040419111887, 0.3394003530873432, 0.3438125825904498, 0.34653377693425136, 0.3452067362810086, 0.3457523729601114, 0.34651500922402456, 0.3505782233507013, 0.3296975741664573, 0.010242479599268384, 0.014410973470163846, 0.009214687949734235, 0.007568969358659028, 0.008085043874127007, 0.011474858508577213, 0.011459438231074426, 0.012892527952594324, 0.01551156197582837, 0.10342860043575597, 0.1083768178693465, 0.0979506112434596, 0.09592996077360039, 0.09607017784792338, 0.09647537237571902, 0.09161857089724212, 0.09389178759784367, 0.09735877591322295, 0.08545867334086721, 0.0831575943066718, 0.08818821208739103, 0.08211393728209027, 0.08127258656863035, 0.08981184072296677, 0.08113767915293923, 0.08607262751722444, 0.08813349138255111, 0.9830307636092686, 0.9504109833125377, 0.9690915160116318, 0.9593952242816542, 0.9525411036477011, 0.9801539428020177, 0.9585006276280947, 0.9444009092605228, 0.9450642537455614, 0.19111810122244743, 0.19613626484392643, 0.19426031615971784, 0.19805015076438848, 0.1882246913389487, 0.18910247158139548, 0.19517764885748212, 0.20052136806894727, 0.2021094515875418, 0.23107668314139151, 0.21527605096853353, 0.21374873727181964, 0.22698505234090316, 0.22342736966240895, 0.21129181101582672, 0.2529274508082706, 0.2180986693213518, 0.22035399970739467, 0.10091665203802824, 0.10410570490645499, 0.11664051633067485, 0.11670442378062784, 0.10321450499185358, 0.09743415259349475, 0.1087209829055028, 0.11381675479418885, 0.10596341715750801, 0.1191376727950666, 0.09537399829848803, 0.09465591413580932, 0.10891382796345384, 0.1007270611340082, 0.1083861649469885, 0.09986196958443783, 0.100311051699983, 0.10050993610407877, 0.0003685164370326177, 0.002341486702056139, 0.00011203323661412856, 0.008062125375634221, 0.0011138744158799563, 9.999999999998899e-05, 0.0010541798058949503, 9.999999999998899e-05, 0.001886504702787728, 0.08366068111176539, 0.06292459824686303, 0.0630130074969738, 0.05011684822725526, 0.04728488417716359, 0.04528741747727072, 0.05770958359011835, 0.04995233570803759, 0.051023322758210865, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010374375914616873, 9.999999999998899e-05, 0.0003933372437302518, 9.999999999998899e-05, 0.00011469055754020907, 9.999999999998899e-05, 0.048793403328232676, 0.051422909503130554, 0.0475237117481071, 0.06541908146490749, 0.06546783757671559, 0.05237969341670634, 0.042350259236910825, 0.0384161245667578, 0.049809409633386204, 0.3217431502478961, 0.3324097146070145, 0.3391946325377072, 0.3299342887403164, 0.3152155552698723, 0.32208222793438956, 0.332169472948595, 0.32286933251213146, 0.32881811545160144, 0.08232642345415975, 0.09344195547911027, 0.08590447462115702, 0.08738227266362153, 0.08685919008138243, 0.08409731673607768, 0.08867415739767126, 0.08087713364981142, 0.09032629404625148, 0.15165583612116773, 0.1804700517578196, 0.14925265324388348, 0.15521675381572564, 0.15562979447972847, 0.1473439233511319, 0.16452200624286129, 0.15283819936811593, 0.14877341383043008, 0.2308140425953501, 0.2345280548231775, 0.23745792299735236, 0.23703952791739824, 0.2274544879990007, 0.23612497418928635, 0.26186457073628433, 0.23979749107553017, 0.24186601555176834, 0.17640166691334724, 0.1892979068983064, 0.18018410296099097, 0.1559074901766926, 0.14469666342976817, 0.17387270396931997, 0.18413366660684072, 0.17771591088189276, 0.16340016179545314, 0.18935444994012063, 0.19154847592233926, 0.19481140101387573, 0.17609718041575073, 0.19246091293473588, 0.1759784612293308, 0.1940251134842489, 0.205378965447076, 0.19826776804951485, 0.17836323583044866, 0.192178288628174, 0.18500628494029192, 0.19076078352931158, 0.18836154234607316, 0.19207772083431207, 0.17626249247389825, 0.18821032652719327, 0.19365896292572393, 0.18202628169046153, 0.34666836861296446, 0.3302273722166197, 0.4431501317737535, 0.28679864726651727, 0.18577227151466635, 0.24367194191622144, 0.2829730999574447, 0.3269627801989312, 0.2815975211420838, 0.1809167593652825, 0.1857774098631938, 0.17816469383125588, 0.185363081543217, 0.19039371778929803, 0.3191964644694252, 0.2283804486341724, 0.19837044171623597, 0.17744607131238588, 0.18978552125310955, 0.19291540617099956, 0.18093216207566343, 0.17206690893563914, 0.18701993192206523, 0.19070090900669912, 0.18015533197133626, 0.17888623072467214, 0.08178017893964129, 0.0768026620078952, 0.06788470651551337, 0.07334188607292669, 0.06995420724528956, 0.08406225716702609, 0.07118058676424976, 0.06263933923084752, 0.07031190882722982]}, "mutation_prompt": null}
{"id": "793e845e-9390-4887-8d2d-772a9a09afce", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def stochastic_crossover_probability(self):\n        return np.tanh(np.random.rand() * self.cr)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Stochastic Crossover\n                crossover_prob = self.stochastic_crossover_probability()\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "The algorithm enhances exploration and exploitation by integrating adaptive mutation scaling and stochastic crossover probabilities into the differential evolution framework with Levy Flights.", "configspace": "", "generation": 13, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7b1f6ede-b296-4680-aaec-ca49450d6514", "metadata": {"aucs": [0.3624896303721369, 0.3448627876405779, 0.359920443282415, 0.3632195464640613, 0.3691764345120526, 0.3686873020111061, 0.3533821810310044, 0.3632701941027804, 0.3606793436700074, 0.008217767595560366, 0.01568564308356668, 0.014072504310896905, 0.015121315036132676, 0.008314650530203638, 0.01528166400117803, 0.010431888004641565, 0.01598529933491477, 0.012672149342541128, 0.10970593385031169, 0.11577961283236182, 0.10568012577387853, 0.11736873524136682, 0.11008411399051132, 0.11461803444234697, 0.0987628538068942, 0.10978221178862735, 0.11391955225102923, 0.08333186503889833, 0.09501148539178506, 0.09703425737657367, 0.08130746383325982, 0.08323238252194154, 0.09252123782028521, 0.09184050310074199, 0.09414189326354683, 0.08771381256754118, 0.983153012277798, 0.9633761909000584, 0.9475527331781166, 0.9730371274185031, 0.9075214920303548, 0.9544956325266643, 0.9725334553335787, 0.9560766825788564, 0.9566924560100586, 0.21403410107228804, 0.20821704624059534, 0.20914844819798084, 0.20490473437365464, 0.21272366586886637, 0.21165011415594104, 0.20430024952124226, 0.22018041695091983, 0.20799103589277135, 0.29622004742801145, 0.2263589050832031, 0.24757254897221193, 0.27068250121836823, 0.2814979722394674, 0.2707204203474066, 0.26030712285259117, 0.29773240720990213, 0.24362284728245165, 0.15142598851087874, 0.12060981557283557, 0.12671973001974635, 0.11073942418797211, 0.12656839985297408, 0.11986761760519216, 0.1281525501206473, 0.11144461279248985, 0.12211395587897556, 0.10681948591465662, 0.11469436166537816, 0.10822279270072777, 0.1304554756801164, 0.1093326213489143, 0.11666455328066327, 0.12187046412313607, 0.1232572922859857, 0.10943039105763652, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004480110219325595, 0.0068873614717913645, 0.0015011379960334637, 9.999999999998899e-05, 9.999999999998899e-05, 0.06757047170447861, 0.05516680617851688, 0.08507318816664211, 0.06085211711938232, 0.05386465068101731, 0.05327822265239868, 0.0912881006879217, 0.0572118730892236, 0.057376450897282716, 0.0002963292690375541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009215291269180081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00045530999841592035, 0.06013638658177112, 0.06096098562145036, 0.0657792905030532, 0.06488512998504958, 0.06020692601758659, 0.0666247218333259, 0.05537086396687141, 0.05590745366579286, 0.061023133605348945, 0.35532034152792535, 0.33043772236577473, 0.3509714295953287, 0.3381577633448343, 0.3408364634754327, 0.33401089443502885, 0.3473773471078595, 0.34573073498393325, 0.33919531435559125, 0.11090381364774238, 0.10199341087354019, 0.08714455217782613, 0.09135411959467432, 0.09104695714054145, 0.09351925947489925, 0.09390060046316029, 0.09552983776266699, 0.09305210702462574, 0.14449255244027193, 0.15573421355183759, 0.1366126902874335, 0.1370020264217846, 0.14812020070153054, 0.20154710593963987, 0.13992928455156683, 0.14161264650805028, 0.13583201752048135, 0.24760018917447257, 0.2475257596262207, 0.2583753813732981, 0.2559750683080181, 0.2395144770356893, 0.24484155387747675, 0.2559916437130779, 0.2552819956121789, 0.24426511674081552, 0.1895579523579105, 0.18286746923723107, 0.18960299020145244, 0.18715446793696588, 0.1770282281167962, 0.19429493528331032, 0.18560192263391417, 0.18067244105609692, 0.18626785868330076, 0.19365766556801745, 0.1933939117510316, 0.21248884604344176, 0.20825326926737264, 0.19046210465046143, 0.19636567152273043, 0.21040034807678976, 0.20892815139671028, 0.2029936643774859, 0.19570594750051062, 0.2063315779809496, 0.19166685202715839, 0.19345309838592206, 0.1937448043157174, 0.17773131731024694, 0.18911917295435765, 0.19711009112264577, 0.1884382751158984, 0.3609126577373317, 0.3495536556571427, 0.17536077340937228, 0.42436268763702223, 0.3375871742510427, 0.40088076637663916, 0.2620881226721402, 0.17143494730146136, 0.4456641961618051, 0.21365428806904618, 0.25527797434469157, 0.24182429700582875, 0.29718266220380307, 0.2818536700018712, 0.34772571247043493, 0.3066258244781771, 0.2657615305052081, 0.19977020773353305, 0.1868222716921243, 0.18402724803619086, 0.19064569267260845, 0.1910180068591707, 0.17198847564377806, 0.18944350930375298, 0.19178846640131542, 0.18551907437669057, 0.19356401169855098, 0.07714717742030774, 0.07144283905289772, 0.08485501659866035, 0.07818174930696875, 0.07090276770417747, 0.08022106696272835, 0.07051502392455533, 0.08293902678911602, 0.07462981033801241]}, "mutation_prompt": null}
{"id": "12ed0832-b151-40dc-b8df-c13c11884ad7", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):  # Changed function\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + np.random.uniform(-0.5, 0.5, self.dim)), self.lower_bound, self.upper_bound)  # Alteration in mutation\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    \n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Improves convergence by incorporating a dynamic crossover probability strategy and adjusting the mutation strategy for better diversity.", "configspace": "", "generation": 15, "fitness": 0.19395144931371724, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "7b1f6ede-b296-4680-aaec-ca49450d6514", "metadata": {"aucs": [0.36376874209195953, 0.3549531638926229, 0.35109148358207853, 0.34785933687698023, 0.3606743145414927, 0.37196986757362527, 0.3558655928663961, 0.3514137268557651, 0.3768467662066345, 0.013680303891125734, 0.013816483024964743, 0.012109442161985173, 0.008144919572235065, 0.02668352369328786, 0.012089161232476164, 0.010575587938633335, 0.00899625429038553, 0.015176258168849044, 0.10417867063744657, 0.10904085728558943, 0.10743239793944626, 0.1274613436651294, 0.1261143130063087, 0.1055930777322166, 0.09629177960402246, 0.10645492228485509, 0.11321816368294546, 0.08896363902892934, 0.09912284629184775, 0.0825227577421268, 0.09215310656117404, 0.08997985652202845, 0.08601282654557074, 0.08646264832270478, 0.09513351934297043, 0.08986277901306639, 0.9557940238682956, 0.9508335085430368, 0.9543963048775654, 0.9621630509478556, 0.9696800107090078, 0.940744461674308, 0.969771561021658, 0.9608275258600867, 0.9407040994137105, 0.22969105584172989, 0.2328398088278233, 0.22430570218974766, 0.2254735555528692, 0.21963704118136118, 0.2168210581830291, 0.21551422656735764, 0.2278375232018146, 0.21776518105445675, 0.3104533160223999, 0.2861373104362309, 0.3047252541645742, 0.2473360638302936, 0.2618319344009752, 0.2628758740268373, 0.2715695801136081, 0.28043421618269726, 0.31456721443052493, 0.11764626171923886, 0.11556553787555646, 0.1405129611951701, 0.1227469862426317, 0.11914897942404545, 0.11952493002704756, 0.11500266880862842, 0.11475963838735137, 0.12173083746454882, 0.10882592119606982, 0.12185208425966121, 0.12686814254054757, 0.1023434757336581, 0.13001163761196743, 0.1257962824707154, 0.12351551197871335, 0.12202529541309015, 0.11476196158238794, 9.999999999998899e-05, 0.0008915757208742825, 9.999999999998899e-05, 0.00027580798659399, 0.00032772234479561124, 0.0035953943387808662, 9.999999999998899e-05, 0.003983068415043478, 0.008674217327848233, 0.12370764588386118, 0.08971850704892936, 0.06778472964845983, 0.09108871490491488, 0.062341009454715435, 0.1545364864887877, 0.07030827336605594, 0.04560731098533777, 0.06938960869190691, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004893410410626853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06352913584813591, 0.061769500323726634, 0.059420439817879034, 0.0590310093461589, 0.0669463582667631, 0.07176403989993829, 0.0695834213947284, 0.05574941452323723, 0.061132236559245934, 0.32666475839009657, 0.3305307318964459, 0.33469704886152907, 0.3527579125773518, 0.3436794228220379, 0.3493262598140884, 0.33892930347970185, 0.33942269570470984, 0.3402493531475135, 0.08951808516725557, 0.07833962451431054, 0.10195641065207439, 0.101897719390459, 0.09767316549163385, 0.10038418180051267, 0.10211628804679362, 0.10385234857014258, 0.09043574091224416, 0.18178599554729935, 0.15463546134823647, 0.1300139498039078, 0.14922654395819157, 0.14537148353786578, 0.1397931921431067, 0.16931980371467015, 0.1667091816581595, 0.14249620240911332, 0.26360241142843, 0.25110017286674235, 0.24622729641752916, 0.24998605146296904, 0.2450374082495509, 0.2477913665433754, 0.2511553383870432, 0.25431561851415396, 0.254080637042735, 0.19062962842636255, 0.20398516410072154, 0.1857375295017597, 0.1859739035258946, 0.18173557212943092, 0.19737306141040312, 0.18977708319668907, 0.19359027077598479, 0.19289998128481756, 0.19845914755009786, 0.1981406581617734, 0.1946851482616646, 0.18209339216665854, 0.1980782050102935, 0.20503805429611732, 0.20406469188040954, 0.19388289024432104, 0.209710573273025, 0.19988642253398425, 0.202849759578556, 0.20228619254807445, 0.1998251608440169, 0.19778259048853797, 0.21237483316100148, 0.18590817508342927, 0.19675616723678646, 0.1987875089188278, 0.16760771954140508, 0.486477656905552, 0.408380542975764, 0.4517559915965743, 0.17250627397342855, 0.1828152120374381, 0.16213637780755685, 0.3464598401039165, 0.17592314774007378, 0.19287876942960758, 0.37127193718548734, 0.4552166229654616, 0.23212190252887555, 0.1793723959026211, 0.1957626449014841, 0.2031502742850133, 0.20229978588193964, 0.15083670855292353, 0.2011912032377361, 0.18228279485127852, 0.20128709686933155, 0.1896241711728338, 0.1799722204545966, 0.21792157750047936, 0.17475125971292038, 0.18876918207675142, 0.18339414603252024, 0.07672738750216523, 0.08105587687634419, 0.08034952298367681, 0.072765522633368, 0.08812359537768011, 0.08344979212030534, 0.07930191510924955, 0.08100809589166458, 0.0853439748307373]}, "mutation_prompt": null}
{"id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 16, "fitness": 0.194945337933224, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "12ed0832-b151-40dc-b8df-c13c11884ad7", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "b8a2cab8-ca18-4e76-8a7f-34c26d135e96", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "4ce7b7e4-c814-4baf-92e7-22c34813a3d3", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "49125a05-c645-4498-9da1-798f83dc4a33", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, population):\n        diversity = np.mean(np.std(population, axis=0))  # Modifying using population diversity\n        return self.f * (1 - (evaluations / self.budget)) * (1 + diversity)\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, population)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a modified mutation scaling strategy by incorporating population diversity to enhance convergence speed.", "configspace": "", "generation": 19, "fitness": 0.17706123500021315, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.33852970637192714, 0.3462519305387406, 0.33269076029162237, 0.3517796930509952, 0.3653714317900352, 0.3543158728150003, 0.35260582823623143, 0.34987258798500964, 0.3533490603586169, 0.008902727906206054, 0.012845333230065425, 0.0130450717509204, 0.012656143832584177, 0.014348862040347576, 0.026017048703963486, 0.012170763370116577, 0.010700871274826884, 0.017002576450647178, 0.09833433427482019, 0.11262525421008218, 0.08476261800336693, 0.08450166215936683, 0.09888027910473374, 0.10273885659460391, 0.09304119276525613, 0.11094466734115371, 0.08740200094207884, 0.07959199435208808, 0.0792334178261952, 0.07960817302741363, 0.08502783460064367, 0.07882956218475845, 0.08299837111058372, 0.08986059563519266, 0.0848217740994931, 0.08293897379848825, 0.9666376619513353, 0.9694493321309288, 0.9564654033905335, 0.9512537686421295, 0.9453305074504659, 0.9554736470203016, 0.9623260054786458, 0.9558709716121208, 0.9571529040046843, 0.20601047735911382, 0.214664614291589, 0.21340120343172841, 0.20356596392004322, 0.2184909716022032, 0.2116642660499305, 0.20778354568905533, 0.2105499833612282, 0.21092265737371751, 0.18721704493841407, 0.30433279129690816, 0.21556384776996707, 0.2603839258502445, 0.23120217892439265, 0.24573078074723642, 0.29763996361397915, 0.2710937164234499, 0.23177686588393553, 0.09715263694622212, 0.10050686051867141, 0.10909774714003928, 0.1097348351275661, 0.0992350873523441, 0.10331397466805214, 0.10163108558008738, 0.10832509451340722, 0.09918755015476122, 0.06730544994920606, 0.09660593076176194, 0.07218305814858339, 0.10599371861407803, 0.10917264692300466, 0.10111900128582152, 0.09250244894222182, 0.0555256162193839, 0.09760579651773482, 9.999999999998899e-05, 0.00012798720482820602, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004501529602380927, 9.999999999998899e-05, 0.0013914231114363629, 0.0029162776581826977, 0.05089607722427758, 0.03358511217488269, 0.012634513883524101, 0.08518933747481694, 0.048296353509446055, 0.047023310722319356, 0.03622743062156186, 0.047080129583905506, 0.023223187822128732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05020574657960519, 0.04967822158687418, 0.053545473995297854, 0.056324807996271375, 0.06408132662739585, 0.059052554255152656, 0.05333321727202278, 0.06119978993970365, 0.05321999325439497, 0.3099340559272985, 0.328123275199361, 0.3156648300683963, 0.32926672475409535, 0.327478635980041, 0.3331416589617481, 0.33165591008503303, 0.32768754508356535, 0.3580213284290983, 0.08325658063332009, 0.10139019171454655, 0.08400804644679816, 0.08063711940658724, 0.07812904829898981, 0.08498103642089849, 0.08030374168436005, 0.07940017277051592, 0.10660725185699282, 0.171102044929345, 0.1381875249357647, 0.1264355140078769, 0.154424932343321, 0.13849880685831828, 0.15496784677592967, 0.15348048580473383, 0.1647006648659073, 0.14432120047220653, 0.24369338241836735, 0.22693597484554395, 0.23204802290266546, 0.22275435192617532, 0.23092596912625718, 0.22907761815816263, 0.23925534524732062, 0.25144919590888626, 0.23982742429415527, 0.17627464199387233, 0.16438490454290366, 0.17372030978377095, 0.15882468441985242, 0.16439273524554554, 0.16987984643428755, 0.1853795703389466, 0.18757000972757332, 0.17467169925771264, 0.18486469639225234, 0.16889061435710662, 0.18010902183917388, 0.1616434406967463, 0.17101950917082887, 0.16541370969926372, 0.17166746042030523, 0.1785641908646397, 0.16298820812526138, 0.16875393002272554, 0.1810676075559593, 0.164792766683176, 0.16650056983325412, 0.17346826730460452, 0.17010180685535592, 0.18532931915020778, 0.16780454677118828, 0.18873666805835243, 0.3687875193599186, 0.15986299755291988, 0.16592304577693395, 0.17797603548230823, 0.4014074722052148, 0.17804443506298906, 0.17854280755423335, 0.1684661816958536, 0.17223405454258167, 0.1609107013211789, 0.16198860919810432, 0.23382135401711623, 0.15436902085170678, 0.16932182259081496, 0.16101616085585446, 0.19767295481240577, 0.1920020819381556, 0.3915013974166057, 0.2111028176401123, 0.185714511922636, 0.18289674149090152, 0.1777790736237299, 0.18768668941898892, 0.17633924914500654, 0.19380553013092428, 0.19449120632404104, 0.17969220398812957, 0.06952061405607324, 0.06535888315967187, 0.0680625180030876, 0.07367965911344343, 0.06588714011820607, 0.06439153681626031, 0.06866307239644687, 0.08146978896557688, 0.06841487935278567]}, "mutation_prompt": null}
{"id": "c0664eb3-d4d4-44ff-b755-70e32924d3cd", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "06e4da20-4da9-448a-8b90-fb36366c9d89", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "0ad0811a-bc6b-48be-9f86-ce7178a25ea9", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "cbc080e2-6438-4164-b21e-968812ad19f1", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def adjust_population_size(self, evaluations):\n        # Dynamically adjust population size based on remaining budget\n        return max(10, int(self.initial_population_size * (1 - evaluations / self.budget)))\n\n    def __call__(self, func):\n        population_size = self.initial_population_size\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = population_size\n        \n        while evaluations < self.budget:\n            population_size = self.adjust_population_size(evaluations)\n            new_population = np.copy(population[:population_size])\n            \n            for i in range(population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(population_size, 3, replace=False)\n                x0, x1, x2 = new_population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover with permutation\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                perm = np.random.permutation(self.dim)\n                trial = np.where(crossover, mutant[perm], new_population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            population = np.copy(new_population)\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Integrates a dynamic population size adjustment and enhances crossover with random permutation for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.1556044489716, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.26850498359768626, 0.27571049559259997, 0.273742122433527, 0.26223827131471134, 0.27454086641745457, 0.2746417725366438, 0.3100503927524575, 0.2772294729975019, 0.300525304669663, 0.006411786586393631, 0.000704244624864403, 0.008629923589937083, 9.999999999998899e-05, 0.0012725631352337174, 0.0004376774506770209, 0.005970029424691381, 0.001026150982499363, 9.999999999998899e-05, 0.08002274904134377, 0.0673574628393131, 0.07314592051296098, 0.07338073544140311, 0.06951173433575553, 0.06892552005579622, 0.0640293460727851, 0.06675730388504342, 0.06129783640059616, 0.084224428949211, 0.08564775509322975, 0.08969390760795926, 0.07465243351540263, 0.06493985530956647, 0.06997717199568942, 0.06018180395246597, 0.05702247368577851, 0.06908974493689435, 0.8129008503709187, 0.8246730902863307, 0.750394692423566, 0.8044848599635757, 0.6002876457653007, 0.8502906369000696, 0.8646490817040029, 0.8985495310748975, 0.8135599332305472, 0.1293813737025339, 0.1083450834228673, 0.1328599133736088, 0.10269871530340169, 0.12236961757219633, 0.10774206951073317, 0.1449767549276818, 0.13659677272862114, 0.12635483671838776, 0.19064329869106122, 0.21143194028069856, 0.18919997972057856, 0.16074520178228668, 0.17016674554373368, 0.1670410304479536, 0.15484087557709225, 0.1480399882622483, 0.18296322472201876, 0.07826193533446768, 0.06687012093442712, 0.09215598459744256, 0.08292529611187549, 0.0757119414091898, 0.06829890590474175, 0.06783792539518219, 0.06749045514011265, 0.06502798387255682, 0.1261156832829402, 0.1013114075368794, 0.13510415628206207, 0.11648505709555024, 0.11573420173553317, 0.1014956600483582, 0.12478034974046692, 0.11050680748496666, 0.12292394407438278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00033633631422858024, 9.999999999998899e-05, 0.060613426671729975, 0.05376159676771186, 0.05069423516649718, 0.09313011267700788, 0.05189831492104091, 0.04107076663180065, 0.06870517971124757, 0.06657159478719099, 0.08916201196821472, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017215613181101097, 0.015172386957567285, 0.005097591143287228, 0.02040136030667128, 0.02923178635725543, 0.03215062972483518, 0.02595627649693666, 0.013452794973592086, 0.02540745068986272, 0.28274405431076066, 0.28717622257770603, 0.26876608090987797, 0.2689671472054822, 0.2543909298365413, 0.27275461555116187, 0.3018818035872094, 0.3043925383393129, 0.2946236300370405, 0.07871255401868782, 0.07929252170101209, 0.07660401208844925, 0.07089718426195746, 0.07218529692439368, 0.08174816707112986, 0.0691754593377163, 0.06920171056309721, 0.07079002602716977, 0.1327760390239633, 0.14750534881854416, 0.15103456331605958, 0.13126601985760755, 0.1616363785153595, 0.1441804791758079, 0.17946219078064019, 0.1310920048270755, 0.14854763621128042, 0.21338104840736627, 0.20276812658178955, 0.2190362245439179, 0.21946381079449528, 0.22974014230087492, 0.21545978967658652, 0.1934971650745526, 0.19944839303213535, 0.18546785054009762, 0.15986927239612236, 0.13679931245261068, 0.14336375485785524, 0.14845756616073047, 0.1528417202902529, 0.17779925581370737, 0.13045836647237408, 0.1288899401176672, 0.13537475816044375, 0.2008842199594093, 0.1854875530644876, 0.20438572304210045, 0.2086867521450686, 0.19527328842859637, 0.19285633031433957, 0.192435742410221, 0.23269942116526166, 0.19980274974407242, 0.17451232890637713, 0.1780004066802383, 0.18157225162774449, 0.1861669370541803, 0.1977047188781993, 0.19358425028241955, 0.1774646086443572, 0.20527397715219753, 0.19463723254308207, 0.265978234782394, 0.18604713221156333, 0.24441416562982943, 0.2931520514102226, 0.22598717820870595, 0.22883281641752717, 0.2042536570015866, 0.156610229787422, 0.22676205580990305, 0.2066230429443987, 0.17737903016491874, 0.15754807759836165, 0.23314756464586595, 0.17315202882374592, 0.243188857174795, 0.2682400122321703, 0.1813408882504921, 0.2012280814037124, 0.20448654826660417, 0.189319041382346, 0.18166880528064544, 0.1797286619387034, 0.1912965066933625, 0.18936789330830173, 0.18146442869961177, 0.1769625612412281, 0.1872000434815021, 0.07715870367000566, 0.06067707782803644, 0.07291163031036818, 0.058556325184978, 0.07758122997854078, 0.06901217307517005, 0.0742893880770904, 0.06397736607792792, 0.06701861710902668]}, "mutation_prompt": null}
{"id": "19b970e9-7744-461c-8494-f25975069c95", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "36dbca20-b7fb-4c5b-8af6-d9485e7a04cb", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "06534683-b116-4c27-9a09-a37c808e0ba4", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_population_resizing(self, evaluations):\n        return int(self.population_size * (0.5 + 0.5 * (self.budget - evaluations) / self.budget))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.adaptive_population_resizing(evaluations)):\n                # Mutation with adaptive scaling and improved noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.05 * (self.budget - evaluations) / self.budget, self.dim)  # Improved noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive population resizing and improved noise adaptation to enhance convergence speed.", "configspace": "", "generation": 26, "fitness": 0.19155564212830137, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.3474453771519901, 0.35999019882992445, 0.352433386678804, 0.38195086043145265, 0.3573927929086539, 0.34927646691054814, 0.35953549850316757, 0.362069865481103, 0.35049278734225053, 0.017803300420816015, 0.030179782104993835, 0.02975641738873469, 0.01701141919024407, 0.013408197082340867, 0.018493825730730884, 0.013624162186210875, 0.013370185050031957, 0.021542450724737705, 0.10083989436417828, 0.11231238266862997, 0.12075652211308174, 0.12736459390937105, 0.1082861209107363, 0.09916169367927141, 0.1116082721790137, 0.09716646040079413, 0.10477902198858302, 0.08854073300880749, 0.08540664441216572, 0.08076513106849237, 0.0916602968093353, 0.09053508179110759, 0.09444637662048849, 0.07954852096161269, 0.08910025701665603, 0.08530823149355515, 0.9617157040127756, 0.984616933248957, 0.955198204994032, 0.9770044334295045, 0.9556642404900723, 0.9501269307227355, 0.9687581070234211, 0.961727317214772, 0.9548054378373008, 0.22514416772459556, 0.213589982306313, 0.22175760926464005, 0.20695605030036168, 0.21514548367068687, 0.20603956304572768, 0.20598792853715187, 0.20894856598800038, 0.2146316980836238, 0.303794546725622, 0.2857803578783976, 0.2512200051556852, 0.2628688716263541, 0.24407961503559295, 0.2262351685447812, 0.25941872484510275, 0.2465879932807552, 0.2829805456085619, 0.12263318049479421, 0.12801829172187695, 0.10862136098571828, 0.12485421008581055, 0.11411685880333589, 0.11458994738747574, 0.1284480353905748, 0.10892917013661185, 0.11186341713178649, 0.11631187676846966, 0.1059004865168175, 0.0964434526289848, 0.11619327596904239, 0.11802151600935484, 0.11034181241251861, 0.11361188369703246, 0.11816168074819522, 0.1104498143139544, 0.0012542152041129517, 0.013431248037623855, 9.999999999998899e-05, 0.0002168000992330832, 0.0003708573705182294, 0.023787973025462428, 9.999999999998899e-05, 0.00227854169569619, 0.0023499270419963247, 0.05038598656750093, 0.086540311744987, 0.07633601781814436, 0.03153907366487052, 0.05546522630685158, 0.03781327493958975, 0.0512284241020341, 0.0853433436333082, 0.09654277027871472, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011065302386525921, 0.00011941715091745575, 0.0004096252532151956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05101075027176827, 0.06628263663864675, 0.05038071251098408, 0.06537486816967575, 0.06911014389591075, 0.06688252532726369, 0.056121417914580474, 0.06623516137234586, 0.053059410567465215, 0.3363607744144126, 0.3502388847740191, 0.33818202144981446, 0.3401845945060171, 0.34352446807984927, 0.33094253279448194, 0.34166648692117674, 0.33817977389992326, 0.3275167785497708, 0.09852675226024732, 0.0984662631769384, 0.1060104365673431, 0.08627607138621096, 0.0963047736708671, 0.09617525775731084, 0.09005317020676717, 0.09147497183627562, 0.0897483158453668, 0.1427639343533832, 0.161833233962411, 0.13967615062436378, 0.1437091849097627, 0.15394655297458215, 0.15071484125020163, 0.20281611087461748, 0.16759488368858433, 0.1594410261437792, 0.2528317422456423, 0.25323111825230893, 0.25122853396706224, 0.24848038222024604, 0.24247378892235438, 0.2457491684817571, 0.24892933295951225, 0.24936677120040807, 0.2509693157158852, 0.1833724574341895, 0.1947849396324931, 0.18575359803171754, 0.19494299754293065, 0.19317306687162072, 0.18367742851901359, 0.1952383989301869, 0.2015645754338008, 0.18636408585580555, 0.20243258799740838, 0.1952386988376833, 0.18165820187489945, 0.19937287530712167, 0.18968637602309402, 0.19042738268485115, 0.23960192536248504, 0.20879294813989313, 0.18791771915440758, 0.19925099520442746, 0.220128288902241, 0.20828236913567233, 0.1987143040264332, 0.2159069829834428, 0.18988580751452167, 0.19565583976147938, 0.19099259639752586, 0.19668252206657733, 0.16713584344541377, 0.36513532869765586, 0.43995687870776856, 0.4155969528968062, 0.17231542129383792, 0.39685385539521667, 0.4062775199890243, 0.3903264615659966, 0.1957507950730617, 0.18877269137647967, 0.19047164592436283, 0.19076664971370805, 0.28064729580258885, 0.16537948863107466, 0.18938257418735638, 0.20743479129440523, 0.20639365112853203, 0.20168623830456145, 0.19511101216050886, 0.18822132210035836, 0.18483146068333522, 0.17550887205147503, 0.18258206556866763, 0.18055525302428177, 0.18467610570947568, 0.18313026679867606, 0.1816233322957811, 0.07482412570400176, 0.09132713388727576, 0.08129349572679079, 0.07915723070741953, 0.08105055049394938, 0.07781174742425134, 0.07449199230489012, 0.07657808541952249, 0.07543321281723092]}, "mutation_prompt": null}
{"id": "ec8fe894-68c5-44c2-90a0-caf7f051fbd2", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n        \n        evaluations = self.population_size\n        chaotic_var = np.random.rand()  # Added chaotic variable\n\n        while evaluations < self.budget:\n            chaotic_var = self.chaotic_map(chaotic_var)  # Update chaotic variable\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations) * chaotic_var  # Chaotic scaling\n                noise = np.random.normal(0, 0.1, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob * chaotic_var  # Chaotic influence\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Integrates chaotic maps to enhance diversity and convergence in mutation and crossover operations.", "configspace": "", "generation": 27, "fitness": 0.192531491538133, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.3626131476689599, 0.3532524175162881, 0.3537821028489503, 0.3532579688024583, 0.37404557635082114, 0.3586142241191166, 0.3752745637011341, 0.3668051713992063, 0.3621664076018125, 0.024858000714725992, 0.018019607024190365, 0.026662111034111646, 0.02667848240270887, 0.018565960991317132, 0.0001106013762605107, 0.007002447693367886, 0.016755411508765805, 0.02030518330358877, 0.10598532287799511, 0.10174042627917401, 0.10726734168477492, 0.10923576987988659, 0.11466050282211204, 0.10515528641227356, 0.10856231963470686, 0.11344072452896647, 0.10568674089270458, 0.09240550355235777, 0.0914634655265325, 0.0884171818368723, 0.0902253716330983, 0.08406814980239219, 0.08877870499057205, 0.09512709108137096, 0.08958712075846675, 0.0858900505643736, 0.9558660296254775, 0.9699278112538566, 0.934301358807685, 0.9719134085588845, 0.9551059986510396, 0.9493428863995723, 0.9669490466709622, 0.9409852903529684, 0.9813676566833195, 0.21953731640492058, 0.22110339301998305, 0.2076257120237227, 0.2028687895771476, 0.22138264130648466, 0.21652750439648205, 0.21398462286689113, 0.21338951063491784, 0.21359665951415807, 0.23936389629949595, 0.20731469740167952, 0.24993970898559548, 0.2553931442510238, 0.2567397110233355, 0.2541499770524962, 0.22183031036310308, 0.23335649105827538, 0.2250510047523635, 0.12034342247057683, 0.11918058866741443, 0.11581533156505608, 0.121828391987989, 0.11820058867752703, 0.11058766918326024, 0.11697610548698611, 0.11555329035748108, 0.12167145797031842, 0.1262625360608043, 0.1248052779203841, 0.127671965590899, 0.11987562787224781, 0.12291817023424301, 0.11299944124542471, 0.12024357566357702, 0.12013467835909508, 0.11946644852237354, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004379284223680058, 9.999999999998899e-05, 0.0014318395091240665, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004005799636110696, 0.09869641605596424, 0.0511063731128274, 0.08838125942811315, 0.07286034771728989, 0.06233467003215687, 0.04243882374451147, 0.07209279255639778, 0.06387272848001335, 0.043093890040953875, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06202517714806255, 0.054226569177859174, 0.066858352408797, 0.05766646862707059, 0.07530229594683346, 0.06802078468994699, 0.05955558269375705, 0.05790176736162034, 0.044989444028799674, 0.34653682490023185, 0.3387754323418011, 0.3507404467950035, 0.34348082376453803, 0.33286856405752474, 0.3381153370190826, 0.34121510740571803, 0.3230197436784322, 0.3329202766749001, 0.09177463502867955, 0.09460947754375593, 0.08757850236086762, 0.09782954035999958, 0.09440587729804939, 0.10449587488773737, 0.09488873573819179, 0.0890010607979208, 0.0881464632389205, 0.15620485824549957, 0.1628107864284759, 0.13894650865769365, 0.15698349904169573, 0.18436438445107928, 0.15549274097464605, 0.1500767535398705, 0.1412254063455214, 0.13319046460837292, 0.2492036605263125, 0.24902201226264753, 0.25011794243068297, 0.25291271256832404, 0.24655281662432826, 0.2474936041927044, 0.25504337468122207, 0.24786934421070683, 0.24763794166468023, 0.1869427783505282, 0.1852655812046179, 0.18331794340061613, 0.18939812887780783, 0.17416552554681553, 0.17991615454264898, 0.18421443197269904, 0.19515793485409005, 0.18471748517445663, 0.20793675146403767, 0.20621042045515614, 0.20443466526083753, 0.20529047766688768, 0.20220930290179162, 0.20593310439377865, 0.20412339351641662, 0.21046824862953328, 0.1878025126479791, 0.1977933250815962, 0.19675948123053044, 0.20239623234915194, 0.2061087679896092, 0.19882714419899838, 0.20901760872959152, 0.18304365751427232, 0.19271083764300911, 0.1957903500464575, 0.1687029062390235, 0.32661616718154696, 0.47285139418518296, 0.45294017404204256, 0.4233864516189707, 0.3146316451139508, 0.2602997751087328, 0.3073477952715665, 0.4165071399950844, 0.28985019254319766, 0.18112344259047208, 0.18240985181738856, 0.1876851921157605, 0.2186867832145506, 0.20398873486520286, 0.3257123613881244, 0.31282192309017864, 0.14964783243161217, 0.1847308006269417, 0.19018245462688732, 0.18167885178308407, 0.18271769848386343, 0.17462181042945446, 0.17363967274776737, 0.19197804816861064, 0.19042441752488648, 0.20158887528835934, 0.08471298586120923, 0.07665742609107151, 0.08150274807672742, 0.07988872926167401, 0.08572901520419329, 0.07922507519753874, 0.07838889004625127, 0.07746156285087868, 0.08224464875851789]}, "mutation_prompt": null}
{"id": "664eccbd-5d5d-4f14-b04b-45194e692627", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "26bba893-cc79-4897-b504-1d6f6e3266fc", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "69cc2ec8-af47-41db-b568-96eba95458a5", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "b06a6c9e-597b-46f6-b50f-b15acdf927af", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and dynamic noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_scale = 0.1 * ((self.budget - evaluations) / self.budget)  # Dynamic noise scaling\n                noise = np.random.normal(0, noise_scale, self.dim)  # Adjusted noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Enhances convergence by introducing a dynamic noise scaling factor in mutation to improve exploration.", "configspace": "", "generation": 31, "fitness": 0.19297791794291475, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.3712858922598845, 0.36341691515941543, 0.3749421385420193, 0.3433966054513693, 0.3661202461212725, 0.35633342273273716, 0.3487922785791533, 0.35535476694552515, 0.3536141849385944, 0.029135559700386837, 0.013083244456449039, 0.02185582694111221, 0.013211967961751725, 0.022749036354387187, 0.0029699729247668616, 0.019490225822796803, 0.033544716336465163, 0.018519761638795207, 0.10614434643431447, 0.09920247733052623, 0.11392589084051474, 0.10147183343468935, 0.11846627649966446, 0.11212700897562788, 0.1041102503104554, 0.11877592487674371, 0.11032233598701713, 0.084472830661531, 0.09384997272393736, 0.08584036904221826, 0.09333065266534701, 0.09322146920319141, 0.09459632555765363, 0.09089427138183348, 0.08953725485180108, 0.09168289142691322, 0.9568559874971355, 0.9629315101577257, 0.9566864473862705, 0.9571568341405223, 0.9098916027916092, 0.9535870203072222, 0.9607092052156827, 0.9554190680618295, 0.9600691727579902, 0.2149556182405733, 0.22653500216636102, 0.21918352054556112, 0.21909983503450114, 0.22483009735546133, 0.21994085151416876, 0.21619392543293403, 0.23381709590057786, 0.22660064968217708, 0.31688613562829304, 0.2408539368774415, 0.33189855426122095, 0.3029446737801973, 0.26757921034193055, 0.2721882891714007, 0.2493405170341545, 0.282736776500243, 0.2910137864611504, 0.12539945600949942, 0.11127085987896934, 0.11193853434285628, 0.12238616769758703, 0.12097952999681416, 0.11376841452928621, 0.12666018412242208, 0.11902646069927703, 0.13541324884494021, 0.1169781131292843, 0.11136322373802099, 0.11612280474381365, 0.12174572143682871, 0.12793251433223085, 0.1322786161242815, 0.12142461500347401, 0.13062675418122105, 0.11365993605916214, 0.011055398248354331, 0.000931580659847886, 9.999999999998899e-05, 0.001743708738632499, 9.999999999998899e-05, 0.0001768775159218805, 0.001289605249974346, 9.999999999998899e-05, 0.002054273800656148, 0.07751841487325584, 0.050405695448705545, 0.07727224842359648, 0.06439278306985341, 0.06824145045819008, 0.018753209921571035, 0.07519132707798326, 0.05366766837965131, 0.042332119408264535, 0.00019328347034441862, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00025558227997535266, 0.00013842326437729646, 0.0001408754764826714, 9.999999999998899e-05, 0.061084573770840866, 0.06282527884939504, 0.058315443197611394, 0.066446034086311, 0.06703731914200894, 0.071803140061235, 0.05806585094479455, 0.05878060087032133, 0.05868665931337724, 0.34503203110841196, 0.34512449431149683, 0.3342402210541061, 0.33693505771846444, 0.34112658889597847, 0.3439993092637659, 0.35560741217553893, 0.34228701448058907, 0.33697810591994026, 0.0936037788353773, 0.10709021488663917, 0.1024487974976408, 0.0979755674635866, 0.09451029340057171, 0.09678440325192894, 0.0975227749819858, 0.11137158979277628, 0.09413133673748675, 0.20024880141052603, 0.1499966998142489, 0.17174740353895157, 0.19670150291291832, 0.16736127971222736, 0.16505768349522443, 0.16160088273655926, 0.1476623909859156, 0.13276050965577013, 0.24992008220166362, 0.2481701924345604, 0.2537079933144616, 0.25032699513488577, 0.24691112156360195, 0.2577239707771324, 0.2569315727207566, 0.2562911409033757, 0.2497400265877483, 0.18969309058695538, 0.19559016929845952, 0.19827747202318646, 0.19741920068634067, 0.18695116645459764, 0.1909310119177482, 0.2019905864363314, 0.19612280234132518, 0.19531130449290035, 0.20386502525642658, 0.20971679364595153, 0.18853154236262504, 0.18963408257782066, 0.20478553875646954, 0.19644155878403413, 0.21023204661305694, 0.20025418535977257, 0.19128777778045147, 0.19026363125031953, 0.18560371138218612, 0.18670448432304787, 0.20123478175665033, 0.19588393390633851, 0.21197311217432002, 0.1919439336476505, 0.21001396830492636, 0.21871354641534912, 0.1644651421629444, 0.1697760273815968, 0.3798225245084139, 0.4514440304986138, 0.18073558999306338, 0.17977919223312933, 0.15883683288338868, 0.4196809808664457, 0.4986526003419859, 0.16781442521008672, 0.19321064848888292, 0.1878782629397867, 0.28718671923889083, 0.25671558394187244, 0.19814052983700248, 0.20578023311150262, 0.31814507212385756, 0.20573521638581194, 0.19562038464938492, 0.19718124821586636, 0.19050871097463984, 0.17744447941270192, 0.1767174361160312, 0.1768037822708729, 0.18237779539065213, 0.1699834601204644, 0.18144540949862298, 0.07459966625594794, 0.07302756260634047, 0.085016327593886, 0.08211509424256525, 0.081809638602522, 0.0791442475958849, 0.07318084968245964, 0.07917040455292368, 0.0760154153417899]}, "mutation_prompt": null}
{"id": "9aa5aff7-4696-411b-96fe-e677b384e23e", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        # Modified for self-adaptation\n        return self.f * (1 + 0.5 * np.sin(2 * np.pi * evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with self-adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism and occasional perturbation\n                if np.random.rand() < 0.05:\n                    trial += np.random.normal(0, 0.01, self.dim)  # Elitist perturbation\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Improves convergence speed by incorporating a self-adaptive mutation strategy and occasional elitist perturbation.", "configspace": "", "generation": 32, "fitness": 0.1926647486611197, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.34397059245908546, 0.3528187079975915, 0.3536632576880383, 0.3481430375779525, 0.3616439256543367, 0.3698915960332735, 0.3698335462676051, 0.3598458009364144, 0.34581528192609967, 0.011148502909292035, 0.011185334682804582, 0.0174883270432592, 0.019315229262214628, 0.01815404863315384, 0.01619947012666456, 0.012808960229169664, 0.01076774611476028, 0.02073927431196776, 0.0925257894625029, 0.09909609386179385, 0.09068589092343593, 0.098178813121101, 0.09917132715663268, 0.08275093624054075, 0.09191248037568767, 0.10385184040530981, 0.08365440893362452, 0.07344666018728041, 0.08682574423935241, 0.0881644935422431, 0.08010975718857793, 0.07945554410380828, 0.08689052689916077, 0.08991821004716916, 0.08302776726736594, 0.0755288598278645, 0.9758049101259374, 0.9590617233294032, 0.9561951903858169, 0.9450128802398989, 0.9545968820560393, 0.9656173850273818, 0.9604941837186158, 0.9878911948525069, 0.9749580073764724, 0.21476264288155356, 0.23583328486334654, 0.21345379923286534, 0.213321629006601, 0.20091372726865397, 0.2129460420250746, 0.22311618713144055, 0.1989727898300787, 0.21953881628923433, 0.24103593027311632, 0.25654351650990725, 0.23510451830753054, 0.3062088569218413, 0.31901368724364043, 0.2952026695292157, 0.23998294153211597, 0.26136207899573327, 0.30935488031799596, 0.1125683542359518, 0.11509258528699917, 0.11437117239567329, 0.12247336790561225, 0.12629924552673766, 0.11387470422392598, 0.1279796184541816, 0.11370043752294245, 0.12246139154583546, 0.10763798277868786, 0.0808972276139499, 0.12635776337222704, 0.11479566046781309, 0.12573671914627726, 0.11289887377767194, 0.11110439078118584, 0.10652727261996664, 0.12355210297150965, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002108130430147348, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004736798567406275, 0.06684286143041296, 0.06733523626524751, 0.06618605696679292, 0.05253592165685894, 0.08882226092829493, 0.07620814831060196, 0.06639914316304618, 0.09062730388260953, 0.054947162327708465, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06212287267803818, 0.06758801315607543, 0.05773177531956697, 0.059071899576644715, 0.08182931316001107, 0.05429916527349654, 0.05656405880016668, 0.059922603638134175, 0.0457631978005969, 0.3538798386722819, 0.34326719310729303, 0.33536827580887973, 0.3288060837180794, 0.33353863773660086, 0.3331506986852426, 0.33278956331395626, 0.33060141104743546, 0.3368630024868432, 0.09557145106267051, 0.10237510801009575, 0.10300374888805186, 0.10343253014423659, 0.09218738451170416, 0.09396040449189114, 0.08330450212882756, 0.09087236121918885, 0.08633955563641227, 0.15358766758379172, 0.13302674962045058, 0.15863069162747323, 0.15749886194561435, 0.19265473006860911, 0.13862963240205628, 0.1485435573480921, 0.1404647912496042, 0.1601248639645403, 0.24574642749102416, 0.25170833496778267, 0.2407134283152459, 0.24875305596569108, 0.24510789914193232, 0.24764977799931098, 0.2541261005654111, 0.26124521856333127, 0.24201077921708058, 0.1850154039421037, 0.18813371769158016, 0.18881778752916245, 0.16829567739501106, 0.17119184079499206, 0.19226846076279602, 0.18318626035294006, 0.18962009252323975, 0.19344553779756357, 0.1802783546854867, 0.18811425305803475, 0.19698536604692685, 0.199237825627114, 0.18220207681223943, 0.18387500251318556, 0.19074482290224537, 0.18483257487235483, 0.1954728978304846, 0.18505675143985445, 0.18252960203373547, 0.1783452120822614, 0.17709150555801112, 0.1878864797887584, 0.1785905101014168, 0.1809393910787307, 0.18005769431394603, 0.1797333995749688, 0.43713687508637966, 0.45782219046561345, 0.4085627554913638, 0.3911379808435056, 0.17563661059978253, 0.4277764042416774, 0.17416578445862085, 0.4289128256742252, 0.24574621123720275, 0.28186158816759255, 0.18670121990909438, 0.3165977580263013, 0.19471170446145358, 0.18802094044385298, 0.18284067331748088, 0.3824407138767262, 0.39399073656513317, 0.21060323513571888, 0.18442546238512636, 0.18457730518196636, 0.18726670764174858, 0.18474888305471304, 0.18389596701591437, 0.18347636352596386, 0.18865044429374234, 0.206933548365838, 0.19826435717020363, 0.07254892808098012, 0.08120991888500084, 0.08466061175492157, 0.0681125862805888, 0.06557569850499789, 0.07988974272942362, 0.07077975854474339, 0.074293643712815, 0.07978826108521064]}, "mutation_prompt": null}
{"id": "789433a3-0c6d-4af7-9ab2-c1cf6ae7fb43", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def calculate_population_diversity(self, population):\n        return np.mean(np.std(population, axis=0))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Calculate population diversity\n                diversity = self.calculate_population_diversity(population)\n                \n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations) * (1 + diversity)  # Diversity factor\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.cr\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a variable mutation factor based on the population diversity to enhance convergence speed.", "configspace": "", "generation": 33, "fitness": 0.18780084359593835, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.3357632927425591, 0.36464771426561915, 0.3478183035746242, 0.3613148315584339, 0.34805494792872005, 0.3565556301344758, 0.35885236744751414, 0.34425012743574723, 0.35049559183251666, 0.022574892653049572, 0.022445086802391545, 0.011521047137097562, 0.006672548401131628, 0.01970521924297519, 0.012047232202874847, 0.01717936030062317, 0.009220342813587523, 0.016762591029518825, 0.11917528708919822, 0.09402953569917227, 0.08893948861891932, 0.09832569444242456, 0.09668919014641686, 0.08878907860004748, 0.10835267738685161, 0.10246613245600167, 0.11071187240091585, 0.07958450955076679, 0.0801328537747713, 0.08691960746410221, 0.07416212324762617, 0.0746321054902237, 0.07390732064799799, 0.0744676428035631, 0.07440238696453794, 0.07468282890469513, 0.9666400824308957, 0.9386628137682347, 0.9535927042601127, 0.9753760953745231, 0.9461587343168912, 0.955531321898951, 0.961992412495724, 0.9338475212354538, 0.9592352806329159, 0.20806636620759678, 0.21652075069560273, 0.20188386795053592, 0.22629679156156446, 0.2088636328191692, 0.20638780574049564, 0.20225338050967234, 0.21462497815447423, 0.22486015296262718, 0.3316916748973122, 0.27897988323705414, 0.3093776880782845, 0.2986514097730757, 0.3083723761859437, 0.3201398530139521, 0.3157090011725652, 0.3163522313390529, 0.273094906247904, 0.0976657688055036, 0.10873940335925891, 0.10318174568383565, 0.1139756974654631, 0.1060784522789947, 0.11509709066632534, 0.1223150066432439, 0.11046736642597277, 0.11508496199925722, 0.06878539127248062, 0.10945630306701293, 0.06704560898542222, 0.11299629750734907, 0.12801484427055365, 0.10297258342546867, 0.10807634525062915, 0.11082720269038748, 0.10339978906365033, 0.007680124078040862, 0.019080374970713798, 0.007422622492535114, 0.004020854651814787, 0.00017890374473861215, 0.005168072843573124, 0.003209503880749587, 0.006130924621877809, 0.01282771774911795, 0.05287393903221782, 0.04846714081790526, 0.05573624205405581, 0.08807679297926607, 0.05529909556860424, 0.0932675503331376, 0.07033592207152273, 0.06426429131000333, 0.044660168289737734, 0.0017252007641230804, 0.0005903561970186377, 0.0008910006054191344, 0.0023901617061512503, 0.005435522037128937, 0.0008531100615644105, 0.0012615009247454179, 0.0029657903787708717, 0.0028317448220906982, 0.06076677373447836, 0.06709824831471412, 0.0669013456714187, 0.061650471930799866, 0.05749683401668315, 0.06363639934186016, 0.06601299151790296, 0.061852146167040156, 0.06436658241670756, 0.3349391520421434, 0.33426597992916585, 0.3575157286348263, 0.34536792634059776, 0.3405707374929139, 0.3340088081061565, 0.3265982549408586, 0.3269313932318064, 0.3410593988319748, 0.09475790562749475, 0.08886423765522977, 0.09990993027665829, 0.0878022080814631, 0.08989117243108635, 0.0863175691749275, 0.09003825847121172, 0.1023516878939752, 0.09837283112845963, 0.15285763574191202, 0.1846454117038766, 0.17627324577750114, 0.20534930094406223, 0.23591725044389344, 0.15534745392207638, 0.16600254861875785, 0.17614699920657317, 0.18535716833604954, 0.22664951311426496, 0.23258858790720338, 0.2450541507392512, 0.22956211706654261, 0.233094153022939, 0.23069166100861016, 0.25329804692426017, 0.2497467543156292, 0.24153482284690786, 0.1705969686072698, 0.1700064272054882, 0.16682977354587836, 0.16641227539446213, 0.17710332610996904, 0.17703296108702904, 0.18619325436471335, 0.18387982800658875, 0.1811242877272431, 0.16434747902588065, 0.17143722526494953, 0.18256589340397278, 0.16708907841401832, 0.17913850499744166, 0.16741839689557114, 0.17942554453069748, 0.1605417338736348, 0.18211131436113714, 0.1863044842785211, 0.16361739494289196, 0.19784879586531678, 0.18753339794802193, 0.17528487914701274, 0.16876747567616335, 0.1840677734776276, 0.19135696019215598, 0.19037167818351275, 0.16148901028631057, 0.1721998870399415, 0.38728205521984005, 0.17937343336434552, 0.39358577721667376, 0.18573938510242127, 0.18528338389916743, 0.41232281058612397, 0.18147359000426255, 0.35288453059947356, 0.1770323867083855, 0.1574008527157903, 0.34895297224388855, 0.29102709247169556, 0.22621931679191043, 0.19828161761497187, 0.19647460354189328, 0.3544760235440575, 0.1802589828169826, 0.1696838710691536, 0.18626568899277807, 0.19243230331281524, 0.197897618330376, 0.1762404520241766, 0.1859067469466581, 0.18651590939362483, 0.1725907910333936, 0.0673607834806157, 0.0594908170913766, 0.07229966827535661, 0.07222022333322708, 0.07827659697643707, 0.06863811051826363, 0.06892104432452528, 0.0688220518182645, 0.07055325246375199]}, "mutation_prompt": null}
{"id": "9819a34e-e3a4-4ff7-bdfe-62c3e5f8cfca", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "c3b9e832-1bdd-4400-afce-8002f2ae0d44", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.5 + 0.5 * (self.budget - evaluations) / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise = np.random.normal(0, 0.1, self.dim)  # Added noise\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces diversity by adding noise to the mutation strategy and employs elitism to preserve the best solution.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.35816298840851857, 0.35720161210140955, 0.3695733941339606, 0.35533686619009, 0.36531719152620357, 0.3567976491512903, 0.35554515970991285, 0.3574955098082342, 0.37810879752797755, 0.015807665665558357, 0.02460847739680816, 0.01597573425145893, 0.015320336749200414, 0.020771594982963548, 0.012746042405770819, 0.014965014767961082, 0.015150299818785573, 0.018108004639296404, 0.10659570581059286, 0.09770572676496792, 0.1057151604330111, 0.09409125518070383, 0.10865962430202103, 0.11480168172151262, 0.10001505939619804, 0.10917463782078429, 0.12069035356983404, 0.09539658293731135, 0.08319003345523468, 0.08827949306099325, 0.09017261453882042, 0.0923408971480063, 0.09097580363637969, 0.09284595654041838, 0.09160918596432621, 0.0936807007894207, 0.9568547897107245, 0.9629285048044421, 0.9566883204684417, 0.9571566128458175, 0.909730091619791, 0.9535873084988085, 0.9607083554783651, 0.9554205820216282, 0.9600727145081652, 0.21846063468263577, 0.21727872080952437, 0.2243031817923794, 0.21966743657962762, 0.21609820208921904, 0.23632080562638125, 0.2162732935065681, 0.22078971567625216, 0.20847610476488077, 0.27666032618477465, 0.24776232364390616, 0.289912141404408, 0.2749165584781105, 0.3616262614161717, 0.31045711637418094, 0.304701570357935, 0.25507492226640927, 0.30438148168846924, 0.11774400218581427, 0.11175235559501817, 0.11592188037651363, 0.11499925220742735, 0.120911917795131, 0.11259097438019128, 0.11826868127651868, 0.11378907925819692, 0.11812603948009204, 0.13133265365491786, 0.10692145804659303, 0.10812281810475544, 0.11956380847045689, 0.1249974746610103, 0.12208682265638982, 0.1166252220596723, 0.1196259822235003, 0.11008078221718531, 9.999999999998899e-05, 0.021811383780524607, 9.999999999998899e-05, 9.999999999998899e-05, 0.004732700860045624, 0.015164961836198976, 0.0026012610890960852, 0.001692123585605776, 0.0022332651745818888, 0.07934007567671597, 0.09799326623849958, 0.04183920948393349, 0.08568240228468382, 0.07556799774894485, 0.07899346668397944, 0.07536164264750245, 0.057932854387722776, 0.04758948296735421, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07016965542395537, 0.06760827537669278, 0.05982944807471702, 0.07203857204435138, 0.07069283196662168, 0.06003171834875398, 0.05488715736874983, 0.05464567377799745, 0.06570040119319454, 0.33083795791230575, 0.3717227962949985, 0.34355733986266934, 0.35718416623983573, 0.3491840516397501, 0.3362710536502155, 0.35199324040467517, 0.3388943466493841, 0.3557145316755792, 0.09199685629203047, 0.09930817699672678, 0.08810104745243119, 0.0989520432359885, 0.0984679840557725, 0.10065342859962789, 0.08534836926390121, 0.09162192984774975, 0.0967744876753488, 0.20348430207852997, 0.1573307036945727, 0.15558481922647804, 0.14588028678453246, 0.14729742465442974, 0.13450818105554185, 0.15460743296321033, 0.14787754173817824, 0.15328794676404522, 0.25106683714640454, 0.25262599845310185, 0.25800561011854994, 0.24598071500630903, 0.2498422828748278, 0.24584314825519193, 0.24772421302431513, 0.2580849698623474, 0.25654875969014435, 0.1893370943046191, 0.19325839676396284, 0.19226627201490576, 0.18622618229103627, 0.18437004120788858, 0.18682429638211784, 0.18249875788137815, 0.19910894432045356, 0.19263160044254168, 0.22146849665499435, 0.19914883406560457, 0.20054125400870293, 0.19107880477191064, 0.18091407650333236, 0.20844072839580086, 0.20971178373092192, 0.20878012366914722, 0.19460728489307544, 0.22010384640736225, 0.19267082688684145, 0.2025611677338015, 0.18753381193287122, 0.20436627879408287, 0.18512322905277911, 0.19000956336029529, 0.2092846254186035, 0.23121709205660312, 0.41848219002362785, 0.1737799284333561, 0.3687097534583259, 0.45167913415884187, 0.18150460209519859, 0.17773338559335117, 0.15991179012210865, 0.43322519673343907, 0.4753362828449349, 0.16786644367869863, 0.19287602239257673, 0.185525287158406, 0.29794874755869627, 0.2645728091596724, 0.1993575676808168, 0.20590383583512406, 0.3714263723512554, 0.20676034949728417, 0.1919362645510252, 0.1934882793170144, 0.18601322459860448, 0.20086657036256206, 0.17997281626544714, 0.18643391894752526, 0.18094264284226325, 0.201123623230682, 0.20109887242882452, 0.08337040645477045, 0.0802998133740177, 0.0748610184333065, 0.08745133510023695, 0.08053268179139472, 0.07378106463218359, 0.08008775140322599, 0.08987039548385689, 0.07917229822463101]}, "mutation_prompt": null}
{"id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)  # Adjusted value\n\n    def adaptive_noise_level(self, evaluations):  # New adaptive noise level function\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and adaptive noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)  # Use adaptive noise level\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive scaling to noise level in mutation and refines crossover probability to improve convergence.", "configspace": "", "generation": 36, "fitness": 0.20024214081107167, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "2091013a-ad81-48b3-b7ea-fc571692a48d", "metadata": {"aucs": [0.359739088573798, 0.3620098272319713, 0.36948791215332333, 0.3703083654160523, 0.3682666408890969, 0.37848147324406645, 0.35241906130894884, 0.3505464347604067, 0.36498909100050014, 0.02050923126473847, 0.015271138619847302, 0.028205217215198752, 0.018379490609065074, 0.013310135153588587, 0.015116261031314804, 0.020895686367720212, 0.0316727134945366, 0.014232196969377608, 0.11685721739451183, 0.11171917709657042, 0.10389053907266044, 0.0944035445790089, 0.1114013612160899, 0.11309456134976648, 0.10521790852758417, 0.118631384946977, 0.11441530097319752, 0.09678889013126968, 0.09014920909410162, 0.08792838123969382, 0.10585561932291443, 0.08782375733152259, 0.09069113901740888, 0.07674207376390296, 0.08679012078070913, 0.0888306598834373, 0.9546419259013592, 0.9629315101577257, 0.9566862822672635, 0.9571568341405223, 0.909908824322838, 0.941247138364632, 0.9605227398051346, 0.9614971279285398, 0.9600691727579902, 0.2354860775946621, 0.2205200026836156, 0.21993120459323945, 0.22561689512492333, 0.22436179521667654, 0.2307396216565153, 0.21698091625876004, 0.22732273104980993, 0.22453241906895605, 0.29175743709122426, 0.2796855636716018, 0.26114455635534106, 0.2626221110838889, 0.31633633321224486, 0.3263620185358471, 0.28429723167473986, 0.2566656254449122, 0.30394627283006725, 0.11629077305163937, 0.1260128777672237, 0.11321350700392663, 0.11906614895316614, 0.1233671340498449, 0.13273080180290764, 0.11642715908288415, 0.13001428423235561, 0.11458143161745615, 0.10845565242706234, 0.1150823969636936, 0.10196121864750185, 0.12469455504979632, 0.12073219062161755, 0.1189781435890751, 0.12229024613110873, 0.11456359143829653, 0.11343886455572882, 0.00022266025201822526, 0.009297353427421107, 0.00042768306513774057, 0.030307341104247598, 0.0070937811592736155, 0.009214869600020159, 0.0006119029791973318, 0.00011195672782704502, 9.999999999998899e-05, 0.06553252253495734, 0.08842054859820714, 0.06327458791101248, 0.04737857922799249, 0.10482134613728744, 0.036790775035358436, 0.08081067885604931, 0.07569539223957578, 0.07118220350084503, 0.0014467953740257, 0.0042313265190928595, 0.0001599705338538593, 0.0013399686959488788, 0.0001054753092808447, 0.0002491663530809207, 0.0007360484277365575, 0.00022560610839861273, 0.0012820301910138054, 0.06634199299409704, 0.06273767453903967, 0.05629125676495894, 0.06757921437305181, 0.07989974623899576, 0.06494914266842555, 0.049541680343287986, 0.05841425359052532, 0.06479615230313596, 0.346315476100312, 0.356454956388478, 0.3307186085845891, 0.3331156579244948, 0.3365534123914038, 0.35629169016113527, 0.3434939917082296, 0.3495873224468399, 0.3456704076829479, 0.09418460581602028, 0.10820393474162504, 0.0971382790334312, 0.0952211615979004, 0.10798097566321796, 0.09852071305709109, 0.09225818991509227, 0.098152202998678, 0.0921852849474617, 0.19975780077492689, 0.1651953638251421, 0.17055975147261215, 0.19981494623826157, 0.16219380460533106, 0.17077187138181638, 0.16497105672676682, 0.15585763454362345, 0.14839282520247088, 0.25052688239143284, 0.24983043585734077, 0.24919869715023635, 0.2492127291802534, 0.25139051259765943, 0.26572706296575366, 0.2580076072186197, 0.2580803330819319, 0.2509908198917369, 0.20068027735508798, 0.19577290469452768, 0.18859666606314662, 0.1810787663848179, 0.19105545134469837, 0.1913544914484061, 0.19652321569077102, 0.19640036324442145, 0.1957518825689829, 0.19338424419817235, 0.1983135368826352, 0.19194983851266467, 0.19416447027759476, 0.18764125131165488, 0.19386817273945756, 0.18720203746638486, 0.2060689285902073, 0.20585988756061002, 0.20813326277542887, 0.19535783490019598, 0.20545864372475275, 0.19946442081085614, 0.20903349765836232, 0.2060605730841516, 0.1965397786257067, 0.20067855030183057, 0.2032928297494424, 0.4577670620435975, 0.4470699619189289, 0.1694949500353301, 0.45495140072615625, 0.33780348566527785, 0.47372470131556943, 0.4301123124890984, 0.46302409100734865, 0.4819340792874912, 0.1681906985876247, 0.19715002248772728, 0.340823941907643, 0.38239897849279636, 0.19590552425029395, 0.19902421636617396, 0.20504534602559632, 0.3095391427335177, 0.20664946050544364, 0.18147841722917224, 0.19322071087274906, 0.1790936748072134, 0.1765207410813704, 0.18029831141448704, 0.1758828760857506, 0.18597034653750721, 0.19207393469168188, 0.1895103965505892, 0.08092192250661734, 0.08299162201632915, 0.07695691515288106, 0.08463030788006998, 0.07611854640855986, 0.07310015073707932, 0.07606216918609565, 0.08583722323692733, 0.08724814823337601]}, "mutation_prompt": null}
{"id": "1c7af9ff-616d-4945-9e62-6b32423bdd4f", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)  # Adjusted value\n\n    def adaptive_noise_level(self, evaluations):  # New adaptive noise level function\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and adaptive noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)  # Use adaptive noise level\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive scaling to noise level in mutation and refines crossover probability to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.359739088573798, 0.3620098272319713, 0.36948791215332333, 0.3703083654160523, 0.3682666408890969, 0.37848147324406645, 0.35241906130894884, 0.3505464347604067, 0.36498909100050014, 0.02050923126473847, 0.015271138619847302, 0.028205217215198752, 0.018379490609065074, 0.013310135153588587, 0.015116261031314804, 0.020895686367720212, 0.0316727134945366, 0.014232196969377608, 0.11685721739451183, 0.11171917709657042, 0.10389053907266044, 0.0944035445790089, 0.1114013612160899, 0.11309456134976648, 0.10521790852758417, 0.118631384946977, 0.11441530097319752, 0.09678889013126968, 0.09014920909410162, 0.08792838123969382, 0.10585561932291443, 0.08782375733152259, 0.09069113901740888, 0.07674207376390296, 0.08679012078070913, 0.0888306598834373, 0.9546419259013592, 0.9629315101577257, 0.9566862822672635, 0.9571568341405223, 0.909908824322838, 0.941247138364632, 0.9605227398051346, 0.9614971279285398, 0.9600691727579902, 0.2354860775946621, 0.2205200026836156, 0.21993120459323945, 0.22561689512492333, 0.22436179521667654, 0.2307396216565153, 0.21698091625876004, 0.22732273104980993, 0.22453241906895605, 0.29175743709122426, 0.2796855636716018, 0.26114455635534106, 0.2626221110838889, 0.31633633321224486, 0.3263620185358471, 0.28429723167473986, 0.2566656254449122, 0.30394627283006725, 0.11629077305163937, 0.1260128777672237, 0.11321350700392663, 0.11906614895316614, 0.1233671340498449, 0.13273080180290764, 0.11642715908288415, 0.13001428423235561, 0.11458143161745615, 0.10845565242706234, 0.1150823969636936, 0.10196121864750185, 0.12469455504979632, 0.12073219062161755, 0.1189781435890751, 0.12229024613110873, 0.11456359143829653, 0.11343886455572882, 0.00022266025201822526, 0.009297353427421107, 0.00042768306513774057, 0.030307341104247598, 0.0070937811592736155, 0.009214869600020159, 0.0006119029791973318, 0.00011195672782704502, 9.999999999998899e-05, 0.06553252253495734, 0.08842054859820714, 0.06327458791101248, 0.04737857922799249, 0.10482134613728744, 0.036790775035358436, 0.08081067885604931, 0.07569539223957578, 0.07118220350084503, 0.0014467953740257, 0.0042313265190928595, 0.0001599705338538593, 0.0013399686959488788, 0.0001054753092808447, 0.0002491663530809207, 0.0007360484277365575, 0.00022560610839861273, 0.0012820301910138054, 0.06634199299409704, 0.06273767453903967, 0.05629125676495894, 0.06757921437305181, 0.07989974623899576, 0.06494914266842555, 0.049541680343287986, 0.05841425359052532, 0.06479615230313596, 0.346315476100312, 0.356454956388478, 0.3307186085845891, 0.3331156579244948, 0.3365534123914038, 0.35629169016113527, 0.3434939917082296, 0.3495873224468399, 0.3456704076829479, 0.09418460581602028, 0.10820393474162504, 0.0971382790334312, 0.0952211615979004, 0.10798097566321796, 0.09852071305709109, 0.09225818991509227, 0.098152202998678, 0.0921852849474617, 0.19975780077492689, 0.1651953638251421, 0.17055975147261215, 0.19981494623826157, 0.16219380460533106, 0.17077187138181638, 0.16497105672676682, 0.15585763454362345, 0.14839282520247088, 0.25052688239143284, 0.24983043585734077, 0.24919869715023635, 0.2492127291802534, 0.25139051259765943, 0.26572706296575366, 0.2580076072186197, 0.2580803330819319, 0.2509908198917369, 0.20068027735508798, 0.19577290469452768, 0.18859666606314662, 0.1810787663848179, 0.19105545134469837, 0.1913544914484061, 0.19652321569077102, 0.19640036324442145, 0.1957518825689829, 0.19338424419817235, 0.1983135368826352, 0.19194983851266467, 0.19416447027759476, 0.18764125131165488, 0.19386817273945756, 0.18720203746638486, 0.2060689285902073, 0.20585988756061002, 0.20813326277542887, 0.19535783490019598, 0.20545864372475275, 0.19946442081085614, 0.20903349765836232, 0.2060605730841516, 0.1965397786257067, 0.20067855030183057, 0.2032928297494424, 0.4577670620435975, 0.4470699619189289, 0.1694949500353301, 0.45495140072615625, 0.33780348566527785, 0.47372470131556943, 0.4301123124890984, 0.46302409100734865, 0.4819340792874912, 0.1681906985876247, 0.19715002248772728, 0.340823941907643, 0.38239897849279636, 0.19590552425029395, 0.19902421636617396, 0.20504534602559632, 0.3095391427335177, 0.20664946050544364, 0.18147841722917224, 0.19322071087274906, 0.1790936748072134, 0.1765207410813704, 0.18029831141448704, 0.1758828760857506, 0.18597034653750721, 0.19207393469168188, 0.1895103965505892, 0.08092192250661734, 0.08299162201632915, 0.07695691515288106, 0.08463030788006998, 0.07611854640855986, 0.07310015073707932, 0.07606216918609565, 0.08583722323692733, 0.08724814823337601]}, "mutation_prompt": null}
{"id": "5ebdae1c-70ae-4dfd-885a-69d68e8f38ea", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)  # Adjusted value\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def adaptive_differential_weight(self, evaluations):  # New adaptive differential weight function\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                differential_weight = self.adaptive_differential_weight(evaluations)  # Apply adaptive differential weight\n                mutant = np.clip(x0 + adaptive_f * (differential_weight * (x1 - x2) + noise), self.lower_bound, self.upper_bound)\n\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a diversity preservation mechanism by incorporating adaptive differential weights for better exploration and convergence.", "configspace": "", "generation": 38, "fitness": 0.19946334544938052, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.3630745101516487, 0.35472390754037364, 0.3547123981617315, 0.3665828984698364, 0.3416782032347154, 0.3531137302263495, 0.3619316811290303, 0.35889325243924974, 0.3542454800204271, 0.027145691691569662, 0.016759034195340194, 0.016536757425405946, 0.005218757897654136, 0.020826379370365244, 0.01615755934743701, 0.01425044545938925, 0.02126462892137626, 0.017261390362001694, 0.1069274895070732, 0.11018982083398254, 0.10264638852360619, 0.12398374406306034, 0.10663755958571941, 0.10342912159164275, 0.1020787396878915, 0.12001454740330342, 0.10481626016194856, 0.09219442009736123, 0.09796525009870038, 0.08772830277118904, 0.09425546072221658, 0.09700699661564849, 0.08063547018118666, 0.09422079678079609, 0.08251249960413132, 0.08827767550234422, 0.9546310733695411, 0.9629984905570403, 0.956725710497144, 0.9501024346141927, 0.9215555407759272, 0.953597962563107, 0.9608087958204022, 0.9615060097751456, 0.9602084628073887, 0.2218000984680727, 0.2195239573607073, 0.21463031984190362, 0.22325499195001253, 0.21631270325720442, 0.23368272766979203, 0.21481146197411627, 0.23970972041274807, 0.2266280261493322, 0.30923839682770915, 0.31115806237478927, 0.31286779550056965, 0.3058200425837424, 0.26426704346916496, 0.2739284555734708, 0.3289035782603441, 0.3275761820715718, 0.28748396722518776, 0.11687343691658991, 0.11985142824443573, 0.12191207548550809, 0.12628321803707898, 0.11812454149237961, 0.10931393133992373, 0.1160806703344115, 0.11646872490705718, 0.12046850897707007, 0.11734958819391872, 0.10402888772158292, 0.11023689254719393, 0.12084548689912411, 0.11877571901839745, 0.11482642414661004, 0.1334565301747359, 0.11221969333840753, 0.11582914948239864, 0.011331644617726844, 0.008107712907915454, 0.0036070586242691327, 0.004305013000149294, 9.999999999998899e-05, 0.004857650360001187, 0.007139550265830241, 0.003870606955140077, 0.00042902921962650886, 0.08909557344455532, 0.09381259632238836, 0.052026017134322866, 0.061353122626416234, 0.039519294297846175, 0.03939347510244773, 0.08522542399919109, 0.05939433998839305, 0.061992392703694166, 0.0013764413075295634, 0.0011362981450896426, 9.999999999998899e-05, 0.00023503493831378286, 9.999999999998899e-05, 0.0005698929105220074, 9.999999999998899e-05, 0.0006637357328578286, 9.999999999998899e-05, 0.06652169442200828, 0.05674030901689597, 0.06182085147163796, 0.0708699466926449, 0.08493185480372067, 0.07461426134287519, 0.05784917844424198, 0.07203233913988183, 0.062334546854975637, 0.33500408220153044, 0.3362475023209226, 0.3455624784929532, 0.3382906776474399, 0.33481870953675164, 0.34946241383488574, 0.33460611291697406, 0.3308419226988042, 0.3484307286088759, 0.09603598662001245, 0.09915599282324838, 0.0956601455711219, 0.10148938605506974, 0.10109832447355616, 0.10732613036783245, 0.10087335897849947, 0.10833238191206618, 0.11077937600602294, 0.15681659682731586, 0.15805640620135453, 0.18408545821551048, 0.15145306337610787, 0.17057156231126647, 0.16133684594733555, 0.18187927115560132, 0.1659997197707671, 0.172449882766315, 0.24865888606395414, 0.2538258040010647, 0.26313448725483557, 0.2603044209618217, 0.24717662473551683, 0.2506027389205502, 0.25353427825101893, 0.25965493647637716, 0.2644776890204803, 0.1871048415244264, 0.18602431831274635, 0.18896137324171602, 0.19423460697086414, 0.19820021009037525, 0.1879980754224725, 0.19097783315396788, 0.19307507591121353, 0.19266097987856978, 0.1843651627900822, 0.2392131342027899, 0.2003279446447085, 0.208892952757182, 0.18864994973691362, 0.18701828112568764, 0.19637719192840764, 0.19422366117858458, 0.20048279418765902, 0.204740437705633, 0.2051360147669674, 0.20014051967154278, 0.20551565623708168, 0.2089613064239224, 0.21321767468041541, 0.1958572516232412, 0.20416902105833523, 0.2076302726433853, 0.427041162775861, 0.44252658766178465, 0.16932228838421448, 0.46783387233618323, 0.4793573399883112, 0.45069660392996247, 0.4548141546534218, 0.36620071147577626, 0.45536019874119404, 0.1953448245701651, 0.19304277213010035, 0.34259944923231656, 0.30540774474236154, 0.19805221625147407, 0.19826150238833584, 0.20505128569634012, 0.15721103454139196, 0.20681743614774573, 0.1799910156453448, 0.19448136934579174, 0.1926125552049751, 0.18910735915593413, 0.1854368536956449, 0.1908342784323932, 0.1797110011572386, 0.16987479628161783, 0.19152887123911277, 0.0780494437636784, 0.08069837174883066, 0.07922336704696809, 0.08461796337003868, 0.07783248046962776, 0.09056026096608982, 0.08443500974070817, 0.07755851064423425, 0.07616594274241106]}, "mutation_prompt": null}
{"id": "ab2e5eda-3b59-41b8-bd5d-09fe67f22c49", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (0.5 + 0.5 * ((self.budget - evaluations) / self.budget))  # Adjusted scaling\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutation_step = adaptive_f * (x1 - x2 + noise)  # Introducing variable step size\n                mutant = np.clip(x0 + mutation_step, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive differential weight scaling and variable step size in mutation to enhance convergence speed.", "configspace": "", "generation": 39, "fitness": 0.1961431500126162, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.35806690499875726, 0.36193517357852034, 0.3532543666906831, 0.3470277485263574, 0.3579026238690135, 0.3654039392444963, 0.3631869629968272, 0.35206411637236257, 0.362518210309696, 0.014443261780565209, 0.009060133766329304, 0.018102142430717505, 0.018932342838604566, 0.01611978804761749, 0.029036390020538927, 0.01804526905346615, 0.01136776827947672, 0.021132510292071305, 0.09463446646296814, 0.09372175206673727, 0.10332854529753788, 0.09925194426285366, 0.10456589767631652, 0.10257253195201288, 0.10170629462137892, 0.09083025732232364, 0.10210719418440262, 0.09066445407663848, 0.08251872331592691, 0.08061468470842847, 0.07893808348314957, 0.0784606583114581, 0.08338841365140781, 0.08131437822874743, 0.08162088259147382, 0.08294489196181853, 0.954656103219782, 0.9628647385523773, 0.9570180249849937, 0.9571533841389225, 0.9097260633437061, 0.941184796551034, 0.9605308860976793, 0.9614875359392454, 0.9599822526785295, 0.22094405855474542, 0.2133373242971509, 0.22170966896898137, 0.2262942399224641, 0.22109828111187213, 0.22116919175534266, 0.21304243360517683, 0.23664760635117776, 0.2143129582557347, 0.27990017305367865, 0.28289476232836364, 0.31009550252925, 0.2596520819472795, 0.3411004189832626, 0.28278555321327126, 0.27030684530495463, 0.27871955546498217, 0.2681422908967869, 0.11563411240710897, 0.12393185307457555, 0.12895629271222986, 0.11541529983545329, 0.11498021916254697, 0.11218709337639521, 0.12506404058754939, 0.12380706879294123, 0.11804202105875106, 0.10298633341486363, 0.11850879626663735, 0.12763316928443325, 0.12572480338471415, 0.1069662350169659, 0.11793916574776064, 0.11750992250302938, 0.12149797968192055, 0.1120854203136421, 0.0060649494782312185, 0.005007585362673317, 0.015176263872970552, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012452555966947498, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007838017711313539, 0.0862394687339123, 0.07924540669285907, 0.05116800999750981, 0.040884065429576566, 0.07738816194283826, 0.03352166542494539, 0.08253988429880732, 0.0368415197057439, 0.045057179537308145, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019509657908600708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05545250739854235, 0.057810371889690404, 0.06076331615560426, 0.061186722749544065, 0.08253052769778169, 0.064525424376222, 0.0655951610707951, 0.06447280741927319, 0.0736025004826224, 0.3394443651427572, 0.3383781544120442, 0.3478794570106982, 0.3339066862758161, 0.3459712997961416, 0.3634779580104722, 0.34056596897867064, 0.33585231392449033, 0.34812499466695923, 0.08997030109669069, 0.08115151384882846, 0.08619766553185548, 0.09401053426058747, 0.07808830251647048, 0.0914790440997083, 0.10554342888335655, 0.08414618138214225, 0.0875139793908678, 0.19225658637383491, 0.2074275349592003, 0.14398154666740048, 0.15364156144243912, 0.17195713513904376, 0.14568769503400636, 0.14889638701083407, 0.14938047370230711, 0.12351722009035715, 0.2551810869600888, 0.25578814987336196, 0.251890261884926, 0.25590079934370147, 0.24779333665312042, 0.2479017357604908, 0.24859319445821715, 0.2506807470607715, 0.24928166540608432, 0.17862100676902226, 0.18382410147462602, 0.19243509309947493, 0.18965676025662492, 0.17592027558728118, 0.1980883644894078, 0.19278049158708266, 0.19762092607869985, 0.18789790766711545, 0.2219201261392184, 0.204523603611792, 0.19064325746711264, 0.20697193618864984, 0.20080180430893602, 0.20630325687870743, 0.18282071059019522, 0.19711563375703467, 0.18437810209573324, 0.1877539578203189, 0.19339974210571964, 0.18377753334037128, 0.1856628371038782, 0.1826771529056147, 0.20986868052390317, 0.20102924702195235, 0.2038706567166284, 0.18353735633796864, 0.38766501068383286, 0.4499044639846428, 0.16717761686230626, 0.4806494057022628, 0.45821608176517514, 0.477283749812184, 0.3710578284238947, 0.38976071957483116, 0.478924052149416, 0.16777242634204637, 0.31781911720008515, 0.1632368802070947, 0.1832154132958379, 0.22158437743961412, 0.20145762267878198, 0.20561241168852784, 0.3857639455919619, 0.20453612026275736, 0.1890781399005229, 0.19079801334618052, 0.19125477135228097, 0.19669136747262084, 0.18243366599036448, 0.20078009733817648, 0.18541736606821135, 0.18177374834940008, 0.17925673620402593, 0.08486277126437325, 0.07594990473353869, 0.08271095151007901, 0.07504312783694478, 0.08320091607169566, 0.07258458141094504, 0.09289080962468466, 0.0854217185227355, 0.07486676348294274]}, "mutation_prompt": null}
{"id": "5a73afeb-256c-4096-9c84-53fcde8da9e3", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def stochastic_mutation_scaling(self, evaluations):\n        return self.f * np.random.uniform(0.8, 1.2) * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.stochastic_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations % (self.population_size // 2) == 0:\n                diversity = np.std(population, axis=0)\n                if np.any(diversity < 0.1):\n                    population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                    fitness = np.array([func(ind) for ind in population])\n                    evaluations += self.population_size\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Incorporates stochastic adaptive scaling and dynamic diversity preservation to enhance convergence robustness and efficiency.", "configspace": "", "generation": 40, "fitness": 0.18918915032421357, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.3441607381284346, 0.3409070366222876, 0.3184448799252433, 0.34141053105095287, 0.3406060991626827, 0.3432998309394224, 0.3355198764657865, 0.3342222502105009, 0.3371339174769884, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019799373220587, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09094862218926736, 0.10115001313247685, 0.10643644090203475, 0.0955934722561731, 0.11086255943852885, 0.10337215852654302, 0.10175566542814285, 0.10677232863761654, 0.10542134611576126, 0.08914529137023641, 0.09029062596231274, 0.10041830612518066, 0.08611997805099725, 0.09491338362162538, 0.0786704639841973, 0.08185440077207096, 0.08911439706918678, 0.09378072908344492, 0.8131892529680581, 0.897009260266878, 0.966276020645784, 0.9791836007846391, 0.9125243862279074, 0.9250753733465561, 0.9357475348364436, 0.913061030012871, 0.9690687247369714, 0.19869842105992852, 0.22473700916376083, 0.21560777103322193, 0.19465977312568117, 0.2001015256858124, 0.21673904300723024, 0.19355597946394254, 0.19454646342917736, 0.21207629650778703, 0.2684505708325712, 0.2686988441131045, 0.25774069202021843, 0.26845931733237827, 0.2650194634286629, 0.2617021306349032, 0.24068362210769123, 0.24995859876531357, 0.24449017433734488, 0.11537480812700773, 0.11651261492048548, 0.11108608308330403, 0.12388107236291634, 0.11782105549066946, 0.11949719497414157, 0.11756632995006566, 0.12458188476233423, 0.11262160267810195, 0.10630036106527063, 0.10279083625354157, 0.11089634359387313, 0.12858548853024365, 0.12334037508466222, 0.13403397130966166, 0.12536297693384846, 0.1016774265001954, 0.11742737460901209, 0.0003418218587969424, 0.0032200658857794995, 0.00266104809914236, 0.002627385814144123, 0.00016675279835887125, 0.000874792544787284, 0.0013501838853761106, 0.005999289756004833, 0.0025359479693163323, 0.0773924893272333, 0.09488645160137532, 0.07650810174629075, 0.10489505756080308, 0.08124962773232836, 0.04336712475506754, 0.07132721045968393, 0.08144782829847486, 0.04851446270662707, 0.0008994758778564371, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031190699144512113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05723375272258813, 0.05859470596579941, 0.053707747226108715, 0.05395324821505998, 0.058070217092693, 0.0727271411178323, 0.06316107578531283, 0.06321077660645491, 0.055414471027775525, 0.3350621555979104, 0.3262958528077744, 0.3379208384858323, 0.3338724343102959, 0.34569559195184907, 0.3161633616460259, 0.33061305909385386, 0.34071340666705696, 0.3174200732367467, 0.09401112797368205, 0.09290399062752297, 0.09258455674658694, 0.10129915115015298, 0.09582766523983732, 0.08780119185068558, 0.09525294649672955, 0.09691713319285411, 0.10528878463282676, 0.1618777464978639, 0.14355785730568127, 0.14825439924852013, 0.15833049039469171, 0.1447501917604197, 0.17103500705587482, 0.13946017104496733, 0.15931520424382073, 0.15026751473923272, 0.24590412565725606, 0.24213686168689763, 0.23630007308359358, 0.23666213755417242, 0.2508491235095043, 0.24415942819023462, 0.24705385513764377, 0.24041859093071283, 0.23962719159107537, 0.18954975674759755, 0.19821271650800654, 0.1813752643874592, 0.18154477923859969, 0.18721214345843895, 0.18117135712379295, 0.18756340999015397, 0.18916911350037735, 0.1906189709591002, 0.19781503985597115, 0.1921475442977425, 0.19480803678712366, 0.20903048773592858, 0.1971514268101635, 0.20597724508690185, 0.18726316103555396, 0.18713381196297707, 0.20075827765383258, 0.1986668696340833, 0.20249668187392622, 0.20579686071077052, 0.1918902028766326, 0.205929640553964, 0.20507453342240156, 0.19268736668079378, 0.1854294575306974, 0.17942720110566568, 0.20847815425010197, 0.4253079709832699, 0.2606655737287251, 0.36016378388084314, 0.3425584893382396, 0.381354166979577, 0.42073070762855147, 0.3745708554435523, 0.16295256959603344, 0.18891391659552914, 0.1949678405898051, 0.21140584042304178, 0.3045206348831333, 0.17864256405260115, 0.28721768062431574, 0.2756888660590061, 0.4223577893828486, 0.20348776397358237, 0.17490560518052867, 0.185898921343973, 0.21001770674283304, 0.18936191027798155, 0.18876053880524457, 0.18444495202340483, 0.19006116009655238, 0.18335259334711318, 0.19392341735404783, 0.07932942696777012, 0.08571560516027077, 0.0850197963773438, 0.07993273109186227, 0.07680405358054176, 0.0884076104667838, 0.07682407904491229, 0.07784104277144466, 0.07989138061287993]}, "mutation_prompt": null}
{"id": "e9d637d3-dd97-409d-b23c-5216c0dec62d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def adaptive_population_size(self, evaluations):\n        return max(10, int(self.population_size * (1 - evaluations / self.budget)))\n\n    def opposition_based_learning(self, individual):\n        return self.lower_bound + self.upper_bound - individual\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                opp_trial = self.opposition_based_learning(trial)\n                opp_trial_fitness = func(opp_trial)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if opp_trial_fitness < trial_fitness:\n                    trial = opp_trial\n                    trial_fitness = opp_trial_fitness\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population_size = self.adaptive_population_size(evaluations)\n            population = np.resize(population, (self.population_size, self.dim))\n            fitness = np.resize(fitness, self.population_size)\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces probabilistic opposition-based learning and adaptive population size to improve exploration and exploitation balance.", "configspace": "", "generation": 41, "fitness": 0.16620699614282894, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.28718436800233005, 0.28121433645023275, 0.27202678371137967, 0.29312935585082855, 0.3207779259926197, 0.2778153144202655, 0.2802702749890561, 0.30429354283056886, 0.28425023066168476, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08016092696269805, 0.0792705773313892, 0.07357904467824516, 0.07149828894593102, 0.07771368605391704, 0.07931894807049356, 0.06991688243149452, 0.0883020540838999, 0.07589788172113854, 0.06063774344539141, 0.06763395172802378, 0.06455505886424528, 0.05832084780898217, 0.07546163540404027, 0.06135688679871487, 0.06510601886616618, 0.05751136829469905, 0.06538503221674397, 0.9302225122927037, 0.9396320476840468, 0.9331646867324825, 0.9398858259587536, 0.9154757991306678, 0.9037970732861285, 0.9507326030752461, 0.9164607246809141, 0.9079404771278328, 0.17683136351991557, 0.1681122555486665, 0.16628273393927062, 0.17107210283843965, 0.1788764315067739, 0.17787590297517364, 0.176962867542514, 0.15725395207617365, 0.16410308270522145, 0.23414672690707894, 0.20299815769034935, 0.19812805176296555, 0.1953427537684702, 0.20841968035322522, 0.20569307069191556, 0.19748591476213384, 0.22325286788058052, 0.20430708134281317, 0.08964063240684905, 0.09596568605990718, 0.1114787946216731, 0.08917223075208092, 0.10382426866140482, 0.09243221448460792, 0.08541458104344879, 0.10083516050130148, 0.08336157949001699, 0.09366088499327307, 0.09248166481264575, 0.05528126255776877, 0.09802269064144564, 0.1124085956232237, 0.10253462199268326, 0.092624088451291, 0.08960067020901119, 0.09281021427475511, 0.0010280966481286402, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002123838337896311, 0.0016531138178159654, 9.999999999998899e-05, 9.999999999998899e-05, 0.05133120284181947, 0.0804933444355751, 0.05249345554922147, 0.060721270006624195, 0.0351963823603626, 0.04947224900640124, 0.05941400489255888, 0.057116130587817504, 0.038171618620975845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02733613028012838, 0.03350630710778946, 0.03091096162234408, 0.04047301374472845, 0.03628172395770812, 0.03989217937258416, 0.027936394738400705, 0.03203774704775553, 0.03954471020088601, 0.28047828377586115, 0.28875452333705376, 0.29512655816815614, 0.27820378693944037, 0.3075998257507706, 0.2869490482090937, 0.28888523720913173, 0.29795076227209405, 0.2893926269258693, 0.0760017962615912, 0.08590122240152365, 0.07365271035149112, 0.07533435459569193, 0.0924710734641696, 0.06467324595172008, 0.09918912020469706, 0.07086404368977728, 0.06851795426255503, 0.13223899199578915, 0.14368023288409715, 0.12548043595134262, 0.1469386155775082, 0.1377798577791709, 0.1662876460311833, 0.13941803422417998, 0.11383875305446456, 0.13095640546779685, 0.21044995400716615, 0.21048718388735188, 0.21635431525372262, 0.2078561937927671, 0.21923325324979048, 0.22119669226439553, 0.2141051084693425, 0.2303513948593764, 0.20896595993681988, 0.15907320086755938, 0.1394964178719229, 0.15663973237246354, 0.16514223875759015, 0.16178110890294284, 0.15141982535397547, 0.15922884644840773, 0.1593208410137832, 0.15879711375070582, 0.18895255033568636, 0.17890530103054592, 0.18716520248905233, 0.1885819688228818, 0.20307158292589522, 0.1964144823429128, 0.19193553165625832, 0.20025661468884404, 0.1955392618539049, 0.1811287270912475, 0.16133252757136796, 0.16094466333239232, 0.17201090709195144, 0.16397393958817852, 0.1710753248774125, 0.16900183892972231, 0.15752096782176161, 0.1725099538786099, 0.1793629067839656, 0.33103312409274355, 0.250479345522023, 0.3625972157322319, 0.36660303544329265, 0.3536522803601384, 0.16308278021321243, 0.242421511825769, 0.27887137071677814, 0.18298633083937854, 0.17995515687872465, 0.18678718945368022, 0.1768817421386637, 0.1539361153077914, 0.24947692160116486, 0.19605600288213332, 0.19174142529488403, 0.27252734547243285, 0.18852046680964973, 0.20328874596689994, 0.1727872849831399, 0.17805777893643648, 0.20725416641329464, 0.19547248150150065, 0.18887470779173732, 0.1839643125178715, 0.18728802447356752, 0.06890533641861107, 0.07282124730107498, 0.06984987011306099, 0.07809670009514191, 0.06995478671287803, 0.07218201278219094, 0.06953796622825426, 0.06218610680067016, 0.07021351967469813]}, "mutation_prompt": null}
{"id": "c9a89aa3-0b59-4a6d-b812-8284d7d2b8de", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)  # Adjusted value\n\n    def adaptive_noise_level(self, evaluations):  # New adaptive noise level function\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and adaptive noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)  # Use adaptive noise level\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive scaling to noise level in mutation and refines crossover probability to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.359739088573798, 0.3620098272319713, 0.36948791215332333, 0.3703083654160523, 0.3682666408890969, 0.37848147324406645, 0.35241906130894884, 0.3505464347604067, 0.36498909100050014, 0.02050923126473847, 0.015271138619847302, 0.028205217215198752, 0.018379490609065074, 0.013310135153588587, 0.015116261031314804, 0.020895686367720212, 0.0316727134945366, 0.014232196969377608, 0.11685721739451183, 0.11171917709657042, 0.10389053907266044, 0.0944035445790089, 0.1114013612160899, 0.11309456134976648, 0.10521790852758417, 0.118631384946977, 0.11441530097319752, 0.09678889013126968, 0.09014920909410162, 0.08792838123969382, 0.10585561932291443, 0.08782375733152259, 0.09069113901740888, 0.07674207376390296, 0.08679012078070913, 0.0888306598834373, 0.9546419259013592, 0.9629315101577257, 0.9566862822672635, 0.9571568341405223, 0.909908824322838, 0.941247138364632, 0.9605227398051346, 0.9614971279285398, 0.9600691727579902, 0.2354860775946621, 0.2205200026836156, 0.21993120459323945, 0.22561689512492333, 0.22436179521667654, 0.2307396216565153, 0.21698091625876004, 0.22732273104980993, 0.22453241906895605, 0.29175743709122426, 0.2796855636716018, 0.26114455635534106, 0.2626221110838889, 0.31633633321224486, 0.3263620185358471, 0.28429723167473986, 0.2566656254449122, 0.30394627283006725, 0.11629077305163937, 0.1260128777672237, 0.11321350700392663, 0.11906614895316614, 0.1233671340498449, 0.13273080180290764, 0.11642715908288415, 0.13001428423235561, 0.11458143161745615, 0.10845565242706234, 0.1150823969636936, 0.10196121864750185, 0.12469455504979632, 0.12073219062161755, 0.1189781435890751, 0.12229024613110873, 0.11456359143829653, 0.11343886455572882, 0.00022266025201822526, 0.009297353427421107, 0.00042768306513774057, 0.030307341104247598, 0.0070937811592736155, 0.009214869600020159, 0.0006119029791973318, 0.00011195672782704502, 9.999999999998899e-05, 0.06553252253495734, 0.08842054859820714, 0.06327458791101248, 0.04737857922799249, 0.10482134613728744, 0.036790775035358436, 0.08081067885604931, 0.07569539223957578, 0.07118220350084503, 0.0014467953740257, 0.0042313265190928595, 0.0001599705338538593, 0.0013399686959488788, 0.0001054753092808447, 0.0002491663530809207, 0.0007360484277365575, 0.00022560610839861273, 0.0012820301910138054, 0.06634199299409704, 0.06273767453903967, 0.05629125676495894, 0.06757921437305181, 0.07989974623899576, 0.06494914266842555, 0.049541680343287986, 0.05841425359052532, 0.06479615230313596, 0.346315476100312, 0.356454956388478, 0.3307186085845891, 0.3331156579244948, 0.3365534123914038, 0.35629169016113527, 0.3434939917082296, 0.3495873224468399, 0.3456704076829479, 0.09418460581602028, 0.10820393474162504, 0.0971382790334312, 0.0952211615979004, 0.10798097566321796, 0.09852071305709109, 0.09225818991509227, 0.098152202998678, 0.0921852849474617, 0.19975780077492689, 0.1651953638251421, 0.17055975147261215, 0.19981494623826157, 0.16219380460533106, 0.17077187138181638, 0.16497105672676682, 0.15585763454362345, 0.14839282520247088, 0.25052688239143284, 0.24983043585734077, 0.24919869715023635, 0.2492127291802534, 0.25139051259765943, 0.26572706296575366, 0.2580076072186197, 0.2580803330819319, 0.2509908198917369, 0.20068027735508798, 0.19577290469452768, 0.18859666606314662, 0.1810787663848179, 0.19105545134469837, 0.1913544914484061, 0.19652321569077102, 0.19640036324442145, 0.1957518825689829, 0.19338424419817235, 0.1983135368826352, 0.19194983851266467, 0.19416447027759476, 0.18764125131165488, 0.19386817273945756, 0.18720203746638486, 0.2060689285902073, 0.20585988756061002, 0.20813326277542887, 0.19535783490019598, 0.20545864372475275, 0.19946442081085614, 0.20903349765836232, 0.2060605730841516, 0.1965397786257067, 0.20067855030183057, 0.2032928297494424, 0.4577670620435975, 0.4470699619189289, 0.1694949500353301, 0.45495140072615625, 0.33780348566527785, 0.47372470131556943, 0.4301123124890984, 0.46302409100734865, 0.4819340792874912, 0.1681906985876247, 0.19715002248772728, 0.340823941907643, 0.38239897849279636, 0.19590552425029395, 0.19902421636617396, 0.20504534602559632, 0.3095391427335177, 0.20664946050544364, 0.18147841722917224, 0.19322071087274906, 0.1790936748072134, 0.1765207410813704, 0.18029831141448704, 0.1758828760857506, 0.18597034653750721, 0.19207393469168188, 0.1895103965505892, 0.08092192250661734, 0.08299162201632915, 0.07695691515288106, 0.08463030788006998, 0.07611854640855986, 0.07310015073707932, 0.07606216918609565, 0.08583722323692733, 0.08724814823337601]}, "mutation_prompt": null}
{"id": "6f9ae15e-5483-46c5-b9fe-66bbdd39247d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)  # Adjusted value\n\n    def adaptive_noise_level(self, evaluations):  # New adaptive noise level function\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and adaptive noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)  # Use adaptive noise level\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive scaling to noise level in mutation and refines crossover probability to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.359739088573798, 0.3620098272319713, 0.36948791215332333, 0.3703083654160523, 0.3682666408890969, 0.37848147324406645, 0.35241906130894884, 0.3505464347604067, 0.36498909100050014, 0.02050923126473847, 0.015271138619847302, 0.028205217215198752, 0.018379490609065074, 0.013310135153588587, 0.015116261031314804, 0.020895686367720212, 0.0316727134945366, 0.014232196969377608, 0.11685721739451183, 0.11171917709657042, 0.10389053907266044, 0.0944035445790089, 0.1114013612160899, 0.11309456134976648, 0.10521790852758417, 0.118631384946977, 0.11441530097319752, 0.09678889013126968, 0.09014920909410162, 0.08792838123969382, 0.10585561932291443, 0.08782375733152259, 0.09069113901740888, 0.07674207376390296, 0.08679012078070913, 0.0888306598834373, 0.9546419259013592, 0.9629315101577257, 0.9566862822672635, 0.9571568341405223, 0.909908824322838, 0.941247138364632, 0.9605227398051346, 0.9614971279285398, 0.9600691727579902, 0.2354860775946621, 0.2205200026836156, 0.21993120459323945, 0.22561689512492333, 0.22436179521667654, 0.2307396216565153, 0.21698091625876004, 0.22732273104980993, 0.22453241906895605, 0.29175743709122426, 0.2796855636716018, 0.26114455635534106, 0.2626221110838889, 0.31633633321224486, 0.3263620185358471, 0.28429723167473986, 0.2566656254449122, 0.30394627283006725, 0.11629077305163937, 0.1260128777672237, 0.11321350700392663, 0.11906614895316614, 0.1233671340498449, 0.13273080180290764, 0.11642715908288415, 0.13001428423235561, 0.11458143161745615, 0.10845565242706234, 0.1150823969636936, 0.10196121864750185, 0.12469455504979632, 0.12073219062161755, 0.1189781435890751, 0.12229024613110873, 0.11456359143829653, 0.11343886455572882, 0.00022266025201822526, 0.009297353427421107, 0.00042768306513774057, 0.030307341104247598, 0.0070937811592736155, 0.009214869600020159, 0.0006119029791973318, 0.00011195672782704502, 9.999999999998899e-05, 0.06553252253495734, 0.08842054859820714, 0.06327458791101248, 0.04737857922799249, 0.10482134613728744, 0.036790775035358436, 0.08081067885604931, 0.07569539223957578, 0.07118220350084503, 0.0014467953740257, 0.0042313265190928595, 0.0001599705338538593, 0.0013399686959488788, 0.0001054753092808447, 0.0002491663530809207, 0.0007360484277365575, 0.00022560610839861273, 0.0012820301910138054, 0.06634199299409704, 0.06273767453903967, 0.05629125676495894, 0.06757921437305181, 0.07989974623899576, 0.06494914266842555, 0.049541680343287986, 0.05841425359052532, 0.06479615230313596, 0.346315476100312, 0.356454956388478, 0.3307186085845891, 0.3331156579244948, 0.3365534123914038, 0.35629169016113527, 0.3434939917082296, 0.3495873224468399, 0.3456704076829479, 0.09418460581602028, 0.10820393474162504, 0.0971382790334312, 0.0952211615979004, 0.10798097566321796, 0.09852071305709109, 0.09225818991509227, 0.098152202998678, 0.0921852849474617, 0.19975780077492689, 0.1651953638251421, 0.17055975147261215, 0.19981494623826157, 0.16219380460533106, 0.17077187138181638, 0.16497105672676682, 0.15585763454362345, 0.14839282520247088, 0.25052688239143284, 0.24983043585734077, 0.24919869715023635, 0.2492127291802534, 0.25139051259765943, 0.26572706296575366, 0.2580076072186197, 0.2580803330819319, 0.2509908198917369, 0.20068027735508798, 0.19577290469452768, 0.18859666606314662, 0.1810787663848179, 0.19105545134469837, 0.1913544914484061, 0.19652321569077102, 0.19640036324442145, 0.1957518825689829, 0.19338424419817235, 0.1983135368826352, 0.19194983851266467, 0.19416447027759476, 0.18764125131165488, 0.19386817273945756, 0.18720203746638486, 0.2060689285902073, 0.20585988756061002, 0.20813326277542887, 0.19535783490019598, 0.20545864372475275, 0.19946442081085614, 0.20903349765836232, 0.2060605730841516, 0.1965397786257067, 0.20067855030183057, 0.2032928297494424, 0.4577670620435975, 0.4470699619189289, 0.1694949500353301, 0.45495140072615625, 0.33780348566527785, 0.47372470131556943, 0.4301123124890984, 0.46302409100734865, 0.4819340792874912, 0.1681906985876247, 0.19715002248772728, 0.340823941907643, 0.38239897849279636, 0.19590552425029395, 0.19902421636617396, 0.20504534602559632, 0.3095391427335177, 0.20664946050544364, 0.18147841722917224, 0.19322071087274906, 0.1790936748072134, 0.1765207410813704, 0.18029831141448704, 0.1758828760857506, 0.18597034653750721, 0.19207393469168188, 0.1895103965505892, 0.08092192250661734, 0.08299162201632915, 0.07695691515288106, 0.08463030788006998, 0.07611854640855986, 0.07310015073707932, 0.07606216918609565, 0.08583722323692733, 0.08724814823337601]}, "mutation_prompt": null}
{"id": "93427a0a-bc67-4117-874b-65ad1fd8a732", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations):\n        return self.f * (1 - (evaluations / self.budget))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)  # Adjusted value\n\n    def adaptive_noise_level(self, evaluations):  # New adaptive noise level function\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Mutation with adaptive scaling and adaptive noise\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                adaptive_f = self.adaptive_mutation_scaling(evaluations)\n                noise_level = self.adaptive_noise_level(evaluations)  # Use adaptive noise level\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Enhanced Levy flight with adaptive step size\n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                # Selection with elitism\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces adaptive scaling to noise level in mutation and refines crossover probability to improve convergence.", "configspace": "", "generation": 37, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.359739088573798, 0.3620098272319713, 0.36948791215332333, 0.3703083654160523, 0.3682666408890969, 0.37848147324406645, 0.35241906130894884, 0.3505464347604067, 0.36498909100050014, 0.02050923126473847, 0.015271138619847302, 0.028205217215198752, 0.018379490609065074, 0.013310135153588587, 0.015116261031314804, 0.020895686367720212, 0.0316727134945366, 0.014232196969377608, 0.11685721739451183, 0.11171917709657042, 0.10389053907266044, 0.0944035445790089, 0.1114013612160899, 0.11309456134976648, 0.10521790852758417, 0.118631384946977, 0.11441530097319752, 0.09678889013126968, 0.09014920909410162, 0.08792838123969382, 0.10585561932291443, 0.08782375733152259, 0.09069113901740888, 0.07674207376390296, 0.08679012078070913, 0.0888306598834373, 0.9546419259013592, 0.9629315101577257, 0.9566862822672635, 0.9571568341405223, 0.909908824322838, 0.941247138364632, 0.9605227398051346, 0.9614971279285398, 0.9600691727579902, 0.2354860775946621, 0.2205200026836156, 0.21993120459323945, 0.22561689512492333, 0.22436179521667654, 0.2307396216565153, 0.21698091625876004, 0.22732273104980993, 0.22453241906895605, 0.29175743709122426, 0.2796855636716018, 0.26114455635534106, 0.2626221110838889, 0.31633633321224486, 0.3263620185358471, 0.28429723167473986, 0.2566656254449122, 0.30394627283006725, 0.11629077305163937, 0.1260128777672237, 0.11321350700392663, 0.11906614895316614, 0.1233671340498449, 0.13273080180290764, 0.11642715908288415, 0.13001428423235561, 0.11458143161745615, 0.10845565242706234, 0.1150823969636936, 0.10196121864750185, 0.12469455504979632, 0.12073219062161755, 0.1189781435890751, 0.12229024613110873, 0.11456359143829653, 0.11343886455572882, 0.00022266025201822526, 0.009297353427421107, 0.00042768306513774057, 0.030307341104247598, 0.0070937811592736155, 0.009214869600020159, 0.0006119029791973318, 0.00011195672782704502, 9.999999999998899e-05, 0.06553252253495734, 0.08842054859820714, 0.06327458791101248, 0.04737857922799249, 0.10482134613728744, 0.036790775035358436, 0.08081067885604931, 0.07569539223957578, 0.07118220350084503, 0.0014467953740257, 0.0042313265190928595, 0.0001599705338538593, 0.0013399686959488788, 0.0001054753092808447, 0.0002491663530809207, 0.0007360484277365575, 0.00022560610839861273, 0.0012820301910138054, 0.06634199299409704, 0.06273767453903967, 0.05629125676495894, 0.06757921437305181, 0.07989974623899576, 0.06494914266842555, 0.049541680343287986, 0.05841425359052532, 0.06479615230313596, 0.346315476100312, 0.356454956388478, 0.3307186085845891, 0.3331156579244948, 0.3365534123914038, 0.35629169016113527, 0.3434939917082296, 0.3495873224468399, 0.3456704076829479, 0.09418460581602028, 0.10820393474162504, 0.0971382790334312, 0.0952211615979004, 0.10798097566321796, 0.09852071305709109, 0.09225818991509227, 0.098152202998678, 0.0921852849474617, 0.19975780077492689, 0.1651953638251421, 0.17055975147261215, 0.19981494623826157, 0.16219380460533106, 0.17077187138181638, 0.16497105672676682, 0.15585763454362345, 0.14839282520247088, 0.25052688239143284, 0.24983043585734077, 0.24919869715023635, 0.2492127291802534, 0.25139051259765943, 0.26572706296575366, 0.2580076072186197, 0.2580803330819319, 0.2509908198917369, 0.20068027735508798, 0.19577290469452768, 0.18859666606314662, 0.1810787663848179, 0.19105545134469837, 0.1913544914484061, 0.19652321569077102, 0.19640036324442145, 0.1957518825689829, 0.19338424419817235, 0.1983135368826352, 0.19194983851266467, 0.19416447027759476, 0.18764125131165488, 0.19386817273945756, 0.18720203746638486, 0.2060689285902073, 0.20585988756061002, 0.20813326277542887, 0.19535783490019598, 0.20545864372475275, 0.19946442081085614, 0.20903349765836232, 0.2060605730841516, 0.1965397786257067, 0.20067855030183057, 0.2032928297494424, 0.4577670620435975, 0.4470699619189289, 0.1694949500353301, 0.45495140072615625, 0.33780348566527785, 0.47372470131556943, 0.4301123124890984, 0.46302409100734865, 0.4819340792874912, 0.1681906985876247, 0.19715002248772728, 0.340823941907643, 0.38239897849279636, 0.19590552425029395, 0.19902421636617396, 0.20504534602559632, 0.3095391427335177, 0.20664946050544364, 0.18147841722917224, 0.19322071087274906, 0.1790936748072134, 0.1765207410813704, 0.18029831141448704, 0.1758828760857506, 0.18597034653750721, 0.19207393469168188, 0.1895103965505892, 0.08092192250661734, 0.08299162201632915, 0.07695691515288106, 0.08463030788006998, 0.07611854640855986, 0.07310015073707932, 0.07606216918609565, 0.08583722323692733, 0.08724814823337601]}, "mutation_prompt": null}
{"id": "c1d61369-acc8-476c-921e-132c936e3e90", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 45, "fitness": 0.20094152995202313, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "e0eb7852-fc54-434c-88dc-13378b1432bb", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "f1986b47-c382-4be2-a1c4-e543a7ac50ac", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "8b8135ad-11b0-41e0-9106-b831d31fd00e", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        chaotic_factor = 0.7 * (1 - np.abs(1 - 2 * (evaluations / self.budget)))\n        return self.f * (1 - (evaluations / self.budget)) * temperature * chaotic_factor\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Implements a chaotic map-based dynamic adjustment for mutation scaling, enhancing exploration efficiency.", "configspace": "", "generation": 47, "fitness": 0.19830721430551457, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.382473892966652, 0.364838214312175, 0.37594685186707266, 0.36245715258229505, 0.353472805059897, 0.36073510147706567, 0.36467351092913314, 0.3843999588732967, 0.35927190002337717, 0.01592052293883739, 0.013228035997942755, 0.008176289938886527, 0.022768110127442065, 0.027748750167016056, 0.017645962990361697, 9.999999999998899e-05, 0.021505262573071504, 0.0036570388322841874, 0.11965601382566982, 0.11114746637351003, 0.11179403894816042, 0.10487285433940141, 0.11186560485889718, 0.1170245474505347, 0.11122696008499078, 0.11955881515703282, 0.1072547732513458, 0.09460292102764412, 0.083533679059972, 0.08997066748234284, 0.09665735461411828, 0.09116576238573126, 0.08471963362233925, 0.09197072612990054, 0.09314174936368891, 0.09443565791520891, 0.9763603042369496, 0.9844916548331589, 0.9581143044673246, 0.9690483086628539, 0.9568441202729209, 0.9626511891471614, 0.9627683692721836, 0.9609107901455858, 0.9479040281347934, 0.2290501074480923, 0.24057958667353418, 0.2274969012904947, 0.22725538257662592, 0.22044077293765152, 0.21783958376280066, 0.21872992239674272, 0.21844566347034777, 0.2185857687097429, 0.28068536776981756, 0.33335595971895515, 0.31272017971654964, 0.30435564310797814, 0.3053866615425398, 0.33148638570304545, 0.3186779728892104, 0.3320101604255107, 0.3496077450289182, 0.12417970528649891, 0.12333331584279039, 0.12471529020711603, 0.11566406107167981, 0.12682030407510247, 0.12609570867981879, 0.11765095704562867, 0.1321945527530496, 0.13148603098820755, 0.11977991686326628, 0.13016890086600874, 0.1272644452923154, 0.11961553953759863, 0.11393514981393948, 0.14053910938392, 0.13333779523674838, 0.12819401978014378, 0.11823903129933766, 0.009826826357949736, 9.999999999998899e-05, 9.999999999998899e-05, 0.004034353567734628, 9.999999999998899e-05, 0.01058379978631141, 0.010035194733194475, 9.999999999998899e-05, 0.005574972582510829, 0.055765280852235644, 0.06501837979890879, 0.11029037863912872, 0.07230758612965038, 0.08225359827227896, 0.030673496953551926, 0.07296107464226731, 0.07598987545087221, 0.047992432196767965, 0.0027356577424588746, 9.999999999998899e-05, 0.0005758677321391348, 0.0008290964890868002, 0.00022889316010277216, 0.00032312556095148715, 0.0002993171002504402, 0.0010326715332966696, 0.0007012842470333069, 0.07109042586100767, 0.06905533612762738, 0.07665966797572543, 0.07272398283133297, 0.06900403737840988, 0.06613150699289105, 0.06367976700908151, 0.0661511895103476, 0.06496263657120216, 0.3516149020469038, 0.3400131104311901, 0.3502787546271773, 0.3354086392037603, 0.3361858480088382, 0.3507036663326728, 0.33794489074683765, 0.3487899359876081, 0.3412891832617647, 0.09659589743165087, 0.11949189546862982, 0.09715386933439862, 0.1090943798830798, 0.09095779136136573, 0.09355483706454448, 0.10227803766951005, 0.09795936061506905, 0.10079830435947057, 0.16694500882738827, 0.18763991067484098, 0.1947878028958665, 0.1897456982046385, 0.19075524275831068, 0.17242871454202036, 0.18672577228779952, 0.16628254003931142, 0.18001550177362347, 0.25576295776955793, 0.2512856470939768, 0.26002804506766686, 0.24843236214436226, 0.2536071301160242, 0.2546598171260809, 0.2577816075440319, 0.2578933330646641, 0.25420732093314424, 0.19168976648593006, 0.19611188762747633, 0.187973315746656, 0.20247840156716435, 0.1878369739704594, 0.194551905624177, 0.19749704869532858, 0.19873218885981314, 0.1998754408446326, 0.20890206149648016, 0.20489554469611138, 0.22249327704502486, 0.21112456088074494, 0.20937762044030694, 0.2031103501143744, 0.21394114224241378, 0.20839601462959967, 0.21783333315066844, 0.20750325578040096, 0.21698123988800067, 0.1888803720959089, 0.2154817612564267, 0.21881098321084191, 0.21289070831630263, 0.22661787756560303, 0.1832854722033972, 0.2091471068516002, 0.1824865674359275, 0.1830821933998913, 0.4978770696605921, 0.1625593803203359, 0.1918472720241291, 0.17462691067476954, 0.19517456002210587, 0.48747648297516755, 0.165146939167233, 0.3137401050779939, 0.19735672749869881, 0.19107726292964466, 0.20061410570139138, 0.37415712563268977, 0.1976858458224301, 0.20374360559662497, 0.43715541865282304, 0.20649992954927276, 0.19536181244767192, 0.19585559979984724, 0.18723260083341664, 0.18101966378367418, 0.18699332712578032, 0.1770369394718082, 0.19039361377894515, 0.18143882213380458, 0.17431320757630642, 0.08591132886774144, 0.0884807020799886, 0.08674538383175856, 0.08196370906053929, 0.08553805192241148, 0.07470154860295808, 0.07711669713940283, 0.09270234549374257, 0.09110113621773452]}, "mutation_prompt": null}
{"id": "1453d41b-23a3-4ba3-9ff3-9ea4cd17f74a", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "61710e5f-334e-4d71-acf3-07956ad79668", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "96453f0e-aca3-40d5-9206-84162c741647", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "ebd00224-10a8-44b8-a82f-368e26507873", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "ce4aed5f-0ace-44d4-91a0-08d0751db45e", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget)\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduces a temperature-based annealing factor to further adjust mutation scaling and enhance convergence over time.", "configspace": "", "generation": 46, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.35156329039708545, 0.3733290094680408, 0.36087151961160435, 0.3443109150394378, 0.35383317604645836, 0.35992517352906683, 0.34335279350366876, 0.3503554259282702, 0.3609985014091235, 0.02349566173100337, 0.03436990411076257, 0.03675473255390649, 0.011513409364042104, 0.0134605876619589, 0.01727808885627724, 0.018649236137288416, 0.00831677123372121, 0.011566482226236796, 0.10106773594877616, 0.11131245065911666, 0.10449898760257526, 0.11337039618914546, 0.10550637737384894, 0.11346719644597358, 0.10256821427103602, 0.1231276068002084, 0.11160463952467947, 0.08658344362824899, 0.09652484040520326, 0.08863635463129271, 0.09837696144910113, 0.0849036710401726, 0.09497048231568406, 0.10107981850502634, 0.08824944557455017, 0.09467959702397022, 0.9546337115871624, 0.9630000819165456, 0.9567248234445962, 0.9501048160659102, 0.921581828246891, 0.9535977686830737, 0.9608044486827576, 0.9615065349740891, 0.9602064196067975, 0.22486852152771175, 0.22026963736326455, 0.2299199048734648, 0.2102530958283254, 0.22841480666311942, 0.23357918635151687, 0.214127667666835, 0.22987921111060128, 0.21765045637642022, 0.33695456001193347, 0.2956964135153458, 0.30110989411517786, 0.2857089300722754, 0.3650178602621209, 0.32904858570678086, 0.32607696846487044, 0.31629173916049136, 0.3188736436569861, 0.12410977383937483, 0.12802668687546792, 0.12998755876925994, 0.13442986221386888, 0.1400511663647399, 0.11660590912750779, 0.12096567456413487, 0.12909773465048724, 0.12802370790605488, 0.12765633675462285, 0.11072004070737507, 0.12535347024350108, 0.11289204414165865, 0.11845344789083279, 0.12729378048991036, 0.12127852543363571, 0.12472502096593285, 0.11519104488454723, 0.0005910013211907206, 0.0020612964892058327, 0.013407009405541848, 0.005106010218874912, 9.999999999998899e-05, 0.009997577120759216, 0.0036731083438323875, 0.0005654170859028529, 9.999999999998899e-05, 0.06580505331429909, 0.07522548220830161, 0.05164931657252614, 0.054386073572254445, 0.0619315344269622, 0.027050325426842603, 0.08177912020441802, 0.05917228408803332, 0.0650893520341308, 0.00011894596335182417, 0.000743672934204409, 0.00046585569675294813, 0.0005070607713189013, 0.0008376759612097606, 0.0005228116908374547, 0.0005431701352773821, 0.0005034269130735902, 0.0028148883017623527, 0.0599403492958368, 0.05797306163952509, 0.05822470919216849, 0.06774525134514975, 0.07319376105459374, 0.07320045454188762, 0.05817698133114613, 0.06997108129769802, 0.05847844857240725, 0.33680061024576735, 0.35666625237831184, 0.3421172698060281, 0.3344874900614766, 0.33658692296136106, 0.35090894584068355, 0.3326680961682521, 0.34362657380237427, 0.33868116132033776, 0.10710453032657519, 0.10026875442644434, 0.09260299945800232, 0.10105718669745967, 0.0919919364504207, 0.10496061346102903, 0.0914338690365506, 0.1118367890457379, 0.09449803687288094, 0.14388136871966184, 0.15536307528142046, 0.15305973291378416, 0.19016144297839888, 0.1677648971638791, 0.19536635825161064, 0.1417687068305573, 0.18821103967179276, 0.15252506639585828, 0.2523685950733163, 0.2530302171035903, 0.25417248923301905, 0.2527317180110732, 0.2495003823477968, 0.24623507686554613, 0.2553875472268641, 0.26374287251732853, 0.2504978345469936, 0.19182392613860866, 0.1973214126104358, 0.18787699008049863, 0.19351717769436383, 0.18340416826714911, 0.18757158961679665, 0.18803745654917148, 0.19938850201621627, 0.20046902365437713, 0.1948469058273774, 0.19630494004364396, 0.1996517289748666, 0.20331349266683596, 0.20271036708577128, 0.1986732172050497, 0.18560873946900158, 0.19506934999383652, 0.20498589338935258, 0.2142054318715707, 0.20180648556736103, 0.206770421142502, 0.22807575563969007, 0.2102351371544, 0.2085096809278787, 0.20552596007569868, 0.20362748357030458, 0.1899809537019871, 0.4096874103136956, 0.41744832050980185, 0.4211312315902832, 0.4923074906765189, 0.4447345729052711, 0.4549582849764696, 0.4589637356262418, 0.16456024102840416, 0.4908746316026976, 0.19503364268837953, 0.1933650103831931, 0.3528018514626883, 0.32908777217527363, 0.192776650970099, 0.19879965805710864, 0.20504123321199774, 0.15634304624305428, 0.20682185495015637, 0.19180427461931593, 0.17599465948895998, 0.18073565405624759, 0.18405697910753072, 0.1897099273868701, 0.18980883324621478, 0.20712321100496822, 0.18118326912550953, 0.19069850926161502, 0.07642716163945551, 0.07772542003587202, 0.08086126155309814, 0.08971855368504933, 0.07990856279714642, 0.08958760497206952, 0.09203574537241055, 0.07922155911596906, 0.09176622494461173]}, "mutation_prompt": null}
{"id": "bf037fa5-ef89-4932-a35f-054f485e8956", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Enhanced adaptive mutation and crossover strategies with Gaussian perturbations for improved exploration.", "configspace": "", "generation": 53, "fitness": 0.20131008147697974, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "c1d61369-acc8-476c-921e-132c936e3e90", "metadata": {"aucs": [0.36758282216008586, 0.37181265484614456, 0.3588675427598198, 0.35886467268232514, 0.35243057531814737, 0.3598702319740823, 0.37391787437268853, 0.3641230012149399, 0.37009413230728816, 0.0011451010026687358, 0.01431684085893592, 0.01958300543327407, 0.029935517867811123, 0.015286763582899932, 0.015942240503181937, 0.0165550249075328, 0.016523486362280848, 0.02105722103546448, 0.11300048904876825, 0.10655978665344779, 0.10765955812287809, 0.11515942076551544, 0.10451071160350534, 0.10218877694007189, 0.10848455821120484, 0.10558940709404796, 0.09911934853977877, 0.09259212690292007, 0.0894177356291408, 0.08627535377986661, 0.09159874897469467, 0.10858270659701486, 0.09815937866541424, 0.08481886848303288, 0.08666712060705317, 0.0838583122513572, 0.9537429490365742, 0.9708548110212707, 0.9516285610990212, 0.955487217159526, 0.9573051404883632, 0.9747266665263423, 0.9477444994019053, 0.9581730872694748, 0.9438784779791052, 0.2227726584908547, 0.2267219610973108, 0.2169301586280734, 0.2249466344962492, 0.2140422086090391, 0.2169974344691269, 0.21743291707435597, 0.21311163817854673, 0.21263369208374694, 0.3058825260972139, 0.3101775255950373, 0.3266355211370815, 0.2876000218331912, 0.31944977433633504, 0.308657248150102, 0.3243048038550206, 0.29447473344822406, 0.31065329643398587, 0.124638851416489, 0.11947666611076313, 0.1284299082082775, 0.12122306984067976, 0.12055966716643873, 0.12933458494852823, 0.127053977025826, 0.1250250752003358, 0.12970929579810764, 0.12012445210980771, 0.09905364930829075, 0.11849295172823948, 0.12131187779000852, 0.12244652330512107, 0.11460374041213184, 0.1413638712828309, 0.11684716099841719, 0.11688059871563039, 0.00027967663295580536, 0.004295035083960674, 0.004040250236603815, 0.004535643231751263, 0.0011266959375574315, 0.021560669169987556, 0.0037544574850971735, 0.0039661473564468475, 0.009391540599842152, 0.05257135055632367, 0.0593177402013253, 0.09786817724284069, 0.11166388690246898, 0.1093149120286343, 0.05957149042852672, 0.06523239772714773, 0.10815148003863162, 0.0762122411224263, 0.0009008058255567386, 9.999999999998899e-05, 0.0008633948032402694, 0.0008633848213716044, 9.999999999998899e-05, 0.00016217238155114, 0.0017783364062256002, 0.0008737566699059673, 9.999999999998899e-05, 0.05988473065012312, 0.06653922274031243, 0.0646813519376428, 0.0795202280059053, 0.06783528715824072, 0.06836257729544704, 0.06095008874024366, 0.05821378596793547, 0.05085682225597954, 0.34328257094866654, 0.3439175055177327, 0.3396847613919215, 0.34774656665087367, 0.3301938302817633, 0.3424252240576646, 0.34468237419531333, 0.3415169620574745, 0.3530820146699426, 0.09784568942567207, 0.08988832895967358, 0.10719359040821452, 0.09850418959958152, 0.12091574258117455, 0.08745533729395283, 0.08856019623860323, 0.09491325425939301, 0.0978181388834326, 0.1644320132989855, 0.15351549236179285, 0.16683327632747091, 0.14826137752415036, 0.20312422689420073, 0.14772762144512597, 0.13892582417238208, 0.1681186797901062, 0.15330172765155836, 0.2495356095413832, 0.25041939037953775, 0.2571616485317779, 0.25246422944931346, 0.25557126060642266, 0.25576380276008026, 0.2541771340246253, 0.2667088088338776, 0.25767938166225324, 0.1932916864041313, 0.19087953785819323, 0.18535803070295287, 0.19198870683372138, 0.18412221760555225, 0.18907070979497143, 0.20488111424250866, 0.19724624185559492, 0.1982240596547945, 0.212995304713664, 0.2109775147230426, 0.1851327442887457, 0.19571388989782124, 0.18716266300261397, 0.19163365276111777, 0.20679879633008946, 0.19055764165062494, 0.1983903146680478, 0.21922198302408602, 0.21700374513722942, 0.21796136078512862, 0.21217106386912743, 0.2103917207443896, 0.21657161611628317, 0.2115567937573174, 0.21764971769497032, 0.1831011392162869, 0.47293470316515607, 0.16697787828431288, 0.4692553616241283, 0.4524558165784841, 0.45111160814717777, 0.42719850593398234, 0.4718789768414776, 0.39484487968701465, 0.15433621915553053, 0.2522383076446759, 0.36950693263579293, 0.19018836624762692, 0.2635187810783177, 0.12424354218419342, 0.3337854984482236, 0.42813135745406994, 0.20625513831345232, 0.15733330210687146, 0.17616826243039774, 0.17981298814209445, 0.20575967059620537, 0.1925111426848699, 0.18681898621757842, 0.19654086016525063, 0.1924447484566677, 0.1848193858394218, 0.177757117065952, 0.07936025682297221, 0.08341624398256009, 0.07923840966741102, 0.07736761856977215, 0.08392025706093886, 0.08378380734970436, 0.07763119199655699, 0.07238527000879058, 0.0825115153683873]}, "mutation_prompt": null}
{"id": "a6e1bf41-e94e-4aa2-a737-57607abb7d36", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature, diversity):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01)) * diversity\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def population_diversity(self, population):\n        return np.mean(np.std(population, axis=0))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            diversity = self.population_diversity(population)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature, diversity)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Enhanced exploration and exploitation balance by incorporating variable scaling in mutation.", "configspace": "", "generation": 54, "fitness": 0.18790250175584397, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "bf037fa5-ef89-4932-a35f-054f485e8956", "metadata": {"aucs": [0.3563219199769767, 0.3601684315145275, 0.3754038464089181, 0.35798764585272225, 0.35312621723491333, 0.3608398798079112, 0.3592373154839147, 0.3643226556560897, 0.3695344715581921, 0.016709916251451462, 0.010782556347743277, 0.013202281960935203, 0.01089163076358457, 0.017474658250286712, 0.0163311268202877, 0.015233648425634239, 0.011473536750996605, 0.03176490087966777, 0.09806962154575571, 0.10459143493046374, 0.109668576117952, 0.10604649639877006, 0.11451160161207063, 0.11782190909860879, 0.12330300601201694, 0.10627430097709822, 0.10692971770306448, 0.09359364471775045, 0.0891023416303951, 0.0947190351301126, 0.08791309359283583, 0.09203059375636657, 0.08701713842804004, 0.08740323209509404, 0.11031500423274743, 0.09047104148291385, 0.9688385453380015, 0.9526436884400057, 0.9449515395871928, 0.9785557887218991, 0.9705512964850508, 0.9550202493167365, 0.939661190506993, 0.9684476248293713, 0.9354722580383522, 0.24054037232971692, 0.2116973965585578, 0.2177249940493704, 0.203811204570869, 0.2157530647428585, 0.2165608646127306, 0.21691713655819767, 0.21978432614347276, 0.216333194120073, 0.2675536783455217, 0.334284561425194, 0.24944416920583956, 0.2961849344482561, 0.2599443948038699, 0.2933047444763971, 0.29091798300994454, 0.26099135204620927, 0.2796043269700623, 0.13125217254600285, 0.11138195649485383, 0.11297512425639744, 0.1156833241055798, 0.11785536410445385, 0.11312040226834319, 0.11151386180535738, 0.12951746761752514, 0.12163530047066018, 0.07981709370314205, 0.0805941782266234, 0.07554993600527793, 0.11016008652261755, 0.11233894927609145, 0.1154859123145161, 0.11436151516539717, 0.10806695101323183, 0.10940100940902231, 0.00029253330183387494, 0.013477821878521312, 0.002569370201529253, 0.0030113221148861946, 0.0007213957583531716, 0.0028017435833473936, 0.007308054230838912, 0.015384132935376105, 0.011299689744171504, 0.060960998537348265, 0.05082672720161685, 0.052470171381691744, 0.06685284747814968, 0.024941980608973013, 0.06404941442046819, 0.06783144288253862, 0.043331338299210764, 0.04470692096828821, 0.000827106800741606, 0.000962292186667435, 0.0002595699476114488, 0.0018594461306822296, 0.00021581951363969232, 0.0013136742777344335, 0.001692226072194547, 0.0014449473046576067, 9.999999999998899e-05, 0.059751519358008265, 0.05477195540558055, 0.06917989518185763, 0.06216282110967075, 0.0698932062378117, 0.06272895948088786, 0.06259555575814557, 0.06415874494593243, 0.06436685774850759, 0.32703750137648424, 0.3389878119488233, 0.3281176624791936, 0.3506775075123836, 0.34435933782138284, 0.3312323844131033, 0.3444475560740996, 0.33672161900109787, 0.3350508141033611, 0.08938180638296667, 0.10248616717640124, 0.08516047834487195, 0.09929053414817024, 0.09587385891126765, 0.09611923631715058, 0.08951781695232786, 0.09804714551825056, 0.09478432191914321, 0.18423976861391644, 0.20841680273289043, 0.15475655224487672, 0.15318743394056766, 0.14554667830664492, 0.16103646863372267, 0.17175232414152486, 0.1565248106866185, 0.14722851208960186, 0.2525995496120126, 0.24970783531312124, 0.24565142260625128, 0.24128451201751233, 0.2491007786153523, 0.23311728674246834, 0.24684945459040974, 0.2569100275889463, 0.2574315291224799, 0.183058563262381, 0.19037551114028106, 0.18256136383761745, 0.187064426488607, 0.18326568517127018, 0.17803692990281195, 0.19929220602696518, 0.1924282152226574, 0.18780129255923583, 0.1853789747004193, 0.1928468133019713, 0.19727049201804425, 0.18255789501619835, 0.19388041184353377, 0.1881717809621125, 0.20856380429044352, 0.17645865546484818, 0.19138584084397148, 0.19861365189580704, 0.18226548180700763, 0.21996353764359633, 0.17962505883451518, 0.2011606119252638, 0.20877512685566357, 0.21099881936071196, 0.2086156788476109, 0.22212336380412012, 0.16632329883979147, 0.4398490861896214, 0.16439969905076757, 0.1806346732132451, 0.18120759641060447, 0.17851271208062403, 0.45099519434288105, 0.17409950922707196, 0.1763388402496917, 0.16226336007087616, 0.1831878243324362, 0.15997443599372696, 0.16572284226806044, 0.16888654349696608, 0.23524133086277765, 0.20428823415813835, 0.3060210527191686, 0.2001098888488959, 0.17597009375267703, 0.188465486716475, 0.19144967228177934, 0.19610287265009763, 0.19502077862621792, 0.18308341449436505, 0.1919614030009168, 0.17689848163378086, 0.2041814268427924, 0.08997908968687074, 0.08486595424922161, 0.08284038246217951, 0.07054685166356212, 0.08899978319211954, 0.07886840489087898, 0.08304954146119359, 0.0824466044871468, 0.0810620964074924]}, "mutation_prompt": null}
{"id": "86a251ee-0894-4333-a30c-d100961cf69c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 55, "fitness": 0.2020072378605883, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "bf037fa5-ef89-4932-a35f-054f485e8956", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "d6700738-59b1-4448-8f04-f5d57f4e9db6", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "15414d33-5b79-496a-b36f-23f34089d56c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "f9e869c1-fbd4-4920-8b33-21344fb6cd17", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "8c6fd426-0293-4297-b699-0748706cf305", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "075d0e72-2430-4eea-9587-d800736f0db2", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "7e6a2fff-500b-4b7e-9510-e39ad09caac0", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, fitness_variability):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u * (1 + fitness_variability)\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                step_size = (self.budget - evaluations) / self.budget\n                fitness_variability = np.std(fitness) / (np.mean(fitness) + 1e-8)\n                levy_step = self.levy_flight(self.dim, fitness_variability)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce dynamic scaling of Levy flight step size based on fitness variability for improved exploration.", "configspace": "", "generation": 61, "fitness": 0.1887593523974921, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.38178994840226965, 0.362511508730037, 0.35944045624075693, 0.35686029998794755, 0.358153802369623, 0.36306632798371963, 0.359233946633021, 0.39367081839498996, 0.3673975848531672, 0.002922392802652052, 0.007215365164893073, 0.004285756707424704, 0.017236295254385192, 0.0066773940351518846, 0.00966623968739333, 0.004858977943276832, 0.024714020505421264, 0.012479037096826517, 0.11819989355395555, 0.11196705707779075, 0.1164781639423953, 0.1015833163815052, 0.11316360526243119, 0.10044424518829875, 0.11512886922954835, 0.11191194741602706, 0.10655257200070778, 0.09597664461158473, 0.09214270244656475, 0.09531375208139747, 0.08575969830982832, 0.08706986595261501, 0.10571207630440571, 0.10527511678717916, 0.08971291811955795, 0.08727541059329846, 0.961503284228497, 0.9579814371503493, 0.955056570803581, 0.9523889536294743, 0.9575084218305416, 0.9747146461265754, 0.9350829297140679, 0.9575107220279229, 0.962982764611574, 0.2171615548510607, 0.22121379745646585, 0.2184604567242241, 0.2078335637508949, 0.21040204181444022, 0.21163416008413338, 0.18738718597574067, 0.21719630025436898, 0.1947225621969686, 0.2532671554197401, 0.3621678024378452, 0.2366305956905177, 0.32240795409007283, 0.2776981216399349, 0.29602491429344246, 0.199045072051509, 0.2500630471760441, 0.28620738913447075, 0.1046771952011557, 0.10796772500372231, 0.11583735594365974, 0.0003224616661283708, 0.00046298730097737995, 9.999999999998899e-05, 0.11837848256781291, 0.113181819999561, 0.11049274819313837, 0.1119241829647053, 0.09412113657454424, 0.11147273592624063, 0.11007061575358912, 0.1112128620164371, 0.09480283972311243, 0.10078379497162604, 0.09968970538585398, 0.10489888157798355, 0.011512354972392003, 0.0053293710206034905, 0.0022330870490745447, 0.0009242174519733526, 0.0020557962126426244, 0.00044555056243367197, 0.0016958254284541452, 9.999999999998899e-05, 9.999999999998899e-05, 0.05430356586639207, 0.05156404631552414, 0.05144055499600597, 0.09071618584702279, 0.048059711867613486, 0.11361399428271124, 0.04957650760780874, 0.038082640079218466, 0.09250130054008654, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004611343767990661, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056415459339562934, 0.05537597835417385, 0.056718221324290385, 0.04141072294055881, 0.03829945501595777, 0.03668271842683557, 0.03210358842789118, 0.0028741763024945355, 0.010263940816349515, 0.3283481927250902, 0.3491054813433788, 0.34581888466728494, 0.34261425649752997, 0.3383369585206799, 0.3412265874020959, 0.3327686432820798, 0.33322917728912727, 0.3417197436857389, 0.1152726067409785, 0.10904619575832697, 0.10402095312801463, 0.09632124641545148, 0.08946718969105516, 0.09496035959729465, 0.07204611430187469, 0.056216373555161625, 0.06393737553524204, 0.1726838825997702, 0.1586146701124278, 0.18670577489366602, 0.1898051121184029, 0.18600553719263835, 0.15091526503235708, 0.15869146096133557, 0.17148694212674487, 0.18192961028734012, 0.2501317876795841, 0.25489355298113825, 0.24836963468248563, 0.2536160789909322, 0.24615275861913033, 0.25191179890930204, 0.2599438799159731, 0.2607401923007361, 0.2680749117345812, 0.14119512005793022, 0.10657032968286562, 0.11678208673461454, 0.19128320628766482, 0.18612822156032738, 0.19732580363907504, 0.21169829769211979, 0.19823117796630496, 0.18711883013264818, 0.18456730804132682, 0.19981679626806137, 0.2039805879954929, 0.2286623970611087, 0.198496664905231, 0.20030723678125473, 0.22521827319233434, 0.20978472899710443, 0.19629756420618016, 0.19588425926208197, 0.176012227728656, 0.15935189835955044, 0.1926757479275788, 0.21434300319752841, 0.1903973430350666, 0.20153486105503748, 0.20280063665775216, 0.21397463941417494, 0.19136759292383054, 0.4422337191655463, 0.4901366765037104, 0.23861495077436135, 0.1735896931399873, 0.21259151245907604, 0.44541127874312003, 0.4748086626188015, 0.1539280013677362, 0.26881724914455996, 0.19446302616080946, 0.19220425229169213, 0.19783196076063292, 0.30888405717606804, 0.19349978007138247, 0.19731793802305964, 0.19878057021839068, 0.19807117948919573, 0.1828296161784666, 0.18275681180011405, 0.18719651488375533, 0.18478634129749372, 0.18624561970894848, 0.18495366758840182, 0.175245864486267, 0.17368704921194456, 0.19145039348273074, 0.08107997844572656, 0.08310338252228378, 0.08015611422940438, 0.08825669016238857, 0.07648271149685082, 0.08916124706296347, 0.08438732040919783, 0.0814391368045666, 0.07852204852917455]}, "mutation_prompt": null}
{"id": "5fb6e082-b19d-4949-bc60-561122ad8dea", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.52 + 0.5 * (1 - evaluations / self.budget)  # Slight increase in base temperature for enhanced exploration\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Enhance convergence speed by introducing a slight increase in temperature factor scaling, affecting exploration dynamics.", "configspace": "", "generation": 62, "fitness": 0.19835170730470925, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.348682949569167, 0.36406313820454506, 0.3563302536151657, 0.36203093657483565, 0.37145917731176237, 0.3744095383147854, 0.3627249299345996, 0.35989340535155956, 0.3536042475100638, 0.021257176261937794, 0.02566385491751222, 0.008614074413568651, 0.015556937771997403, 0.015301288821423231, 0.015164751797396847, 0.016741165608553765, 0.01290708472857427, 0.017804667278204178, 0.10700891100893983, 0.11033671706029324, 0.11788313431527075, 0.12096340328134725, 0.10118829824815168, 0.11444827058921114, 0.10793917195321623, 0.10736719887728619, 0.09860169643481209, 0.09113721614295589, 0.10108064271175521, 0.09119524608985574, 0.09468533806687174, 0.09004460825341742, 0.08393323660013663, 0.092027651628525, 0.08920096057292903, 0.0989046835089048, 0.9537683461570639, 0.9595638699687746, 0.9515290164351377, 0.9553903320740874, 0.9584803772288866, 0.9747045055658147, 0.947344626108744, 0.9519304955730997, 0.9610584238681806, 0.2137958185277974, 0.2234674912156619, 0.2236187983652217, 0.2312474275706219, 0.2226788682568751, 0.21887225166415414, 0.2191266450615833, 0.22506941838699546, 0.2204724190378291, 0.3149248467862804, 0.24712431424689463, 0.307207777361, 0.31766754226575056, 0.24844412877231303, 0.305101507147278, 0.2621311605222786, 0.27360533723476343, 0.2735977184141928, 0.12958854058378144, 0.1426660782870509, 0.1117807085847391, 0.13143122066143298, 0.12472006787822776, 0.12428463114894972, 0.12033494434178449, 0.11616591393949838, 0.13399623870303146, 0.11563644865613298, 0.10685948419846192, 0.13602228070849742, 0.1264424879768743, 0.125794181492765, 0.12622766659959073, 0.11889916366402542, 0.12488021210538935, 0.12026979371361834, 9.999999999998899e-05, 0.0015346078919606931, 9.999999999998899e-05, 0.0013076564012836078, 9.999999999998899e-05, 0.0009783754373041686, 0.002012523027849822, 0.005767726366525894, 0.0007138743142098836, 0.0881993670612754, 0.11784374031086431, 0.06374715860817437, 0.09263858843874528, 0.09873054557144201, 0.05326697779062817, 0.0630983512642872, 0.09799567944333498, 0.11553245115091193, 0.0002762442652625152, 9.999999999998899e-05, 0.00025838540002764976, 0.0005079718356327811, 0.0012645194257151493, 0.0018535738458229645, 0.00045841988083306084, 0.000412332868421017, 0.00012142390676384007, 0.06372231241305559, 0.059631758583685746, 0.06619588430951229, 0.06744813906659453, 0.07292692670003709, 0.07602358533037801, 0.052085105499106055, 0.05709143937918182, 0.055331267085541924, 0.33350920756102587, 0.332290814058119, 0.34099139975244175, 0.3451348655315595, 0.35006712257010564, 0.34139622214441956, 0.34871971165882587, 0.34322322700215524, 0.3383132443048378, 0.10150627350985764, 0.10353763236206692, 0.10117626822659853, 0.09513575333093227, 0.10026323636947454, 0.09212227880984303, 0.09336485343760303, 0.09476153511641772, 0.0961063657363096, 0.1889077841761153, 0.14480148571328844, 0.17078672877066836, 0.17880385037335111, 0.18415865541592913, 0.16584590624052287, 0.17233519521668017, 0.1587834854115967, 0.16983328545393683, 0.26387142432487354, 0.25540538459555295, 0.25267607439254336, 0.25229010597547874, 0.26588654925163857, 0.2502631880120585, 0.2526653698513288, 0.2563304624717818, 0.2510705773101376, 0.18799841111752014, 0.19474064627555088, 0.19190736012528864, 0.18960489998497687, 0.18411586206882635, 0.20198841155011737, 0.1935609569298844, 0.19025684356412198, 0.1889666942550512, 0.20693567772999555, 0.18267237295342098, 0.17880891768415663, 0.2047374803779073, 0.22226370218560576, 0.19495861396719927, 0.21847779063273232, 0.20217957101309025, 0.20837612207576062, 0.2120525666808577, 0.21962373977102778, 0.20288364935276704, 0.21115338083650936, 0.20723090668609978, 0.22244306822677296, 0.2163489919204098, 0.21222482274175491, 0.19119039533213678, 0.49510217739531037, 0.16383270190396781, 0.17414954759029533, 0.45932981346692425, 0.4384865721504835, 0.48095486793212117, 0.4482086405722405, 0.41134451683572915, 0.1792245302660811, 0.18635405852939446, 0.1959010600841582, 0.194966137196799, 0.22351042871228688, 0.19606981351051977, 0.18823203234542663, 0.4261259813512668, 0.20500309918878024, 0.16470576344342625, 0.18717652583568756, 0.1954367781157964, 0.18933597972912353, 0.17451098669669085, 0.18444248958725962, 0.1788331257010859, 0.19244547359998865, 0.17787200249734447, 0.18726658586361677, 0.07384908960656944, 0.08145603161505788, 0.08422836875713624, 0.07956132767278035, 0.0833097721834789, 0.08086220975482206, 0.07837793365000123, 0.08038535472024577, 0.08162321601064793]}, "mutation_prompt": null}
{"id": "678b20ef-7e80-4bde-963d-ec5e08187344", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive shrinkage factor in the mutation step to dynamically reduce the search space over time.", "configspace": "", "generation": 56, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.37454127521218195, 0.3533729040913347, 0.3564077082527475, 0.3705857772469794, 0.37220155995345605, 0.37017785733423836, 0.3662638529842317, 0.3469056144122846, 0.3625568698316787, 0.02565676169260911, 0.022345904214305157, 0.01485323091711599, 0.014597383162682664, 0.014391774159688842, 0.019202856770307752, 0.0204102999204564, 0.03246042226394952, 0.006732132037553851, 0.12257106959335429, 0.11390095989144389, 0.1060915863693479, 0.10108165833232108, 0.1039673248647518, 0.10283167100201573, 0.12111113283183039, 0.11622976944047991, 0.10502028040081313, 0.10120604098625374, 0.10213414536845555, 0.09338825602585243, 0.09048800684070357, 0.09003738227525393, 0.0927944000950296, 0.10372608423583984, 0.08366114840993599, 0.10685947098651505, 0.953729956593936, 0.9708516890123617, 0.9245842687685817, 0.9557407137341961, 0.9573102213338043, 0.9747254910060406, 0.952081786319413, 0.9520161628767898, 0.9424898098697211, 0.23385149704918817, 0.21330708844110935, 0.22484345775406012, 0.2139592918307922, 0.2233971882030913, 0.2117400164305162, 0.21505601298575627, 0.2260493185224266, 0.22215212504115667, 0.302673565318892, 0.3201213883742162, 0.3237313950872063, 0.3105371431934921, 0.3492587743753477, 0.2919353913717705, 0.20563380478403548, 0.2706868315135934, 0.3157298009433046, 0.12353186080141243, 0.11839900308237916, 0.1215791849568415, 0.1449980835662762, 0.12424721226437452, 0.11451007537542846, 0.12009488999220319, 0.11930699383094945, 0.11930908369950721, 0.11599212804696013, 0.11476389109048923, 0.11372623099542467, 0.11529670939044845, 0.1145258385764506, 0.11188575878378237, 0.12653496210791415, 0.11613241589764589, 0.12138059285780167, 0.00031915934312642946, 0.01339607886837968, 0.002334252343739185, 0.005473199269769413, 0.009211506183271156, 0.0030468681650037688, 0.0001189211219618791, 0.0032220946613086276, 0.010645720817524351, 0.07656862695877431, 0.09772229743322858, 0.09516911788507731, 0.07519410133439575, 0.11152371412246487, 0.04512034658243447, 0.060378207316450605, 0.11103255479195973, 0.07999700373510044, 0.0005761257311996948, 0.0011886079341671962, 0.0004978382446159113, 0.0013558204530205176, 0.00010825659504354324, 0.0023754505812972893, 0.00014084025504557118, 0.00150160532003063, 0.00024645373865583853, 0.068533135600507, 0.07450889433914365, 0.06760566450685435, 0.06456584924994369, 0.069095820286742, 0.06816899896456885, 0.0579538489587661, 0.0636749819064949, 0.05174746793690321, 0.3353931219410523, 0.33589438545995853, 0.3370833954648713, 0.3460067539688759, 0.3494399132130407, 0.3386764727416861, 0.34554275097575526, 0.3337275837150354, 0.34508976806036573, 0.09482476716965649, 0.1017803337974077, 0.08895362768378723, 0.10443871500070179, 0.10645362922078772, 0.13940535952210487, 0.0975452291952168, 0.08848642563988907, 0.11388777993037624, 0.1622772642095035, 0.1846180034318894, 0.16357109052177654, 0.16347002916638398, 0.1732281187896504, 0.15743091179318458, 0.17145398923172817, 0.16873177272791984, 0.1585227772224147, 0.25061970762890884, 0.24852553463037508, 0.25510376361320897, 0.25212286882270896, 0.25153790970486933, 0.24955470752047737, 0.2554573936465301, 0.24927068219348691, 0.25189990247755667, 0.19274450852866531, 0.18861041451954186, 0.18530248095370883, 0.18961855244137715, 0.18645830005343045, 0.18661261937893847, 0.19632297662479004, 0.19034925963736993, 0.19111104771155174, 0.19504596964841014, 0.2028104602612686, 0.21211259179942432, 0.18982205758178738, 0.1969594001933358, 0.2116535101294077, 0.19871841351187225, 0.19209576341815648, 0.19660552394008568, 0.21293517531533457, 0.2056801497691073, 0.2088158554566374, 0.20298326470701755, 0.20386938099103458, 0.21796615903122885, 0.20489456235964731, 0.21061919251841632, 0.20485228825372293, 0.4293821684867024, 0.4597366726102943, 0.4922581285557288, 0.43203923037772474, 0.17695611426535374, 0.4452252765807517, 0.4576019777938978, 0.5102363112107775, 0.17349922906270554, 0.1641713456207795, 0.1926132896690288, 0.20146993617808717, 0.19640506296085858, 0.3628440750221362, 0.4487619150359726, 0.44281191016798993, 0.20446472738467492, 0.15220251060065404, 0.19675309733063928, 0.20664560205346338, 0.17926175182273907, 0.2105574708355208, 0.18467563115525676, 0.18697921985187427, 0.20489320772572328, 0.19216706793987937, 0.17301541692491662, 0.07711468531295906, 0.074137284634758, 0.0798044138496331, 0.08125720469851039, 0.07803209695631375, 0.07421054035840702, 0.08465120877924559, 0.07472680201578263, 0.07691136529285358]}, "mutation_prompt": null}
{"id": "4902aad0-1327-4559-a18a-05fcc2d507a5", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor, self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                # Introduce random offspring for diversity every 25 evaluations\n                if evaluations % 25 == 0:\n                    random_offspring = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    random_fitness = func(random_offspring)\n                    evaluations += 1\n                    if random_fitness < best_fitness:\n                        best_fitness = random_fitness\n                        best = random_offspring\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce a random offspring generation step for diversity in the population, enhancing exploration.", "configspace": "", "generation": 64, "fitness": 0.19856714996299796, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.35871879144305907, 0.35092945143026766, 0.3541013243493272, 0.35257321329986724, 0.37165931338326175, 0.36966492661593975, 0.36725154341752986, 0.3472932072386061, 0.370632875804646, 0.011349533187618333, 0.022493090676070082, 0.0321846257973315, 0.023768155469391927, 0.012582714329592237, 9.999999999998899e-05, 0.022069059876376418, 0.026197451473472966, 0.014589996676884542, 0.11762100367346462, 0.11222333930007677, 0.11200514772428283, 0.11511946259071104, 0.11536360284724156, 0.09710916068308584, 0.09957175892114223, 0.10954636751103264, 0.10494101683100032, 0.08508275497341278, 0.09529907570421059, 0.09820750460902783, 0.10067503469207917, 0.09174504421042906, 0.08403532903159416, 0.09673655360780342, 0.08928103720552694, 0.10081692524774921, 0.9380526720658575, 0.9700471349275445, 0.916815664936329, 0.9357562627662381, 0.9796416847108761, 0.9879677103375014, 0.9539098580334039, 0.9623761073678919, 0.9275779332742341, 0.22427243144560927, 0.2214604341724764, 0.22280677131370152, 0.2092464961806847, 0.21502635656260505, 0.22174779046710702, 0.21725861789309087, 0.23664251554990845, 0.21198466838655583, 0.333034645436037, 0.27320986729686214, 0.3076514649604353, 0.2843503349866322, 0.2644980514843903, 0.2518440786853722, 0.2534172744468789, 0.2911356140021093, 0.3343415144712898, 0.1265043807744476, 0.12369274139733644, 0.1247315339195002, 0.12743220348734807, 0.11872732394828178, 0.11347960432306903, 0.12225481727292753, 0.13562026552640005, 0.13398874469110522, 0.1295046742639785, 0.1165427385853407, 0.11095679670425174, 0.12392140436939447, 0.12643639158197928, 0.12132690525216094, 0.12159842414057953, 0.1293938396002462, 0.11262716740719902, 0.003664241322446138, 0.0012134134812274988, 0.0014106446016588503, 0.005417132204181829, 0.0016486672920374978, 0.007217950114192906, 0.007034941281796492, 0.0018157602927790784, 0.014370673269067491, 0.08558386851148447, 0.058920498371098806, 0.04702159996202282, 0.01942567755739144, 0.07351824182069777, 0.035356427606050955, 0.07174059530214272, 0.029180669286431482, 0.06743353879199587, 0.0008222072397816582, 0.0004110598612369065, 0.0016703846755066198, 0.0009027936901931932, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013383025605122612, 0.0003621083291863725, 0.06553540815185077, 0.060459027658136044, 0.0654159580401501, 0.06919329824913001, 0.06313252923321888, 0.06636149413761427, 0.058948980612812396, 0.053032050626841576, 0.05876936686354817, 0.3392020175637226, 0.3458513664022602, 0.3300514903650883, 0.3353785980507872, 0.34419679696199323, 0.3563669704050496, 0.3366162481246546, 0.3425467050507651, 0.33157217959680274, 0.10970491522941817, 0.09328437472733819, 0.09895569564048323, 0.10593643104019246, 0.10281212038148302, 0.10600427704639093, 0.10523102176162924, 0.11183995978105865, 0.09610308340509399, 0.20029004046612342, 0.16372715638438762, 0.1858028460395611, 0.16100139341879038, 0.1810061751523866, 0.15647889592354536, 0.1735227025800592, 0.16530264730537514, 0.20045921910811038, 0.2608884196381881, 0.2517404289909564, 0.24543423274182496, 0.26787874185884375, 0.24914802186257468, 0.24993638985342392, 0.26848231603312167, 0.25343715322285676, 0.2553311672833687, 0.19077514051128797, 0.20306510400243538, 0.1873068193973354, 0.18916803588819464, 0.17978005724616286, 0.1829405920168644, 0.1891469367845825, 0.20378657910926556, 0.1934089116237354, 0.17994276822131505, 0.21771372867932715, 0.20056224272081358, 0.20364012427979294, 0.1917636141035256, 0.19515673397463207, 0.2106749148614152, 0.201348771687336, 0.21331567694089348, 0.2087611674880987, 0.2045394513659995, 0.22085714167925485, 0.21033771545869873, 0.2054088070636133, 0.22133115794453762, 0.21986286489413687, 0.20961075370652993, 0.2011099521004266, 0.476593119522687, 0.1610031866942101, 0.45238362826812717, 0.3908772173011814, 0.17975190277063846, 0.4390967957221156, 0.18454086869989716, 0.1759281723531294, 0.4472661318555381, 0.18919340227593584, 0.1601253303654252, 0.19247719951275055, 0.38093693511251014, 0.2970584711455845, 0.4083557097802458, 0.4068536751797597, 0.14470232652897863, 0.43119285506365934, 0.16850467597254615, 0.17848480784685072, 0.17832656522588441, 0.177550000398498, 0.18206344937469598, 0.18890202653663613, 0.18288441784332365, 0.18954171441185141, 0.1996602203957386, 0.07441452234927493, 0.0821622258574467, 0.07574511212664259, 0.08528802009844438, 0.07212699261023714, 0.0841792656023439, 0.07616194819552258, 0.08298423081273887, 0.07936648680987834]}, "mutation_prompt": null}
{"id": "0a8477d0-c1fb-44e9-800f-8616a1ca6427", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                \n                local_best = population[np.argmin(fitness)]  # New local best vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Incorporate a directional mutation strategy using a local best vector to improve convergence speed.", "configspace": "", "generation": 65, "fitness": 0.2055886648813871, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "86a251ee-0894-4333-a30c-d100961cf69c", "metadata": {"aucs": [0.3619735125448902, 0.36811011258076076, 0.37813165378461877, 0.35532848162582864, 0.36229648603136244, 0.37069208270338994, 0.3663036568008985, 0.36911956481690666, 0.34727738375080797, 0.014149392695808616, 0.006267090732816172, 0.013291110315727717, 0.02489048893167367, 0.005617786969980831, 0.004282498356271036, 0.021164590490952095, 0.014378404704006642, 0.015559503430816357, 0.10258166371677868, 0.1113371670084714, 0.10670584710587061, 0.10786726037694638, 0.1053460668221261, 0.11582234938594427, 0.11036607552028999, 0.11028337324856219, 0.12919890567926173, 0.09878628831802705, 0.08931967707519595, 0.08605979469061709, 0.0862496629191355, 0.09492373016290145, 0.08726585794956732, 0.10367386391017608, 0.09021899714826975, 0.0857804428326372, 0.9616607317359791, 0.9524228077992787, 0.9525469825483275, 0.9355151331828134, 0.9627349244436543, 0.951943025198931, 0.9523411579270085, 0.9517866948479855, 0.9482464648646765, 0.22721932588737104, 0.22428287404389435, 0.22807805201768083, 0.2493540240408142, 0.23508584904554175, 0.21637979746273905, 0.24071834625348643, 0.227386738670332, 0.22867224506912376, 0.2940333074272903, 0.28178920440180644, 0.29579692118809253, 0.2799894240318377, 0.29283400497768364, 0.38650526457662304, 0.3004638266098093, 0.30256213744569294, 0.27593450717130785, 0.13678169002268037, 0.12674928373986727, 0.126393804043461, 0.11706432481767226, 0.12891819728801057, 0.1206256477457176, 0.12649189967911556, 0.12207441856338641, 0.12481393688790543, 0.12112610955630165, 0.13745215501027175, 0.12370707785682666, 0.13260904570748644, 0.11257360701310459, 0.12680545621074435, 0.12898623926156594, 0.12884199023412857, 0.12220749571296341, 0.012870983143615566, 0.0019410052364824404, 0.018342816514606786, 0.006458489886149943, 0.01673637815872675, 0.001037909917717128, 0.006980699556924819, 0.014114187022045366, 0.005740476733285371, 0.06123405514874758, 0.12520216091286296, 0.10517915165016334, 0.08055693752451554, 0.06429474702103322, 0.06266561904707757, 0.08081582572186563, 0.09459068622858635, 0.09843428605634053, 0.0015174710308730743, 0.00014242869842195915, 0.0007126551803797732, 0.002220699080845767, 0.0015775058971081446, 0.002011055539704265, 0.0015153690150045973, 0.0010258522745891785, 0.0011227779860115694, 0.06557528617994324, 0.07293194984903617, 0.06644858781395346, 0.06869520591858913, 0.0658377438480997, 0.06975588914410913, 0.08250165718290658, 0.06285863016445092, 0.054465237023610835, 0.3433593962445486, 0.34489628430103425, 0.34164935350950243, 0.3516974783010317, 0.3430483915327449, 0.3429225376075534, 0.3442332420346004, 0.33671977796577823, 0.33937295919626653, 0.11420910121550154, 0.09816106689568627, 0.10771667749507507, 0.09938957293563311, 0.10028794022227416, 0.10118727146837991, 0.09313049483253832, 0.09863682979115418, 0.10199258549705303, 0.16549027427378782, 0.169269824368252, 0.28301754784221966, 0.17718001890398283, 0.17718366644775252, 0.17087588852002533, 0.16371569742467396, 0.16082577155103794, 0.17304811603983616, 0.25016910271539816, 0.24973812353921965, 0.25602712777100656, 0.25466171715070396, 0.26693876108182446, 0.2510190074752473, 0.25149964901489996, 0.26051715942604936, 0.2615637034779551, 0.1863350264214243, 0.19246834596033435, 0.19421993340566057, 0.1990863757696788, 0.19356755028315709, 0.1997349960541983, 0.19617959550022446, 0.20808582951566645, 0.19564613322198965, 0.2205377736518499, 0.1912414430446132, 0.20145776724085385, 0.19995512941371396, 0.20324190830238076, 0.18948285661023878, 0.20215181762563572, 0.18564387562163065, 0.2104910084699253, 0.21196279158759712, 0.20889752372147918, 0.21767782879711484, 0.22149200985955453, 0.2066682515052738, 0.19549461967972415, 0.20784533603304345, 0.19418149020661069, 0.2236181874915345, 0.181595211030941, 0.1710974654879709, 0.4941800357438496, 0.48569151239526864, 0.4701185792783734, 0.450014912633952, 0.49086143350201417, 0.4358118844838941, 0.5229699231963628, 0.38840416078582507, 0.19439968469701807, 0.19893424885748434, 0.42845008432726517, 0.4224584279026632, 0.19744486684833673, 0.207344202913336, 0.15391069539252, 0.3881169015513367, 0.1855800531273506, 0.19114668706335236, 0.18839085728200455, 0.1743773933617242, 0.1786835184399732, 0.18604828956303854, 0.18324666413714552, 0.17794892773148263, 0.19870221319915093, 0.07799170550545553, 0.07675938716615205, 0.08042810481909435, 0.09056759540167092, 0.0809427331433662, 0.07748202872427701, 0.08448389637696385, 0.08679640679901457, 0.08381400377697812]}, "mutation_prompt": null}
{"id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite = population[np.argsort(fitness)[:3]]  # Preserve top 3 elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, 3)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce elite preservation in the mutation step to enhance convergence speed by maintaining top performers.", "configspace": "", "generation": 66, "fitness": 0.20658681294250136, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "0a8477d0-c1fb-44e9-800f-8616a1ca6427", "metadata": {"aucs": [0.3815316054582347, 0.36022029866712457, 0.36797071292941297, 0.3475511434070683, 0.3681283754394996, 0.35686918681382307, 0.3606417879152717, 0.3591888552848802, 0.3655818378037037, 0.023584099291425242, 0.010146713036870425, 0.02195560034693622, 0.023793210741004045, 0.009368916275952488, 0.010273828825781872, 0.02736624473907867, 0.0044583764270417214, 0.029972322815388752, 0.12045446554047357, 0.09890168451874781, 0.10921990983304275, 0.13866025336534582, 0.12112826673433974, 0.11318332137621778, 0.12118546863337853, 0.10410852663577319, 0.11506719492475181, 0.09451835835960753, 0.08418648708559706, 0.08858238046282663, 0.09476286155740055, 0.09237365862845381, 0.10049368304843842, 0.0960544663924171, 0.0962596478090485, 0.10020748497518384, 0.9700754271948913, 0.9664690805219711, 0.9705766979330552, 0.9542724450505046, 0.9619149996456158, 0.9544382124236994, 0.9611909234018186, 0.957795832847348, 0.9495493154506147, 0.23493246569251058, 0.24671820351084772, 0.21549268582607328, 0.21951007805482892, 0.22544288225733122, 0.2217045303288152, 0.22347283657442008, 0.22046440076883667, 0.22443596773997343, 0.30907445292135294, 0.2910256828075538, 0.31442761317660284, 0.3257958746612172, 0.3208751092108053, 0.3452362478829334, 0.34610298042160814, 0.31848734176184856, 0.22543102337956544, 0.11616860147543484, 0.11818867400634592, 0.11730257367421004, 0.11567474445989989, 0.13626605729441232, 0.12459157787223629, 0.11904479839913384, 0.12606299374379193, 0.12999614030515827, 0.12397348804459929, 0.11424108880642214, 0.11378850656143791, 0.1510663876168784, 0.12083462427834435, 0.11819282363281203, 0.12538347212181056, 0.12264619507979702, 0.12153112039918124, 0.002402876445054658, 0.002958507135217392, 0.001620811442931025, 0.007220262055093407, 0.0011945740313765718, 0.007345587463112535, 0.0014936584070636139, 0.00794538343136697, 0.005725605007608103, 0.06913274823088855, 0.06895387908244899, 0.07823869368397551, 0.06079446838286151, 0.11442972123653072, 0.0667487018573849, 0.047355066742195584, 0.0771930630772576, 0.0917045414048101, 9.999999999998899e-05, 0.0011298506428952804, 0.004839179388930637, 0.0004726214345959212, 0.00033483797424704864, 0.0036549670155247016, 0.00105833239151365, 0.0002937542656478165, 0.0028549520350925617, 0.07101034027888597, 0.06839699416338407, 0.07184190025233927, 0.07524851786660092, 0.07511347429869897, 0.0717494392394139, 0.0756143786845922, 0.06835034858617905, 0.06981860836266074, 0.3637083404846194, 0.3616456873084555, 0.3418211161036784, 0.3424822732631244, 0.34755150013374336, 0.34559924226573546, 0.35053944306023055, 0.3489150841707582, 0.35534496436438956, 0.10330613330488814, 0.09594699729882017, 0.10795722307771594, 0.09180568867416272, 0.11383950500567863, 0.10896861376282219, 0.1071099223330284, 0.09931961999334415, 0.09568928216899986, 0.15931594108971636, 0.17343939992136892, 0.18293658843117877, 0.18377107557387107, 0.19618235910132698, 0.16496426989521695, 0.15622670014010653, 0.1936326061821121, 0.15822851094650414, 0.2760702848010367, 0.25701420784534434, 0.25247092506985913, 0.25436612959749016, 0.25593600248294457, 0.2651611807817269, 0.2629688330495631, 0.25472583840654617, 0.25115690848905736, 0.19415098258805763, 0.1967133776106832, 0.20503178580473835, 0.20398600358482621, 0.19132995309008216, 0.18973240720092688, 0.19288114641362386, 0.19422133658482166, 0.20665966129780922, 0.21736422785670684, 0.19691105647579532, 0.207645620731835, 0.2166813408592343, 0.21530177520095684, 0.20218907267949549, 0.20496208728305532, 0.19565541962437405, 0.2355736100106075, 0.2191047879618031, 0.2089290957380885, 0.21751212954079924, 0.22456687855327495, 0.22122667732819667, 0.2104466277462661, 0.21999056924680638, 0.20846183893371262, 0.20880399072903288, 0.4454771631832838, 0.5106845284648078, 0.4711185256455289, 0.4653297954915916, 0.45037176913996946, 0.43832542982758504, 0.46495311211653634, 0.4751517283572527, 0.15619769044055143, 0.16726071108010476, 0.20241784105312122, 0.4247102968826807, 0.18802117681408015, 0.18020217388086235, 0.24747138970598115, 0.24722588564269854, 0.4102512878604856, 0.20476439204604402, 0.19114213174139305, 0.1759473630778341, 0.17608199200088204, 0.19661837853205444, 0.1795000481984016, 0.2192459952235779, 0.2316873409411463, 0.19689176525908125, 0.1881836113936155, 0.0818956327607695, 0.08660128369159759, 0.07951679164169745, 0.08580993865851705, 0.08497496217171485, 0.0797210705360385, 0.08220216982495587, 0.08009043706272878, 0.08839486465986879]}, "mutation_prompt": null}
{"id": "fba13001-fdb8-4a8c-a303-ad7b5c4d7130", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite = population[np.argsort(fitness)[:3]]  # Preserve top 3 elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, 3)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce elite preservation in the mutation step to enhance convergence speed by maintaining top performers.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "metadata": {"aucs": [0.3815316054582347, 0.36022029866712457, 0.36797071292941297, 0.3475511434070683, 0.3681283754394996, 0.35686918681382307, 0.3606417879152717, 0.3591888552848802, 0.3655818378037037, 0.023584099291425242, 0.010146713036870425, 0.02195560034693622, 0.023793210741004045, 0.009368916275952488, 0.010273828825781872, 0.02736624473907867, 0.0044583764270417214, 0.029972322815388752, 0.12045446554047357, 0.09890168451874781, 0.10921990983304275, 0.13866025336534582, 0.12112826673433974, 0.11318332137621778, 0.12118546863337853, 0.10410852663577319, 0.11506719492475181, 0.09451835835960753, 0.08418648708559706, 0.08858238046282663, 0.09476286155740055, 0.09237365862845381, 0.10049368304843842, 0.0960544663924171, 0.0962596478090485, 0.10020748497518384, 0.9700754271948913, 0.9664690805219711, 0.9705766979330552, 0.9542724450505046, 0.9619149996456158, 0.9544382124236994, 0.9611909234018186, 0.957795832847348, 0.9495493154506147, 0.23493246569251058, 0.24671820351084772, 0.21549268582607328, 0.21951007805482892, 0.22544288225733122, 0.2217045303288152, 0.22347283657442008, 0.22046440076883667, 0.22443596773997343, 0.30907445292135294, 0.2910256828075538, 0.31442761317660284, 0.3257958746612172, 0.3208751092108053, 0.3452362478829334, 0.34610298042160814, 0.31848734176184856, 0.22543102337956544, 0.11616860147543484, 0.11818867400634592, 0.11730257367421004, 0.11567474445989989, 0.13626605729441232, 0.12459157787223629, 0.11904479839913384, 0.12606299374379193, 0.12999614030515827, 0.12397348804459929, 0.11424108880642214, 0.11378850656143791, 0.1510663876168784, 0.12083462427834435, 0.11819282363281203, 0.12538347212181056, 0.12264619507979702, 0.12153112039918124, 0.002402876445054658, 0.002958507135217392, 0.001620811442931025, 0.007220262055093407, 0.0011945740313765718, 0.007345587463112535, 0.0014936584070636139, 0.00794538343136697, 0.005725605007608103, 0.06913274823088855, 0.06895387908244899, 0.07823869368397551, 0.06079446838286151, 0.11442972123653072, 0.0667487018573849, 0.047355066742195584, 0.0771930630772576, 0.0917045414048101, 9.999999999998899e-05, 0.0011298506428952804, 0.004839179388930637, 0.0004726214345959212, 0.00033483797424704864, 0.0036549670155247016, 0.00105833239151365, 0.0002937542656478165, 0.0028549520350925617, 0.07101034027888597, 0.06839699416338407, 0.07184190025233927, 0.07524851786660092, 0.07511347429869897, 0.0717494392394139, 0.0756143786845922, 0.06835034858617905, 0.06981860836266074, 0.3637083404846194, 0.3616456873084555, 0.3418211161036784, 0.3424822732631244, 0.34755150013374336, 0.34559924226573546, 0.35053944306023055, 0.3489150841707582, 0.35534496436438956, 0.10330613330488814, 0.09594699729882017, 0.10795722307771594, 0.09180568867416272, 0.11383950500567863, 0.10896861376282219, 0.1071099223330284, 0.09931961999334415, 0.09568928216899986, 0.15931594108971636, 0.17343939992136892, 0.18293658843117877, 0.18377107557387107, 0.19618235910132698, 0.16496426989521695, 0.15622670014010653, 0.1936326061821121, 0.15822851094650414, 0.2760702848010367, 0.25701420784534434, 0.25247092506985913, 0.25436612959749016, 0.25593600248294457, 0.2651611807817269, 0.2629688330495631, 0.25472583840654617, 0.25115690848905736, 0.19415098258805763, 0.1967133776106832, 0.20503178580473835, 0.20398600358482621, 0.19132995309008216, 0.18973240720092688, 0.19288114641362386, 0.19422133658482166, 0.20665966129780922, 0.21736422785670684, 0.19691105647579532, 0.207645620731835, 0.2166813408592343, 0.21530177520095684, 0.20218907267949549, 0.20496208728305532, 0.19565541962437405, 0.2355736100106075, 0.2191047879618031, 0.2089290957380885, 0.21751212954079924, 0.22456687855327495, 0.22122667732819667, 0.2104466277462661, 0.21999056924680638, 0.20846183893371262, 0.20880399072903288, 0.4454771631832838, 0.5106845284648078, 0.4711185256455289, 0.4653297954915916, 0.45037176913996946, 0.43832542982758504, 0.46495311211653634, 0.4751517283572527, 0.15619769044055143, 0.16726071108010476, 0.20241784105312122, 0.4247102968826807, 0.18802117681408015, 0.18020217388086235, 0.24747138970598115, 0.24722588564269854, 0.4102512878604856, 0.20476439204604402, 0.19114213174139305, 0.1759473630778341, 0.17608199200088204, 0.19661837853205444, 0.1795000481984016, 0.2192459952235779, 0.2316873409411463, 0.19689176525908125, 0.1881836113936155, 0.0818956327607695, 0.08660128369159759, 0.07951679164169745, 0.08580993865851705, 0.08497496217171485, 0.0797210705360385, 0.08220216982495587, 0.08009043706272878, 0.08839486465986879]}, "mutation_prompt": null}
{"id": "e616f3f0-b090-4306-af3c-3a9b49d5f03a", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite = population[np.argsort(fitness)[:3]]  # Preserve top 3 elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, 3)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce elite preservation in the mutation step to enhance convergence speed by maintaining top performers.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "metadata": {"aucs": [0.3815316054582347, 0.36022029866712457, 0.36797071292941297, 0.3475511434070683, 0.3681283754394996, 0.35686918681382307, 0.3606417879152717, 0.3591888552848802, 0.3655818378037037, 0.023584099291425242, 0.010146713036870425, 0.02195560034693622, 0.023793210741004045, 0.009368916275952488, 0.010273828825781872, 0.02736624473907867, 0.0044583764270417214, 0.029972322815388752, 0.12045446554047357, 0.09890168451874781, 0.10921990983304275, 0.13866025336534582, 0.12112826673433974, 0.11318332137621778, 0.12118546863337853, 0.10410852663577319, 0.11506719492475181, 0.09451835835960753, 0.08418648708559706, 0.08858238046282663, 0.09476286155740055, 0.09237365862845381, 0.10049368304843842, 0.0960544663924171, 0.0962596478090485, 0.10020748497518384, 0.9700754271948913, 0.9664690805219711, 0.9705766979330552, 0.9542724450505046, 0.9619149996456158, 0.9544382124236994, 0.9611909234018186, 0.957795832847348, 0.9495493154506147, 0.23493246569251058, 0.24671820351084772, 0.21549268582607328, 0.21951007805482892, 0.22544288225733122, 0.2217045303288152, 0.22347283657442008, 0.22046440076883667, 0.22443596773997343, 0.30907445292135294, 0.2910256828075538, 0.31442761317660284, 0.3257958746612172, 0.3208751092108053, 0.3452362478829334, 0.34610298042160814, 0.31848734176184856, 0.22543102337956544, 0.11616860147543484, 0.11818867400634592, 0.11730257367421004, 0.11567474445989989, 0.13626605729441232, 0.12459157787223629, 0.11904479839913384, 0.12606299374379193, 0.12999614030515827, 0.12397348804459929, 0.11424108880642214, 0.11378850656143791, 0.1510663876168784, 0.12083462427834435, 0.11819282363281203, 0.12538347212181056, 0.12264619507979702, 0.12153112039918124, 0.002402876445054658, 0.002958507135217392, 0.001620811442931025, 0.007220262055093407, 0.0011945740313765718, 0.007345587463112535, 0.0014936584070636139, 0.00794538343136697, 0.005725605007608103, 0.06913274823088855, 0.06895387908244899, 0.07823869368397551, 0.06079446838286151, 0.11442972123653072, 0.0667487018573849, 0.047355066742195584, 0.0771930630772576, 0.0917045414048101, 9.999999999998899e-05, 0.0011298506428952804, 0.004839179388930637, 0.0004726214345959212, 0.00033483797424704864, 0.0036549670155247016, 0.00105833239151365, 0.0002937542656478165, 0.0028549520350925617, 0.07101034027888597, 0.06839699416338407, 0.07184190025233927, 0.07524851786660092, 0.07511347429869897, 0.0717494392394139, 0.0756143786845922, 0.06835034858617905, 0.06981860836266074, 0.3637083404846194, 0.3616456873084555, 0.3418211161036784, 0.3424822732631244, 0.34755150013374336, 0.34559924226573546, 0.35053944306023055, 0.3489150841707582, 0.35534496436438956, 0.10330613330488814, 0.09594699729882017, 0.10795722307771594, 0.09180568867416272, 0.11383950500567863, 0.10896861376282219, 0.1071099223330284, 0.09931961999334415, 0.09568928216899986, 0.15931594108971636, 0.17343939992136892, 0.18293658843117877, 0.18377107557387107, 0.19618235910132698, 0.16496426989521695, 0.15622670014010653, 0.1936326061821121, 0.15822851094650414, 0.2760702848010367, 0.25701420784534434, 0.25247092506985913, 0.25436612959749016, 0.25593600248294457, 0.2651611807817269, 0.2629688330495631, 0.25472583840654617, 0.25115690848905736, 0.19415098258805763, 0.1967133776106832, 0.20503178580473835, 0.20398600358482621, 0.19132995309008216, 0.18973240720092688, 0.19288114641362386, 0.19422133658482166, 0.20665966129780922, 0.21736422785670684, 0.19691105647579532, 0.207645620731835, 0.2166813408592343, 0.21530177520095684, 0.20218907267949549, 0.20496208728305532, 0.19565541962437405, 0.2355736100106075, 0.2191047879618031, 0.2089290957380885, 0.21751212954079924, 0.22456687855327495, 0.22122667732819667, 0.2104466277462661, 0.21999056924680638, 0.20846183893371262, 0.20880399072903288, 0.4454771631832838, 0.5106845284648078, 0.4711185256455289, 0.4653297954915916, 0.45037176913996946, 0.43832542982758504, 0.46495311211653634, 0.4751517283572527, 0.15619769044055143, 0.16726071108010476, 0.20241784105312122, 0.4247102968826807, 0.18802117681408015, 0.18020217388086235, 0.24747138970598115, 0.24722588564269854, 0.4102512878604856, 0.20476439204604402, 0.19114213174139305, 0.1759473630778341, 0.17608199200088204, 0.19661837853205444, 0.1795000481984016, 0.2192459952235779, 0.2316873409411463, 0.19689176525908125, 0.1881836113936155, 0.0818956327607695, 0.08660128369159759, 0.07951679164169745, 0.08580993865851705, 0.08497496217171485, 0.0797210705360385, 0.08220216982495587, 0.08009043706272878, 0.08839486465986879]}, "mutation_prompt": null}
{"id": "c543bcbb-b6f0-49f4-a971-319d067e148b", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite = population[np.argsort(fitness)[:3]]  # Preserve top 3 elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, 3)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce elite preservation in the mutation step to enhance convergence speed by maintaining top performers.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "metadata": {"aucs": [0.3815316054582347, 0.36022029866712457, 0.36797071292941297, 0.3475511434070683, 0.3681283754394996, 0.35686918681382307, 0.3606417879152717, 0.3591888552848802, 0.3655818378037037, 0.023584099291425242, 0.010146713036870425, 0.02195560034693622, 0.023793210741004045, 0.009368916275952488, 0.010273828825781872, 0.02736624473907867, 0.0044583764270417214, 0.029972322815388752, 0.12045446554047357, 0.09890168451874781, 0.10921990983304275, 0.13866025336534582, 0.12112826673433974, 0.11318332137621778, 0.12118546863337853, 0.10410852663577319, 0.11506719492475181, 0.09451835835960753, 0.08418648708559706, 0.08858238046282663, 0.09476286155740055, 0.09237365862845381, 0.10049368304843842, 0.0960544663924171, 0.0962596478090485, 0.10020748497518384, 0.9700754271948913, 0.9664690805219711, 0.9705766979330552, 0.9542724450505046, 0.9619149996456158, 0.9544382124236994, 0.9611909234018186, 0.957795832847348, 0.9495493154506147, 0.23493246569251058, 0.24671820351084772, 0.21549268582607328, 0.21951007805482892, 0.22544288225733122, 0.2217045303288152, 0.22347283657442008, 0.22046440076883667, 0.22443596773997343, 0.30907445292135294, 0.2910256828075538, 0.31442761317660284, 0.3257958746612172, 0.3208751092108053, 0.3452362478829334, 0.34610298042160814, 0.31848734176184856, 0.22543102337956544, 0.11616860147543484, 0.11818867400634592, 0.11730257367421004, 0.11567474445989989, 0.13626605729441232, 0.12459157787223629, 0.11904479839913384, 0.12606299374379193, 0.12999614030515827, 0.12397348804459929, 0.11424108880642214, 0.11378850656143791, 0.1510663876168784, 0.12083462427834435, 0.11819282363281203, 0.12538347212181056, 0.12264619507979702, 0.12153112039918124, 0.002402876445054658, 0.002958507135217392, 0.001620811442931025, 0.007220262055093407, 0.0011945740313765718, 0.007345587463112535, 0.0014936584070636139, 0.00794538343136697, 0.005725605007608103, 0.06913274823088855, 0.06895387908244899, 0.07823869368397551, 0.06079446838286151, 0.11442972123653072, 0.0667487018573849, 0.047355066742195584, 0.0771930630772576, 0.0917045414048101, 9.999999999998899e-05, 0.0011298506428952804, 0.004839179388930637, 0.0004726214345959212, 0.00033483797424704864, 0.0036549670155247016, 0.00105833239151365, 0.0002937542656478165, 0.0028549520350925617, 0.07101034027888597, 0.06839699416338407, 0.07184190025233927, 0.07524851786660092, 0.07511347429869897, 0.0717494392394139, 0.0756143786845922, 0.06835034858617905, 0.06981860836266074, 0.3637083404846194, 0.3616456873084555, 0.3418211161036784, 0.3424822732631244, 0.34755150013374336, 0.34559924226573546, 0.35053944306023055, 0.3489150841707582, 0.35534496436438956, 0.10330613330488814, 0.09594699729882017, 0.10795722307771594, 0.09180568867416272, 0.11383950500567863, 0.10896861376282219, 0.1071099223330284, 0.09931961999334415, 0.09568928216899986, 0.15931594108971636, 0.17343939992136892, 0.18293658843117877, 0.18377107557387107, 0.19618235910132698, 0.16496426989521695, 0.15622670014010653, 0.1936326061821121, 0.15822851094650414, 0.2760702848010367, 0.25701420784534434, 0.25247092506985913, 0.25436612959749016, 0.25593600248294457, 0.2651611807817269, 0.2629688330495631, 0.25472583840654617, 0.25115690848905736, 0.19415098258805763, 0.1967133776106832, 0.20503178580473835, 0.20398600358482621, 0.19132995309008216, 0.18973240720092688, 0.19288114641362386, 0.19422133658482166, 0.20665966129780922, 0.21736422785670684, 0.19691105647579532, 0.207645620731835, 0.2166813408592343, 0.21530177520095684, 0.20218907267949549, 0.20496208728305532, 0.19565541962437405, 0.2355736100106075, 0.2191047879618031, 0.2089290957380885, 0.21751212954079924, 0.22456687855327495, 0.22122667732819667, 0.2104466277462661, 0.21999056924680638, 0.20846183893371262, 0.20880399072903288, 0.4454771631832838, 0.5106845284648078, 0.4711185256455289, 0.4653297954915916, 0.45037176913996946, 0.43832542982758504, 0.46495311211653634, 0.4751517283572527, 0.15619769044055143, 0.16726071108010476, 0.20241784105312122, 0.4247102968826807, 0.18802117681408015, 0.18020217388086235, 0.24747138970598115, 0.24722588564269854, 0.4102512878604856, 0.20476439204604402, 0.19114213174139305, 0.1759473630778341, 0.17608199200088204, 0.19661837853205444, 0.1795000481984016, 0.2192459952235779, 0.2316873409411463, 0.19689176525908125, 0.1881836113936155, 0.0818956327607695, 0.08660128369159759, 0.07951679164169745, 0.08580993865851705, 0.08497496217171485, 0.0797210705360385, 0.08220216982495587, 0.08009043706272878, 0.08839486465986879]}, "mutation_prompt": null}
{"id": "936fa70f-8057-4a33-bd4c-7f33859fe372", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite = population[np.argsort(fitness)[:3]]  # Preserve top 3 elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, 3)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce elite preservation in the mutation step to enhance convergence speed by maintaining top performers.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "metadata": {"aucs": [0.3815316054582347, 0.36022029866712457, 0.36797071292941297, 0.3475511434070683, 0.3681283754394996, 0.35686918681382307, 0.3606417879152717, 0.3591888552848802, 0.3655818378037037, 0.023584099291425242, 0.010146713036870425, 0.02195560034693622, 0.023793210741004045, 0.009368916275952488, 0.010273828825781872, 0.02736624473907867, 0.0044583764270417214, 0.029972322815388752, 0.12045446554047357, 0.09890168451874781, 0.10921990983304275, 0.13866025336534582, 0.12112826673433974, 0.11318332137621778, 0.12118546863337853, 0.10410852663577319, 0.11506719492475181, 0.09451835835960753, 0.08418648708559706, 0.08858238046282663, 0.09476286155740055, 0.09237365862845381, 0.10049368304843842, 0.0960544663924171, 0.0962596478090485, 0.10020748497518384, 0.9700754271948913, 0.9664690805219711, 0.9705766979330552, 0.9542724450505046, 0.9619149996456158, 0.9544382124236994, 0.9611909234018186, 0.957795832847348, 0.9495493154506147, 0.23493246569251058, 0.24671820351084772, 0.21549268582607328, 0.21951007805482892, 0.22544288225733122, 0.2217045303288152, 0.22347283657442008, 0.22046440076883667, 0.22443596773997343, 0.30907445292135294, 0.2910256828075538, 0.31442761317660284, 0.3257958746612172, 0.3208751092108053, 0.3452362478829334, 0.34610298042160814, 0.31848734176184856, 0.22543102337956544, 0.11616860147543484, 0.11818867400634592, 0.11730257367421004, 0.11567474445989989, 0.13626605729441232, 0.12459157787223629, 0.11904479839913384, 0.12606299374379193, 0.12999614030515827, 0.12397348804459929, 0.11424108880642214, 0.11378850656143791, 0.1510663876168784, 0.12083462427834435, 0.11819282363281203, 0.12538347212181056, 0.12264619507979702, 0.12153112039918124, 0.002402876445054658, 0.002958507135217392, 0.001620811442931025, 0.007220262055093407, 0.0011945740313765718, 0.007345587463112535, 0.0014936584070636139, 0.00794538343136697, 0.005725605007608103, 0.06913274823088855, 0.06895387908244899, 0.07823869368397551, 0.06079446838286151, 0.11442972123653072, 0.0667487018573849, 0.047355066742195584, 0.0771930630772576, 0.0917045414048101, 9.999999999998899e-05, 0.0011298506428952804, 0.004839179388930637, 0.0004726214345959212, 0.00033483797424704864, 0.0036549670155247016, 0.00105833239151365, 0.0002937542656478165, 0.0028549520350925617, 0.07101034027888597, 0.06839699416338407, 0.07184190025233927, 0.07524851786660092, 0.07511347429869897, 0.0717494392394139, 0.0756143786845922, 0.06835034858617905, 0.06981860836266074, 0.3637083404846194, 0.3616456873084555, 0.3418211161036784, 0.3424822732631244, 0.34755150013374336, 0.34559924226573546, 0.35053944306023055, 0.3489150841707582, 0.35534496436438956, 0.10330613330488814, 0.09594699729882017, 0.10795722307771594, 0.09180568867416272, 0.11383950500567863, 0.10896861376282219, 0.1071099223330284, 0.09931961999334415, 0.09568928216899986, 0.15931594108971636, 0.17343939992136892, 0.18293658843117877, 0.18377107557387107, 0.19618235910132698, 0.16496426989521695, 0.15622670014010653, 0.1936326061821121, 0.15822851094650414, 0.2760702848010367, 0.25701420784534434, 0.25247092506985913, 0.25436612959749016, 0.25593600248294457, 0.2651611807817269, 0.2629688330495631, 0.25472583840654617, 0.25115690848905736, 0.19415098258805763, 0.1967133776106832, 0.20503178580473835, 0.20398600358482621, 0.19132995309008216, 0.18973240720092688, 0.19288114641362386, 0.19422133658482166, 0.20665966129780922, 0.21736422785670684, 0.19691105647579532, 0.207645620731835, 0.2166813408592343, 0.21530177520095684, 0.20218907267949549, 0.20496208728305532, 0.19565541962437405, 0.2355736100106075, 0.2191047879618031, 0.2089290957380885, 0.21751212954079924, 0.22456687855327495, 0.22122667732819667, 0.2104466277462661, 0.21999056924680638, 0.20846183893371262, 0.20880399072903288, 0.4454771631832838, 0.5106845284648078, 0.4711185256455289, 0.4653297954915916, 0.45037176913996946, 0.43832542982758504, 0.46495311211653634, 0.4751517283572527, 0.15619769044055143, 0.16726071108010476, 0.20241784105312122, 0.4247102968826807, 0.18802117681408015, 0.18020217388086235, 0.24747138970598115, 0.24722588564269854, 0.4102512878604856, 0.20476439204604402, 0.19114213174139305, 0.1759473630778341, 0.17608199200088204, 0.19661837853205444, 0.1795000481984016, 0.2192459952235779, 0.2316873409411463, 0.19689176525908125, 0.1881836113936155, 0.0818956327607695, 0.08660128369159759, 0.07951679164169745, 0.08580993865851705, 0.08497496217171485, 0.0797210705360385, 0.08220216982495587, 0.08009043706272878, 0.08839486465986879]}, "mutation_prompt": null}
{"id": "a7a37830-23dc-4efa-83f1-e3fee1e85161", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite = population[np.argsort(fitness)[:3]]  # Preserve top 3 elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, 3)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce elite preservation in the mutation step to enhance convergence speed by maintaining top performers.", "configspace": "", "generation": 67, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "metadata": {"aucs": [0.3815316054582347, 0.36022029866712457, 0.36797071292941297, 0.3475511434070683, 0.3681283754394996, 0.35686918681382307, 0.3606417879152717, 0.3591888552848802, 0.3655818378037037, 0.023584099291425242, 0.010146713036870425, 0.02195560034693622, 0.023793210741004045, 0.009368916275952488, 0.010273828825781872, 0.02736624473907867, 0.0044583764270417214, 0.029972322815388752, 0.12045446554047357, 0.09890168451874781, 0.10921990983304275, 0.13866025336534582, 0.12112826673433974, 0.11318332137621778, 0.12118546863337853, 0.10410852663577319, 0.11506719492475181, 0.09451835835960753, 0.08418648708559706, 0.08858238046282663, 0.09476286155740055, 0.09237365862845381, 0.10049368304843842, 0.0960544663924171, 0.0962596478090485, 0.10020748497518384, 0.9700754271948913, 0.9664690805219711, 0.9705766979330552, 0.9542724450505046, 0.9619149996456158, 0.9544382124236994, 0.9611909234018186, 0.957795832847348, 0.9495493154506147, 0.23493246569251058, 0.24671820351084772, 0.21549268582607328, 0.21951007805482892, 0.22544288225733122, 0.2217045303288152, 0.22347283657442008, 0.22046440076883667, 0.22443596773997343, 0.30907445292135294, 0.2910256828075538, 0.31442761317660284, 0.3257958746612172, 0.3208751092108053, 0.3452362478829334, 0.34610298042160814, 0.31848734176184856, 0.22543102337956544, 0.11616860147543484, 0.11818867400634592, 0.11730257367421004, 0.11567474445989989, 0.13626605729441232, 0.12459157787223629, 0.11904479839913384, 0.12606299374379193, 0.12999614030515827, 0.12397348804459929, 0.11424108880642214, 0.11378850656143791, 0.1510663876168784, 0.12083462427834435, 0.11819282363281203, 0.12538347212181056, 0.12264619507979702, 0.12153112039918124, 0.002402876445054658, 0.002958507135217392, 0.001620811442931025, 0.007220262055093407, 0.0011945740313765718, 0.007345587463112535, 0.0014936584070636139, 0.00794538343136697, 0.005725605007608103, 0.06913274823088855, 0.06895387908244899, 0.07823869368397551, 0.06079446838286151, 0.11442972123653072, 0.0667487018573849, 0.047355066742195584, 0.0771930630772576, 0.0917045414048101, 9.999999999998899e-05, 0.0011298506428952804, 0.004839179388930637, 0.0004726214345959212, 0.00033483797424704864, 0.0036549670155247016, 0.00105833239151365, 0.0002937542656478165, 0.0028549520350925617, 0.07101034027888597, 0.06839699416338407, 0.07184190025233927, 0.07524851786660092, 0.07511347429869897, 0.0717494392394139, 0.0756143786845922, 0.06835034858617905, 0.06981860836266074, 0.3637083404846194, 0.3616456873084555, 0.3418211161036784, 0.3424822732631244, 0.34755150013374336, 0.34559924226573546, 0.35053944306023055, 0.3489150841707582, 0.35534496436438956, 0.10330613330488814, 0.09594699729882017, 0.10795722307771594, 0.09180568867416272, 0.11383950500567863, 0.10896861376282219, 0.1071099223330284, 0.09931961999334415, 0.09568928216899986, 0.15931594108971636, 0.17343939992136892, 0.18293658843117877, 0.18377107557387107, 0.19618235910132698, 0.16496426989521695, 0.15622670014010653, 0.1936326061821121, 0.15822851094650414, 0.2760702848010367, 0.25701420784534434, 0.25247092506985913, 0.25436612959749016, 0.25593600248294457, 0.2651611807817269, 0.2629688330495631, 0.25472583840654617, 0.25115690848905736, 0.19415098258805763, 0.1967133776106832, 0.20503178580473835, 0.20398600358482621, 0.19132995309008216, 0.18973240720092688, 0.19288114641362386, 0.19422133658482166, 0.20665966129780922, 0.21736422785670684, 0.19691105647579532, 0.207645620731835, 0.2166813408592343, 0.21530177520095684, 0.20218907267949549, 0.20496208728305532, 0.19565541962437405, 0.2355736100106075, 0.2191047879618031, 0.2089290957380885, 0.21751212954079924, 0.22456687855327495, 0.22122667732819667, 0.2104466277462661, 0.21999056924680638, 0.20846183893371262, 0.20880399072903288, 0.4454771631832838, 0.5106845284648078, 0.4711185256455289, 0.4653297954915916, 0.45037176913996946, 0.43832542982758504, 0.46495311211653634, 0.4751517283572527, 0.15619769044055143, 0.16726071108010476, 0.20241784105312122, 0.4247102968826807, 0.18802117681408015, 0.18020217388086235, 0.24747138970598115, 0.24722588564269854, 0.4102512878604856, 0.20476439204604402, 0.19114213174139305, 0.1759473630778341, 0.17608199200088204, 0.19661837853205444, 0.1795000481984016, 0.2192459952235779, 0.2316873409411463, 0.19689176525908125, 0.1881836113936155, 0.0818956327607695, 0.08660128369159759, 0.07951679164169745, 0.08580993865851705, 0.08497496217171485, 0.0797210705360385, 0.08220216982495587, 0.08009043706272878, 0.08839486465986879]}, "mutation_prompt": null}
{"id": "eea922ce-442a-45d3-99ce-d42f3429a6a5", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce dynamic elite size based on evaluation progress to enhance adaptability during optimization.", "configspace": "", "generation": 72, "fitness": 0.20886500967160881, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "8fae0779-26ba-4df4-bfa3-9ce3e7ce527e", "metadata": {"aucs": [0.371493579210765, 0.3631334195583519, 0.3642781763755053, 0.36955896844852554, 0.3989070428999102, 0.3596226451180835, 0.3860395642066149, 0.3531080923244768, 0.3491774258750071, 0.008284178564912481, 0.01497809776964587, 0.020554591072319606, 0.010358878613167866, 0.0001053476550205712, 9.999999999998899e-05, 0.027112964498734238, 0.023579014250931896, 0.004928762484722071, 0.10465675382920459, 0.10357658732155683, 0.11053825309774801, 0.10819725421864934, 0.10711848735450002, 0.11606699116923824, 0.10567880010302211, 0.10851136956343921, 0.1279352791852416, 0.08137300424121519, 0.09010833957159814, 0.09935546289461528, 0.09867674496596868, 0.09127977402326726, 0.09149727630846793, 0.09832035579581333, 0.08885271638293579, 0.09828378883067068, 0.9527355691848272, 0.9322295498072659, 0.9539046071385995, 0.9741678977251043, 0.9623589550951462, 0.9636722936920856, 0.9725883614332151, 0.9693976512203407, 0.9436878128168383, 0.22839010208040356, 0.23651277313657604, 0.22419526281893298, 0.22561425300833837, 0.22964001740073747, 0.22527360476355196, 0.22104216416154365, 0.2189285735543517, 0.2232389606491424, 0.40669385123404245, 0.3029544103875135, 0.31361963984495866, 0.30023559933270016, 0.24998754059238204, 0.298446474522463, 0.35191656953488204, 0.2957754916607912, 0.3052731310311867, 0.12742481281910512, 0.1148684105097949, 0.1256311033730444, 0.130907968936119, 0.12527397268241114, 0.1385404378713303, 0.13195433421071068, 0.129970933585568, 0.1216227002278294, 0.1316984749073259, 0.12185867120331839, 0.12744521055502078, 0.12393117761647432, 0.11975310039124065, 0.11713463260688173, 0.12513935205488957, 0.1304172383064338, 0.12426578724164106, 0.0053196640715108545, 9.999999999998899e-05, 0.0073236586993971065, 0.005065373040994525, 0.000540507264229384, 9.999999999998899e-05, 0.004658707540343698, 0.00010755846929100255, 0.0006752161330497719, 0.10743864654699242, 0.0826789615198621, 0.09081615447724967, 0.05406859921358975, 0.011307942706479834, 0.045391039837185065, 0.11066873432012236, 0.0906039486513881, 0.06666374515043427, 0.005421616427327192, 0.000373291079706517, 0.0003702054303171831, 0.0024252882711524038, 0.00033691696608961763, 0.000577755977475336, 0.0011534889455062647, 0.0010967460429779363, 0.0006664141480418051, 0.06556323040376044, 0.0627703485830099, 0.07303544764716885, 0.0667192343101024, 0.06937814062306902, 0.07309832241372483, 0.07014909427334881, 0.06769496979413303, 0.060717053090699524, 0.343833934860184, 0.350938265364641, 0.34825128444605147, 0.3526886056778038, 0.3683004313758236, 0.3609423430592287, 0.33990214145396336, 0.3584696287080633, 0.34333508418163405, 0.10456638102317461, 0.10714239846297346, 0.10250627956153857, 0.11204139943553859, 0.11125801059174978, 0.10810610724287872, 0.10681738668487473, 0.09361188968856082, 0.10996642379986388, 0.17471196942641887, 0.14403989642126724, 0.15625782796067456, 0.177837472743268, 0.1832761070970923, 0.21082638747050797, 0.17164863563270427, 0.19111710724222875, 0.17994212678180588, 0.25497352745742896, 0.2576887287542783, 0.2541623028215919, 0.25523566072886494, 0.2505745107510643, 0.25208306138460546, 0.25649165026160536, 0.25596892663428983, 0.25728211224719766, 0.20570447184569762, 0.1999257019647529, 0.19950989709434797, 0.1953489533946665, 0.1913614165847759, 0.20396418699249208, 0.20370025586603724, 0.20650251902037298, 0.1963373511944685, 0.22373929776196178, 0.20562189731868452, 0.20396428021331647, 0.21803410169762705, 0.2023866865847308, 0.19483931880047567, 0.20513684586430503, 0.191459036777896, 0.21257561018758353, 0.21592477110036057, 0.1919451147042841, 0.21222389203760494, 0.22224103765547265, 0.2170267468237942, 0.19381611086302974, 0.22247201230883729, 0.1957992114289947, 0.21347624521252073, 0.46110481589603824, 0.4888345566924376, 0.1762059010596153, 0.4967564193085925, 0.4534464623498127, 0.4913967756486314, 0.4733329910683983, 0.430251090360539, 0.4717234100437382, 0.4243437782879571, 0.19994620517373485, 0.40325726089342695, 0.43226625430591636, 0.19037801328595028, 0.4293087395348204, 0.20351005096011854, 0.3958111207052867, 0.20085884240114482, 0.17843174879793733, 0.18840446316185977, 0.18068403349640394, 0.17717722955274462, 0.20695399559421734, 0.17726901488055136, 0.19415407602985213, 0.1885306816883473, 0.18303284528549357, 0.08191920281127008, 0.08700847489414842, 0.09721372978678777, 0.07016451890677222, 0.09146050217232438, 0.077321047484327, 0.07952325776988489, 0.08997648787506352, 0.08030766538818479]}, "mutation_prompt": null}
{"id": "3fff50d7-4f34-4ce4-9ce6-79ab21de22d9", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def inertia_weight(self, evaluations):\n        return 0.9 - 0.5 * (evaluations / self.budget)  # Dynamic inertia weight\n    \n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n                inertia = self.inertia_weight(evaluations)  # Use dynamic inertia weight\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + inertia * (adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0)), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce a dynamic inertia weight factor in the mutation step to improve convergence speed.", "configspace": "", "generation": 73, "fitness": 0.20197003540160813, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "eea922ce-442a-45d3-99ce-d42f3429a6a5", "metadata": {"aucs": [0.36536565764041407, 0.35783418076384765, 0.36409003004927687, 0.3608683618437907, 0.3486014728754685, 0.3615019047856456, 0.37056876368892777, 0.3568057502005224, 0.3514658490778616, 0.019074875006184766, 0.011405817261093576, 0.029617311057274276, 0.012400884787471256, 0.028479914626822977, 0.004345328616235156, 0.021801164210032198, 0.014159497539593224, 0.004838922659641365, 0.10475521489759554, 0.1130184837176339, 0.1316613956482866, 0.10825180551301328, 0.11377048532040412, 0.1172040897189881, 0.12069644918880984, 0.1119340900043222, 0.11301743077161486, 0.10763564710562967, 0.08802849558199055, 0.09192796621610011, 0.09774806843263528, 0.08617685552628973, 0.09251277788638201, 0.1023900581666154, 0.09095831200299931, 0.10031790904817006, 0.9555196501281815, 0.957849152140676, 0.9624193436744948, 0.9369012987223305, 0.9725763634081936, 0.9682062368955586, 0.9725336263736061, 0.9504785604513128, 0.9550612776230745, 0.21622125608587917, 0.23011915013400108, 0.2352437115812137, 0.23436250987486995, 0.22281236252458336, 0.22909183173640268, 0.21954276107132653, 0.2244999885536194, 0.23563025252203074, 0.36196480971084377, 0.28497349704098596, 0.3351188953810038, 0.3826025033325292, 0.2994857007070637, 0.31636478529217804, 0.263272098395514, 0.2975082760742527, 0.2761789942332713, 0.11965065506512962, 0.12555047313568535, 0.12218255413708923, 0.13276197743070173, 0.11297275138026908, 0.12486892953852369, 0.13212760186066408, 0.12549926413727786, 0.12483656318939773, 0.12186881574682662, 0.12490114691874077, 0.11862475068442602, 0.1414825100587328, 0.11896043153098779, 0.12514007951988682, 0.13090379955343556, 0.13714570980481544, 0.1174635830171541, 0.008771678239601122, 0.007783683074553349, 0.00830148668921371, 0.0259111287384165, 0.001256786306453761, 9.999999999998899e-05, 0.012394312532440055, 9.999999999998899e-05, 0.0036508647894319957, 0.1017858194121698, 0.08208129679403464, 0.07206147480553338, 0.07187179983114345, 0.022583045086821185, 0.06706695816497199, 0.07536104816116063, 0.06673356249225781, 0.0731755593579353, 0.0006182758197581517, 0.0004317989789381915, 0.00010177879623785024, 0.0018322666999698312, 0.00014652129004477654, 0.0010292385198498177, 9.999999999998899e-05, 0.0012546530241299703, 0.0011797020745610842, 0.05887545206921552, 0.07084164948705096, 0.06695074310132698, 0.07931293965791542, 0.0662497260876278, 0.07186446170914351, 0.058067726330786384, 0.05854434095012184, 0.06827293772048537, 0.33507631567452834, 0.3350503815712943, 0.3574956907402427, 0.3661616308548947, 0.34305954213309764, 0.3374983344988469, 0.350440733587005, 0.3366523581507267, 0.34488884062141856, 0.09873698233665251, 0.10604155949350147, 0.10489881542815149, 0.09635440604286194, 0.09171276559961794, 0.10452828889369448, 0.09628490015105218, 0.1033781325106169, 0.09969201401179872, 0.20070383797947033, 0.19909112528841155, 0.19827079909356538, 0.19411675927395644, 0.1797069042907915, 0.1677248255537801, 0.18185316235125204, 0.18586509754893188, 0.16993470204774042, 0.248629286958711, 0.2583363235597397, 0.2645315857037903, 0.26010364751600334, 0.2577416133244921, 0.2537629529700025, 0.25915558761769997, 0.26244294761497666, 0.2572839748993412, 0.1921090218359195, 0.19910528425224416, 0.19432577361249148, 0.19193674457383214, 0.19657615434575926, 0.201117922491578, 0.20252249399874123, 0.1995344194436921, 0.19292152927919226, 0.1971011942656019, 0.20852912677999924, 0.21273291744440503, 0.2068470839856128, 0.20406136377194273, 0.21697696371490738, 0.19921091465124763, 0.18673930829260998, 0.20930148423659933, 0.2115873990900735, 0.22026479756617978, 0.22202517947136546, 0.21601266197536062, 0.21876910555566842, 0.20951019954351824, 0.19686176941136257, 0.210914075238251, 0.22284019100114105, 0.16518848287965027, 0.47645251759125296, 0.1835413484477988, 0.5215928292107725, 0.49028090165330773, 0.1693404126587268, 0.17627452586658654, 0.1929288387595126, 0.5122094048819442, 0.35630349885653156, 0.19358335552750405, 0.20234589282381754, 0.45710654924471283, 0.40159762227020623, 0.1975123103297456, 0.14985407570142228, 0.33747589861493166, 0.1486152600913092, 0.18453562045336636, 0.19346602993514928, 0.170269423509409, 0.2001341007025389, 0.19888018938754082, 0.18874754996087895, 0.1835534383419879, 0.19239798185069135, 0.18407645622844448, 0.07475987980082188, 0.08291081825128199, 0.0771975863607639, 0.07990006929919113, 0.0772481751824845, 0.0759499334987388, 0.08501955427174013, 0.07686545102456221, 0.08439332894645046]}, "mutation_prompt": null}
{"id": "ceb653f7-126e-4dd1-b7ec-8eee28bfaa5c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce dynamic elite size based on evaluation progress to enhance adaptability during optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eea922ce-442a-45d3-99ce-d42f3429a6a5", "metadata": {"aucs": [0.371493579210765, 0.3631334195583519, 0.3642781763755053, 0.36955896844852554, 0.3989070428999102, 0.3596226451180835, 0.3860395642066149, 0.3531080923244768, 0.3491774258750071, 0.008284178564912481, 0.01497809776964587, 0.020554591072319606, 0.010358878613167866, 0.0001053476550205712, 9.999999999998899e-05, 0.027112964498734238, 0.023579014250931896, 0.004928762484722071, 0.10465675382920459, 0.10357658732155683, 0.11053825309774801, 0.10819725421864934, 0.10711848735450002, 0.11606699116923824, 0.10567880010302211, 0.10851136956343921, 0.1279352791852416, 0.08137300424121519, 0.09010833957159814, 0.09935546289461528, 0.09867674496596868, 0.09127977402326726, 0.09149727630846793, 0.09832035579581333, 0.08885271638293579, 0.09828378883067068, 0.9527355691848272, 0.9322295498072659, 0.9539046071385995, 0.9741678977251043, 0.9623589550951462, 0.9636722936920856, 0.9725883614332151, 0.9693976512203407, 0.9436878128168383, 0.22839010208040356, 0.23651277313657604, 0.22419526281893298, 0.22561425300833837, 0.22964001740073747, 0.22527360476355196, 0.22104216416154365, 0.2189285735543517, 0.2232389606491424, 0.40669385123404245, 0.3029544103875135, 0.31361963984495866, 0.30023559933270016, 0.24998754059238204, 0.298446474522463, 0.35191656953488204, 0.2957754916607912, 0.3052731310311867, 0.12742481281910512, 0.1148684105097949, 0.1256311033730444, 0.130907968936119, 0.12527397268241114, 0.1385404378713303, 0.13195433421071068, 0.129970933585568, 0.1216227002278294, 0.1316984749073259, 0.12185867120331839, 0.12744521055502078, 0.12393117761647432, 0.11975310039124065, 0.11713463260688173, 0.12513935205488957, 0.1304172383064338, 0.12426578724164106, 0.0053196640715108545, 9.999999999998899e-05, 0.0073236586993971065, 0.005065373040994525, 0.000540507264229384, 9.999999999998899e-05, 0.004658707540343698, 0.00010755846929100255, 0.0006752161330497719, 0.10743864654699242, 0.0826789615198621, 0.09081615447724967, 0.05406859921358975, 0.011307942706479834, 0.045391039837185065, 0.11066873432012236, 0.0906039486513881, 0.06666374515043427, 0.005421616427327192, 0.000373291079706517, 0.0003702054303171831, 0.0024252882711524038, 0.00033691696608961763, 0.000577755977475336, 0.0011534889455062647, 0.0010967460429779363, 0.0006664141480418051, 0.06556323040376044, 0.0627703485830099, 0.07303544764716885, 0.0667192343101024, 0.06937814062306902, 0.07309832241372483, 0.07014909427334881, 0.06769496979413303, 0.060717053090699524, 0.343833934860184, 0.350938265364641, 0.34825128444605147, 0.3526886056778038, 0.3683004313758236, 0.3609423430592287, 0.33990214145396336, 0.3584696287080633, 0.34333508418163405, 0.10456638102317461, 0.10714239846297346, 0.10250627956153857, 0.11204139943553859, 0.11125801059174978, 0.10810610724287872, 0.10681738668487473, 0.09361188968856082, 0.10996642379986388, 0.17471196942641887, 0.14403989642126724, 0.15625782796067456, 0.177837472743268, 0.1832761070970923, 0.21082638747050797, 0.17164863563270427, 0.19111710724222875, 0.17994212678180588, 0.25497352745742896, 0.2576887287542783, 0.2541623028215919, 0.25523566072886494, 0.2505745107510643, 0.25208306138460546, 0.25649165026160536, 0.25596892663428983, 0.25728211224719766, 0.20570447184569762, 0.1999257019647529, 0.19950989709434797, 0.1953489533946665, 0.1913614165847759, 0.20396418699249208, 0.20370025586603724, 0.20650251902037298, 0.1963373511944685, 0.22373929776196178, 0.20562189731868452, 0.20396428021331647, 0.21803410169762705, 0.2023866865847308, 0.19483931880047567, 0.20513684586430503, 0.191459036777896, 0.21257561018758353, 0.21592477110036057, 0.1919451147042841, 0.21222389203760494, 0.22224103765547265, 0.2170267468237942, 0.19381611086302974, 0.22247201230883729, 0.1957992114289947, 0.21347624521252073, 0.46110481589603824, 0.4888345566924376, 0.1762059010596153, 0.4967564193085925, 0.4534464623498127, 0.4913967756486314, 0.4733329910683983, 0.430251090360539, 0.4717234100437382, 0.4243437782879571, 0.19994620517373485, 0.40325726089342695, 0.43226625430591636, 0.19037801328595028, 0.4293087395348204, 0.20351005096011854, 0.3958111207052867, 0.20085884240114482, 0.17843174879793733, 0.18840446316185977, 0.18068403349640394, 0.17717722955274462, 0.20695399559421734, 0.17726901488055136, 0.19415407602985213, 0.1885306816883473, 0.18303284528549357, 0.08191920281127008, 0.08700847489414842, 0.09721372978678777, 0.07016451890677222, 0.09146050217232438, 0.077321047484327, 0.07952325776988489, 0.08997648787506352, 0.08030766538818479]}, "mutation_prompt": null}
{"id": "a7ac6c02-33b6-421a-9acf-4f7145ad622b", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce dynamic elite size based on evaluation progress to enhance adaptability during optimization.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eea922ce-442a-45d3-99ce-d42f3429a6a5", "metadata": {"aucs": [0.371493579210765, 0.3631334195583519, 0.3642781763755053, 0.36955896844852554, 0.3989070428999102, 0.3596226451180835, 0.3860395642066149, 0.3531080923244768, 0.3491774258750071, 0.008284178564912481, 0.01497809776964587, 0.020554591072319606, 0.010358878613167866, 0.0001053476550205712, 9.999999999998899e-05, 0.027112964498734238, 0.023579014250931896, 0.004928762484722071, 0.10465675382920459, 0.10357658732155683, 0.11053825309774801, 0.10819725421864934, 0.10711848735450002, 0.11606699116923824, 0.10567880010302211, 0.10851136956343921, 0.1279352791852416, 0.08137300424121519, 0.09010833957159814, 0.09935546289461528, 0.09867674496596868, 0.09127977402326726, 0.09149727630846793, 0.09832035579581333, 0.08885271638293579, 0.09828378883067068, 0.9527355691848272, 0.9322295498072659, 0.9539046071385995, 0.9741678977251043, 0.9623589550951462, 0.9636722936920856, 0.9725883614332151, 0.9693976512203407, 0.9436878128168383, 0.22839010208040356, 0.23651277313657604, 0.22419526281893298, 0.22561425300833837, 0.22964001740073747, 0.22527360476355196, 0.22104216416154365, 0.2189285735543517, 0.2232389606491424, 0.40669385123404245, 0.3029544103875135, 0.31361963984495866, 0.30023559933270016, 0.24998754059238204, 0.298446474522463, 0.35191656953488204, 0.2957754916607912, 0.3052731310311867, 0.12742481281910512, 0.1148684105097949, 0.1256311033730444, 0.130907968936119, 0.12527397268241114, 0.1385404378713303, 0.13195433421071068, 0.129970933585568, 0.1216227002278294, 0.1316984749073259, 0.12185867120331839, 0.12744521055502078, 0.12393117761647432, 0.11975310039124065, 0.11713463260688173, 0.12513935205488957, 0.1304172383064338, 0.12426578724164106, 0.0053196640715108545, 9.999999999998899e-05, 0.0073236586993971065, 0.005065373040994525, 0.000540507264229384, 9.999999999998899e-05, 0.004658707540343698, 0.00010755846929100255, 0.0006752161330497719, 0.10743864654699242, 0.0826789615198621, 0.09081615447724967, 0.05406859921358975, 0.011307942706479834, 0.045391039837185065, 0.11066873432012236, 0.0906039486513881, 0.06666374515043427, 0.005421616427327192, 0.000373291079706517, 0.0003702054303171831, 0.0024252882711524038, 0.00033691696608961763, 0.000577755977475336, 0.0011534889455062647, 0.0010967460429779363, 0.0006664141480418051, 0.06556323040376044, 0.0627703485830099, 0.07303544764716885, 0.0667192343101024, 0.06937814062306902, 0.07309832241372483, 0.07014909427334881, 0.06769496979413303, 0.060717053090699524, 0.343833934860184, 0.350938265364641, 0.34825128444605147, 0.3526886056778038, 0.3683004313758236, 0.3609423430592287, 0.33990214145396336, 0.3584696287080633, 0.34333508418163405, 0.10456638102317461, 0.10714239846297346, 0.10250627956153857, 0.11204139943553859, 0.11125801059174978, 0.10810610724287872, 0.10681738668487473, 0.09361188968856082, 0.10996642379986388, 0.17471196942641887, 0.14403989642126724, 0.15625782796067456, 0.177837472743268, 0.1832761070970923, 0.21082638747050797, 0.17164863563270427, 0.19111710724222875, 0.17994212678180588, 0.25497352745742896, 0.2576887287542783, 0.2541623028215919, 0.25523566072886494, 0.2505745107510643, 0.25208306138460546, 0.25649165026160536, 0.25596892663428983, 0.25728211224719766, 0.20570447184569762, 0.1999257019647529, 0.19950989709434797, 0.1953489533946665, 0.1913614165847759, 0.20396418699249208, 0.20370025586603724, 0.20650251902037298, 0.1963373511944685, 0.22373929776196178, 0.20562189731868452, 0.20396428021331647, 0.21803410169762705, 0.2023866865847308, 0.19483931880047567, 0.20513684586430503, 0.191459036777896, 0.21257561018758353, 0.21592477110036057, 0.1919451147042841, 0.21222389203760494, 0.22224103765547265, 0.2170267468237942, 0.19381611086302974, 0.22247201230883729, 0.1957992114289947, 0.21347624521252073, 0.46110481589603824, 0.4888345566924376, 0.1762059010596153, 0.4967564193085925, 0.4534464623498127, 0.4913967756486314, 0.4733329910683983, 0.430251090360539, 0.4717234100437382, 0.4243437782879571, 0.19994620517373485, 0.40325726089342695, 0.43226625430591636, 0.19037801328595028, 0.4293087395348204, 0.20351005096011854, 0.3958111207052867, 0.20085884240114482, 0.17843174879793733, 0.18840446316185977, 0.18068403349640394, 0.17717722955274462, 0.20695399559421734, 0.17726901488055136, 0.19415407602985213, 0.1885306816883473, 0.18303284528549357, 0.08191920281127008, 0.08700847489414842, 0.09721372978678777, 0.07016451890677222, 0.09146050217232438, 0.077321047484327, 0.07952325776988489, 0.08997648787506352, 0.08030766538818479]}, "mutation_prompt": null}
{"id": "c5709277-2c57-4f64-9fd4-a7ef84a5b4d3", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n\n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def stochastic_perturbation(self, evaluations):\n        return np.random.uniform(-0.1, 0.1, self.dim) * (1 - evaluations / self.budget)\n\n    def adaptive_learning_rate(self, evaluations):\n        return 0.1 + 0.9 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))\n            elite = population[np.argsort(fitness)[:elite_size]]\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.1 * (local_best - x0), self.lower_bound, self.upper_bound)\n\n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n\n                adaptive_lr = self.adaptive_learning_rate(evaluations)\n                stochastic_perturb = self.stochastic_perturbation(evaluations)\n                trial += adaptive_lr * (stochastic_perturb + self.levy_flight(self.dim)) * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce adaptive learning rate and stochastic perturbations to accelerate convergence speed while maintaining exploration-exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.19634460079797483, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "eea922ce-442a-45d3-99ce-d42f3429a6a5", "metadata": {"aucs": [0.35145214664319036, 0.33664242715884307, 0.34170732371177726, 0.36498286645353195, 0.3420728299930347, 0.3486251771846042, 0.34406992353239196, 0.34176924718541113, 0.3410047475349385, 0.006374626174761033, 0.01798819253914119, 0.004302937358219072, 0.002927765438322294, 0.012674492989080521, 0.008746920747507492, 0.01463821909554408, 0.006980207717527276, 0.009690950801409248, 0.09611775869521022, 0.09101826994161621, 0.09566963035830356, 0.092448948421052, 0.11461137340053196, 0.102790017787033, 0.09646213953533789, 0.09415666456817273, 0.10353155072488152, 0.09907721727299035, 0.07826961295479595, 0.09159607474898912, 0.08616309936796773, 0.08184424097699083, 0.08380655471878595, 0.083375032625705, 0.08198316446714349, 0.09017304439741869, 0.9807822740146102, 0.9521445723871582, 0.9174074217520265, 0.9540367781288062, 0.9741097819066125, 0.9693911502094558, 0.9723175645465354, 0.9584321372230977, 0.9414460135440196, 0.21517084210218262, 0.2233519042827068, 0.22135577847819876, 0.21019038457286077, 0.2234036237970668, 0.21803604235730478, 0.2118836763802492, 0.2161340791046824, 0.21244749181273181, 0.2822286818982437, 0.25684929741871443, 0.2836166382958777, 0.2398392420196115, 0.2611602476452308, 0.2435402342138533, 0.28183401425218746, 0.2303880325335914, 0.25765710285378796, 0.11499553753752534, 0.1116888049706477, 0.11876353849641308, 0.12484796233399886, 0.1171419227555931, 0.1122236785680254, 0.12348751908012234, 0.13349976008897924, 0.12189383323138026, 0.12807970683715664, 0.1167492541519326, 0.12031038524646209, 0.11998461509392999, 0.13385509433005716, 0.12416608679404251, 0.12135540953461676, 0.1214496065655658, 0.11650121006827518, 0.004802369955572816, 0.007833696729144135, 0.007655474227981407, 0.0009576790832830362, 0.002167161297055853, 0.010074934160265503, 0.003999564245873444, 0.00029033343738282813, 0.010740927908220343, 0.07459082483506696, 0.06354359036543478, 0.0730593009399697, 0.05010903993289706, 0.04796282512359362, 0.08015356920386218, 0.13351361562693942, 0.0678645539535353, 0.10224033618129669, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06521233230034063, 0.07449186116461481, 0.05533358053601756, 0.06281067501393534, 0.0675814907472071, 0.06486203051044181, 0.07458904820051726, 0.050632398625468866, 0.054982035651298444, 0.343026477287694, 0.3330134197383803, 0.3331667884734093, 0.3308884297652881, 0.3382118821703094, 0.3532120030672925, 0.33973407083597884, 0.3263658629194539, 0.338059579250636, 0.09430096264204568, 0.0972243489986897, 0.10556372617802989, 0.09530570534829863, 0.0926896809129607, 0.09313600912503739, 0.0982923338898476, 0.10961625784722162, 0.10358169857724664, 0.1713084212730357, 0.1738005434070803, 0.15397336006230944, 0.1619304361581524, 0.19272285098161968, 0.1526911151664273, 0.15406702863525612, 0.162107463696887, 0.17101715011462926, 0.25504063234549534, 0.24451130899934292, 0.26003443250852787, 0.24261282337029944, 0.2530760406073733, 0.24692943375626353, 0.24618628288277655, 0.24282752231423854, 0.2546337987822178, 0.18185750996749717, 0.1864430054314219, 0.20109252153230472, 0.18712329778902936, 0.18545716355906727, 0.19117706109525834, 0.20133464190829242, 0.1854248905854522, 0.19219173441944937, 0.19675679520990086, 0.19886994144463244, 0.20159699538159603, 0.1913321461942754, 0.22218113390751082, 0.20305484755000347, 0.21917851886509354, 0.20744005473264826, 0.1959556687781976, 0.18678760613412637, 0.20656005393649346, 0.2066503453212909, 0.2102984569755585, 0.20078519069772605, 0.2070163025915095, 0.19610650676479224, 0.20618686578877587, 0.1817222039955535, 0.4299434370973112, 0.42272649708539256, 0.1837633653762012, 0.43948122068756446, 0.4477325880445634, 0.4127477035996131, 0.4516318211292273, 0.43789128465163163, 0.3924944958267208, 0.19823371995971595, 0.19962865065245328, 0.19476505948388967, 0.3968732596093971, 0.1662033500344542, 0.36322307997867587, 0.15017612721348328, 0.20265656761054074, 0.2042136140529659, 0.16708810536890628, 0.17993363210072566, 0.20845630501878842, 0.18435561101832032, 0.19516410930957873, 0.18388722256564582, 0.17949007547894946, 0.1933751159449063, 0.21670123772318406, 0.07424658392191597, 0.08389207244349706, 0.07900595311087688, 0.07768954910587778, 0.08657424542523207, 0.08655138558658981, 0.07978983782085614, 0.08577022565925041, 0.0757857394229473]}, "mutation_prompt": null}
{"id": "1907b2f4-1f00-4b56-afb6-460f1935fcbd", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Refine mutation strategy by adjusting local best influence and enhancing exploration control, maintaining solution diversity.", "configspace": "", "generation": 77, "fitness": 0.20901069431804567, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "eea922ce-442a-45d3-99ce-d42f3429a6a5", "metadata": {"aucs": [0.3656863192480836, 0.35047640968608496, 0.3655258886920847, 0.3714238004510787, 0.3574089004604364, 0.3671011753127972, 0.3678436613171293, 0.35714341738107447, 0.3717598231468744, 0.002812219038872854, 0.015665608789383056, 0.03559379030489107, 0.02576159379941423, 0.020012780258030216, 0.00010043168246343104, 0.020749766874525677, 0.01817324472261972, 0.02125605275916731, 0.10811126176429098, 0.10245652656951565, 0.11074438205077908, 0.1113169927012374, 0.11459778913641416, 0.10489925854562077, 0.10199874534067765, 0.12039935317263772, 0.12010596389583295, 0.09918852969591985, 0.08970823009585516, 0.08926124147783943, 0.10021902335055133, 0.08923847041353461, 0.10870141262894828, 0.09473582852136386, 0.09206866683556114, 0.09157914808287893, 0.9659344283757979, 0.9466145003846345, 0.9461187204397337, 0.9739683337737125, 0.9727179138122544, 0.9684538410673987, 0.972711905268692, 0.9675938466419599, 0.9431988035529123, 0.24278025641468493, 0.23606822351581436, 0.22543262774140427, 0.2423278848572774, 0.2249807662414468, 0.23524626903213286, 0.22792308027728725, 0.22488683695923062, 0.21975199528266431, 0.37099860333287327, 0.31761109290216105, 0.3435206088725131, 0.3209182114040171, 0.31853182013115333, 0.3236851713256861, 0.35277436472638546, 0.34846201212016026, 0.29896509977594676, 0.12777548298807673, 0.11661498469868226, 0.12591411879045444, 0.11803946580478109, 0.11952102920859542, 0.13108424832476373, 0.12441072421948429, 0.1335520975106208, 0.11837480777533471, 0.141696596443331, 0.13730988841528102, 0.12746270292088024, 0.12453097945420455, 0.13676195110965927, 0.12846764138852018, 0.117841691670722, 0.12141492032566059, 0.12258477838792825, 0.01588993182296705, 0.001485975210982704, 0.002705377426386102, 0.013657431850455204, 0.02013695407854066, 0.008965883016678, 0.007018825768758452, 0.009242224747246452, 0.030006471091093, 0.11301627866364738, 0.04951913192234714, 0.09846514712192078, 0.05765995504778676, 0.00020893362257390358, 0.05063066736217625, 0.09201993362488525, 0.08914086375050534, 0.19084126699700932, 0.0032560053974480807, 0.0011540230313378252, 0.002277496540388557, 0.0013140409124305918, 0.0004944835548991167, 0.002410549987164945, 0.0010703204838864444, 0.0021364023191510206, 0.0014763844279884752, 0.08335417717949112, 0.07015070399419165, 0.06762054341477164, 0.07594603707584535, 0.07225095028109085, 0.07271208212616476, 0.059719829144447845, 0.06739286257277821, 0.0707250115172019, 0.36049900110999755, 0.33656365013295486, 0.3481220871521117, 0.35327475917458495, 0.3448406200530134, 0.34047224353591743, 0.34774470973177574, 0.3517282702411437, 0.34197194410078113, 0.10339436467950147, 0.09565574380154174, 0.10299101354429874, 0.10430270224589056, 0.11223831529538564, 0.10256580533035142, 0.10308930836927321, 0.09745034141494324, 0.10107100480099385, 0.18274508922375376, 0.1713011114112012, 0.1456886066100589, 0.19922129155112578, 0.1437561634931095, 0.22874456951938427, 0.18137496785461327, 0.1623768173535305, 0.1700893667617942, 0.2612003935285897, 0.25864241793133935, 0.2530211740990741, 0.2582459140473303, 0.26775374843317146, 0.2568414312934032, 0.2601276199370651, 0.2619832930953109, 0.25260300628845844, 0.1982009207814025, 0.19605194992195707, 0.1960858138221453, 0.20691788002713463, 0.19407893809178423, 0.18095132809537895, 0.19975966199230744, 0.21321150014258128, 0.20766166730134294, 0.1988648777027443, 0.21411654385861023, 0.24080442270407587, 0.18235036003256233, 0.20966812628453413, 0.19503393298938643, 0.20215571788830144, 0.21676650110769957, 0.2049174854259631, 0.2030743030133051, 0.19367338906484233, 0.2140364555279527, 0.22287374576218422, 0.21657333877713514, 0.20967074563470012, 0.2304945827163376, 0.19127557975597176, 0.22364314831320153, 0.467893896350838, 0.175896614449234, 0.4752259455736225, 0.488957660052036, 0.17989397760182524, 0.18552016810250194, 0.44586708354394533, 0.4662555837237976, 0.5070750189965041, 0.16389909733580676, 0.43908886919738166, 0.3560450294554971, 0.4109576078981987, 0.37084341039675983, 0.29583215761726733, 0.35271184816957823, 0.42035162010443905, 0.14622988852041507, 0.19707918439907635, 0.20005584127928955, 0.1747770749148343, 0.2051845149579007, 0.19131788533071448, 0.18991557131601822, 0.17623818555620296, 0.2021193823220212, 0.18900506685185614, 0.07779147615133153, 0.08523681047701281, 0.08086817048029515, 0.08153861775450733, 0.08412850124435989, 0.08683059479441924, 0.07911715722940282, 0.08649172598972632, 0.08802875771890517]}, "mutation_prompt": null}
{"id": "6033b1bc-fe8a-41aa-bb4a-8001edf52d23", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            stochastic_perturbation = np.random.normal(0, 0.05, self.dim)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)] + stochastic_perturbation  # Use elite with perturbation\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Integrate stochastic perturbation into elite selection to enhance exploration while maintaining convergence control in black box optimization.", "configspace": "", "generation": 78, "fitness": 0.20280386166614064, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "1907b2f4-1f00-4b56-afb6-460f1935fcbd", "metadata": {"aucs": [0.3579932728852797, 0.35150756392166604, 0.3708829946994071, 0.36303303977194046, 0.36231535660401715, 0.3732720262083843, 0.35978603715483126, 0.3626096828689892, 0.3738148323698949, 0.017472045425385496, 0.017225876118472483, 0.017654514354457196, 9.999999999998899e-05, 0.011976887153016702, 0.0062672977169857536, 0.023865432929657038, 0.026150339198705685, 0.01514376872964307, 0.10961922237387844, 0.10493038711922142, 0.11705617524997491, 0.11857065544042111, 0.09903789382243033, 0.12080062595146301, 0.10180824447625614, 0.1114174877278834, 0.09781064395842753, 0.08786868206428955, 0.09094792820874986, 0.08903530979310037, 0.09345710683323682, 0.09942518489553809, 0.09017800530480202, 0.09778025101702315, 0.098844093618081, 0.10053188492115117, 0.9727766637566484, 0.9791218747271011, 0.9589470238178746, 0.9795685040332452, 0.9468636120009367, 0.9675725485689496, 0.9696382933642432, 0.9475973449357711, 0.9801125035903845, 0.23620637376673514, 0.23134305723340653, 0.22338743722232013, 0.23665997121260662, 0.23365727226966482, 0.23105786278677964, 0.23020634383306382, 0.22025239531842833, 0.25139087934102144, 0.2964339868281394, 0.3689176061272723, 0.3036839897832554, 0.3294897908514318, 0.3167194451927836, 0.3255909948462298, 0.28630692046311024, 0.27299000890262515, 0.277750644416317, 0.12524421148524356, 0.1391817655610501, 0.11494664428030177, 0.15585104280206874, 0.12367664952727975, 0.12540371368609193, 0.12002579382853107, 0.1176652066377395, 0.13943963171551643, 0.1356782127897046, 0.11736024207114404, 0.11273961917436504, 0.11679652789873995, 0.11248414002313933, 0.12064008220792455, 0.11947224333768758, 0.1249911619773606, 0.13662026210713174, 0.010767541448014728, 0.01168268228240954, 0.004562781528654192, 0.009632092002353598, 0.012881309997059165, 0.0014791382204615289, 0.0061706768410300095, 9.999999999998899e-05, 0.01803483208046619, 0.09174797504784094, 0.08734836731169127, 0.09634130643432759, 0.03614956863917085, 0.05973165950882864, 0.0525047590023312, 0.08768323626463936, 0.1430963671580272, 0.10022162289413794, 9.999999999998899e-05, 0.0009864091325006985, 0.0030542584028989683, 0.0026643667050437747, 0.0017980983171480558, 0.00025789020939426255, 0.00027307206548865537, 9.999999999998899e-05, 0.0010719239389574975, 0.07213859356732888, 0.0695524880502506, 0.06943311870414404, 0.07950481714455815, 0.06660378694658975, 0.07693057678146109, 0.06342684775498675, 0.06927716689529806, 0.06368367555756849, 0.34748790810908003, 0.34914121920481556, 0.34105975211922424, 0.34128199582010543, 0.34496494030997593, 0.3382902658083692, 0.3553995733572253, 0.3477069219549108, 0.35129822334674154, 0.10450916775925811, 0.11631056891729752, 0.10265631021739552, 0.11224087035765473, 0.10521348696007315, 0.10376949528973745, 0.09977137393565116, 0.10569146060397439, 0.10360269033326153, 0.15268167603474847, 0.1555287490130708, 0.1668499845732202, 0.1650634912844795, 0.19121703390145206, 0.16761506088470812, 0.1948835651057279, 0.1825650711511958, 0.1732786531005629, 0.26045301838101076, 0.2572863568471384, 0.2567103754812664, 0.27536146848815, 0.25579950274724583, 0.25199751887770105, 0.26022039731941793, 0.25644690754072563, 0.25531581924369273, 0.19996971597402913, 0.20028387398239134, 0.19749646164217272, 0.19448779747824751, 0.19601460687727135, 0.19686155362205804, 0.19149703882380575, 0.19762533697712792, 0.19680463572980111, 0.2261346540143102, 0.2044136872014629, 0.1974610502528722, 0.2158174381229261, 0.21049465302864379, 0.23024444172412628, 0.20204920237819846, 0.22475641022715198, 0.21601478411609476, 0.21553294223821584, 0.21656241507386298, 0.2256926656927919, 0.2174102302285743, 0.21548312875681508, 0.18731577296379665, 0.2128755331608181, 0.21583863607673526, 0.21215642841386995, 0.17550442079905515, 0.17452373553407852, 0.4541430781855059, 0.5163310999859508, 0.5372423002894955, 0.17218075797654897, 0.4356701927997285, 0.4673932079782288, 0.1636375742279812, 0.34237374429135736, 0.19703206282015495, 0.38705380125661104, 0.1645024536949986, 0.16786564428935546, 0.4472562315370857, 0.15014184435578048, 0.15026637650893304, 0.20484566891637446, 0.1811842605795282, 0.1936976332800231, 0.19490131639969388, 0.1753402110879846, 0.17670910230047154, 0.17993178436593793, 0.1723687507065762, 0.18513039824684518, 0.17872113649612642, 0.08434764860150679, 0.080071427289227, 0.08504738486993169, 0.08010494147695535, 0.08671243027422593, 0.08434187020197537, 0.07937539183682818, 0.0903532791127829, 0.07872073013100178]}, "mutation_prompt": null}
{"id": "f8a11b32-a0c3-4d07-88f3-e127d9a134bb", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size):\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha))\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(4 * (1 - evaluations / self.budget)))  # Improved dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce a dynamic elite adaptation strategy to enhance exploration and convergence speed.", "configspace": "", "generation": 79, "fitness": 0.20582297895877458, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "1907b2f4-1f00-4b56-afb6-460f1935fcbd", "metadata": {"aucs": [0.3536045019932076, 0.3648058625843966, 0.35280115141449975, 0.3812333753597855, 0.3564681066136559, 0.35302887341522093, 0.3628860747928324, 0.3618525154416955, 0.35728768338285366, 0.033674758692164186, 0.017095578369860975, 0.014065601320299215, 0.01635863209347621, 0.01188088479615923, 0.00935578095269829, 0.026463433452671103, 0.01598740543988575, 9.999999999998899e-05, 0.10376126896631854, 0.10267203463150998, 0.10744704334157618, 0.10313441458848027, 0.12078466460391413, 0.10901949289624135, 0.10768791467622918, 0.10649400344806437, 0.1223625678517023, 0.09803609375787203, 0.09433324346548722, 0.09822497267125363, 0.08966373477375855, 0.08685954483660696, 0.09712914356088564, 0.08563431136313193, 0.09460413891165842, 0.09890903685985919, 0.9518000748280785, 0.9634090665255552, 0.9623926852003819, 0.9544113927424578, 0.974923213359483, 0.9542355847653737, 0.96138877431866, 0.9584635725610248, 0.9599802198797757, 0.22754335539128412, 0.23216864696999084, 0.22183370238904732, 0.22779036546783316, 0.22652058524699048, 0.2260183932884834, 0.22067463233876883, 0.23235456612910377, 0.23228967589683447, 0.31120700787110067, 0.3781201237513222, 0.3152300466573019, 0.3793879542874522, 0.3325288985879339, 0.2738510640075247, 0.29884152990927315, 0.3181588608468955, 0.3028003456381414, 0.113613671451253, 0.11891747939267461, 0.11913774505679597, 0.12381054014329496, 0.12629068931206033, 0.11764983128870043, 0.15543525457829344, 0.13594094969363757, 0.12325091957948331, 0.11907800869291219, 0.1623245889966891, 0.12708749235539785, 0.12018714825741594, 0.12216113395739447, 0.12208848574726672, 0.12058395606761407, 0.11953969370183093, 0.1201432484604329, 0.006759950808619242, 0.0014899224089296448, 0.009716080419949313, 0.023904359366792916, 0.0029738216293808684, 0.012491652903666162, 0.00010162389429602126, 9.999999999998899e-05, 0.010699512094772379, 0.10026902113019365, 0.054108654344802165, 0.07493747843182375, 0.06826380083872974, 0.11454932983350119, 0.042759541293773684, 0.10089346724942694, 0.11590447086076439, 0.11695695279192164, 0.0012872362768977519, 0.0014247822054929138, 0.0006914654754547334, 0.002107523528500188, 0.0003622699769688653, 0.0014306457864505795, 0.0001731983920475466, 0.001359799497372638, 0.0007152128446574757, 0.06975812770750489, 0.0659053904238377, 0.06316329982812097, 0.09819567459706291, 0.07006668742374877, 0.07075032242795898, 0.06535843860706281, 0.0740308496310903, 0.05692944216208229, 0.3505166669515791, 0.3435404647581488, 0.34054276909316006, 0.3446258547925425, 0.36937653163384554, 0.36545107198235327, 0.3466790491333168, 0.3395540835879568, 0.3460275658420513, 0.1025080340749539, 0.10576710292251079, 0.10513363094932815, 0.09839098800829693, 0.10838829560423147, 0.10114498487608548, 0.10280843466092027, 0.10632828733457267, 0.10044034330513874, 0.1865712819722125, 0.15820270688090754, 0.15983143101658792, 0.18410506640825552, 0.15284193291227188, 0.15299919319241584, 0.1836251541736661, 0.17569114632249128, 0.17214873814397214, 0.2571571548735794, 0.25488336619087526, 0.2620652829502046, 0.251261522871685, 0.25922108835080604, 0.2496641531163727, 0.25997199242219327, 0.26171547869205913, 0.26189890527760695, 0.1993743166528853, 0.20794188509509903, 0.19022774898332018, 0.19606535963787397, 0.18885492412416516, 0.19248708384110025, 0.19379124771679712, 0.19720128996037423, 0.19378543310528507, 0.2058140935297883, 0.1966261527498374, 0.20443172184548442, 0.22003764574793994, 0.21445843020906674, 0.19575582754369525, 0.2115733408723901, 0.19659220507854513, 0.19870427983120653, 0.21483146540968912, 0.1978597476348386, 0.21717583670264728, 0.1887210294257261, 0.19312014620408768, 0.19758212693019628, 0.22168414940018277, 0.21291691880887342, 0.20266713493479716, 0.4916041219122501, 0.17856048365071597, 0.4089447537387717, 0.5080203125192395, 0.18362511044828045, 0.5029508929822604, 0.4255293061166542, 0.4807823918399087, 0.18120443548399467, 0.40551541183426465, 0.19774413731615004, 0.3296024283727256, 0.19235646626701797, 0.3604271991411079, 0.42447714285757665, 0.14992914623450448, 0.4470959994473592, 0.2040902259201982, 0.20092292966613534, 0.1730537612604014, 0.19571947867998385, 0.18246667880395828, 0.19169436124160855, 0.1878741761129128, 0.19484761476204204, 0.18738620484494084, 0.17462120236290535, 0.08210164468050729, 0.08125463225759855, 0.08281306043261738, 0.09465116075403435, 0.08635509529338692, 0.08380663841602798, 0.07959461548761793, 0.07654947835425951, 0.07636643034355672]}, "mutation_prompt": null}
{"id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 80, "fitness": 0.24291511338994784, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "1907b2f4-1f00-4b56-afb6-460f1935fcbd", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "6f718683-d4a1-4f7e-8150-60dfad49ff7a", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                # Probability-based elite selection\n                elite_prob = np.random.uniform(0, 1)\n                if elite_prob < 0.5:\n                    local_best = elite[np.random.randint(0, elite_size)]\n                else:\n                    local_best = x0\n\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Enhance convergence by introducing a probability-based elite selection mechanism for mutation.", "configspace": "", "generation": 81, "fitness": 0.23406384208346342, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.43445598920717576, 0.43339621364339964, 0.43517985798785397, 0.43724752824185775, 0.4356654833281205, 0.43229947967415705, 0.43372486611009153, 0.436412689941409, 0.4272438534779479, 0.03851936261412481, 0.06124720753327251, 0.027982996147291495, 0.04327972634282118, 0.0728059057403112, 0.037469648003647715, 0.030101491239108658, 0.0617292317290834, 0.06485167694419669, 0.1757854896074772, 0.12049478809280567, 0.17398505226262806, 0.1672465189405672, 0.1309947494498569, 0.12326252896732659, 0.17123491833768223, 0.17034731246618995, 0.17028834854118247, 0.09839075379665774, 0.11371320415335595, 0.14991764892791726, 0.11115907710086814, 0.106554381071854, 0.09337911833041412, 0.10087614550329416, 0.10713516533027345, 0.11254745970461577, 0.9589037360320206, 0.9448835879191135, 0.967712355532936, 0.9608605095782182, 0.9513985714479611, 0.9636539118991359, 0.9646640054399814, 0.983891141970065, 0.9478227916445935, 0.2849246553300696, 0.29312727308240827, 0.28085261023411545, 0.2814976695660173, 0.28180571056531967, 0.27791850053254163, 0.27746090720892447, 0.2844595527451619, 0.27700784530752276, 0.5084977930906582, 0.4729559898301805, 0.4390512809470529, 0.4594928357046333, 0.23680407449286855, 0.45501186006691485, 0.4800758000983715, 0.4649550853834846, 0.4362472589957028, 0.14079040131671094, 0.14054153190023333, 0.13940434872163676, 0.13375115219384337, 0.12888148592754844, 0.12862904654478657, 0.12868396556905537, 0.1327876664752623, 0.14557556017768403, 0.15327543802686905, 0.1378986613077725, 0.15435250586947036, 0.1255988660135252, 0.13700802075186425, 0.13945338777724048, 0.13141531128946504, 0.15093546911750078, 0.13398390216634848, 0.033015775402625014, 0.021871183870493915, 0.018414178103942525, 0.006508220643506646, 0.025602383908975734, 0.03358167252875388, 0.01679983304325594, 0.039739796322947774, 0.015953322013481208, 0.11303037301428853, 0.07147932422059822, 0.0982328364656807, 0.07189356018919935, 0.062306744614428644, 0.030971023740602344, 0.100606020954365, 0.0861367755563921, 0.0915697144830303, 0.009746047338124897, 0.006115992606595344, 0.004400269207387231, 0.02291654253822617, 0.019123831208049724, 0.02150609695666794, 0.015669683754626962, 0.018741061475037513, 0.021918787172922394, 0.10043708223156622, 0.10007893967701476, 0.08534912341195611, 0.10222636575838495, 0.08552749738151288, 0.10568910374828888, 0.0865406334767258, 0.09103681137494901, 0.07804872911415461, 0.38533945372996736, 0.3897828574240819, 0.3955416642347659, 0.3885855104478666, 0.38882494031385795, 0.37938640593072837, 0.4098641053782546, 0.3904414790090138, 0.39106321990330006, 0.12979121679535843, 0.10986951093128028, 0.175395117227224, 0.12385405757660106, 0.11846285579642502, 0.10960083222596007, 0.11421373005679814, 0.16402925067396024, 0.12647055292067033, 0.23000485740486853, 0.18348538534515824, 0.19425262993320536, 0.2304377125690441, 0.19587207625992054, 0.2351590259441435, 0.1744693234485437, 0.15514798195656876, 0.19490397425756933, 0.28735194574050327, 0.28755277243331956, 0.2944485687340438, 0.2909195278489709, 0.2852330320536648, 0.292500756559432, 0.2927864770849564, 0.2952370375634419, 0.2945478268707248, 0.22388781547510195, 0.22125322345148546, 0.22411949458258096, 0.22998107826644532, 0.23266957928875887, 0.22309809743062148, 0.23067429224186542, 0.23929956890212312, 0.2338800644025386, 0.19518128704502236, 0.19144012578266478, 0.18516720085993954, 0.19118579301577543, 0.1967050551475521, 0.2158158065610185, 0.19735157403038495, 0.20651425734190632, 0.24530741471526984, 0.2824232535549026, 0.27861150914176, 0.2811972574474063, 0.18604510333683377, 0.20666634030969366, 0.2846847187271544, 0.2940975155951495, 0.2853559579484025, 0.2914670444019748, 0.19617818311087265, 0.5687910829175766, 0.5855787377845741, 0.6054531528043707, 0.18328853760283115, 0.5844765351636819, 0.5636967078274784, 0.18327046035947892, 0.18100577220243386, 0.5418617548927268, 0.5284414729520626, 0.5017369538879333, 0.1637514359127219, 0.16607810320174865, 0.4088946798838622, 0.20571431443019805, 0.1507713237183731, 0.20713223018723714, 0.18694466585211356, 0.1854200853174124, 0.17969379140698893, 0.17839468347335719, 0.19312459106756485, 0.1807473200639581, 0.17808203642809328, 0.1668285662873017, 0.17970878296423365, 0.08416282977031275, 0.08092995828671878, 0.08414791809270539, 0.08124453932629572, 0.08403523760119624, 0.0819983955334388, 0.08326596867321368, 0.0900787749362062, 0.08133696272590873]}, "mutation_prompt": null}
{"id": "5166dcc9-1811-4e3f-bd66-e52ac914f65a", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "7492d18f-fc21-43a2-beb3-d22d2a857af7", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "cd78c2ae-f315-456a-8f1a-84fb9ec268bd", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "cb305472-1018-479b-ad45-bfd63f47a621", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n        self.chaos_sequence = np.random.rand(self.population_size)\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def chaotic_sequence_update(self, evaluations):\n        self.chaos_sequence = (self.chaos_sequence + 4 * self.chaos_sequence * (1 - self.chaos_sequence)) % 1\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            self.chaotic_sequence_update(evaluations)\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))\n            elite = population[np.argsort(fitness)[:elite_size]]\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]\n                chaotic_mutation = self.chaos_sequence[i] * (x1 - x2)\n                mutant = np.clip(x0 + adaptive_f * (chaotic_mutation + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Incorporate chaotic sequences and dynamic adjustment of mutation strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 85, "fitness": 0.2321717826270809, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4576863973894013, 0.44292334999049376, 0.44189911002893, 0.4380426519143541, 0.4315136241418527, 0.43733151178719176, 0.43017504019617003, 0.4431052088464278, 0.4420218090229884, 0.028709059833844863, 0.019458765851686266, 0.07220248469672075, 0.08341022400597153, 0.07033981688397994, 0.04436647776860192, 9.999999999998899e-05, 0.021604126876467178, 0.005591014479330858, 0.12701373690360906, 0.1755300458949105, 0.12494742465371711, 0.12202058874299349, 0.12981753182066147, 0.11953646380419103, 0.12621542717509715, 0.17148217207570593, 0.17511723780722954, 0.10471227126588512, 0.11121177407673755, 0.11380826183699355, 0.10195222864394504, 0.11915071460135984, 0.10663798823984905, 0.11088288967029425, 0.10800465040244267, 0.10496938516894372, 0.9551319752456826, 0.9547096603574798, 0.9607289432671713, 0.9571201607894262, 0.9820190615779911, 0.9685895233179007, 0.9654220767077812, 0.9415581176155872, 0.9580284149820298, 0.2950734183494208, 0.28451382568000394, 0.28755600569288364, 0.28609052453536443, 0.2791740318175354, 0.2943179797077383, 0.28695094500553975, 0.29343835435075416, 0.2768203530112977, 0.5263489500067444, 0.48406333966013837, 0.47393860976244273, 0.29389996016180653, 0.46384681466657596, 0.4068507926015298, 0.4759449118922716, 0.4701422160877823, 0.28233448170507913, 0.13345257803137078, 0.15233952503349368, 0.14782107272275424, 0.13713264253480406, 0.1332130670642564, 0.1413367635834527, 0.15048713919706336, 0.13552213989903716, 0.13567310458310222, 0.15569953921112922, 0.13642345850313597, 0.147746583933968, 0.1436807452745048, 0.17183739936192055, 0.14377790593993633, 0.14345661042482916, 0.15754847143682904, 0.1357470909919013, 0.03984593674676129, 9.999999999998899e-05, 0.0437822242708773, 0.007740243728316054, 0.042564061730941294, 0.009525593123320353, 0.022794549795191243, 0.0014179830861908993, 0.022633325027862528, 0.1069333824160219, 0.05354972992051976, 0.08978450438322993, 0.06514606756871921, 0.03287947157332782, 0.11970056413892638, 0.09418243170339302, 0.10374788300364524, 0.07213042370037948, 0.0267067122720428, 0.005124126890231118, 0.01903152342608372, 0.0169412647620355, 0.01364403314350271, 0.0170563679096154, 0.020411510551240686, 0.023104790959837418, 0.01542686061835652, 0.09499856270247142, 0.09506269683609792, 0.10577511113966898, 0.0997003348720531, 0.0971674241161663, 0.10560762005153934, 0.0982133127197129, 0.10059372211501871, 0.09940916295696423, 0.3876390027234079, 0.40102536450611836, 0.3885998695607277, 0.3963847741433595, 0.383866520469445, 0.40309425589047077, 0.4057217365563135, 0.3959846346043634, 0.4054683931616567, 0.1194583987483957, 0.12237453008933863, 0.10105173371414422, 0.1168949781018398, 0.11114728742930724, 0.11862654083883395, 0.12443655214056326, 0.10837903992034004, 0.12239366084387637, 0.2047355027633294, 0.2590519057420242, 0.18865830653152782, 0.22280656641117935, 0.24786003983961868, 0.23781973236482723, 0.26088832841764487, 0.2563102467283296, 0.24536680124484822, 0.28471458744385614, 0.28549743584588483, 0.2887036891917034, 0.28825363908965496, 0.29118054306869645, 0.2897939740964611, 0.29820568051957097, 0.2948693201315806, 0.2937130391103968, 0.2316210644514909, 0.23332363190733796, 0.23448098391076588, 0.2312668931262125, 0.225626427161306, 0.22709897837208604, 0.2266506502295369, 0.2407418732913582, 0.24132795231451887, 0.2105518422794106, 0.22572744067418815, 0.20123056661151595, 0.22239613316466222, 0.21770341798617188, 0.23754561111021044, 0.19385565632838508, 0.20527200455068595, 0.21864688385309483, 0.2142379541112419, 0.29843960973217865, 0.28782528454935896, 0.27874348427661555, 0.2847049689112825, 0.19886381068024428, 0.28737438759982414, 0.2880384875218335, 0.20049005347614468, 0.18361864871052525, 0.19952671565607816, 0.1813617775589006, 0.5992402027195831, 0.1939331863468282, 0.6116997116351381, 0.1575053975784515, 0.6094928175592819, 0.5977566627436282, 0.5850451753787085, 0.19542768741654426, 0.20402560452204432, 0.2017771767283878, 0.16657882474381347, 0.20667831980787066, 0.10351705335623751, 0.5090035770399884, 0.20618359374880257, 0.18942751554792148, 0.17614795641283165, 0.17801911228901846, 0.18769680309853043, 0.20245703524180825, 0.18276604756361414, 0.19141422584984813, 0.18699215055827423, 0.19592942977593952, 0.07985915070548855, 0.0880263016356464, 0.08380008250073245, 0.08790934806027051, 0.07835310341954516, 0.08988624891678465, 0.08235292390506166, 0.09470773349577599, 0.0927908143135806]}, "mutation_prompt": null}
{"id": "3adc9709-a8e8-42b5-b2ea-34c8ed71fd85", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce controlled elitism for better diversity maintenance and convergence balance.", "configspace": "", "generation": 86, "fitness": 0.24291511338994784, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "22d3b280-7fc0-4457-8130-6092dc038226", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "bf1a8722-42e9-42fc-be8a-1825a2d52867", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "59c2eaa2-ef25-4363-8777-9d1d5ecc5d6c", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "97fa4efe-651e-42cf-bd35-26b06f1edfee", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "02048cfb-f36b-4bf0-8d4f-8401fb1a031d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            if evaluations % 100 == 0:  # Dynamic elite injection\n                population += np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n                population = np.clip(population, self.lower_bound, self.upper_bound)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce a dynamic elite injection strategy to enhance diversity and convergence speed by periodically injecting random elite mutations.", "configspace": "", "generation": 91, "fitness": 0.2072573276907982, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.36228293207713225, 0.37466209130642103, 0.37751662656958374, 0.3830862093972116, 0.3749400153943858, 0.37002199727227614, 0.3816992902088414, 0.38642334056256145, 0.387220479617567, 0.027069419923046345, 0.023127972598995572, 0.010083615732487505, 9.999999999998899e-05, 0.016072609159580087, 0.006136813854201506, 0.032803963677934145, 0.008619258246722383, 0.011425151121358446, 0.10531045625397673, 0.11659707815317144, 0.10576954554347484, 0.11677669956959813, 0.11267035802913028, 0.12027875323649428, 0.10114051241819777, 0.10217618470829348, 0.10444349782326734, 0.09728781812198517, 0.09710795603274613, 0.08501423155357335, 0.09496444152256989, 0.0978262970859638, 0.09391217586971179, 0.09471312222557349, 0.09106293496216045, 0.09415590310927668, 0.9497830876404254, 0.9727260323932929, 0.9773786347785092, 0.9608436081106779, 0.9522253541043492, 0.9691166482485414, 0.9762846253295607, 0.9568164511082763, 0.9722969089807213, 0.2561814777123791, 0.23102359453474242, 0.23562737633487363, 0.24484797125256885, 0.27468187413166334, 0.23271356169566493, 0.2348543107131521, 0.2370281862888951, 0.2502170936441891, 0.2986298160866766, 0.4578345058734863, 0.29594192661350216, 0.2481734732276636, 0.2798992225467978, 0.2948483240238966, 0.2680885560412545, 0.4420513622658675, 0.5674213543737687, 0.1309844513890146, 0.14380942067446745, 0.12427872393165362, 0.1361639549769752, 0.14028847070779515, 0.14972781556143122, 0.12368325582358353, 0.1261903183807137, 0.12662180386013155, 0.1362745618927702, 0.12259457137219543, 0.12783450298681676, 0.13100256516780295, 0.16156340456417018, 0.13262641451117474, 0.1350418917616677, 0.1358225853706423, 0.13111712311429835, 0.004533742253584938, 0.0019938956199090363, 0.020931160807340143, 9.999999999998899e-05, 0.01406378244846096, 9.999999999998899e-05, 0.02085184007668872, 0.005921763962357884, 0.009833004755523844, 0.059350708723140855, 0.07785140486292863, 0.14869929692164674, 0.0620816448014464, 0.07102912319631904, 0.028686690206276344, 0.08742908854651721, 0.08126428106386097, 0.10396262210295559, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07928430919734075, 0.08111434433143494, 0.08052153870858325, 0.08364461864495765, 0.08512773079867164, 0.07080755058194976, 0.08212318891477643, 0.07941533800686884, 0.06646116647195244, 0.35246526320415716, 0.3576551710592385, 0.3652306906000029, 0.36219996742138993, 0.34758315032137155, 0.3514525275422875, 0.35710246715719673, 0.35363168355010943, 0.35698990489195304, 0.10256983212365234, 0.1069220862771193, 0.10262827358191207, 0.09593928466675172, 0.09746013399439069, 0.10091877661147353, 0.10675977019665206, 0.10674914123912893, 0.09550774982093646, 0.17334917690925955, 0.17998713422061263, 0.14559101363041105, 0.15543800071472724, 0.18341861330780884, 0.14873898436033828, 0.19797458449198324, 0.19920841013109325, 0.18586380593702634, 0.2637634477305415, 0.2636288163624805, 0.2673245049916855, 0.2726388665791205, 0.26539624593024413, 0.25907388978548995, 0.2604126374332484, 0.2729151090228725, 0.2585541433795894, 0.20354501062181662, 0.21054626033965163, 0.2077995781308698, 0.20049153295828948, 0.18162684841242493, 0.20441107276370185, 0.20719960511331548, 0.203061459151195, 0.2059856086599149, 0.21109864321205463, 0.192927047859632, 0.2412673587491564, 0.20497860514319288, 0.2002752913168494, 0.21808260810132163, 0.20940356754139478, 0.21141904250205057, 0.20420331214073728, 0.23625314202789527, 0.19932366099709165, 0.23930981409287078, 0.23877814852594081, 0.19513006222320728, 0.2115478927676233, 0.20131583355429516, 0.1895218895376657, 0.1983539035313222, 0.5199035905805349, 0.5286086933167814, 0.17897516622810838, 0.1727117391877946, 0.18259778970787632, 0.5051095026887238, 0.17910428285884228, 0.49609606193386757, 0.2032185316079944, 0.40801582173403284, 0.19876066277266724, 0.08173174136521333, 0.4488542340024131, 0.19550021704039144, 0.4680476051200164, 0.2047190970818088, 0.15051559810738124, 0.14964693854565225, 0.1792063153849507, 0.17799984570489435, 0.1750816122871165, 0.17551517744129086, 0.177418496961549, 0.19207918488204534, 0.1829934051665355, 0.19559040805763683, 0.19418996155754265, 0.09620421975480242, 0.08571627746596255, 0.08699633033014764, 0.08770899778902219, 0.09340422782506941, 0.08999319261592498, 0.09904438751524025, 0.09056406555473495, 0.08911457883643947]}, "mutation_prompt": null}
{"id": "1fb10e42-3091-46bd-b2c7-decc681df4de", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "69d74f05-0b90-4896-ab0a-b7191f25ec48", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "fd59c77c-ad7e-46ef-b75f-994f7834429f", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "fc1e58b5-8c1d-47e6-98f4-af583a8f8354", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
{"id": "45e14e19-ed73-4512-8b8c-58f909845e47", "solution": "import numpy as np\n\nclass SpiralEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget\n        u = np.random.normal(0, 1, size) * (np.abs(np.random.normal(0, 1, size)) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def spiral_update(self, base, target, evaluations):\n        angle = 0.2 * np.pi * (1 - evaluations / self.budget)\n        spiral_factor = 1.0 + angle\n        return base + spiral_factor * (target - base)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(2 + 3 * (1 - evaluations / self.budget)))\n            elite = population[np.argsort(fitness)[:elite_size]]\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n\n                local_best = elite[np.random.randint(0, elite_size)]\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2) + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                trial = self.spiral_update(mutant, population[i], evaluations)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, trial, population[i])\n                \n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "SpiralEnhancedDifferentialEvolution", "description": "Introduce a spiral update mechanism combined with adaptive elite selection to enhance convergence speed by maintaining diversity and focusing search.", "configspace": "", "generation": 96, "fitness": 0.12284935385953502, "feedback": "The algorithm SpiralEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.25493313223662084, 0.22105801425022065, 0.2874758707320678, 0.15534067577985733, 0.15659263900051923, 0.1741300937734671, 0.1410392032731388, 0.1714000856516632, 0.1458145719855518, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015045662432525697, 0.03208525901460302, 0.03066784999756378, 0.03186819436905386, 0.04319052651850119, 0.04119101462148933, 0.05288964056013534, 0.03428398907223962, 0.01720521735309921, 0.03182395810313432, 0.05030653718026645, 0.010992982981416155, 0.05018801445497956, 0.03448788130152136, 0.03181704374239702, 0.021983718199589553, 0.02184831757722694, 0.027097231956838885, 0.0181732791824033, 0.9884965846903667, 0.986640471219053, 0.8797102590402393, 0.9675700837766953, 0.9874304055217689, 0.9891365440335669, 0.9707976216851546, 0.961272259343739, 0.9747035003825126, 0.05317011608020783, 0.036314758497508426, 0.07672590676951263, 0.07795539641586924, 0.08185258030355347, 0.11786865448991879, 0.06441885740841136, 0.050141522850812414, 0.05239271906974596, 0.1400230895294664, 0.14610376877657982, 0.1296660035456294, 0.1104004123469402, 0.1045090941373501, 0.10297430012356257, 0.11150869102345584, 0.12503326547254745, 0.10625854495612874, 9.999999999998899e-05, 0.0499393565846421, 0.06233328944871519, 9.999999999998899e-05, 0.06671745023663311, 0.028920723325260966, 0.0638341016663253, 0.008201962817693698, 0.04796489782020996, 0.06965559784065967, 0.039875995139888265, 0.06796621394916402, 0.03897847513079089, 9.999999999998899e-05, 0.050987826897562316, 0.05885658792253723, 0.007028994407733857, 0.03167447075401819, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015373841897528662, 0.007797866084857552, 0.022949876384128043, 0.011010448288041652, 0.03579488528655983, 0.03990242953587653, 0.022205924836143254, 0.011627676804149778, 0.014861252081411425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031447063460459113, 9.999999999998899e-05, 0.023932190160553923, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017726172084603475, 0.03067789308951452, 0.14444620105227113, 0.19966396331134062, 0.2635213624216447, 0.1928186835028055, 0.13376405462432417, 0.18875503398272186, 0.21257150554465065, 0.1664472219631029, 0.21661810723653674, 0.04088082878439714, 0.05382277071534991, 0.018844813841857433, 0.0431946882039731, 0.024457057900776458, 0.043575852502175993, 0.04771187747033978, 0.04756540092155759, 0.0488625204767279, 0.14567991473428665, 0.14351785626018232, 0.14651957353332856, 0.14232267545451016, 0.1741371918684136, 0.14579850974117925, 0.13703060270399314, 0.1268296843425022, 0.14954351253332554, 0.12606322416185645, 0.12774914781430236, 0.16915023263730766, 0.1603274835586237, 0.164408855441338, 0.15500462181593289, 0.16263453200265743, 0.17646656475806743, 0.15485669506769262, 0.1123234773989985, 0.06759033441468387, 0.11954623077093851, 0.09329397078171986, 0.12402732791978066, 0.11999676589068642, 0.12799554946125902, 0.11824202822089225, 0.11109052920372797, 0.14963221814949668, 0.1276582687099732, 0.14960858007015942, 0.1532634925460581, 0.13607381880290126, 0.1437265804223995, 0.14619629807614365, 0.1404446991486017, 0.15977236249962556, 0.14649670109901236, 0.116943410361387, 0.15211069299381108, 0.1483341640813718, 0.10755024498411092, 0.15494643020225796, 0.0938184538003376, 0.130620208604875, 0.14462928816164244, 0.17256541577995888, 0.13799628925015406, 0.160714980353592, 0.13314113736622224, 0.171508611628709, 0.13041781706805122, 0.14280695076809458, 0.1484956829375753, 0.15813358610984074, 0.14036449470100398, 0.14481316433409852, 0.14583936204986114, 0.11127865583181085, 0.1057060321113853, 0.12647573463218942, 0.1909833844197204, 0.15506722696681996, 0.11242676050666267, 0.18081536880632265, 0.17516123839534103, 0.1866476997072436, 0.19009225391588336, 0.17767767659546463, 0.18420544055955235, 0.17940428327692226, 0.1830725151705408, 0.20196908187949725, 0.0454088197368252, 0.03448143523951097, 0.06673062500436933, 0.04901762398557452, 0.0349170245399828, 0.03836553151019251, 0.027081024761753003, 0.027297529846407653, 0.03507899682516313]}, "mutation_prompt": null}
{"id": "4268bdfa-201e-455c-9224-66cd307dc0a2", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                if np.random.rand() < 0.5:  # Dynamic strategy selection\n                    trial = np.clip(population[i] + levy_step, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce dynamic strategy selection between mutation and levy flights to enhance convergence.", "configspace": "", "generation": 97, "fitness": 0.2295434021382691, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.417659459339229, 0.4079912933882942, 0.42051689993668484, 0.41465387751361493, 0.41318281033602544, 0.41064570050500315, 0.4106461578200933, 0.40592986445049406, 0.40719926766432923, 0.022928408802826206, 0.05251755048421458, 0.007594506354958508, 0.03509155950669807, 0.029422526125921666, 0.05946031250119266, 0.04400940740367254, 0.07385634921336837, 0.05430113122147484, 0.12516281401185292, 0.10968518026590013, 0.12515324641129788, 0.15450280926181736, 0.16221734810708477, 0.17047060910854794, 0.11989928952937112, 0.15151426972048088, 0.11325597934751241, 0.10078485006337867, 0.10454889870988937, 0.10193478817153157, 0.0922466917122221, 0.10878036431665772, 0.10425475235189574, 0.10425308678119272, 0.09321354255702541, 0.09567984812830799, 0.945251229560583, 0.958537377247935, 0.9491891651646754, 0.9578083304777419, 0.9599766209805949, 0.9359152861009148, 0.9450861210410371, 0.9123862658093564, 0.9651182716028759, 0.2591165503126378, 0.26757081144782324, 0.2614182088797635, 0.26615315467337575, 0.2788142566347428, 0.2631992023658426, 0.2627274986840078, 0.25221218441013493, 0.2614397311792407, 0.4111967701121553, 0.4622021422674899, 0.4327248252360345, 0.3768420307457143, 0.36510686889379107, 0.477188584805062, 0.439382224602722, 0.474146891254996, 0.2755815094333167, 0.12769101881108968, 0.1280572485079583, 0.12800485413978768, 0.13853212538762927, 0.13330213444542294, 0.13191814326305906, 0.12377927758271712, 0.12674901852467757, 0.17074544890536691, 0.13411464734570033, 0.13314614606820108, 0.1639072940163142, 0.1325947895692985, 0.12488821719755727, 0.14910760568807035, 0.13373941925400645, 0.13282188145229845, 0.12063522374314983, 0.02101485997994801, 0.02270592647404479, 0.021806944046024568, 0.013594179562941844, 0.014359104153707447, 0.010968458758224386, 0.03921427652057885, 0.0033516468108928388, 0.0050287420077009815, 0.09444057001911954, 0.09178206708835968, 0.08755182019196439, 0.0941904301605786, 0.04503775652091335, 0.11010677592667995, 0.0814600429174519, 0.09908868969829543, 0.10198219026914934, 0.015576157270812296, 0.0031841888913891614, 0.015595556859994364, 0.0062227619520077715, 0.006740057280283374, 0.010456300366053828, 0.01143676137190941, 0.010306301797372353, 0.02060218793453006, 0.08761784878956969, 0.08763094957031248, 0.09575895792606659, 0.08674289188694073, 0.09195320361777981, 0.08524125890094147, 0.07906223093307185, 0.07889961538232926, 0.07594198433552646, 0.3792514256582902, 0.36453576172608493, 0.3816712942545205, 0.4037891717123602, 0.38832844636194763, 0.3649979967363238, 0.37258824390840806, 0.36897644700252563, 0.38005908016949796, 0.12362309916562353, 0.1041624003884204, 0.09524166085949815, 0.10316266581742328, 0.08894664149989562, 0.10370247241343566, 0.10167842611293709, 0.1004574405548112, 0.10236713865175484, 0.18319993192976614, 0.18518732846993202, 0.1997146657303147, 0.19586818425764108, 0.14965175197799163, 0.1775823118281361, 0.1741819747111687, 0.1610622825159349, 0.1826641938807767, 0.27348692901949, 0.2727048323357639, 0.2703363656511165, 0.27719130585984886, 0.28073270584936694, 0.27451360260891455, 0.2758471027191133, 0.28313942229541633, 0.27451652683820016, 0.21085161840215716, 0.21345241972215478, 0.21670630432231053, 0.210046701219755, 0.22556393107860562, 0.21263679459052842, 0.21907095589929848, 0.23119965683184895, 0.22092392625870816, 0.20079819489076933, 0.19543917770891128, 0.2389118129836011, 0.21641869344125775, 0.221937542378846, 0.20843983834123714, 0.19931607020710052, 0.20095076202759088, 0.21497998453468126, 0.26091361602728624, 0.20433550060059646, 0.2530107666223126, 0.19193226654267515, 0.18944818805494412, 0.24664777101960444, 0.26327202375007985, 0.20981022191806986, 0.26441894083355955, 0.5457772995471066, 0.5729711844549537, 0.19357250004864646, 0.5402299736201932, 0.5339403509294012, 0.5567169648673442, 0.5606757412162748, 0.5694735214052367, 0.5288539202032868, 0.47044778566185774, 0.3414747762242343, 0.1947158344006873, 0.4405048664489779, 0.363595543997263, 0.3331745859699067, 0.4547120994647852, 0.2039459376487348, 0.2044361074225597, 0.20002938470974319, 0.19401639452404196, 0.18838344978909805, 0.1814215185923097, 0.21276860033136324, 0.19862474687992482, 0.18441351226228486, 0.17808929769629522, 0.22903591005405166, 0.07445724478268134, 0.0807834418572162, 0.07886173015950904, 0.08148521446556023, 0.07694768633915916, 0.08576391240256742, 0.08510982599286798, 0.08439067251878674, 0.09517265817167553]}, "mutation_prompt": null}
{"id": "6863b8c9-0f7a-4914-a505-5655cc12ce8d", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def dynamic_elite_influence(self, evaluations):\n        return 0.15 * (1 - evaluations / self.budget)\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                elite_influence = self.dynamic_elite_influence(evaluations)\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + elite_influence * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce a dynamic elite influence factor to enhance exploration and exploitation balance, improving convergence speed.", "configspace": "", "generation": 98, "fitness": 0.23582309361159448, "feedback": "The algorithm EnhancedLevyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4355889162050668, 0.4259251071051511, 0.4327869613508648, 0.44101802550031366, 0.437620487775533, 0.42449815403176494, 0.43374331966457613, 0.43198763185982325, 0.4277155724678662, 0.017134894544249768, 0.019734734339163285, 0.05787202152564874, 0.07066099373460233, 0.053007018547937323, 0.004628950330783477, 9.999999999998899e-05, 0.056332030079335516, 0.058978447582984206, 0.12425136695685046, 0.175390569615128, 0.17012838123618967, 0.1296928076274415, 0.1665596534064998, 0.16345526204282046, 0.16795645745604304, 0.1765913544218516, 0.1278913292600239, 0.11596268830733625, 0.14479689424574538, 0.11298421527474967, 0.10419592665934507, 0.1060461340825597, 0.10821667458516515, 0.09673483360267854, 0.10918251045550276, 0.11567877128181003, 0.9659452314459045, 0.9603895952835689, 0.9631412677061073, 0.9739426721195527, 0.9726952446052347, 0.968437632467847, 0.972718077360323, 0.9486928772048387, 0.9424179424608883, 0.28005165605333426, 0.27795192587691187, 0.2781899156172779, 0.28327719957618713, 0.2777128823783369, 0.2792951293530951, 0.2792815574856903, 0.2800886862377361, 0.2781982031621063, 0.4248324773414913, 0.3979842816271022, 0.5123290970312362, 0.4370399037293894, 0.4377493119983543, 0.4548650292050228, 0.4569030677319589, 0.4357228923632801, 0.4719989337057282, 0.15411808814528538, 0.1463171723810479, 0.15605415927702215, 0.13123931720328708, 0.13771016551369175, 0.13795050049097213, 0.15062925865688614, 0.12792473874140864, 0.12876747199728833, 0.13934283013611626, 0.12756029412430148, 0.14576242617889257, 0.16554101928077047, 0.15127637863203314, 0.1430591705330616, 0.15649717915598105, 0.14406318165339815, 0.14062644500860766, 0.023100768527361093, 0.022317016380458465, 9.999999999998899e-05, 0.03710873252189939, 0.01747516154273654, 0.015900171126175477, 0.008524777225697666, 9.999999999998899e-05, 0.02321258877239818, 0.12939969056333844, 0.11198742800464023, 0.08950160880778335, 0.045100386253558056, 0.1301065760971154, 0.048801042983499965, 0.0704047150384628, 0.09512980348146483, 0.11351870853873225, 0.018381351889973252, 0.024213943883161337, 0.017469496704181298, 0.025293168868300575, 0.015291285922689912, 0.02497015642332734, 0.01913278545510233, 0.017469981638010945, 0.020975683358719244, 0.09791802943471561, 0.09320855174011011, 0.09696689545877302, 0.10747909456039284, 0.09576747357422133, 0.09948195700578144, 0.08912346426706064, 0.10301215446010104, 0.10289933471844748, 0.39920240950087427, 0.38929534766925233, 0.38675148266525616, 0.3900590854509842, 0.38173744416848276, 0.3826193272401406, 0.38126586633068626, 0.3913562908310929, 0.386396837923651, 0.11714671694364787, 0.10635787405427255, 0.1534423320547137, 0.11557838083062855, 0.11267008883202267, 0.10913611783912514, 0.1222442732238882, 0.10688344284536055, 0.17762533122581714, 0.20448404363173023, 0.24756183040617608, 0.23229608078129105, 0.1977370738828691, 0.2352196124308037, 0.18573159821089724, 0.25845401788489986, 0.21365300449936409, 0.162378424422987, 0.2873979397134112, 0.2864747154192011, 0.28770283538256314, 0.2902661471861884, 0.28796406051812995, 0.2809096961261658, 0.29764650738103793, 0.2890365040502948, 0.2864745513702295, 0.23875491297666906, 0.2138039567140798, 0.22258586760117793, 0.20982931076391842, 0.2205420384333192, 0.22132754101135454, 0.2254130929333451, 0.23056379991072862, 0.23417014351310683, 0.21624799321088695, 0.2016425207856951, 0.22948825701136, 0.2019467011525934, 0.2157344216553012, 0.22329439200063494, 0.21432453590510936, 0.2364570154710024, 0.2199137450841815, 0.2039389197119652, 0.28332423532318585, 0.2800293959297474, 0.27927784603584427, 0.2786492317117135, 0.2757641334694828, 0.2903370650553556, 0.2891695444235296, 0.28085801126918064, 0.1583578321803787, 0.17896347331067486, 0.5881894965846934, 0.6055509474152461, 0.5435641189455477, 0.17921229788978765, 0.5768633758664106, 0.16532475141815173, 0.5815523355221979, 0.3020418175222491, 0.3459984437811542, 0.5126305640165447, 0.49412559653309696, 0.1661112480024598, 0.19859603857746944, 0.20692447683707837, 0.4598533776772433, 0.15349743514525305, 0.21710469987171577, 0.17626665518594997, 0.17400136239873665, 0.17927075893281652, 0.20304090554443788, 0.1691598243160819, 0.17509087346082508, 0.17686316478245334, 0.18238418764489295, 0.08710769973219379, 0.0904376724212802, 0.09234185088858904, 0.0933023302032665, 0.08709193675460414, 0.08582809083312293, 0.08778787730820936, 0.08199777751208781, 0.09062143246455434]}, "mutation_prompt": null}
{"id": "00b73c20-298c-4a30-88e1-2a2346726f19", "solution": "import numpy as np\n\nclass EnhancedLevyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, 5 * dim)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.f = 0.5\n        self.cr = 0.9\n        self.alpha = 1.5\n\n    def levy_flight(self, size, evaluations):\n        scale_factor = 1 - evaluations / self.budget  # Adaptive scaling factor\n        u = np.random.normal(0, 1, size) * (np.sqrt(np.abs(np.random.normal(0, 1, size))) ** (-1 / self.alpha)) * scale_factor\n        return u\n\n    def adaptive_mutation_scaling(self, evaluations, temperature):\n        return self.f * (1 - (evaluations / self.budget)) * temperature * (1 + np.random.normal(0, 0.01))\n\n    def dynamic_crossover_probability(self, evaluations):\n        return self.cr * (0.7 + 0.3 * (self.budget - evaluations) / self.budget) * (1 + np.random.normal(0, 0.01))\n\n    def adaptive_noise_level(self, evaluations):\n        return 0.1 * (1 - evaluations / self.budget)\n\n    def temperature_factor(self, evaluations):\n        return 0.5 + 0.5 * (1 - evaluations / self.budget)\n    \n    def adaptive_shrinkage_factor(self, evaluations):\n        return (1 - evaluations / self.budget) ** 0.5\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        best_fitness = fitness[best_idx]\n\n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            elite_size = max(1, int(3 * (1 - evaluations / self.budget)))  # Dynamic elite size\n            elite = population[np.argsort(fitness)[:elite_size]]  # Preserve top elites\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                temperature = self.temperature_factor(evaluations)\n                adaptive_f = self.adaptive_mutation_scaling(evaluations, temperature)\n                noise_level = self.adaptive_noise_level(evaluations)\n                noise = np.random.normal(0, noise_level, self.dim)\n                shrink_factor = self.adaptive_shrinkage_factor(evaluations)\n\n                local_best = elite[np.random.randint(0, elite_size)]  # Use elite vector\n                mutant = np.clip(x0 + adaptive_f * (x1 - x2 + noise) * shrink_factor + 0.15 * (local_best - x0), self.lower_bound, self.upper_bound)\n                \n                crossover_prob = self.dynamic_crossover_probability(evaluations)\n                crossover = np.random.rand(self.dim) < crossover_prob\n                if not np.any(crossover):\n                    crossover[np.random.randint(0, self.dim)] = True\n                trial = np.where(crossover, mutant, population[i])\n                \n                step_size = (self.budget - evaluations) / self.budget\n                levy_step = self.levy_flight(self.dim, evaluations)\n                trial += step_size * levy_step * np.exp(-evaluations / self.budget)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                \n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if trial_fitness < best_fitness:\n                    best_fitness = trial_fitness\n                    best = trial\n\n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "EnhancedLevyDifferentialEvolution", "description": "Introduce an adaptive levy flight scaling factor tied to evaluations to improve exploration and convergence.", "configspace": "", "generation": 81, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "5f1714f8-395f-4b74-99d8-6ecea5e06ee4", "metadata": {"aucs": [0.4424702573377982, 0.438255888474278, 0.42865814052761475, 0.44013046657992483, 0.4343085553494931, 0.43089069973752114, 0.43912315397164203, 0.45641489239411703, 0.42344759103386564, 0.04828719526240244, 9.999999999998899e-05, 0.03355572633529025, 0.03835263997084204, 0.04628951582227159, 9.999999999998899e-05, 0.039628720654586114, 0.04101879299796907, 0.05906604167523133, 0.1692142958604661, 0.16653454911267762, 0.12315550744252235, 0.12293199576431324, 0.13247305015893784, 0.1744829414799235, 0.17037013289350467, 0.12014845386944639, 0.13060325405875972, 0.10412443068321608, 0.11182226410108465, 0.09823148357024059, 0.10342262258199231, 0.10164414702340274, 0.15740513888514052, 0.10142561652765636, 0.11419433259382517, 0.1137684523456104, 0.9659467256577354, 0.9604179462290211, 0.9631653302600819, 0.973943539115033, 0.9727088694852278, 0.9684430159795714, 0.9727179150427653, 0.9675938696902981, 0.9447356361518935, 0.2887334014369304, 0.2844750668318635, 0.2894979619095378, 0.28419707186787535, 0.2902626910354805, 0.2924833845778636, 0.2936056310368872, 0.28127015741659145, 0.27860324077702536, 0.47683150914027106, 0.4728734576033572, 0.4970855932212561, 0.4996253530317668, 0.43380116248342837, 0.5220170406286474, 0.47275929717121035, 0.45106934131627474, 0.4529624438060885, 0.13980971006994647, 0.15341734768661897, 0.14044016644764545, 0.1365356084887197, 0.13449600317693422, 0.16071497952148306, 0.13766316320079008, 0.15319558576828263, 0.14988272928335533, 0.1452201588544969, 0.1374306181334265, 0.14605655986173138, 0.13187685965093132, 0.134689777257626, 0.13761355319871094, 0.13773465400283424, 0.1485965228751278, 0.15776746555386567, 0.023125702211689192, 0.04084211927463799, 0.024611775808915937, 0.02229613586982504, 9.999999999998899e-05, 0.0202692521343506, 0.021372313738566517, 0.033654486080442636, 0.026677352614247307, 0.1019457713513855, 0.10505394564237136, 0.08963153591467421, 0.05802522432049395, 0.054490074152158785, 0.02194955536907417, 0.09552481969433735, 0.11892842376068746, 0.1329649862081651, 0.022050429448660758, 0.01905148851399685, 0.020149112978675277, 0.011914637930330318, 0.009546689957462329, 0.028212471964752295, 0.02358958286472823, 0.018925952574007865, 0.015604783388717403, 0.099247822738048, 0.10116588881348487, 0.09847528276888717, 0.11216664270672005, 0.10645855122857462, 0.10047832416146119, 0.10198736098667105, 0.09391605163590189, 0.10006979082731704, 0.3892931915651838, 0.4080720266664831, 0.39212273428973854, 0.401237748886657, 0.40235287817655907, 0.389134779665248, 0.39469508478024684, 0.3974661125215353, 0.39201224926589306, 0.10939764624908366, 0.10703880175961566, 0.11243583417425995, 0.12145119560940498, 0.11209349292619863, 0.1714781392920227, 0.1263176220355492, 0.10916942258613893, 0.1228827751217072, 0.18862906205687036, 0.1983244519859665, 0.19660723407558, 0.20523309646094479, 0.22651553112830092, 0.22255763138334017, 0.2429598091276619, 0.24431643236890854, 0.21806965973939618, 0.2909023030884912, 0.2907602728284172, 0.2920043547332134, 0.2884853617084233, 0.2896732520627725, 0.29891780149619085, 0.2941229358164956, 0.2918334658583702, 0.2867920619695754, 0.24117701549545678, 0.2387933063203328, 0.23032205740128697, 0.22455693726791948, 0.22302898734126841, 0.226901425140981, 0.2362336319477586, 0.23504223078238207, 0.23433906275915528, 0.21336966160446713, 0.18872921165709255, 0.2210379000128515, 0.20170472675043327, 0.20285527675418558, 0.21574764229426258, 0.20087328363072565, 0.21334856236378097, 0.20063451791513842, 0.28848950126062634, 0.29049491815508977, 0.2038991609961377, 0.3032990270654715, 0.21051821181359887, 0.20262964746387602, 0.3039259519116867, 0.2938604970872022, 0.278944139109649, 0.5892210336698155, 0.1789153420839128, 0.6133508288578118, 0.5978186267233618, 0.5785622183807125, 0.5617716396283909, 0.5795545696751001, 0.5664155402222817, 0.5905314687736147, 0.3352140696360125, 0.5243395942052467, 0.5202172980938545, 0.5546990618825223, 0.16593862934742554, 0.2014567559733368, 0.20527857031040309, 0.15109695312970284, 0.1532745234433025, 0.18633664649141302, 0.18866968929399186, 0.18340277475845168, 0.1874310389462608, 0.1952429661899341, 0.18382900925743395, 0.1964398400594377, 0.18963285656644957, 0.20185574305864207, 0.0819129464058882, 0.08282001467164368, 0.08476845419975942, 0.08215462811977581, 0.09005379801293889, 0.08744506562714072, 0.09078130836896747, 0.08814350462006859, 0.0854811351319611]}, "mutation_prompt": null}
