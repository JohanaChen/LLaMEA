{"id": "b27a5a80-f848-4266-8bb8-d5e180aa62ac", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if evals >= self.budget:\n                    break\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.uniform(-0.1, 0.1)\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]\n\n# Example usage:\n# optimizer = HybridDifferentialEvolution(budget=10000, dim=10)\n# best_solution = optimizer(some_black_box_function)", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution and Local Search to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 0, "fitness": 0.2879327096508894, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6678065554883635, 0.638634131684304, 0.683149734327173, 0.6889351475070519, 0.7044084214837534, 0.6943144521001932, 0.671401939509448, 0.6580035360207944, 0.6651277502582953, 0.3618754010538082, 0.3395514167610404, 0.36055231465992843, 0.33317183485153223, 0.3554349509078297, 0.3547726697416206, 0.3641225301851908, 0.3377060212643047, 0.35591530903195523, 0.11484715402323997, 0.15650061610537291, 0.11583160689366645, 0.13198936340061396, 0.10897835142716028, 0.12146885422814213, 0.14447345657943045, 0.11113158297031078, 0.1071790864271075, 0.097297710822985, 0.15855813119808737, 0.16886096554645902, 0.09817370434334405, 0.10673822575870473, 0.13220422809206267, 0.1386440797273626, 0.09606304838699375, 0.12345410413371682, 0.9588646995682851, 0.9652251590331383, 0.9637768774888555, 0.9194053893102667, 0.9378746739390887, 0.9440680334547576, 0.9539118281655979, 0.9574251833609015, 0.9470451052587606, 0.3100834198265324, 0.3025961325812543, 0.31158606112672316, 0.27635729480800764, 0.32277676303366076, 0.3064110217176521, 0.2727343733981843, 0.2887616435021185, 0.3051847912403579, 0.49585922999818166, 0.4528426866466134, 0.41238043372558497, 0.43961852827956804, 0.7644826202723005, 0.5417089658839702, 0.5226708546723577, 0.4693301851460546, 0.5164007584002381, 0.22211480222152324, 0.1989011959211544, 0.21516059353258565, 0.24091357171027727, 0.215704030645804, 0.18055245329888314, 0.19314268998677175, 0.18374872120585983, 0.20570117945227584, 0.22025205750601906, 0.18685360987323663, 0.24708007826309353, 0.19569620593505133, 0.1814793736594702, 0.2133704558326417, 0.1846626535051169, 0.21707755223126357, 0.2150030213500751, 0.12095611210004886, 0.10911513718153454, 0.10380995674815297, 0.14609003130825515, 0.1240159129509506, 0.1597719381493502, 0.13962784436676834, 0.11984892644775502, 0.12106781022229929, 0.24894732277302634, 0.2439138691997489, 0.20148421049441745, 0.2315904906813786, 0.1905353896586054, 0.21011352939694528, 0.25437501497035, 0.27188974017606726, 0.27892521110088964, 0.0825354696502012, 0.04548527786841827, 0.05288720570140126, 0.10040956665168743, 0.0669234013511637, 0.09992026018642808, 0.09884756250786264, 0.0400777447371653, 0.07185963799154238, 0.15105152836402136, 0.15700248704576136, 0.17039470401271173, 0.18910720553425875, 0.1670268163279759, 0.18722732193597402, 0.1831183247505519, 0.14219505584028957, 0.15414308821625167, 0.519629950179081, 0.4911186655266727, 0.5160343279372328, 0.5000614690987163, 0.49434747232954546, 0.48330105741894036, 0.4876810870351469, 0.49388692913178034, 0.4906878892836074, 0.13092235195887403, 0.11281535675653998, 0.11293250164740054, 0.17139199062317945, 0.11955650393699013, 0.1541387744787076, 0.11651617690960281, 0.09778577655256737, 0.12755595863726576, 0.22427028797010307, 0.1466810655911398, 0.16743941009990904, 0.16692270456690383, 0.21270786125962382, 0.22870087104761672, 0.1724772997164047, 0.18660396968296822, 0.2949225339158028, 0.28311083668338366, 0.28036687967084006, 0.26504052675020373, 0.24532279794794498, 0.24939993719023246, 0.2892737186988825, 0.3095434084826215, 0.279148841187694, 0.2938800336954207, 0.23648889897525183, 0.2212141033794195, 0.21902935656178069, 0.19513620873314275, 0.21394083235795602, 0.21018662833342872, 0.2115182890131856, 0.22801791929873172, 0.22553875879974727, 0.2113773592367747, 0.18218529430060604, 0.23689200546512756, 0.19379288267660777, 0.2329852155276788, 0.2385896144870553, 0.1905082411936323, 0.18046530574888142, 0.21094140482379375, 0.19001520081082224, 0.19051021931902368, 0.2003297732303153, 0.18265690102303012, 0.18653802071069425, 0.19659193363297578, 0.1905081076275249, 0.2197224325899496, 0.20020622430712398, 0.15097074043195402, 0.6985130043587053, 0.5466549744717858, 0.7019804656602495, 0.4790117747983882, 0.18272811881033346, 0.6861486832420738, 0.3449916772988426, 0.6322535243751295, 0.3296081861766681, 0.41347346911573646, 0.20151890915218795, 0.27973064350737065, 0.18739329475432165, 0.3972783839670755, 0.4950432744225911, 0.6329244456915366, 0.19997860607666995, 0.19267595680699734, 0.20115040996101563, 0.2058850138208418, 0.220713229412845, 0.24453003240389914, 0.1927828251855298, 0.2025396641167969, 0.20584877484822883, 0.1947381646427604, 0.1013787042693226, 0.08226480452528906, 0.08908071579835619, 0.08470047311448703, 0.08439045238741294, 0.0784257607366442, 0.10482006672977973, 0.08302388664871174, 0.07188336363609438]}, "mutation_prompt": null}
{"id": "21866f08-034c-4077-814b-071c373ad182", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 1, "fitness": 0.3160961542791753, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "b27a5a80-f848-4266-8bb8-d5e180aa62ac", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "d012166d-c00c-4fd4-9c8c-9e82a0263923", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # slightly increased adaptive population size\n        self.F = 0.9  # enhanced differential weight\n        self.CR = 0.85  # adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Enhanced Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with a slightly modified strategy\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                mutant = np.clip(a + self.F * (b - c) + 0.5 * (c - d), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Gradient-Based Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                gradient_step = 0.01 if np.random.rand() < 0.5 else -0.01  # deterministic small step\n                neighbor[d] += gradient_step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Population Adaption\n            if evals < 0.6 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "A refined hybrid optimization approach integrating Enhanced Differential Evolution, Gradient-Based Local Search, and Dynamic Population Adaption to effectively balance exploration and exploitation within constrained evaluations.", "configspace": "", "generation": 2, "fitness": 0.25380125393720876, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.6625042228127962, 0.6394198332170397, 0.6388250520309179, 0.6517268015275017, 0.6821156958231144, 0.70166053853761, 0.6660867565107802, 0.680765039729563, 0.614050632444203, 0.3778473547549517, 0.38886616069726676, 0.37001611996568995, 0.3919384430562549, 0.39895911673486717, 0.3833773187662246, 0.3861146383062598, 0.3544119298307812, 0.35637112804081383, 0.10894139982831041, 0.11206056949193821, 0.13279798562986767, 0.10119112134054464, 0.12665635443644274, 0.14890690264338924, 0.13135210555887844, 0.09786825054054094, 0.13140257022612822, 0.16858904409506936, 0.12117063360277147, 0.1100223183918615, 0.1092207555023822, 0.10310047147387336, 0.09854784695965502, 0.13460129565964785, 0.10949494630108891, 0.12787282078111406, 0.9621319850484535, 0.9404413835743137, 0.9554373193865316, 0.920438615782582, 0.9582494034845311, 0.9069701967750003, 0.9406765650118746, 0.9570865016332359, 0.956740296229516, 0.2972089205255134, 0.26279923252189974, 0.26416418122174945, 0.25648722750543995, 0.2792959328227945, 0.29140893184574046, 0.2977631340380872, 0.31132652712249786, 0.2977127015000832, 0.3475907593058942, 0.498608694334544, 0.3930812668937339, 0.4988234391980232, 0.49520107631363797, 0.5034984235304597, 0.47946939616293904, 0.3579287816919092, 0.397067531410888, 0.1933996850359656, 0.20949221652062566, 0.1362220393848711, 0.16203593841183828, 0.1488409844874954, 0.20967614677669433, 0.15527345816055982, 0.17385644072784578, 0.14896231425690598, 0.17978152643379108, 0.18693966432141917, 0.1354169807466591, 0.14263747721853137, 0.1584667390693325, 0.24479393282101514, 0.16407587958652892, 0.1426877595608994, 0.1283389152217067, 0.08304574177885538, 0.08130481169632364, 0.05444025192730073, 0.09485986027953508, 0.07448330672117276, 0.08145940434250243, 0.11185468025772238, 0.07278177173848543, 0.09422846484034475, 0.18963291706238117, 0.17533719900846734, 0.17086509897525615, 0.1944293839158513, 0.19126697468130738, 0.17409746616761945, 0.23071658207935963, 0.20632070847381612, 0.20318659639773728, 0.038937330113634205, 0.029534036427662058, 0.03372440885716277, 0.046366288718613036, 0.046758918473842837, 0.05366593849354995, 0.03507544131293072, 0.03775250683475151, 0.04861277560408939, 0.13614084299723672, 0.1550996362852658, 0.13860862562310994, 0.15304863194080842, 0.16429610176548848, 0.15532591039299004, 0.13845451995056302, 0.14791147630830126, 0.15588436784713156, 0.49201808094660004, 0.4750576817257969, 0.47376317178874083, 0.45152885242075347, 0.44638745868060814, 0.47808509006001865, 0.4995863697058388, 0.4382293605082288, 0.46020728107589326, 0.13428533921511354, 0.12223329132574778, 0.14838477257794802, 0.10683038003767054, 0.1454680201055245, 0.10252336209177504, 0.0940833571761095, 0.09842527462243966, 0.08912196037277786, 0.15429458874648716, 0.20689208256278524, 0.13968344545810718, 0.1671792008758759, 0.1548545945205677, 0.18167170936345056, 0.17322675942833266, 0.1403935842228612, 0.1346299305069122, 0.2731812664753862, 0.2844034293490787, 0.2688168728243655, 0.27802760390721437, 0.2527787580475588, 0.2521223351317676, 0.2787070630287699, 0.3049530388201236, 0.27420895947501, 0.22004221296125948, 0.1747907564548239, 0.2185986472101108, 0.1905768842540142, 0.18295149303047598, 0.21455474485191184, 0.19425260833371383, 0.2337937475702213, 0.2036594800192708, 0.17043206108340092, 0.17302822966574916, 0.17117486222472655, 0.1852018044131699, 0.1753157549354084, 0.1814664863379083, 0.17637313812834565, 0.19961936764631705, 0.1878954356603284, 0.1966675897808785, 0.19099731234675443, 0.20816305228439091, 0.1815928134182062, 0.204855901088833, 0.1856146818229285, 0.19363726296378903, 0.1778711646690353, 0.17982616375549965, 0.20160791079212725, 0.18903309858992712, 0.1938971976376137, 0.32280497274081377, 0.16860694803294263, 0.2761033159008416, 0.1701983696793986, 0.4597508016272408, 0.3539291084555012, 0.36292265057430373, 0.16793181399943025, 0.16818672400687595, 0.17242007512586555, 0.18542875479421717, 0.24098971597192909, 0.20955573932609595, 0.20545782495255804, 0.20749756001126385, 0.19415970187249365, 0.19216305890613405, 0.17879817114092889, 0.19655293783998462, 0.19199232270233535, 0.18380450334776777, 0.1972667413911534, 0.1827786198757354, 0.20223244573524468, 0.07469572801858304, 0.07935779234764306, 0.08625316818907325, 0.0671028231821672, 0.08867257305284348, 0.08143912660032127, 0.0860562944075498, 0.09244420151705801, 0.07291039684154421]}, "mutation_prompt": null}
{"id": "43b75f93-01e6-4e21-9821-85d66e46c85a", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "31c8579b-43da-42d6-83cc-ca308b85c24f", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "d75d36c5-294f-4ea3-baf6-385794a997cf", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "cd631fcc-c9e7-4d59-93e5-2e23998f17ae", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "f574c6d5-ed24-4f15-8d07-bcdc6a0b75a0", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "5fd880e7-bc66-400c-a86e-dee9dd104846", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "391ca2ca-7517-4f21-90a0-c0f009e4f1c9", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "d3580319-2172-407e-991e-e52c9c4005f8", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "1eede574-1fca-4195-af6a-29f4c1312a4b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.9  # differential weight adjusted for exploration\n        self.CR = 0.85  # crossover probability adjusted for exploitation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Simulated Annealing Phase\n            temp = 0.1  # initial temperature\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.1)  # adjusted step size for SA\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                # Metropolis criterion\n                if neighbor_fitness < best_fitness or np.exp((best_fitness - neighbor_fitness) / temp) > np.random.rand():\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm integrating Differential Evolution, Simulated Annealing, and Adaptive Population Sizing for robust global and local optimization within a constrained evaluation budget.", "configspace": "", "generation": 11, "fitness": 0.2596016878869111, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.46464113724093514, 0.49064787864745363, 0.4614401828851066, 0.4745104103886304, 0.47697582967326757, 0.527237978375708, 0.4599432884101482, 0.4968805220174699, 0.5062537756199953, 0.3121239108606433, 0.33031140440180495, 0.3181304126793706, 0.3360634449890447, 0.31497398758254447, 0.3072765564885209, 0.31423221302045856, 0.34713501744140385, 0.3369149404866555, 0.15701423396221292, 0.1292518594430747, 0.15091169021432982, 0.13979999028415846, 0.17952202534862194, 0.15255188211146054, 0.1460176399875609, 0.13970870423082982, 0.15984658552434017, 0.10824299904378876, 0.15184055174935274, 0.11134237107451539, 0.0987160369498914, 0.11770532202477457, 0.13978753122509457, 0.10575799416034481, 0.10231386463556336, 0.11164361940182843, 0.9751518726868912, 0.9867571546028348, 0.9311841995217016, 0.9661014302037673, 0.9523628701093143, 0.9673965116456613, 0.9670613720590344, 0.9759680149088275, 0.9811331866769197, 0.2484894059806252, 0.2659253773097654, 0.29412218844813676, 0.2589884086306181, 0.25337305597847937, 0.2868777086242612, 0.26136812592397074, 0.25642357755731715, 0.2766679069875019, 0.5750929809315711, 0.27750512454996956, 0.35192959542398994, 0.4809086113536246, 0.40588755670306187, 0.29723413242023544, 0.30239280627945786, 0.479429639936635, 0.423245820737129, 0.22052497586538955, 0.1601690403941327, 0.18594726057211142, 0.26393901892232796, 0.1819153016400029, 0.17418165088608528, 0.18644030607817685, 0.1919335157909029, 0.30588468551815196, 0.18091127256037043, 0.15085226009217245, 0.20707256270167607, 0.17420334993895725, 0.13648077468278097, 0.19003925810007893, 0.16921527104904344, 0.17642936134825427, 0.17345236146885712, 0.05354607023298252, 0.09239364741497935, 0.11546111291241445, 0.06698712924724404, 0.06911152366654572, 0.0723146838446177, 0.07778169665600831, 0.06844916435952164, 0.039579775237233106, 0.16868562649622854, 0.16097596822549953, 0.1535620484234438, 0.18328648887316557, 0.16367197245266163, 0.15832139341990992, 0.21370033737199268, 0.1988250216210331, 0.19301647753241546, 0.04235717432896258, 0.03809764671135907, 0.0759512868557154, 0.09563782330202253, 0.06392836293412985, 0.06112642762043574, 0.06936041991481234, 0.07623102950610083, 0.06066266158723521, 0.15118042016535382, 0.1819186647337787, 0.11899180175809865, 0.1823477866820613, 0.17008947061114144, 0.13862304796931002, 0.15578187237767505, 0.1377534345403506, 0.1485533996203574, 0.3914862599821476, 0.3920265210088787, 0.37463023296052866, 0.4060233357171408, 0.4088199839901312, 0.3831558065375139, 0.40266701203273925, 0.3737577902358755, 0.40733483258545633, 0.1258567654247199, 0.09681026450674801, 0.1264749077778533, 0.11563199507992727, 0.1228169394666867, 0.10709501127342103, 0.13666049039738282, 0.12737329478964365, 0.12193301550654456, 0.3146013628688591, 0.33522554478354083, 0.18388794559958976, 0.18335377416522702, 0.27495979291956485, 0.31190305391074225, 0.23049650041252123, 0.16372318700511845, 0.22366787413482414, 0.2807887566984051, 0.27225109320647345, 0.26136828752762353, 0.2734577618133961, 0.25035300756904244, 0.26494514685669546, 0.2829503652651898, 0.25974493708708757, 0.27908854656642557, 0.2210352034260622, 0.2055183622498049, 0.2304767422172459, 0.22179831689679064, 0.1873735675149213, 0.2144027249406022, 0.22790273879721779, 0.23733672649491633, 0.23801433361250046, 0.2554110239345393, 0.17653956859550068, 0.191073947671199, 0.17380737679705138, 0.1623069549849926, 0.21211568875542208, 0.19454394948205977, 0.21091811677773697, 0.19986326811299981, 0.20147653855172976, 0.1923828338189406, 0.1895061860799765, 0.19005173613526416, 0.19497748763704936, 0.2505634254023634, 0.19843660683240316, 0.21359143168775996, 0.1932230736382241, 0.4063626254351791, 0.41326442509456474, 0.48911342663097535, 0.4425239869730282, 0.3641267989537338, 0.17679372495393908, 0.5509673537063975, 0.31594032353807877, 0.4775163968268389, 0.4115571025377932, 0.2059420454147074, 0.19456587558747962, 0.35642595035978886, 0.3752869665448132, 0.31615876838720003, 0.47262765170465304, 0.47879485948483735, 0.20658927519190295, 0.18120393637325471, 0.21702563326850433, 0.19963653022596772, 0.20723433649071343, 0.19270136199230614, 0.20116842778045962, 0.20670847028838057, 0.227846732371076, 0.20040608558084605, 0.06985018533549825, 0.07160197559815029, 0.07896569608221793, 0.07564791045701458, 0.07112007807524678, 0.08536559498588014, 0.08574694225931467, 0.08321493103942135, 0.08749134374522383]}, "mutation_prompt": null}
{"id": "8cca41ce-5b47-44b6-927b-6e761c622da6", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # slightly more adaptive population size\n        self.F = 0.7  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Enhanced Local Search Phase with Levy Flights\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.1) * np.random.standard_cauchy()  # Levy flight step\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Resizing\n            if evals < 0.4 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (8, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedDifferentialEvolution", "description": "A novel hybrid algorithm improving Differential Evolution with enhanced local search using Levy flights and adaptive population resizing for efficient exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.30404289184617295, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7170969761342908, 0.7240743169477672, 0.7284212719005239, 0.750926168555478, 0.7367754908807234, 0.7339831180667431, 0.7275813928528996, 0.7273096062411304, 0.720199526497093, 0.4852327501685638, 0.4597020206410589, 0.4573709172276146, 0.48519864565902837, 0.4685474549337455, 0.4684393020601556, 0.4631689663368169, 0.49906095847223564, 0.4881588656526257, 0.1382990843963089, 0.13153558004816568, 0.1306897845314987, 0.15010785965229412, 0.1390430181223432, 0.14983540354475045, 0.2461902033998724, 0.13433596750979582, 0.16189781053496732, 0.1743597640307456, 0.14243466331842902, 0.09879688907928807, 0.13724084818116566, 0.12793298097629124, 0.1367116971430098, 0.1205623298880848, 0.1618435206956398, 0.14096217898699925, 0.9463751885428426, 0.9716229201624696, 0.9348872175805851, 0.9475744694662811, 0.9605230369650285, 0.9300373399328699, 0.9466846292315271, 0.9473660677820218, 0.938977303818149, 0.3450612227148857, 0.3342812635670964, 0.31471858363401184, 0.3267952849010367, 0.3202353548596406, 0.3057228290771372, 0.30263128284422425, 0.3576028942670315, 0.3182710098677427, 0.4942519554603838, 0.41965805040055515, 0.4665317985473072, 0.6216683094713817, 0.5365563818733776, 0.5518929540492845, 0.6032956896372567, 0.631143734363355, 0.6280966702716289, 0.2355982818791328, 0.3081936009121893, 0.20142975345350334, 0.20777391679631407, 0.21331236376613438, 0.2072936242884731, 0.24234898817563466, 0.22119349490593254, 0.20593699769513063, 0.23676201995797697, 0.11072608478283796, 0.15784633855666985, 0.27581652644959076, 0.2214268985786485, 0.23518547171111792, 0.2058467082985882, 0.18501403660919402, 0.2229391422047312, 0.14768655918028084, 0.12173831545411884, 0.12249496192725018, 0.11518273487312036, 0.11688189466390764, 0.1036827525974211, 0.13789137689617348, 0.14908304199767464, 0.11386134326278641, 0.24038140343014958, 0.21653251243418503, 0.2521510092676771, 0.21279134961369695, 0.22552475043622877, 0.19688704909251487, 0.2579890552984946, 0.2863349352866511, 0.24570982759785043, 0.10015060903010375, 0.11464701222552098, 0.09309292649884826, 0.10699543125526889, 0.08610859229456835, 0.10853361031090225, 0.11251564445550033, 0.129305824627714, 0.09902872275282149, 0.16953767685768484, 0.18375850458617637, 0.17835192567355984, 0.17180896552492975, 0.1986429487208482, 0.19585386547805084, 0.18095243126429528, 0.1972743703853519, 0.1991252623368187, 0.5297148573819996, 0.5090811322025581, 0.521531491377565, 0.5096015435964539, 0.5073132553628541, 0.5031665494342464, 0.5088385651016707, 0.5086135199719939, 0.4962407412407438, 0.1801380842411585, 0.09938789922286562, 0.10730011314737586, 0.13446444446359984, 0.11839383774989765, 0.11534896353094903, 0.09533219999582776, 0.13217137262941703, 0.1179290937476919, 0.18993622452166914, 0.3055819783894862, 0.20044571287140145, 0.18551935485366, 0.2127067712033659, 0.2032994046041735, 0.21694730572874243, 0.1907937902902005, 0.19359505392617893, 0.3017839852944524, 0.28440885568230556, 0.29091366298487087, 0.2801618134961569, 0.2758567138832787, 0.30503980763670535, 0.3287549730654683, 0.3427230663641807, 0.30313611596991596, 0.2310300224172963, 0.21170291987258005, 0.22368584762275956, 0.2361654933712095, 0.20590627361035574, 0.2095304943601909, 0.24853035523442635, 0.2346838183405855, 0.24861063634190594, 0.23760220081333405, 0.21535365365353465, 0.19455772560829188, 0.2379438441945726, 0.1969058620802171, 0.21197683268873557, 0.20585671619175905, 0.1921812885990184, 0.19813647024644088, 0.1880756702550228, 0.20736868087829918, 0.21230202449156343, 0.18713221777738642, 0.19643740473194582, 0.20315567213178087, 0.18955523134285024, 0.1883131987248886, 0.19431310892358633, 0.6015358856560464, 0.5141878332995378, 0.6381476550472739, 0.6796404924760902, 0.23725145013633486, 0.7304879268766916, 0.19940304648907503, 0.5335606572121654, 0.16819495216115354, 0.4468413184011727, 0.49859679316692807, 0.19732070802315316, 0.20448564866129237, 0.34288645459240497, 0.38627663302166715, 0.5622427186844096, 0.2091669981993104, 0.210385982804015, 0.2073399125509794, 0.2010435002877381, 0.22675199551252456, 0.23714360942548462, 0.19169442684949944, 0.19480382348427494, 0.1993599993999997, 0.2066300144283021, 0.2066784929524158, 0.0788877969796371, 0.07259576939852663, 0.07302355760387458, 0.08443374873946452, 0.08553478049357854, 0.10995575153938497, 0.09741525277291352, 0.09088791454633338, 0.08566099406187355]}, "mutation_prompt": null}
{"id": "6dbbfcc5-bf3f-4ad3-8900-9dc7d424455f", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "4c5c4fb9-1013-4f0e-bf7a-470cd150c282", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "eac36081-65fb-4fbc-a80a-5c107ade0552", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # adaptive population size\n        self.F = 0.85  # differential weight\n        self.CR = 0.8  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with dynamic scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                d = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)  # random vector for diversity\n                mutant = np.clip(a + self.F * (b - c) + 0.1 * (d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.1)  # dynamic step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.7 * self.budget and len(population) < 1.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (10, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "An enhanced hybrid algorithm using Differential Evolution, Local Search, and Dynamic Scaling to better explore and exploit the search space within a given budget.", "configspace": "", "generation": 15, "fitness": 0.22488405151532115, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.6236039984975282, 0.6166060305855823, 0.6191176178036125, 0.6049816340620107, 0.5888772528029704, 0.5681026426833402, 0.5654264272594894, 0.6267800987445684, 0.5937412299554612, 0.0737006618525855, 0.14391252127832377, 0.19101450571526368, 0.12429273845272693, 0.20242075595670583, 0.16136007551209386, 0.1831812089279713, 0.2241416374635513, 0.03592097336310418, 0.11325310280468348, 0.10087413634967657, 0.09847480831335265, 0.10668487247617264, 0.14550224996483863, 0.11318266426344659, 0.11718905554655268, 0.15855144391381615, 0.14220864847151882, 0.1060575894949981, 0.09537798370702022, 0.09194449943958849, 0.09527411026784116, 0.1213042167573487, 0.1005075245052538, 0.142066816092832, 0.09608474391120003, 0.10888748104152113, 0.8509725972558827, 0.8351371697673207, 0.7370940342043992, 0.8419153171193096, 0.8325973949238501, 0.8440550841515522, 0.9157508003182263, 0.9556719114458667, 0.8779253836487444, 0.3133463520971963, 0.24167938944911416, 0.3045884612580272, 0.32310108444984176, 0.2690624925657701, 0.28709550739673817, 0.27523701579713, 0.26293026933055275, 0.21619094918755832, 0.21969213688370437, 0.28403867069994027, 0.26288433720761817, 0.3014201255298945, 0.25582553181659995, 0.2766121163759875, 0.29905347560385487, 0.34717929987809093, 0.23330572782748626, 0.17895154839490757, 0.13018378177918655, 0.13469969862071707, 0.1712186113638967, 0.13619995809535035, 0.11489620943536705, 0.14289472968692896, 0.1590032153212726, 0.1441514711259695, 0.3027678881211652, 0.14766486140325064, 0.1292864856502901, 0.1499990013568846, 0.1260778534539344, 0.12651111284808303, 0.11483102210831164, 0.15983890876393236, 0.15375313186738604, 0.0023183062139296995, 9.999999999998899e-05, 0.06299391142859934, 9.999999999998899e-05, 0.007526661629526643, 9.999999999998899e-05, 0.023754407874763794, 9.999999999998899e-05, 0.013991196443823517, 0.07148615063115327, 0.06555952909833285, 0.06892842351260275, 0.10199820039272489, 0.08917357406670523, 0.07781127109632269, 0.07456715357046773, 0.0709489655954687, 0.0697858779345375, 0.030047469427603057, 0.044814966157753267, 0.044658428017004925, 0.0779807046975618, 0.1196482206590912, 0.03440801409695593, 0.06679942933200855, 0.08465875846920845, 0.05663028645878143, 0.1257204304241636, 0.1306743117207526, 0.08788137872713542, 0.17917521190177, 0.05888393480263909, 0.07585984425070602, 0.0744014397894629, 0.08918054813757448, 0.08661322857886866, 0.3637462089776631, 0.3631947429043848, 0.38872523538595083, 0.4097064740463444, 0.35110806326605903, 0.3718718728553565, 0.38298058010031355, 0.3822369321497444, 0.36652706297910476, 0.14245187045015595, 0.0818784954594255, 0.10556069150800629, 0.10277180908742123, 0.09601030683113221, 0.10972940980754853, 0.11785563660641307, 0.11501167337217688, 0.13286087679554204, 0.26776678704207146, 0.178006100287449, 0.18400608296259002, 0.14798379087553515, 0.20056949588423434, 0.23682304553718803, 0.1864347727516692, 0.16788731823368364, 0.16202253758849416, 0.24307621831202575, 0.2339436269446875, 0.24095815191734937, 0.23425353468888244, 0.25431880257083517, 0.23560596543210788, 0.24858791513497447, 0.24410141185706724, 0.26251181365010134, 0.18150679079755971, 0.156108285012599, 0.16867277837443762, 0.21995425320093787, 0.1772664859641302, 0.2030438683706577, 0.18204266029826477, 0.17351352565994826, 0.20948850990066503, 0.2661213820898839, 0.18423574945606247, 0.19094675753315427, 0.24580339063205037, 0.18481448513602772, 0.18728695328278988, 0.1824673599206087, 0.19111600779954796, 0.25818254871270685, 0.18402509627191288, 0.17947682480084093, 0.18216000738721183, 0.1748418737534192, 0.18537881958053737, 0.19117459743384813, 0.1787385754677454, 0.19196311706583036, 0.2188076340536208, 0.5594802068720506, 0.1642931491782088, 0.20420283524725902, 0.5708455531929657, 0.338315314679586, 0.18518622805197082, 0.17010681257292437, 0.2601944373670688, 0.6652655469360796, 0.38344054270512173, 0.35343202587750067, 0.2027630326859151, 0.3021678095338344, 0.3232536624048804, 0.2199151234135649, 0.2077947115419313, 0.4304761256627885, 0.45309525075039514, 0.2046057578265974, 0.1991352758614413, 0.19068407479500504, 0.2216188315136094, 0.19703929467805803, 0.20180219794674104, 0.1935814302566492, 0.20941853740625738, 0.19125256835627535, 0.09608156173626736, 0.0980169477503483, 0.08479338925732915, 0.07398293885355955, 0.08935697474946391, 0.07339568176998723, 0.08169639615585678, 0.07334624310710403, 0.08151468544043095]}, "mutation_prompt": null}
{"id": "0f7b064f-d355-470e-af24-34f5b8658653", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "c7ece2ba-8555-4d63-a70c-070d8f785ea2", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # adjusted adaptive population size\n        self.F_min = 0.5  # differential weight lower bound\n        self.F_max = 1.0  # differential weight upper bound\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Self-Adaptive Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with self-adaptive F\n                F = np.random.uniform(self.F_min, self.F_max)\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n            step_size = 0.03 + 0.07 * (1 - evals / self.budget)  # dynamic step size\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, step_size)\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Management\n            if evals < 0.5 * self.budget and len(population) < 1.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (7, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm leveraging Self-Adaptive Differential Evolution, Dynamic Local Search, and Adaptive Population Management to achieve superior exploration and exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.3065098755726972, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7209190021913341, 0.7192949294632348, 0.7088158539115426, 0.7343698497590905, 0.736448881255017, 0.7483488772569802, 0.7347648290329027, 0.7012666049289509, 0.7039359971406094, 0.42744278293508564, 0.4814575743250683, 0.38606804567486885, 0.40209411781343596, 0.44922419184893037, 0.41531880915373687, 0.4511282729902716, 0.44687348434627194, 0.4429474987758447, 0.10639202918200208, 0.12427003220945532, 0.12486979524896469, 0.11999681547527785, 0.11472961768967893, 0.11177230117963477, 0.14650886296429322, 0.14198554715316658, 0.10885146942209778, 0.1178912764187493, 0.10189122240884552, 0.09416593883705848, 0.14263801331758863, 0.1139357487793623, 0.09619034868458476, 0.1446788629287148, 0.11765179333580456, 0.12917722826133793, 0.9597777356328536, 0.9633893533926184, 0.9474399113645273, 0.9570532917239403, 0.9474008179846046, 0.9444465797800944, 0.9571143755319989, 0.9674610355135824, 0.9443598185029752, 0.33497343204380714, 0.3277753056110214, 0.3340032829580116, 0.3228469995745923, 0.33178098144810697, 0.33208918108526, 0.34492661242908595, 0.3266948015011514, 0.32149356630658166, 0.6379966216215522, 0.5090714534314941, 0.5764331184397308, 0.5641572514364599, 0.6222293212339345, 0.7221742875409392, 0.6323686834056934, 0.5941358737737066, 0.5715007066295943, 0.25924815625228326, 0.19896620491643857, 0.21031825970620088, 0.24188002974253342, 0.2924115384730467, 0.1780550644498422, 0.24304191544408027, 0.2414972152954119, 0.2239915934109714, 0.22799945055913085, 0.37232107424638483, 0.24965897641739698, 0.27604009774275085, 0.22349077041602372, 0.21248976537616504, 0.22779184080066495, 0.2559494851707914, 0.19599900431635608, 0.1526599785606637, 0.12526969895054463, 0.14039925879019632, 0.16453884431741683, 0.2081944094427447, 0.13145366210444898, 0.18268237379849916, 0.1628108224872602, 0.173468461162952, 0.27861933035973296, 0.2705473279499835, 0.2634083939145049, 0.26122412520945903, 0.2801257020306003, 0.28087145835572935, 0.326883028721358, 0.34775688726676757, 0.32450206484284205, 0.05506451893281372, 0.07027306679016032, 0.043003878657579264, 0.05764769167157424, 0.047651442075047123, 0.0970458898470955, 0.06381580103391205, 0.07456025469354277, 0.07615058906969385, 0.19101390457589018, 0.20967135303612616, 0.20983446173553089, 0.18075690564850888, 0.2108641753553656, 0.1844138795158623, 0.18947986954659468, 0.18140552681306055, 0.19544981096242742, 0.5479710261436721, 0.5233088245684182, 0.5511614040697206, 0.49788226655974555, 0.5415356569708085, 0.5320136716414748, 0.5493200953733968, 0.5008111768191339, 0.5429643565791877, 0.1260667063059665, 0.10481178202414942, 0.0939971718731194, 0.12739866974841185, 0.11212160867489696, 0.09369353874996356, 0.08806199094547051, 0.12235749672665519, 0.10276138719445227, 0.163816016526933, 0.21868482659609245, 0.16331815912631542, 0.15761185255156784, 0.15203513027490556, 0.18890694758044546, 0.21669644372518893, 0.1499675304064595, 0.1452434902247991, 0.31174551119311755, 0.3133339707793903, 0.28737902405166005, 0.2599187982836394, 0.299167562801147, 0.30421046182101985, 0.3114134585008522, 0.3186502819899808, 0.3153558489939948, 0.21805844037238975, 0.23288532502003634, 0.23344271586348297, 0.24280007578742158, 0.20452892425635505, 0.21750280480451134, 0.24122936146896679, 0.23793223067591507, 0.23399891379380156, 0.1931926792600026, 0.24472337588841786, 0.17168061780624522, 0.2236639327312856, 0.18309611817591898, 0.2082976836726933, 0.1894879675597273, 0.23210692037259617, 0.1862247081068682, 0.19167900053390374, 0.17767918070356536, 0.20327040471049562, 0.24120807669963373, 0.19809226408231773, 0.36604604950969255, 0.18730498736625778, 0.21837480519466768, 0.18485933094193752, 0.7162431154640998, 0.18503125971131673, 0.15083976721058112, 0.3684733008893911, 0.45891246379790385, 0.5157909108453486, 0.17743218626423474, 0.19899642910742565, 0.8345402214959866, 0.6693584667815451, 0.20468474687457994, 0.8205415359801772, 0.4064198029684756, 0.3931217244042359, 0.2034773733450017, 0.7335240985961664, 0.20500974499120694, 0.204542929505951, 0.17713912146051802, 0.19842376715372134, 0.18666789185210286, 0.21097850487287495, 0.21502028311273524, 0.20782327894711605, 0.20578545569221263, 0.21218271593268245, 0.20279807304048736, 0.08860218848536117, 0.08985615903001976, 0.07904675971083819, 0.08526062217986641, 0.0950681382835522, 0.07214712660504774, 0.07902698929619179, 0.06905579058074418, 0.07716894031695831]}, "mutation_prompt": null}
{"id": "4de98828-3c8c-46e8-99a3-241443fe13d4", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # slightly increased adaptive population size\n        self.F = 0.85  # increased differential weight\n        self.CR = 0.8  # slightly reduced crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase with Gaussian Perturbations\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.1)  # adjusted step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Population Expansion\n            if evals < 0.4 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (8, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid algorithm integrating Differential Evolution, Local Search with Gaussian Perturbations, and Dynamic Population Expansion for enhanced search efficiency within a limited budget.", "configspace": "", "generation": 18, "fitness": 0.25109620132621685, "feedback": "The algorithm RefinedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.6208910286882214, 0.6580433629525632, 0.6278166527054196, 0.6322323825982986, 0.635193502908769, 0.7159688194653002, 0.6383545581380135, 0.661505239557759, 0.6727632634170659, 0.30772407035940974, 0.3567971022391624, 0.331489746768338, 0.31750159428643, 0.3187694992401132, 0.32375779153078055, 0.33547099810971737, 0.33263567259876625, 0.34462328330929526, 0.12765251078853013, 0.12228345439653765, 0.12697760488449217, 0.1088298031335988, 0.11556527947831163, 0.1284997608781263, 0.10846943029877953, 0.12324133066003884, 0.13666716262241407, 0.11203042789384576, 0.13634181907624732, 0.12987904001395423, 0.10760477803494928, 0.1434696841584009, 0.1294347264199439, 0.09912959396750143, 0.10230842837721921, 0.11142686915836697, 0.9244499917541891, 0.9419922402752989, 0.9658027030693115, 0.9332928445090618, 0.9364238596909155, 0.9205962103365861, 0.9608114799027625, 0.9652846720126329, 0.9622296854986538, 0.27156567282270894, 0.24153058856154475, 0.2560384299729408, 0.2843029460181403, 0.2569448200693387, 0.2703484133955806, 0.2720887285560538, 0.2601432931902422, 0.2716729635603252, 0.2676488939946057, 0.28283721765189074, 0.24965655006007814, 0.5853022676641042, 0.39428715340735265, 0.40822696794557656, 0.2697581068006194, 0.29973464285533, 0.35123619381148785, 0.18255908381299968, 0.1414934372664014, 0.1750922284180242, 0.16534589336951977, 0.19496968242877022, 0.1347404521438631, 0.14929025818878017, 0.20669843766596363, 0.15467202562930304, 0.19576634606765198, 0.186300095906744, 0.11687226121224581, 0.14802372428699961, 0.1877297579628271, 0.15637821159736776, 0.16440065356853117, 0.13424383836788145, 0.18294495927921228, 0.03129970670525506, 0.03438181976304555, 0.017672514949860663, 0.021468002081605264, 0.0616332545710957, 0.012556669410092813, 0.032546601423907306, 0.026446127848153034, 0.020467335877994985, 0.12129630196769503, 0.13063279909216585, 0.15797625786285208, 0.09890036911580424, 0.12574676895744363, 0.09537360393612038, 0.15635649351349312, 0.1664589227906741, 0.16023817549300634, 0.033495040380885466, 0.06683628962553245, 0.027777620880517717, 0.09356479822555408, 0.05148824677881714, 0.02384230280268418, 0.06711724875532787, 0.047632066561865916, 0.09105023645139698, 0.12237985992839773, 0.1356083475669937, 0.13378805596232157, 0.16671735845737312, 0.15378596056552052, 0.14772654576937616, 0.12072587679555491, 0.16435808973841726, 0.11913632464328927, 0.44626965874770996, 0.43316594640072204, 0.4573584615871321, 0.4400341611249743, 0.43226379139010607, 0.4678888897297684, 0.43688178642250786, 0.4379794944178369, 0.4420134056633055, 0.12308431446122536, 0.11546946880824505, 0.1150449505697172, 0.12313844475025049, 0.09634406039286969, 0.14285394588721012, 0.11627276591232116, 0.11319135671026836, 0.08887811852310101, 0.1487625594817188, 0.14990971739261527, 0.17212421617954077, 0.22608712126278951, 0.15980816609907522, 0.16073128288574157, 0.15904036594313475, 0.18372929306666597, 0.1589951293434244, 0.2641645127287321, 0.26210163552319576, 0.259784043703035, 0.23724227723413782, 0.2566990876168205, 0.23624898936343985, 0.2848486782686286, 0.2695127609168002, 0.2780068319835537, 0.1984537736948716, 0.16514887253577581, 0.19113630379469382, 0.192786717901134, 0.1768914653969076, 0.18003833339939213, 0.23050088603522545, 0.21215156667973323, 0.20738888688958945, 0.19988677932676713, 0.20466641666604068, 0.18746803083201447, 0.19965482550963265, 0.1972824899252511, 0.19821907167623842, 0.19824391851991785, 0.1877849734799132, 0.17613711063111492, 0.1844792623001814, 0.20177680749381266, 0.20099764115624374, 0.19896183722833094, 0.2054199202534801, 0.20552665545464, 0.1936888766781647, 0.2076054209287418, 0.1899071706654667, 0.3569276784904264, 0.6525241864880473, 0.4754463384162353, 0.7559293893952309, 0.3716752850857272, 0.19413597897549684, 0.17276486594121487, 0.33798128746290734, 0.5813939052499284, 0.434091994877032, 0.41652752415351335, 0.2290489463012253, 0.33758642394246796, 0.16029355674099044, 0.2023444143433244, 0.20106827868143984, 0.21008791975686458, 0.1993074319353475, 0.18098044293394688, 0.19644775537034986, 0.18915686458935288, 0.19934779173106498, 0.2095946917470931, 0.21463470608448776, 0.21880722325387192, 0.19449485976834158, 0.21030823627553896, 0.08100451510081808, 0.086501935999307, 0.08000752468821704, 0.08802229750591084, 0.07419429949577694, 0.0841508092501293, 0.08576014612152283, 0.07662862880596844, 0.06790649303292973]}, "mutation_prompt": null}
{"id": "1baa7c56-0dcf-4514-873c-e3d50c3426e9", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "f3db9a93-c77d-42d6-94d7-9b02e7b51749", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for d in range(self.dim):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual.copy()\n                step = np.random.normal(0, 0.05)  # smaller step size\n                neighbor[d] += step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.5 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution, Local Search, and Adaptive Population Sizing to efficiently explore and exploit the search space within a given budget.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.7407335468994471, 0.7128605355109571, 0.7580588829112203, 0.7296313651314654, 0.7256301250409078, 0.7335232979679105, 0.7381134367273008, 0.7464996446519883, 0.7377277421546189, 0.4728656337028416, 0.47784029752868584, 0.4403554182890346, 0.44011199824333236, 0.4801605751288027, 0.46192102605736596, 0.4562298684368501, 0.4703105156738906, 0.46429489715631445, 0.125779417160244, 0.10787868789562982, 0.11923522550069465, 0.13384134102932532, 0.11226271760898288, 0.13415090360705562, 0.12223000153608388, 0.12425675397107516, 0.1355590352060757, 0.11084960407144395, 0.10130301272118936, 0.14311417007798644, 0.11833471546499619, 0.1015564416951874, 0.10436313933898145, 0.13249119697212586, 0.09900191497990785, 0.1302029883992396, 0.9215057638414397, 0.9135394396194001, 0.9247300779955704, 0.9560433419403954, 0.9481475109872853, 0.935546957435667, 0.9773112781907711, 0.9687643602946295, 0.9790109416468319, 0.3290186015342351, 0.33130480598598866, 0.3569826456340125, 0.37350000495863056, 0.33878237350459295, 0.3303842302714284, 0.3587629980601479, 0.36944637888708487, 0.33996788091664565, 0.609397189387137, 0.5587650262105721, 0.5907082880639212, 0.7128354124438783, 0.5747757218398596, 0.5778677298622887, 0.5682919684950423, 0.5946542540983947, 0.6564118166084235, 0.2500878192404834, 0.2476768760986594, 0.25669791049684176, 0.24617730059124, 0.24004161478585395, 0.2826040733693449, 0.3297275635786746, 0.2646262110512625, 0.32855940422717844, 0.1511815566123207, 0.2514196455936972, 0.18170176615188194, 0.22809709976518056, 0.26097454758604677, 0.27231388260993394, 0.24440459682865157, 0.1953596177390594, 0.20559513293629617, 0.16457652539474543, 0.2031868909811203, 0.15011312975595137, 0.16351282647941956, 0.15298960470455258, 0.2011177575129991, 0.1785684152883641, 0.15327721348575618, 0.1819301325125563, 0.3196134050595303, 0.26579264978028205, 0.28903550618470686, 0.26927795696647605, 0.28775756793387597, 0.2980745736297964, 0.3257920018306636, 0.3168326300197798, 0.29357833024725344, 0.1107870156568257, 0.13564052576494245, 0.09530978524593015, 0.062140526792925255, 0.13785138947491327, 0.08425780770321656, 0.08513803500429962, 0.1584779865975543, 0.08481613669593535, 0.19754988068329382, 0.20861989560599958, 0.21840372853398327, 0.2102209022396494, 0.19157809304314943, 0.21088938651012334, 0.19735985510513165, 0.20373922461154237, 0.20692754738093322, 0.5227421254638493, 0.522023906836552, 0.5030456784477684, 0.516751660827007, 0.5515059856619593, 0.5138252388915394, 0.5245649899969878, 0.5282515805992885, 0.4985335781509934, 0.12642690999399597, 0.0913136816171316, 0.12152620713903617, 0.13528954904881263, 0.105596988812248, 0.10752443915085819, 0.1124321875487907, 0.13502954803788214, 0.13175209315591707, 0.18625357508695684, 0.19419953067179307, 0.20491531930322604, 0.18535376137976534, 0.20116721780508107, 0.18276904022902707, 0.17807242419965919, 0.2756242048779778, 0.30199863046329267, 0.30159708675973296, 0.298701976167153, 0.31601774551363415, 0.30032029237877444, 0.2868828067785848, 0.2930591640301363, 0.3210040977269515, 0.3139471070863409, 0.3243631277431931, 0.25880996695821135, 0.2519498249537355, 0.25520885592107434, 0.21255893987140906, 0.24666932376332162, 0.21819227967560928, 0.24941204619192103, 0.26079772404800383, 0.23960934476252072, 0.2054617520966857, 0.20749909481840745, 0.20968934161947594, 0.20186287340286413, 0.1882468887257588, 0.19275405129626355, 0.21794072359541494, 0.19734055649346283, 0.19144145441283666, 0.1914253915043781, 0.18725843498066574, 0.33651761707196914, 0.1943797667845042, 0.1936504404515137, 0.1861328029585928, 0.22363941316357538, 0.1858874859030749, 0.18834731089978263, 0.7015924179885402, 0.19426871824188563, 0.6876399073434407, 0.7742390658091589, 0.636428140578835, 0.17844282316224036, 0.36423234830563755, 0.6060843189576488, 0.7212493994764915, 0.5901847713644157, 0.20370759702861785, 0.6473895826347591, 0.1920663632665931, 0.3732833789574673, 0.475571232968634, 0.20788875089294578, 0.1259777509535861, 0.15143994210638845, 0.22174155773964332, 0.1848082195487264, 0.19642071518133686, 0.19553528343128934, 0.21254657894035456, 0.1741616346721555, 0.2039769599588963, 0.22948024126322808, 0.22549224847013727, 0.08170148624621798, 0.10556930267316433, 0.08565079059963077, 0.09841733360967575, 0.07835914426645862, 0.08829445471630659, 0.09277837853007731, 0.08242798848469479, 0.08893479918143199]}, "mutation_prompt": null}
{"id": "7e338c9f-cfc3-462e-b667-8bf1485e22dd", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 30)  # adaptive population size\n        self.F = 0.7  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3, self.dim)):  # tweak to consider multiple dimensions\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.6 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm integrating Differential Evolution with a strategic local search and progressive population adaptation for improved convergence efficiency.", "configspace": "", "generation": 21, "fitness": 0.3775569609663635, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "21866f08-034c-4077-814b-071c373ad182", "metadata": {"aucs": [0.8230148570100105, 0.8252883507562973, 0.8025480405379098, 0.8302159244887286, 0.829158710121967, 0.8147824460790865, 0.8214829135829889, 0.8202524607064821, 0.8243260763946261, 0.6735867249452945, 0.6633624133467534, 0.6599607488473527, 0.671780165472688, 0.6862287920112662, 0.6775804284912104, 0.6631971014922409, 0.6772080067957504, 0.6684743006304728, 0.1277936165574487, 0.12904419378077858, 0.12516855455251863, 0.15582681030792023, 0.16184623690898647, 0.12107790437147581, 0.1332482636007709, 0.15574143223177017, 0.11168734544820869, 0.11794583928337865, 0.12716250607071855, 0.12595078629675094, 0.11941759513914274, 0.12273016133744297, 0.15467254537009267, 0.12267854247618304, 0.10912077856586966, 0.12786696035541956, 0.9493254145730232, 0.9624121929460703, 0.9434916741551378, 0.9604168150245859, 0.9817683295256768, 0.9403009431293796, 0.9625119098772422, 0.9725270361661992, 0.9030838496113416, 0.5301506625692036, 0.497441046000776, 0.48118561783903246, 0.48462647882884835, 0.4809170987601572, 0.5037356095591716, 0.5102773768371875, 0.4787505098158069, 0.49124386846213, 0.6723864044915658, 0.7655460622744862, 0.6480107268316062, 0.7758597911291724, 0.774192212225711, 0.685142353177999, 0.7682083321299156, 0.7417202662408771, 0.771418863378886, 0.3517103568415101, 0.40198988159234883, 0.4722989053468377, 0.35701499233275813, 0.44516373593752145, 0.43319027479401173, 0.3580429128024708, 0.2918088057274012, 0.3874681239211375, 0.14101476850966688, 0.4140602684867217, 0.4339123034115968, 0.4163269665362095, 0.3704142409982193, 0.3352253517734436, 0.389764568346621, 0.4510289403636796, 0.3786826179675067, 0.28541048655965584, 0.259280051762937, 0.32170202316985796, 0.2627546053520303, 0.2574019671416732, 0.26331487372857, 0.2796837688260705, 0.2839138803917043, 0.31447133990165643, 0.43617954493756916, 0.39613394461843987, 0.35099958644575924, 0.39361404947057255, 0.396473352100721, 0.4350786163757415, 0.41683197046239606, 0.4600100527243649, 0.43972586789794144, 0.10416101594119498, 0.15684841443243913, 0.08305151086415807, 0.16511798288904977, 0.15403715931013628, 0.16491691761078342, 0.13012363646599767, 0.08100557192691216, 0.07567611925068851, 0.24934831564398074, 0.27792800555459385, 0.24401232940567774, 0.28844910731553386, 0.2993624018460438, 0.2905887434799048, 0.28388323918096126, 0.28677655978197447, 0.2424760160848416, 0.6391612156978099, 0.6770180423644008, 0.6516930270139539, 0.6684469375365071, 0.6434672764195561, 0.6644173127031356, 0.6424889096523274, 0.6885338240488742, 0.6368171455852475, 0.1292759724727064, 0.1450961624720125, 0.12615231798817017, 0.1342809128567649, 0.10639621140263666, 0.10018598794415534, 0.1189274201719962, 0.10277295636246597, 0.08907455724011704, 0.18386177198630071, 0.1628480967847591, 0.15622049453208364, 0.14704031315600774, 0.23273572506251217, 0.19311507501925362, 0.21493536261561608, 0.18509403847360817, 0.22409746409334708, 0.36842258873976375, 0.39759922627138156, 0.3648656328700878, 0.3541625262857335, 0.3903076452118648, 0.3410536098978433, 0.38661108327249993, 0.4118448442120247, 0.39509049125627804, 0.27551570460947017, 0.2623861698889288, 0.27904510117635495, 0.24535890456357934, 0.27974325491636964, 0.26909826655315716, 0.29125004471042115, 0.31900540152697887, 0.32137907062131954, 0.20931844174071124, 0.19029507879236573, 0.18470559068344383, 0.19922268670956889, 0.17804045161666449, 0.19907745997177406, 0.21074317170905343, 0.1958178850900747, 0.20473500062548278, 0.21184702129910538, 0.2842226698071706, 0.21685888298488798, 0.22971229917834668, 0.20502731252998496, 0.19939260984388452, 0.24799805895828764, 0.24298116611829634, 0.1985130876884974, 0.7971824991467384, 0.1531347064171441, 0.8442051808127269, 0.18368953302865998, 0.7007164285512568, 0.7279119427052676, 0.8236077539328238, 0.1822638265297446, 0.7163930450747136, 0.7887981618258963, 0.2067238724017204, 0.7187222841331027, 0.2075540375791306, 0.7778266302759123, 0.20233029005196512, 0.19669492309332304, 0.20742512268234303, 0.2086356771951443, 0.17070331054801624, 0.18388055149394744, 0.19238446627787664, 0.17777710445202588, 0.1910424316064947, 0.17635596501676465, 0.18201054456761168, 0.19101776570215057, 0.19333123777368744, 0.07984927547949827, 0.08935476081963101, 0.0801701474088875, 0.08057563581134364, 0.08867671690368639, 0.07741304204110278, 0.07647406528361667, 0.09032927536541535, 0.08379735868777771]}, "mutation_prompt": null}
{"id": "6e223718-fce4-4e63-b9c2-b0774445d08a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 30)  # adaptive population size\n        self.F = 0.7  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3, self.dim)):  # tweak to consider multiple dimensions\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Sizing\n            if evals < 0.6 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm integrating Differential Evolution with a strategic local search and progressive population adaptation for improved convergence efficiency.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7e338c9f-cfc3-462e-b667-8bf1485e22dd", "metadata": {"aucs": [0.8230148570100105, 0.8252883507562973, 0.8025480405379098, 0.8302159244887286, 0.829158710121967, 0.8147824460790865, 0.8214829135829889, 0.8202524607064821, 0.8243260763946261, 0.6735867249452945, 0.6633624133467534, 0.6599607488473527, 0.671780165472688, 0.6862287920112662, 0.6775804284912104, 0.6631971014922409, 0.6772080067957504, 0.6684743006304728, 0.1277936165574487, 0.12904419378077858, 0.12516855455251863, 0.15582681030792023, 0.16184623690898647, 0.12107790437147581, 0.1332482636007709, 0.15574143223177017, 0.11168734544820869, 0.11794583928337865, 0.12716250607071855, 0.12595078629675094, 0.11941759513914274, 0.12273016133744297, 0.15467254537009267, 0.12267854247618304, 0.10912077856586966, 0.12786696035541956, 0.9493254145730232, 0.9624121929460703, 0.9434916741551378, 0.9604168150245859, 0.9817683295256768, 0.9403009431293796, 0.9625119098772422, 0.9725270361661992, 0.9030838496113416, 0.5301506625692036, 0.497441046000776, 0.48118561783903246, 0.48462647882884835, 0.4809170987601572, 0.5037356095591716, 0.5102773768371875, 0.4787505098158069, 0.49124386846213, 0.6723864044915658, 0.7655460622744862, 0.6480107268316062, 0.7758597911291724, 0.774192212225711, 0.685142353177999, 0.7682083321299156, 0.7417202662408771, 0.771418863378886, 0.3517103568415101, 0.40198988159234883, 0.4722989053468377, 0.35701499233275813, 0.44516373593752145, 0.43319027479401173, 0.3580429128024708, 0.2918088057274012, 0.3874681239211375, 0.14101476850966688, 0.4140602684867217, 0.4339123034115968, 0.4163269665362095, 0.3704142409982193, 0.3352253517734436, 0.389764568346621, 0.4510289403636796, 0.3786826179675067, 0.28541048655965584, 0.259280051762937, 0.32170202316985796, 0.2627546053520303, 0.2574019671416732, 0.26331487372857, 0.2796837688260705, 0.2839138803917043, 0.31447133990165643, 0.43617954493756916, 0.39613394461843987, 0.35099958644575924, 0.39361404947057255, 0.396473352100721, 0.4350786163757415, 0.41683197046239606, 0.4600100527243649, 0.43972586789794144, 0.10416101594119498, 0.15684841443243913, 0.08305151086415807, 0.16511798288904977, 0.15403715931013628, 0.16491691761078342, 0.13012363646599767, 0.08100557192691216, 0.07567611925068851, 0.24934831564398074, 0.27792800555459385, 0.24401232940567774, 0.28844910731553386, 0.2993624018460438, 0.2905887434799048, 0.28388323918096126, 0.28677655978197447, 0.2424760160848416, 0.6391612156978099, 0.6770180423644008, 0.6516930270139539, 0.6684469375365071, 0.6434672764195561, 0.6644173127031356, 0.6424889096523274, 0.6885338240488742, 0.6368171455852475, 0.1292759724727064, 0.1450961624720125, 0.12615231798817017, 0.1342809128567649, 0.10639621140263666, 0.10018598794415534, 0.1189274201719962, 0.10277295636246597, 0.08907455724011704, 0.18386177198630071, 0.1628480967847591, 0.15622049453208364, 0.14704031315600774, 0.23273572506251217, 0.19311507501925362, 0.21493536261561608, 0.18509403847360817, 0.22409746409334708, 0.36842258873976375, 0.39759922627138156, 0.3648656328700878, 0.3541625262857335, 0.3903076452118648, 0.3410536098978433, 0.38661108327249993, 0.4118448442120247, 0.39509049125627804, 0.27551570460947017, 0.2623861698889288, 0.27904510117635495, 0.24535890456357934, 0.27974325491636964, 0.26909826655315716, 0.29125004471042115, 0.31900540152697887, 0.32137907062131954, 0.20931844174071124, 0.19029507879236573, 0.18470559068344383, 0.19922268670956889, 0.17804045161666449, 0.19907745997177406, 0.21074317170905343, 0.1958178850900747, 0.20473500062548278, 0.21184702129910538, 0.2842226698071706, 0.21685888298488798, 0.22971229917834668, 0.20502731252998496, 0.19939260984388452, 0.24799805895828764, 0.24298116611829634, 0.1985130876884974, 0.7971824991467384, 0.1531347064171441, 0.8442051808127269, 0.18368953302865998, 0.7007164285512568, 0.7279119427052676, 0.8236077539328238, 0.1822638265297446, 0.7163930450747136, 0.7887981618258963, 0.2067238724017204, 0.7187222841331027, 0.2075540375791306, 0.7778266302759123, 0.20233029005196512, 0.19669492309332304, 0.20742512268234303, 0.2086356771951443, 0.17070331054801624, 0.18388055149394744, 0.19238446627787664, 0.17777710445202588, 0.1910424316064947, 0.17635596501676465, 0.18201054456761168, 0.19101776570215057, 0.19333123777368744, 0.07984927547949827, 0.08935476081963101, 0.0801701474088875, 0.08057563581134364, 0.08867671690368639, 0.07741304204110278, 0.07647406528361667, 0.09032927536541535, 0.08379735868777771]}, "mutation_prompt": null}
{"id": "8d68751b-e955-4b3b-a73c-388fd9479471", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.3866210941634528, "feedback": "The algorithm AdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "7e338c9f-cfc3-462e-b667-8bf1485e22dd", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "ed39902c-766c-45cc-90e7-d3671c3f7934", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "68ec27b6-5663-49f3-a279-000fc30c5dbc", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "9dcf8478-2cb0-40ed-90b5-2fb32b53350a", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "a86c9eb5-03e3-4207-b864-daf4d9fbfc66", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "65c6e0c3-fd25-4988-b5d2-8ddb25022927", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "fff550a1-5fe4-40ee-a098-b38d0fa0d7f8", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "86e3697e-afaf-48ca-86db-8223bf31ed3a", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "83a61b83-b442-49db-ab28-0287ee3abf2b", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "fd4d3255-b3fc-4de3-adf3-b4ccfceddae3", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "9a065297-0fe1-48f0-a73c-b049f65d823c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # adjusted adaptive population size\n        self.F = 0.7  # slight increase in differential weight\n        self.CR = 0.85  # slight decrease in crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with adaptive scaling\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F_adaptive = self.F * np.random.uniform(0.5, 1.5)\n                mutant = np.clip(a + F_adaptive * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Enhanced Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3, self.dim)):  # reduced local search iterations for efficiency\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Probabilistic Adaptive Diversity\n            if evals < 0.5 * self.budget and np.random.rand() < 0.5:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm integrating Differential Evolution with an advanced dynamic local search and probabilistic adaptive mutation for robust exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.3098725420581419, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.7174841848724722, 0.725326200356235, 0.7098138864012905, 0.7316369611341941, 0.7328005611635171, 0.7360393060621082, 0.7313507752100286, 0.7423127546147636, 0.7230094083857188, 0.5093011907593409, 0.47454470244823355, 0.49235352124298604, 0.4704931463660582, 0.5202119495681746, 0.4946705501069958, 0.4750775635471437, 0.5013980735020747, 0.5096179190796934, 0.13508440547869416, 0.12606984527327147, 0.12141834156321696, 0.1325809053218534, 0.1355178133531717, 0.14488671605092807, 0.12500800706517134, 0.1153346209241094, 0.14646383563341492, 0.11200731829110677, 0.10691197973889188, 0.10639651477433165, 0.12124376081501265, 0.10644462886751227, 0.11484164478107683, 0.12495275437820619, 0.10900449614729024, 0.10673448293234833, 0.9017848760604168, 0.9033303900862368, 0.91249188079169, 0.9584552307010756, 0.9127404092097622, 0.9109405923006664, 0.9274148521668314, 0.9353490868514789, 0.9732071080415496, 0.3738706757486969, 0.3230814521791181, 0.366226709542507, 0.3496468364316573, 0.3650703919972009, 0.3815260174938281, 0.38369008186127007, 0.3710697489887168, 0.35747913587267033, 0.6176166695194736, 0.6164246594047207, 0.5917027294800874, 0.5732275090235285, 0.6136788155920845, 0.6587770329140257, 0.6162151747092075, 0.711506009641678, 0.6860324125171701, 0.2318738377266193, 0.2383688564148806, 0.24218455354656565, 0.244721277196985, 0.22270301900719558, 0.20492391722648073, 0.24488137638808183, 0.26768679371836546, 0.22503706620856123, 0.1408785751873105, 0.28831243032709586, 0.22618115727162846, 0.2856624261689683, 0.2564129662252135, 0.2275133785208775, 0.2294540568336746, 0.24198509747433006, 0.20448163829788457, 0.14989356622823946, 0.15363071445019905, 0.12696730839391057, 0.15169041545973228, 0.12660179673247562, 0.11983070745238433, 0.1362920909133869, 0.14393873966359427, 0.10989457512642331, 0.2798759348790103, 0.25430791713862355, 0.2485927771957661, 0.23959443076437204, 0.25509650741457646, 0.21487805407467409, 0.30806692009138636, 0.27089360302189935, 0.30000890925504786, 0.07093274998317411, 0.010025212557256413, 0.02950256612589741, 0.03526842672653352, 0.07331628322890216, 0.04476690009471129, 0.054269261093098375, 0.05980366569152251, 0.06090986390963149, 0.17589531012723714, 0.20239422740650947, 0.17069483340352032, 0.21396586150598074, 0.18550722053377744, 0.1965230019004348, 0.17791822010642133, 0.17856659368954497, 0.19027294084982882, 0.5165869594583534, 0.5944082544326373, 0.559154043741515, 0.5566840870608154, 0.5298124888886178, 0.5558987808084112, 0.535450528577571, 0.5434628053758572, 0.540457476424673, 0.12271546812978507, 0.10374949944213496, 0.10494065914466133, 0.11484376853532519, 0.13378647774883523, 0.12031152551546109, 0.10562898421047884, 0.1047722351281376, 0.13409655189577785, 0.1895137612180503, 0.2066107522597499, 0.28610640434246415, 0.21796403717467538, 0.22647709695167784, 0.18499934871927926, 0.20762678472763751, 0.18037993181602996, 0.17203464552727943, 0.32906656184003746, 0.32636458951007385, 0.30763253844957306, 0.32324656002352636, 0.332959252980208, 0.3328761197239153, 0.3472594555018894, 0.3422458736402555, 0.3328937055876473, 0.23089347889127732, 0.2291537727086086, 0.22658830896448912, 0.23388933176748083, 0.23973950478912764, 0.2497019971194412, 0.25218000459934353, 0.2735393471199905, 0.25801190441917343, 0.19905518833289548, 0.19590898105445298, 0.20254040886241131, 0.2059815751121462, 0.19378664238244536, 0.18368123272662407, 0.20542064469071997, 0.20062250264514292, 0.18229965528340208, 0.2193600140816392, 0.251355883016001, 0.1981211482268087, 0.19434892244463253, 0.23976462442669622, 0.19386674304664153, 0.19880827874888807, 0.24348730162885424, 0.19232551247157303, 0.16344793755136577, 0.647834233925529, 0.1836707305258185, 0.6957611036396903, 0.3278304550375597, 0.6118728676143654, 0.6660759164758696, 0.16654917933236413, 0.6056682383792922, 0.6160818043991287, 0.20963174008587526, 0.4745514698891061, 0.5842661496362764, 0.20581037446748418, 0.6167732341911296, 0.20942348592209614, 0.20975354517235878, 0.2070213254746931, 0.18194564887108422, 0.19254417753132014, 0.18301915756600617, 0.17575592288102126, 0.18976262290032642, 0.19447501606385453, 0.18223729507702924, 0.1881810260914233, 0.1755036129885762, 0.08330992172260654, 0.0819993072164622, 0.07654102526521878, 0.088429345342944, 0.08087515139117984, 0.07746094370045697, 0.07255791590151872, 0.08013016106372184, 0.08351437092157599]}, "mutation_prompt": null}
{"id": "f8427e90-2e88-4249-885b-6dcd1687984d", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "8fedc729-4e85-4619-9b14-37e7a71c2b1d", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "180f2956-ce26-4a17-b17a-12fac13c6737", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "478fef1a-b57a-4fda-9d8a-47d15bd71354", "solution": "import numpy as np\n\nclass RefinedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.7  # slightly increased differential weight for better exploration\n        self.CR = 0.85  # slightly decreased crossover probability for more diversity\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Enhanced Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhanced local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)  # finer local search\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Population Control\n            if evals < 0.4 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))  # more aggressive population growth\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedAdaptiveHybridDifferentialEvolution", "description": "A refined adaptive hybrid algorithm using Differential Evolution with enhanced local search and dynamic population control to balance exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.33118842634112944, "feedback": "The algorithm RefinedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.7609139733437886, 0.7583128923355016, 0.7727099644216042, 0.7588466016858949, 0.7640880006747603, 0.7603895198122523, 0.7712639358568693, 0.7614783234788128, 0.7670346883020451, 0.5655601010029955, 0.5435946262413367, 0.5219733451506945, 0.5626261150522944, 0.5377095975433133, 0.5476582893070164, 0.5612494425471259, 0.5313015211440407, 0.5921369543160386, 0.11631175277739625, 0.12328215813023757, 0.11916486593125064, 0.12012248898218891, 0.11798109884833952, 0.12900456328230414, 0.1178592106530939, 0.14220002811796273, 0.11739770650177639, 0.1108732995449696, 0.11177309749809305, 0.12480373121703159, 0.11816277943236275, 0.10533747759694834, 0.12627543194577107, 0.11944421158323182, 0.11654472382849235, 0.10243136648923379, 0.9511248873961946, 0.9728218698816404, 0.898025877484202, 0.9538524158768384, 0.9160284085257808, 0.9416371447827795, 0.9366469068391094, 0.9433552271926572, 0.9637622210832649, 0.37325967616513367, 0.37952108679440766, 0.3653500831132305, 0.38197899561596027, 0.3768740395984541, 0.40072449437879387, 0.38291305690841393, 0.3596791962666237, 0.40933441472641297, 0.5406036866249602, 0.6853446274316776, 0.623311650065967, 0.6469275532356102, 0.6937416392595495, 0.7093855895589574, 0.6512782190877027, 0.6395199196051364, 0.789919802053983, 0.256643713952891, 0.33580963261503083, 0.28415724886766514, 0.2662043535586529, 0.30245025879309806, 0.282312163994916, 0.2672294525103789, 0.3424128816377724, 0.3268665001903909, 0.24727572766634864, 0.12835593020176161, 0.21270963044627356, 0.2904127924667055, 0.24305779986294196, 0.2749782789085945, 0.26882764178688867, 0.31522509540912347, 0.2756644113368859, 0.20788437735850362, 0.1797624171901523, 0.19975682867950328, 0.15753809053929158, 0.154312119600589, 0.12166569869301547, 0.19185271104826285, 0.1633065329774679, 0.17576033206715258, 0.2859749718132041, 0.3185407191305578, 0.32456013865458266, 0.291860869329055, 0.28093267777124453, 0.2685008004131709, 0.30003871229883894, 0.3372139881958012, 0.31221554073547275, 0.05771924597525935, 0.03922031659777492, 0.0732128545687023, 0.028534816234766502, 0.08092976268042873, 0.05133290069031449, 0.06750404232603668, 0.07369106674543768, 0.047859861943609916, 0.19132441465725725, 0.22456644025151473, 0.18631703207712325, 0.23993531118179268, 0.22530609558877512, 0.22337283798693697, 0.19761121278747995, 0.2305701165463231, 0.19779230704875195, 0.5873944629473329, 0.5530580310142257, 0.5939893746727432, 0.5680044881236463, 0.5545411921943039, 0.545721912869058, 0.5852880735205842, 0.5548558353625862, 0.5783309493215294, 0.10290774941942948, 0.10355638442326087, 0.1184285322899572, 0.114528129903813, 0.10474779980540683, 0.10957048742880593, 0.09923548949434513, 0.12317086532342514, 0.10281893413459786, 0.16967805908456757, 0.14684267862467582, 0.2443107741040249, 0.15367207257571758, 0.21036335064515388, 0.18261081069577645, 0.16814964851112868, 0.18553578943525062, 0.20547838094621096, 0.33054573620086436, 0.3005284633822546, 0.3507664776866677, 0.3307848364190258, 0.31092375764167857, 0.3055395047953592, 0.35096567563531467, 0.34653064792405286, 0.3342255097060156, 0.26165609142025137, 0.2638863205388614, 0.2442209357986671, 0.23748867620621805, 0.2340136407333432, 0.24084783673899102, 0.24638176610807117, 0.2762070878291696, 0.2458976103637227, 0.18432833504989754, 0.20430488436915695, 0.18720405014554276, 0.1903669151330334, 0.18111110963108634, 0.19045710921482228, 0.18847249677205757, 0.21706231068393156, 0.21759693301287242, 0.29550834492210465, 0.1942120036760525, 0.19987884508493248, 0.21492067576932616, 0.199506910237489, 0.18366525717668858, 0.2082421846802075, 0.23040701264394037, 0.2315397034212574, 0.7775306482126899, 0.7076399484923996, 0.704809280959938, 0.7143225817923837, 0.19822383011218325, 0.8364003019763865, 0.637108422149827, 0.6153948827938303, 0.7538270776796814, 0.5738687652553741, 0.2092686195970942, 0.556109253844407, 0.6666389889590159, 0.1994781804656618, 0.18994292040884775, 0.20414899591131241, 0.20691432415166378, 0.2107221013335847, 0.1819709191894674, 0.18579460818244975, 0.19472926493182652, 0.18454926038697494, 0.19384779169998267, 0.21249910266776073, 0.18308727294339955, 0.1788937863920701, 0.18245542955232652, 0.08031863058058042, 0.07514060441470305, 0.06676691971514614, 0.0753358997929483, 0.07972695487401016, 0.06952426885552954, 0.07221557351193386, 0.09076687257433802, 0.07592964097676524]}, "mutation_prompt": null}
{"id": "49d43c0d-adb1-47fd-b359-b484b9609024", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "2f9241c6-96e7-4367-976b-ebdac42973e7", "solution": "import numpy as np\n\nclass AdaptiveSynergisticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 45)  # slightly increased population size for better exploration\n        self.F = 0.5  # slightly reduced differential weight for refined adjustments\n        self.CR = 0.85  # adjusted crossover probability for better exploitation\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Adaptive Local Exploration Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # slightly increased local search iterations for finer tuning\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.15, self.dim)  # adjusted exploration step size\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Modulation\n            if evals < 0.4 * self.budget and len(population) < 2.8 * self.population_size:  # altered condition for diversity expansion\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))  # increased new individuals\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveSynergisticDifferentialEvolution", "description": "A synergistic hybrid optimization algorithm blending Differential Evolution with adaptive local exploration and diversity modulation for improved convergence.", "configspace": "", "generation": 39, "fitness": 0.36507967395636004, "feedback": "The algorithm AdaptiveSynergisticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8214938047859578, 0.8140539326472962, 0.8040608375825402, 0.8055136555374818, 0.8097184373700931, 0.8113509717004883, 0.7956594194314125, 0.8024138351466097, 0.8014995665130709, 0.6665638062747782, 0.6684016427585462, 0.6593074965469785, 0.6524435612117905, 0.6243860309432357, 0.6724817958082296, 0.6374385678588763, 0.67457453524881, 0.6569859839734644, 0.13882692722311263, 0.1273302094822406, 0.1431923780289417, 0.13523349711725663, 0.10526251280248111, 0.107018116701464, 0.12041974091496699, 0.1337478947302454, 0.11130350690959645, 0.10789825801264596, 0.11397542481593137, 0.10690396500340926, 0.1111447793785828, 0.1176506735108378, 0.13487157776760073, 0.10456107784780921, 0.1081320150079026, 0.09368114354797386, 0.9305006013151633, 0.9173279138242315, 0.9461445260766275, 0.9406658300061078, 0.9181114770014008, 0.9364838454164659, 0.9325618211891326, 0.897558463152247, 0.905453341481053, 0.45046121026518793, 0.46548882556658033, 0.4695477752490764, 0.4836756013966226, 0.5150322040283095, 0.4890261928176044, 0.4915514459404404, 0.4882234767313893, 0.4945274798382847, 0.7106931379026289, 0.7292304962277953, 0.7182370195400761, 0.7507905441683809, 0.7671093767560957, 0.777040606668266, 0.7804084854291521, 0.7719210108435691, 0.7481513094049579, 0.26130552609308544, 0.23703466753622815, 0.21565161403855704, 0.26233291743573295, 0.2240758359442424, 0.1834973544073737, 0.2855516860917503, 0.21873836447480277, 0.1564676810144583, 0.19980275892820565, 0.21944313538702231, 0.18903469876754675, 0.24461796122999724, 0.2931093195044676, 0.17374295782130889, 0.3067679323110004, 0.24441799108490259, 0.36875047142787976, 0.2460790887441653, 0.2745834817009981, 0.28161127559287213, 0.32396676735451424, 0.29023524583356386, 0.2726276487584197, 0.3218709836362368, 0.30112992161882757, 0.3320573505223354, 0.44493572313923146, 0.4071850527974391, 0.42749980358812045, 0.4188560778799638, 0.42521255451343376, 0.4368216748324476, 0.4708694879507277, 0.46536062051777116, 0.44568475777130323, 0.14852706323212228, 0.10910039060487964, 0.12116798717183241, 0.16015449527434988, 0.1945698593506402, 0.19971262195488648, 0.14371023186090226, 0.1829383672404441, 0.1623737025948736, 0.26430825935053437, 0.2708874017514009, 0.2617202354001089, 0.2776278664173655, 0.2708768622156784, 0.31048332298021264, 0.2852799275220662, 0.27839542565330355, 0.27231242865479066, 0.6635659107593616, 0.6521327680960249, 0.6842348057442094, 0.6802972569891618, 0.6988621581091747, 0.6807240040796534, 0.6682291195543415, 0.6694654644551021, 0.6804124950643777, 0.12458077854336302, 0.10934915321028804, 0.1095844644591989, 0.1133500855948556, 0.09687525569010191, 0.10789029962941588, 0.10794768103925434, 0.10415530249608873, 0.09416568338241726, 0.22756354423022496, 0.15828216006338047, 0.15741352885053062, 0.18617977538281816, 0.2155150369597547, 0.1619157453815787, 0.2680355144783888, 0.21956637378693344, 0.19828409173485584, 0.3948436197663011, 0.4034561270523076, 0.3925404806357814, 0.4067916219249148, 0.4266561437115276, 0.4013883446247545, 0.42703281997570375, 0.44056674692717057, 0.4504218458781206, 0.3008949813379196, 0.25757771269825647, 0.29571422150523263, 0.29944605664982304, 0.2999950247332759, 0.2871304732534049, 0.3168476244695121, 0.32563985127893613, 0.32623105694688237, 0.19366916540179002, 0.19101737502939242, 0.21404849576837714, 0.20665835382149367, 0.22059493525547613, 0.18717424630342172, 0.23857784379773994, 0.1936155399148114, 0.19767849231419454, 0.19128036715726626, 0.3872678336835863, 0.20170631383337845, 0.19435460442893904, 0.22071584853047088, 0.2952826121166868, 0.21162543307040493, 0.21515323548327092, 0.20673268715102133, 0.1837740124708911, 0.16280416937324138, 0.19051318774517956, 0.7948096363154488, 0.6845571530193917, 0.7036356901210583, 0.6246464851399511, 0.5578782640181643, 0.17527406545453628, 0.6831380381643151, 0.4946156592113431, 0.6843437874303515, 0.6663591512912983, 0.2101997719878499, 0.20582313008290753, 0.21084861644076713, 0.21098246697955003, 0.2085588151590454, 0.1910006105770864, 0.19642553783984218, 0.18342325703419726, 0.18051691235737877, 0.19214806669719864, 0.1817266773005386, 0.18442386524700938, 0.17478180450738545, 0.19778389232634985, 0.09725140683236899, 0.07942795359711985, 0.07441679774659882, 0.08726674279006585, 0.07836787947059909, 0.08155813707885518, 0.07965571440227703, 0.08486104915994963, 0.09000213714642447]}, "mutation_prompt": null}
{"id": "a04e154c-f988-49f8-be37-cfd017b5b731", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "cbda42c4-28bf-41e1-94be-b1d42cbb9826", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "e3dde85f-cca7-4242-a644-9b5fe3a5489e", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "1f79eacc-3e95-4abc-b4dd-0cd7f0f662cc", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "6ec2266f-2cb4-4e20-8c64-572dc77e1c91", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # adaptive population size\n        self.F = 0.7  # differential weight\n        self.CR = 0.8  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Stochastic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(int(0.3 * self.dim)):  # stochastic factor in local search\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.15, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Mutation Control\n            diversity = np.std(population, axis=0).mean()\n            if diversity < 0.1:\n                self.F = min(1.0, self.F + 0.1)\n            elif diversity > 1.0:\n                self.F = max(0.5, self.F - 0.1)\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm blending Differential Evolution with stochastic local search and adaptive mutation control for improved convergence and diversity management.", "configspace": "", "generation": 44, "fitness": 0.33720546325989864, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8000710024131619, 0.8031624370366566, 0.7921860423052605, 0.7932970551852541, 0.7932525491264397, 0.8045789336038237, 0.7936028010656664, 0.8176541463828866, 0.7999488082075042, 0.6333450819888113, 0.6377711106605455, 0.6449370226716749, 0.6442594807895469, 0.601477320215569, 0.6410053713394684, 0.6468383968732931, 0.6353895859846896, 0.6248387030454998, 0.13878001665445205, 0.11738644206817772, 0.12800077495755668, 0.12203129934220724, 0.13819613052096558, 0.13245257549505318, 0.12734299857766984, 0.13470352913668115, 0.13778511495412182, 0.10424371747294259, 0.12624375876140803, 0.10847421686062952, 0.11810135560604196, 0.10970387427985007, 0.1068383886658465, 0.11586470769071433, 0.12060001636894901, 0.10714375914779173, 0.9483428611653293, 0.9299014608758778, 0.901819464774032, 0.9120601305815885, 0.948777765855334, 0.9333162626685999, 0.9210726371287263, 0.884719102677932, 0.930391726049088, 0.4561241066229311, 0.42451909064872395, 0.4235909282440794, 0.4391251437427909, 0.47565904001258863, 0.45355616365469675, 0.4552937225327409, 0.463023440885618, 0.42084341351122034, 0.6416915458927395, 0.6947699444849517, 0.6530074769581733, 0.6969006755492138, 0.7078685486043088, 0.7328764362706558, 0.6621486775714143, 0.6659262502677443, 0.7087397655289177, 0.2077336195645375, 0.41374582651019554, 0.24128671834984994, 0.2643905884376826, 0.18009709257257878, 0.18160026996407475, 0.2055005664525068, 0.18906479802945608, 0.26453737036091796, 0.24137664703046802, 0.15215987415429388, 0.16754540625072345, 0.16586331130567944, 0.2296211509307654, 0.17306687368693707, 0.23264309482104062, 0.19235349219522424, 0.19900437809809357, 0.15801722084809733, 0.20693681991010604, 0.19293151121595054, 0.18765880593375128, 0.18033059911188642, 0.17357360056565052, 0.18867859833222278, 0.1840960226896291, 0.1877030568788024, 0.29120272631098365, 0.33188804077867484, 0.2682233802239615, 0.27957265971685397, 0.27867794461131734, 0.29879641588830785, 0.33321255269745564, 0.3395342689768833, 0.3370493970568281, 0.12772089586864144, 0.08067745157982187, 0.10841922613072419, 0.1282628092949748, 0.07708764139890933, 0.03521060141251331, 0.0764720480201202, 0.07586226501285531, 0.13056543136418441, 0.20233023520845095, 0.20030336191217857, 0.20679872675309163, 0.2529936679490181, 0.21872673716361812, 0.2459084620813461, 0.20941638026373177, 0.21795974655954464, 0.20807637693816394, 0.6139573994817217, 0.6021639695246404, 0.6279788575701261, 0.6094954873602249, 0.6409073187192323, 0.6076818756034983, 0.597994000878395, 0.6187171235778882, 0.6225106974837509, 0.08583790760374521, 0.11013413868200073, 0.09958208161854165, 0.09437625734517674, 0.10936361842659825, 0.09509168440060112, 0.09970614567254965, 0.10174650676140207, 0.09480419341982704, 0.130821300810397, 0.28296103683271656, 0.16142716902129617, 0.17823624254684323, 0.2076558717369632, 0.20905636597208577, 0.1820321338289277, 0.18625539386593615, 0.15027348515113603, 0.3797101593623612, 0.36164117688358843, 0.4168362458244562, 0.40422064617389875, 0.37853179668106507, 0.38877765000922915, 0.43272643361137575, 0.42333358584228586, 0.39181760576644586, 0.2788183301585222, 0.266495026297741, 0.31131852979858954, 0.2701714705320618, 0.2680614731476363, 0.2822800927060857, 0.2901117076908689, 0.3030273022904878, 0.29800177984934484, 0.20165543571019784, 0.183637429939154, 0.2075969072063225, 0.19939309965117158, 0.20140643978789374, 0.18706979737708418, 0.21075378745994855, 0.20290696822042975, 0.2001805701472098, 0.19365256167573452, 0.19818671845757863, 0.23095896075682876, 0.19714344280306384, 0.1973870248485351, 0.2288783677891838, 0.21402306465232346, 0.2207199954045045, 0.19736567693361495, 0.19428129243715087, 0.5792990777950463, 0.19387440128984712, 0.6327377383559787, 0.1937372367125798, 0.5680189330973877, 0.719534387154604, 0.5546193536459715, 0.5710542514493643, 0.541923530891459, 0.44863773806394713, 0.20170762724023283, 0.5248625613704647, 0.5971880514005278, 0.19496918926128537, 0.6140168290000302, 0.20461778052865642, 0.20647020708380837, 0.1857188082219129, 0.19457067861529576, 0.18872034899804757, 0.17810302327149197, 0.1838687785438884, 0.20123900902607894, 0.1903492836885523, 0.18133693013905006, 0.21087759868160372, 0.0800655790042667, 0.08260007952749715, 0.08301021255083962, 0.08058305540022448, 0.0811233804631174, 0.08013368714544344, 0.07559738136712368, 0.08077142460882225, 0.08655401917236138]}, "mutation_prompt": null}
{"id": "c4717997-a1bd-4656-a8d8-2688e7c28169", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.7  # slightly higher differential weight for increased exploration\n        self.CR = 0.85  # slightly lower crossover probability to preserve diversity\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase with adaptive mutation scaling\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive mutation adjustment\n                adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))\n                mutant = np.clip(a + adaptive_F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Intensified Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # more intensive local search exploration\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Diversity Control\n            if evals < 0.6 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm integrating Differential Evolution with adaptive mutation, local search intensification, and dynamic diversity regulation for robust optimization.", "configspace": "", "generation": 45, "fitness": 0.32333521432873114, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.7587516409815989, 0.7624581511394793, 0.7878775493855912, 0.760865977128229, 0.7543745994548448, 0.7585928931111969, 0.7672869316721959, 0.7651699146875822, 0.7585895691975391, 0.5714323563836919, 0.5582840770721172, 0.5603565823411314, 0.5460160972978534, 0.5446255572598865, 0.5284742974771564, 0.5511415434749403, 0.5538888961561865, 0.5538327366466851, 0.16003956183869394, 0.12001568705032295, 0.11694493412010942, 0.14538367397117857, 0.11343420665486703, 0.13630484813098698, 0.13071043653355496, 0.11062590673536166, 0.12144943605374281, 0.12005299705002725, 0.11790997479854415, 0.12463583629305264, 0.109006988316109, 0.11620998090511858, 0.11492237614116763, 0.14293940652574222, 0.12956042455698158, 0.1098447553155123, 0.9600426742989175, 0.9228390796498865, 0.9223064294209317, 0.9411618397768597, 0.9387017454178657, 0.9484080032733607, 0.9334185574265463, 0.9373059272677962, 0.9528657557693847, 0.41180375357451826, 0.35437619335484916, 0.3625107148608149, 0.4202566037916363, 0.3783319923912357, 0.36920211858119956, 0.39906703029400736, 0.3739341692838227, 0.38107059938166377, 0.6558539353062458, 0.5745906155406317, 0.622711832764772, 0.7129911506822479, 0.7097767313140934, 0.7415270961097296, 0.6828977542916475, 0.7238368519817728, 0.5726028560843526, 0.2989554039579123, 0.2727597097499398, 0.3152633778232352, 0.2566470999902144, 0.3034651931006025, 0.2345684811548987, 0.30917182534998966, 0.27589707213915304, 0.289141190231212, 0.2517653879445938, 0.2812940260789776, 0.21462541343082353, 0.25500834093314484, 0.294676070744348, 0.2655833702060473, 0.2856964042331035, 0.30489106481804096, 0.27188156207767256, 0.16506823779128954, 0.18556564016781507, 0.17124402771672942, 0.14430850553500918, 0.15771292300973927, 0.15228948038677592, 0.1482936009705179, 0.15510223868521822, 0.12664277619591924, 0.30977047434974525, 0.3240355823360339, 0.30530365356816014, 0.2800073253389298, 0.27048180969781277, 0.2636548601368456, 0.3228588673502165, 0.3545991744672836, 0.27268826138802726, 0.06416948490969676, 0.057608343643239635, 0.0450966600046977, 0.084519277782238, 0.09666394055895855, 0.07955138521713179, 0.030320687989075834, 0.0704605936258047, 0.092246600676261, 0.1959202904584112, 0.1879407019698599, 0.1955271191712309, 0.2286832330999582, 0.22053411689997748, 0.20159900590790847, 0.18870502564682923, 0.19668700255030336, 0.20165925153077346, 0.5805421384394103, 0.5855398589233752, 0.5712196204919148, 0.5552915860425105, 0.558127543163409, 0.5568298178574465, 0.5652734909573529, 0.5603799291338681, 0.5687747090188454, 0.11762724741622477, 0.11606562311866642, 0.08029289063321798, 0.09337060520317786, 0.11026188572403461, 0.12093539896593697, 0.13714683708369957, 0.12001418692913102, 0.09491716046831156, 0.14986163905115735, 0.18686194979902115, 0.17243901853948207, 0.14943842340812485, 0.1942928195802669, 0.18812988374697814, 0.2121583366113936, 0.18317219520120898, 0.2294747483432863, 0.3075520113406841, 0.323139479429819, 0.31466101849475303, 0.288747962989126, 0.31838690943051073, 0.3095779824657341, 0.3359447562925709, 0.34397599923319755, 0.36473481239627803, 0.24484250888807546, 0.26755604182477233, 0.23527427528861766, 0.251476577482736, 0.23221981083234555, 0.24213873285544008, 0.251476092889547, 0.26409473554272467, 0.24805178391392824, 0.19786098749665337, 0.19470303256132448, 0.1774748312684573, 0.19674797543395872, 0.21359775948657445, 0.1701030288444505, 0.20527763896527962, 0.226641020778937, 0.2093824500988556, 0.2181374111496328, 0.20981377118966427, 0.22330927959586588, 0.20887799469081403, 0.1987131973921803, 0.25254091699654313, 0.19156274201357437, 0.24707639149910043, 0.18645717250854388, 0.2045144545915185, 0.15192401250809784, 0.16531160019111557, 0.8115235595297146, 0.5451357630940978, 0.4418037124811577, 0.1862242416608899, 0.3351030785215884, 0.6197618031860066, 0.5946668666233196, 0.6217448121759912, 0.6225127983009688, 0.15390099854144101, 0.20157296349805442, 0.5552514844529057, 0.2105348875063685, 0.6356684277447846, 0.20999626194989496, 0.17983569815686573, 0.1886702556984725, 0.18749855641564406, 0.1829909686230008, 0.18934184916546815, 0.17699292243556886, 0.19762493649357105, 0.19516936252059514, 0.18252904315154272, 0.09404214555863488, 0.07843105515945858, 0.06760013535822529, 0.07748662793156891, 0.0838397665402173, 0.08527006989234831, 0.0747791296784519, 0.1083088797084969, 0.07706056009904771]}, "mutation_prompt": null}
{"id": "314b716e-f9cc-46bc-99c4-05e48f070d0c", "solution": "import numpy as np\n\nclass StochasticPerturbedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)\n        self.F = 0.6\n        self.CR = 0.9\n        self.perturbation_factor = 0.15\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial = trial + np.random.uniform(-self.perturbation_factor, self.perturbation_factor, self.dim)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        return population[np.argmin(fitness)]", "name": "StochasticPerturbedDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with dynamic local search and adaptive diversity control, enhanced by stochastic perturbations for improved convergence.", "configspace": "", "generation": 46, "fitness": 0.24737634227233157, "feedback": "The algorithm StochasticPerturbedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.449838251412469, 0.43314263350377014, 0.4700958766280151, 0.45248698075721283, 0.4771615900347751, 0.4728607365178428, 0.43589872438641064, 0.48279014167225864, 0.4511323586035353, 0.05320566426909723, 0.057045045742480927, 0.03218529185363317, 0.04289588564955105, 0.056475780274149345, 0.044867919375482956, 0.0984907850711002, 0.048069056402465504, 0.05301370423724583, 0.11095029659922839, 0.14348614096949275, 0.1113363715745399, 0.11233801705558488, 0.09922064642210371, 0.12124050924242713, 0.10933554538193335, 0.11992673123408071, 0.11506427142992648, 0.11153134685818245, 0.10166960425771832, 0.11413058723186298, 0.11944494077507828, 0.11126673539946064, 0.10669661684454745, 0.11617563524640373, 0.10892110706542413, 0.09523452852806291, 0.9442330489454398, 0.9231600815349157, 0.9144621851041954, 0.92318961981327, 0.9224612085612284, 0.9177964293869085, 0.8793602091034826, 0.9130049627966397, 0.948845614672459, 0.3324939741674472, 0.29506542252752355, 0.28508882568346583, 0.28339904447219955, 0.2894566658273373, 0.30973973682107603, 0.297632867872341, 0.309653565390996, 0.3003017434739945, 0.34697496590235977, 0.6823110931760998, 0.34435019403412925, 0.36946053447343197, 0.4899566619557558, 0.39431243960806006, 0.6853376183361604, 0.3614786583444132, 0.7253622511256195, 0.17813001971659614, 0.15733381519618284, 0.15589381834339167, 0.18778859329519582, 0.1692472779116606, 0.16597547893790565, 0.16830213836329222, 0.18043213290295157, 0.2080317291207734, 0.1779823303936695, 0.17071616187520777, 0.17582613458890706, 0.1718585489379133, 0.1518302080643925, 0.1834599994073699, 0.19997586649826615, 0.17775934187672082, 0.18561394223476868, 0.04308530285514023, 0.052652267859049084, 0.07917194640371594, 0.0793745307311512, 0.03473994793865165, 0.039777372862460636, 0.043137797897677466, 0.034425036947472676, 0.03868772561373213, 0.10303839744708199, 0.11265766628035212, 0.11967789479856905, 0.11933519112727553, 0.07271753316054674, 0.1265639586095766, 0.1999897576859574, 0.10815133555344525, 0.150890390180478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1082623185566528, 0.12192995250644056, 0.10959970591478196, 0.10923323942752083, 0.11930293128638259, 0.1199184409574473, 0.10531471288938532, 0.11088372138784541, 0.10270434422783836, 0.45065457619901594, 0.41731741921973975, 0.4125449191150127, 0.4198095680645184, 0.42152482409444125, 0.40196534188531785, 0.42486309553128354, 0.4291631922925242, 0.39965107283554757, 0.11801364415000648, 0.12467376063245561, 0.12591562965363123, 0.11038909435112909, 0.140258423359775, 0.1239451257441595, 0.10167876904856055, 0.10451548886930428, 0.11345249470145446, 0.2177252773086824, 0.18336367695331823, 0.2771917360278061, 0.26479141516903837, 0.2958342554158804, 0.17849501212221308, 0.25003068388999716, 0.1624336509230241, 0.20779296407719494, 0.293468274528099, 0.2917210119911574, 0.29384532862067503, 0.28487984676972433, 0.28052631283218277, 0.28719618665533364, 0.29298262576981127, 0.30019633420104996, 0.28188843616796244, 0.22295976898498393, 0.23054603589734457, 0.22531247506642027, 0.2380739130170868, 0.22492682503474948, 0.2423317032125688, 0.2386021050773559, 0.24562920768986274, 0.22926281245909508, 0.2034330130601386, 0.1917424946274926, 0.20188234147985717, 0.20846166046948733, 0.24319700712999814, 0.19088160253719377, 0.1872418782862444, 0.18215110423004166, 0.21103615897444683, 0.192942955320915, 0.2176156984208648, 0.18974849214629919, 0.19776210081578183, 0.2008880499473138, 0.19799122648793932, 0.18617651038338268, 0.21358455416290034, 0.1941550418290291, 0.6181091892707066, 0.16809940658633116, 0.6553736891974447, 0.6658900547118869, 0.5013319414181892, 0.61674322565719, 0.18693218669770129, 0.7005156778751133, 0.5268095455265958, 0.6083435089944984, 0.5533320681009606, 0.3807310594147245, 0.5666499540465557, 0.20629867014490777, 0.46665854890430136, 0.21153476079309907, 0.2123902602165516, 0.21256772916771793, 0.19836601836586554, 0.18067754322405183, 0.19074787977574537, 0.18674195505328806, 0.19495795348531986, 0.18279943577650337, 0.19011606182973684, 0.1790546975840832, 0.18548323742980233, 0.07923148498054922, 0.09100477719597566, 0.07980874684038775, 0.08529310376796506, 0.07838889326426246, 0.07065853250688559, 0.0799558457724262, 0.08551281438080183, 0.08214662655537308]}, "mutation_prompt": null}
{"id": "99112bcd-6141-4dfc-8845-bc655cd03a06", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # modified population size for enhanced diversity\n        self.F = 0.5 + np.random.rand() * 0.4  # dynamic differential weight for better exploration\n        self.CR = 0.8  # slightly reduced crossover probability for more diverse offsprings\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # increase local search intensity slightly\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)  # smaller steps for fine-tuning\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.6 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid algorithm blending Differential Evolution and adaptive local search with enhanced diversity control and dynamic parameter tuning for superior exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.2874795804903818, "feedback": "The algorithm RefinedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.6719883636668962, 0.7173994423336771, 0.7004861012076911, 0.7242401412939845, 0.7147095525470216, 0.728559462950382, 0.6800216144238682, 0.7422065145245373, 0.7168761257077013, 0.4202355953949244, 0.5042402483183164, 0.48319900390115944, 0.4178202348922584, 0.49033248756723236, 0.4816507313362245, 0.4275214346353371, 0.4823225667277341, 0.4711609636437527, 0.12039337208760204, 0.13896847933110568, 0.13128288243997088, 0.1287374782567836, 0.16887944854517223, 0.11158927994367696, 0.14538761026398783, 0.11820974178909038, 0.11409600837046996, 0.11949420142055656, 0.11349695749471944, 0.1118565393332519, 0.10138916305637125, 0.11266961389113017, 0.10441313724134837, 0.10700066445994727, 0.11410371966655986, 0.10583081256984572, 0.9712782578223714, 0.9697215621753503, 0.9354482370300421, 0.967804802838431, 0.9217917163327976, 0.9212233559296313, 0.9498192487523407, 0.9483239732802927, 0.9400351897920263, 0.33810245561299124, 0.35028421137109056, 0.3315178756249426, 0.31419571547668823, 0.34983466535085617, 0.30793580572148826, 0.311180835812472, 0.3356702065832854, 0.3427445890595494, 0.5144291949825904, 0.4894951435098387, 0.5839037083740639, 0.5520993934740547, 0.5872188924240955, 0.5908555852769048, 0.560316243902188, 0.5743591554242432, 0.547095764381663, 0.18491618537173915, 0.2197529707747159, 0.19505147171171444, 0.18103426275161316, 0.22630075376965375, 0.24080675108875293, 0.17626102787114273, 0.21456102441053437, 0.2116064296510043, 0.18294485949194572, 0.16533966847875836, 0.19219602498428046, 0.18963943752366008, 0.2012169396114557, 0.21004907049107036, 0.18199575040049176, 0.1828464051521259, 0.19882992755190865, 0.054377634778245865, 0.058731526177874915, 0.06154900261525276, 0.04465640877581134, 0.06267666594702004, 0.06689365422864524, 0.04601162339999376, 0.08258360563805656, 0.08359092289273062, 0.16341568376000248, 0.2190819675625404, 0.19629254746177416, 0.1637633030154535, 0.19155961655545717, 0.19711331901326523, 0.16536528571593812, 0.2367717462249972, 0.21954009713761036, 0.014810330780813619, 0.00680728393024943, 0.013848932443699224, 0.010935487962632773, 0.008250286107985616, 0.023246704297724463, 0.04936784412641626, 0.042902194839994134, 0.01841803422557642, 0.15209142562764832, 0.14200664635846338, 0.14968023747326098, 0.14865035460804443, 0.19666209626911346, 0.1992971396537795, 0.13554456775182921, 0.18021812463716547, 0.1527309843017821, 0.4926545491835532, 0.5322898839809953, 0.5057051968479964, 0.47847425151652656, 0.5118973034496725, 0.5256604402570757, 0.47190704976079434, 0.49226310718026944, 0.5361275982649093, 0.11636443339262881, 0.11350304699281388, 0.10023342279996306, 0.0924665906763057, 0.0944383220278816, 0.0970894638179387, 0.10641338157026059, 0.10813914436717964, 0.0897160936654855, 0.15190038695716157, 0.14753906634768732, 0.26260967482863673, 0.1486911101864996, 0.18402101842796015, 0.1991444293813175, 0.22887868334393413, 0.1467499460915893, 0.2531164724473127, 0.26474697029369676, 0.2923457799017377, 0.3062103699093176, 0.2664403033305277, 0.3003829869579778, 0.2956853679680863, 0.3142730903190919, 0.30343760287569044, 0.3256631523264728, 0.20781072074978424, 0.22960177659111136, 0.2188897720885079, 0.21034545302549357, 0.21465592603173056, 0.2026520965013473, 0.22052111876655522, 0.2450335458783286, 0.23576647085289548, 0.2159851926339409, 0.21219146052027937, 0.18795744735033837, 0.20548322429615473, 0.1889839481046094, 0.18499915958029445, 0.18608962798559858, 0.20814774326911634, 0.18642245593800033, 0.2079057048046038, 0.19587929358930356, 0.18732104707224495, 0.18640617440401042, 0.20052194933841816, 0.2093453099252729, 0.20614811170197678, 0.19508245071096286, 0.2014416851272096, 0.4321039290690153, 0.6589317637755305, 0.7318179283077276, 0.6621420612759645, 0.18766304725681848, 0.1873601476604072, 0.1815273308120413, 0.6867904166438106, 0.46131259915125056, 0.19870914590706457, 0.6117640014949131, 0.40116093390938223, 0.20108837626684561, 0.551265275204611, 0.4342643907793514, 0.20181025358933935, 0.5095076910755378, 0.20834036138637968, 0.18737986972580434, 0.1885086929175943, 0.1827106364519786, 0.18044016141565267, 0.1956294978988975, 0.18148283517669905, 0.18535577468333253, 0.19973076585755034, 0.1891341434928704, 0.0816850966718764, 0.08519696315936764, 0.08377705811590908, 0.07052697430099142, 0.07135098731475376, 0.08572426071927897, 0.08953126504370934, 0.0795774661251002, 0.07727099586607455]}, "mutation_prompt": null}
{"id": "5606834b-2095-4880-8b34-7b302d59edee", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "0a13473c-ed09-4031-8522-d2a56440587a", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)\n        self.F = 0.7  # slightly increased differential weight for stronger mutation\n        self.CR = 0.8  # reduced crossover probability for diversity\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                cross_points = np.random.rand(self.dim) < (self.CR if np.random.rand() > 0.5 else self.CR / 2)\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)  # refined local search\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Population Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))  # less aggressive expansion\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with adaptive crossover, guided mutation, and dynamic population control for efficient global and local search.", "configspace": "", "generation": 49, "fitness": 0.28840311968059024, "feedback": "The algorithm AdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.7700678527007718, 0.7482637450093552, 0.7507328174125674, 0.7698283159325214, 0.7639979191168247, 0.7525670704183638, 0.7626760144170941, 0.762118374693177, 0.750596224071467, 0.525238531742138, 0.5314340168133621, 0.5806033720248345, 0.5497554701801055, 0.5250060588420506, 0.5438772245320614, 0.5423592012154435, 0.5441682664635603, 0.5661214872335213, 0.2552626888637404, 0.2061445562430585, 0.2977893122849934, 0.21559135002811936, 0.20569430053671767, 0.19531109856269846, 0.1886974248948855, 0.17840624735573563, 0.1882745605753321, 0.12579280360286904, 0.15683250801587367, 0.17603790545305764, 0.1626502861670338, 0.16826480481238304, 0.1405171350060127, 0.15328726055670283, 0.16829376485527703, 0.1519083047273716, 0.9499690121667891, 0.9717730285134908, 0.9362825607538336, 0.9446547898340578, 0.9692431400829254, 0.9610962649419625, 0.9219932011819769, 0.9851875554821388, 0.948838010611086, 0.3532975246215353, 0.34795739154376304, 0.3302895042516155, 0.28837684480816617, 0.36058738687076874, 0.33857631269375354, 0.32985764098237447, 0.3095053319076313, 0.31761771763679636, 0.49400853539974987, 0.36092971268453533, 0.32164031181450337, 0.6460384303182602, 0.5072919017584303, 0.44541957279212785, 0.5087366484009743, 0.45866816432274105, 0.4395694246064814, 0.20283250575705647, 0.18721298503279626, 0.19846696111778062, 0.16668035915183843, 0.194147191863975, 0.1862630847689467, 0.1795475414730794, 0.17023631135491035, 0.18195639625783555, 0.19745632238162203, 0.13361418332131247, 0.12394400169165798, 0.16789122133637846, 0.1778162338053617, 0.17417104728837607, 0.2004299855940882, 0.18761585907462397, 0.19801446611038287, 0.034161309396073536, 0.013030809570938384, 0.01650343597545001, 0.05323424043486791, 0.0229846595250498, 0.04366702546870149, 0.05110568353128042, 0.02389357728527952, 0.013808120375096822, 0.1432504917809978, 0.16650888646184359, 0.1280090069194041, 0.10950153672389695, 0.13998970093753593, 0.11052875723437572, 0.157830593662876, 0.17394419423953933, 0.18595853357499736, 0.004981834244340844, 0.0059055782116210764, 0.0072782203129369005, 0.003256928134684145, 0.009359944886522475, 0.0016437762620542529, 0.004049606022046293, 0.011755090186229555, 0.012359810318692377, 0.12085091277713578, 0.11300382265664888, 0.13279945649077307, 0.14014615255220908, 0.14878777659777587, 0.14202670862302835, 0.11669009687322596, 0.13068622295149857, 0.14390750863615664, 0.4983361737363561, 0.5205527586074137, 0.4907136465099373, 0.49081582961558357, 0.50915633352285, 0.4722918383544378, 0.5078354469041517, 0.4931178445785769, 0.4844315220143267, 0.10477608805418859, 0.10501571388068465, 0.12802155018253902, 0.09590713305903154, 0.10277697887652215, 0.1275868772872646, 0.13720114250154625, 0.142305032054293, 0.10226387153968353, 0.1580703618877064, 0.213004995208256, 0.1784518403717077, 0.15107624675879794, 0.17812132003422998, 0.18860989392523186, 0.2303305649469225, 0.18953145526688153, 0.18393554991703764, 0.28188098526831595, 0.28301329015583077, 0.291931491980733, 0.28864217946268167, 0.2940750612019255, 0.27619834869655446, 0.315118780386777, 0.3106888241584468, 0.3264850814698661, 0.2337059023261039, 0.21031083074231405, 0.2271079613548752, 0.2024743216227769, 0.20648336284210544, 0.20370227391179185, 0.22449610176985357, 0.2345945833149925, 0.2298632296241505, 0.18455151141927695, 0.21687520768111102, 0.20334953999311167, 0.2011201090396607, 0.182385387379555, 0.2107371872552506, 0.20695106223712811, 0.20830085720951896, 0.2088049316961581, 0.2601361323526087, 0.19711614712995107, 0.23816121210994334, 0.21563021318649833, 0.2529810585987654, 0.2575777492183271, 0.23168969158358077, 0.23524381991858123, 0.2694653976143735, 0.5769990337313917, 0.6273101995785311, 0.3342920664553011, 0.75870821235503, 0.5253530904718007, 0.21405960344976216, 0.17154652141393312, 0.6266594390317759, 0.6052565723208617, 0.4917553673191032, 0.20897825690594563, 0.33631284974198905, 0.3387567378971865, 0.37877056218659133, 0.35713928900185876, 0.21168213553288928, 0.20353051837818859, 0.21031372153393502, 0.18038450014699026, 0.1784238220411114, 0.1765800623921575, 0.18947397728437054, 0.190411387799714, 0.18357175946852977, 0.18172849769495714, 0.18995600584859185, 0.2059267239011534, 0.09063702547736507, 0.07635015336935358, 0.07907545271154326, 0.0833893854773552, 0.0849389197730801, 0.10162368594517124, 0.08040485828306099, 0.07662138951972697, 0.07479336749616872]}, "mutation_prompt": null}
{"id": "a84b48a7-58fa-4bf6-a727-b04c92187cb1", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # slightly increased population size\n        self.F = 0.7  # increased differential weight for better exploration\n        self.CR = 0.85  # adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Refined Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(max(5, self.dim // 2)):  # increased local search iterations\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)  # smaller step size\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Strategy\n            if evals < 0.6 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid algorithm combining Differential Evolution with a refined local search mechanism and adaptive diversity strategies to improve convergence across diverse optimization landscapes.", "configspace": "", "generation": 50, "fitness": 0.2996832389684152, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.7012940902456812, 0.6993428140288553, 0.7136995762505947, 0.6915047143044669, 0.7139747735434084, 0.7372931174023634, 0.7128642854851821, 0.7031394325064303, 0.7262589360037479, 0.4488806924473734, 0.44506388476045056, 0.4778934994555879, 0.44813488729360573, 0.4761663726016997, 0.46426615668345883, 0.4700083249397736, 0.4215707434535406, 0.483221337753725, 0.11772399513895526, 0.11377620869867111, 0.11910392486415045, 0.10670603201700835, 0.12572613054791526, 0.1279096848378729, 0.10392257554703832, 0.13133396018882382, 0.11773099802664222, 0.10294489532223883, 0.10995270884407637, 0.11144818133961165, 0.1266280987329117, 0.12301027711817691, 0.10465013177427096, 0.10196334133216989, 0.10861008225291024, 0.09976553811666267, 0.9527261084030038, 0.9367233784845782, 0.9592265989623574, 0.9549312084899386, 0.9503306716663419, 0.9367114943783643, 0.9581207757005181, 0.9376989132937037, 0.9476132385942233, 0.32101461610484605, 0.32235164459621324, 0.34480087200375886, 0.3163052623240117, 0.32839260051133856, 0.3197650635165511, 0.37521423965321055, 0.32904018507636934, 0.3315236716808394, 0.7150857184111069, 0.5402437679309795, 0.5115497458544844, 0.629151804555621, 0.6144949860137705, 0.5880869882820043, 0.6748922727926603, 0.5643304932827216, 0.5911440146153998, 0.21006806236782094, 0.23331037480081762, 0.22687771372319576, 0.20104307443593272, 0.21927185792861337, 0.1934190356253761, 0.21538147853503298, 0.20421153807800918, 0.26094594503770907, 0.11317591511571323, 0.14289096921026045, 0.1676471662984904, 0.19764545750337847, 0.2484141002070921, 0.20835023420574383, 0.17120205324337168, 0.21392189638958536, 0.23695592634711693, 0.08936581886139172, 0.0918725431559938, 0.10489985997080453, 0.1025228765096241, 0.12307928606110163, 0.09637179207432, 0.09247013618019173, 0.12377611768097885, 0.1140794530582585, 0.20977749998643658, 0.22557058334906654, 0.2109002251579244, 0.20824713495723057, 0.21034559605784053, 0.23382929510948092, 0.25562202489311814, 0.26844392923521354, 0.2503769526958116, 0.03389288580941319, 0.03462998872775047, 0.029827676536856584, 0.04018399248622451, 0.028625693151072884, 0.03875640635495292, 0.05971392520820318, 0.03394277474123264, 0.03324101201560514, 0.17536353769001178, 0.13824047837296294, 0.1487350546255859, 0.17281438632625246, 0.16873614771890155, 0.17268254080204115, 0.15387514387642676, 0.1675814967080449, 0.16067865235245848, 0.5206571302901475, 0.5225190168484142, 0.5061459273749043, 0.5059340986254371, 0.5209363907310532, 0.5529082522723137, 0.5429277686137095, 0.5236007811923514, 0.4972057602663764, 0.10317846159873822, 0.1719111565246494, 0.10570954815528844, 0.10749003448220606, 0.11217043819350914, 0.14125694060000038, 0.10676052115997736, 0.1495729981274535, 0.11815298562309451, 0.17986666877901536, 0.30469726288859944, 0.263497292208141, 0.15133281808139853, 0.21729712723171435, 0.19211580430570818, 0.22045462000904426, 0.2176558201458294, 0.21891407059156065, 0.2900178251062995, 0.279945176765935, 0.2956836768939498, 0.3006992874278904, 0.29278766767490016, 0.2941602997490771, 0.3178047037278908, 0.3231873319255253, 0.33642477264183834, 0.23166175499100983, 0.2513661858172661, 0.22893726185439123, 0.22562206398965423, 0.21713658374738043, 0.21300210066612346, 0.24875825104241767, 0.22945714547632734, 0.24079078015548983, 0.19427714342562608, 0.18726809422994184, 0.17883656823841898, 0.19255031507499942, 0.1846736425509703, 0.19534491159551892, 0.18561654151566231, 0.18344136697216762, 0.1804373801614727, 0.18558968622496408, 0.1765013483019542, 0.19230818578401399, 0.2162256581706341, 0.19879821590088909, 0.2101771799224128, 0.1875268219461752, 0.19795879411468853, 0.18178133597103574, 0.19362386879999116, 0.6417563415523403, 0.7311288726256675, 0.6378418701229849, 0.19909864684541723, 0.6728646113192868, 0.16586588790019974, 0.6454188494349089, 0.5850268800303536, 0.582211371381417, 0.20889872288628009, 0.4690538249162479, 0.6182580296033499, 0.42999315837546215, 0.4632149957873648, 0.20215542696480981, 0.20695875602559066, 0.6652543908616199, 0.1944943433810764, 0.1873211968008085, 0.18460947892903756, 0.17973285124211635, 0.184025673609729, 0.17445829040944005, 0.20293497782240655, 0.1893590292432239, 0.19527813322315812, 0.07199021598936761, 0.08276893216757475, 0.07417896022989678, 0.07302235806630941, 0.07919710006920144, 0.08000050768313594, 0.07587039849169197, 0.07917304209038267, 0.07615341102927853]}, "mutation_prompt": null}
{"id": "404dc1ec-9dc9-432a-b1e5-ed8afc7a8b39", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "bb28956b-3366-4b52-93b3-6f561776988e", "solution": "import numpy as np\n\nclass AdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.8194695075628048, 0.7998022430094943, 0.8146715640348611, 0.8096236298946983, 0.8162203797741899, 0.8154340725761025, 0.8102437604968394, 0.8073254808300313, 0.8168130982842154, 0.6538566140922227, 0.6416773171305461, 0.6940753485333773, 0.6650973190365996, 0.6217077981553352, 0.6363348598009542, 0.6399211364204023, 0.6457913548345322, 0.6391937252890174, 0.11252961224956903, 0.11726718123279312, 0.13098905269866445, 0.11221762121785561, 0.11056734480139108, 0.1347414159715843, 0.1280705673237792, 0.1651145966995844, 0.12683535678611602, 0.1114975848016122, 0.11168755387997575, 0.10542070493412081, 0.12263066546281975, 0.11687192254345025, 0.12375410095500394, 0.09068426940144614, 0.09948068343131522, 0.13585857878239038, 0.9403925445322536, 0.9124519585715767, 0.929564431404825, 0.9014337902086391, 0.9367887247835159, 0.9352779944419584, 0.9362001580551413, 0.9060980524188358, 0.918576302684969, 0.5044603380644916, 0.5173137298512368, 0.4853411498178569, 0.5162455436841975, 0.4973538468307048, 0.46584325059536724, 0.5030765531711301, 0.4868157074078233, 0.49005430245991466, 0.7732078603671629, 0.7509342539103727, 0.7714130080695303, 0.7657377456597052, 0.8095539171878487, 0.7733103534240846, 0.727832106997637, 0.7611707867304407, 0.7587729366364379, 0.28551206974945686, 0.42971000219206534, 0.4244207481668921, 0.241750523956483, 0.3228045255118738, 0.12747610080713945, 0.33636764319424817, 0.39726840884376835, 0.35167959517255665, 0.4185466064396781, 0.3622542264465157, 0.3201446678307024, 0.46476822434860576, 0.29683358676364924, 0.43385082815067977, 0.43855289428642397, 0.4400846219575494, 0.3548103843605388, 0.3880319230837159, 0.35457907837293545, 0.35508638805411163, 0.4132254932377003, 0.40746675218088635, 0.3933799850869396, 0.37348624231000027, 0.3612321795010578, 0.360129533977546, 0.5071414056987629, 0.5059375467927867, 0.5403153150520531, 0.5161408795433385, 0.505003779084898, 0.515980708049268, 0.5734632115580278, 0.5676463027077743, 0.5482533680469339, 0.1726216056848201, 0.23804680172839177, 0.1267418715358184, 0.16056135974599728, 0.28112503255998245, 0.25044081863528267, 0.13595920700935094, 0.13907709854936934, 0.18058687277299834, 0.31678528003757767, 0.29477736677522426, 0.3127243155963212, 0.3148087454108234, 0.330569992382042, 0.34667395063988204, 0.317364873845684, 0.29396812365614333, 0.30966438437122135, 0.6756536015924455, 0.6922708954017318, 0.6897966739195776, 0.7156721060595301, 0.6992798572920078, 0.6984702831457809, 0.7255472183050874, 0.6807946785459691, 0.6845757903255008, 0.10888869151567271, 0.10546337968341846, 0.14006818694651924, 0.11969736223787275, 0.11962214856033426, 0.10446663633796072, 0.0953228056376969, 0.11575290330738153, 0.1278758607171263, 0.19177334086925824, 0.21456916698908624, 0.16908739860443878, 0.2603335521512925, 0.17122931965436328, 0.1691093874566172, 0.16182168021831345, 0.1804596304766699, 0.1966499359952233, 0.3999852846658005, 0.39988966746062826, 0.38986629075952983, 0.3773890467811538, 0.3888378401024064, 0.37436156471677173, 0.4305303025973136, 0.3863558304530408, 0.4134413149230217, 0.3001651747653916, 0.30114914002099946, 0.293724188810888, 0.2863338020572924, 0.3045798477781305, 0.2881148205667531, 0.32856621156313803, 0.33547639228700066, 0.3302191816703556, 0.18910590294049923, 0.22629148373927077, 0.20692872876637503, 0.1928062206019, 0.21105665642217486, 0.20239250486058935, 0.20320563535146763, 0.19395199395226737, 0.2165772845370758, 0.19372958760676529, 0.23431077805177114, 0.36453427839538055, 0.19218472104392748, 0.20767459475918626, 0.19202442387597363, 0.2038105407570191, 0.19706251869252678, 0.25765448667691504, 0.1762791802411382, 0.20577935583406015, 0.16747433304351, 0.7970757231912107, 0.7070572898334466, 0.18176101704505732, 0.824100912677437, 0.16824028772712607, 0.782440608514811, 0.7312754929169254, 0.21141733216458292, 0.6485922111774424, 0.5507508198739921, 0.20569804351857923, 0.7686776822758785, 0.21251852553027772, 0.20703335776729526, 0.20731103762199188, 0.19745720181839455, 0.2027003039556705, 0.18496502187118502, 0.18369928816995684, 0.16989956802950457, 0.2005173908561526, 0.17719995692771995, 0.18468337742865237, 0.19216184034784234, 0.07589759772576732, 0.0819105471026278, 0.08095340857160305, 0.07747497759330091, 0.07525471830441255, 0.07390184804596278, 0.07734632198729796, 0.07907019331586507, 0.07850600898971027]}, "mutation_prompt": null}
{"id": "27df1bd5-106b-4548-b467-54242a2b8534", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 53, "fitness": 0.4033255204120302, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "8d68751b-e955-4b3b-a73c-388fd9479471", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "8e8d2907-d259-4dff-a1af-6386ebf36396", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # slightly adjusted population size\n        self.F = 0.7  # adjusted differential weight\n        self.CR = 0.8  # adjusted crossover probability\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F = self.F if np.random.rand() < 0.8 else np.random.uniform(0.5, 0.9)  # adjusted mutation strategy\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(5):  # slightly more local search tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)  # refined local search step\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            if evals < 0.6 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))  # more diversity\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm that enhances Differential Evolution with dynamic local search, adaptive diversity, and optimal mutation control for robust exploration and exploitation across diverse optimization landscapes.", "configspace": "", "generation": 54, "fitness": 0.279637881934377, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7144680868140367, 0.713125652175354, 0.6919299396784312, 0.6890885369967235, 0.7398082177091749, 0.7209672181897475, 0.7339214902014444, 0.7002731209943316, 0.7021068983072134, 0.43920695668534027, 0.4519232736519314, 0.49194728391080933, 0.4677464571849619, 0.42904942723752515, 0.47383988211685013, 0.45101287452500105, 0.4777527490724994, 0.49120542768821984, 0.11864734825998036, 0.14273215498710545, 0.12730032889550225, 0.11997295684683218, 0.12323143822082439, 0.11409028591536352, 0.1267533855627807, 0.12689571031599822, 0.10883157089025886, 0.11592275754270631, 0.13165045340800696, 0.11647198668573366, 0.13303941430420962, 0.10779366792352485, 0.12191589291127225, 0.11092807519512338, 0.10608384112769076, 0.10401021258194199, 0.9329415401694208, 0.9378042525196993, 0.9539338755179444, 0.897427215885142, 0.9406837775463921, 0.9294815567522174, 0.9648318581966331, 0.9120547509192434, 0.9503922156054816, 0.30997537673127173, 0.3387069748322572, 0.3212497761345797, 0.28670610759524184, 0.35262102669886897, 0.3208146081697977, 0.3224981023635928, 0.334185889641771, 0.3236067811870953, 0.5341262829487388, 0.544319020416062, 0.45026964199664066, 0.5658947927677511, 0.5688463153599574, 0.5146302456308508, 0.5320832880024753, 0.4194491466338467, 0.417624399253556, 0.23640361468340398, 0.2174893953048309, 0.20394750016247354, 0.19179106706011972, 0.2035567162088847, 0.20079474473911785, 0.18278008852612015, 0.23286070910003687, 0.1784030680074835, 0.1391185890900224, 0.17377352513730826, 0.196168793134884, 0.16817315080941664, 0.2543775871206776, 0.21035186384593774, 0.20810235731349647, 0.17964930087412756, 0.19178097482264123, 0.04978129234706108, 0.06145407216327481, 0.07626635668004778, 0.08781515958895503, 0.07249782927526816, 0.05991158092866622, 0.09021040382878076, 0.06279359624135272, 0.06585525896263844, 0.17536322544871963, 0.18769788898778306, 0.17556084749741785, 0.19707166748015525, 0.2016089623332804, 0.15177937573866473, 0.2160852069536222, 0.2205326326401651, 0.20142223662625325, 0.015655182317876326, 0.01445298356775715, 0.005074612366129605, 0.013709966547810093, 0.0043031259425561075, 0.011011531726105028, 0.013532174868120417, 0.05152530705984992, 0.019785646430146908, 0.15389566706359037, 0.14448578584691163, 0.13118324948088178, 0.14788532007696054, 0.19095448296003015, 0.16243039261353553, 0.14217274832286397, 0.14307324339434457, 0.1488866949386083, 0.4971596076713636, 0.5172624285451481, 0.5041526962272143, 0.5116136885703724, 0.49884526482369285, 0.4994310081457124, 0.4961836270298122, 0.4750266366101793, 0.4755288508698271, 0.11424599137882507, 0.10565803457135858, 0.12942036602959361, 0.10975159368581522, 0.10982476933645324, 0.09617379447166219, 0.09780557604299067, 0.09523528601376297, 0.09760045540298723, 0.19457750738333413, 0.15775620907896992, 0.19159644654274566, 0.17025736738774044, 0.23171128446167522, 0.2224895991096293, 0.21385247601063606, 0.1891175173486438, 0.18388181709138895, 0.27650732038058046, 0.28759758312585004, 0.2841204687416148, 0.2962773880459634, 0.29272091685744506, 0.2767197922028839, 0.313746757175682, 0.3088645514027233, 0.3299751674593099, 0.21102884399470145, 0.2275114330422855, 0.22608258472583287, 0.22810650464580562, 0.19512858997579852, 0.2184392306200873, 0.2225083362557424, 0.2369361295034974, 0.21263150709922318, 0.19677468525271413, 0.18281824376350742, 0.20868262853720976, 0.20554625624392275, 0.2000445184450782, 0.17848956617639467, 0.19304921176535206, 0.17737356310468788, 0.1888250157061966, 0.19732259140925512, 0.1945482182687348, 0.2087837411693646, 0.19657368576396705, 0.2260396228467576, 0.19183187223772147, 0.19459378239636593, 0.20360321232780088, 0.20632010025397785, 0.19674447013432295, 0.4421582299504977, 0.19384191522701044, 0.18157095266818724, 0.19982915240659316, 0.5843661304965073, 0.31969053086046584, 0.5689741060714564, 0.7199127825580584, 0.5802185168256593, 0.3981941749871075, 0.16313314900052556, 0.3350713269876583, 0.26632458468690234, 0.436680634914719, 0.15483170919510159, 0.6119606037646035, 0.20559248624496185, 0.19390767019815136, 0.20357863314148994, 0.1767233915581512, 0.19876272604949896, 0.18239905590672456, 0.18672681594889462, 0.19683393316989173, 0.2030816435358762, 0.18425486993981566, 0.0749099858927682, 0.07737925912345223, 0.08025965550085823, 0.0765650744395392, 0.07348408361936631, 0.07508553369818383, 0.07731073982644288, 0.07398425723119872, 0.075103641921069]}, "mutation_prompt": null}
{"id": "a4789ae6-5027-4f8c-9d6d-731e67caf3ec", "solution": "import numpy as np\n\nclass RefinedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)\n        self.F = 0.6\n        self.CR = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.9)  # Adjusted upper range\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3, self.dim)):  # Reduced local search steps\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.2, self.dim)  # Increased perturbation\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            if evals < 0.6 * self.budget and len(population) < 2.5 * self.population_size:  # Adjusted budget fraction\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        return population[np.argmin(fitness)]", "name": "RefinedAdaptiveHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution leveraging dynamic local search with Gaussian perturbations and adaptive control for enhanced diversity and convergence.", "configspace": "", "generation": 55, "fitness": 0.390799933322034, "feedback": "The algorithm RefinedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.8034558258912318, 0.8028960608390908, 0.7931499315475785, 0.7936857251689404, 0.8189561869252013, 0.7977924232891004, 0.7967298896100452, 0.7958419718362031, 0.8016801823981147, 0.6605413878985239, 0.6475017828192468, 0.6290915207865515, 0.6369395196611105, 0.6302655252695062, 0.6392546267983484, 0.6433514253481771, 0.6403029457156293, 0.6238735413082477, 0.10201018622751268, 0.10701979774313386, 0.11927649329330303, 0.11919876708017696, 0.12811556868226237, 0.09733591376418915, 0.10612349679326183, 0.12482720851394224, 0.12858137698684236, 0.09107551367543787, 0.1006602188692356, 0.10014293206894076, 0.09821525664738606, 0.10570404683045331, 0.10256728803133441, 0.10496236918405999, 0.0963788739594571, 0.10392128101942488, 0.9481696711607485, 0.885396792053467, 0.9343337343648026, 0.9539049760112696, 0.9529707294522236, 0.9588331707860757, 0.9544221949202368, 0.9645346459927719, 0.977710150408156, 0.49083463519570425, 0.47575072889863856, 0.46296266285688303, 0.4526436469876397, 0.47932899205295676, 0.470254847086625, 0.48641550359063335, 0.4638859643571467, 0.49087808135119926, 0.7618249803219916, 0.7953932639572747, 0.6997473337380962, 0.7806026008254706, 0.8071936474164233, 0.757459533147825, 0.7584362990306784, 0.7265060347934695, 0.8264214837898948, 0.374308551173421, 0.40364151697539297, 0.4543785323919931, 0.3671929493161852, 0.31802933605108274, 0.31161079985006723, 0.41818281091022913, 0.30990550360568714, 0.3637807347273059, 0.182323033831141, 0.2689116850505384, 0.1978421270087356, 0.4228978307549919, 0.3846993607887561, 0.3675535036740918, 0.45615393596031595, 0.39769216770846316, 0.39536731429263694, 0.3772451120512701, 0.3201487789356434, 0.33912694134297894, 0.4075560806512959, 0.3660564362640397, 0.3634150181513709, 0.3321514195086084, 0.3838094784655852, 0.3627767376536787, 0.4959930584064798, 0.5246681905110905, 0.48981154394276927, 0.5104400289010421, 0.4853470015583434, 0.48781982105491883, 0.5223016014291065, 0.5606217417170384, 0.5863525179912793, 0.14812188207655685, 0.20703602249355468, 0.1923592272604906, 0.16871631320163527, 0.17098920817018404, 0.22645547969948931, 0.07834205400910577, 0.1229390331522211, 0.13682874655721078, 0.28454146159535976, 0.31127493354426294, 0.3004985981192595, 0.32364572957080184, 0.3646311605017457, 0.3380683842908263, 0.2924759350129451, 0.30978675412613776, 0.3065098945571061, 0.6892380741167963, 0.7239750620137677, 0.6794560601799877, 0.7056567902538023, 0.696542994276427, 0.6694493251736856, 0.6907437197489289, 0.6707342965286107, 0.6988791303963908, 0.10058112766512017, 0.11030527362979681, 0.12085083142020325, 0.0981864377014845, 0.0920866115130935, 0.11002916324418088, 0.09780717215754886, 0.09948825171125664, 0.09352936325358718, 0.5709649641836372, 0.15087273200370932, 0.2309050639326926, 0.17547197529839775, 0.18927905986846294, 0.17058457545369787, 0.3560533581408267, 0.16516909630462628, 0.1709073867735309, 0.36877312250090055, 0.37371444262858144, 0.38621631280886826, 0.3965525023976538, 0.4051934983527855, 0.3950257855671201, 0.414600532990716, 0.4762456720158511, 0.40715968572350814, 0.28752256287892464, 0.3011126436315854, 0.2927910241428313, 0.3019247763559705, 0.3155357504746764, 0.2767438333876606, 0.3444320673223076, 0.32390782922808403, 0.3129984232121038, 0.22359682257191926, 0.1965822041501316, 0.19015270515287064, 0.19159400655515102, 0.24543167686905154, 0.194736507448257, 0.22160128072594254, 0.2063838750753112, 0.2135477519516339, 0.1895827950019192, 0.18672034040450747, 0.19755153136218728, 0.19921150384135244, 0.1889162349352803, 0.19510890936633918, 0.19316498353256917, 0.35672875583747077, 0.18293175420766705, 0.7669248211390219, 0.680270872946312, 0.21102142873894714, 0.20988776145328125, 0.20815215093623218, 0.6119994278497622, 0.18328424786140318, 0.7444622093998317, 0.3544445479063244, 0.8093968444135444, 0.7039697277315824, 0.7673584578963455, 0.6330426788188411, 0.16440633698386808, 0.6086368145684881, 0.20863752811507785, 0.739785751723631, 0.7670072843397675, 0.1828878257249068, 0.17736223496546222, 0.18643231416420836, 0.1845423295866463, 0.18620778919164582, 0.18738937529939048, 0.17691056002068872, 0.1807338359271491, 0.18615162474110725, 0.07650558009433839, 0.08594639910146185, 0.08083524403259668, 0.07058428300926956, 0.08493175476511239, 0.071925177393514, 0.07512181406671081, 0.07069803636588601, 0.09161113715707603]}, "mutation_prompt": null}
{"id": "7cfb5870-1192-4072-bf7c-ba6fbbe7a795", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n        self.elitism_prob = 0.2  # probability of using elitism\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Adaptive Crossover\n                CR = self.CR + 0.1 * np.random.randn()\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase with Elitism\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3, self.dim)):  # refined local search\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            if np.random.rand() < self.elitism_prob:\n                population[best_idx] = best_individual\n                fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "EnhancedAdaptiveDifferentialEvolution with adaptive crossover and integrated elitist local search for improved convergence and exploration.", "configspace": "", "generation": 56, "fitness": 0.38877982201574307, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7952662440440761, 0.8129014501259547, 0.8087051064136576, 0.814507924107096, 0.7944512352268706, 0.7895215425781217, 0.8104953341993687, 0.8013316124323069, 0.8126692760574479, 0.6514001927790456, 0.6452078508253709, 0.6456609331707187, 0.6345227975367227, 0.6556638026193391, 0.6600589712810694, 0.6237631651208194, 0.6235100954600956, 0.6607651519285991, 0.10900349868462711, 0.13339166817290338, 0.1190928360774769, 0.13067579110089844, 0.1150878438013031, 0.1123015858131321, 0.11809550129451285, 0.13257148766258686, 0.1352595009107137, 0.10623791796439441, 0.12063372444950948, 0.0976634860170037, 0.12229033371732678, 0.10425625495488289, 0.10496716502567283, 0.11187159681405212, 0.10809768950618004, 0.10238796094984537, 0.8732012020338097, 0.9182118871008834, 0.9096145814048311, 0.9483466613818946, 0.9071293225254715, 0.9259688186982286, 0.9287922362016939, 0.8170911614671366, 0.9485695278274604, 0.4965610100910418, 0.48047618306096196, 0.5219602044419641, 0.5190524596058128, 0.5277001449877113, 0.5187010672143378, 0.45460728472809375, 0.5003287380586683, 0.532227981323926, 0.8102400039866864, 0.7496462674376897, 0.7603980150007623, 0.79912308640975, 0.7643691984201757, 0.7514412013233107, 0.7957920646173704, 0.7304538000528699, 0.7908437283339904, 0.45889120144184914, 0.336318741713749, 0.3708019349651458, 0.3037660321672154, 0.37456653227597314, 0.4095858514285605, 0.40905439424498813, 0.3788969850149442, 0.4106723836159887, 0.21108919740671028, 0.41290785979526357, 0.41347439083044524, 0.32754511065085234, 0.3501929770972185, 0.3535840761129415, 0.28024223634914847, 0.3877429194727233, 0.31161667890584455, 0.37020777206856537, 0.39435920971295524, 0.3895598499082542, 0.4093929218933354, 0.4508241702872494, 0.4180981343305199, 0.45157053855844365, 0.3975047750251006, 0.4476266874918732, 0.549804710699091, 0.5036364779866997, 0.5374810549039705, 0.5551502001535402, 0.503828736010314, 0.5142866519759393, 0.5712764747042417, 0.596047242263666, 0.5984368625669759, 0.27589335180712504, 0.18551341581371128, 0.09769579558005825, 0.23986784978583786, 0.15121312286288635, 0.16731673680158943, 0.1438751133369145, 0.11998532795215855, 0.14947572305934953, 0.3187797376846295, 0.33681893365849513, 0.3056822212634138, 0.3214920329862604, 0.3246827966875242, 0.33811787469912846, 0.31196152942561584, 0.3100890883770945, 0.33287669585431123, 0.7037665460286118, 0.7290826037167315, 0.7216385320992721, 0.7166148702250281, 0.6946210062888423, 0.6896313565428698, 0.7150808540303297, 0.707483682406838, 0.7067188445559334, 0.10769498983085868, 0.11069195014999456, 0.1336650520385474, 0.114633958059977, 0.10247134569845551, 0.125177191450771, 0.10619204658204762, 0.11229814234083257, 0.12268004167994573, 0.21135849082103053, 0.17559117429602888, 0.21064298628893707, 0.20211382273842615, 0.2281595500466096, 0.21636450122052753, 0.19355321710050022, 0.1791953060137732, 0.15370916616306274, 0.4114462699572674, 0.39128014556588164, 0.4038530210219322, 0.36707591526708816, 0.35157451447221577, 0.4160790175200758, 0.41438600663124125, 0.4107925393583327, 0.39468675872018355, 0.29676919484281294, 0.307342055505736, 0.2856987909663453, 0.3102310658358658, 0.3136297529847415, 0.2930528470207737, 0.3495658757871797, 0.3336910304792411, 0.3140886441614862, 0.19628581829200642, 0.18701510797174148, 0.21506214382906075, 0.18552915248117263, 0.21124262851198206, 0.2064065651824365, 0.19489758034094617, 0.1944848402542615, 0.19382410870298106, 0.24795783183730924, 0.20195754145336375, 0.20541327715637403, 0.22227483055550845, 0.294223671937071, 0.19121212080442873, 0.19543240560193265, 0.22120481543486348, 0.2958837393494823, 0.18347955491214907, 0.7749140562701867, 0.16979273975153952, 0.18487387089492524, 0.19496578721307778, 0.717233821268578, 0.18271896436019952, 0.5490319335072229, 0.57807471052851, 0.7707376072477041, 0.20231465815442273, 0.6765105329739427, 0.5845736139207647, 0.6043896377199894, 0.2018413932489852, 0.20713281534875583, 0.7834097866860579, 0.20636850571004584, 0.1903473121240421, 0.1840671844173053, 0.17526639915615794, 0.18573980418592062, 0.20233118004223694, 0.19822190510624238, 0.1735412987574344, 0.171856102147379, 0.18826690347773867, 0.07646203497013704, 0.07588453783803994, 0.07751436151681779, 0.08125789923987359, 0.08074689548438185, 0.09029072857329612, 0.08247490522731982, 0.08200759934541801, 0.07490197163695722]}, "mutation_prompt": null}
{"id": "84924de2-19ec-4ff4-905d-8be74beb585d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # increased adaptive population size\n        self.F = 0.7  # adjusted differential weight for better exploration\n        self.CR = 0.8  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.9)  # adjusted mutation strategy\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # more intensive local search\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.3 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution using adaptive mutation strategies, dynamic local search, and enhanced diversity control for robust black box optimization.", "configspace": "", "generation": 57, "fitness": 0.30122716978795483, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7185577923865784, 0.7301930347682144, 0.7264197499955563, 0.754649082255261, 0.7520188327087758, 0.7215063660869913, 0.7380619185444379, 0.714695947322655, 0.7459002260936687, 0.48222675527182013, 0.5050272156884507, 0.4992297309405751, 0.496214814158217, 0.49365675941162257, 0.47421161228637265, 0.49034016732501085, 0.5148350451917938, 0.4668418841884163, 0.12334010379230098, 0.11162259699451171, 0.12172238736234375, 0.15378118500721194, 0.10819978625552307, 0.14083707422561564, 0.12004490412495838, 0.11989860055685497, 0.12928093343155778, 0.12013288859705606, 0.1322228591493183, 0.11030311658572123, 0.11079497643997671, 0.10539593221586185, 0.10232984822346936, 0.12887709242312395, 0.1103470481278489, 0.12055476383167585, 0.9496753436091377, 0.9323489144368218, 0.9254465530627582, 0.9334813125317974, 0.9306635685580311, 0.9176078017742608, 0.9531868506608436, 0.9289298882415222, 0.920562082382357, 0.3516769330586249, 0.3466903887659677, 0.32338016514928725, 0.3533086632407382, 0.35193886309355116, 0.3516731201997859, 0.3724847615521306, 0.3881674586902222, 0.372578319201625, 0.6039907529827104, 0.5690845884406979, 0.4552530353466011, 0.5789215383335915, 0.6775686485986692, 0.6853447391485114, 0.6812653950985589, 0.5827674885825664, 0.84344904080015, 0.2573908478542466, 0.2059238440931105, 0.22865953701588215, 0.19589790700550724, 0.1833814505533501, 0.1800788387787785, 0.19232053011441763, 0.21858963492800687, 0.19135054203970825, 0.15916691428484886, 0.19266867327553483, 0.1808815864640375, 0.22201340279767445, 0.18494731145115206, 0.24486226246476828, 0.2103056152977164, 0.19863916366919787, 0.1971680018241243, 0.1127291761179029, 0.10289236631428667, 0.10291332503232531, 0.10864090618009536, 0.06889278453424974, 0.08279810668141929, 0.08815101442030793, 0.08244388854494777, 0.12309339562811661, 0.18822422069653366, 0.19406772839097364, 0.20596229493489626, 0.2168010074432445, 0.21407123091105895, 0.1613525819757038, 0.2519549494770936, 0.23728647079798282, 0.21660495483534026, 0.018958168196990477, 0.01655151903339791, 0.008096472913280195, 0.009847318187753862, 0.028133786177512055, 0.03963840161351129, 0.024922090079314674, 0.054933835142324305, 0.022987853901137556, 0.16716261200086557, 0.15572636197597745, 0.17647030663907282, 0.16570694194091906, 0.16949521042301763, 0.177500476589864, 0.1897637585398564, 0.14950182778203158, 0.1750178699478414, 0.5281120468134458, 0.5284442967361194, 0.5066998426174933, 0.5258856820021776, 0.5155780424305871, 0.5163587957578579, 0.532012613579293, 0.5076220031800819, 0.5130977989803216, 0.1239038837872537, 0.11180737408732844, 0.11938391733890752, 0.14563982016769972, 0.1729768268991706, 0.1312323465546844, 0.14510388485388825, 0.1400661500943745, 0.11762343416130772, 0.14032676377220488, 0.18508490119285537, 0.21247817665593605, 0.21509430721176137, 0.1798621073980019, 0.2944273307829387, 0.22406782488797494, 0.2820044567587723, 0.2083619210206591, 0.3116851043636497, 0.3029771841112465, 0.3103188074060854, 0.3114498944835441, 0.2955753018039943, 0.28833256160405807, 0.3415424630461965, 0.3251403383182445, 0.33284561199288876, 0.2438942982339357, 0.2353442515268923, 0.21659919525041216, 0.2176650042263255, 0.23401269213092035, 0.22417101569399178, 0.23887584561361896, 0.23283006758853475, 0.24694322195151652, 0.20927551067099426, 0.1973330305323956, 0.21478430398335846, 0.21764954800388214, 0.22183176380979663, 0.17968393535783544, 0.1911194170873416, 0.18096335543397157, 0.19039915951201047, 0.20246269512852677, 0.24547808673295912, 0.2212390465231906, 0.1993963015212964, 0.19856805958311374, 0.26489123434184425, 0.2156322454759848, 0.20224307873036573, 0.20331173182894968, 0.4950640724842952, 0.17218392260376603, 0.18118481938067532, 0.6860031433740958, 0.19973252001397723, 0.5290406101045559, 0.24404229640701247, 0.7510027917571905, 0.7005849846472311, 0.44731388252780657, 0.20810002788078275, 0.49759930095060423, 0.39643687911683523, 0.4236163673467913, 0.51710104371463, 0.20885566368179387, 0.6722914790526784, 0.20920265218901135, 0.186149146820204, 0.18901126652316802, 0.20014017688777985, 0.1925322221853657, 0.2012778782004847, 0.18663307821200714, 0.19518250274049787, 0.18095453151623708, 0.17756820362836767, 0.07488840819683995, 0.07672232123013478, 0.08924027022303493, 0.07362681059512366, 0.07828485852586509, 0.07808821815167377, 0.07806820146695703, 0.07699177238389943, 0.07136991072580945]}, "mutation_prompt": null}
{"id": "804406d3-0e76-41a5-84a7-8edf10dd6e0b", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # increased adaptive population size\n        self.F = 0.7  # adjusted differential weight\n        self.CR = 0.85  # slightly reduced crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Strategic mutation with additional donor vector\n                F = np.random.choice([self.F, np.random.uniform(0.5, 0.9)], p=[0.6, 0.4])\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Stochastic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # more thorough local search\n                if evals >= self.budget:\n                    break\n\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                neighbor = best_individual + perturbation\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Multi-layered Diversity Enhancement\n            if evals < 0.5 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid algorithm combining Differential Evolution with strategic adaptive mechanisms, including stochastic local search and multi-layered diversity enhancement for robust exploration and faster convergence.", "configspace": "", "generation": 58, "fitness": 0.3477275686039239, "feedback": "The algorithm RefinedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7859146058506437, 0.7897899675230031, 0.7940122439484139, 0.772376285277449, 0.7888107826926307, 0.7917041629741933, 0.7809819303860963, 0.7979473613870477, 0.7787124322632488, 0.6209209570017965, 0.6052009327596735, 0.6152648811746981, 0.6110218332311717, 0.6312072755228976, 0.6330250425269516, 0.6188188804228364, 0.6265862008679144, 0.6127898431942319, 0.12782179774405555, 0.13005769871059436, 0.11345871337985847, 0.1600606763591288, 0.12082720888645271, 0.12776156405428463, 0.12951073870295582, 0.13222993566518193, 0.13594528462899003, 0.11491414030657632, 0.10354579444647938, 0.10632560136952018, 0.12021256295443361, 0.11136088344710438, 0.10502861244367245, 0.12169031001890729, 0.10788839360143443, 0.09943862339721021, 0.9280172229878481, 0.8945800126851903, 0.910553908678535, 0.924541141881145, 0.8722822413403327, 0.8928785314581104, 0.9287643693202905, 0.8803591706250911, 0.9026579434824291, 0.43599941330002934, 0.40022697413465724, 0.4319915052194766, 0.4192974126288177, 0.42222819169060644, 0.432571640059343, 0.41891567200436153, 0.41307774316220036, 0.419708831385635, 0.7337979808322264, 0.6744241660907705, 0.7195460161511092, 0.7668197385231857, 0.7319724912946224, 0.71819520506458, 0.6784889516701619, 0.7231900579667898, 0.7289669010746098, 0.24991044540533125, 0.21366046543768114, 0.19183458743951176, 0.27007364809212464, 0.35634076024567807, 0.19247023268926577, 0.18139530244777624, 0.27545727297152645, 0.26138236243573165, 0.1958629890557888, 0.21897107680065486, 0.21186484372034653, 0.26483135717007666, 0.22416614157599768, 0.20663232520234187, 0.2858873313938787, 0.20765024687226086, 0.1931416267258934, 0.2551915364830023, 0.21501536687056133, 0.22796090039599715, 0.22084202523837604, 0.21442348744813766, 0.24910272963713542, 0.27284942885694174, 0.2264689444810033, 0.25788930813725575, 0.41435051969389547, 0.40144036247786885, 0.3733422505570331, 0.36573467299040285, 0.3883470152909064, 0.3473280188122807, 0.4093759286332668, 0.4028656148659776, 0.42762972014453504, 0.08024072392954318, 0.10705794783170675, 0.12239808998861224, 0.10606912231572574, 0.10996055066546562, 0.07940408438283286, 0.0765576201866901, 0.05373752898159345, 0.09619831527738731, 0.26449851084959597, 0.2478191751902622, 0.2507585834689319, 0.2534864674891121, 0.27191361893127175, 0.2576987671015427, 0.23725554232421797, 0.24019726576594302, 0.22436825651139014, 0.6204257969451211, 0.6518428673793272, 0.6476548555833924, 0.6162043252376943, 0.65740274014307, 0.6165511191000574, 0.6631214992433646, 0.6266775179653005, 0.655032577945252, 0.10509390470846558, 0.13111346808206925, 0.12378383459549935, 0.12323478592905979, 0.09617639335776962, 0.13381003072182174, 0.12007271146387666, 0.1126791824376282, 0.12963562400075512, 0.18898819481502105, 0.17147964065147736, 0.17573716649459858, 0.23244573883448139, 0.20583813457902655, 0.18837757939002275, 0.19664061913948527, 0.16864503647824491, 0.1589737531996287, 0.3768396230424462, 0.3783964731670856, 0.36710113165948655, 0.36517478257593383, 0.3539292542773096, 0.363200437594664, 0.3828716646674709, 0.38403745990018423, 0.38082726457108806, 0.26216147097136844, 0.26688315861400624, 0.28084067280476466, 0.28503219200525076, 0.27240816550926994, 0.25887254306249696, 0.29285671628878207, 0.2865312352482918, 0.2763828780587735, 0.243540766727386, 0.19316374252000867, 0.22589147442780544, 0.20302108849044176, 0.19788077985605523, 0.1883054254381472, 0.2031480161319087, 0.2342501061259301, 0.2242207030171116, 0.20584649300373448, 0.21036088202263914, 0.2020904456623277, 0.2057437568576278, 0.192507978060799, 0.2103025278129692, 0.1941334702660431, 0.1959943719699857, 0.1934738923388083, 0.6432204943251216, 0.17183459728682793, 0.47291938147329526, 0.6502471952568221, 0.576165222008325, 0.641991145350653, 0.702080628133231, 0.627623882875912, 0.44271374188985657, 0.5379799517718074, 0.45490402767074467, 0.5172254965294811, 0.4263658849408717, 0.5158671047626082, 0.3989384966641627, 0.253815997187392, 0.21080620043505083, 0.2079728460070267, 0.1818455536992275, 0.19407896899287302, 0.18404881382526883, 0.17719228662150166, 0.18425810024531608, 0.1923355792608018, 0.18766689151949167, 0.19575212638709405, 0.17605105437142587, 0.07704738673713785, 0.08788007360157735, 0.08196896063597503, 0.0775123035707922, 0.0876941735989778, 0.075589236402136, 0.08166552169006902, 0.07902263053725533, 0.0804821072893781]}, "mutation_prompt": null}
{"id": "6fd70a59-4768-4364-939f-a440f9adbd0a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "eb7d9b5f-c666-4d32-9c19-3944f3517c99", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # slightly increased population size for better exploration\n        self.F = 0.7  # adjusted differential weight for more aggressive mutation\n        self.CR = 0.85  # slightly reduced crossover probability to maintain diversity\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with probabilistic strategy\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Enhanced Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # further enhance local search with additional tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.15, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control with increased range\n            if evals < 0.5 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution algorithm with adaptive and probabilistic strategy enhancements, leveraging both global exploration and intensified local search to optimize various functions efficiently.", "configspace": "", "generation": 60, "fitness": 0.30987369798285097, "feedback": "The algorithm RefinedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7296774395107462, 0.7394197299404643, 0.7211799934523324, 0.7360120811453918, 0.7207778167293916, 0.7389634530969902, 0.7452633835823022, 0.7101404836332612, 0.7226137829556192, 0.5331013743221673, 0.5265990229698433, 0.48768127267032624, 0.4704661483910051, 0.4848970639287612, 0.4955087588924417, 0.49117796792934176, 0.5059523702016117, 0.5334053252614723, 0.11775294446859697, 0.12533394223547634, 0.11767882733570656, 0.11590211566770503, 0.11391967427246386, 0.11604277940927166, 0.12260850548753277, 0.10721049152173168, 0.1132037868768293, 0.09850599627532886, 0.10746291589167156, 0.10980343615143007, 0.09466840485450079, 0.1267750136213841, 0.10017910129899577, 0.0937091928368523, 0.09270577315680273, 0.10734669768847693, 0.9312411179237873, 0.9397266237033788, 0.9196893195360586, 0.9760950750951484, 0.9354507102186276, 0.9111508367856579, 0.9322733797849521, 0.9356138764511274, 0.9624153682249006, 0.3386384196501776, 0.3373068885282716, 0.3416725678169372, 0.3657492618583855, 0.34734033446315715, 0.35108459893990007, 0.36417617341101116, 0.3596851192175786, 0.3583170553866264, 0.6110084026738627, 0.578553104110766, 0.6168629090383562, 0.6186472996419397, 0.6360741396269598, 0.6442673774221273, 0.5940772265193875, 0.6650864316609608, 0.6077941723944698, 0.20450630862367936, 0.18399082339225348, 0.2711964635640036, 0.24431333452918225, 0.27017193018390495, 0.23004477185816208, 0.23374987037528527, 0.22161321085507635, 0.2914461131831171, 0.16404536903294775, 0.2673978399648226, 0.1846438640146243, 0.23999629041505255, 0.23001808797716916, 0.2226667763121194, 0.25652400561535327, 0.22012657967126814, 0.22409798838251804, 0.14105328003877293, 0.1332513326706667, 0.17254192745348773, 0.14752465706093298, 0.18343957856327664, 0.11098296145591247, 0.18090984566003954, 0.15932227988199488, 0.11841190316973116, 0.28646982460008963, 0.26853538374747543, 0.30354115064432163, 0.2648562679316594, 0.3044780382374087, 0.25079743019634326, 0.28258278562230055, 0.3205064112433882, 0.3163903499130635, 0.024687008320950388, 0.05612457014947647, 0.027600082600746423, 0.04276377979653734, 0.08514241615638907, 0.05977974869296998, 0.05667730616543798, 0.04206590161504287, 0.08402057530332863, 0.1728508216476755, 0.18749408996830275, 0.15701045397082658, 0.19023169555979025, 0.19907295741372777, 0.18697232763256844, 0.19250792525285754, 0.19540793899485265, 0.16906783434718076, 0.5366272404149728, 0.5477400638981114, 0.546446279972481, 0.536630767537582, 0.5343270666586997, 0.5693894220849983, 0.554503535109119, 0.54094450386783, 0.575417057407958, 0.09106060022571805, 0.09306913306435094, 0.10854568924902741, 0.10171525488629907, 0.1093754193462666, 0.09296498509380235, 0.10308694352625569, 0.08370712787788015, 0.09128988842161467, 0.20006071254280677, 0.1836916438227365, 0.23262365475783864, 0.15626444424621855, 0.2118914359190629, 0.16027735867646276, 0.16480071957386466, 0.16054001142654906, 0.156853138391442, 0.3125256265083278, 0.30376451052011877, 0.3131723936580847, 0.3260135950285399, 0.3177517023101467, 0.3109054347222776, 0.34150655153737974, 0.33741117194354375, 0.35382138603556657, 0.2341826162905819, 0.22530978296781468, 0.2527821750196356, 0.23308022583464238, 0.2164734930691301, 0.2363709107264481, 0.25702975386781246, 0.2590640952723121, 0.25134302280698506, 0.18674389320449425, 0.18216201436316404, 0.22393385996660264, 0.20507838709434334, 0.19153517494859584, 0.21322353604560762, 0.19642954879692442, 0.18750267741246396, 0.20381536649947207, 0.1882061716156327, 0.19539989228296883, 0.20258971445785268, 0.19998602474081695, 0.19699734665511548, 0.20185115365053663, 0.2098451313221411, 0.20902413383228235, 0.2179404437447865, 0.16715450815653332, 0.47799911066521505, 0.7257038621928442, 0.652431249891867, 0.20093158423202173, 0.5313742099271523, 0.4490783365982254, 0.579036037940289, 0.37622412136944294, 0.5966244646184131, 0.5742214633638332, 0.4652613950444817, 0.4077772706253141, 0.19610367462324063, 0.5536542425443145, 0.2048968786387867, 0.6104938303683245, 0.20945732177558418, 0.17131093743051384, 0.17991628001998083, 0.17659817774633957, 0.18187263929318076, 0.19486013419840909, 0.19480288110865562, 0.1913147814123709, 0.1836397236235403, 0.17798032544493492, 0.08601609837518864, 0.07508275296768441, 0.08212277554289193, 0.06606126733683837, 0.07037962237675188, 0.07639934794435754, 0.07654870196937336, 0.07010029430913511, 0.07140411648788503]}, "mutation_prompt": null}
{"id": "4d68e909-110d-4ac0-85d0-f2397b177a8a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # increased adaptive population size\n        self.F = 0.7  # adjusted differential weight\n        self.CR = 0.8  # adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation with random scale factor\n                F = self.F if np.random.rand() < 0.5 else np.random.uniform(0.5, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection with random acceptance probability\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < 0.1:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # more iterations to intensify local search\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control and stochastic resizing\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (np.random.randint(1, 4), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, featuring refined selection rules and stochastic population adjustments for enhanced robustness and efficiency.", "configspace": "", "generation": 61, "fitness": 0.22514859109912108, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.5341257032357348, 0.5486342380150113, 0.5427467035292979, 0.5956696363821101, 0.6172004386165544, 0.6180057807154555, 0.5853484221633615, 0.5937342986719731, 0.5840199137307016, 0.2952946007445407, 0.27445063991653995, 0.26728979450632684, 0.2753111166915746, 0.22842837661964366, 0.28977135633160256, 0.2605985471896676, 0.27610258542359156, 0.2946642547295266, 0.10273605880267533, 0.09794031953898519, 0.1160057032832037, 0.1391361554566467, 0.12942681305625758, 0.11935802483618807, 0.15016684588942697, 0.1021117709461773, 0.10944707092466566, 0.09368324910248593, 0.09817463350121924, 0.09400743573107939, 0.09546267408724163, 0.10189107022956834, 0.10827306412067339, 0.10609230041887108, 0.09309726738545465, 0.09655943899942121, 0.9635787203957876, 0.9379514027007873, 0.9563057977619192, 0.931315836346631, 0.9620155403622868, 0.9428466372724311, 0.9611915997907519, 0.9418365496387341, 0.9677345114614633, 0.2960155622987578, 0.23280001703316577, 0.19972956610991122, 0.2085365681665724, 0.2457907452371615, 0.1874506555841533, 0.2410637100029337, 0.2141605591637169, 0.23895366334983337, 0.30015624255350337, 0.23751293399387874, 0.1828346159305928, 0.2595241578934414, 0.27519525185003235, 0.26158495623639466, 0.2117265097258202, 0.2473151374614112, 0.22137190015765196, 0.17949699684565712, 0.1922929910411053, 0.16864752432324714, 0.13737213510646595, 0.16280153238177464, 0.14528867484902497, 0.167714663212977, 0.15364551400686777, 0.15096476675388126, 0.18468730845538328, 0.14531338748098532, 0.10873675363739477, 0.14543503579250994, 0.14102340102639044, 0.1284386255040294, 0.134443766814493, 0.11022806772318783, 0.13097612852333407, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03537948484072129, 9.999999999998899e-05, 0.01782560811741718, 9.999999999998899e-05, 9.999999999998899e-05, 0.07280114473174237, 0.06682882635052789, 0.10679438405205677, 0.06816041651752824, 0.09808339527701049, 0.08057699055005108, 0.0759092032954588, 0.11342882747245531, 0.11148215651503068, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08494505843205502, 0.11376065743964814, 0.09888999855435754, 0.10893064875525471, 0.10221393922593491, 0.10893874120351743, 0.10985450194268209, 0.09967164395031503, 0.0973252432138394, 0.43209620994315256, 0.4000975601939135, 0.41864191844412557, 0.40684691683584606, 0.3965261933812656, 0.39761886575369576, 0.39734641867153864, 0.4055917980739967, 0.3867779007749743, 0.1327689546830466, 0.10879731653010183, 0.11460005044322474, 0.0988927562203884, 0.09679049944176821, 0.11519922873772848, 0.11555720050787954, 0.10870045880333035, 0.113982142220443, 0.15615387270176184, 0.1994283443978827, 0.212576006345795, 0.2229720107962635, 0.2252288285820938, 0.21606851166056584, 0.24159283142113153, 0.16909953487846174, 0.22379837101808708, 0.2505285774501451, 0.24850343794706742, 0.26106860813666743, 0.25149372170649564, 0.2085404872572968, 0.266242398008395, 0.2865842232292187, 0.26533203772138714, 0.26839609172688983, 0.1826558794702503, 0.19514169661101843, 0.18635087737657285, 0.17185138445935955, 0.14768554077753993, 0.16140709109451312, 0.2098345324564228, 0.2174026645981214, 0.20000675062686157, 0.17244332332448886, 0.18049664420473022, 0.18280424908999304, 0.17271970559702277, 0.18241496458763518, 0.19224499505766623, 0.18764825285576014, 0.17812634768626523, 0.1911139167141449, 0.17788741678885012, 0.1953611796385598, 0.18861255055759807, 0.19779633937687469, 0.19443792185557274, 0.19217755311723217, 0.19475307206095116, 0.18838998896132997, 0.18639221037729237, 0.5786680112571615, 0.4972570436787762, 0.17272824185419544, 0.40624186113615013, 0.17769167747364678, 0.41846371994294906, 0.17813887218220292, 0.17954280744587636, 0.17484730352231714, 0.43737849583801636, 0.18685127104775479, 0.2641152975233956, 0.3899341564251749, 0.24348920761562476, 0.27900385095338953, 0.20107596706292585, 0.30897957421484656, 0.3491685578796512, 0.18795165852668716, 0.1918108899536034, 0.2015116341140888, 0.19779296903125443, 0.20692490132473107, 0.19439863811982216, 0.19611534367594485, 0.17965522032870962, 0.2029842528749548, 0.07160929954720796, 0.07758761965143135, 0.07539119835011243, 0.07672988257987201, 0.07456843755009435, 0.06785559721801404, 0.07195409199244895, 0.0664295639649185, 0.07627743166405798]}, "mutation_prompt": null}
{"id": "1045e420-e42a-47d2-9ed5-a5d859c4deda", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # slightly increased adaptive population size\n        self.F = 0.5  # adjusted differential weight\n        self.CR = 0.8  # adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Introduce probabilistic mutation strategy\n                F = self.F if np.random.rand() < 0.8 else np.random.uniform(0.3, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Stochastic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):  # increased exploration in local search\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.15, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Diversity Management\n            if evals < 0.6 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdvancedAdaptiveDifferentialEvolution", "description": "An advanced adaptive multi-phase evolutionary algorithm combining Differential Evolution with stochastic local search, adaptive mutation strategies, and dynamic diversity management for robust exploration and convergence.", "configspace": "", "generation": 62, "fitness": 0.3362083272135492, "feedback": "The algorithm AdvancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7864449908551937, 0.7818676419702023, 0.7852550147445592, 0.7807098725351386, 0.7731607503597626, 0.7811417666484302, 0.7957941590233841, 0.7913835772716042, 0.790024815764474, 0.5963444628905086, 0.607488021278707, 0.5882346466907935, 0.6250034350423295, 0.6064982991043588, 0.5894528590791639, 0.582192563984919, 0.6029202368606876, 0.6328282758140868, 0.12450588237172466, 0.12880329426159387, 0.1202420613458759, 0.12191916281830417, 0.11567912414064652, 0.13769788129541305, 0.12451896346083846, 0.12910881942323904, 0.12879722061492505, 0.12348288323098056, 0.12233697611634431, 0.10666095435600509, 0.11843453607961751, 0.10805647122756667, 0.11612343141234727, 0.11673100472152642, 0.11338212009971882, 0.11254939664204011, 0.9643349727576224, 0.8830430270603644, 0.9135145571267076, 0.945822222851637, 0.9365187270055008, 0.9506276470489121, 0.9430020757821932, 0.8974761019506732, 0.9343170923302351, 0.4223426052783772, 0.4144846367036522, 0.4349800393694284, 0.4367132265125361, 0.4221619669307688, 0.4162819385543314, 0.4259134122291639, 0.4080487518128646, 0.456096684971793, 0.6727202320384984, 0.6953658641165664, 0.6279870547885056, 0.7420408505152507, 0.7400365912809975, 0.664010565167896, 0.6480750960587136, 0.6895254195087933, 0.7254830518334856, 0.23201836928880726, 0.19514791106145157, 0.27729469863029477, 0.2108807063681486, 0.18081940860343704, 0.2104081126398678, 0.21887752643638414, 0.2418327948710246, 0.27868807534930307, 0.20303107249754626, 0.20164651063200822, 0.20338612296118785, 0.2017379653390271, 0.23971058536630296, 0.19925080197264589, 0.22078705453790737, 0.1807760475189658, 0.24079986497568895, 0.15690386968432157, 0.16051170282241, 0.13032737482891554, 0.13743933217663684, 0.1461338263758336, 0.1728262633095644, 0.18359564326334876, 0.20052954119740074, 0.19485012392745316, 0.32075370897338906, 0.2816878531495697, 0.2724720577729647, 0.2441804150662118, 0.26344845485813784, 0.23008831740837654, 0.3081383656273148, 0.32673192432954723, 0.3519052856195072, 0.09500768987561736, 0.06718236210599093, 0.08699627038203384, 0.06619075785810513, 0.10138827377560078, 0.07374341715933497, 0.08145667112006572, 0.11672397202345652, 0.08469868516893198, 0.19393691342100616, 0.1973234157730176, 0.20276381520001008, 0.24186236265999927, 0.20778727242139672, 0.20489051120544088, 0.1858967756908937, 0.2083634956442787, 0.21641253916171732, 0.6230323776487743, 0.6100427188452513, 0.6137740390489743, 0.5810189651893938, 0.5891940145832033, 0.6068479203642778, 0.6070543995672202, 0.5776990957564992, 0.5878123093771177, 0.09789124562146734, 0.09817181491839988, 0.10335829189796863, 0.10007382833466272, 0.11926782521161694, 0.10796642892365704, 0.10983093044150771, 0.10806838085589587, 0.1220560582163589, 0.16687426993966092, 0.2459735842296561, 0.1758513924199997, 0.23765947746282157, 0.2056154159823813, 0.18671184102826388, 0.2093352540981882, 0.18438194409770892, 0.2144602352722772, 0.3610063281520889, 0.36486750079674435, 0.365114047845959, 0.35440757728500816, 0.3820580159556519, 0.3807204384750694, 0.4271226584770137, 0.4121281067616853, 0.4188014010063563, 0.251748521905792, 0.2644726260500313, 0.2619853018736924, 0.2399753406196593, 0.2602626194801758, 0.23519590679788394, 0.26421222270985445, 0.3011488105564405, 0.32406209242096373, 0.19403487606295733, 0.20240924170208296, 0.1863838453730604, 0.18168758639991434, 0.20717109441312564, 0.20722458263840215, 0.20660710967694718, 0.20008285946677873, 0.20092838910323219, 0.20292402397558318, 0.2956631433955409, 0.2181517032722824, 0.19859022794648085, 0.19023399970938182, 0.2105339585549293, 0.2006388279107263, 0.21012225941265195, 0.20097683782117504, 0.1820685400653972, 0.6460327670324997, 0.7509265631596245, 0.17782174708393472, 0.6803378800955138, 0.47771711106993653, 0.6562750469421239, 0.6631853094335738, 0.5627171393453612, 0.5182291429382567, 0.5431779100803835, 0.2081376220818344, 0.48542406398998705, 0.527127813391991, 0.20493229167298244, 0.6216138560916715, 0.6181709545168386, 0.15588410107985362, 0.19328349994860405, 0.17855082503924513, 0.20129564141607703, 0.18268398427788257, 0.1921673405763853, 0.1746864619334232, 0.1941516915145367, 0.19883078530607667, 0.1863132934023145, 0.07959355691704983, 0.08041256250072892, 0.08788167785908607, 0.08071007501603367, 0.08825361123627917, 0.07981811304525765, 0.0761997665897477, 0.0770989624293994, 0.08666595049793069]}, "mutation_prompt": null}
{"id": "801f4c37-162a-45a6-96ff-3f959f2d0c99", "solution": "import numpy as np\n\nclass ImprovedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.8  # crossover probability adjusted\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation with adaptive factor\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.5, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover with probabilistic element\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase with memory-based enhancements\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control with memory consideration\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (int(0.05 * self.population_size), self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "ImprovedHybridDifferentialEvolution", "description": "An improved hybrid algorithm integrating Differential Evolution with dynamic local search, adaptive memory-based diversity control, and probabilistic crossover for enhanced exploration-exploitation balance.", "configspace": "", "generation": 63, "fitness": 0.33286679886778503, "feedback": "The algorithm ImprovedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.7820094242554595, 0.7931856752551207, 0.788012571297653, 0.7980446315084194, 0.8010507296040221, 0.7919743105029244, 0.7899739115485902, 0.7967364936131871, 0.7951842679245609, 0.6171956597634518, 0.6460490166877393, 0.6369291423528529, 0.6121495167467202, 0.6049434282741111, 0.625738616203966, 0.6116412437654906, 0.6102926550834182, 0.6050369564840632, 0.14093531819652638, 0.14265435595971232, 0.13530347195309556, 0.12184742753458833, 0.1124041024861896, 0.12159876741395914, 0.14426833997806876, 0.11129840710124594, 0.11114857833703806, 0.10348472991311686, 0.10783644659418168, 0.1173327495883828, 0.1272940334545929, 0.11382872664110377, 0.11465787815043349, 0.10440373022312432, 0.11587668403760931, 0.12370972329836438, 0.9702347685395512, 0.9615226525352636, 0.9523931112007692, 0.9701428152372099, 0.9581434021476783, 0.9656634549958468, 0.9472529787144159, 0.9482255560091403, 0.9790528867334641, 0.41336560784553766, 0.42235044466802596, 0.4241621956125263, 0.4155590252328357, 0.41574527487772206, 0.4328161640543594, 0.43439702009698045, 0.4704575533512557, 0.40094398591371805, 0.6798071753406392, 0.660564853014173, 0.7058008691407625, 0.6614145801198195, 0.6998188090444852, 0.6373939929032438, 0.5677727086302775, 0.7325258383585971, 0.6897730273641741, 0.24154385443430015, 0.2396690973277541, 0.2691182057004283, 0.25748320264314906, 0.27080751616207155, 0.23950304717202975, 0.2695817260257717, 0.23543805071113677, 0.23333728724171943, 0.2484612217409734, 0.20533932221399842, 0.21750667763909382, 0.18603049060505872, 0.21462523693522784, 0.2575483719854884, 0.24328094751769946, 0.2508120207106208, 0.2708656074267276, 0.1153398218667786, 0.13188506437881098, 0.1577174558499257, 0.20688082346584558, 0.14952341129059132, 0.11991775690371909, 0.1636949463370091, 0.17898503493520002, 0.1805539001877462, 0.2618402404840281, 0.30228706876336486, 0.2515831647050478, 0.2560590466929823, 0.24827294388469823, 0.2511035016981469, 0.2743784752964987, 0.31876552571221217, 0.35640796062336055, 0.056738044237303664, 0.028668805950499365, 0.03757466338491444, 0.06029896508342503, 0.11111845982566193, 0.11238264773191553, 0.08287697357168922, 0.07603876573256252, 0.08527081290651728, 0.20479448752869578, 0.19964133604174572, 0.20408943981274974, 0.22229592678583077, 0.1988959385082134, 0.2049723090614688, 0.19796346382860708, 0.197092571748822, 0.20458015774742244, 0.5773795757312529, 0.5836902228384321, 0.5935339911497829, 0.5753375161402585, 0.5893109734852402, 0.5548240656919672, 0.5931749628394112, 0.5558127012932843, 0.5924521081754195, 0.1124843027296687, 0.11020652085621208, 0.10246192920402974, 0.1256447842332007, 0.0968803044943416, 0.14089585022125906, 0.12658042754121757, 0.10077591200133307, 0.1249682950536628, 0.1610932647409481, 0.18986080761889912, 0.30093428709579484, 0.20587545896908155, 0.20719371657673447, 0.21357649735278983, 0.20018518167579025, 0.24472728224792173, 0.2103559951352546, 0.31879973680147244, 0.3288861756662699, 0.33121658200281956, 0.3493347411147514, 0.33407617857609595, 0.3288727456332271, 0.38994758445632394, 0.3695095570952709, 0.384903647391049, 0.24488779693186946, 0.26001269343116395, 0.2553588410270031, 0.25075593075443003, 0.24677722272400637, 0.2428337782147847, 0.27240158190554775, 0.27280322087845976, 0.28388424123889966, 0.18975914962162, 0.19467921066189509, 0.2023054845506732, 0.19185566883061456, 0.19577462751720254, 0.19307561472733303, 0.18988016519963435, 0.21092294520818966, 0.18829733012808492, 0.20468672590818104, 0.26324149504863836, 0.22413209343167662, 0.20625206209051816, 0.25335669838494523, 0.1844649956993334, 0.19357389318145857, 0.20547957447453402, 0.21658102360260123, 0.6170239595701248, 0.7760266834182566, 0.6986618865243298, 0.7642095740716793, 0.20001018808149584, 0.18350619613863528, 0.3086010856743876, 0.1798330334851007, 0.27834695239955676, 0.6570953712555563, 0.2102247119060373, 0.5077611056388383, 0.6310596930821979, 0.2111455952898056, 0.20668577493945695, 0.7001684034270157, 0.20907468275093055, 0.6574069528796964, 0.18564354312357545, 0.18341432817649383, 0.1744123189281599, 0.17025937913379563, 0.19211322782947104, 0.1998571470888303, 0.17972743359980636, 0.17013622650482685, 0.1830275364066941, 0.09270588572840299, 0.08621908289391833, 0.08395154309060493, 0.0799497172811553, 0.07935859133886847, 0.082773461626242, 0.07765997122571866, 0.08011221289316328, 0.08249287866215249]}, "mutation_prompt": null}
{"id": "32eac34d-7f0d-4156-bbd8-2a0ec04184ff", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "39ce812c-c844-4e36-85c3-0c7f360a99be", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "b80d744f-8f27-4c41-afcf-7b476ba50181", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "39d073f1-0fb6-4fe4-a0b5-cd46af263265", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "59a708e3-24b8-4033-a63f-bf4a2f04d7a4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # initial differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive F based on dimension\n                adaptive_F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + adaptive_F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Fitness-based crossover\n                current_CR = self.CR if fitness[i] < np.median(fitness) else np.random.uniform(0.6, 0.95)\n                cross_points = np.random.rand(self.dim) < current_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A refined hybrid algorithm leveraging Differential Evolution with dynamic local search, adaptive diversity, and strategic mutation, enhanced by incorporating fitness-based crossover probability and adaptive dimension-wise F adjustments for improved convergence and robustness.", "configspace": "", "generation": 68, "fitness": 0.39388578974970395, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.811406170024652, 0.8104489832497945, 0.7966395571211377, 0.805793895387463, 0.828160026426378, 0.8024838082557206, 0.7967463981824671, 0.8016725720518265, 0.7963664755933961, 0.6282504689927612, 0.6725744234877851, 0.645777049796485, 0.6326424320542652, 0.6554843073558287, 0.6575662410506837, 0.6378001615666832, 0.6394792110684773, 0.6543958877988534, 0.12105005978266381, 0.1226273706275759, 0.11326677206506697, 0.11650893493408021, 0.11415738568117195, 0.1133939361187789, 0.12275152547092216, 0.1249277618532475, 0.1110598439191619, 0.10850942897824356, 0.1123661532517437, 0.1064909937374039, 0.11355705578035635, 0.1112119372596484, 0.10114007727261254, 0.10634870421495612, 0.11204170751721654, 0.11099347971931783, 0.9477695059476371, 0.929909532696877, 0.940027712879711, 0.952747004100256, 0.9435347317607278, 0.9358212728332944, 0.9361013926062319, 0.9135113696193174, 0.9548547608616892, 0.49586960294375626, 0.46088575381637886, 0.507172878887046, 0.5084880330707162, 0.4524898005406145, 0.4928990733839924, 0.47524203142434673, 0.4785405594576999, 0.4650543851755836, 0.7461522123660236, 0.7213717784807208, 0.7826657683399356, 0.7589240819628283, 0.7813910994978398, 0.7713352991137646, 0.7650307625416862, 0.7586106024742948, 0.7448583742314325, 0.33681304303252313, 0.4403358391603698, 0.37487234334578856, 0.2011119723347421, 0.412349741490901, 0.36452207541996307, 0.2991148599216109, 0.4144215473388718, 0.5197391662301736, 0.2069752419559452, 0.4990763551297258, 0.4031304570978326, 0.26355348956469815, 0.5060586688854161, 0.3840852848244781, 0.4015117763475575, 0.3142870304347297, 0.5010705799701076, 0.4015212713393792, 0.3972300154512959, 0.30579657505559166, 0.3691936051266521, 0.416365298587107, 0.37555358585166565, 0.3324575513673076, 0.3468564559261801, 0.3003887263198086, 0.5261902632315345, 0.5486839511678012, 0.4778052813103423, 0.5117225942345421, 0.49356547782257354, 0.49883807968154226, 0.529091481580007, 0.5690897728083537, 0.5603615254391954, 0.12348270205807532, 0.11857363632881246, 0.13991359132576453, 0.23965329229645016, 0.2650603932982334, 0.2807201330467649, 0.2045908080450748, 0.20505995760012496, 0.10076293603147102, 0.3130936075669426, 0.32994987159150224, 0.3006306592099234, 0.323346637876772, 0.31923495104017063, 0.3466327608030143, 0.2869391531656569, 0.3138859395196181, 0.2903901832539857, 0.7410606939380311, 0.6879052167207494, 0.7292178202459116, 0.6986668105416731, 0.6850922050787589, 0.7068223296220713, 0.7142925949280692, 0.6979770271077823, 0.6678924851061099, 0.10831940836232912, 0.1533163038203993, 0.0999662621126286, 0.1112344889486887, 0.14115430655539873, 0.1028883156259004, 0.1116131639836554, 0.1029663606148864, 0.0927155118159706, 0.21836905362093328, 0.17058311912221358, 0.16552979837700676, 0.30845897188986804, 0.20333829323533748, 0.18969826909178045, 0.2685793287629519, 0.1483082026581235, 0.17724417492566313, 0.39693526583321403, 0.38972411012788943, 0.3490227998727228, 0.38961625731267113, 0.33880245283123933, 0.4107843489507669, 0.38974745693745316, 0.42461128747256416, 0.41052807228706956, 0.3131456496317705, 0.28507637389186946, 0.3160700702129605, 0.29011814168215, 0.30072442717273185, 0.3109004565348551, 0.3114325739987387, 0.29898091361108525, 0.3174300768438657, 0.2056490866981796, 0.21903289968779782, 0.18962275753532587, 0.20053179004127542, 0.1980762988391146, 0.18551196858595254, 0.213719661759604, 0.21286567116229538, 0.19573398787176022, 0.1997849587988315, 0.30885695875725117, 0.2353749594559238, 0.20272829727192754, 0.1954117296129605, 0.311123846924909, 0.2212162779091349, 0.2079625521523567, 0.2058383295511289, 0.6737678757223234, 0.7630551860975706, 0.7258133087788985, 0.8034273127162059, 0.1999107572935538, 0.7399153309396171, 0.607360376888465, 0.600877561831602, 0.7456212006149678, 0.7681032406636217, 0.21090952706929134, 0.2024443044138302, 0.2065978869658055, 0.2078532740016057, 0.6870480526747794, 0.7317443472394021, 0.20893815348723876, 0.21025437395563118, 0.1798644209404563, 0.18335274119879152, 0.18130807828097784, 0.19255179885387452, 0.18626270618020913, 0.1828759168925389, 0.18847475401335145, 0.17822591360923634, 0.19105478933097064, 0.0974359781141031, 0.07500879550478734, 0.07177781894742763, 0.07620695489822304, 0.07300914214836574, 0.08464508334213239, 0.08554687319643106, 0.08038987079931426, 0.07878081618831256]}, "mutation_prompt": null}
{"id": "3118318a-92d5-4f5d-8702-cf927355e17d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.6  # differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Apply strategic mutation\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(4, self.dim)):  # enhance local search with more tweaks\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A novel hybrid algorithm combining Differential Evolution with a dynamic local search and adaptive diversity control, enhanced with probabilistic selection and strategic mutation for improved exploration and convergence.", "configspace": "", "generation": 54, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.803749489881964, 0.8071396457761179, 0.8092991849563058, 0.8159250188053775, 0.8111514860164707, 0.8026985057322512, 0.8106488973127417, 0.8113017615537651, 0.803458569462723, 0.6445373995223822, 0.658401013973398, 0.6269783223389807, 0.6627899963511726, 0.6585305039028364, 0.6452138087716677, 0.6365590671565458, 0.641001763539168, 0.6359936020970277, 0.12773436196393473, 0.13209779872723815, 0.12001584823309497, 0.14453906820904394, 0.1297396115918642, 0.13143732130328678, 0.1348513225553466, 0.11869870127553295, 0.12239388411555996, 0.11007349537858313, 0.10657319574400992, 0.11405540274412451, 0.0983645404897765, 0.12094553390047091, 0.11677635881921511, 0.11567466076924593, 0.11010059240142878, 0.11144589395523963, 0.9543372222968003, 0.9641018445059875, 0.9445193550765709, 0.9452942496367935, 0.9787270075013883, 0.9540849453244633, 0.9507998524654295, 0.9505143132188285, 0.9654420281584888, 0.4950892003492865, 0.4887859203312408, 0.49313769510010197, 0.49147072365252653, 0.497650669188508, 0.4803323631496159, 0.5158145628635098, 0.4740838026087597, 0.5015216505982152, 0.7414090137079614, 0.7179448402691047, 0.7332192216156727, 0.7613151933275909, 0.777594764680377, 0.7788683692800475, 0.7782875611601789, 0.8024617282812919, 0.7560488735435358, 0.3758783655278489, 0.3194187810847583, 0.3417670454525842, 0.434804028122156, 0.43729051418040676, 0.489520166454809, 0.3698170825710928, 0.4275675095890118, 0.4860818048659178, 0.5005159941028676, 0.39867943243587345, 0.24708234680060492, 0.3110528179621529, 0.3311326297969034, 0.4102853556636865, 0.43365995953539627, 0.35811067068939706, 0.44707708572581606, 0.3783133750513875, 0.3496126849263643, 0.3853446458222758, 0.3902939682547044, 0.4040452432924593, 0.342481792434032, 0.3581722624472302, 0.35318211628337026, 0.40288082819302085, 0.45017079014728556, 0.5023110171776706, 0.5587447819168134, 0.5475791022175053, 0.5260277065868746, 0.5234782931762196, 0.5394208444583923, 0.5791170022604839, 0.5547687955408211, 0.13392649581161897, 0.09692120614812483, 0.1714272525328948, 0.27664405482226917, 0.2532627438193369, 0.28368049389770966, 0.15803048032563727, 0.1541388107752344, 0.13737213364033796, 0.3245585778096932, 0.2944244879487744, 0.30558244347375596, 0.3133684890636095, 0.31608128619620224, 0.34663477063692094, 0.28128307830767685, 0.29533325316302117, 0.29285826305661333, 0.7134200104083055, 0.6973568098594369, 0.7146917215873376, 0.7214757079332321, 0.6873025994743993, 0.7144508284243816, 0.7029726024411571, 0.6832955771647511, 0.7065200679654959, 0.11549118784114687, 0.10993009563786582, 0.11932051184546799, 0.1241895783956154, 0.12476375255475325, 0.13156695877167035, 0.11748002931810819, 0.12964882551289814, 0.1317834877052626, 0.22605300586326194, 0.14794555936171983, 0.1951588663152467, 0.37431740471186414, 0.21922419774582302, 0.18566066781920587, 0.23297172691517698, 0.17194130579396782, 0.26781620675577245, 0.36588128068884695, 0.38852679648094157, 0.3519939922687155, 0.3849164488765934, 0.38462277713265325, 0.4015568766452171, 0.410954345562086, 0.43148643870418546, 0.40806041857105424, 0.30797068976665876, 0.26088273149533703, 0.3069752061418206, 0.2769905747552629, 0.305404456200319, 0.31131708663240987, 0.3245033835824379, 0.33811358400956126, 0.3166536809959316, 0.1888267256677142, 0.2225033435911853, 0.18821180940697746, 0.18650155688199144, 0.21162515501631873, 0.20048505133958128, 0.2041840003156008, 0.23213127016449275, 0.20714187174378806, 0.20027606489100214, 0.19642502286641095, 0.21058984611030696, 0.18202100229572094, 0.2754294669721842, 0.20469439273333, 0.20813716190749598, 0.20944402071160562, 0.2195819675092907, 0.16356182147987963, 0.7610706143032695, 0.7420139674934021, 0.8303480648509809, 0.7394759959333106, 0.7467589747778414, 0.7383482853654648, 0.6982222870439072, 0.6706273354664308, 0.7527229045847664, 0.20961480894919426, 0.6255681017668133, 0.7242605145910603, 0.19890025491442997, 0.6797375205784841, 0.20826746806882834, 0.6965569676837012, 0.20863000134819387, 0.18511436576972973, 0.1741891733875316, 0.19259835513345958, 0.194482807826873, 0.17247943631575435, 0.184737191924774, 0.18570517935179875, 0.17144252934128668, 0.20085624132792723, 0.07559712304915334, 0.07006846030380842, 0.0775389251968962, 0.0850077178772164, 0.0846749981247169, 0.08674761773599349, 0.08269418997467837, 0.0841232694334374, 0.07883138156737735]}, "mutation_prompt": null}
{"id": "17fc2a20-e537-4a46-9b98-6899f5313bfa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)\n        self.F = 0.6\n        self.CR = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F_dynamic = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.9)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(5, self.dim)):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveHybridDifferentialEvolution", "description": "A sophisticated hybrid algorithm blending Differential Evolution with adaptive mutation rates, stochastic local search enhancements, and population diversity control to optimize exploration and exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.3963061870577028, "feedback": "The algorithm EnhancedAdaptiveHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.8055175981699387, 0.8167974065835668, 0.7930845970671807, 0.8058783522846262, 0.8014140671742522, 0.8218650752679577, 0.8018059794221913, 0.8025319881254563, 0.803856676523719, 0.634890177939077, 0.6265894451900378, 0.6059817423658469, 0.6018474776489007, 0.6416050220252469, 0.6144084817153355, 0.6456749884663593, 0.6417997103509951, 0.6115704625079611, 0.1475229662140749, 0.1686678817681524, 0.13058378562975936, 0.10689123095322195, 0.1165357967027899, 0.12626346732422156, 0.11908011293070608, 0.12294323917705041, 0.1210814432789653, 0.10079890075842579, 0.11029553477030551, 0.10201081746137985, 0.10633898207563275, 0.1190238752077194, 0.11329183009866606, 0.11707064298095193, 0.09695782823091992, 0.10223533954768449, 0.947914614449963, 0.9035394028756184, 0.9361163337759866, 0.9441627488629196, 0.9842757555862129, 0.935626419033354, 0.9718711881348967, 0.8920517210195464, 0.9552988266524146, 0.4569590168291482, 0.4812015237767916, 0.4377591122185417, 0.4537589433547159, 0.45929918065887254, 0.49797752883540103, 0.4398525483938839, 0.46110352615558026, 0.48407675968792485, 0.7837407537005161, 0.7714837410463212, 0.7486153337238903, 0.7803440707114458, 0.7690390747781627, 0.7666432432115003, 0.7256996098439732, 0.7566509608432871, 0.7724499567776477, 0.3461095226816827, 0.4610122828239037, 0.31766895316961963, 0.42450483046282583, 0.4218038185147782, 0.3355926635503189, 0.44880267799510143, 0.3266096927030623, 0.2866721008022558, 0.34152144429362463, 0.25687476845699864, 0.16107693709723514, 0.3335662174004389, 0.38377343552141385, 0.27208219416134083, 0.35823694645434434, 0.3985135559344388, 0.3096986404004731, 0.39638450173063633, 0.33065743987239515, 0.3854892712606809, 0.37527776463038587, 0.3588236518729181, 0.38804134454079, 0.3675309836722368, 0.39131427050521284, 0.40851756165167585, 0.5826881086332983, 0.49702800909620004, 0.48929078009729643, 0.49471441475566225, 0.4159153932288403, 0.4745628440149974, 0.5568227567888114, 0.5341140850123283, 0.5103743915748225, 0.141745720235531, 0.10845921612887, 0.13224186838987229, 0.22838497957021442, 0.23032883640307455, 0.21850714365314694, 0.12583069969066474, 0.14711894100094158, 0.19456313988009155, 0.283581034939002, 0.3127333089686146, 0.2839764264217032, 0.29575857146816775, 0.29033395970196385, 0.30801645051497084, 0.31708621332317377, 0.2641207406070144, 0.28143483866120744, 0.6894662167640182, 0.6886819628829373, 0.6806021566978564, 0.6768764252806445, 0.7121267566494787, 0.650185751923572, 0.7080271418394462, 0.6817850074267968, 0.6740081751195852, 0.10696678463584286, 0.1200829643952851, 0.111442076214605, 0.1231502602396648, 0.11251251701031761, 0.13212015247314646, 0.10393010466299091, 0.12281278226382475, 0.11514936453098978, 0.16027661418659422, 0.22783986703692483, 0.6463113853428286, 0.16167006842095066, 0.27411164767403096, 0.27794326968553174, 0.20544845162165637, 0.21298579964978825, 0.1468378295451419, 0.36495328966264784, 0.4118045512182952, 0.3745617332734358, 0.3353835708594698, 0.3788140759225229, 0.36998465691220006, 0.37627770947519146, 0.44098137180228925, 0.403733840652181, 0.2511573571341065, 0.2884883317405359, 0.2812651465449769, 0.28671644265962304, 0.2777178644941555, 0.3179141185151264, 0.2998469478841681, 0.31929512181870434, 0.29059379251205997, 0.20898959465960765, 0.21077622912654392, 0.21613036984931389, 0.20955692345809473, 0.20316771442187442, 0.1946593622207874, 0.2161905986449114, 0.19430623228954969, 0.20675114312608478, 0.22765179509480904, 0.19358211141946136, 0.19611497536435663, 0.19187710714074657, 0.22563898527441617, 0.2018150870451222, 0.24938464288331397, 0.21909810492395665, 0.20066931575073332, 0.831832188939789, 0.5273025674295748, 0.8219592774199326, 0.817576238083291, 0.8043476661395299, 0.19950983471255312, 0.7639706436543945, 0.7086759057350092, 0.18675418224329443, 0.7173125949004922, 0.6822925422307944, 0.6178121210016114, 0.6658208417726534, 0.20342971288983658, 0.6562492530990907, 0.20869073287955853, 0.75784035386788, 0.7993471297181137, 0.187615953850934, 0.18002997764173145, 0.1888032641559172, 0.18707871000422338, 0.18408175774048696, 0.18802170646390837, 0.18272473468304162, 0.2105284611054251, 0.1982580777819103, 0.0732023583238719, 0.085091807827823, 0.08091985004119362, 0.08412789581251567, 0.08641547246777559, 0.08003868260348213, 0.07998271299089499, 0.08918876213620641, 0.0779855183661804]}, "mutation_prompt": null}
{"id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Enhanced strategic mutation\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.7)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3 + int(0.1 * self.dim), self.dim)):  # adaptive local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution with enhanced mutation strategies, adaptive local search intensity, and improved diversity control mechanisms for robust optimization performance.", "configspace": "", "generation": 71, "fitness": 0.4065067812379798, "feedback": "The algorithm RefinedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "27df1bd5-106b-4548-b467-54242a2b8534", "metadata": {"aucs": [0.8345947556041204, 0.8344129807767731, 0.8496897455254219, 0.850880566213741, 0.8398700864604994, 0.8341194144105729, 0.8331192695753851, 0.83468467302919, 0.8556694603902995, 0.6899101586472853, 0.691698210308391, 0.6940338692720854, 0.7078210947456172, 0.6976575165581711, 0.7055912662872857, 0.712267926249102, 0.714117006925792, 0.7453705520959476, 0.12207745589717722, 0.13042729626863725, 0.1683692767867354, 0.12165062330854448, 0.1438693219360473, 0.12379395824200723, 0.14284227235783076, 0.18343669055542888, 0.1388966501011648, 0.12050913458608592, 0.14048991280325485, 0.11818782861074628, 0.1078569328928628, 0.1514644011773134, 0.13484253340477315, 0.12237849260670464, 0.13681409875845296, 0.12526923194958584, 0.9515813983819036, 0.9575708486221908, 0.8959780406814486, 0.9383796386856079, 0.8785420019331741, 0.9456639060462296, 0.9623331092369904, 0.9612054128762256, 0.9301115365300654, 0.5659620057267705, 0.5975174707046442, 0.5470784808957301, 0.5028509412473794, 0.5401741723756995, 0.5292089681338346, 0.5644123902336324, 0.5971607440226782, 0.5523857986399616, 0.8182252349989906, 0.8147875097695667, 0.7612773161076937, 0.7965176795577389, 0.8198220329979958, 0.7754038220455346, 0.8151971989194233, 0.8153393882528859, 0.7994102939170779, 0.3101263990307639, 0.25501149779839216, 0.20595554994131882, 0.47677211664284824, 0.4840308566899385, 0.2765709947993519, 0.5353029341338831, 0.22158559678040068, 0.21369695895437313, 0.19883551151452106, 0.4680690015726112, 0.22455949378496154, 0.2655526554836063, 0.2043074547908097, 0.18771827829647914, 0.2163993236738837, 0.22744354934031497, 0.2508436003113276, 0.39676919739410854, 0.4109050776930292, 0.2811997796134026, 0.3750506935065109, 0.3464002092635504, 0.34936012103614644, 0.4296069155882375, 0.39175010608079186, 0.3382245487833929, 0.5495584421984303, 0.5151131414685374, 0.4787331504365022, 0.5042129952566867, 0.5082796068952418, 0.4945445540011696, 0.6066789181317289, 0.5518764918072907, 0.5033516412363188, 0.1469112426121859, 0.15901511531761225, 0.11868771040498938, 0.2682480763202735, 0.22721109545203144, 0.1080628825499087, 0.18540040167484928, 0.1383819691326158, 0.23448163099672859, 0.308721848927748, 0.3234531677580409, 0.3256119101393413, 0.34407359911282287, 0.36097924011383287, 0.32948483102494797, 0.3052901751326711, 0.34104118677147655, 0.3008385046780653, 0.7243897906305089, 0.7349545691665464, 0.7136487517137047, 0.73226459796416, 0.7470723844665785, 0.7110322275798219, 0.7448839293223198, 0.6828990658151786, 0.7359294140393221, 0.11492515589253671, 0.10908521109335745, 0.1155802540615829, 0.1259213355874741, 0.10514979088223608, 0.13628497269268391, 0.11150169278675526, 0.10813043452587534, 0.1266715402548494, 0.19697147032609874, 0.29454396682760553, 0.16412239265176176, 0.22666354294649937, 0.2917752390369516, 0.16715091832368667, 0.21686945699505544, 0.17205995207483715, 0.22256722662648143, 0.4348835700794995, 0.45649020980153643, 0.4224355352011846, 0.4075582853666667, 0.4421687237309133, 0.42582452928250436, 0.5197862250450395, 0.5220647224829045, 0.5128337745848454, 0.3325786345694479, 0.3282593282903946, 0.35133647331528317, 0.3208405943571796, 0.3395674338937893, 0.350695368573549, 0.36962469329332326, 0.4105996337455271, 0.3578817523566138, 0.19376225806473912, 0.1830453243218364, 0.22551197892944552, 0.20518142569060305, 0.20153202293018857, 0.182095717775688, 0.18484883492789383, 0.22276710046196435, 0.19457681027207385, 0.4210064040796183, 0.3521823951136437, 0.22291412523081156, 0.2761305448743445, 0.5011511312336032, 0.22721542636377845, 0.277021351918746, 0.30782994980964573, 0.23341109548685612, 0.7943608096816817, 0.16733427322706196, 0.7541610147982819, 0.7777343364764226, 0.7705149550109041, 0.19736054597479658, 0.8390107641143383, 0.7095547298908531, 0.6187264924150875, 0.7890763168565442, 0.7879146919113671, 0.20443787204931074, 0.7255722416417429, 0.16876048995269088, 0.16487382790227434, 0.20530063181688607, 0.2553825542317131, 0.2060515987920617, 0.18812691555770755, 0.1970278488111299, 0.1872844935809972, 0.19066320147517313, 0.17935417733429826, 0.1975097256713605, 0.19322198580968775, 0.1802682275988, 0.17758997441552404, 0.08722953351037066, 0.09005834190472617, 0.08782969904548588, 0.08472551125995997, 0.07697942823837034, 0.08814855956983136, 0.07831293544202711, 0.08074202817357257, 0.08052738460933129]}, "mutation_prompt": null}
{"id": "5bb3216d-5a37-413a-b704-4e16ce9697f2", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 50)  # Adjusted adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Adaptive strategic mutation\n                F = self.F if np.random.rand() < 0.4 else np.random.uniform(0.4, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Stochastic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3 + int(0.2 * self.dim), self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                perturbation = np.random.normal(0, 0.2, self.dim) * np.random.choice([-1, 1], size=self.dim)\n                neighbor = best_individual + perturbation\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Diversity Control\n            if evals < 0.6 * self.budget and len(population) < 2.7 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid Differential Evolution with adaptive mutation, stochastic local search, and diversity control to enhance exploration and exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.3385386549355135, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.7489712131915485, 0.7753980440274763, 0.75783051518842, 0.7464840897345504, 0.7745203394844378, 0.7699615382268076, 0.7710406793223912, 0.7608340931285583, 0.7744141607023844, 0.6131499511480983, 0.582397004196251, 0.6089126237203031, 0.5596389045895023, 0.570044200211141, 0.582201922660142, 0.5893486775560052, 0.5838598012766174, 0.5939616074140633, 0.11132755789996285, 0.1288497886779323, 0.12286639727804083, 0.12503479905717263, 0.11545174219519139, 0.13005520123762615, 0.12172326864007188, 0.11861557139987344, 0.11644211640126045, 0.09306624803053365, 0.11573575435745265, 0.10816282385718878, 0.10864034650229804, 0.11278337932285598, 0.09572556414070765, 0.09693632559016119, 0.11099215143699004, 0.11108840487329563, 0.9188011455651255, 0.9344200223998647, 0.9370906027976422, 0.9465833911837183, 0.9510862922502484, 0.9087738924946351, 0.9092579651273868, 0.9244695339431478, 0.9474628137149487, 0.4147060830098954, 0.38909880080564485, 0.3703504297356609, 0.39093889094637546, 0.413764384691223, 0.4098421443879201, 0.41542237813497274, 0.4135395907491318, 0.4210328891840238, 0.7267397973177858, 0.6648737352408488, 0.6520104867571476, 0.7403628636356185, 0.637858889841099, 0.6832209628906545, 0.7321132903696874, 0.6522262946969952, 0.7189433487716395, 0.33449062889311, 0.2709139323210016, 0.20201654505638633, 0.3186789014569479, 0.31422474377960374, 0.19155235209929977, 0.24589416717624246, 0.21418026976664828, 0.2277506439060335, 0.1530241341951274, 0.19219978106421687, 0.22153430651502526, 0.24223536888031827, 0.24978997939890246, 0.2640433101703502, 0.24503421359056454, 0.2333136352714259, 0.2522581107416483, 0.25066241566501735, 0.21038212528252176, 0.2024340358182879, 0.21346773835053023, 0.18187396255888633, 0.20375856638676149, 0.19213543278744527, 0.19035267660304256, 0.20505433744076107, 0.3283880666277753, 0.3533873635280682, 0.3278050273985744, 0.31014792004975966, 0.3305771440863221, 0.3044067226686591, 0.37240408760109944, 0.3782012892015949, 0.33725335387674604, 0.09136006024900578, 0.12905994377710672, 0.07990101366065716, 0.1525660441797314, 0.09807776521733447, 0.09299896777392913, 0.10238865206360237, 0.1202446131011331, 0.11244830917030291, 0.25023216552064764, 0.20050328491135672, 0.23624923615856863, 0.2430318766937104, 0.224086419747217, 0.2251152898031159, 0.22038576870292437, 0.22569726952299518, 0.22783984101763544, 0.6157984616630272, 0.6096836839454673, 0.6408634238009034, 0.6031494459039498, 0.613964147373854, 0.5899449714103346, 0.6205664899173247, 0.5977078296588079, 0.5896465164140468, 0.08857371604452235, 0.10666228751329176, 0.10491754413818322, 0.11359601601444391, 0.11081717736090835, 0.12023879320423092, 0.0969773375575449, 0.09494579555338278, 0.09956231933888315, 0.17734056133190135, 0.1528491678274988, 0.1602167333228064, 0.1624966377454724, 0.19728444455968164, 0.24068857604554095, 0.1752871583085509, 0.15297991309902814, 0.16452734322543183, 0.33490907163973527, 0.32114511564069004, 0.37292563062126327, 0.3445571575971368, 0.3478076280979431, 0.34038643115513634, 0.3693392766891791, 0.3874507425219015, 0.38182699449829727, 0.25457282006664483, 0.2561385185706979, 0.262320870374232, 0.25307033951585, 0.24560732147712305, 0.2846035731318136, 0.2774913090003053, 0.29218768467700207, 0.29087443541738833, 0.202619246165039, 0.20138754408427828, 0.18536061706576779, 0.2017178036267152, 0.18291366016557298, 0.20835771323092023, 0.21620219523760498, 0.20005447547032706, 0.2311934155473493, 0.19681673005404687, 0.19447114775627883, 0.21004840582776863, 0.20422782213374246, 0.1943471544725377, 0.19951290495696816, 0.21374927793143872, 0.23550205254012047, 0.2036409077536756, 0.5764127529894261, 0.18449559217720934, 0.6684859860136648, 0.7229381851972834, 0.4605517053766168, 0.48400080137416557, 0.5411666637117334, 0.6265974207988949, 0.18146715884657483, 0.650096808903327, 0.4870320571574712, 0.7267134041208002, 0.20459731278113114, 0.4929117562818687, 0.5345522445175913, 0.2072435864850568, 0.6861033167625246, 0.20576227845625505, 0.18367625140239918, 0.18613474368649263, 0.18417127283842227, 0.19172756618059883, 0.20086147386680064, 0.18281223506134758, 0.18329814177792925, 0.19628121485072414, 0.20870950336352734, 0.08794726402559572, 0.08969892801717994, 0.0838934106386845, 0.08452914645143605, 0.06885356320347835, 0.07729020143270393, 0.08015320848043905, 0.08584267105710042, 0.07724361198690843]}, "mutation_prompt": null}
{"id": "87e923ed-e8c0-400b-af15-5fea8320f8e1", "solution": "import numpy as np\n\nclass AdaptiveGlobalLocalDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 50)  # adaptive population size\n        self.F_base = 0.4  # base differential weight\n        self.CR_base = 0.7  # base crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F = self.F_base if np.random.rand() < 0.7 else np.random.uniform(0.2, 0.8)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Self-Adaptive Crossover\n                CR = self.CR_base if np.random.rand() < 0.5 else np.random.uniform(0.5, 1.0)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Global-Local Balance\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(int(0.2 * self.dim), self.dim // 2)):  # reduced local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.2, self.dim) * (0.5 if np.random.rand() < 0.3 else 1.0)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Diversity Control\n            if evals < 0.6 * self.budget and len(population) < 2.0 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveGlobalLocalDifferentialEvolution", "description": "A novel Adaptive Differential Evolution with global-local balancing and self-adaptive crossover probabilities for robust performance.", "configspace": "", "generation": 73, "fitness": 0.3490434676851656, "feedback": "The algorithm AdaptiveGlobalLocalDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.81933084140933, 0.8121657229938046, 0.8234419484142785, 0.8166297192480497, 0.8156381256247854, 0.8271997351281958, 0.815674735237298, 0.8226216503653996, 0.8191854206803476, 0.6826836022729159, 0.6637662711806316, 0.6548531854219719, 0.653536173633573, 0.6806632828081775, 0.6984551426543943, 0.665928271532185, 0.6551151357196017, 0.6724969358875964, 0.206031913919558, 0.20516201166932457, 0.2861439944517731, 0.12736178718670543, 0.16139607367345543, 0.20639696235496374, 0.14160292635177252, 0.14009620166392978, 0.142164120868015, 0.12595629392284424, 0.12975313850948, 0.13773711532276667, 0.1522098977002625, 0.13154600105643677, 0.12188877516796126, 0.13803077620366644, 0.15126282003063685, 0.1378538957712402, 0.9147851373123226, 0.8960125960228331, 0.8943009180154848, 0.9377406567510961, 0.905953368560678, 0.9433311838353122, 0.9121227893367665, 0.955275996530731, 0.9347376714078843, 0.4374243129900546, 0.4416349968378186, 0.429699735721753, 0.46559559150283525, 0.4281260883473055, 0.4203161433340201, 0.42025810981646206, 0.425996215481942, 0.43054971607168113, 0.6691206621159617, 0.6784594779931711, 0.6954886452844596, 0.7394462485581907, 0.6980330480408881, 0.6611046358320216, 0.7781531824222196, 0.7033202479223128, 0.7855286298924665, 0.24976905061350774, 0.2185543382465147, 0.23589069862985812, 0.16393882457197306, 0.1734659605463763, 0.21771323638199291, 0.1402237596813033, 0.19103880737984924, 0.210557543445828, 0.22361593021391046, 0.1697848125417315, 0.1847269938241296, 0.17513456263343508, 0.23009562358921198, 0.18484899868803384, 0.17444709487400378, 0.22837347609671566, 0.18930465067949775, 0.11937015463960599, 0.15373932776574728, 0.17684662262872264, 0.15364878060905118, 0.13627489186995412, 0.1703249899728686, 0.14395564169118258, 0.13633411314440325, 0.19073034824769763, 0.29800814761506766, 0.22777605740282314, 0.2727137064004598, 0.2906493964516359, 0.25888024409977084, 0.26634466801852585, 0.3373086883700719, 0.35159208535733155, 0.30656764326675356, 0.06864514133131616, 0.048942346142882176, 0.05638870700554466, 0.10121524660671255, 0.1109883093431665, 0.10688117568596722, 0.12143062364342516, 0.08223349010472736, 0.09532950931001449, 0.22535695305914683, 0.21676171369095854, 0.22599008076832816, 0.20109518098158063, 0.23614592287855063, 0.22669347078299684, 0.2175650023709098, 0.21126924189162688, 0.18520903195036043, 0.5849526679109078, 0.589264255081686, 0.6073047529163038, 0.6035595282088594, 0.5981595887193181, 0.5921693569737916, 0.6323794538500609, 0.6121358876309853, 0.6180800173190507, 0.1281173232876145, 0.10135153296027055, 0.09934159378882601, 0.10253912683299204, 0.11443721430483988, 0.11380342372256924, 0.1225100255659376, 0.10175894621959591, 0.10354976610120703, 0.20234432248267953, 0.17254006417659862, 0.1486408148087197, 0.19272487107945024, 0.15863862444758792, 0.16431080866973757, 0.16376215010235906, 0.2114273024155756, 0.17551506062129119, 0.3811166538580546, 0.4110728118960313, 0.41924473061689294, 0.4312577525108905, 0.4129641924279245, 0.4219516420194216, 0.44974017381685494, 0.46748913572793394, 0.4352165925156207, 0.29911181659134667, 0.2826092506907042, 0.280026709725697, 0.28896615660119074, 0.24502399125436491, 0.28159954229424966, 0.3018436620774524, 0.34452658454995977, 0.3022713331232233, 0.18587678241124272, 0.19704415570617628, 0.2068603125891052, 0.21407813161814582, 0.22560586226815593, 0.19972046688522183, 0.21921850644668228, 0.18961464448878795, 0.21971433748189562, 0.20968407051925309, 0.23770558630759764, 0.2318893126589795, 0.25136056306732435, 0.19556084432232712, 0.21217559369984074, 0.4057888313685012, 0.37940817711512687, 0.2675562089549177, 0.6990487313894513, 0.6810044341942953, 0.5844259378937184, 0.7775861823021704, 0.4790610436386985, 0.6596627851045834, 0.5760523513873641, 0.5912659698611192, 0.2601878442735006, 0.5881763475061415, 0.578658405360195, 0.24930785758328833, 0.5521660995148838, 0.1983573392445105, 0.6201187905779575, 0.49865622967148016, 0.33033365765977296, 0.20491809114998416, 0.1781271643739607, 0.18163823804232904, 0.19179002563010883, 0.1880934558459133, 0.18695338918647264, 0.18711280086008197, 0.17474529369835257, 0.18310011510890567, 0.18495050876968944, 0.07623742844457959, 0.08485612604676751, 0.0843021387186833, 0.07762032567742916, 0.08334246380092136, 0.07534538688592185, 0.08314433959706125, 0.09005007809236709, 0.0975904127834345]}, "mutation_prompt": null}
{"id": "7f1c2378-68ed-40d3-a51a-356410bccd3f", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Enhanced strategic mutation\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.7)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3 + int(0.1 * self.dim), self.dim)):  # adaptive local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution with enhanced mutation strategies, adaptive local search intensity, and improved diversity control mechanisms for robust optimization performance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.8345947556041204, 0.8344129807767731, 0.8496897455254219, 0.850880566213741, 0.8398700864604994, 0.8341194144105729, 0.8331192695753851, 0.83468467302919, 0.8556694603902995, 0.6899101586472853, 0.691698210308391, 0.6940338692720854, 0.7078210947456172, 0.6976575165581711, 0.7055912662872857, 0.712267926249102, 0.714117006925792, 0.7453705520959476, 0.12207745589717722, 0.13042729626863725, 0.1683692767867354, 0.12165062330854448, 0.1438693219360473, 0.12379395824200723, 0.14284227235783076, 0.18343669055542888, 0.1388966501011648, 0.12050913458608592, 0.14048991280325485, 0.11818782861074628, 0.1078569328928628, 0.1514644011773134, 0.13484253340477315, 0.12237849260670464, 0.13681409875845296, 0.12526923194958584, 0.9515813983819036, 0.9575708486221908, 0.8959780406814486, 0.9383796386856079, 0.8785420019331741, 0.9456639060462296, 0.9623331092369904, 0.9612054128762256, 0.9301115365300654, 0.5659620057267705, 0.5975174707046442, 0.5470784808957301, 0.5028509412473794, 0.5401741723756995, 0.5292089681338346, 0.5644123902336324, 0.5971607440226782, 0.5523857986399616, 0.8182252349989906, 0.8147875097695667, 0.7612773161076937, 0.7965176795577389, 0.8198220329979958, 0.7754038220455346, 0.8151971989194233, 0.8153393882528859, 0.7994102939170779, 0.3101263990307639, 0.25501149779839216, 0.20595554994131882, 0.47677211664284824, 0.4840308566899385, 0.2765709947993519, 0.5353029341338831, 0.22158559678040068, 0.21369695895437313, 0.19883551151452106, 0.4680690015726112, 0.22455949378496154, 0.2655526554836063, 0.2043074547908097, 0.18771827829647914, 0.2163993236738837, 0.22744354934031497, 0.2508436003113276, 0.39676919739410854, 0.4109050776930292, 0.2811997796134026, 0.3750506935065109, 0.3464002092635504, 0.34936012103614644, 0.4296069155882375, 0.39175010608079186, 0.3382245487833929, 0.5495584421984303, 0.5151131414685374, 0.4787331504365022, 0.5042129952566867, 0.5082796068952418, 0.4945445540011696, 0.6066789181317289, 0.5518764918072907, 0.5033516412363188, 0.1469112426121859, 0.15901511531761225, 0.11868771040498938, 0.2682480763202735, 0.22721109545203144, 0.1080628825499087, 0.18540040167484928, 0.1383819691326158, 0.23448163099672859, 0.308721848927748, 0.3234531677580409, 0.3256119101393413, 0.34407359911282287, 0.36097924011383287, 0.32948483102494797, 0.3052901751326711, 0.34104118677147655, 0.3008385046780653, 0.7243897906305089, 0.7349545691665464, 0.7136487517137047, 0.73226459796416, 0.7470723844665785, 0.7110322275798219, 0.7448839293223198, 0.6828990658151786, 0.7359294140393221, 0.11492515589253671, 0.10908521109335745, 0.1155802540615829, 0.1259213355874741, 0.10514979088223608, 0.13628497269268391, 0.11150169278675526, 0.10813043452587534, 0.1266715402548494, 0.19697147032609874, 0.29454396682760553, 0.16412239265176176, 0.22666354294649937, 0.2917752390369516, 0.16715091832368667, 0.21686945699505544, 0.17205995207483715, 0.22256722662648143, 0.4348835700794995, 0.45649020980153643, 0.4224355352011846, 0.4075582853666667, 0.4421687237309133, 0.42582452928250436, 0.5197862250450395, 0.5220647224829045, 0.5128337745848454, 0.3325786345694479, 0.3282593282903946, 0.35133647331528317, 0.3208405943571796, 0.3395674338937893, 0.350695368573549, 0.36962469329332326, 0.4105996337455271, 0.3578817523566138, 0.19376225806473912, 0.1830453243218364, 0.22551197892944552, 0.20518142569060305, 0.20153202293018857, 0.182095717775688, 0.18484883492789383, 0.22276710046196435, 0.19457681027207385, 0.4210064040796183, 0.3521823951136437, 0.22291412523081156, 0.2761305448743445, 0.5011511312336032, 0.22721542636377845, 0.277021351918746, 0.30782994980964573, 0.23341109548685612, 0.7943608096816817, 0.16733427322706196, 0.7541610147982819, 0.7777343364764226, 0.7705149550109041, 0.19736054597479658, 0.8390107641143383, 0.7095547298908531, 0.6187264924150875, 0.7890763168565442, 0.7879146919113671, 0.20443787204931074, 0.7255722416417429, 0.16876048995269088, 0.16487382790227434, 0.20530063181688607, 0.2553825542317131, 0.2060515987920617, 0.18812691555770755, 0.1970278488111299, 0.1872844935809972, 0.19066320147517313, 0.17935417733429826, 0.1975097256713605, 0.19322198580968775, 0.1802682275988, 0.17758997441552404, 0.08722953351037066, 0.09005834190472617, 0.08782969904548588, 0.08472551125995997, 0.07697942823837034, 0.08814855956983136, 0.07831293544202711, 0.08074202817357257, 0.08052738460933129]}, "mutation_prompt": null}
{"id": "6316b1cf-d429-497a-ba48-fc75be9b0175", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Enhanced strategic mutation\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.7)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3 + int(0.1 * self.dim), self.dim)):  # adaptive local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution with enhanced mutation strategies, adaptive local search intensity, and improved diversity control mechanisms for robust optimization performance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.8345947556041204, 0.8344129807767731, 0.8496897455254219, 0.850880566213741, 0.8398700864604994, 0.8341194144105729, 0.8331192695753851, 0.83468467302919, 0.8556694603902995, 0.6899101586472853, 0.691698210308391, 0.6940338692720854, 0.7078210947456172, 0.6976575165581711, 0.7055912662872857, 0.712267926249102, 0.714117006925792, 0.7453705520959476, 0.12207745589717722, 0.13042729626863725, 0.1683692767867354, 0.12165062330854448, 0.1438693219360473, 0.12379395824200723, 0.14284227235783076, 0.18343669055542888, 0.1388966501011648, 0.12050913458608592, 0.14048991280325485, 0.11818782861074628, 0.1078569328928628, 0.1514644011773134, 0.13484253340477315, 0.12237849260670464, 0.13681409875845296, 0.12526923194958584, 0.9515813983819036, 0.9575708486221908, 0.8959780406814486, 0.9383796386856079, 0.8785420019331741, 0.9456639060462296, 0.9623331092369904, 0.9612054128762256, 0.9301115365300654, 0.5659620057267705, 0.5975174707046442, 0.5470784808957301, 0.5028509412473794, 0.5401741723756995, 0.5292089681338346, 0.5644123902336324, 0.5971607440226782, 0.5523857986399616, 0.8182252349989906, 0.8147875097695667, 0.7612773161076937, 0.7965176795577389, 0.8198220329979958, 0.7754038220455346, 0.8151971989194233, 0.8153393882528859, 0.7994102939170779, 0.3101263990307639, 0.25501149779839216, 0.20595554994131882, 0.47677211664284824, 0.4840308566899385, 0.2765709947993519, 0.5353029341338831, 0.22158559678040068, 0.21369695895437313, 0.19883551151452106, 0.4680690015726112, 0.22455949378496154, 0.2655526554836063, 0.2043074547908097, 0.18771827829647914, 0.2163993236738837, 0.22744354934031497, 0.2508436003113276, 0.39676919739410854, 0.4109050776930292, 0.2811997796134026, 0.3750506935065109, 0.3464002092635504, 0.34936012103614644, 0.4296069155882375, 0.39175010608079186, 0.3382245487833929, 0.5495584421984303, 0.5151131414685374, 0.4787331504365022, 0.5042129952566867, 0.5082796068952418, 0.4945445540011696, 0.6066789181317289, 0.5518764918072907, 0.5033516412363188, 0.1469112426121859, 0.15901511531761225, 0.11868771040498938, 0.2682480763202735, 0.22721109545203144, 0.1080628825499087, 0.18540040167484928, 0.1383819691326158, 0.23448163099672859, 0.308721848927748, 0.3234531677580409, 0.3256119101393413, 0.34407359911282287, 0.36097924011383287, 0.32948483102494797, 0.3052901751326711, 0.34104118677147655, 0.3008385046780653, 0.7243897906305089, 0.7349545691665464, 0.7136487517137047, 0.73226459796416, 0.7470723844665785, 0.7110322275798219, 0.7448839293223198, 0.6828990658151786, 0.7359294140393221, 0.11492515589253671, 0.10908521109335745, 0.1155802540615829, 0.1259213355874741, 0.10514979088223608, 0.13628497269268391, 0.11150169278675526, 0.10813043452587534, 0.1266715402548494, 0.19697147032609874, 0.29454396682760553, 0.16412239265176176, 0.22666354294649937, 0.2917752390369516, 0.16715091832368667, 0.21686945699505544, 0.17205995207483715, 0.22256722662648143, 0.4348835700794995, 0.45649020980153643, 0.4224355352011846, 0.4075582853666667, 0.4421687237309133, 0.42582452928250436, 0.5197862250450395, 0.5220647224829045, 0.5128337745848454, 0.3325786345694479, 0.3282593282903946, 0.35133647331528317, 0.3208405943571796, 0.3395674338937893, 0.350695368573549, 0.36962469329332326, 0.4105996337455271, 0.3578817523566138, 0.19376225806473912, 0.1830453243218364, 0.22551197892944552, 0.20518142569060305, 0.20153202293018857, 0.182095717775688, 0.18484883492789383, 0.22276710046196435, 0.19457681027207385, 0.4210064040796183, 0.3521823951136437, 0.22291412523081156, 0.2761305448743445, 0.5011511312336032, 0.22721542636377845, 0.277021351918746, 0.30782994980964573, 0.23341109548685612, 0.7943608096816817, 0.16733427322706196, 0.7541610147982819, 0.7777343364764226, 0.7705149550109041, 0.19736054597479658, 0.8390107641143383, 0.7095547298908531, 0.6187264924150875, 0.7890763168565442, 0.7879146919113671, 0.20443787204931074, 0.7255722416417429, 0.16876048995269088, 0.16487382790227434, 0.20530063181688607, 0.2553825542317131, 0.2060515987920617, 0.18812691555770755, 0.1970278488111299, 0.1872844935809972, 0.19066320147517313, 0.17935417733429826, 0.1975097256713605, 0.19322198580968775, 0.1802682275988, 0.17758997441552404, 0.08722953351037066, 0.09005834190472617, 0.08782969904548588, 0.08472551125995997, 0.07697942823837034, 0.08814855956983136, 0.07831293544202711, 0.08074202817357257, 0.08052738460933129]}, "mutation_prompt": null}
{"id": "e65baca3-906b-4342-9445-7b5aeeae2443", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Enhanced strategic mutation\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.7)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3 + int(0.1 * self.dim), self.dim)):  # adaptive local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution with enhanced mutation strategies, adaptive local search intensity, and improved diversity control mechanisms for robust optimization performance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.8345947556041204, 0.8344129807767731, 0.8496897455254219, 0.850880566213741, 0.8398700864604994, 0.8341194144105729, 0.8331192695753851, 0.83468467302919, 0.8556694603902995, 0.6899101586472853, 0.691698210308391, 0.6940338692720854, 0.7078210947456172, 0.6976575165581711, 0.7055912662872857, 0.712267926249102, 0.714117006925792, 0.7453705520959476, 0.12207745589717722, 0.13042729626863725, 0.1683692767867354, 0.12165062330854448, 0.1438693219360473, 0.12379395824200723, 0.14284227235783076, 0.18343669055542888, 0.1388966501011648, 0.12050913458608592, 0.14048991280325485, 0.11818782861074628, 0.1078569328928628, 0.1514644011773134, 0.13484253340477315, 0.12237849260670464, 0.13681409875845296, 0.12526923194958584, 0.9515813983819036, 0.9575708486221908, 0.8959780406814486, 0.9383796386856079, 0.8785420019331741, 0.9456639060462296, 0.9623331092369904, 0.9612054128762256, 0.9301115365300654, 0.5659620057267705, 0.5975174707046442, 0.5470784808957301, 0.5028509412473794, 0.5401741723756995, 0.5292089681338346, 0.5644123902336324, 0.5971607440226782, 0.5523857986399616, 0.8182252349989906, 0.8147875097695667, 0.7612773161076937, 0.7965176795577389, 0.8198220329979958, 0.7754038220455346, 0.8151971989194233, 0.8153393882528859, 0.7994102939170779, 0.3101263990307639, 0.25501149779839216, 0.20595554994131882, 0.47677211664284824, 0.4840308566899385, 0.2765709947993519, 0.5353029341338831, 0.22158559678040068, 0.21369695895437313, 0.19883551151452106, 0.4680690015726112, 0.22455949378496154, 0.2655526554836063, 0.2043074547908097, 0.18771827829647914, 0.2163993236738837, 0.22744354934031497, 0.2508436003113276, 0.39676919739410854, 0.4109050776930292, 0.2811997796134026, 0.3750506935065109, 0.3464002092635504, 0.34936012103614644, 0.4296069155882375, 0.39175010608079186, 0.3382245487833929, 0.5495584421984303, 0.5151131414685374, 0.4787331504365022, 0.5042129952566867, 0.5082796068952418, 0.4945445540011696, 0.6066789181317289, 0.5518764918072907, 0.5033516412363188, 0.1469112426121859, 0.15901511531761225, 0.11868771040498938, 0.2682480763202735, 0.22721109545203144, 0.1080628825499087, 0.18540040167484928, 0.1383819691326158, 0.23448163099672859, 0.308721848927748, 0.3234531677580409, 0.3256119101393413, 0.34407359911282287, 0.36097924011383287, 0.32948483102494797, 0.3052901751326711, 0.34104118677147655, 0.3008385046780653, 0.7243897906305089, 0.7349545691665464, 0.7136487517137047, 0.73226459796416, 0.7470723844665785, 0.7110322275798219, 0.7448839293223198, 0.6828990658151786, 0.7359294140393221, 0.11492515589253671, 0.10908521109335745, 0.1155802540615829, 0.1259213355874741, 0.10514979088223608, 0.13628497269268391, 0.11150169278675526, 0.10813043452587534, 0.1266715402548494, 0.19697147032609874, 0.29454396682760553, 0.16412239265176176, 0.22666354294649937, 0.2917752390369516, 0.16715091832368667, 0.21686945699505544, 0.17205995207483715, 0.22256722662648143, 0.4348835700794995, 0.45649020980153643, 0.4224355352011846, 0.4075582853666667, 0.4421687237309133, 0.42582452928250436, 0.5197862250450395, 0.5220647224829045, 0.5128337745848454, 0.3325786345694479, 0.3282593282903946, 0.35133647331528317, 0.3208405943571796, 0.3395674338937893, 0.350695368573549, 0.36962469329332326, 0.4105996337455271, 0.3578817523566138, 0.19376225806473912, 0.1830453243218364, 0.22551197892944552, 0.20518142569060305, 0.20153202293018857, 0.182095717775688, 0.18484883492789383, 0.22276710046196435, 0.19457681027207385, 0.4210064040796183, 0.3521823951136437, 0.22291412523081156, 0.2761305448743445, 0.5011511312336032, 0.22721542636377845, 0.277021351918746, 0.30782994980964573, 0.23341109548685612, 0.7943608096816817, 0.16733427322706196, 0.7541610147982819, 0.7777343364764226, 0.7705149550109041, 0.19736054597479658, 0.8390107641143383, 0.7095547298908531, 0.6187264924150875, 0.7890763168565442, 0.7879146919113671, 0.20443787204931074, 0.7255722416417429, 0.16876048995269088, 0.16487382790227434, 0.20530063181688607, 0.2553825542317131, 0.2060515987920617, 0.18812691555770755, 0.1970278488111299, 0.1872844935809972, 0.19066320147517313, 0.17935417733429826, 0.1975097256713605, 0.19322198580968775, 0.1802682275988, 0.17758997441552404, 0.08722953351037066, 0.09005834190472617, 0.08782969904548588, 0.08472551125995997, 0.07697942823837034, 0.08814855956983136, 0.07831293544202711, 0.08074202817357257, 0.08052738460933129]}, "mutation_prompt": null}
{"id": "7391b6dd-179f-456c-a03a-8ad0a98a0d66", "solution": "import numpy as np\n\nclass RefinedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 40)  # adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                # Enhanced strategic mutation\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.3, 0.7)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(min(3 + int(0.1 * self.dim), self.dim)):  # adaptive local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "RefinedHybridDifferentialEvolution", "description": "A refined hybrid Differential Evolution with enhanced mutation strategies, adaptive local search intensity, and improved diversity control mechanisms for robust optimization performance.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.8345947556041204, 0.8344129807767731, 0.8496897455254219, 0.850880566213741, 0.8398700864604994, 0.8341194144105729, 0.8331192695753851, 0.83468467302919, 0.8556694603902995, 0.6899101586472853, 0.691698210308391, 0.6940338692720854, 0.7078210947456172, 0.6976575165581711, 0.7055912662872857, 0.712267926249102, 0.714117006925792, 0.7453705520959476, 0.12207745589717722, 0.13042729626863725, 0.1683692767867354, 0.12165062330854448, 0.1438693219360473, 0.12379395824200723, 0.14284227235783076, 0.18343669055542888, 0.1388966501011648, 0.12050913458608592, 0.14048991280325485, 0.11818782861074628, 0.1078569328928628, 0.1514644011773134, 0.13484253340477315, 0.12237849260670464, 0.13681409875845296, 0.12526923194958584, 0.9515813983819036, 0.9575708486221908, 0.8959780406814486, 0.9383796386856079, 0.8785420019331741, 0.9456639060462296, 0.9623331092369904, 0.9612054128762256, 0.9301115365300654, 0.5659620057267705, 0.5975174707046442, 0.5470784808957301, 0.5028509412473794, 0.5401741723756995, 0.5292089681338346, 0.5644123902336324, 0.5971607440226782, 0.5523857986399616, 0.8182252349989906, 0.8147875097695667, 0.7612773161076937, 0.7965176795577389, 0.8198220329979958, 0.7754038220455346, 0.8151971989194233, 0.8153393882528859, 0.7994102939170779, 0.3101263990307639, 0.25501149779839216, 0.20595554994131882, 0.47677211664284824, 0.4840308566899385, 0.2765709947993519, 0.5353029341338831, 0.22158559678040068, 0.21369695895437313, 0.19883551151452106, 0.4680690015726112, 0.22455949378496154, 0.2655526554836063, 0.2043074547908097, 0.18771827829647914, 0.2163993236738837, 0.22744354934031497, 0.2508436003113276, 0.39676919739410854, 0.4109050776930292, 0.2811997796134026, 0.3750506935065109, 0.3464002092635504, 0.34936012103614644, 0.4296069155882375, 0.39175010608079186, 0.3382245487833929, 0.5495584421984303, 0.5151131414685374, 0.4787331504365022, 0.5042129952566867, 0.5082796068952418, 0.4945445540011696, 0.6066789181317289, 0.5518764918072907, 0.5033516412363188, 0.1469112426121859, 0.15901511531761225, 0.11868771040498938, 0.2682480763202735, 0.22721109545203144, 0.1080628825499087, 0.18540040167484928, 0.1383819691326158, 0.23448163099672859, 0.308721848927748, 0.3234531677580409, 0.3256119101393413, 0.34407359911282287, 0.36097924011383287, 0.32948483102494797, 0.3052901751326711, 0.34104118677147655, 0.3008385046780653, 0.7243897906305089, 0.7349545691665464, 0.7136487517137047, 0.73226459796416, 0.7470723844665785, 0.7110322275798219, 0.7448839293223198, 0.6828990658151786, 0.7359294140393221, 0.11492515589253671, 0.10908521109335745, 0.1155802540615829, 0.1259213355874741, 0.10514979088223608, 0.13628497269268391, 0.11150169278675526, 0.10813043452587534, 0.1266715402548494, 0.19697147032609874, 0.29454396682760553, 0.16412239265176176, 0.22666354294649937, 0.2917752390369516, 0.16715091832368667, 0.21686945699505544, 0.17205995207483715, 0.22256722662648143, 0.4348835700794995, 0.45649020980153643, 0.4224355352011846, 0.4075582853666667, 0.4421687237309133, 0.42582452928250436, 0.5197862250450395, 0.5220647224829045, 0.5128337745848454, 0.3325786345694479, 0.3282593282903946, 0.35133647331528317, 0.3208405943571796, 0.3395674338937893, 0.350695368573549, 0.36962469329332326, 0.4105996337455271, 0.3578817523566138, 0.19376225806473912, 0.1830453243218364, 0.22551197892944552, 0.20518142569060305, 0.20153202293018857, 0.182095717775688, 0.18484883492789383, 0.22276710046196435, 0.19457681027207385, 0.4210064040796183, 0.3521823951136437, 0.22291412523081156, 0.2761305448743445, 0.5011511312336032, 0.22721542636377845, 0.277021351918746, 0.30782994980964573, 0.23341109548685612, 0.7943608096816817, 0.16733427322706196, 0.7541610147982819, 0.7777343364764226, 0.7705149550109041, 0.19736054597479658, 0.8390107641143383, 0.7095547298908531, 0.6187264924150875, 0.7890763168565442, 0.7879146919113671, 0.20443787204931074, 0.7255722416417429, 0.16876048995269088, 0.16487382790227434, 0.20530063181688607, 0.2553825542317131, 0.2060515987920617, 0.18812691555770755, 0.1970278488111299, 0.1872844935809972, 0.19066320147517313, 0.17935417733429826, 0.1975097256713605, 0.19322198580968775, 0.1802682275988, 0.17758997441552404, 0.08722953351037066, 0.09005834190472617, 0.08782969904548588, 0.08472551125995997, 0.07697942823837034, 0.08814855956983136, 0.07831293544202711, 0.08074202817357257, 0.08052738460933129]}, "mutation_prompt": null}
{"id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Enhanced strategic mutation with feedback adjustment\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.15 * self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control with feedback\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveDualPhaseDifferentialEvolution", "description": "Adaptive Dual-Phase Differential Evolution that integrates strategic mutation, dynamic local search, and diversity rebalance with feedback mechanisms for enhanced convergence.", "configspace": "", "generation": 78, "fitness": 0.41979263561426516, "feedback": "The algorithm AdaptiveDualPhaseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "6903bde5-ded7-4b01-bac1-3c015396e74f", "metadata": {"aucs": [0.8598955202290018, 0.8616594449857364, 0.8572506210644175, 0.8473590683431149, 0.842086265004254, 0.8555103373146736, 0.8595970147140798, 0.8514555741315436, 0.8499840669579848, 0.7370865980733468, 0.7316018770249493, 0.7484547807804844, 0.7315492060187176, 0.7206538392397789, 0.7343984634693022, 0.7403969283695472, 0.7517573371478008, 0.7294526087554171, 0.19152050494654616, 0.12454085038993035, 0.1495493877634272, 0.12459219386584341, 0.13634490652504794, 0.1481049282400514, 0.13432484647810072, 0.1293019361022758, 0.14757454418045435, 0.122342518112321, 0.1209434968260672, 0.11841387873797848, 0.10211403908798145, 0.11643353087603625, 0.10433676591488406, 0.11870839193793414, 0.11597305019876891, 0.11595082037058069, 0.8383354516284651, 0.8225143937568133, 0.7299913083747736, 0.8459750459642306, 0.7456848200775029, 0.760717323520778, 0.8235068776225777, 0.8363681866734549, 0.8556543530987102, 0.4837586049490187, 0.5628672193707285, 0.4310711096781682, 0.4004504658734457, 0.5172600926123634, 0.5733852933543091, 0.5138517582171027, 0.4048640883768009, 0.479107678413341, 0.8521816006333705, 0.8423473770827983, 0.7959856656808892, 0.8396140388101023, 0.8458444998276514, 0.8515098524342405, 0.784767362676888, 0.8409310389223834, 0.8161617334621245, 0.17202941018574747, 0.16614780778444183, 0.15367523871893407, 0.19773148777871752, 0.22465513090036748, 0.20851487654439071, 0.15766071387111735, 0.25316139843055485, 0.21124224180572615, 0.14602589905943164, 0.16600484892615008, 0.15688760321747863, 0.17040376605842067, 0.17206024959979005, 0.17388582860362645, 0.1613783287740882, 0.19566921383186064, 0.16480844301752573, 0.5748410768700215, 0.5742675245091251, 0.5658440583064221, 0.5950379521168994, 0.6071472679947699, 0.594836751803888, 0.6034234036919384, 0.5645657887561399, 0.5761118532278752, 0.6732547888556879, 0.6805298853510346, 0.6587314094601813, 0.5797826319747563, 0.6352062845089304, 0.6392730638691542, 0.711841349776916, 0.6872829920973851, 0.6720702144670696, 0.13442857957866872, 0.12435599186599033, 0.2768883086813855, 0.43732930592028496, 0.3662450959644187, 0.1935098327782523, 0.21899744519109565, 0.17707544999008695, 0.2567047423949419, 0.44590076386688826, 0.4596615069203517, 0.42716411632060847, 0.45372876551000163, 0.5108313166968093, 0.4790675340234807, 0.4612481636794893, 0.45077553340056264, 0.4487736759020333, 0.7944192339105325, 0.8160584979312793, 0.8107822479975004, 0.7822641998982919, 0.7907039259888127, 0.784350547929036, 0.7962542906102453, 0.8013926127081629, 0.799967705779381, 0.14193616628616423, 0.12910624813267113, 0.12943422827120488, 0.15396515167484615, 0.140337582776222, 0.14551474276785303, 0.12636743645334558, 0.12286963860517774, 0.1481207171105574, 0.17427088557880543, 0.15701705763678087, 0.18620137019013172, 0.21715366538227965, 0.1787255081042236, 0.19022900590837566, 0.27398799414483765, 0.2572352065724888, 0.1971096705586547, 0.506988849910473, 0.49184501078474074, 0.5279976516505778, 0.511963231864804, 0.5096186477930558, 0.5072540236398608, 0.5160498656812706, 0.5223443365390561, 0.5376602584103969, 0.38929562801546547, 0.3610330108042984, 0.40340573874649344, 0.33761397540147686, 0.36733159370307267, 0.3579525548364221, 0.40291499007092857, 0.4058296837766999, 0.41877807350635987, 0.2036507931254916, 0.21512696816114174, 0.21673942925490175, 0.21131334084222486, 0.19177277822023076, 0.20912141917648963, 0.23315703056552806, 0.2173035188572564, 0.22493763090884566, 0.1935782984235459, 0.21915321386321307, 0.20866839773959367, 0.23578610183530357, 0.20042515603199196, 0.22510307800785478, 0.212964523748696, 0.19778517157237052, 0.2157840052954344, 0.1872141949519388, 0.18141538502223598, 0.19254990066933464, 0.7399266906016644, 0.19436865778836243, 0.8258570173187958, 0.8430784038022697, 0.7395738030440672, 0.6300267041952123, 0.8387552047435335, 0.4072823229490268, 0.784797697487442, 0.6988408481837437, 0.25170877850420026, 0.7516770366146411, 0.20648323726970674, 0.7014140421680128, 0.3509785935151283, 0.19017688368783037, 0.18063680411697136, 0.21269254198518572, 0.19406618463572334, 0.18337401652007412, 0.18558169206006958, 0.1867416593884691, 0.1896274229175614, 0.2048722809147152, 0.09159955764735206, 0.08377830775801265, 0.08535744849343607, 0.07821382471645089, 0.08995650215590589, 0.08091602150690891, 0.09818733668380286, 0.08339222136814184, 0.08146225091858705]}, "mutation_prompt": null}
{"id": "774d2db1-09b0-430b-8ded-e582cae59beb", "solution": "import numpy as np\n\nclass AdaptiveHybridEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 60)  # slightly increased population size\n        self.F = 0.5  # adjusted differential weight for more exploration\n        self.CR = 0.8  # slightly lower crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Hybrid Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with adaptive feedback\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                F = self.F + np.random.uniform(-0.1, 0.1)  # more variable F\n                mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n                # Crossover with strategic points selection\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Niche Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(2 + int(0.2 * self.dim)):  # variable local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.07, self.dim)  # adjusted step size\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Population Diversity\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveHybridEvolutionaryStrategy", "description": "Adaptive Hybrid Evolutionary Strategy blending strategic crossover, mutation, and niche local search for robust optimization.", "configspace": "", "generation": 79, "fitness": 0.2567477028196589, "feedback": "The algorithm AdaptiveHybridEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.6469126625285716, 0.6503668768444076, 0.6483297750863594, 0.6724048064880346, 0.6786649020141923, 0.6619173386868671, 0.6633403441973489, 0.6613996117209815, 0.6630302307858498, 0.4203594070569876, 0.38803494070731126, 0.4068713411201502, 0.38435976121205717, 0.39923785980040816, 0.3552542186951603, 0.4013236461811329, 0.3647530983370074, 0.3862653305664435, 0.10729832679067497, 0.1198813987424765, 0.1245978350445286, 0.11779270539911135, 0.11257761110364861, 0.10118585809379621, 0.10698008974639217, 0.10319813023143665, 0.13102187163868728, 0.09262776860819633, 0.09789017958890145, 0.09561875876380421, 0.11182353584198224, 0.10064602539752154, 0.1053210510450916, 0.11876724976761466, 0.09045482542903849, 0.11075171844164511, 0.9006894802355683, 0.8890686910924264, 0.9295267482428865, 0.9195391936467411, 0.9660660703175553, 0.9274839865597788, 0.9407161281279948, 0.913224094840342, 0.89091324862792, 0.2628882378627059, 0.2814516673287343, 0.2894712744804998, 0.2808051159737982, 0.2995112698944872, 0.2873223419136971, 0.28423713157882224, 0.31053980264620795, 0.289225130514403, 0.3417996249859666, 0.3770077311653477, 0.38707090795031185, 0.5043934014411859, 0.40103062914647547, 0.46935600132932975, 0.5151506208449379, 0.45392005288317827, 0.411290150362692, 0.1493493335201994, 0.17043145140081417, 0.1782280242039458, 0.19154248667652418, 0.17776554711104187, 0.15769903258065554, 0.15969551090415446, 0.1691313235640668, 0.1657910407973765, 0.16807642188168304, 0.14787400720869193, 0.14193223126019838, 0.17351722147997184, 0.14857768036230756, 0.1806978907842286, 0.16912652658008098, 0.1391218352122212, 0.14480534926856203, 0.027491836247102053, 0.03521254258373396, 0.04364117526493194, 0.03234117935624814, 0.044883736334843216, 0.03666164213258305, 0.05429899699786289, 0.04021195697566704, 0.06661538425906388, 0.15797876100827501, 0.1396894342750996, 0.1577554583655223, 0.12953456827046306, 0.14543766139397007, 0.1599182437522486, 0.18318778586189133, 0.1645611915538271, 0.1670771830861728, 0.00029264900371306357, 0.0002047732671029978, 0.0051846651012772416, 0.005859437509846632, 0.005820248244666648, 0.011259544787336373, 0.011350356874617273, 0.028260926935481212, 0.011657208827782428, 0.13865069387784457, 0.11633591427685075, 0.12396793142241547, 0.12073651137208619, 0.12235404732238386, 0.1224213266070383, 0.12603255694089543, 0.12141607688538425, 0.1342145425822655, 0.45109660736173307, 0.44990151587215266, 0.48780461865855684, 0.446813624741362, 0.4710493076794735, 0.4598340166581213, 0.48385324835006593, 0.45745866510343736, 0.4567585348305825, 0.09807209759804936, 0.1111030720809405, 0.10027172391500949, 0.12359960403671322, 0.09928698422834237, 0.10119907459236932, 0.10327596118805249, 0.09194116647951045, 0.09075055599777515, 0.14223251466158093, 0.2178185981474996, 0.25696189954690485, 0.2545045799251706, 0.1670795528754787, 0.20358752100198751, 0.20229434977627248, 0.2227284975402929, 0.16887117703250965, 0.28832197274208116, 0.2805649321838055, 0.29472229043623643, 0.26999283975469957, 0.2768130783204191, 0.29031598918360246, 0.29808777306220335, 0.29502976392580404, 0.29217877052532304, 0.1913498139296962, 0.203173250788656, 0.2059059141519306, 0.20589505669186536, 0.18658867687639058, 0.203470549299555, 0.20572270504081214, 0.2178878741571989, 0.18727486749339783, 0.19560407293020166, 0.19583903348447262, 0.20446910603275048, 0.19082319633925482, 0.18473175010920007, 0.1904533332197892, 0.18610740878903786, 0.1854159004231718, 0.18246700824353979, 0.22499334632616907, 0.1862462532854524, 0.18313873487800558, 0.2037186668588623, 0.20235827423701958, 0.19927959475128165, 0.20808822053154907, 0.2024172608796847, 0.2659458615421283, 0.6550759858442347, 0.2616938876224625, 0.318075749033643, 0.569277501211375, 0.23252039707504635, 0.520419712350355, 0.56944451201879, 0.2625367733288759, 0.16962819953259622, 0.4339855239093676, 0.348346715601216, 0.20482136480887614, 0.32997990823762335, 0.2201052217912708, 0.2726549388981604, 0.20381171786049757, 0.37085792698794284, 0.20929664463251973, 0.20003885797556065, 0.17944026986766748, 0.186003488881604, 0.18919078015207136, 0.18070429722292125, 0.18179392528682292, 0.19091295868057723, 0.18718099505819652, 0.17905503862212557, 0.08377471829843819, 0.0711204322288077, 0.08370384544610532, 0.06623963831645707, 0.08210187499276544, 0.07104435128530573, 0.07506451904843348, 0.07220935770144077, 0.06900867787795628]}, "mutation_prompt": null}
{"id": "a6076f78-04e4-4f88-a197-6bba771b9f85", "solution": "import numpy as np\n\nclass QuantumInspiredDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)\n        self.F = 0.6\n        self.CR = 0.9\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.1 * self.dim)):\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            if evals < 0.5 * self.budget and len(population) < 2.0 * self.population_size:\n                tunneling_probability = np.exp(-abs(fitness - np.min(fitness)) / np.std(fitness))\n                if np.random.rand() < np.mean(tunneling_probability):\n                    new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                    new_fitness = np.array([func(ind) for ind in new_individuals])\n                    evals += len(new_individuals)\n                    population = np.vstack((population, new_individuals))\n                    fitness = np.hstack((fitness, new_fitness))\n\n        return population[np.argmin(fitness)]", "name": "QuantumInspiredDualPhaseDifferentialEvolution", "description": "Quantum-Inspired Dual-Phase Differential Evolution with stochastic tunneling for enhanced exploration and convergence stability.", "configspace": "", "generation": 80, "fitness": 0.3477742595871477, "feedback": "The algorithm QuantumInspiredDualPhaseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.756291121851608, 0.7444807438885004, 0.7558577671452265, 0.7776176091004443, 0.7596901188666838, 0.775284390412474, 0.755284514243974, 0.7708877154730052, 0.7593763427545527, 0.5441901700194032, 0.570485395413511, 0.542044641708418, 0.5287755763981641, 0.5621302537280444, 0.5695001111712449, 0.5812555372391274, 0.5625653680791038, 0.5530630389365829, 0.14356178580707113, 0.14362240372448054, 0.13627885088537384, 0.13446865682999054, 0.10872511972599419, 0.15698387794930402, 0.12524245026237912, 0.13142451870788008, 0.1171177666486306, 0.1222826656425281, 0.1096689227663955, 0.11608183992105603, 0.09619358251889987, 0.1024201503617167, 0.13590582996032008, 0.10788206334367734, 0.13656664389959317, 0.09868518343456267, 0.8710614094359372, 0.9345183157756348, 0.9062565382238029, 0.9169056887133403, 0.9731797243206675, 0.9220355661986251, 0.9264064468812588, 0.8918266663481327, 0.9416855204531687, 0.4084522479706726, 0.3820675206287888, 0.3938880483142231, 0.39539858384201887, 0.415791139368652, 0.38584474034921945, 0.40342560020034346, 0.43378446474982835, 0.4319231374359983, 0.7159649142792943, 0.7490296222647936, 0.662883196024598, 0.6970834595244972, 0.7075382026007022, 0.7123705893695793, 0.7309263359257279, 0.6868711385453339, 0.7258265439314499, 0.27950573358353425, 0.28732955466254373, 0.2584621070557459, 0.2688450893474832, 0.43933164318379847, 0.3345972941314934, 0.36099831064597987, 0.30850910232666573, 0.33746779215041456, 0.2124356053630314, 0.18785651756350286, 0.30802999227614036, 0.39281849951991865, 0.2931827416916837, 0.3184971492825792, 0.33417433425732757, 0.3063145989715186, 0.29374553682912796, 0.2945973307197859, 0.2826871298147995, 0.27476642018901787, 0.26957391684199683, 0.25671834660798176, 0.2639750098128766, 0.3105464080908934, 0.2803754709787314, 0.2572122918802501, 0.4176515143569812, 0.4223149631712906, 0.40303843259504557, 0.42135925178336986, 0.4097023061291809, 0.3932623532230767, 0.42400042900520274, 0.42737733446862625, 0.4248179248885249, 0.07475963423081122, 0.1269027651156195, 0.10477325600869702, 0.10987635603320556, 0.14973151519956573, 0.11871883358060642, 0.13526493613110746, 0.10332204217204721, 0.12878597186795238, 0.22592775444912983, 0.25410714372911014, 0.2526033935149069, 0.27412201295050387, 0.24751263014517166, 0.2751776787682191, 0.2598184527103693, 0.23873586093183408, 0.26129275430728216, 0.6417969924997604, 0.6208518583512104, 0.5978272901098136, 0.6207931238866233, 0.6406698015445408, 0.6331115118523908, 0.6206697727758828, 0.6064167385219355, 0.6176920331933193, 0.11456365179456007, 0.12983958626470304, 0.09655591919437234, 0.11769474321100892, 0.09932151846013781, 0.11743767059531152, 0.1164263816426393, 0.11494215370955063, 0.09577805927376415, 0.23365897678309588, 0.26706909090115727, 0.20905992246325333, 0.2070536076346312, 0.16312648430073495, 0.2543927486905263, 0.16561997078522417, 0.24335971713781968, 0.1734119972016992, 0.3574091715880017, 0.3530428114525964, 0.32283778626062054, 0.3534538285501271, 0.346688584928426, 0.32945952810124046, 0.3742348643496072, 0.38422883429744603, 0.3829663481217357, 0.2583423773280862, 0.27476430113033434, 0.27194117491289593, 0.24819922910488912, 0.27912318743075526, 0.2527162834082666, 0.24600947793976025, 0.2745523188421467, 0.2848820670520894, 0.1971476764325103, 0.20094643092008035, 0.20447814735523717, 0.1871274172437689, 0.21401679597080359, 0.20054615576324375, 0.2027091142774129, 0.18872903554722564, 0.19241068942927364, 0.19061385831564504, 0.21725452255860978, 0.19668198349793087, 0.21592671081967485, 0.27304338302131903, 0.2495338547809639, 0.21934787794322652, 0.2174069746279944, 0.2019260438569297, 0.1841659471165087, 0.20516197552719406, 0.6933659007023436, 0.1819608965425048, 0.542591564273115, 0.18360540253863034, 0.7240821774304453, 0.6305169572895372, 0.18329768589217665, 0.685052255818001, 0.2046184243808261, 0.6654395598115286, 0.20236644299061368, 0.20259568824131047, 0.6596563212018256, 0.7165895919380083, 0.2090863216800518, 0.20730771244362178, 0.1933586688277792, 0.1815631727688206, 0.1828723877018784, 0.18413186925899183, 0.19685222901708865, 0.18363717269452196, 0.18682107911134027, 0.20149420230081494, 0.19089203143674327, 0.076926971158925, 0.08110428368062217, 0.07738865333464096, 0.07971673946616176, 0.08345091185653108, 0.09557058782110894, 0.08814057029387656, 0.0820945804644373, 0.07557344412838063]}, "mutation_prompt": null}
{"id": "9de82c2c-ccaf-4c82-9392-85410d0ccaf0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDualPhaseEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 60)  # adjusted adaptive population size\n        self.F = 0.5  # refined differential weight\n        self.CR = 0.85  # refined crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                # Feedback-driven mutation strategy\n                F = np.random.uniform(0.3, 0.7) if np.random.rand() < 0.8 else np.random.uniform(0.6, 0.9)\n                mutant = np.clip(a + F * (b - c) + F * (d - e), self.lower_bound, self.upper_bound)\n\n                # Dynamic Crossover\n                cross_points = np.random.rand(self.dim) < (self.CR + 0.05 * np.sin(0.1 * evals))\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.2 * self.dim)):  # enhanced local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.04, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Incremental Diversity Boosting with feedback\n            if evals < 0.6 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveDualPhaseEvolutionaryAlgorithm", "description": "Enhanced Adaptive Dual-Phase Evolutionary Algorithm with Feedback-Driven Mutation, Dynamic Crossover, and Incremental Diversity Boosting for Robust Convergence.", "configspace": "", "generation": 81, "fitness": 0.2535848265108542, "feedback": "The algorithm EnhancedAdaptiveDualPhaseEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.5879437113781827, 0.6176542639928015, 0.667516898984855, 0.6256051849064501, 0.6266197620818665, 0.6175254684303577, 0.6528562648893471, 0.6378320836711158, 0.6055215239739611, 0.32568657794572964, 0.3104861669170258, 0.36107150272965494, 0.3251691630818999, 0.3154533269187684, 0.3370471090186775, 0.3187110106549834, 0.3408728408709929, 0.33629250214961526, 0.14848195408358278, 0.1031802035222712, 0.0998837236056328, 0.11234318526564979, 0.11539738435104463, 0.10792447304839459, 0.10969174322810105, 0.12265130495964771, 0.09996831944174478, 0.10814183843458469, 0.10438936974889401, 0.10116592813532077, 0.10831968493341826, 0.11302548593172668, 0.10176675645093403, 0.10535235930964537, 0.103792750179177, 0.10270278489858375, 0.9307653167068557, 0.874236116775319, 0.8575017465026052, 0.942921027816076, 0.9098772037608824, 0.9236102906223138, 0.900746461009441, 0.9156570578832612, 0.9177455645044875, 0.31200838042617596, 0.2781953081061249, 0.2715023766758743, 0.26671182145441585, 0.2718240467278591, 0.27054463803718987, 0.2747850142302929, 0.2931045496564417, 0.2715531135866226, 0.37476241361049356, 0.38606362795325466, 0.4367927314324145, 0.5697908960541499, 0.5184669475048165, 0.46604562198303134, 0.5720125737552046, 0.6803467114410551, 0.38395971241816873, 0.15102630620570945, 0.16695195377381788, 0.1546433559642073, 0.16921903353548184, 0.16862196821041175, 0.16708641239247113, 0.1673434589338565, 0.16188869173661058, 0.14180561876047282, 0.17605232394459558, 0.19115950448127073, 0.18496170305765136, 0.14177147934189893, 0.19649169775329633, 0.15096964733647966, 0.15519395805790226, 0.1966575891232959, 0.13238383156424827, 0.06229505196501728, 0.08748747736486961, 0.08270352749140097, 0.07956516185236873, 0.0644538079605913, 0.04648792171462324, 0.0771210353390046, 0.08199157309829608, 0.08122902221722794, 0.1997383422934187, 0.16424417365497446, 0.21282460645241064, 0.1439855165259103, 0.1709765705932117, 0.17312422753136159, 0.18949323273679397, 0.22369375435235084, 0.18581439930495702, 0.006148507022544769, 0.004750623373390606, 0.009263966070689689, 0.007328859412891187, 0.009528579753667277, 0.0337159625395238, 0.02615794061461152, 0.017055228870209604, 0.015083620156767563, 0.1437748555112086, 0.13065288203333625, 0.1391817301257201, 0.1445475775628856, 0.13432986940156788, 0.13013858200886153, 0.1376900501795144, 0.1260357947713967, 0.14664679643829603, 0.4879057317118559, 0.46896743703991794, 0.48310874863408604, 0.4455645600718514, 0.45429447421835734, 0.45464978640967557, 0.484848955717182, 0.45282613206758593, 0.4529394570549057, 0.1034260713726246, 0.11227068769301207, 0.1097581698335316, 0.12233313262110856, 0.08563096104876278, 0.10976267361576486, 0.10972680600200624, 0.11102880001022075, 0.116832522789309, 0.1395320750974175, 0.254581004078859, 0.19437437905402288, 0.18709864307755153, 0.14642218394468365, 0.16235124654949507, 0.16793513837065643, 0.14447759027522533, 0.18999196630568005, 0.2708392657079176, 0.27222351182031157, 0.26994664096405707, 0.2773007865603999, 0.260375396522462, 0.2516099933729281, 0.2622850716641737, 0.3143795767461969, 0.29024889567590817, 0.20868530587018952, 0.2225665648025511, 0.19345687697493286, 0.19418420864125296, 0.20717647445305054, 0.19264467363056015, 0.22575602298738362, 0.2080838865103195, 0.2184208674504391, 0.20332151747086658, 0.18090280123861735, 0.2022385364570215, 0.22228737440033175, 0.1893496182424267, 0.1906421253752515, 0.18426057310235455, 0.20371852504438348, 0.1786756592062385, 0.19021988881835883, 0.17324508341209877, 0.21636933800877356, 0.20552835997634578, 0.20939540721605165, 0.18809089050066508, 0.29814921488513824, 0.2014273120590373, 0.1883795945531972, 0.18029232682678853, 0.5889848243721065, 0.19888981241019876, 0.4709804191046465, 0.19571464546221473, 0.6029287794311644, 0.5361971814853523, 0.31027391366042933, 0.17794844109276942, 0.39140605472105294, 0.28641670512248485, 0.16383790090722783, 0.23485613377336367, 0.19376526370654834, 0.2212176939106295, 0.20334733495058877, 0.19835872696088852, 0.20587946224043485, 0.18021901652657546, 0.1989091552733251, 0.19136683745266914, 0.18750119113705777, 0.1932884862021501, 0.19126857782511864, 0.1760179889314597, 0.17766753837699667, 0.20126363945039494, 0.07441781925735269, 0.07440289069752526, 0.07368591173523276, 0.07708805273376895, 0.07924669209411772, 0.07972126059892304, 0.07977298714037917, 0.0705056606562432, 0.07459277989975821]}, "mutation_prompt": null}
{"id": "88812628-48ea-49b0-afba-024092dccbbc", "solution": "import numpy as np\n\nclass QuantumInfusedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 60)  # adaptive population size\n        self.F = 0.5  # differential weight\n        self.CR = 0.8  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                # Quantum-inspired mutation with stochastic tunneling\n                F = self.F if np.random.rand() < 0.8 else np.random.uniform(0.3, 0.9)\n                mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Stochastic tunneling local search\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(4 + int(0.2 * self.dim)):  # moderate local search intensity\n                if evals >= self.budget:\n                    break\n\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                neighbor = best_individual + perturbation\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.6 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "QuantumInfusedDifferentialEvolution", "description": "Quantum-Infused Differential Evolution with stochastic tunneling and adaptive population dynamics for enhanced global exploration and convergence.", "configspace": "", "generation": 82, "fitness": 0.24939297528366622, "feedback": "The algorithm QuantumInfusedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.6404525368680954, 0.6043607824996595, 0.6329886768892461, 0.6627385706059203, 0.6472855471354177, 0.636482947419301, 0.6464960470566959, 0.6386653857967911, 0.6570705693129637, 0.3539770119370288, 0.32091763141623597, 0.37352438469195326, 0.33676911986978075, 0.34860886308218997, 0.339550688700164, 0.3524717307691684, 0.36605751412092236, 0.3594613935483765, 0.12594659287800059, 0.1129600217578618, 0.12327635903441936, 0.12025376506040952, 0.11043216980810844, 0.11123288263360753, 0.10845071134504758, 0.10096189744475081, 0.11975503969939416, 0.0947068153880638, 0.09468204518785728, 0.09761064812466991, 0.09422035596667211, 0.10947597476242532, 0.09384627481780516, 0.09746029534984357, 0.11297216762046358, 0.0944717078971804, 0.9037390206758251, 0.9240859503284143, 0.9147002457633427, 0.9218227100369982, 0.9585601156755194, 0.9075380546167424, 0.9161233092812352, 0.9535056597252187, 0.9451138930829848, 0.28966230400461346, 0.2697095231043303, 0.2570096435814765, 0.2642007643488199, 0.2540152800923715, 0.2659534589630078, 0.28947947591966816, 0.299682454642182, 0.2511082899752849, 0.3232841637493914, 0.3133622345593353, 0.2898422300647068, 0.5093111069961406, 0.35560001112882045, 0.3852076873663207, 0.3487110489712796, 0.4351147393943162, 0.35716137428459893, 0.19786330363721527, 0.1497521293675409, 0.15492864171859233, 0.16617066761882193, 0.20185625549163155, 0.16934719043315127, 0.17612450638735822, 0.16578745484233748, 0.184396859643168, 0.1514402950047119, 0.1326104730387706, 0.16148991656464462, 0.18038770620875944, 0.1859724799316962, 0.17152876787530436, 0.19521144148552605, 0.16990992168137886, 0.14713073192592963, 0.025994039591191398, 0.060330079174411355, 0.028573977743296175, 0.035894045228239024, 0.0362376151428645, 0.02750676005267383, 0.04211389037498503, 0.030254621131981185, 0.027337667619031336, 0.1435275884568209, 0.13311256945514993, 0.16670938340037578, 0.13773314733355324, 0.154067971770949, 0.13096903541908234, 0.15686371864608395, 0.1755891135648977, 0.14087433382272396, 0.007809497559034928, 9.999999999998899e-05, 0.00012212277667589255, 0.008551551929463996, 0.00023620292013915023, 9.999999999998899e-05, 0.0043533393212613625, 0.009678485856958075, 0.002110901308411517, 0.13703759807188232, 0.11064795940108108, 0.11531830597388493, 0.1336014592143352, 0.1302268312723145, 0.13729859841006942, 0.1301296704544449, 0.12093690077314567, 0.11523000875972389, 0.4521680742516432, 0.4489402726649939, 0.46373521135718077, 0.4580138812652056, 0.46071009073136315, 0.455228604245267, 0.47547387057093027, 0.47010907163673654, 0.4273200788890098, 0.13062418191259562, 0.11756660844716116, 0.11167745043183663, 0.11538118611834891, 0.10394649840148973, 0.08858165683330477, 0.10186558785513722, 0.10890119312024749, 0.10766989165513585, 0.14943940523231014, 0.23504603722953532, 0.2322459637032338, 0.20748610767399722, 0.2287620310432732, 0.24909293848421277, 0.20048756444156712, 0.18770885226839884, 0.1799374767604679, 0.27321865801134815, 0.26739713206627636, 0.27167558249401025, 0.256484751732144, 0.2630633861974828, 0.2603947705133952, 0.2881604237072416, 0.2679858419273128, 0.28171516508312233, 0.2087507359951235, 0.188829338590767, 0.21540019587203507, 0.1942831360442746, 0.19356524450978185, 0.20591065526043262, 0.2098516192611357, 0.20907904753409812, 0.20710015570112916, 0.19660750232436053, 0.19886947131736776, 0.18364351852461236, 0.1901620362510692, 0.1902008725314669, 0.18909081563688923, 0.19337825378578188, 0.17494262147404793, 0.1877413187309288, 0.20973868945150997, 0.18607446946287787, 0.18676371900614708, 0.20871462464596457, 0.18760402843056911, 0.1997802944474153, 0.2100208969892492, 0.18986965869111738, 0.1856897068888811, 0.531684136773485, 0.3035509502825009, 0.38275719796529595, 0.5907193753380904, 0.20036258743324376, 0.5770523330467021, 0.18753913311044867, 0.16016370363502153, 0.3719997731017759, 0.5285089213582295, 0.2070706484328383, 0.1939669704698198, 0.2044524341227355, 0.2042492482717828, 0.22532639512309482, 0.20958055938063136, 0.377102675011151, 0.5657995635486407, 0.1920919983581586, 0.18814524971398783, 0.18226981619520144, 0.17629349841901099, 0.17948397245026826, 0.1949597544777354, 0.18243742638946403, 0.1769094617220559, 0.17619486000933082, 0.07484411052053963, 0.07891000449445218, 0.0879569539193148, 0.0676303517366661, 0.071999411935036, 0.0694666888959653, 0.07659975882837677, 0.06813081505884566, 0.07950618380894026]}, "mutation_prompt": null}
{"id": "4568c6f0-7572-40ea-ae7a-06b2e78c3586", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Enhanced strategic mutation with feedback adjustment\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.15 * self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control with feedback\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveDualPhaseDifferentialEvolution", "description": "Adaptive Dual-Phase Differential Evolution that integrates strategic mutation, dynamic local search, and diversity rebalance with feedback mechanisms for enhanced convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.8598955202290018, 0.8616594449857364, 0.8572506210644175, 0.8473590683431149, 0.842086265004254, 0.8555103373146736, 0.8595970147140798, 0.8514555741315436, 0.8499840669579848, 0.7370865980733468, 0.7316018770249493, 0.7484547807804844, 0.7315492060187176, 0.7206538392397789, 0.7343984634693022, 0.7403969283695472, 0.7517573371478008, 0.7294526087554171, 0.19152050494654616, 0.12454085038993035, 0.1495493877634272, 0.12459219386584341, 0.13634490652504794, 0.1481049282400514, 0.13432484647810072, 0.1293019361022758, 0.14757454418045435, 0.122342518112321, 0.1209434968260672, 0.11841387873797848, 0.10211403908798145, 0.11643353087603625, 0.10433676591488406, 0.11870839193793414, 0.11597305019876891, 0.11595082037058069, 0.8383354516284651, 0.8225143937568133, 0.7299913083747736, 0.8459750459642306, 0.7456848200775029, 0.760717323520778, 0.8235068776225777, 0.8363681866734549, 0.8556543530987102, 0.4837586049490187, 0.5628672193707285, 0.4310711096781682, 0.4004504658734457, 0.5172600926123634, 0.5733852933543091, 0.5138517582171027, 0.4048640883768009, 0.479107678413341, 0.8521816006333705, 0.8423473770827983, 0.7959856656808892, 0.8396140388101023, 0.8458444998276514, 0.8515098524342405, 0.784767362676888, 0.8409310389223834, 0.8161617334621245, 0.17202941018574747, 0.16614780778444183, 0.15367523871893407, 0.19773148777871752, 0.22465513090036748, 0.20851487654439071, 0.15766071387111735, 0.25316139843055485, 0.21124224180572615, 0.14602589905943164, 0.16600484892615008, 0.15688760321747863, 0.17040376605842067, 0.17206024959979005, 0.17388582860362645, 0.1613783287740882, 0.19566921383186064, 0.16480844301752573, 0.5748410768700215, 0.5742675245091251, 0.5658440583064221, 0.5950379521168994, 0.6071472679947699, 0.594836751803888, 0.6034234036919384, 0.5645657887561399, 0.5761118532278752, 0.6732547888556879, 0.6805298853510346, 0.6587314094601813, 0.5797826319747563, 0.6352062845089304, 0.6392730638691542, 0.711841349776916, 0.6872829920973851, 0.6720702144670696, 0.13442857957866872, 0.12435599186599033, 0.2768883086813855, 0.43732930592028496, 0.3662450959644187, 0.1935098327782523, 0.21899744519109565, 0.17707544999008695, 0.2567047423949419, 0.44590076386688826, 0.4596615069203517, 0.42716411632060847, 0.45372876551000163, 0.5108313166968093, 0.4790675340234807, 0.4612481636794893, 0.45077553340056264, 0.4487736759020333, 0.7944192339105325, 0.8160584979312793, 0.8107822479975004, 0.7822641998982919, 0.7907039259888127, 0.784350547929036, 0.7962542906102453, 0.8013926127081629, 0.799967705779381, 0.14193616628616423, 0.12910624813267113, 0.12943422827120488, 0.15396515167484615, 0.140337582776222, 0.14551474276785303, 0.12636743645334558, 0.12286963860517774, 0.1481207171105574, 0.17427088557880543, 0.15701705763678087, 0.18620137019013172, 0.21715366538227965, 0.1787255081042236, 0.19022900590837566, 0.27398799414483765, 0.2572352065724888, 0.1971096705586547, 0.506988849910473, 0.49184501078474074, 0.5279976516505778, 0.511963231864804, 0.5096186477930558, 0.5072540236398608, 0.5160498656812706, 0.5223443365390561, 0.5376602584103969, 0.38929562801546547, 0.3610330108042984, 0.40340573874649344, 0.33761397540147686, 0.36733159370307267, 0.3579525548364221, 0.40291499007092857, 0.4058296837766999, 0.41877807350635987, 0.2036507931254916, 0.21512696816114174, 0.21673942925490175, 0.21131334084222486, 0.19177277822023076, 0.20912141917648963, 0.23315703056552806, 0.2173035188572564, 0.22493763090884566, 0.1935782984235459, 0.21915321386321307, 0.20866839773959367, 0.23578610183530357, 0.20042515603199196, 0.22510307800785478, 0.212964523748696, 0.19778517157237052, 0.2157840052954344, 0.1872141949519388, 0.18141538502223598, 0.19254990066933464, 0.7399266906016644, 0.19436865778836243, 0.8258570173187958, 0.8430784038022697, 0.7395738030440672, 0.6300267041952123, 0.8387552047435335, 0.4072823229490268, 0.784797697487442, 0.6988408481837437, 0.25170877850420026, 0.7516770366146411, 0.20648323726970674, 0.7014140421680128, 0.3509785935151283, 0.19017688368783037, 0.18063680411697136, 0.21269254198518572, 0.19406618463572334, 0.18337401652007412, 0.18558169206006958, 0.1867416593884691, 0.1896274229175614, 0.2048722809147152, 0.09159955764735206, 0.08377830775801265, 0.08535744849343607, 0.07821382471645089, 0.08995650215590589, 0.08091602150690891, 0.09818733668380286, 0.08339222136814184, 0.08146225091858705]}, "mutation_prompt": null}
{"id": "68fe1eea-c466-4377-a5ce-7afce510fbdb", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Enhanced strategic mutation with feedback adjustment\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.15 * self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control with feedback\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveDualPhaseDifferentialEvolution", "description": "Adaptive Dual-Phase Differential Evolution that integrates strategic mutation, dynamic local search, and diversity rebalance with feedback mechanisms for enhanced convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.8598955202290018, 0.8616594449857364, 0.8572506210644175, 0.8473590683431149, 0.842086265004254, 0.8555103373146736, 0.8595970147140798, 0.8514555741315436, 0.8499840669579848, 0.7370865980733468, 0.7316018770249493, 0.7484547807804844, 0.7315492060187176, 0.7206538392397789, 0.7343984634693022, 0.7403969283695472, 0.7517573371478008, 0.7294526087554171, 0.19152050494654616, 0.12454085038993035, 0.1495493877634272, 0.12459219386584341, 0.13634490652504794, 0.1481049282400514, 0.13432484647810072, 0.1293019361022758, 0.14757454418045435, 0.122342518112321, 0.1209434968260672, 0.11841387873797848, 0.10211403908798145, 0.11643353087603625, 0.10433676591488406, 0.11870839193793414, 0.11597305019876891, 0.11595082037058069, 0.8383354516284651, 0.8225143937568133, 0.7299913083747736, 0.8459750459642306, 0.7456848200775029, 0.760717323520778, 0.8235068776225777, 0.8363681866734549, 0.8556543530987102, 0.4837586049490187, 0.5628672193707285, 0.4310711096781682, 0.4004504658734457, 0.5172600926123634, 0.5733852933543091, 0.5138517582171027, 0.4048640883768009, 0.479107678413341, 0.8521816006333705, 0.8423473770827983, 0.7959856656808892, 0.8396140388101023, 0.8458444998276514, 0.8515098524342405, 0.784767362676888, 0.8409310389223834, 0.8161617334621245, 0.17202941018574747, 0.16614780778444183, 0.15367523871893407, 0.19773148777871752, 0.22465513090036748, 0.20851487654439071, 0.15766071387111735, 0.25316139843055485, 0.21124224180572615, 0.14602589905943164, 0.16600484892615008, 0.15688760321747863, 0.17040376605842067, 0.17206024959979005, 0.17388582860362645, 0.1613783287740882, 0.19566921383186064, 0.16480844301752573, 0.5748410768700215, 0.5742675245091251, 0.5658440583064221, 0.5950379521168994, 0.6071472679947699, 0.594836751803888, 0.6034234036919384, 0.5645657887561399, 0.5761118532278752, 0.6732547888556879, 0.6805298853510346, 0.6587314094601813, 0.5797826319747563, 0.6352062845089304, 0.6392730638691542, 0.711841349776916, 0.6872829920973851, 0.6720702144670696, 0.13442857957866872, 0.12435599186599033, 0.2768883086813855, 0.43732930592028496, 0.3662450959644187, 0.1935098327782523, 0.21899744519109565, 0.17707544999008695, 0.2567047423949419, 0.44590076386688826, 0.4596615069203517, 0.42716411632060847, 0.45372876551000163, 0.5108313166968093, 0.4790675340234807, 0.4612481636794893, 0.45077553340056264, 0.4487736759020333, 0.7944192339105325, 0.8160584979312793, 0.8107822479975004, 0.7822641998982919, 0.7907039259888127, 0.784350547929036, 0.7962542906102453, 0.8013926127081629, 0.799967705779381, 0.14193616628616423, 0.12910624813267113, 0.12943422827120488, 0.15396515167484615, 0.140337582776222, 0.14551474276785303, 0.12636743645334558, 0.12286963860517774, 0.1481207171105574, 0.17427088557880543, 0.15701705763678087, 0.18620137019013172, 0.21715366538227965, 0.1787255081042236, 0.19022900590837566, 0.27398799414483765, 0.2572352065724888, 0.1971096705586547, 0.506988849910473, 0.49184501078474074, 0.5279976516505778, 0.511963231864804, 0.5096186477930558, 0.5072540236398608, 0.5160498656812706, 0.5223443365390561, 0.5376602584103969, 0.38929562801546547, 0.3610330108042984, 0.40340573874649344, 0.33761397540147686, 0.36733159370307267, 0.3579525548364221, 0.40291499007092857, 0.4058296837766999, 0.41877807350635987, 0.2036507931254916, 0.21512696816114174, 0.21673942925490175, 0.21131334084222486, 0.19177277822023076, 0.20912141917648963, 0.23315703056552806, 0.2173035188572564, 0.22493763090884566, 0.1935782984235459, 0.21915321386321307, 0.20866839773959367, 0.23578610183530357, 0.20042515603199196, 0.22510307800785478, 0.212964523748696, 0.19778517157237052, 0.2157840052954344, 0.1872141949519388, 0.18141538502223598, 0.19254990066933464, 0.7399266906016644, 0.19436865778836243, 0.8258570173187958, 0.8430784038022697, 0.7395738030440672, 0.6300267041952123, 0.8387552047435335, 0.4072823229490268, 0.784797697487442, 0.6988408481837437, 0.25170877850420026, 0.7516770366146411, 0.20648323726970674, 0.7014140421680128, 0.3509785935151283, 0.19017688368783037, 0.18063680411697136, 0.21269254198518572, 0.19406618463572334, 0.18337401652007412, 0.18558169206006958, 0.1867416593884691, 0.1896274229175614, 0.2048722809147152, 0.09159955764735206, 0.08377830775801265, 0.08535744849343607, 0.07821382471645089, 0.08995650215590589, 0.08091602150690891, 0.09818733668380286, 0.08339222136814184, 0.08146225091858705]}, "mutation_prompt": null}
{"id": "a86815a0-0562-48ae-b2aa-a0d3c6d6a518", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 60)  # slightly increased adaptive population size\n        self.F = 0.7  # slightly increased differential weight\n        self.CR = 0.85  # adjusted crossover probability\n        self.alpha = 0.01  # quantum-inspired coefficient for exploration\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                F = self.F if np.random.rand() < 0.6 else np.random.uniform(0.5, 0.9)\n                mutant = np.clip(a + F * (b - c) + self.alpha * np.random.randn(self.dim), \n                                 self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Quantum-Inspired Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(4 + int(0.2 * self.dim)):  # further increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.uniform(-self.alpha, self.alpha, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control with quantum feedback\n            if evals < 0.6 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Feedback for Enhanced Global and Local Search Balance.", "configspace": "", "generation": 85, "fitness": 0.2536663445865936, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.5431356012893285, 0.5566725758187212, 0.5626887813106476, 0.6151998123898011, 0.5687916669234496, 0.6017224406405259, 0.57119415979091, 0.5635336267581255, 0.597776614421323, 0.17327375741475481, 0.17469549864779677, 0.16305116613700488, 0.19848251444721987, 0.1651981262938128, 0.15864674433731396, 0.17351260189624118, 0.16066192581630934, 0.17953088202251632, 0.12705347381216836, 0.10834939499852791, 0.13426210062404265, 0.14168455849542938, 0.11817088827220379, 0.12162304367782473, 0.11480727459577977, 0.12421939852188046, 0.13757012381170874, 0.10222740571655631, 0.11055503755686602, 0.12341082523782154, 0.12123832582999261, 0.09848670164298112, 0.10132890617171919, 0.09972901460699446, 0.09471444835089116, 0.09974123382240163, 0.9552336422843848, 0.9092987962652833, 0.9770737875635895, 0.9077468453964401, 0.9144043985266467, 0.892065800493565, 0.9403514243871066, 0.9371893735831139, 0.8818965836139899, 0.2830537639151023, 0.2624138378880392, 0.32025121036277937, 0.300525800175236, 0.3031269470195628, 0.3272455279561789, 0.2723112870118425, 0.31862786451159686, 0.31923465867446377, 0.47641051996991046, 0.4898667451660025, 0.3790879954926123, 0.5105540357789105, 0.5601669239697478, 0.5428827078592688, 0.4292645804666858, 0.5271199699245404, 0.3900676055128137, 0.16358786560979532, 0.17526326584813778, 0.24387858371408155, 0.17021097045769185, 0.1796439106229062, 0.16768200620937934, 0.16901171804501247, 0.19150843055986355, 0.24542749211853565, 0.1291396183139899, 0.16994184657461597, 0.1869234990822446, 0.15325539110930042, 0.18821246408325099, 0.16242258710243007, 0.17032394525576278, 0.2019509601421241, 0.18496167220738247, 0.08035799547250622, 0.0673492072467512, 0.06726500103250177, 0.10663753699866996, 0.06436976212984624, 0.06254941773327138, 0.09079953717410882, 0.08231119513652907, 0.07631498062313569, 0.1370891981629857, 0.15585131045857614, 0.12954979522596133, 0.13088213203524524, 0.14584876576996264, 0.12062546078631353, 0.16282003275251422, 0.20062598460404357, 0.17560325053013226, 0.04815153386492854, 0.06667465831026387, 0.09795796759978626, 0.04773699217513039, 0.08105722859556741, 0.0371215037989725, 0.05233768967800412, 0.04363764248232238, 0.08882681771115664, 0.1558817272309092, 0.12652235579295035, 0.12730305499272765, 0.17799185824652763, 0.15201695722138797, 0.15121208416725107, 0.16282752776423026, 0.1366224092806353, 0.1712504253487832, 0.43459140477309566, 0.45320758026589647, 0.44307181255310635, 0.4384555093019401, 0.45650844701561644, 0.42982505207626764, 0.4477243162777651, 0.4246325920886225, 0.4313457904072737, 0.11518516696615244, 0.10960716442820717, 0.239715340990734, 0.11755644476151705, 0.13135012980172833, 0.12283201173318015, 0.16776827737073308, 0.10952414997967952, 0.10174941282000272, 0.13940398490909978, 0.16203352285409733, 0.17921503917677128, 0.15822279103869064, 0.16910838984543097, 0.15162514262552718, 0.17127478725838519, 0.15653249104476785, 0.18424021747715602, 0.285238674140352, 0.29540850652744344, 0.268205211191869, 0.2778773681476303, 0.2990048692129761, 0.2765550233438009, 0.30975658773717596, 0.2973541057004717, 0.29980956176780227, 0.24075382341367135, 0.19923754511566483, 0.21817605082425262, 0.23044138511652468, 0.1840212976869906, 0.20603858349494597, 0.23988601609627225, 0.22317357382095415, 0.23997684445299805, 0.208617201946248, 0.1858043752099705, 0.17863560663035094, 0.20671253256993005, 0.1965322681627747, 0.22225042275472762, 0.2185766899284658, 0.19195802463912837, 0.23073912882274683, 0.18466043024693812, 0.2071932928525363, 0.1933672545876699, 0.19769282578190828, 0.21456446728272083, 0.18178690318666746, 0.19720647872524133, 0.2189553185930585, 0.18983385234815486, 0.36052810185279216, 0.16062316085623884, 0.39345151693943714, 0.2098184989018459, 0.319533065909297, 0.1811038008884177, 0.16946992809260608, 0.5100959720488023, 0.5021378659326354, 0.5413204316093483, 0.44910591628736174, 0.38056415577880975, 0.40773818142496143, 0.1709434291332136, 0.18344306167591518, 0.2042427235345382, 0.2007315965288219, 0.5010090881563609, 0.1961218268916617, 0.1952405811650989, 0.19516983992472847, 0.23006276595303898, 0.22435077809418924, 0.19800183182840736, 0.22187999520902535, 0.2117041985825655, 0.21906374535319906, 0.0853823339506884, 0.0918198131626996, 0.10134479979713307, 0.09728379165188983, 0.0915656664613489, 0.07498009250534432, 0.09771405603370653, 0.08849458580853531, 0.09383964981496973]}, "mutation_prompt": null}
{"id": "855b4f76-a429-4214-a9b1-e3829a47a80d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(4 * dim, 40)  # slightly reduced population size for efficiency\n        self.F = 0.5  # reduced differential weight\n        self.CR = 0.8  # adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with quantum-inspired approach\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                F_adaptive = np.random.uniform(0.3, 0.7) if np.random.rand() < 0.8 else 0.5\n                mutant = np.clip(a + F_adaptive * (b - c) + F_adaptive * (d - e), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Quantum-Inspired Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(5 + int(0.1 * self.dim)):  # quantum-inspired search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Local Entropy Control\n            if evals < 0.5 * self.budget and len(population) < 2.0 * self.population_size:\n                entropy_level = np.std(population, axis=0)\n                if np.mean(entropy_level) < 1.0:\n                    new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                    new_fitness = np.array([func(ind) for ind in new_individuals])\n                    evals += len(new_individuals)\n                    population = np.vstack((population, new_individuals))\n                    fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation and Local Entropy Control.", "configspace": "", "generation": 86, "fitness": 0.3067026741891319, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.7551881253198384, 0.754264999876819, 0.7624035370943706, 0.7774625413022009, 0.773781835315618, 0.786932620101628, 0.738638707358979, 0.7734783119487523, 0.746758055045858, 0.5589424233411935, 0.5560578357915478, 0.5786672321062707, 0.5436401654934182, 0.565397920578329, 0.5668777478399889, 0.5686428122275655, 0.5270112345698413, 0.5766811482465389, 0.14099645003739136, 0.11671113082839635, 0.11117876398696258, 0.1215772947557312, 0.14600786616735917, 0.15575769696886232, 0.13976704517771454, 0.12464658398806006, 0.139258998877677, 0.11312678867925174, 0.1113686343828787, 0.09730287783599412, 0.11165286787434581, 0.11468609554834353, 0.10491164128348551, 0.1120486339627258, 0.1234096188868039, 0.11299892029978842, 0.9247873547059314, 0.9305956543370661, 0.9438275732070777, 0.9586611517433924, 0.954292937636076, 0.939752244302508, 0.9580708690757296, 0.9460155983837354, 0.945027109587021, 0.38330624833251326, 0.37612456352357426, 0.37530539746080227, 0.35679135339866996, 0.356623631184002, 0.37872229726180595, 0.37860697844749047, 0.352302986184574, 0.382390585780801, 0.5749880427163341, 0.6315581683444443, 0.5372419630879454, 0.6798355470169793, 0.6629238657832037, 0.7190269944367057, 0.6834269136446682, 0.6701768458592305, 0.6615873060320969, 0.21813666430052037, 0.2666462220078861, 0.20066515524314232, 0.2265638417468454, 0.19757757569569312, 0.16413602478780265, 0.23635599350628844, 0.23139850113999394, 0.23534306869163102, 0.22732377081365152, 0.19594881987100154, 0.20217734662470543, 0.20122607841068163, 0.19900853918897687, 0.23549556248401804, 0.2996848432936634, 0.20056788333295328, 0.20892331093672734, 0.10749335082751199, 0.12219486394309476, 0.11936984866560019, 0.10832581799941943, 0.08756139615566394, 0.08560066520804355, 0.11458711832267143, 0.12167621458914801, 0.13624164301122432, 0.22883149462274366, 0.22315530440024145, 0.2164044263333964, 0.2483907768189615, 0.19827559902346903, 0.1771453533837687, 0.2955768518476036, 0.25039773437831614, 0.26337947754116686, 0.06305219049996125, 0.04344890197706175, 0.03261926651324487, 0.05100905363827768, 0.04485570276234796, 0.01856845042285149, 0.019253769421314404, 0.04673173556179022, 0.05014628042561364, 0.1803052379315604, 0.18766495005744144, 0.16479383116514001, 0.2008583066287607, 0.19388151517645846, 0.19799866094622376, 0.17244259865681688, 0.17696695568824927, 0.16334440093622193, 0.5366968835483601, 0.5569743086584202, 0.5610434334100556, 0.5789361041550101, 0.5310608471176874, 0.5400438049948211, 0.5594766949144048, 0.5504758138543875, 0.5541567915869934, 0.12140914397877911, 0.10159762421190321, 0.09930919047898623, 0.09526672926455793, 0.09422198782032953, 0.15389966802926647, 0.11572122180562239, 0.11816421614928618, 0.1232881783843277, 0.16707635874611237, 0.18003315457221847, 0.18241814218328056, 0.29434412380896546, 0.2320076458218039, 0.16337684571232025, 0.2208026497491753, 0.2397205095876337, 0.14550642793084712, 0.31580820300755186, 0.29674624911288694, 0.33648712644102574, 0.33899804145181, 0.324254205060837, 0.29621215517172894, 0.34636210744042517, 0.32624711829718966, 0.3530910720355178, 0.2277233210424895, 0.22270035852837688, 0.22678340205967984, 0.23083768071458477, 0.23359278966768648, 0.23197309109521624, 0.24615274925132746, 0.2609093230967171, 0.24133739421650424, 0.1956895161266735, 0.19827798827375254, 0.2078314798071489, 0.18543346613701328, 0.19134053742952883, 0.2013209668954551, 0.1937288537730526, 0.21415140803362642, 0.20279764581438997, 0.21589958497994033, 0.1901495040442397, 0.20743216452883673, 0.20246144180008774, 0.2016736347037873, 0.19602455562050192, 0.20511434831542597, 0.21194281169577112, 0.2127389318453523, 0.4746877564691552, 0.6208995748639997, 0.2541763263413712, 0.47870457468273575, 0.3331757619517606, 0.3435102048005241, 0.5009816034427259, 0.3212638580460553, 0.17636252721239198, 0.48326018826454786, 0.2117573811252259, 0.5346221973745687, 0.3986590153467522, 0.5435836990298655, 0.20165221260140576, 0.21190066888696113, 0.20722046740105227, 0.20457326892692385, 0.18561226174437206, 0.19295237001518606, 0.18513038850217722, 0.18548710197059293, 0.18523365399605818, 0.1706294353313268, 0.1766527190738547, 0.18971060166333042, 0.18645703554888526, 0.07340261508133994, 0.07480261904153118, 0.0942824314471069, 0.09439115781083152, 0.08138674067985208, 0.08146582458336304, 0.08302170009724341, 0.0907672702803487, 0.07821239109290568]}, "mutation_prompt": null}
{"id": "7778ddf8-e1c0-439e-ab74-7392c70eb902", "solution": "import numpy as np\n\nclass DynamicMultiPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)\n        self.F = 0.7  # dynamic differential weight\n        self.CR = 0.8  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F = np.random.uniform(0.5, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Diversified Local Exploration Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(5 + int(0.1 * self.dim)):  # diversified local exploration\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Stochastic Rejuvenation\n            if evals < 0.6 * self.budget and len(population) < 2.0 * self.population_size:\n                rejuvenation_size = 4\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (rejuvenation_size, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += rejuvenation_size\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "DynamicMultiPhaseDifferentialEvolution", "description": "Dynamic Multi-Phase Differential Evolution with Adaptive Mutation, Diversified Local Exploration, and Stochastic Rejuvenation for Enhanced Global Search Efficiency.", "configspace": "", "generation": 87, "fitness": 0.29003805264541993, "feedback": "The algorithm DynamicMultiPhaseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.7173287330238667, 0.7131218047018615, 0.6803183261545225, 0.7235385472473512, 0.7075377754219705, 0.7456122559156053, 0.7454372345242275, 0.7298256094639508, 0.7207213519528473, 0.4680540251200489, 0.46422723179131475, 0.4544925175671174, 0.44847146760813794, 0.4474846943371674, 0.47472003231957893, 0.4574465985768752, 0.4691075528368436, 0.4720364556333134, 0.1142573636174109, 0.10792503829285283, 0.12466214002756637, 0.12227057731545321, 0.13224997122300897, 0.110987330446214, 0.11665806152290426, 0.11354034931325785, 0.1109015274773606, 0.10906582549612343, 0.10686458165963764, 0.10368934323342383, 0.11033437671531776, 0.10941271591264745, 0.10995581787459197, 0.10577892543387846, 0.09784795850265204, 0.10913758163471232, 0.9459460382372232, 0.9345016971451808, 0.9529839620008707, 0.9512547396414553, 0.9510717968392661, 0.9528654246710669, 0.9724261712411537, 0.9272708621403071, 0.954746017531205, 0.3486013665584645, 0.3320892999002063, 0.3051435216313102, 0.3479518137850245, 0.3401058993979975, 0.31314216959081886, 0.30703220675161547, 0.36082340709602456, 0.3173160662147544, 0.5241466750485648, 0.5822576880790478, 0.4713798981406315, 0.5952935882698052, 0.6066643452521683, 0.5389236116713809, 0.5005925823473327, 0.5543547426586706, 0.5462809797949743, 0.18927453385220439, 0.20301676404438362, 0.20155921370213936, 0.2027392288085682, 0.18364049412391037, 0.20269071000416072, 0.20014529539943005, 0.20060426539674314, 0.1840956841920609, 0.1590554886034834, 0.18008473010199177, 0.19086591887155713, 0.22304566960428873, 0.17660023821678006, 0.20911102952913685, 0.2125502150808013, 0.16828826262255314, 0.20779342012411528, 0.07598288556491739, 0.06273730986685877, 0.05148982111920397, 0.07542327482490141, 0.06418455041916438, 0.07041050877318267, 0.05612950790843263, 0.08907077196472324, 0.09101837290190651, 0.18897732823210822, 0.1835910617414106, 0.20920331189704888, 0.19571832028095948, 0.1749731401617648, 0.15432987924372243, 0.21529978303703856, 0.20422365936696352, 0.16513704582568467, 0.02345971362254129, 0.02200918631727633, 0.013924794442009447, 0.0410658695128151, 0.020544366171271422, 0.03576031290358628, 0.010490888698564182, 0.033704292856581164, 0.010623093162394626, 0.14256108265069, 0.13367976907354095, 0.14216660359477173, 0.1635570128009125, 0.16739078076015834, 0.17514736395907826, 0.13002130060082617, 0.1414258428440095, 0.16321978667093862, 0.513265309226944, 0.49027020950596756, 0.5087290655227827, 0.4973779897916376, 0.5132128293113886, 0.49505943141512554, 0.5237087256179139, 0.5192902980706162, 0.5014154499124015, 0.09609353925963005, 0.09841742854538593, 0.09048815970864998, 0.09736203771763485, 0.09447335325048245, 0.11508215009427458, 0.09922070012907114, 0.09480966310432504, 0.11283816656039158, 0.16117940185071855, 0.2544533985875954, 0.17409936936780646, 0.2849519928599743, 0.28637045782607884, 0.19307407972835489, 0.22505326609080123, 0.2664350670584985, 0.1786297802991066, 0.27312497645943623, 0.2714931661939264, 0.2924858669466188, 0.2957455443088265, 0.27807815283013804, 0.27403539606186755, 0.3209829240779122, 0.3208831226111054, 0.31969435209300623, 0.21607859240977312, 0.21061534241339952, 0.22949977897404916, 0.22172925555067002, 0.24370345860749787, 0.20599304845533883, 0.22316922919279958, 0.24083256109960116, 0.2149436123245818, 0.1923283384402138, 0.18548307199948855, 0.1986008080114211, 0.1990924463581013, 0.186829054305645, 0.19253208415397172, 0.19403816063879054, 0.19782040852681126, 0.19718234839144355, 0.18244183860996654, 0.22589805371082927, 0.18912573685499312, 0.18500885601165473, 0.18738406608491132, 0.18766094947436085, 0.22393077063863953, 0.19603256329802254, 0.1988762477834446, 0.17402948686308373, 0.41997634333296874, 0.38317625440664993, 0.5262088317519242, 0.6009909815022473, 0.5799469186940112, 0.49371088021808307, 0.2045269029508735, 0.6842006492053174, 0.5829613405731511, 0.21024561259762942, 0.5236868167931237, 0.28358633533730526, 0.20841789115300247, 0.4331092308611413, 0.7001408026624691, 0.5839982701221107, 0.5653255628110927, 0.1864903023878004, 0.19116104352776608, 0.17852208535264835, 0.17635750490943902, 0.1809195080669307, 0.18282722109774519, 0.1777923493999366, 0.19393656571444595, 0.19303756984386866, 0.08294754648739855, 0.09113178020181112, 0.07393507731181181, 0.06807357057621743, 0.07444139858038579, 0.07438492030267918, 0.06565341248695111, 0.07629807850386527, 0.07935279292359887]}, "mutation_prompt": null}
{"id": "b407a6c8-eb5f-42dd-80e0-51a52bae4d50", "solution": "import numpy as np\n\nclass AdaptiveGeneticParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 60)  # adaptive population size\n        self.c1 = 1.494  # cognitive component\n        self.c2 = 1.494  # social component\n        self.inertia = 0.729  # inertia weight\n\n    def __call__(self, func):\n        # Initialize population and velocities\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = np.array([func(ind) for ind in population])\n        global_best_idx = np.argmin(personal_best_fitness)\n        global_best_position = personal_best_positions[global_best_idx].copy()\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Update velocities and positions\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            velocities = (self.inertia * velocities +\n                          self.c1 * r1 * (personal_best_positions - population) +\n                          self.c2 * r2 * (global_best_position - population))\n            population += velocities\n            population = np.clip(population, self.lower_bound, self.upper_bound)\n\n            # Evaluate fitness\n            fitness = np.array([func(ind) for ind in population])\n            evals += self.population_size\n\n            # Update personal and global bests\n            improved = fitness < personal_best_fitness\n            personal_best_positions[improved] = population[improved]\n            personal_best_fitness[improved] = fitness[improved]\n            new_global_best_idx = np.argmin(personal_best_fitness)\n            if personal_best_fitness[new_global_best_idx] < personal_best_fitness[global_best_idx]:\n                global_best_idx = new_global_best_idx\n                global_best_position = personal_best_positions[global_best_idx].copy()\n\n            # Genetic algorithm inspired crossover and mutation\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                parent1, parent2 = population[np.random.choice(self.population_size, 2, replace=False)]\n                crossover_point = np.random.randint(1, self.dim)\n                child = np.concatenate((parent1[:crossover_point], parent2[crossover_point:]))\n                mutation = np.random.normal(0, 0.01, self.dim)\n                child += mutation\n                child = np.clip(child, self.lower_bound, self.upper_bound)\n                child_fitness = func(child)\n                evals += 1\n\n                if child_fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = child\n                    personal_best_fitness[i] = child_fitness\n\n        return global_best_position", "name": "AdaptiveGeneticParticleSwarmOptimization", "description": "Adaptive Genetic Particle Swarm Optimization combines genetic algorithm crossover and mutation with swarm-inspired velocity updates for enhanced exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.21794371464149595, "feedback": "The algorithm AdaptiveGeneticParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.46558563650525253, 0.5130413401014449, 0.5198901624315324, 0.5178879470027491, 0.5453488447605651, 0.495924191305951, 0.5212459773915137, 0.5048773582368817, 0.4218973194396689, 0.13697706166544998, 0.1086169660894779, 0.11017579087987073, 0.14492138813505429, 0.12996719933894352, 0.13117558774644877, 0.06698758169973462, 0.04417770238972729, 0.166459869275146, 0.10758727154041514, 0.12100818518515677, 0.10026958143820375, 0.12998953215120623, 0.11497140622246571, 0.11143717035516187, 0.13865326241097065, 0.1019516194975213, 0.12861430152175413, 0.09418044426137584, 0.11404274788292512, 0.08739378340728343, 0.10257226181804979, 0.08540482469564614, 0.09271584731230054, 0.09894232126940095, 0.10888313933043414, 0.08918350365816263, 0.9699120121905875, 0.9725025160882326, 0.9740318443329928, 0.9610840037645328, 0.9627194875098155, 0.967641752605341, 0.9729897674387089, 0.9731752285702298, 0.972352219312639, 0.26299183747883015, 0.304819467427192, 0.16462136682614015, 0.19586783615245784, 0.17182536399606818, 0.3017065406378695, 0.13213575964106916, 0.20226232101334551, 0.28327152728339744, 0.3613341386691824, 0.2168232112942926, 0.16962968489888075, 0.2452554395864852, 0.4513732693394594, 0.19028477410642874, 0.19920578050744908, 0.2824115671402819, 0.22589280069732587, 0.13616471452409173, 0.08453331943797782, 0.14175160259580244, 0.10508519123951354, 0.1384169719789392, 0.09697206464794439, 0.11203552821945528, 0.13284358367137195, 0.1354013859547858, 0.16719551975165503, 0.08586355960656633, 0.11665338439453043, 0.11869379260376722, 0.11900870251015316, 0.17149317409957798, 0.15012812219273186, 0.1708422437724807, 0.1199498947354658, 9.999999999998899e-05, 0.00020454351595866616, 9.999999999998899e-05, 0.024006143840042515, 9.999999999998899e-05, 9.999999999998899e-05, 0.010308145729915896, 9.999999999998899e-05, 0.0023993421453737396, 0.07979148547328274, 0.09302928969315871, 0.09700026817074592, 0.049751090283315924, 0.08179320559532932, 0.07197773600525248, 0.04491565705713363, 0.099476925853347, 0.05071420915574398, 0.018950184662655523, 0.020538561259695998, 0.01426865111798814, 0.03192991046878635, 0.08938139376551024, 0.029598486129346013, 0.039880049717958, 0.03372622111683454, 0.052719046588162066, 0.10771145756554201, 0.0939662698917273, 0.11966981410431377, 0.13210444872002136, 0.10010089117788412, 0.07109178190527232, 0.06346629823274907, 0.04847543326441628, 0.0725418403909911, 0.4295720763589108, 0.39490400905983847, 0.463486612533605, 0.4089060578996915, 0.4599809854017485, 0.4169076744452428, 0.41316253564707417, 0.4174734893847192, 0.4241723826644499, 0.09864519515788617, 0.07532731127511894, 0.1180910636751813, 0.10539664588082343, 0.11345860807902775, 0.1133624961721934, 0.11374413071001022, 0.10762116099952668, 0.08796658968952542, 0.144015851068096, 0.1743203428257406, 0.17538507221848554, 0.19987450276119412, 0.16615173973910968, 0.16591465288412788, 0.20462212290232162, 0.16389212310136514, 0.19257758280186932, 0.29840362919078756, 0.29312426656042667, 0.282972547862147, 0.29136354195685343, 0.3130928906883782, 0.27734865697157185, 0.3004246058320501, 0.31878082973029853, 0.3006575166482799, 0.20552068150893543, 0.2067137329065617, 0.2392040898814941, 0.1519498770010761, 0.19935862274754834, 0.24712397873552328, 0.26197251762261686, 0.24353299961320485, 0.20766951596070415, 0.1909546987604318, 0.20846053342804738, 0.20469868525126433, 0.2064669503742802, 0.19187346080001144, 0.18630409159762495, 0.1989257149023631, 0.2055106864112234, 0.1841040076163637, 0.24940226249480624, 0.2593939101817072, 0.1740953635407736, 0.26956559077548903, 0.1969535915469246, 0.2007296769695418, 0.17991154482654148, 0.22779623034020868, 0.18776943675498425, 0.4797607215804228, 0.18560341631251054, 0.16665866878489743, 0.7694780786761127, 0.19818207989302727, 0.19651247263781202, 0.14023635510919252, 0.16123920116398227, 0.6703829531105728, 0.6466285235229394, 0.2067278673496492, 0.19522572845507247, 0.20231125838921726, 0.1688682907788026, 0.12502648844653141, 0.2060601371467793, 0.2045477933816886, 0.3017612284023752, 0.1922653797246432, 0.1855029868089222, 0.17182155267208088, 0.18453500184413774, 0.18073899852057584, 0.20334903230646928, 0.19344335816134983, 0.18453744414020534, 0.1983979285396852, 0.08645775495929142, 0.07979024717137873, 0.08123906411449555, 0.08170947056391265, 0.08005812257041567, 0.07438801956761831, 0.08627350286245294, 0.09268512371485327, 0.07227197245277672]}, "mutation_prompt": null}
{"id": "9fbd5649-ffd7-4975-8fd8-83eecf0ca9ec", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 60)  # adjusted population size\n        self.F = 0.7  # modified differential weight\n        self.CR = 0.85  # adjusted crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                # Dynamic mutation with probabilistic adaptation\n                F = self.F if np.random.rand() < 0.8 else np.random.uniform(0.5, 0.9)\n                mutant = np.clip(a + F * (b - c) + F * (d - e), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Intensified Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(5 + int(0.2 * self.dim)):  # further increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.03, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Population Control with conditional expansion\n            if evals < 0.4 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution combines adaptive mutation, strategic crossover, and intensified local search with dynamic population control for robust optimization.", "configspace": "", "generation": 89, "fitness": 0.21768613565632908, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.4890859779104034, 0.48117069364918563, 0.4872698888377076, 0.499961537566756, 0.487987189491227, 0.4921213642986382, 0.5196889731063729, 0.48278966739876883, 0.48309213046642085, 0.14919465908399465, 0.1820097444287414, 0.15925974976102553, 0.18462982196407474, 0.18049204307203104, 0.19563352135245105, 0.15485004993053697, 0.14951360574514605, 0.1810697091591762, 0.12198441469423649, 0.08423849592605981, 0.09030335356363106, 0.09408020482406976, 0.1025353985669466, 0.11201476382187958, 0.11399940654394813, 0.09975919814169587, 0.10129663762760033, 0.09169269141838321, 0.09598464550732189, 0.11211929239749574, 0.07791769626081879, 0.10582159682110281, 0.09352575432088961, 0.0824259413096865, 0.08666593091338004, 0.10009086032464698, 0.9388677484400911, 0.955330671154651, 0.9111110287277598, 0.9045159150801985, 0.9208238345563537, 0.9285959232991582, 0.8919099000813571, 0.9695566725228761, 0.9254311739216206, 0.25655132405517644, 0.3383259449168139, 0.2731619805792723, 0.2862061394380455, 0.267802397646849, 0.2894392505673914, 0.27134676012101744, 0.26122272929337464, 0.2781126243104739, 0.2387285501865496, 0.28413861548408403, 0.2336392897780989, 0.22332874435243832, 0.23642026796200288, 0.23455248855890654, 0.32064129696966737, 0.265538014678366, 0.23912750537438532, 0.19412653396741464, 0.18737251691972745, 0.13936323659424577, 0.1409195749387172, 0.13100386631660987, 0.1401405779673882, 0.1449120574994922, 0.13156910288797208, 0.15272809485449557, 0.223175651510092, 0.11738657320841361, 0.14565910200873022, 0.1327841930530418, 0.1409022129335381, 0.1446741080047399, 0.1056976196718451, 0.15463414170058365, 0.1736049629038784, 0.007828207149026656, 0.01855126717508815, 0.01899713155106586, 0.0002828169678267267, 0.0364202016108478, 0.026044040081012798, 0.0240223797875464, 0.021465787921351343, 0.01467486462147427, 0.13217138223575853, 0.09885029944031065, 0.09271528704911047, 0.08685328194763864, 0.08639132944149475, 0.09364534752061282, 0.12937718177424684, 0.10291700696604, 0.12577597078935654, 9.999999999998899e-05, 0.00908870224918723, 0.022779029397867467, 9.999999999998899e-05, 0.0022276369328383394, 0.007023201739700058, 0.03455514779835689, 0.0008630040717851895, 0.00436798960461382, 0.135671365841596, 0.10223104098974711, 0.08382190673485856, 0.11184368946090595, 0.09898731238097302, 0.09863572378756758, 0.09522716118511454, 0.10443097075839691, 0.09699689477850948, 0.38721591634567065, 0.42383181392605296, 0.4035591039794094, 0.3849329874257301, 0.39974469515075184, 0.4088289031164246, 0.40645844697230105, 0.41753778472805747, 0.4472498697650018, 0.09934443111871738, 0.09383025826127833, 0.10021647477497497, 0.0981206396995753, 0.12322242226976521, 0.08065672076865193, 0.09547664651912424, 0.07948861490787129, 0.10035058114046136, 0.19998623959336193, 0.1532517543231131, 0.1665324226488556, 0.18777631695175623, 0.13995298351255603, 0.1539648753079368, 0.16113316779973863, 0.20377973187364995, 0.21025248093386772, 0.23963904002098813, 0.2177312619370506, 0.22633992921719825, 0.20207801067490894, 0.25525831092475215, 0.19663007941119914, 0.24703457857163258, 0.23202315237358995, 0.24139122352383924, 0.148542709091806, 0.17955162359314814, 0.1684513661786592, 0.16048164481065363, 0.16202667562441497, 0.1611254918453584, 0.17303496048125322, 0.1734826269442168, 0.1607319604743197, 0.17461507690012568, 0.1778492411188246, 0.20268242188316887, 0.17910159584874907, 0.19239141457570075, 0.1788898910735114, 0.19362206408395188, 0.22010154066092835, 0.17356817981349482, 0.17695354504256133, 0.1740892403879607, 0.1689231532480293, 0.19266724277695746, 0.18169892527961962, 0.22269757269781187, 0.1783028595829279, 0.16903842282173698, 0.18652929688622066, 0.5641661178801982, 0.181486042188292, 0.36592893921150893, 0.17855490995426448, 0.1969082310825525, 0.6421989419035057, 0.7041198420104791, 0.18658803729190598, 0.33042475338353583, 0.4419551113334562, 0.20669670855318278, 0.19869607325656136, 0.2704415188850784, 0.1910539994832795, 0.25233575061478164, 0.4082227321613734, 0.20316326592233103, 0.3103271601547455, 0.19071243886259204, 0.18944417955262127, 0.21055681147903804, 0.19566885509229692, 0.1987058885458991, 0.22551254566268175, 0.19536938553836147, 0.18331978438793584, 0.19141867306669502, 0.12194401122169907, 0.07625798934195704, 0.07892957470090456, 0.08855289694236923, 0.06739824137083705, 0.05751472396565205, 0.06876941293982675, 0.0651913274101098, 0.06840572127246236]}, "mutation_prompt": null}
{"id": "dd993b56-8bfb-4fbc-8a48-c96269bab6c1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(7 * dim, 70)  # slightly increased adaptive population size\n        self.F = 0.5  # adjusted differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Stochastic feedback adjustment for mutation factor\n                F = self.F if np.random.rand() < 0.8 else np.random.uniform(0.3, 0.7)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Intensive Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(5 + int(0.2 * self.dim)):  # further increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.04, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control with increased sensitivity\n            if evals < 0.4 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Stochastic Feedback and Intensive Local Search for robust convergence.", "configspace": "", "generation": 90, "fitness": 0.3735519709308015, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.8390334809196487, 0.8480052037010399, 0.8346185271426251, 0.8357359902486587, 0.8268351218336536, 0.8353475505918597, 0.8298848378727498, 0.8323915313074228, 0.8338527043028069, 0.694977374286382, 0.698002218944969, 0.6909082947567599, 0.6944221216903486, 0.6974951911327085, 0.6947283923301977, 0.6443379460229128, 0.6932369053590812, 0.09976205273993821, 0.1712059687071975, 0.15311767101873497, 0.15636116464222538, 0.161502038085934, 0.17369605126273113, 0.1574763939328535, 0.15192443241601228, 0.19598733538944102, 0.15183206891954903, 0.12253185792075494, 0.1171867468218315, 0.12090885825805575, 0.12190963485983686, 0.14022207864923353, 0.13252975432335046, 0.14078528148748415, 0.12147333434275664, 0.10402944050936969, 0.7879353652855536, 0.7990403101207231, 0.7331382295439355, 0.7547255633178944, 0.7801367250382394, 0.7026626616576352, 0.7312688357928663, 0.8077273404343573, 0.7689779767357602, 0.3287216367308825, 0.34629079765275017, 0.3558173413594832, 0.38458768123680453, 0.31456581926643423, 0.37275909870342394, 0.3405627644022744, 0.28684300089464976, 0.2741076106247827, 0.8326076883032029, 0.7908877205591767, 0.7530262121193014, 0.8198708657428229, 0.8159131800968609, 0.8608442461454072, 0.7741682102481471, 0.7765167778091191, 0.8288777803508961, 0.17073374784801232, 0.15042263829736313, 0.14655732037247782, 0.18993505126361743, 0.17656491749954295, 0.3164187204432476, 0.1654622571400186, 0.2013292891252101, 0.16595776806802753, 0.22744471990990844, 0.16318275381415548, 0.19852610704691154, 0.1730945656227625, 0.15141415308964457, 0.1864793912264634, 0.15193767047931417, 0.20707170595809843, 0.1567157350505053, 0.3720269338638512, 0.35672160650407203, 0.23482472428452084, 0.394727969389872, 0.35207124577372695, 0.11315452168328843, 0.15872603887299896, 0.19405336629587366, 0.39932553215905997, 0.5338718136689615, 0.5240128492990992, 0.49751431444550087, 0.14474785028643056, 0.4525544524155546, 0.42363681879893444, 0.5666847366364158, 0.5269048189773338, 0.3760040823018497, 0.17751451201422752, 0.20783474444349526, 0.15611026722339394, 0.12125809757732642, 0.20016440258087564, 0.14845922273165946, 0.17039191979457446, 0.18139532891415033, 0.17816988623811902, 0.3518113161569718, 0.32541072451955744, 0.3249128925398954, 0.34243232054898776, 0.3631641607114027, 0.36569324890454635, 0.3463444106829512, 0.3008141520728841, 0.32646101459658095, 0.7446433987222089, 0.727860943030578, 0.7529514302963098, 0.7160195066994646, 0.7278725933426502, 0.7001273432724635, 0.7305985242257649, 0.7241836272872537, 0.7325345024743798, 0.14348919397284865, 0.14622768372309625, 0.11769938203533059, 0.1322615049838025, 0.13590132995922144, 0.11859848520866179, 0.12934306021513753, 0.13367639737799542, 0.13956872947798127, 0.1770149950281893, 0.19846919149837927, 0.16550780629801376, 0.17174764941113752, 0.16002732192667501, 0.15784852948053363, 0.164677818342289, 0.17409227633840108, 0.1896459721800744, 0.4641586445000476, 0.43545146259800793, 0.4941649815163489, 0.4780543095263905, 0.46289658082388285, 0.4778288986881929, 0.5047971986091611, 0.5144932343608539, 0.512250312589277, 0.3518249928927466, 0.32862554348693174, 0.3482635113917413, 0.34282350250433136, 0.3366773377998491, 0.3719837475880986, 0.3672937879627408, 0.3770686224142019, 0.34438901355675866, 0.20976070201201402, 0.2146650942975058, 0.2320510250940988, 0.2319376997532162, 0.22301333938397883, 0.21696001932721531, 0.2272534612883651, 0.23993895725511583, 0.22495230988982617, 0.19537190640148094, 0.19623582001312156, 0.1916061439064587, 0.2745088865079176, 0.24027089908820898, 0.19820379720282555, 0.21662406653834088, 0.19615906746192557, 0.2067432780958851, 0.18522752054726954, 0.7822195855713745, 0.6684514435523896, 0.7379104691238723, 0.7510851603615101, 0.7535934904523407, 0.6144293851820477, 0.6627744143029957, 0.7471290230137553, 0.7496215291569311, 0.3625187745913425, 0.7702983821308191, 0.3530538527448406, 0.5024653175454621, 0.20577443294908415, 0.2279331149319591, 0.7543967721704408, 0.1665800901794222, 0.19447055635969068, 0.17528342236489025, 0.19705860373000794, 0.20801830046236114, 0.20123556477019233, 0.19684670909477175, 0.19334721377235742, 0.19212016093716489, 0.18077988375186926, 0.08975388178033994, 0.09420059722004592, 0.09476340182694853, 0.08846259255172662, 0.0926469359149249, 0.08831167685332653, 0.08671236992902809, 0.10459792258991807, 0.1012700084310616]}, "mutation_prompt": null}
{"id": "7ab7772e-51a8-453e-94f5-871777613dc0", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Enhanced strategic mutation with feedback adjustment\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.15 * self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control with feedback\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveDualPhaseDifferentialEvolution", "description": "Adaptive Dual-Phase Differential Evolution that integrates strategic mutation, dynamic local search, and diversity rebalance with feedback mechanisms for enhanced convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.8598955202290018, 0.8616594449857364, 0.8572506210644175, 0.8473590683431149, 0.842086265004254, 0.8555103373146736, 0.8595970147140798, 0.8514555741315436, 0.8499840669579848, 0.7370865980733468, 0.7316018770249493, 0.7484547807804844, 0.7315492060187176, 0.7206538392397789, 0.7343984634693022, 0.7403969283695472, 0.7517573371478008, 0.7294526087554171, 0.19152050494654616, 0.12454085038993035, 0.1495493877634272, 0.12459219386584341, 0.13634490652504794, 0.1481049282400514, 0.13432484647810072, 0.1293019361022758, 0.14757454418045435, 0.122342518112321, 0.1209434968260672, 0.11841387873797848, 0.10211403908798145, 0.11643353087603625, 0.10433676591488406, 0.11870839193793414, 0.11597305019876891, 0.11595082037058069, 0.8383354516284651, 0.8225143937568133, 0.7299913083747736, 0.8459750459642306, 0.7456848200775029, 0.760717323520778, 0.8235068776225777, 0.8363681866734549, 0.8556543530987102, 0.4837586049490187, 0.5628672193707285, 0.4310711096781682, 0.4004504658734457, 0.5172600926123634, 0.5733852933543091, 0.5138517582171027, 0.4048640883768009, 0.479107678413341, 0.8521816006333705, 0.8423473770827983, 0.7959856656808892, 0.8396140388101023, 0.8458444998276514, 0.8515098524342405, 0.784767362676888, 0.8409310389223834, 0.8161617334621245, 0.17202941018574747, 0.16614780778444183, 0.15367523871893407, 0.19773148777871752, 0.22465513090036748, 0.20851487654439071, 0.15766071387111735, 0.25316139843055485, 0.21124224180572615, 0.14602589905943164, 0.16600484892615008, 0.15688760321747863, 0.17040376605842067, 0.17206024959979005, 0.17388582860362645, 0.1613783287740882, 0.19566921383186064, 0.16480844301752573, 0.5748410768700215, 0.5742675245091251, 0.5658440583064221, 0.5950379521168994, 0.6071472679947699, 0.594836751803888, 0.6034234036919384, 0.5645657887561399, 0.5761118532278752, 0.6732547888556879, 0.6805298853510346, 0.6587314094601813, 0.5797826319747563, 0.6352062845089304, 0.6392730638691542, 0.711841349776916, 0.6872829920973851, 0.6720702144670696, 0.13442857957866872, 0.12435599186599033, 0.2768883086813855, 0.43732930592028496, 0.3662450959644187, 0.1935098327782523, 0.21899744519109565, 0.17707544999008695, 0.2567047423949419, 0.44590076386688826, 0.4596615069203517, 0.42716411632060847, 0.45372876551000163, 0.5108313166968093, 0.4790675340234807, 0.4612481636794893, 0.45077553340056264, 0.4487736759020333, 0.7944192339105325, 0.8160584979312793, 0.8107822479975004, 0.7822641998982919, 0.7907039259888127, 0.784350547929036, 0.7962542906102453, 0.8013926127081629, 0.799967705779381, 0.14193616628616423, 0.12910624813267113, 0.12943422827120488, 0.15396515167484615, 0.140337582776222, 0.14551474276785303, 0.12636743645334558, 0.12286963860517774, 0.1481207171105574, 0.17427088557880543, 0.15701705763678087, 0.18620137019013172, 0.21715366538227965, 0.1787255081042236, 0.19022900590837566, 0.27398799414483765, 0.2572352065724888, 0.1971096705586547, 0.506988849910473, 0.49184501078474074, 0.5279976516505778, 0.511963231864804, 0.5096186477930558, 0.5072540236398608, 0.5160498656812706, 0.5223443365390561, 0.5376602584103969, 0.38929562801546547, 0.3610330108042984, 0.40340573874649344, 0.33761397540147686, 0.36733159370307267, 0.3579525548364221, 0.40291499007092857, 0.4058296837766999, 0.41877807350635987, 0.2036507931254916, 0.21512696816114174, 0.21673942925490175, 0.21131334084222486, 0.19177277822023076, 0.20912141917648963, 0.23315703056552806, 0.2173035188572564, 0.22493763090884566, 0.1935782984235459, 0.21915321386321307, 0.20866839773959367, 0.23578610183530357, 0.20042515603199196, 0.22510307800785478, 0.212964523748696, 0.19778517157237052, 0.2157840052954344, 0.1872141949519388, 0.18141538502223598, 0.19254990066933464, 0.7399266906016644, 0.19436865778836243, 0.8258570173187958, 0.8430784038022697, 0.7395738030440672, 0.6300267041952123, 0.8387552047435335, 0.4072823229490268, 0.784797697487442, 0.6988408481837437, 0.25170877850420026, 0.7516770366146411, 0.20648323726970674, 0.7014140421680128, 0.3509785935151283, 0.19017688368783037, 0.18063680411697136, 0.21269254198518572, 0.19406618463572334, 0.18337401652007412, 0.18558169206006958, 0.1867416593884691, 0.1896274229175614, 0.2048722809147152, 0.09159955764735206, 0.08377830775801265, 0.08535744849343607, 0.07821382471645089, 0.08995650215590589, 0.08091602150690891, 0.09818733668380286, 0.08339222136814184, 0.08146225091858705]}, "mutation_prompt": null}
{"id": "25a68558-3ed2-4860-925c-cd37cc1d040f", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Quantum-inspired mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * np.sin(np.pi * (b - c + d - a)), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Strategic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(4 + int(0.1 * self.dim)):  # adjusted local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.03, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                diversity_factor = np.std(population, axis=0)\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim)) * diversity_factor\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "QuantumInspiredAdaptiveDualPhaseDifferentialEvolution", "description": "Quantum-Inspired Adaptive Dual-Phase Differential Evolution combining quantum-inspired mutations, strategic local intensification, and adaptive diversity management.", "configspace": "", "generation": 92, "fitness": 0.24012229769923082, "feedback": "The algorithm QuantumInspiredAdaptiveDualPhaseDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.5364824528594396, 0.49769913548809996, 0.5338365621582163, 0.5108336063520054, 0.4977552451530224, 0.5299176769780012, 0.5479329936891391, 0.5594919071289789, 0.4717826395278696, 0.08867052785381635, 0.09054860184088664, 0.08736969280706586, 0.08112108400371765, 0.07791209279060918, 0.0712654898313766, 0.10311302518505439, 0.07630979016072925, 0.08902011857329906, 0.12217362383290908, 0.11656649171537514, 0.11778660581005729, 0.1805373402822812, 0.09657573342080505, 0.13104707414017835, 0.15894175173905423, 0.1401830280238071, 0.1339422015465298, 0.09872914450084136, 0.10574995472084225, 0.12785793355489183, 0.1339058318778361, 0.1142130041167575, 0.12402026591949722, 0.09265233411189089, 0.11544973134617653, 0.1363384851241266, 0.8990190822830593, 0.9178537776920461, 0.8957711968778082, 0.9582893357523236, 0.9106896284365679, 0.915375953969822, 0.9191688470908347, 0.9632216489563115, 0.9401265651506798, 0.3260955114657791, 0.3299151561209088, 0.32338490528379304, 0.3449974785654464, 0.3070291773110181, 0.334751325853606, 0.3132378718810035, 0.3503383940312974, 0.31529703567014533, 0.3524265291166947, 0.3425731934417128, 0.32086257645232286, 0.7106496335418528, 0.32312162497121266, 0.3557240618648957, 0.27232507037891185, 0.3025786981207659, 0.3223000556293102, 0.2246748309806037, 0.19645669232801977, 0.17456711727421537, 0.10773222338247213, 0.19467025361629497, 0.15988675100108207, 0.18160358700228751, 0.1817643905738794, 0.14786043854211217, 0.2105652836718923, 0.13507139153414316, 0.17653762054048183, 0.1518377863528011, 0.15179601947329624, 0.1373511533179742, 0.144741417808104, 0.20343583245929298, 0.16105251315343105, 0.041848986511951125, 9.999999999998899e-05, 9.999999999998899e-05, 0.02758336139819839, 0.01237032568526808, 0.016041991288985757, 0.05051616404398829, 0.006506577446080852, 0.007714193185316298, 0.0915597141694241, 0.0543316264329845, 0.12414436407127483, 0.06475715197075771, 0.03915392512824878, 0.08432188919659889, 0.04743555483276707, 0.08929646000174307, 0.06383412783918652, 9.999999999998899e-05, 0.02070736814202878, 9.999999999998899e-05, 0.009924422918394682, 0.019456876353661223, 0.017753184468905614, 0.024669070055036935, 0.0031319205735362843, 9.999999999998899e-05, 0.09384672422016371, 0.13741001046917134, 0.12827998573485944, 0.11106815846849694, 0.14171022715139403, 0.1070607302900547, 0.09983955889514218, 0.10605599669886923, 0.11967054572694957, 0.41635717419461893, 0.4419656430810027, 0.43247117910203303, 0.442054181223391, 0.44156511450405034, 0.41680296972996744, 0.43523510411674493, 0.44829505124026603, 0.42127777390331567, 0.12394368640526987, 0.13481531313678874, 0.12177310755375348, 0.1236529630819263, 0.12709885569689672, 0.16970413778127658, 0.13509333542540247, 0.1324187048430997, 0.14085759879315518, 0.19042394079098746, 0.27882989367341193, 0.22274096114654063, 0.1894979396742963, 0.26608558385746506, 0.21219378101955, 0.21184297196985535, 0.19696587503241902, 0.2278060728049438, 0.2848672440425942, 0.27698357679531793, 0.25679130074863543, 0.257472344541954, 0.32886249647616117, 0.278160293396141, 0.28610693906151163, 0.3059354809053382, 0.2843241787630377, 0.22132501282176764, 0.23740083912853205, 0.2620944200107964, 0.23419315283054876, 0.23138049328518961, 0.2625630977142338, 0.23908499474866707, 0.24256001038610142, 0.24325123223186929, 0.21350091194074827, 0.21803524975194777, 0.21610187728094366, 0.22058973300421425, 0.20623638313469306, 0.1903341813827052, 0.22201461062726002, 0.1995399826942933, 0.24495208797634982, 0.19593838271411979, 0.19623955490552547, 0.18389579726160277, 0.19547735484338202, 0.2025000969046591, 0.22529437094104554, 0.19099017542327523, 0.18418920584026566, 0.18951556672936198, 0.18465842029474155, 0.184910758068086, 0.7596942324099017, 0.7088554592853493, 0.20999794745032185, 0.17256739793236686, 0.16454744557797363, 0.14221322950020165, 0.730276001179476, 0.5080539729904796, 0.21078384622650337, 0.5531832948737705, 0.20247082571183528, 0.43614781609947173, 0.4037752500628138, 0.49320346831967776, 0.3840250920914654, 0.15308591866063948, 0.19020597952591156, 0.18500159808992678, 0.18783353513818746, 0.1802535467909041, 0.181911555167239, 0.18170148073453574, 0.18781221065976528, 0.18965563946645603, 0.19582969622775404, 0.08865417171766365, 0.0915695494304759, 0.08153996259215457, 0.08156455949570696, 0.0907888369032338, 0.09653877735654093, 0.0843408293346185, 0.08262647224044706, 0.08670196994290924]}, "mutation_prompt": null}
{"id": "e926bdfe-7649-45cc-baae-2ef88c72f07a", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Enhanced strategic mutation with feedback adjustment\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.15 * self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control with feedback\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveDualPhaseDifferentialEvolution", "description": "Adaptive Dual-Phase Differential Evolution that integrates strategic mutation, dynamic local search, and diversity rebalance with feedback mechanisms for enhanced convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.8598955202290018, 0.8616594449857364, 0.8572506210644175, 0.8473590683431149, 0.842086265004254, 0.8555103373146736, 0.8595970147140798, 0.8514555741315436, 0.8499840669579848, 0.7370865980733468, 0.7316018770249493, 0.7484547807804844, 0.7315492060187176, 0.7206538392397789, 0.7343984634693022, 0.7403969283695472, 0.7517573371478008, 0.7294526087554171, 0.19152050494654616, 0.12454085038993035, 0.1495493877634272, 0.12459219386584341, 0.13634490652504794, 0.1481049282400514, 0.13432484647810072, 0.1293019361022758, 0.14757454418045435, 0.122342518112321, 0.1209434968260672, 0.11841387873797848, 0.10211403908798145, 0.11643353087603625, 0.10433676591488406, 0.11870839193793414, 0.11597305019876891, 0.11595082037058069, 0.8383354516284651, 0.8225143937568133, 0.7299913083747736, 0.8459750459642306, 0.7456848200775029, 0.760717323520778, 0.8235068776225777, 0.8363681866734549, 0.8556543530987102, 0.4837586049490187, 0.5628672193707285, 0.4310711096781682, 0.4004504658734457, 0.5172600926123634, 0.5733852933543091, 0.5138517582171027, 0.4048640883768009, 0.479107678413341, 0.8521816006333705, 0.8423473770827983, 0.7959856656808892, 0.8396140388101023, 0.8458444998276514, 0.8515098524342405, 0.784767362676888, 0.8409310389223834, 0.8161617334621245, 0.17202941018574747, 0.16614780778444183, 0.15367523871893407, 0.19773148777871752, 0.22465513090036748, 0.20851487654439071, 0.15766071387111735, 0.25316139843055485, 0.21124224180572615, 0.14602589905943164, 0.16600484892615008, 0.15688760321747863, 0.17040376605842067, 0.17206024959979005, 0.17388582860362645, 0.1613783287740882, 0.19566921383186064, 0.16480844301752573, 0.5748410768700215, 0.5742675245091251, 0.5658440583064221, 0.5950379521168994, 0.6071472679947699, 0.594836751803888, 0.6034234036919384, 0.5645657887561399, 0.5761118532278752, 0.6732547888556879, 0.6805298853510346, 0.6587314094601813, 0.5797826319747563, 0.6352062845089304, 0.6392730638691542, 0.711841349776916, 0.6872829920973851, 0.6720702144670696, 0.13442857957866872, 0.12435599186599033, 0.2768883086813855, 0.43732930592028496, 0.3662450959644187, 0.1935098327782523, 0.21899744519109565, 0.17707544999008695, 0.2567047423949419, 0.44590076386688826, 0.4596615069203517, 0.42716411632060847, 0.45372876551000163, 0.5108313166968093, 0.4790675340234807, 0.4612481636794893, 0.45077553340056264, 0.4487736759020333, 0.7944192339105325, 0.8160584979312793, 0.8107822479975004, 0.7822641998982919, 0.7907039259888127, 0.784350547929036, 0.7962542906102453, 0.8013926127081629, 0.799967705779381, 0.14193616628616423, 0.12910624813267113, 0.12943422827120488, 0.15396515167484615, 0.140337582776222, 0.14551474276785303, 0.12636743645334558, 0.12286963860517774, 0.1481207171105574, 0.17427088557880543, 0.15701705763678087, 0.18620137019013172, 0.21715366538227965, 0.1787255081042236, 0.19022900590837566, 0.27398799414483765, 0.2572352065724888, 0.1971096705586547, 0.506988849910473, 0.49184501078474074, 0.5279976516505778, 0.511963231864804, 0.5096186477930558, 0.5072540236398608, 0.5160498656812706, 0.5223443365390561, 0.5376602584103969, 0.38929562801546547, 0.3610330108042984, 0.40340573874649344, 0.33761397540147686, 0.36733159370307267, 0.3579525548364221, 0.40291499007092857, 0.4058296837766999, 0.41877807350635987, 0.2036507931254916, 0.21512696816114174, 0.21673942925490175, 0.21131334084222486, 0.19177277822023076, 0.20912141917648963, 0.23315703056552806, 0.2173035188572564, 0.22493763090884566, 0.1935782984235459, 0.21915321386321307, 0.20866839773959367, 0.23578610183530357, 0.20042515603199196, 0.22510307800785478, 0.212964523748696, 0.19778517157237052, 0.2157840052954344, 0.1872141949519388, 0.18141538502223598, 0.19254990066933464, 0.7399266906016644, 0.19436865778836243, 0.8258570173187958, 0.8430784038022697, 0.7395738030440672, 0.6300267041952123, 0.8387552047435335, 0.4072823229490268, 0.784797697487442, 0.6988408481837437, 0.25170877850420026, 0.7516770366146411, 0.20648323726970674, 0.7014140421680128, 0.3509785935151283, 0.19017688368783037, 0.18063680411697136, 0.21269254198518572, 0.19406618463572334, 0.18337401652007412, 0.18558169206006958, 0.1867416593884691, 0.1896274229175614, 0.2048722809147152, 0.09159955764735206, 0.08377830775801265, 0.08535744849343607, 0.07821382471645089, 0.08995650215590589, 0.08091602150690891, 0.09818733668380286, 0.08339222136814184, 0.08146225091858705]}, "mutation_prompt": null}
{"id": "a42710ea-98e9-4988-af1a-a2ccce6a8f7b", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolutionWithLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 60)  # adjusted for better exploration\n        self.F = 0.7  # adjusted differential weight\n        self.CR = 0.85  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution with Learning\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with learning\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                F = self.F * (0.5 + fitness[indices][0] / (fitness[indices][1] + 1))  # adaptive learning F\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Enhanced Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(2 + int(0.2 * self.dim)):  # enhanced local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.04, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.3 * self.budget and len(population) < 2.0 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "DynamicAdaptiveDifferentialEvolutionWithLearning", "description": "Dynamic Adaptive Differential Evolution with Learning (DADEL) that integrates learning-based differential adaptation, local search intensification, and diversity management for improved solution robustness.", "configspace": "", "generation": 94, "fitness": 0.21706203912083138, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolutionWithLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.4626067206457597, 0.4048874659106575, 0.39811257000156586, 0.46747263938169914, 0.43880855054243484, 0.4584276350917056, 0.44797470675687134, 0.45170538452717024, 0.4273689791041594, 0.2023106720233322, 0.22024029764433417, 0.21321452254972106, 0.23013886147765383, 0.1917833056261754, 0.20827687478755064, 0.22004234435513448, 0.210732203504163, 0.22301419020141988, 0.09959287974985687, 0.10399931934823203, 0.11680016085176581, 0.11971115779905561, 0.11075093757837817, 0.10161399578593067, 0.09532171390682687, 0.11048148825306858, 0.1120993362980629, 0.10072058563597674, 0.09896038559263487, 0.08892713015662468, 0.0903930040889609, 0.08587921512696994, 0.11254016452797644, 0.07179293291530997, 0.08310034951186174, 0.08890720146258535, 0.9760422154729209, 0.9747065373624864, 0.9683746856081249, 0.965395192059321, 0.9618290206764628, 0.9503079540950045, 0.9537676344129952, 0.9741950787628325, 0.991620731787503, 0.204280130864553, 0.24394479632487376, 0.21375343884043618, 0.20050067211290612, 0.2276015182281591, 0.23948493828347306, 0.22840443089295026, 0.2609972466432334, 0.229846716572786, 0.26508198093685975, 0.20782070487875182, 0.1807363977790919, 0.30707655952914215, 0.24682174829840442, 0.25418144029663614, 0.31243440036157666, 0.3112463251148674, 0.3763989415017127, 0.14439620182108592, 0.20030592691813287, 0.1431398688756017, 0.13730786118340366, 0.15946191126543507, 0.14067874747565745, 0.13442144655516353, 0.13782076426828793, 0.14884462274496968, 0.1087799967299623, 0.1430922753440016, 0.1430149015028641, 0.16841945358136057, 0.17368127249310894, 0.1523221083373354, 0.1467202277112667, 0.13528978831335714, 0.16328384386442119, 0.0804844396042621, 0.07462919457067241, 0.09191293876737183, 0.06570801655541714, 0.06136686004300751, 0.08065809501942445, 0.07656198651635782, 0.07882765312221496, 0.06976503429287617, 0.1551652204036782, 0.12332233150847005, 0.14567303786671748, 0.19962699393078975, 0.20836393215129678, 0.19301841229154426, 0.21011799206556225, 0.16909248171787117, 0.19009768069401523, 0.035215998100944446, 0.03661908643339973, 0.016379567228893777, 0.029080081213871734, 0.03901526858719484, 0.05404496516717683, 0.014364818488454278, 0.015210078595632726, 0.019277885965360064, 0.08553511648775636, 0.08056959301343236, 0.0819579612817859, 0.11195655673637939, 0.10123936662663346, 0.1116122749016778, 0.0966491787914916, 0.12855308238829088, 0.09230395395564739, 0.3852565664622172, 0.3582414605738079, 0.3746429636684455, 0.36476991752076615, 0.37454936182805554, 0.3414439907014306, 0.39450952370352, 0.3597460050082051, 0.3746956103533967, 0.09659929113592058, 0.11895554161282729, 0.08271303543201225, 0.08237973624127026, 0.1015510853047199, 0.07405842041682864, 0.11485857982479264, 0.12095788951186293, 0.11594457068910613, 0.22968095085880436, 0.14384918736681374, 0.15928857596565815, 0.1765673684494533, 0.2378367011394431, 0.1883797792007358, 0.1806150158001425, 0.16327058875380973, 0.2721110129077676, 0.23694390640962337, 0.20383156622470577, 0.21981209073772, 0.20639548192514634, 0.21385724897885616, 0.19110717082527384, 0.2507670630938169, 0.2451965681754531, 0.22665029875010878, 0.19084296010564072, 0.19441540233973753, 0.20657717345686566, 0.15197672865243328, 0.1535617418771582, 0.16518729041798674, 0.1599295930764898, 0.17357231981167298, 0.18116518715843832, 0.20587344627951143, 0.17636940345691365, 0.17578332959669263, 0.1725404376457964, 0.16490532798118862, 0.18231948580899549, 0.18562424846066583, 0.18794546761293363, 0.1738738563886083, 0.19126625999771263, 0.17479160102200209, 0.1913431151090913, 0.19677729674465794, 0.17903935882964905, 0.18331725004454225, 0.18606900588901532, 0.18356371123528548, 0.19622586419371535, 0.516007786820917, 0.38987669789842105, 0.17738829696534686, 0.18345005438668804, 0.19531964183630468, 0.17251027489169923, 0.18309733530171457, 0.1717465051949394, 0.20549814457035265, 0.3622390928759093, 0.4172091554490729, 0.19740184199830124, 0.24498484629603312, 0.16137910088350704, 0.2824156792597484, 0.20492995676135695, 0.367085422403312, 0.20546737385957992, 0.19611047902746936, 0.1980073217782803, 0.2054848041254146, 0.20917225233478198, 0.213495394149957, 0.18693897337797105, 0.18587088502503213, 0.18824641159748112, 0.1822050440059646, 0.06558855108991901, 0.0871262939859927, 0.06985371451914957, 0.05643395269817697, 0.06468581641932392, 0.06814438397674094, 0.06938500124504299, 0.0634563106134316, 0.06977698923969378]}, "mutation_prompt": null}
{"id": "76f2d670-d1dd-4fdb-9abd-d13761880afc", "solution": "import numpy as np\n\nclass SwarmInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive swarm-inspired population size\n        self.F = 0.7  # adaptive differential weight\n        self.CR = 0.8  # crossover probability\n        self.alpha = 0.05  # local search step size\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Swarm-inspired Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation with swarm feedback\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.5, 0.9)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(int(0.1 * self.dim) + 2):  # adjusted local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, self.alpha, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control\n            if evals < 0.4 * self.budget and len(population) < 3 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (2, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "SwarmInspiredAdaptiveDE", "description": "Swarm-Inspired Adaptive Differential Evolution with Integrated Adaptive Mutation and Dynamic Local Search for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 95, "fitness": 0.3289248674218539, "feedback": "The algorithm SwarmInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.7961526170513549, 0.8015230003573759, 0.78682623132059, 0.795511125120681, 0.7918102728573814, 0.8041720334104963, 0.7961215653329041, 0.796425879138865, 0.7887934145324662, 0.6310825081122101, 0.6254720763089086, 0.6107974126511342, 0.6123763245685935, 0.6161858025492133, 0.6382863091137907, 0.6490953377050708, 0.6204775491171175, 0.6256858025498591, 0.13141186957031836, 0.13902939552975402, 0.1327191789007991, 0.1316088637026276, 0.11927480599374451, 0.12490031550797853, 0.12216203580189844, 0.13349894055173006, 0.12611726012612312, 0.12373388712464384, 0.11243963393333145, 0.11469001341194529, 0.12474540479263341, 0.10956300045726841, 0.12529652822310744, 0.10845085832252899, 0.12224585303871993, 0.1131564258439115, 0.9738148042293933, 0.8823667222900359, 0.9014142168370862, 0.8790604862829559, 0.8898957353733254, 0.8989653053143907, 0.9268324095549046, 0.8789463156084317, 0.9127944962128831, 0.4035610079580396, 0.40720711038469004, 0.4128661563775854, 0.4250684834201499, 0.4000912196798908, 0.4021990873034943, 0.4329288174431598, 0.38768012277732533, 0.416020194867913, 0.6482735728095894, 0.6806807148192291, 0.6030468537884549, 0.7262344024374415, 0.7229856761018897, 0.6723349779631465, 0.6775947321447338, 0.6923675754554106, 0.6543630566357271, 0.2576871531876498, 0.22896055798814974, 0.20927669635829416, 0.193383915059968, 0.2877200514105037, 0.17765898243787215, 0.23864612573635235, 0.27010892513937024, 0.20641514106342407, 0.19595024042556575, 0.1826828975487168, 0.19362289674515654, 0.21782237462921916, 0.17764137643638156, 0.23580275567022346, 0.2520518061219229, 0.26806472243643864, 0.2124472697608265, 0.17528099106127504, 0.1716975811857303, 0.1373190674674546, 0.19715664834053337, 0.1764584467617607, 0.14796259976099213, 0.19551781284790792, 0.18942487319873047, 0.1597699330490635, 0.3201839768549771, 0.30525384122649024, 0.30596694780238654, 0.3015676359351406, 0.2871907532251431, 0.2720441819321229, 0.34328572571367566, 0.36103352129170496, 0.3012153811083049, 0.04190368139217715, 0.09005707533677199, 0.058767107168954724, 0.11386898157855341, 0.09941600241168524, 0.09338546992324614, 0.08307068410118112, 0.06274905427434152, 0.061592815307488835, 0.20863423752620824, 0.20443420773449805, 0.20829560302929806, 0.23574174533943482, 0.23387392540561924, 0.24438290668586005, 0.1981049935006034, 0.21938683134165438, 0.2054902109470318, 0.6049492187260781, 0.5988932700761611, 0.629495306362605, 0.581742224250714, 0.5881410228593001, 0.5969310476340004, 0.6269914214627477, 0.5741045502715285, 0.6077057192579189, 0.12951253796725126, 0.12074835757947278, 0.17101850454406864, 0.13675918735248505, 0.11690654700049596, 0.1195710397487817, 0.11271977405021771, 0.11926909255016649, 0.1169811215194797, 0.20282902147432236, 0.20492370537736382, 0.1583220787510261, 0.15810004351136253, 0.16419863579143856, 0.21332909751075102, 0.14625408912208893, 0.21100767250442842, 0.20390146338312853, 0.3266588861176385, 0.37539742567937295, 0.3698325670170557, 0.36560989034772173, 0.3575332625660671, 0.36959041558058026, 0.3828669976698318, 0.36892941507992427, 0.3795506984949938, 0.2540693203387321, 0.26367566113328456, 0.2629602637284474, 0.26041779228142004, 0.27057382571636335, 0.24106596272907033, 0.2797904592940965, 0.2663959807723886, 0.2681832552284812, 0.2023865719831892, 0.20323175297271368, 0.20025820574350062, 0.2008975369323609, 0.22081118074078643, 0.19992631279387207, 0.1949444443850633, 0.1875483617712982, 0.19318766830537293, 0.20808447383109596, 0.21922395608621925, 0.2118097228077942, 0.26683428004687804, 0.19674791525222313, 0.230147537396443, 0.18803628117564775, 0.2011768690303012, 0.19830160253510642, 0.18431451349399153, 0.4947877713848289, 0.2945242449409182, 0.2939515895025998, 0.695538384824725, 0.6840009453757876, 0.5878110668637863, 0.4712063566687684, 0.5269581831545032, 0.4483205815555744, 0.2651092196793726, 0.4413746154210222, 0.2875023147345994, 0.2408326741649086, 0.3886834849647752, 0.205507364970546, 0.392788562939143, 0.20557801712742052, 0.18338720798076447, 0.17682347136819077, 0.189684183192249, 0.1829233661589762, 0.18595134832583926, 0.1897868323330606, 0.18236319609983498, 0.18097384445404718, 0.18915512172624627, 0.08398431833657638, 0.07384203134144629, 0.08243858328524933, 0.08410494774943633, 0.0881577838341766, 0.07790699296618309, 0.08558938866927024, 0.0907711303189539, 0.08031209238156711]}, "mutation_prompt": null}
{"id": "0652069c-9a1d-47b1-8d99-6961e0887e7e", "solution": "import numpy as np\n\nclass AdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 60)  # slightly increased adaptive population size\n        self.F = 0.5  # differential weight adjusted for balance\n        self.CR = 0.8  # crossover probability slightly reduced for exploration\n        self.w = 0.5  # inertia weight for PSO influence\n        self.c1 = 1.5  # cognitive (self) component\n        self.c2 = 1.5  # social component\n\n    def __call__(self, func):\n        # Initialize population and velocities\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n        pbest = population.copy()\n        pbest_fitness = fitness.copy()\n        gbest_idx = np.argmin(fitness)\n        gbest = population[gbest_idx].copy()\n\n        while evals < self.budget:\n            # Differential Evolution Phase with PSO influence\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                F_dynamic = self.F if np.random.rand() < 0.6 else np.random.uniform(0.4, 0.9)\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n\n                # PSO Update\n                velocities[i] = self.w * velocities[i] + \\\n                                self.c1 * np.random.rand(self.dim) * (pbest[i] - population[i]) + \\\n                                self.c2 * np.random.rand(self.dim) * (gbest - population[i])\n                trial = np.clip(trial + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    pbest[i] = trial\n                    pbest_fitness[i] = trial_fitness\n                    if trial_fitness < fitness[gbest_idx]:\n                        gbest_idx = i\n                        gbest = trial\n\n            # Dynamic Local Search Phase\n            for _ in range(4 + int(0.1 * self.dim)):\n                if evals >= self.budget:\n                    break\n\n                potential_neighbor = gbest + np.random.normal(0, 0.05, self.dim)\n                potential_neighbor = np.clip(potential_neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(potential_neighbor)\n                evals += 1\n\n                if neighbor_fitness < pbest_fitness[gbest_idx]:\n                    gbest = potential_neighbor\n                    pbest_fitness[gbest_idx] = neighbor_fitness\n\n            # Adaptive Diversity Enhancement\n            if evals < 0.6 * self.budget and len(population) < 2 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        return gbest", "name": "AdaptiveHybridDEPSO", "description": "Adaptive Hybrid Differential Evolution and Particle Swarm Optimization integrating feedback-driven mutation, dynamic local search, and adaptive diversity for robust convergence.", "configspace": "", "generation": 96, "fitness": 0.20892291780416644, "feedback": "The algorithm AdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.41449773006701074, 0.435136576945616, 0.43549696994398923, 0.4811742753243008, 0.4891488666158388, 0.48922304275482775, 0.4750733607306211, 0.43817858412296695, 0.4446161885097786, 0.1557876198430833, 0.15341984695490773, 0.1257777767930951, 0.14408604196755515, 0.1344212578911005, 0.17199750105469158, 0.13562597591115522, 0.1825568878267636, 0.15910389956196502, 0.10937477273983731, 0.08911145600524562, 0.09908487263654675, 0.1077314073157386, 0.09670863537862096, 0.08969286200913151, 0.10133063603947212, 0.11297528666773049, 0.09777462081657906, 0.08271497267314043, 0.08159615610393578, 0.07387963074561399, 0.0810254652949961, 0.09604947651494311, 0.06582829955948544, 0.051230861835277586, 0.11757493463216506, 0.06744857449421526, 0.9919538942196648, 0.9897459239421583, 0.9889432232931509, 0.9867110320089373, 0.9857337453476351, 0.9854798675290943, 0.9880896521350637, 0.9901359679655212, 0.9905581995845246, 0.22480990937473755, 0.26067672233177264, 0.2567311733092589, 0.30214193958041524, 0.21662215365002657, 0.30219608575060386, 0.2602779586685481, 0.2586729197988732, 0.26802279673288854, 0.2634965084885228, 0.20488711038727248, 0.18901609977053402, 0.23109931875635692, 0.2371992859016958, 0.2561805685269083, 0.23021406046409987, 0.27092195519926576, 0.22008168123298988, 0.14530974907678296, 0.1280645061289215, 0.12993814440536922, 0.12392622462646163, 0.1638055800427234, 0.09292961929501431, 0.15723616967160692, 0.14389183589475651, 0.16479455070770987, 0.09900806543468277, 0.11401961405537497, 0.24142235875629736, 0.12034677693069407, 0.17339155407822504, 0.17443167041461893, 0.10055956045224179, 0.16860675557869143, 0.08681358784599924, 9.999999999998899e-05, 9.999999999998899e-05, 0.005562577365363586, 0.003505379479649129, 9.999999999998899e-05, 9.999999999998899e-05, 0.001344685230275311, 9.999999999998899e-05, 9.999999999998899e-05, 0.07176222318224068, 0.05091639780634849, 0.06303901656538746, 0.05430469655444248, 0.0679787685240939, 0.07885938494147526, 0.04004257542063894, 0.06806709401927091, 0.03337770550379171, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09031743371832834, 0.07775514807778072, 0.07774667758544929, 0.0885558032012781, 0.10151205950420661, 0.10802668863391207, 0.07762695636304628, 0.08049533226037764, 0.1189753446946743, 0.36261645767234163, 0.3956809240646615, 0.4002500428953851, 0.37702306146533693, 0.4001360959842808, 0.4024580457459378, 0.34504209637100935, 0.40412862970511276, 0.37724864184604634, 0.10263668865443398, 0.08426609779226724, 0.08569685734544563, 0.14316812618025776, 0.07443533713028028, 0.08830329854702845, 0.09344195751508544, 0.06617216930804226, 0.08349511588988257, 0.14886743818981563, 0.1937176914948645, 0.2516000033779586, 0.2640711207514579, 0.2548942607218696, 0.19848371963726386, 0.22348212580662652, 0.17787703893974427, 0.16655383220639874, 0.24620619896691276, 0.2513059215937258, 0.214151553162367, 0.20845790903633066, 0.18180182409177614, 0.19414379033580176, 0.24585093346806697, 0.2634113736563045, 0.24416616793150425, 0.19079979330853747, 0.17318007434953797, 0.19344685777675674, 0.1738998586622874, 0.1847731046878165, 0.1694716751009604, 0.178496278373516, 0.19205471692645892, 0.19759339843803458, 0.1589648489528558, 0.15711775187991117, 0.1786405947892652, 0.17466281159508146, 0.16547160440884323, 0.1618008929824799, 0.1938833981100625, 0.16141512788207513, 0.15557080918246702, 0.18262852071332936, 0.19721335734507117, 0.17926942100801824, 0.17501595329129938, 0.19641845516522372, 0.17706177340863305, 0.20334389526834384, 0.18739976792373814, 0.1822138353558388, 0.6333934573278825, 0.47582029909706247, 0.2014787850163149, 0.44139906812234075, 0.51779067445471, 0.19303915395810844, 0.1720712115280143, 0.1730724943532317, 0.2038774305141947, 0.5260149102921687, 0.31879827319425447, 0.1683070155177151, 0.27333102914591567, 0.20098716958388885, 0.12352228567108015, 0.16342828878181426, 0.1995610592724979, 0.49188524713950443, 0.1825891325915987, 0.1864803004443133, 0.19489521237276453, 0.19936728932391568, 0.1885433901916993, 0.17469152012454925, 0.18093334742984102, 0.18930896983268564, 0.18683992952127992, 0.06430294918076851, 0.06625550187418505, 0.07851856607193897, 0.07419474609493248, 0.05559510264155365, 0.0710968011866282, 0.061336055226882125, 0.06036002134736085, 0.050389082643622185]}, "mutation_prompt": null}
{"id": "ba392215-b9f9-4d50-831b-d1c6450c3d41", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 50)  # adaptive population size\n        self.F = 0.6  # adjusted differential weight\n        self.CR = 0.9  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c, d = population[indices]\n                # Enhanced strategic mutation with feedback adjustment\n                F = self.F if np.random.rand() < 0.7 else np.random.uniform(0.4, 0.8)\n                mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Dynamic Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(3 + int(0.15 * self.dim)):  # increased local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.05, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Enhanced Adaptive Diversity Control with feedback\n            if evals < 0.5 * self.budget and len(population) < 2.5 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "AdaptiveDualPhaseDifferentialEvolution", "description": "Adaptive Dual-Phase Differential Evolution that integrates strategic mutation, dynamic local search, and diversity rebalance with feedback mechanisms for enhanced convergence.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.8598955202290018, 0.8616594449857364, 0.8572506210644175, 0.8473590683431149, 0.842086265004254, 0.8555103373146736, 0.8595970147140798, 0.8514555741315436, 0.8499840669579848, 0.7370865980733468, 0.7316018770249493, 0.7484547807804844, 0.7315492060187176, 0.7206538392397789, 0.7343984634693022, 0.7403969283695472, 0.7517573371478008, 0.7294526087554171, 0.19152050494654616, 0.12454085038993035, 0.1495493877634272, 0.12459219386584341, 0.13634490652504794, 0.1481049282400514, 0.13432484647810072, 0.1293019361022758, 0.14757454418045435, 0.122342518112321, 0.1209434968260672, 0.11841387873797848, 0.10211403908798145, 0.11643353087603625, 0.10433676591488406, 0.11870839193793414, 0.11597305019876891, 0.11595082037058069, 0.8383354516284651, 0.8225143937568133, 0.7299913083747736, 0.8459750459642306, 0.7456848200775029, 0.760717323520778, 0.8235068776225777, 0.8363681866734549, 0.8556543530987102, 0.4837586049490187, 0.5628672193707285, 0.4310711096781682, 0.4004504658734457, 0.5172600926123634, 0.5733852933543091, 0.5138517582171027, 0.4048640883768009, 0.479107678413341, 0.8521816006333705, 0.8423473770827983, 0.7959856656808892, 0.8396140388101023, 0.8458444998276514, 0.8515098524342405, 0.784767362676888, 0.8409310389223834, 0.8161617334621245, 0.17202941018574747, 0.16614780778444183, 0.15367523871893407, 0.19773148777871752, 0.22465513090036748, 0.20851487654439071, 0.15766071387111735, 0.25316139843055485, 0.21124224180572615, 0.14602589905943164, 0.16600484892615008, 0.15688760321747863, 0.17040376605842067, 0.17206024959979005, 0.17388582860362645, 0.1613783287740882, 0.19566921383186064, 0.16480844301752573, 0.5748410768700215, 0.5742675245091251, 0.5658440583064221, 0.5950379521168994, 0.6071472679947699, 0.594836751803888, 0.6034234036919384, 0.5645657887561399, 0.5761118532278752, 0.6732547888556879, 0.6805298853510346, 0.6587314094601813, 0.5797826319747563, 0.6352062845089304, 0.6392730638691542, 0.711841349776916, 0.6872829920973851, 0.6720702144670696, 0.13442857957866872, 0.12435599186599033, 0.2768883086813855, 0.43732930592028496, 0.3662450959644187, 0.1935098327782523, 0.21899744519109565, 0.17707544999008695, 0.2567047423949419, 0.44590076386688826, 0.4596615069203517, 0.42716411632060847, 0.45372876551000163, 0.5108313166968093, 0.4790675340234807, 0.4612481636794893, 0.45077553340056264, 0.4487736759020333, 0.7944192339105325, 0.8160584979312793, 0.8107822479975004, 0.7822641998982919, 0.7907039259888127, 0.784350547929036, 0.7962542906102453, 0.8013926127081629, 0.799967705779381, 0.14193616628616423, 0.12910624813267113, 0.12943422827120488, 0.15396515167484615, 0.140337582776222, 0.14551474276785303, 0.12636743645334558, 0.12286963860517774, 0.1481207171105574, 0.17427088557880543, 0.15701705763678087, 0.18620137019013172, 0.21715366538227965, 0.1787255081042236, 0.19022900590837566, 0.27398799414483765, 0.2572352065724888, 0.1971096705586547, 0.506988849910473, 0.49184501078474074, 0.5279976516505778, 0.511963231864804, 0.5096186477930558, 0.5072540236398608, 0.5160498656812706, 0.5223443365390561, 0.5376602584103969, 0.38929562801546547, 0.3610330108042984, 0.40340573874649344, 0.33761397540147686, 0.36733159370307267, 0.3579525548364221, 0.40291499007092857, 0.4058296837766999, 0.41877807350635987, 0.2036507931254916, 0.21512696816114174, 0.21673942925490175, 0.21131334084222486, 0.19177277822023076, 0.20912141917648963, 0.23315703056552806, 0.2173035188572564, 0.22493763090884566, 0.1935782984235459, 0.21915321386321307, 0.20866839773959367, 0.23578610183530357, 0.20042515603199196, 0.22510307800785478, 0.212964523748696, 0.19778517157237052, 0.2157840052954344, 0.1872141949519388, 0.18141538502223598, 0.19254990066933464, 0.7399266906016644, 0.19436865778836243, 0.8258570173187958, 0.8430784038022697, 0.7395738030440672, 0.6300267041952123, 0.8387552047435335, 0.4072823229490268, 0.784797697487442, 0.6988408481837437, 0.25170877850420026, 0.7516770366146411, 0.20648323726970674, 0.7014140421680128, 0.3509785935151283, 0.19017688368783037, 0.18063680411697136, 0.21269254198518572, 0.19406618463572334, 0.18337401652007412, 0.18558169206006958, 0.1867416593884691, 0.1896274229175614, 0.2048722809147152, 0.09159955764735206, 0.08377830775801265, 0.08535744849343607, 0.07821382471645089, 0.08995650215590589, 0.08091602150690891, 0.09818733668380286, 0.08339222136814184, 0.08146225091858705]}, "mutation_prompt": null}
{"id": "e7709f45-e534-416b-82ab-bcd84096c616", "solution": "import numpy as np\n\nclass DynamicSelfAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(6 * dim, 60)  # adaptive population size\n        self.F = 0.7  # initial differential weight, self-adaptive\n        self.CR = 0.8  # crossover probability\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Adaptive Differential Evolution Phase\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Mutation\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = population[indices]\n                # Adaptive mutation factor based on success history\n                F = 0.5 + np.random.rand() * 0.5 if np.std(fitness) > 0.1 else 0.4\n                mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n            \n            # Hybrid Local Search Phase\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(4 + int(0.12 * self.dim)):  # modified local search intensity\n                if evals >= self.budget:\n                    break\n\n                neighbor = best_individual + np.random.normal(0, 0.1, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Adaptive Diversity Control with feedback mechanism\n            if evals < 0.6 * self.budget and len(population) < 2.0 * self.population_size:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (4, self.dim))\n                new_fitness = np.array([func(ind) for ind in new_individuals])\n                evals += len(new_individuals)\n                population = np.vstack((population, new_individuals))\n                fitness = np.hstack((fitness, new_fitness))\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "DynamicSelfAdaptiveDE", "description": "Dynamic Self-Adaptive Differential Evolution with hybrid exploration-exploitation strategies utilizing adaptive mutation scaling and local perturbation.", "configspace": "", "generation": 98, "fitness": 0.2041610854317295, "feedback": "The algorithm DynamicSelfAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.4549810988213452, 0.4303002196237212, 0.4358323337941219, 0.48381638960513873, 0.4698149705021185, 0.4643449685075357, 0.46822656057867496, 0.4514548531467072, 0.4583715025215519, 0.15660926231772376, 0.1722168086424397, 0.16941483735638108, 0.19471712682270925, 0.14582436061037518, 0.16238599612760352, 0.1833259251704782, 0.1585728635443343, 0.18241679556170098, 0.10400674606153537, 0.1147846991846776, 0.08247953854196166, 0.09801471061006994, 0.09538127032926313, 0.10490909482349198, 0.08664596855079598, 0.09896744201811436, 0.11400696009533295, 0.08806988359415668, 0.09261915686990652, 0.0787277512937431, 0.07820064336068666, 0.08939984553630909, 0.09379078102412419, 0.0887395101476024, 0.0874393234266383, 0.08599939347666807, 0.8949125826013746, 0.9618986899699272, 0.9459768380241812, 0.9489724824812518, 0.953038862741954, 0.9485978081403141, 0.9626520344021533, 0.9733803116949706, 0.9407349477627438, 0.2601669035305686, 0.232879819303612, 0.23150491263492834, 0.2191282371250879, 0.21553443776797276, 0.2693099002512257, 0.2672760113428603, 0.24919576654083275, 0.265384132355314, 0.20792335136071693, 0.24980725148387017, 0.21080330347410237, 0.25844224595740983, 0.27076723237813516, 0.22491693456959305, 0.23252547789277223, 0.26242886471103544, 0.21187962859542964, 0.1700344023804231, 0.11979694404142849, 0.13773656297045234, 0.17200981784173108, 0.1190190121434378, 0.13062031434214627, 0.10851782726802484, 0.1671254109987267, 0.15991507802213567, 0.1395947082309874, 0.14364013240481832, 0.14484212964122378, 0.13894061721131823, 0.1920335898511295, 0.15203907110807136, 0.1180564367411413, 0.11005387327201643, 0.09411370466518332, 0.004821631214717126, 9.999999999998899e-05, 0.03223728978655305, 0.014993751271220379, 0.0072488472120009195, 0.017826073486646554, 9.999999999998899e-05, 0.002075855518563152, 0.01032099808332676, 0.0786761142976613, 0.08937711810915461, 0.08621304230727056, 0.09678446425803211, 0.08256477803762496, 0.08431942802871839, 0.09200306410680914, 0.12340978569993799, 0.10825200614136088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09749416934858013, 0.08224442992822423, 0.09267963303110793, 0.09297173375641066, 0.08962538678796605, 0.07618865474998071, 0.07477681840386263, 0.11007470884919224, 0.07567288837828579, 0.37124404917374276, 0.3991763795969211, 0.39050742398455496, 0.399538050840046, 0.3942689818352795, 0.39012676190308726, 0.39323465687491466, 0.37151677655139137, 0.3762963469549684, 0.08954180336250916, 0.07606983920049515, 0.08251806421675079, 0.0938670909213839, 0.07122640540359937, 0.09184760814738746, 0.08087241132310152, 0.08237606227297001, 0.11471166581139602, 0.1598662882218892, 0.19592275981551588, 0.1598294861290187, 0.1763321076958766, 0.21354419453978246, 0.17387298353110314, 0.14337422105804343, 0.2006640716888679, 0.16313115713860948, 0.22607168430933022, 0.2701118886581281, 0.24923964585083835, 0.2501557562047728, 0.20417297761928133, 0.21179058721251898, 0.23879851906855665, 0.24988139140000776, 0.25582903630008613, 0.17073445326177095, 0.17328940630087852, 0.1944308047302088, 0.15933509562316428, 0.1418610240449243, 0.1718773797677714, 0.16106191134900383, 0.20209493933671352, 0.17494834627210964, 0.17894531697263805, 0.19341567197261467, 0.18963692932876608, 0.18931233560882832, 0.20425673139626888, 0.15714758963813658, 0.193070709683135, 0.17866844429604756, 0.1907519230384792, 0.17291611014159025, 0.17916420948915324, 0.2411959020663117, 0.18025751508322263, 0.18086332567635888, 0.1891592845178034, 0.18137528963083283, 0.17504877802222252, 0.18779335803386032, 0.2214966846366878, 0.3853204713367103, 0.1668343481615684, 0.1832499076112053, 0.22508547406259227, 0.15881509470094513, 0.1797850179358853, 0.1922436136715453, 0.34064070316827766, 0.424468529317955, 0.2164358134604243, 0.19679621757150267, 0.20357946807571548, 0.3425056565878053, 0.1897567000508278, 0.3651200059424833, 0.20481682322571293, 0.2094825865068778, 0.17811441970447506, 0.1841284504619337, 0.18976235279836906, 0.18240645635824115, 0.1843653486548793, 0.2004592524942711, 0.17713250118267676, 0.18494774363531696, 0.17763056265677746, 0.11149824076817805, 0.06458525730039177, 0.06877664327718191, 0.06635952559900016, 0.08021211598436662, 0.08168056593922646, 0.06665883837971609, 0.06453885226629241, 0.06807142444633718]}, "mutation_prompt": null}
{"id": "6b48f072-d428-43b3-8c6d-a9db9d235500", "solution": "import numpy as np\n\nclass MultiStrategyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(5 * dim, 60)  # slightly larger adaptive population size\n        self.F = 0.5  # moderate differential weight\n        self.CR = 0.85  # lower crossover probability for diversity\n\n    def __call__(self, func):\n        # Initialize population\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        evals = self.population_size\n\n        while evals < self.budget:\n            # Differential Evolution with Multi-Strategy\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Strategy 1: Standard DE mutation\n                    mutant = np.clip(a + self.F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    # Strategy 2: Scaled random vector\n                    random_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    mutant = np.clip(a + self.F * (random_vector - a), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                \n                # Selection\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            # Enhanced Local Search\n            best_idx = np.argmin(fitness)\n            best_individual = population[best_idx].copy()\n            best_fitness = fitness[best_idx]\n\n            for _ in range(5 + int(0.1 * self.dim)):  # adaptive local search based on dimension\n                if evals >= self.budget:\n                    break\n\n                step_size = np.random.exponential(0.1, self.dim)\n                neighbor = best_individual + np.random.normal(0, step_size, self.dim)\n                neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n                neighbor_fitness = func(neighbor)\n                evals += 1\n\n                if neighbor_fitness < best_fitness:\n                    best_individual = neighbor\n                    best_fitness = neighbor_fitness\n\n            population[best_idx] = best_individual\n            fitness[best_idx] = best_fitness\n\n            # Dynamic Parameter Adjustment\n            if evals > 0.3 * self.budget:\n                self.F = 0.4 + 0.3 * (1 - evals / self.budget)  # gradually reduce F\n                self.CR = 0.8 + 0.15 * (evals / self.budget)  # gradually increase CR\n\n        # Return the best solution found\n        return population[np.argmin(fitness)]", "name": "MultiStrategyDifferentialEvolution", "description": "Multi-Strategy Differential Evolution with Adaptive Exploration-Exploitation Balance and Dynamic Parameter Tuning.", "configspace": "", "generation": 99, "fitness": 0.23386809872743844, "feedback": "The algorithm MultiStrategyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "ca884f23-d7fd-4ca0-ade4-232bf88dc38c", "metadata": {"aucs": [0.4850318332368805, 0.47350285690213034, 0.4845178392623096, 0.4996191663435613, 0.45776638182146456, 0.46543936614534, 0.44393596381799394, 0.4906364663831977, 0.47461528697060695, 0.10693492305637142, 0.1325713221015098, 0.12712804646426645, 0.11268419912478489, 0.12915401230686985, 0.1213884456334785, 0.10909669870476879, 0.12019040914054135, 0.14446182203752467, 0.09199038814380056, 0.10056955868740602, 0.11560710841259769, 0.13834186003721827, 0.11432975413732493, 0.10429372038217699, 0.10310119687018127, 0.11793851336940975, 0.12844895519221733, 0.11160872002189115, 0.10212975574661487, 0.09932626567776948, 0.11452258837156937, 0.11897766370803653, 0.10890531745964604, 0.09589113765304813, 0.08941670366363907, 0.10425105380601307, 0.8449615024203618, 0.7187522853435565, 0.8443193588363577, 0.7972144225858344, 0.8229531390955737, 0.7939786378243723, 0.6986082281040259, 0.8474450208078009, 0.7909942434639958, 0.2858946311415993, 0.2643559279526043, 0.3086854252975798, 0.2642596079153601, 0.2673057420931324, 0.27591698334010784, 0.28506309545271646, 0.25872021926636457, 0.2622823951176807, 0.33486928260389937, 0.295185214453731, 0.25252070294324014, 0.30501066451027636, 0.28926114469267505, 0.3040150336290387, 0.2944201276302705, 0.2735256298937606, 0.5417155367654631, 0.20371115216517388, 0.14250945049140884, 0.1573854244574766, 0.17183355341501771, 0.1417478293981438, 0.16917047857209289, 0.14770794813523624, 0.18367101108552442, 0.1437323441794799, 0.137916491612448, 0.17191732089680212, 0.13559528983329006, 0.17161224827142052, 0.18329063161751957, 0.1915627585803774, 0.14455047251973008, 0.16571628541378702, 0.1688131327741872, 0.0216914853749266, 0.011405505129688964, 0.03127587507340446, 0.011380168980588468, 0.03631683323916801, 0.04237314098805778, 0.029742605560575286, 0.045400057120413284, 0.023736178773697825, 0.17027134399192068, 0.15292834400194077, 0.15587372098955787, 0.1368239432202143, 0.12482571797515063, 0.15277222077375097, 0.17540475209557338, 0.14572514534455117, 0.160443185957441, 9.999999999998899e-05, 0.002669534947383534, 0.0005532476805824027, 9.999999999998899e-05, 0.0019077659444490802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10734831181218907, 0.10188587938907456, 0.11219871093140987, 0.10861716039009972, 0.08284477392552236, 0.10657210370816206, 0.08231339803302529, 0.09131966439069039, 0.11195331159346367, 0.4712821549238233, 0.4116323224496037, 0.43693838074209834, 0.41057545879808544, 0.43097701942684163, 0.41267808382800697, 0.41996273086275504, 0.4238336861462303, 0.41684567756162083, 0.10135771918490755, 0.09651216661529183, 0.0937008473033395, 0.10234012669693926, 0.1113216461130152, 0.09244511935523647, 0.08551703219041995, 0.15537876388789063, 0.13983153072727894, 0.216652598574551, 0.173648375579198, 0.20858404911433837, 0.15648795449580344, 0.2414790688293541, 0.18979133238185408, 0.24034013061161863, 0.16296621057458438, 0.2203280958425563, 0.25548457606758634, 0.26918419043841135, 0.2653717699408882, 0.2632058130399738, 0.3094193810534325, 0.2788492619565526, 0.25437179130999843, 0.257062568585536, 0.2934706920334773, 0.20907632533957654, 0.19704515921953902, 0.21323992342101727, 0.20007690845790171, 0.2051146722209588, 0.19375120114315003, 0.20658602293650952, 0.19804732353466725, 0.20377398396237245, 0.21630251013318336, 0.18689021458690191, 0.20092933267737279, 0.1810571223645705, 0.21971708952970104, 0.2043325664429978, 0.20481595649756956, 0.1841662907170637, 0.2230864402375351, 0.18615454608821325, 0.17600342076055908, 0.22743519001067447, 0.18250081022622866, 0.20917703522410125, 0.2053325081755143, 0.19047243801801395, 0.19782371567375567, 0.19650105581884914, 0.679397791291773, 0.2956310238404638, 0.37303971265291647, 0.6194434610181407, 0.45362795645438336, 0.6268736770971302, 0.5533418634253002, 0.6488959363280242, 0.5540766805723132, 0.4558103526771289, 0.39442847610269405, 0.40685386615489216, 0.45730338711954155, 0.4030213171373961, 0.25554721757102516, 0.4581587911466636, 0.3718304682211885, 0.2794692212116915, 0.18999271540958584, 0.19231252583598657, 0.1814064859354526, 0.18020745485588374, 0.1841194365086981, 0.18179027481280075, 0.1818984045801827, 0.20948182458291298, 0.2018725212985898, 0.06725375342584594, 0.07591332430999465, 0.0887260836042042, 0.08193846348089939, 0.07594408199796632, 0.07072397908684691, 0.09243628232185652, 0.07469714931971716, 0.07662785834368457]}, "mutation_prompt": null}
