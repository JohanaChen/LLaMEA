{"id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "solution": "import numpy as np\n\nclass HyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 # Crossover probability\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5 # Cognitive coefficient\n        self.c2 = 1.5 # Social coefficient\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "HyDEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm leveraging adaptive parameter control for effective exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.33034606652083165, "feedback": "The algorithm HyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8397495676609655, 0.8190300489277756, 0.8398750345460931, 0.8397650948869302, 0.8366798786443894, 0.8313015892072477, 0.8245302350980133, 0.8249582159802497, 0.8308134626020947, 0.6487214926601398, 0.6783795521098726, 0.6620149026850402, 0.6230439058570865, 0.6735584857093964, 0.635270642486297, 0.6254502288799718, 0.6289787694262154, 0.6736917853956854, 0.12503759738790088, 0.13554453689206747, 0.1771278060932061, 0.17508093836242988, 0.15141497907699852, 0.10317843460741716, 0.1732031904867366, 0.15298376353876852, 0.11143657448788802, 0.10577500175481636, 0.1231787354538465, 0.13670000284870787, 0.12438066112305601, 0.13359233635335366, 0.11231523199175042, 0.0947159041281933, 0.1301693323602673, 0.08818530945095548, 0.9644974709473209, 0.9419601691244215, 0.923311768894063, 0.9271074104229867, 0.932993425666828, 0.9039612080623244, 0.9215780286333194, 0.9542097321210484, 0.951453532818375, 0.6462847802826264, 0.6629043098747704, 0.6246402484784812, 0.6359269396412675, 0.6008794899607808, 0.6473673583067852, 0.6146107113061905, 0.6296315392869425, 0.606497117458239, 0.2292278227415413, 0.22426437853539338, 0.22300618771580727, 0.27378852382942653, 0.269976839147537, 0.7797423294294236, 0.22070260392231733, 0.23196699347373861, 0.22071890552493512, 0.12813727206610215, 0.2605173072371082, 0.19732230055393196, 0.25715398690181046, 0.12808934079071244, 0.19704697411652683, 0.21997594206284032, 0.23384855428711948, 0.21299395367325458, 0.20781159014248762, 0.23349915394293708, 0.2316316793131773, 0.2325187894419095, 0.1286871304888717, 0.21093907892916453, 0.2505072731754482, 0.24094301175456367, 0.11749879029847776, 0.005231023895867826, 0.1849864088740234, 0.013905123892463789, 0.04451611749692619, 0.012453013605185137, 9.999999999998899e-05, 0.0032065760069228677, 0.0024215129760032372, 9.999999999998899e-05, 0.06837924492958625, 0.15353884267960294, 0.0772819690980523, 0.09185625843295964, 0.0944093144368926, 0.16723526035875436, 0.057408462936272, 0.10134526080966155, 0.11401616719697139, 0.042556193065264036, 0.23882209929295373, 0.04591854711358678, 0.15735597999168172, 0.08147668535611263, 0.1570339445614105, 0.14532986976845963, 0.23260541667178591, 0.17647291208599314, 0.1838623706935688, 0.29605413373279044, 0.17146907825406565, 0.14870902295655675, 0.19608127962715338, 0.1565236342933255, 0.16008436336483178, 0.11120667633500447, 0.0827227754687676, 0.5154910896440872, 0.5346257695762768, 0.548273398000598, 0.5828631313801337, 0.5520627124191595, 0.5912840153066254, 0.5664807650666381, 0.5594783994482939, 0.5491195342847467, 0.10322431767736473, 0.14923889073083663, 0.1270561248958737, 0.12850047896967265, 0.11330680221982603, 0.139818687437965, 0.13746450567375346, 0.13590009062795017, 0.1506218910748779, 0.35043278450595505, 0.29530263984903315, 0.4879017417107462, 0.4460200246945929, 0.19528890825837497, 0.31740463533914876, 0.4713817665049883, 0.49259555332736904, 0.40431347824219743, 0.26193081368045856, 0.5928802856934643, 0.5610181930625151, 0.4264587320227091, 0.5641841636786352, 0.4262556559089017, 0.5191494133116514, 0.5548967606276047, 0.5231489689276392, 0.3056127503213857, 0.20105470698984795, 0.3533152500716086, 0.25184557863655566, 0.33303051076504475, 0.30818215389966686, 0.3472297334823259, 0.3555573852195195, 0.4534175484075891, 0.23929541617054362, 0.2198830235341256, 0.20829148154376453, 0.23621305422988315, 0.21712016022416591, 0.22783956046849885, 0.22903601559876774, 0.2264453624844991, 0.21408577983177202, 0.19617166210049874, 0.6910006932719632, 0.24220890859972655, 0.2001742027031852, 0.1938672859617816, 0.20613774523759876, 0.5521166924555492, 0.22169109437971923, 0.21852139877317744, 0.18679417527018427, 0.18548482517648346, 0.19791267110750155, 0.8985858324777274, 0.15921489447426906, 0.16665607894650913, 0.16843597512104447, 0.1700147578051847, 0.17597989345915743, 0.7453955579706146, 0.21019721790674006, 0.7700748149146781, 0.8363555505253817, 0.16813619684031, 0.7878323755399157, 0.1639235079099528, 0.7841477077768183, 0.20832846198338717, 0.18899365566065007, 0.18667423212974787, 0.18411983885909733, 0.1844262548959653, 0.1980708845196596, 0.1997022546746472, 0.1931314753242782, 0.19663274589911728, 0.18750809551132386, 0.0943226258612132, 0.08635202805268694, 0.09616496775629946, 0.08856115479701931, 0.09102712876233998, 0.08847613806435495, 0.07779122787482173, 0.099665255659944, 0.08609890564256961]}, "mutation_prompt": null}
{"id": "056d00c9-ad5d-41f3-bd7f-ef091cfe5f7a", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = np.random.uniform(0.4, 0.9)  # Dynamic differential weight\n        self.CR = np.random.uniform(0.8, 1.0) # Dynamic crossover probability\n        self.w = 0.5 + np.random.rand() * 0.2  # Randomized inertia weight\n        self.c1 = 1.5 + np.random.rand() * 0.5 # Randomized cognitive coefficient\n        self.c2 = 1.5 + np.random.rand() * 0.5 # Randomized social coefficient\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation with dynamic adjustment\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update with adaptive parameters\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "An enhanced hybrid algorithm combining Differential Evolution and Particle Swarm Optimization with dynamic parameter adaptation for better optimization performance.", "configspace": "", "generation": 1, "fitness": 0.3043615067529323, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.6171163105711749, 0.7703667634401297, 0.6879639072318593, 0.6332512066582147, 0.8076427579527924, 0.7179989446295199, 0.6286547980594225, 0.8011264685616266, 0.6910288146865586, 0.3212059730677831, 0.5951204336473921, 0.3803104183004089, 0.2723351525323371, 0.5897188981606163, 0.43197291693331075, 0.3430542629155432, 0.5639145858975563, 0.43332268257027695, 0.13122203105768437, 0.16520328483958036, 0.2521169053086598, 0.15138297612203255, 0.1435427734390321, 0.14308460764553232, 0.10420522398599419, 0.13565796810073483, 0.12782558800638377, 0.09438495560030802, 0.12643032926125775, 0.12997051789508574, 0.09333222572761801, 0.10393076047524996, 0.09954219884448734, 0.11820861648451941, 0.10863265495438967, 0.1744843500725517, 0.9467360695561392, 0.9457299020854352, 0.9459833196482986, 0.9370461595907998, 0.9483982464361639, 0.9416228467071639, 0.9589495260476518, 0.939439783988585, 0.9418745593916388, 0.31096531243168424, 0.4905145311082263, 0.38885907256287955, 0.30547788550462196, 0.52595733383144, 0.4139402942079602, 0.3078683075753442, 0.5123325636783069, 0.37320270261166466, 0.6313495178774491, 0.7390317885091864, 0.8309333766966533, 0.49371462009706923, 0.3711685309126165, 0.2156276656271009, 0.2791270836090707, 0.7167808586787865, 0.7006560687050525, 0.17065953032199, 0.19517740711298726, 0.2097221786543244, 0.1596486732836001, 0.21228177749498212, 0.2332903119939751, 0.17242127557646636, 0.286363257452099, 0.1778273554828418, 0.19172872993907475, 0.23243660335214977, 0.2157967849726259, 0.15142295628125835, 0.2686146343593998, 0.1615155502023352, 0.20192026576055366, 0.23556783462985653, 0.21724814532029235, 0.037147017713813124, 0.09875073868675677, 9.999999999998899e-05, 9.999999999998899e-05, 0.014450484664951357, 9.999999999998899e-05, 0.0067413736146447745, 0.06054554684273494, 0.07085532534950378, 0.13276225539666198, 0.127356364526942, 0.1286032355478205, 0.03800515583932884, 0.08087603639423868, 0.022162678446597583, 0.07820287560984451, 0.11581547458624064, 0.10575788697434363, 0.0231680819818485, 0.21409162280980198, 0.07525276322710106, 0.010919239867262731, 0.1072622856876635, 0.05240588657943679, 0.05947288156692043, 0.08091279396159479, 0.08905060677293819, 0.14469820823497326, 0.24248540320306688, 0.12948019197467187, 0.11434994720063207, 0.24601682343239994, 0.17012150618582655, 0.14231652778257997, 0.13832511960071847, 0.14608095090451967, 0.45012648193280747, 0.5006800007376331, 0.501576452585395, 0.4629899246262834, 0.556618052583438, 0.4721472020139579, 0.44846979570276535, 0.5269852961817159, 0.4878749063328365, 0.1116276336526093, 0.10665062871999798, 0.11150636380304235, 0.0975749494057383, 0.10694830544379852, 0.11660903798305566, 0.11572574245477318, 0.13306583513691295, 0.11144301124703326, 0.17749851665284355, 0.1755682010287326, 0.3077359117002353, 0.16284789227584517, 0.14034668649384408, 0.23633565240867538, 0.18733205802445663, 0.16713796563549554, 0.23645834856406567, 0.2979727368773931, 0.4426072752603185, 0.381089692968016, 0.35382730190293177, 0.4353279863800382, 0.3985443415640231, 0.33482523736494174, 0.48180791112977606, 0.39186189768791624, 0.22277889264542583, 0.3152814390270401, 0.2205278582535105, 0.21830962790339303, 0.2014143730006841, 0.2687766495974001, 0.2512168242101034, 0.32749657849108027, 0.253812787691471, 0.20966779186296325, 0.24045952877322863, 0.2103835868766437, 0.2104780785468121, 0.19951341079665985, 0.2368394554290838, 0.22303864329770617, 0.22673596499937299, 0.21649001017169922, 0.22271544246268615, 0.21586408205478524, 0.18942261148784856, 0.19820973947136533, 0.20212269453355136, 0.19287026067019208, 0.20691199942755634, 0.23995007538969426, 0.19781129906932426, 0.18189726385972838, 0.8633360450117542, 0.7943686548072042, 0.7657229419116811, 0.8436607939913723, 0.16613013170617308, 0.7633414233311486, 0.8401305489209104, 0.16570846974878695, 0.19978674876192348, 0.7304182360868888, 0.5951063297887327, 0.46632919492664804, 0.7999892755558136, 0.16602790032986303, 0.44368327573247335, 0.7213861087070585, 0.10389207396601052, 0.18576151178083022, 0.17989163468964453, 0.18429558709024474, 0.18964333504507125, 0.184205336508946, 0.18405715531739486, 0.1892637928901274, 0.18205981571505314, 0.17885086638104186, 0.0889799442656718, 0.092131876908915, 0.08161789498549299, 0.0937126501322858, 0.08379207778606201, 0.08427021551908787, 0.0870769741874281, 0.09201668281645092, 0.12175999419101424]}, "mutation_prompt": null}
{"id": "3cf5f06d-f06a-44ec-b12a-5cc9d0ff6504", "solution": "import numpy as np\n\nclass HyPEB:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.6  # Differential weight for mutation\n        self.CR = 0.85 # Crossover probability for DE\n        self.w = 0.6  # Inertia weight for PSO\n        self.c1 = 1.7 # Cognitive coefficient for PSO\n        self.c2 = 1.7 # Social coefficient for PSO\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Evolutionary Bees local search\n            num_local_searches = int(0.2 * self.population_size)\n            for _ in range(num_local_searches):\n                bee_index = np.random.choice(self.population_size)\n                bee_position = self.population[bee_index] + np.random.uniform(-0.1, 0.1, self.dim)\n                bee_position = np.clip(bee_position, self.lower_bound, self.upper_bound)\n                bee_fitness = func(bee_position)\n                evals += 1\n                if bee_fitness < fitness[bee_index]:\n                    self.population[bee_index] = bee_position\n                    fitness[bee_index] = bee_fitness\n                    if bee_fitness < self.best_fitness:\n                        self.global_best = bee_position\n                        self.best_fitness = bee_fitness\n\n        return self.global_best, self.best_fitness", "name": "HyPEB", "description": "HyPEB: A hybrid Particle Swarm Optimization and Evolutionary Bees algorithm using adaptive control for enhanced exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.2605308210111832, "feedback": "The algorithm HyPEB got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.6455188359144021, 0.6414352419702813, 0.6218086641843061, 0.5818082207436189, 0.6465258719103941, 0.6066762514294162, 0.6472207121250898, 0.6658263339769829, 0.6634193077532764, 0.36381436723145144, 0.3332933154193074, 0.32963322923370386, 0.32174538650776163, 0.32154355492061537, 0.3536358426444606, 0.3355595390661632, 0.35454856876323915, 0.3254990276658418, 0.11338309883688558, 0.12323926535557095, 0.11819723388810455, 0.1373929034553979, 0.13728178130743163, 0.13250985666889026, 0.11658197581049701, 0.13539620562347976, 0.12197503951193611, 0.1178624457665175, 0.11284342145509674, 0.11556024149597655, 0.09059367606301127, 0.10524457473358417, 0.10447581196026845, 0.1012063306467127, 0.11411116495987994, 0.12039418072899866, 0.9602330106415577, 0.9535979300598021, 0.9518422227888163, 0.9477909885095566, 0.9390624610728323, 0.9448623380865329, 0.9385629451941867, 0.9502734931402262, 0.9460947497072472, 0.2978832739853595, 0.3151896652887912, 0.31940596805511445, 0.3304240057070458, 0.33890602282735627, 0.31601505283553044, 0.2964973771436168, 0.3083882127987019, 0.30307945335300124, 0.22346997608273977, 0.33203401791522924, 0.6162013817263985, 0.2661816574960004, 0.6830713732745146, 0.5290171110333302, 0.4053458562154717, 0.5089436639534477, 0.6125950849155224, 0.18372439981682887, 0.10513908865970611, 0.16001356940351052, 0.1562469992440263, 0.15475765499880778, 0.12356373135175869, 0.16639408025828473, 0.17491621010387737, 0.17286970517363365, 0.19263025560080627, 0.18506525716455358, 0.10514609305090383, 0.1744144744407824, 0.18519278540931705, 0.19376429201713719, 0.197944320954474, 0.1936689877786314, 0.18793458184819123, 0.04235222266831584, 0.0319383190975947, 0.014579701126699929, 9.999999999998899e-05, 9.999999999998899e-05, 0.025949211979808373, 9.999999999998899e-05, 0.006799359840450436, 0.06458955523375898, 0.10491173938195131, 0.0382423113026904, 0.11181274388859763, 0.12544360962215795, 0.10717909889910604, 0.13999499703984053, 0.11547332974761648, 0.09591488781694701, 0.09193638755697853, 0.05416152466683721, 0.006431248372250731, 0.036678277121066416, 0.02112935819851114, 0.015427308471147816, 0.05178392093630957, 0.07733307875530715, 0.027100118289599795, 0.05591786219840145, 0.09426429609118403, 0.12061835458144365, 0.10587120390781968, 0.12347272922606678, 0.0741791531918945, 0.1525549846293719, 0.12626932429653592, 0.13566580306694487, 0.14277687344736245, 0.4407057240181623, 0.4398393970471429, 0.45086618268306666, 0.4502423800526977, 0.47049640028331663, 0.45665528109564435, 0.47437960238430155, 0.47703858534006705, 0.48859473667459064, 0.07932173648379193, 0.10840919889362832, 0.09529521947727948, 0.09649222185157325, 0.11111596781512145, 0.10072092305987534, 0.14012719774282034, 0.11321077359534248, 0.12496813707859888, 0.23535886120539384, 0.14023630400073728, 0.1945684428736214, 0.13898760422781797, 0.15085923932097944, 0.13703000673108257, 0.21708416550492515, 0.1855090204006632, 0.18053832266544378, 0.3425689598669911, 0.3155556052670826, 0.34449187791749014, 0.31283682538573054, 0.3157893733860364, 0.3461833252765899, 0.32452447438779586, 0.36849375796810235, 0.3550393393706981, 0.20651054867639174, 0.20566325480760184, 0.2538406634517716, 0.21802601642098185, 0.20307504964959677, 0.24418106481287993, 0.2580450258373457, 0.2600975765547985, 0.2665139648146667, 0.212302760674976, 0.23869903891729471, 0.18905593629180206, 0.19511840931654656, 0.19914201741963033, 0.20455283555107862, 0.2053513855234459, 0.20753866164903834, 0.21711355648734032, 0.22253979187760886, 0.20449734241458362, 0.21331285153695578, 0.20765973923944336, 0.24215281349060758, 0.2020744753468503, 0.1995871627013618, 0.29405782505113165, 0.19759434608096205, 0.1666814187828337, 0.1851267804597969, 0.1693312880611607, 0.7420413718741548, 0.16343234407775575, 0.7586802598694796, 0.1251974585130593, 0.13020070247714555, 0.7287614537027901, 0.6273346690850992, 0.16892113090361438, 0.5158627376291001, 0.16452192270716426, 0.16758546139428254, 0.6520289203559833, 0.21014485464071275, 0.20925053342061706, 0.21035639469990097, 0.1761860347642511, 0.1933087741523818, 0.24625315809677384, 0.1890173349444283, 0.19832617314375556, 0.1910206367527143, 0.18968683626495608, 0.18282928496230533, 0.16797371473036948, 0.07981137974887476, 0.09101440089587032, 0.08416513619504329, 0.08528921430612102, 0.09463030413481721, 0.10310031340561343, 0.08163039461777222, 0.08350207783547592, 0.08384302541621724]}, "mutation_prompt": null}
{"id": "a8e24bcc-025b-4411-b4f6-8549ae9a9d79", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5\n        self.CR = 0.9\n        self.w = 0.7  # Adjusted inertia weight for better exploration\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.elite_rate = 0.1  # Proportion of elites to be preserved\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            elite_count = int(self.elite_rate * self.population_size)\n            elite_indices = np.argsort(fitness)[:elite_count]\n            elites = self.population[elite_indices]\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Preserve elites\n            self.population[elite_indices] = elites\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm with dynamic parameter adaptation and elite preservation for enhanced convergence.", "configspace": "", "generation": 3, "fitness": 0.27119312302669907, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.6338576695807598, 0.5911974643082171, 0.6093900714981091, 0.6198404455259471, 0.6078370992260753, 0.6240432490041783, 0.6158546869739137, 0.6055682230440143, 0.6235192616641352, 0.2999477826282029, 0.2911260067233439, 0.2425817419240882, 0.2704794764202545, 0.28229216896646736, 0.2930991331312971, 0.2513191102902348, 0.2538209163454166, 0.2561440013097346, 0.13609863596700666, 0.11679637287536282, 0.10363018348109332, 0.16143207431740503, 0.11981868121262962, 0.15162406189813005, 0.12536045754414915, 0.13495613633861736, 0.13717138307823518, 0.09682836282507234, 0.09889334343698397, 0.09901299746815606, 0.10260627127192312, 0.10240662133678069, 0.10445769081166378, 0.09998098085605578, 0.1284645433320336, 0.11860570085206168, 0.9637525698644264, 0.9549784574510983, 0.9181957745813054, 0.9383402490921908, 0.9448032071101528, 0.9169177195321034, 0.9293898094867129, 0.9315304934270634, 0.9304607202608098, 0.35395337824899087, 0.333164165993018, 0.3097334189717851, 0.33892947011113395, 0.343082856546428, 0.32988444176266396, 0.3291677452820184, 0.33439535438762646, 0.3460475417145773, 0.5703138582279185, 0.5726250414765528, 0.6070261045635117, 0.36158286925587013, 0.27144709320168814, 0.26454399024709496, 0.5997795766327048, 0.631670469619628, 0.22816940974612698, 0.17391554708419021, 0.17057471019843684, 0.16733832068755017, 0.2616186716432253, 0.1708252566125248, 0.1252204816961916, 0.16667383850822048, 0.16903696508236754, 0.1760602915862035, 0.12456152597307113, 0.17219253811200363, 0.18127250104303672, 0.19034637021227074, 0.1722366149183152, 0.17301365468664176, 0.18589410024676056, 0.19027271110946342, 0.16218043962472295, 0.04602076907411834, 0.04885086979668829, 0.008359941089174261, 0.014354099171573598, 0.03636118964987922, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.045417854196342144, 0.10527981319215707, 0.09361891119034704, 0.09113839532990553, 0.06837645599031694, 0.1272815924212779, 0.03523539049641, 0.05311300825642662, 0.05990291425266603, 0.10916386496792219, 0.05005877420811411, 0.09836469478765542, 0.04375525858759555, 0.04654900426430908, 0.04482896884332144, 0.03679471683140434, 0.0639683337669048, 0.061619162860774845, 0.07686167626264417, 0.12978491819462945, 0.16002991078405115, 0.11609715883296434, 0.14355061494956356, 0.13222395852179747, 0.17002344722340057, 0.1185692583687683, 0.07490338010370545, 0.16176758165542449, 0.4472706649745013, 0.46845716419127303, 0.4732714003722658, 0.48484789393276906, 0.4659125607388295, 0.447332215476237, 0.49371751713981427, 0.4598558798768958, 0.44924431788960384, 0.09371456720431448, 0.10817931053862828, 0.10904660627159368, 0.14258491659290706, 0.08322535813328746, 0.10212390153677464, 0.1014755937799715, 0.12437285990172642, 0.12610335857001087, 0.23583519277095266, 0.20758706273029714, 0.1610233959054156, 0.23136467450567366, 0.1690105965857207, 0.19271537296725993, 0.26218295895997357, 0.14518653425819228, 0.2521003906959395, 0.31882786394439744, 0.36090553134605996, 0.2807155787027391, 0.31009435947615516, 0.34579367834300856, 0.351286039361287, 0.3015857114410895, 0.34965277809387263, 0.3276054892978364, 0.24049847533503044, 0.29147020278762636, 0.27315279809053006, 0.2758480102782145, 0.18768013587237053, 0.26552737014318406, 0.2595676954711381, 0.29130964727262465, 0.264397208473528, 0.21794795250310128, 0.21980690233351574, 0.24650856283984746, 0.2289092457320716, 0.2013635393911083, 0.23928932965067928, 0.22271771023498732, 0.2609467510556924, 0.2649781039238205, 0.20182132531363317, 0.35984896921616893, 0.23350220856164705, 0.19655060045409067, 0.2047033365550487, 0.21160203084678808, 0.20146330823618874, 0.23100026767241355, 0.1882182995052163, 0.18305257576713463, 0.780583165763612, 0.19662402052622618, 0.7930064337586804, 0.7283461547277774, 0.15004586962604627, 0.16839305166078133, 0.8043458435209696, 0.6895860085492638, 0.5198216377475269, 0.16820142108522307, 0.592441945011748, 0.5959223140832026, 0.6097446718014183, 0.16734903258783873, 0.1640669103658371, 0.6023130725477122, 0.20912177738734616, 0.20583491823278144, 0.19435403971409537, 0.1732620874767068, 0.1981363691483503, 0.17872895360476726, 0.18219659733320837, 0.17751266529144627, 0.18987618571954823, 0.18452405528686122, 0.0868971026938572, 0.09021855744652929, 0.08257389321026531, 0.08357990943290117, 0.09640423919478014, 0.09695229776545689, 0.09671475638904026, 0.08936860797370993, 0.11306492566643334]}, "mutation_prompt": null}
{"id": "e05d84fa-63ec-498d-b894-6f108188b479", "solution": "import numpy as np\n\nclass HyDEPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.6  # Differential weight\n        self.CR = 0.85 # Crossover probability\n        self.w = 0.4  # Inertia weight\n        self.c1 = 1.7 # Cognitive coefficient\n        self.c2 = 1.4 # Social coefficient\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.temperature = 1.0\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Simulated Annealing perturbation\n                perturbation = np.random.normal(0, self.temperature, self.dim)\n                trial = np.clip(trial + perturbation, self.lower_bound, self.upper_bound)\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection with Simulated Annealing acceptance\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Decrease temperature\n            self.temperature *= 0.99\n\n        return self.global_best, self.best_fitness", "name": "HyDEPSO_SA", "description": "A novel hybridization of Differential Evolution, Particle Swarm Optimization, and Simulated Annealing leveraging adaptive parameters and cooling schedule for enhanced exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.1795211035294329, "feedback": "The algorithm HyDEPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.3056282594368531, 0.2895940729621952, 0.30268869096915874, 0.30176257957042585, 0.3056282832984265, 0.29574041143019847, 0.29491723517721946, 0.3314699331316606, 0.2867577253224667, 0.003499435005522855, 9.999999999998899e-05, 0.0001886448810968222, 0.004806805182026808, 0.00258419822018352, 9.999999999998899e-05, 0.004596306557164254, 0.0038179243595314327, 0.003779941755466698, 0.10214230412959902, 0.09311999655309733, 0.09537196065357079, 0.11139028112519789, 0.0865212178972764, 0.10181486107803261, 0.08382698633384933, 0.08731482742452823, 0.09594611681910059, 0.07765289080432936, 0.09912444002668597, 0.08299492611727433, 0.07576012612457783, 0.08740671947467293, 0.08548375777879247, 0.07786712354031877, 0.0797661912168216, 0.07267467541926831, 0.9207323308435906, 0.9073520902266229, 0.9223036887597923, 0.9497653967948197, 0.934044074992804, 0.92085512605026, 0.9213224554505561, 0.904302873815843, 0.9337506539877114, 0.21218646019020027, 0.19616568974029946, 0.18995276686459794, 0.24110356405553035, 0.20167824562907766, 0.20879562908518778, 0.20264119582957352, 0.1856331837447086, 0.18957477426129932, 0.2675566820120886, 0.23238873166336105, 0.22928508087847288, 0.2297013086329701, 0.24642696678320342, 0.2579340579360272, 0.24065210283090055, 0.23906803881038619, 0.2524354161522787, 0.10313251816049107, 0.11113250071054082, 0.12429765447800512, 0.10706204702074351, 0.11310737059211429, 0.11103519811529727, 0.10426547379913265, 0.11284608582120714, 0.10023516075396255, 0.11145371398060666, 0.11728665857788834, 0.1053566591263354, 0.10185524429128823, 0.1244238643869523, 0.11426513646290182, 0.12357401289279057, 0.09750100252497773, 0.11081817567764407, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007499195831837779, 0.000497553444608223, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08532144711636469, 0.10022492759409529, 0.11732104462461479, 0.07146192355137826, 0.11502273931258877, 0.09194336759476007, 0.07697627522439032, 0.09982542175106623, 0.1512799568802986, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.054392559255965534, 0.041653340146619255, 0.04418121316095536, 0.04887363610028628, 0.047209999557015214, 0.05560046363965887, 0.04272902305329751, 0.04185204231772932, 0.046539616517946136, 0.30103890509491915, 0.299823201067715, 0.2920893781076599, 0.2929161246119143, 0.2921728722289023, 0.2925907864718118, 0.2949719743067669, 0.306592526330439, 0.2922280284660277, 0.09116042235945698, 0.09318464346198674, 0.10419033613967477, 0.08537105096025877, 0.08405767656369512, 0.11757527857142669, 0.09371846518992877, 0.07849139526889415, 0.08426742350661132, 0.14253678189518193, 0.13093038134252089, 0.15546029976187203, 0.14133993103278808, 0.1288920596733122, 0.13804539601869603, 0.14750000312451617, 0.17047023022780194, 0.13970479215163556, 0.2421166755955667, 0.22840293908861664, 0.22895396832788373, 0.22397152112289065, 0.23266086972657807, 0.22546426008947063, 0.22632530077129653, 0.2293316050427716, 0.23476340803981, 0.17854033656177726, 0.18516678206748882, 0.1679787638881386, 0.17463945067539122, 0.17384654006421973, 0.16511540040231443, 0.18577709783195306, 0.17462370690583162, 0.15493276231505493, 0.19868770043212003, 0.19026480996512873, 0.20094949215054103, 0.2109434766095073, 0.18874211252822815, 0.201567926933924, 0.19680390596478348, 0.1947549122421096, 0.19674601522793167, 0.17276602976859357, 0.19645212393446798, 0.17983725120600502, 0.1975539250807673, 0.17658762631500613, 0.17117835836619089, 0.18510483171230752, 0.17390791090861224, 0.1683536132676079, 0.17651171902267726, 0.1792044873838302, 0.17838169653669733, 0.1580623871546175, 0.1646490991791526, 0.17289902992536021, 0.16538352900454267, 0.3939970486979526, 0.35177444959033854, 0.3635659001169743, 0.33620459414575565, 0.340264677090909, 0.1905567850350287, 0.33771551530053645, 0.3698849383234728, 0.32557356935923787, 0.20050190113116884, 0.14978053820466886, 0.18447248933552474, 0.17495570066935284, 0.18895788448985817, 0.18793588909518544, 0.18690104799805562, 0.18332862921563664, 0.18497506404110609, 0.18116103207767542, 0.17748497905229887, 0.07995586914201191, 0.07808938142504118, 0.07974669593953154, 0.08022299843285785, 0.08343305892413466, 0.0789847165709987, 0.09437248050335034, 0.08869305053028342, 0.07573909479726793]}, "mutation_prompt": null}
{"id": "eb53d424-9b87-4131-9b82-e5519ec66865", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 # Crossover probability\n        self.w_init = 0.9  # Initial inertia weight\n        self.w_end = 0.4   # Final inertia weight\n        self.c1 = 1.5 # Cognitive coefficient\n        self.c2 = 1.5 # Social coefficient\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            w = self.w_init - ((self.w_init - self.w_end) * (evals / self.budget))\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection with elite preservation\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "An enhanced hybrid Differential Evolution and Particle Swarm Optimization with adaptive inertia weight and elite selection for improved exploration-exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.272841331313026, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.6189536138925381, 0.6142297747150133, 0.6262673194031518, 0.616346365529014, 0.6116565975727029, 0.6110496161909347, 0.6107350342298306, 0.6204219762978265, 0.6343884230806645, 0.2681727537796913, 0.31285191096546106, 0.31392599833489865, 0.33396364586168514, 0.33621141763966955, 0.3394352017169583, 0.33507598354133983, 0.3509313222301669, 0.28677676663957963, 0.07844595857127024, 0.12131066399817902, 0.12706242467659923, 0.11086612955218367, 0.15563059030476, 0.17852420503988975, 0.12929238482494332, 0.12226605900595755, 0.14082234943975414, 0.09762719593216007, 0.10882999292762274, 0.10200341502044408, 0.09983416452460847, 0.1097844542271117, 0.1143405910065094, 0.10957331040843687, 0.09968817880060521, 0.09918857955555127, 0.9645181799298538, 0.9479565635976035, 0.9384184151791709, 0.9371892044088529, 0.941727491267063, 0.9282099886230281, 0.9496389926192779, 0.9518685947432561, 0.9507441616294852, 0.37933574702298445, 0.3671169928138186, 0.35955677911519757, 0.3774711049941063, 0.38368104479951903, 0.381089430830736, 0.3530589374436862, 0.36436627581311654, 0.37044279869582486, 0.6119443253696829, 0.6183849698309556, 0.5721392423502581, 0.6229386763993334, 0.270286122937731, 0.19950518442645016, 0.5373921638226392, 0.645569832649304, 0.5911328942230671, 0.16911338812062626, 0.1779752424917862, 0.1704775006907383, 0.1545240375538668, 0.16903820346848786, 0.16849607391768717, 0.15791582690209038, 0.18179498977323993, 0.1614262913728175, 0.1834537307114571, 0.1738240753067012, 0.18938116820622075, 0.17415260227118035, 0.1802360388558245, 0.190182893979561, 0.1867873381337657, 0.1750342742760711, 0.103936872567576, 0.031923698419369595, 0.035777455745947706, 0.002607978106417441, 0.013476182639215906, 0.04007055433843876, 0.0003232833641509947, 0.05881877373681943, 0.005885566947089527, 0.04257837957655897, 0.09730202656723519, 0.17437904230112322, 0.054055461398580196, 0.04491109143171712, 0.15313848019614018, 0.03750475109674101, 0.0899956866739895, 0.15167767005952737, 0.10964168395960028, 0.07555860352776311, 0.08880581226794271, 0.10397672066085595, 0.04270458806859001, 0.04607572864720644, 0.09656226264549672, 0.03776347834271654, 0.05729429427824051, 0.07539711275012251, 0.1655158295224557, 0.09216142676020678, 0.14833248498317497, 0.14824632305963592, 0.12523314308951317, 0.14686197425524006, 0.0734118572330481, 0.0770608752762435, 0.122475932905041, 0.44674776371235325, 0.4577115171680157, 0.44625031725330433, 0.4589293387835912, 0.4542527239208347, 0.45527854598543416, 0.4486897522668093, 0.4574571142068923, 0.4739439398915142, 0.09752199587073751, 0.11380579227254528, 0.1305152945273641, 0.12547335486817135, 0.09816131984645349, 0.12028644091067686, 0.11416532965927106, 0.11362324135683044, 0.11119566509898193, 0.1777567595156856, 0.198861996503372, 0.3437285041772732, 0.24570885673014475, 0.21295801318756735, 0.21823292417065, 0.23275062851957484, 0.3158484765468603, 0.27032043481142687, 0.3427694792746363, 0.3578224793184607, 0.3045932857780479, 0.37721456767245076, 0.3477821540242223, 0.37151378674211766, 0.3681001087363148, 0.3567917255032994, 0.3758001264771539, 0.2575333593783111, 0.25568602995188217, 0.21567966883901113, 0.2133835885391958, 0.25577551356684547, 0.27572863167956996, 0.3101232005369178, 0.27125839258645235, 0.27632253283488184, 0.2308122011765864, 0.2145459805019947, 0.21717348295849592, 0.22209658425915235, 0.2250157762174536, 0.22829333560701048, 0.2336404042701039, 0.2167440960557847, 0.2443897218152844, 0.20521107305298958, 0.22117637961643322, 0.416203039941348, 0.1997614812988946, 0.18169273309355272, 0.20394455552701674, 0.2183969559657436, 0.43060298435450683, 0.19863578864294162, 0.18499286797269276, 0.18477780327328153, 0.19613837646391963, 0.7327223445638906, 0.1566440082971099, 0.16701602509850877, 0.7439625828289276, 0.1736462384270986, 0.15694993889679532, 0.5763147360314502, 0.16777546287366962, 0.6254585841038696, 0.543785535841784, 0.16774545213618786, 0.16595273017326562, 0.16411447300529058, 0.6577406046506746, 0.4875897906281481, 0.18470596351700586, 0.19189403586635645, 0.18085097379489035, 0.17865251000320348, 0.18152791857184447, 0.17852431681278325, 0.18255781802766247, 0.2029642766224291, 0.17610411633055423, 0.08997620166043174, 0.09257444127450176, 0.1042152822214455, 0.11943555136521733, 0.0897220851413687, 0.0907549231413124, 0.08732181303420439, 0.08434271050800235, 0.08445857449086747]}, "mutation_prompt": null}
{"id": "763596a0-7159-4cc8-9bb9-b5ff839c5a1e", "solution": "import numpy as np\n\nclass HyDEPES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7  # Differential weight modified for exploration\n        self.CR = 0.8 # Crossover probability adjusted for diversity\n        self.w = 0.4  # Inertia weight reduced for swift convergence\n        self.c1 = 2.0 # Increased cognitive coefficient for enhanced local search\n        self.c2 = 1.7 # Increased social coefficient for better global search\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Adaptive PSO update\n            adapt_inertia = 0.9 - (0.9 - 0.4) * (evals / self.budget)\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = adapt_inertia * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "HyDEPES", "description": "A novel hybrid algorithm fusing Differential Evolution, Particle Swarm Optimization, and adaptive exploration-exploitation balancing to enhance convergence performance.", "configspace": "", "generation": 6, "fitness": 0.19813572033616633, "feedback": "The algorithm HyDEPES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.42274807111671275, 0.3875288023866077, 0.4422177955322041, 0.42383085331058756, 0.40477661897608075, 0.4306144338488881, 0.40089238399485694, 0.40281780300719605, 0.421158991036366, 0.14557369924408048, 0.16172232191983837, 0.12631293513993425, 0.11977208192526323, 0.1337507388896041, 0.1291429104682149, 0.13107039438982082, 0.11020722771443603, 0.107298231304082, 0.0942774607626794, 0.08945786486085472, 0.1057254991978116, 0.09393454803982892, 0.09018954352591624, 0.09455056244960391, 0.10693038657234955, 0.09831440248154466, 0.08856561937894714, 0.10246901749520276, 0.09065627108823704, 0.07985525451251829, 0.09368925847131726, 0.07910459493644506, 0.08913211752494221, 0.08555499455570448, 0.06570783348715936, 0.09424968924047294, 0.9677097273431159, 0.9640958779248723, 0.9555330047129759, 0.941849185759895, 0.9500067013455371, 0.9616637933704333, 0.9518213840773272, 0.9581826208527062, 0.9652897277605961, 0.24178372326742037, 0.21135389833062668, 0.22484325280285267, 0.21480621757900342, 0.22296684133661915, 0.20562658234416942, 0.22589093721192754, 0.20765060323692552, 0.20314090076711488, 0.23576020174409174, 0.3288123826108338, 0.2670265505539483, 0.24780530150544933, 0.23826519928957535, 0.18557045005890271, 0.25571498423829353, 0.30769860059500476, 0.22915259185161185, 0.12271014494764954, 0.07392954381315098, 0.13448219933461392, 0.13303440692654311, 0.12487579626647605, 0.11855628747063929, 0.12142503602941801, 0.12859979684645328, 0.10743759986067358, 0.1968172535388919, 0.1194643368249757, 0.17168556361612208, 0.1275002482799057, 0.12345992767565384, 0.12332757265793248, 0.1338261127692162, 0.12682274283841122, 0.12398711467376922, 0.01348502633782267, 0.0011774934293811157, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11237709086234704, 0.05684633227047453, 0.035449198118031044, 0.04680162750223227, 0.02618486072743431, 0.06180369503059524, 0.10090116765824964, 0.03539806036681492, 0.10407574949089327, 0.004273342328122487, 0.002540227494806091, 0.003032105665669027, 0.020520564061570212, 0.01095380257319134, 0.02497332483923198, 0.003206802349832283, 0.012942663485888128, 0.010293166288684374, 0.04118821331059064, 0.0703702005231811, 0.07437233250154729, 0.06429221505575422, 0.06707522243838848, 0.052773939850767615, 0.06855495107785914, 0.04750853497146379, 0.04474657167942986, 0.3590170795837352, 0.37427316281617296, 0.35955788313775205, 0.3653062653114012, 0.357076966188311, 0.3611634388601901, 0.35031092210614667, 0.3589522555868697, 0.3621085703810393, 0.09171450000878378, 0.0844385957917444, 0.08541508852063484, 0.09109862149461534, 0.09780083214673085, 0.08857203919999523, 0.09530537730464361, 0.0892462724114863, 0.0960936041863637, 0.1399440479939874, 0.1319279464855686, 0.14088146102452082, 0.1671718288817694, 0.1406508619088258, 0.14456139057778872, 0.13084637082552653, 0.17243857731821788, 0.14031867029666423, 0.25138735383689526, 0.25667723732354497, 0.25855270607770153, 0.2573900375314614, 0.24736338753974674, 0.2571775402931482, 0.26219448288333813, 0.2694767805528988, 0.26260578922244904, 0.1771320941917004, 0.19078553346770755, 0.1967464373910499, 0.18731011482109838, 0.19568654666517005, 0.18924739152674008, 0.2084948949495985, 0.20578570706598043, 0.21639626156983371, 0.19738429351002273, 0.20390062394276387, 0.19014711412354002, 0.19145454361397718, 0.1986024314213911, 0.1924803987555581, 0.20234387867736048, 0.18874690180609233, 0.21637077275316063, 0.21514757947967378, 0.19452503303840518, 0.17908248537092752, 0.20002447963313097, 0.17658399753621346, 0.1857930548199398, 0.18937297590594504, 0.18221733824769704, 0.20003304601204108, 0.17772257371981381, 0.5187345280364679, 0.18140519991120774, 0.5349528425404423, 0.5312944107289945, 0.1640897536680821, 0.14141072767417062, 0.14296740805647767, 0.1650258488692018, 0.19716610541459778, 0.20113611310941915, 0.3400970382250813, 0.1623154531031067, 0.204563546030904, 0.19816489488742683, 0.2093867817741084, 0.20394913330235032, 0.20918838091524883, 0.19307726678281667, 0.18737752477061165, 0.17988290973635035, 0.181629774380757, 0.1916510625436184, 0.18140591934170458, 0.18621694205942252, 0.17836739800821866, 0.17911337082785173, 0.07610684299704151, 0.07766723054243463, 0.0916723381168636, 0.08044421306745031, 0.08483688219845775, 0.07714074599129306, 0.07363364373369952, 0.09036938965611696, 0.08775490006384301]}, "mutation_prompt": null}
{"id": "3d25202f-b41e-4562-b10a-e8a2d15f5831", "solution": "import numpy as np\n\nclass HyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 # Crossover probability\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5 # Cognitive coefficient\n        self.c2 = 1.5 # Social coefficient\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "HyDEPSO", "description": "A hybrid Differential Evolution and Particle Swarm Optimization algorithm leveraging adaptive parameter control for effective exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.8397495676609655, 0.8190300489277756, 0.8398750345460931, 0.8397650948869302, 0.8366798786443894, 0.8313015892072477, 0.8245302350980133, 0.8249582159802497, 0.8308134626020947, 0.6487214926601398, 0.6783795521098726, 0.6620149026850402, 0.6230439058570865, 0.6735584857093964, 0.635270642486297, 0.6254502288799718, 0.6289787694262154, 0.6736917853956854, 0.12503759738790088, 0.13554453689206747, 0.1771278060932061, 0.17508093836242988, 0.15141497907699852, 0.10317843460741716, 0.1732031904867366, 0.15298376353876852, 0.11143657448788802, 0.10577500175481636, 0.1231787354538465, 0.13670000284870787, 0.12438066112305601, 0.13359233635335366, 0.11231523199175042, 0.0947159041281933, 0.1301693323602673, 0.08818530945095548, 0.9644974709473209, 0.9419601691244215, 0.923311768894063, 0.9271074104229867, 0.932993425666828, 0.9039612080623244, 0.9215780286333194, 0.9542097321210484, 0.951453532818375, 0.6462847802826264, 0.6629043098747704, 0.6246402484784812, 0.6359269396412675, 0.6008794899607808, 0.6473673583067852, 0.6146107113061905, 0.6296315392869425, 0.606497117458239, 0.2292278227415413, 0.22426437853539338, 0.22300618771580727, 0.27378852382942653, 0.269976839147537, 0.7797423294294236, 0.22070260392231733, 0.23196699347373861, 0.22071890552493512, 0.12813727206610215, 0.2605173072371082, 0.19732230055393196, 0.25715398690181046, 0.12808934079071244, 0.19704697411652683, 0.21997594206284032, 0.23384855428711948, 0.21299395367325458, 0.20781159014248762, 0.23349915394293708, 0.2316316793131773, 0.2325187894419095, 0.1286871304888717, 0.21093907892916453, 0.2505072731754482, 0.24094301175456367, 0.11749879029847776, 0.005231023895867826, 0.1849864088740234, 0.013905123892463789, 0.04451611749692619, 0.012453013605185137, 9.999999999998899e-05, 0.0032065760069228677, 0.0024215129760032372, 9.999999999998899e-05, 0.06837924492958625, 0.15353884267960294, 0.0772819690980523, 0.09185625843295964, 0.0944093144368926, 0.16723526035875436, 0.057408462936272, 0.10134526080966155, 0.11401616719697139, 0.042556193065264036, 0.23882209929295373, 0.04591854711358678, 0.15735597999168172, 0.08147668535611263, 0.1570339445614105, 0.14532986976845963, 0.23260541667178591, 0.17647291208599314, 0.1838623706935688, 0.29605413373279044, 0.17146907825406565, 0.14870902295655675, 0.19608127962715338, 0.1565236342933255, 0.16008436336483178, 0.11120667633500447, 0.0827227754687676, 0.5154910896440872, 0.5346257695762768, 0.548273398000598, 0.5828631313801337, 0.5520627124191595, 0.5912840153066254, 0.5664807650666381, 0.5594783994482939, 0.5491195342847467, 0.10322431767736473, 0.14923889073083663, 0.1270561248958737, 0.12850047896967265, 0.11330680221982603, 0.139818687437965, 0.13746450567375346, 0.13590009062795017, 0.1506218910748779, 0.35043278450595505, 0.29530263984903315, 0.4879017417107462, 0.4460200246945929, 0.19528890825837497, 0.31740463533914876, 0.4713817665049883, 0.49259555332736904, 0.40431347824219743, 0.26193081368045856, 0.5928802856934643, 0.5610181930625151, 0.4264587320227091, 0.5641841636786352, 0.4262556559089017, 0.5191494133116514, 0.5548967606276047, 0.5231489689276392, 0.3056127503213857, 0.20105470698984795, 0.3533152500716086, 0.25184557863655566, 0.33303051076504475, 0.30818215389966686, 0.3472297334823259, 0.3555573852195195, 0.4534175484075891, 0.23929541617054362, 0.2198830235341256, 0.20829148154376453, 0.23621305422988315, 0.21712016022416591, 0.22783956046849885, 0.22903601559876774, 0.2264453624844991, 0.21408577983177202, 0.19617166210049874, 0.6910006932719632, 0.24220890859972655, 0.2001742027031852, 0.1938672859617816, 0.20613774523759876, 0.5521166924555492, 0.22169109437971923, 0.21852139877317744, 0.18679417527018427, 0.18548482517648346, 0.19791267110750155, 0.8985858324777274, 0.15921489447426906, 0.16665607894650913, 0.16843597512104447, 0.1700147578051847, 0.17597989345915743, 0.7453955579706146, 0.21019721790674006, 0.7700748149146781, 0.8363555505253817, 0.16813619684031, 0.7878323755399157, 0.1639235079099528, 0.7841477077768183, 0.20832846198338717, 0.18899365566065007, 0.18667423212974787, 0.18411983885909733, 0.1844262548959653, 0.1980708845196596, 0.1997022546746472, 0.1931314753242782, 0.19663274589911728, 0.18750809551132386, 0.0943226258612132, 0.08635202805268694, 0.09616496775629946, 0.08856115479701931, 0.09102712876233998, 0.08847613806435495, 0.07779122787482173, 0.099665255659944, 0.08609890564256961]}, "mutation_prompt": null}
{"id": "854c7971-61b5-432e-b45d-450cd132fb94", "solution": "import numpy as np\n\nclass HyDEPSO_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 # Crossover probability\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5 # Cognitive coefficient\n        self.c2 = 1.5 # Social coefficient\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.decay_rate = 0.99  # Decay for dynamic sizing\n        self.learning_rate = 0.1  # Adaptive learning rate\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if evals % (self.budget // 10) == 0:\n                self.population_size = max(5, int(self.population_size * self.decay_rate))\n                self.population = self.population[:self.population_size]\n                self.velocities = self.velocities[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = x_r1 + self.F * (x_r2 - x_r3) * (1 + np.random.randn() * self.learning_rate)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "HyDEPSO_Enhanced", "description": "An enhanced hybrid Differential Evolution and Particle Swarm Optimization algorithm with adaptive learning rate and dynamic population sizing for improved convergence.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (50,5) (49,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (50,5) (49,5) ')", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {}, "mutation_prompt": null}
{"id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.6  # Slightly increased Differential weight\n        self.CR = 0.85 # Adjusted Crossover probability\n        self.w = 0.4  # Decreased Inertia weight for quicker convergence\n        self.c1 = 1.7 # Higher emphasis on cognitive learning\n        self.c2 = 1.3 # Slight decrease in social learning\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization employing Differential Evolution and Particle Swarm with Dynamic Strategy Selection for optimal exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.34349079566765867, "feedback": "The algorithm AdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "65d48e9e-af65-4552-abcd-52d6acea4cdb", "metadata": {"aucs": [0.8654156628884216, 0.8505577733650087, 0.8629165407617487, 0.8380421862650951, 0.8456388156840458, 0.8587296791285854, 0.8527912259306096, 0.8559354413193545, 0.8534634313822277, 0.7396929881209096, 0.7341634510349436, 0.7092094663753394, 0.7154728891383115, 0.7193812497122521, 0.7182816213467694, 0.6967750011711794, 0.7069553883493507, 0.7000883977891325, 0.1114105147072143, 0.1481172016688579, 0.1526431654403636, 0.13387851849765897, 0.5442252168246698, 0.14871135036606575, 0.14941128180821783, 0.17945018706496574, 0.1721961393818332, 0.11263438928044145, 0.1503320556503278, 0.11906872559250425, 0.07768433680669018, 0.123196329897314, 0.08839246620613794, 0.10215271061855224, 0.136861489246068, 0.16872141851491052, 0.9553658555778358, 0.962358918073187, 0.94632188274503, 0.9478315924386019, 0.933922097238991, 0.931645767660017, 0.9331854407292095, 0.9361184003567173, 0.9475659196534141, 0.6944265741588745, 0.6856320914341114, 0.6895938036266172, 0.6512602616989766, 0.6877164471456558, 0.6968459829021534, 0.6826596919438079, 0.6890696982652229, 0.6820549676551929, 0.22635534559259274, 0.2395695445189302, 0.871631368557718, 0.27643157799925233, 0.3776060212088548, 0.3654865471871893, 0.22726557497574373, 0.23187077237783693, 0.8641424405872651, 0.11911049122598305, 0.40253532485593235, 0.18724974672384187, 0.18685655018194935, 0.1762400387692964, 0.1677187013488063, 0.20015727878600587, 0.13013515604564707, 0.19273282982800555, 0.13054336021097146, 0.20357835941169955, 0.18189917360312102, 0.20288068384517965, 0.21443735838623112, 0.2665297124948879, 0.10045236270221536, 0.22433507035561873, 0.24968235924269622, 0.04569264568070608, 0.046478388727113074, 0.009403796381180163, 0.11558206670531146, 0.022272836136776775, 9.999999999998899e-05, 9.999999999998899e-05, 0.010927236322666789, 9.999999999998899e-05, 0.09869799781293243, 0.1090027274030263, 0.05063311386168057, 0.04550856712314999, 0.04423383431881778, 0.06882428231234117, 0.08488780433257614, 0.06915948266957872, 0.05616918626292622, 0.09745344578854442, 0.14266038440678452, 0.056123739872517175, 0.07390068554872598, 0.11734251827298636, 0.12287962955005238, 0.0980558089589878, 0.313793869868884, 0.08787551386325854, 0.2917486797997608, 0.07946991282739091, 0.17224156652019373, 0.05828027627746901, 0.1303077885280134, 0.11646763760169576, 0.08124608208620498, 0.09380995154813043, 0.11633120525826257, 0.555773540156163, 0.5361648390238402, 0.5955635893097015, 0.5903343412986675, 0.5705534059184401, 0.5907928198654778, 0.5864770506960435, 0.5807836462029989, 0.5758600831607168, 0.10120420675667552, 0.12293330861734575, 0.08053869524767177, 0.12354207506704484, 0.08073736346821536, 0.10272482608129685, 0.1532115312741822, 0.1360901696747585, 0.11231936726528802, 0.2996945930024152, 0.15036461848789773, 0.29192725793646557, 0.586998814628755, 0.2399129418500099, 0.1898988614820507, 0.27985674526575943, 0.3083813152828182, 0.5046665857709443, 0.37562013603185973, 0.6232592500722111, 0.3557764990869141, 0.5437494596585588, 0.3267962797244046, 0.5034191970719868, 0.2674787778771113, 0.5388690396864722, 0.6257347160992258, 0.23055603168705607, 0.2447596166552669, 0.39697389969629493, 0.2625329956848663, 0.40754650098073675, 0.29008056153170936, 0.1751376443979058, 0.30452850055108005, 0.23510988528554233, 0.19668727799983587, 0.20910730931872668, 0.2175758334347292, 0.20338777031504363, 0.18505592405916904, 0.23282516743307258, 0.23561468261837826, 0.2084214935526616, 0.1992958345658873, 0.22347397714813655, 0.775697066021013, 0.7596980411140908, 0.19538432929097282, 0.2243522715669185, 0.2028591502542586, 0.2386133439715501, 0.19782069255035517, 0.24194431253744464, 0.16480578984400673, 0.18666277229218065, 0.14688420848316563, 0.9098379302694619, 0.1982514777222646, 0.1475028254563553, 0.8731942555370419, 0.16665056287172852, 0.8805288423103896, 0.20927865953032454, 0.21108787377126625, 0.8533564639442084, 0.763389303028059, 0.16733100051057104, 0.8613345632732998, 0.7485132509000212, 0.8102590047437631, 0.7780868464822436, 0.17160405761841613, 0.18127479983452888, 0.18169009769591782, 0.1879575855717499, 0.18826675033422202, 0.18053776450857095, 0.18172286449606012, 0.18021609380021242, 0.18721428705009724, 0.09942796858883207, 0.08282587662772478, 0.09296007929933059, 0.08365309054045356, 0.09063972579928448, 0.10307454917509362, 0.09162982471474646, 0.0995422377362134, 0.08839800323757774]}, "mutation_prompt": null}
{"id": "6adc8420-591e-46ba-9f6c-3d1df3b0f1ba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7  # Slightly more aggressive Differential weight\n        self.CR = 0.9 # Higher Crossover probability\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.5 # Moderate cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([float('inf')] * self.population_size)]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # Wider range for adaptation\n                self.CR = 0.8 + 0.15 * np.random.rand()  # Slightly tighter range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Enhanced Dynamic Strategy Tuning for improved search efficiency.", "configspace": "", "generation": 10, "fitness": 0.3051407233868743, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7996894899279003, 0.7783543459828148, 0.7916400320986785, 0.8034409583617581, 0.790111008002273, 0.7899756856811857, 0.7949354377142268, 0.7952162461808261, 0.8038121629071739, 0.5913700157901913, 0.6288538479985786, 0.5786484871257276, 0.5929135114852904, 0.6211917197714996, 0.5825830933359148, 0.6355576818826034, 0.5960239123996617, 0.6075079292396843, 0.1162749363500929, 0.14057090763640512, 0.113646429346283, 0.12303069629034658, 0.1349895664366242, 0.12221926083374623, 0.1743803390352976, 0.14064965978727773, 0.14825248031158533, 0.10416745502340907, 0.10346520045011709, 0.11051074158658192, 0.10410407661476906, 0.12205085769615087, 0.10076095173000266, 0.13028996473980659, 0.11086186340705284, 0.16050477489798143, 0.9526071989425186, 0.964324559601642, 0.9586306072489498, 0.9573424045080433, 0.9475497206264047, 0.9656526251955347, 0.9553196650332632, 0.9656552842738115, 0.9705904470515175, 0.5605795626208038, 0.5468596973796579, 0.4861255475611147, 0.5609847595934332, 0.5625559480755913, 0.5135652815200102, 0.531818967512065, 0.4701070828657763, 0.4970467735025196, 0.20800429251550534, 0.2198647150790084, 0.2222452353291695, 0.19173584326814153, 0.2052134641500175, 0.20722922246837872, 0.6962798407476467, 0.7881489147215062, 0.4505763164286447, 0.11856742805949783, 0.12064130853785737, 0.10570214598197414, 0.202682690492634, 0.2150527949786727, 0.11922574331047531, 0.21072059150822864, 0.12123318655139215, 0.2097222095473804, 0.20888863657532297, 0.1767806607280521, 0.2067595842330311, 0.16184820403958888, 0.23152869915190344, 0.3215115163314838, 0.2325249301634763, 0.2275947439468018, 0.1262611007163732, 0.03478185622997898, 0.03542428099978623, 0.033848811037125004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06255191816614314, 9.999999999998899e-05, 0.0211869663895633, 0.06219735686648986, 0.06823775386102282, 0.046212137660273434, 0.06954170489839795, 0.09199255717207089, 0.08986835654189873, 0.04820093019252669, 0.046390617172872184, 0.1333347515290163, 0.05766680358802789, 0.10889995343425762, 0.07081453768573542, 0.24201359488818175, 0.1773485405437183, 0.15198082806506152, 0.12219219563728345, 0.16809259908033236, 0.1464268476660998, 0.09383149212282749, 0.10193787262597565, 0.11648393715266048, 0.0812252909396961, 0.09574152403206904, 0.08000818619541283, 0.12069907840292293, 0.07959310576959266, 0.5283305791115084, 0.5354948948000458, 0.5278472190543538, 0.5453061188893615, 0.5175766219048015, 0.5295355711353888, 0.550418211842612, 0.5326235281118482, 0.5307272884962662, 0.12422408870960466, 0.10081850388322733, 0.10989098589911295, 0.1370004657791486, 0.13898132472080382, 0.1424660985550199, 0.15854781276469254, 0.1193141753603586, 0.16903169759755088, 0.5328011743250571, 0.322213617703067, 0.2615863852498014, 0.13577146876018542, 0.18233977027301718, 0.12863924066306898, 0.32661302872224696, 0.1967656732980605, 0.38322049093709176, 0.48088690288058855, 0.3939396437935134, 0.34852333935138124, 0.46067090055883075, 0.46333122962548323, 0.5000123761957607, 0.5302448268936476, 0.47227494957623717, 0.36770609051254555, 0.2603130633583822, 0.31163103586728536, 0.3338024699755108, 0.3136867750040043, 0.1906151343290029, 0.3008601078576889, 0.2799857632204884, 0.2529567644669549, 0.254384035078111, 0.19579125644216178, 0.21835741501982686, 0.21902611846350106, 0.20259687930966352, 0.20583308327056837, 0.2590760677629864, 0.2168248278541972, 0.19732789592894717, 0.22345982222240846, 0.1968174804426065, 0.6310185470679597, 0.21786430061066764, 0.21557207052951832, 0.2375136328921409, 0.20116124656898016, 0.18694993165120855, 0.6201592670823112, 0.23323774046237133, 0.18484594483874695, 0.17696815145387312, 0.16991420028013815, 0.8883676797782232, 0.8432410848773589, 0.19786963395829227, 0.18818992935985868, 0.16183038174710418, 0.15640147169802876, 0.6336651553717338, 0.21193943675421, 0.7561118878778965, 0.166080009636983, 0.16571952056604733, 0.7199218459831495, 0.21105613907132414, 0.20922565014886574, 0.21054300006782212, 0.17440174819571252, 0.19537567320880056, 0.18642910217029285, 0.17223895968798353, 0.18449122848937927, 0.1694263158514836, 0.19082580260281634, 0.17289750117567415, 0.18846481823861994, 0.07533249123108277, 0.09219321526826885, 0.08776251919956934, 0.09227163743223521, 0.08378677853042993, 0.08479318328193308, 0.10157544265173968, 0.09081302748480735, 0.07728438743826149]}, "mutation_prompt": null}
{"id": "9590d93f-f9c4-402d-8ec1-3f952327da8e", "solution": "import numpy as np\n\nclass EnhancedHybridGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 15 * dim\n        self.F = 0.5  # Differential weight for variation\n        self.CR = 0.9 # Crossover probability for diversity\n        self.w = 0.5  # Inertia weight for balance\n        self.c1 = 2.0 # Emphasis on cognitive learning\n        self.c2 = 1.5 # Emphasis on social learning\n        self.mutation_rate = 0.05 # Mutation probability for genetic diversity\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Randomize within a range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Introduce mutation for diversity\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.uniform(-1, 1, self.dim)\n                    trial = np.clip(trial + mutation_vector, self.lower_bound, self.upper_bound)\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridGA", "description": "Enhanced Hybrid Metaheuristic fusing Genetic Algorithms with Adaptive Dynamic Strategy for efficient convergence.", "configspace": "", "generation": 11, "fitness": 0.2775648404556564, "feedback": "The algorithm EnhancedHybridGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.6838980616548327, 0.6784541001192999, 0.668063499291135, 0.6534514760026486, 0.6494019448585262, 0.677407920569785, 0.6686965850500403, 0.6920189031390115, 0.6476211758106833, 0.34527535916175633, 0.3749681445852585, 0.3899072197716953, 0.3821814876438957, 0.3441698583825038, 0.3798588584876963, 0.3023275367873002, 0.38821258997612174, 0.3762913948397467, 0.16697020812833074, 0.12882348836054136, 0.18151263371913195, 0.12762106067687473, 0.12800449291744354, 0.13037798839950832, 0.1558651786671975, 0.178866616042468, 0.17295338949841155, 0.10732737498135736, 0.10466410290596051, 0.11512694286707026, 0.10847833774066351, 0.09805034852371208, 0.11186865469553109, 0.12691015120819849, 0.12782553852436573, 0.09939566135550382, 0.8824561686446796, 0.93748222245297, 0.8865788044840537, 0.9115609092333405, 0.9113591410880285, 0.9366972638507743, 0.9358697665025405, 0.9036920854453617, 0.8788408372328609, 0.34617241850934577, 0.36879939363613545, 0.31830379351418236, 0.36553546760351086, 0.3596476904757858, 0.33766000383789696, 0.3149040707468366, 0.3000465315919292, 0.34260128733079287, 0.3477444908624798, 0.34691474779530185, 0.6946164488402474, 0.5930637305878357, 0.6833891947014696, 0.6771071674713599, 0.6199232890354287, 0.6947741190160779, 0.6666915693822889, 0.11777567968597902, 0.159006573875496, 0.188286925701604, 0.16765653970526617, 0.1745372848962543, 0.24792313765535423, 0.18617451793222994, 0.17102724925364932, 0.1713794741487341, 0.17794729728503533, 0.20445186327970444, 0.17276352710700738, 0.1251172133954298, 0.18861578025382053, 0.16919249954163718, 0.1985727035946354, 0.1959185465291624, 0.18909863775822655, 0.01458405547889119, 9.999999999998899e-05, 0.05849699844444689, 0.0011952887005162172, 0.01495785125655369, 9.999999999998899e-05, 0.006737166748248979, 9.999999999998899e-05, 0.03906302787801286, 0.17417170124082404, 0.14281761597804254, 0.0581135318116216, 0.07171311099055944, 0.053081442438853044, 0.0679820218317736, 0.08710997691346567, 0.16003714076010822, 0.10735098130642762, 0.10998969508196876, 0.020657026210468388, 0.05869240415446075, 0.05395223808771299, 0.03851295533968935, 0.028309122550345456, 0.03151317814278698, 0.06801607788191777, 0.08632656000293826, 0.12024885781377892, 0.10276772709467386, 0.11628195086161508, 0.11656605541286758, 0.13439315706027533, 0.09481455105959236, 0.08793769070784596, 0.08352733045949245, 0.14318634689473964, 0.4667258108707584, 0.4924841045627655, 0.4699643088351336, 0.4896043536457635, 0.47225056676482313, 0.47174499486980326, 0.48568488698007284, 0.44738293081883407, 0.5055349296970038, 0.1161476339697669, 0.14111799189529206, 0.10093464821705622, 0.09814163533219944, 0.10158885889961344, 0.11768605477833627, 0.10941655921457805, 0.09767626861878631, 0.10595712561128423, 0.2556113281818272, 0.2333826146266258, 0.14049360264364552, 0.22612703509300358, 0.21045984869434498, 0.20362627021418722, 0.14152657924135403, 0.1421740347403314, 0.15579303197885042, 0.35105202756056775, 0.36435121293170236, 0.33811311393420174, 0.3858189225186276, 0.3845232033881665, 0.35661103709786846, 0.39606890742073964, 0.3643787046700945, 0.3711968074784301, 0.2664464326748125, 0.22331220322939782, 0.25522195834641903, 0.2815802452303151, 0.19873435920555615, 0.2573238031875541, 0.26795062868586006, 0.2884386828594746, 0.27342988828543713, 0.20373518414580138, 0.20840108228032195, 0.19463407326851434, 0.19052732055268973, 0.22118282592026384, 0.24867075636564295, 0.21769369481542555, 0.21221741944482098, 0.21886720318326824, 0.18706205986049484, 0.22802188368650889, 0.2714398976080521, 0.45507413558421483, 0.20296318634232524, 0.3250469058344514, 0.20701684027929512, 0.20988080365004969, 0.1935099355628277, 0.18250967241390703, 0.1742842962868485, 0.17962148775328768, 0.7793703692634497, 0.760720394381604, 0.2041631282017794, 0.7506284670108158, 0.7669816108256768, 0.16558392432226887, 0.44387934355493885, 0.20758752708077965, 0.5775584227900739, 0.20470058584394346, 0.20472577239965295, 0.1650437212616931, 0.15411589863259, 0.16219663236493942, 0.5646447193389863, 0.17829981254011418, 0.20923507348352777, 0.18537512465117234, 0.17255190924360053, 0.20120128327102438, 0.17962424552994838, 0.18086006305698732, 0.1877543138887635, 0.18476082031061547, 0.08956469045464255, 0.08261220002498393, 0.08656919960785259, 0.08851193071143337, 0.08467931683643781, 0.09496859087290066, 0.09228171153206932, 0.09575765818266424, 0.09721507699710674]}, "mutation_prompt": null}
{"id": "ee00a3fd-6b87-48d7-a6f7-0a7b92ebe5ee", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for better exploration\n        self.F = 0.6\n        self.CR = 0.85\n        self.w = 0.3 # Further decreased inertia weight for faster convergence\n        self.c1 = 1.5 # Balanced cognitive component\n        self.c2 = 1.5 # Balanced social component\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Slightly reduced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        \n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Adaptive mutation control\n                self.F = 0.5 + 0.3 * np.random.rand()  # Broaden mutation range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Broaden crossover range\n\n            for i in range(self.population_size):\n                if evals >= self.budget:\n                    break\n\n                # Differential Evolution mutation with diversity-based strategy\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate and select trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization with Differential Evolution and Particle Swarm featuring Adaptive Mutation Control and Diversity-based Strategy Switching.", "configspace": "", "generation": 12, "fitness": 0.31267094241165944, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8380883276703297, 0.8306683143694131, 0.8296751540402403, 0.8239730501156642, 0.8314853516160523, 0.8255691607581248, 0.8364757938132896, 0.8353331662125849, 0.8293215810798573, 0.6603266555810993, 0.6715296612282764, 0.6770723572325476, 0.6751353723619231, 0.6388906412806794, 0.6840027552101864, 0.6804510246480407, 0.6907882625268229, 0.6750743324249827, 0.17349723859742605, 0.16992849163183532, 0.17582638952066587, 0.13524251835857937, 0.12822223712314917, 0.17023027022171777, 0.15209673545888214, 0.15218777715874532, 0.5260580979977751, 0.09261603187594392, 0.1007041904211241, 0.1217800028895143, 0.13419112770636388, 0.06318279338661592, 0.11728812486682383, 0.12393602020805827, 0.13548303539684892, 0.11092089137480254, 0.9535397213085209, 0.9119049144534561, 0.9212753056036497, 0.927521814536897, 0.9222322195763851, 0.919363975967251, 0.929564477207249, 0.9700415375518032, 0.9215044209698321, 0.6017704804738031, 0.642613109235278, 0.6229943458706663, 0.5915391369210538, 0.6347526495792478, 0.5993449310044582, 0.6245735691340568, 0.5933237808572658, 0.5982779488422518, 0.22506179890374223, 0.22273984454140172, 0.22240150106729795, 0.21455888723380356, 0.42849641462235555, 0.208650336488875, 0.2350063553446009, 0.23034888040637747, 0.8197893923113525, 0.19461820258841112, 0.21727104363901462, 0.12682025530851115, 0.19287850885688207, 0.12381140350881292, 0.180102314973703, 0.1865191421385226, 0.19924444449727874, 0.18464646026845932, 0.21530682224887, 0.18492274770427186, 0.21445096443144007, 0.19046182965570702, 0.22187334318494722, 0.19153655246841916, 0.18339966900943128, 0.22183931309388605, 0.21692041908586002, 0.04109918577941385, 0.0004933602633176992, 0.07582738616306528, 0.05486816338587175, 0.02026647033049589, 0.00541809610335553, 9.999999999998899e-05, 9.999999999998899e-05, 0.01770317669795274, 0.09323922105146454, 0.12087631996612014, 0.10063683061243323, 0.03859720348115114, 0.05298651445767588, 0.08479513578487308, 0.15922379938957898, 0.09101887694891897, 0.0659677946569518, 0.10955371749899712, 0.03411830768145241, 0.03619733897668853, 0.12974553081889484, 0.11219782674087564, 0.0851975318631063, 0.1586946783438452, 0.1610882715387898, 0.15985608857458722, 0.11928380192692545, 0.09697587606907487, 0.17439900233309313, 0.0750376557694451, 0.10298523024912176, 0.08641514485268909, 0.08279889577439459, 0.08193138235614716, 0.2448763932593795, 0.5434269224147047, 0.5576442817879002, 0.5485492857640721, 0.56025294621795, 0.5999007237373553, 0.5250164494515202, 0.5246249528259852, 0.6120697538034225, 0.6208007319460023, 0.13616128630431745, 0.1370610176042515, 0.10547437072345656, 0.10176277740134554, 0.1707323243066292, 0.1298267026910166, 0.11377645288098792, 0.16776293186665792, 0.17333504712605952, 0.4779131374733375, 0.37706913387426844, 0.37653024174179384, 0.289506792448586, 0.16713393052750403, 0.23884882327173373, 0.37255865765259, 0.19927686121247468, 0.17813157135726765, 0.23202052405549545, 0.515489265918967, 0.515269833947724, 0.31480987799304994, 0.4468918432209463, 0.42126546189494307, 0.5883456479312399, 0.5939994735807965, 0.4745455345673253, 0.29531695038301264, 0.2596378942162161, 0.2970961652306565, 0.3274733195493358, 0.2795011104018045, 0.30694197002539325, 0.2194641685070795, 0.21807763305516648, 0.2198614313594155, 0.21752334664875372, 0.19512363044806935, 0.21149977895556638, 0.22785226444063034, 0.23367230300768338, 0.20508779243340236, 0.23616277955006992, 0.20509560280308725, 0.21064830162064396, 0.1894005881232549, 0.238779952738986, 0.20290718028496202, 0.17796450636540195, 0.21979687337856868, 0.19691273288170508, 0.17781532019250113, 0.2033480043167133, 0.19135743349690948, 0.17525695519278273, 0.14577640771835687, 0.18540130332039328, 0.8500908440320526, 0.8896901688122165, 0.1453517477553523, 0.8680242949994266, 0.8589321232139611, 0.17444446621059229, 0.21010029002882458, 0.2100233923551179, 0.11085238349383253, 0.16695782636669132, 0.15199415267609984, 0.20866018683669862, 0.1040884302879369, 0.7202472804763524, 0.103722321179468, 0.17653676198670842, 0.18846750707239046, 0.18238620328292, 0.17449218533019395, 0.17594634619716432, 0.20003738699191054, 0.1767888889285767, 0.174909646163097, 0.1858518621707379, 0.09371845872837425, 0.10674020244723614, 0.09059715750021913, 0.08041465166306183, 0.08766270695971345, 0.09606636103480193, 0.09055763807858552, 0.07860318548147682, 0.09378889726593698]}, "mutation_prompt": null}
{"id": "318a9b88-70ab-49ef-8b1b-78922a400a29", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Adjusted Differential weight for dynamic balance\n        self.CR = 0.9 # Higher Crossover probability for diversity\n        self.w = 0.5  # Balanced Inertia weight for exploration\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Modified velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.elite_factor = 0.05 # Elite population retention factor\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            elite_size = int(self.elite_factor * self.population_size)\n            elite_indices = fitness.argsort()[:elite_size]\n            elite_population = self.population[elite_indices]\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.elite_factor and i not in elite_indices:\n                    continue  # Skip non-elite to provide elite advantage\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update with elite retention\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reintroduce elite members to maintain diversity\n            self.population[:elite_size] = elite_population\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization utilizing Differential Evolution and Particle Swarm with Dynamic Parameter Tuning and Elite Retention for improved convergence.", "configspace": "", "generation": 13, "fitness": 0.32048156875942885, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.812206756026248, 0.8279312315305971, 0.8184980281078289, 0.8287991888639529, 0.8282792884549096, 0.8285517277329507, 0.815213704859453, 0.8318191327988675, 0.818962646738676, 0.6738333237356511, 0.44677517035159586, 0.6586229323550414, 0.5459402120398991, 0.5401260706204185, 0.6570421366391017, 0.67697381559004, 0.673528242201911, 0.6566144903308146, 0.1424921112860955, 0.13781925926985183, 0.5219090273356219, 0.13083797030656752, 0.16154330837936537, 0.16672845843787, 0.10641771819705448, 0.5615375994769322, 0.1666337709354091, 0.09299826184119098, 0.14753645090121625, 0.14557590023476918, 0.12827577651428435, 0.11624787482918619, 0.1321240253512187, 0.13491748400652848, 0.13177212547536343, 0.13044012049187093, 0.9630651170892754, 0.9454959417941762, 0.9253546650852511, 0.9633683474042133, 0.9399733028149031, 0.9560833224093639, 0.9704788864117425, 0.9530120644877236, 0.9510512589455672, 0.6474986823293623, 0.3220089420224014, 0.6390523037199423, 0.6557158877447635, 0.6368048120464631, 0.5651846463499899, 0.6102681842604823, 0.5887008754631476, 0.5649051926954998, 0.21589549614079218, 0.22371918682882208, 0.22072876064362734, 0.858153346280863, 0.8083875152430438, 0.2735854898553187, 0.24447600386214208, 0.3667877335472537, 0.23688141727706757, 0.21723617011919927, 0.20701791717721207, 0.23157906512534931, 0.10625517264512041, 0.19145963728214244, 0.22739333033941445, 0.23284178038721237, 0.21411067850797882, 0.22249420212059612, 0.21284829825865403, 0.2032082593246961, 0.21923242211063532, 0.23253610088469567, 0.2298007867947709, 0.2400146527813124, 0.20853527984277453, 0.23627435493421867, 0.24978994154688217, 9.999999999998899e-05, 0.030472538921964554, 0.05341523315352259, 0.03454517926991829, 0.049484407030398136, 0.07484275344303803, 0.04147314818470438, 0.00010598065217215513, 0.0041980525081264375, 0.09720039140381198, 0.08073181238044302, 0.06075754410938661, 0.1372926368033235, 0.08736923076366365, 0.09878716917499475, 0.034448216244796104, 0.05236184696895674, 0.08479379842455581, 0.10375149444112541, 0.04611778145163281, 0.13587787903958837, 0.07283080391609142, 0.07692308531033376, 0.16005622523367857, 0.0897864972261847, 0.1095584692253978, 0.09987632362762144, 0.2755660188587531, 0.10758327772887188, 0.1610120351748341, 0.07289050289018251, 0.08633939668573598, 0.15765084488721837, 0.1707553428988393, 0.21181428220632947, 0.07986402022182881, 0.5592391022564028, 0.5327224980317923, 0.5638707165128474, 0.5567914284434343, 0.560542734669875, 0.5537993862246573, 0.55213817757952, 0.554800230898548, 0.5441959171912147, 0.13846507873153802, 0.12418329401210071, 0.1470332099959245, 0.13666798267459257, 0.12204147758700745, 0.11445217277743436, 0.14786091575709848, 0.1346742519531352, 0.1513873976476081, 0.22750951860784374, 0.2112192969886355, 0.3136565038028253, 0.23041239728712337, 0.1601700991877929, 0.2973856611944782, 0.23987795783943255, 0.25560952129583725, 0.15955371303803512, 0.275766913431169, 0.5892799982822403, 0.396472341329552, 0.3241008899227712, 0.3958236966970753, 0.3825347382461104, 0.4984990066817653, 0.527646567954331, 0.25750106394994887, 0.3034877747582163, 0.35870305727494656, 0.3277719700923294, 0.32221528426962454, 0.28290287550338866, 0.25642131590670947, 0.20378144726966185, 0.26860291262857316, 0.4282004350478721, 0.19829469844974335, 0.20238316637564624, 0.2101814665810975, 0.22074062198365896, 0.21269735379023869, 0.2096093596564178, 0.2144611832554576, 0.2194934137472403, 0.22804013394240708, 0.20860811540725333, 0.1968712009937783, 0.20025566278575524, 0.20724022065866954, 0.19382648566184546, 0.21483600597122265, 0.24486416226765195, 0.22248955345340105, 0.2137486953693346, 0.16958396507845808, 0.8624880892101257, 0.8761352211101623, 0.8750989719180712, 0.1684422610144587, 0.8596655471597324, 0.2114111078484865, 0.17410351869265017, 0.18739228509440464, 0.8094920648260912, 0.15533080223519935, 0.11244560284673699, 0.16324606484201742, 0.20751033338221192, 0.7576974760810679, 0.1117250188744332, 0.1686375552682131, 0.7569374881346633, 0.17358224760036667, 0.18790869546667777, 0.1856064589627059, 0.18229152178268537, 0.186876749850291, 0.19940838156165908, 0.17788468869194474, 0.1782768074086709, 0.1867236049869615, 0.09838747414003102, 0.09190435893201998, 0.09317995387528577, 0.08484324643108865, 0.0933992547821294, 0.09938443631305693, 0.0920990602326951, 0.09074197916685711, 0.12013713080404376]}, "mutation_prompt": null}
{"id": "e0c5b171-4d28-41a4-8c8f-fe432066472f", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.6  # Slightly increased Differential weight\n        self.CR = 0.85 # Adjusted Crossover probability\n        self.w = 0.4  # Decreased Inertia weight for quicker convergence\n        self.c1 = 1.7 # Higher emphasis on cognitive learning\n        self.c2 = 1.3 # Slight decrease in social learning\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization employing Differential Evolution and Particle Swarm with Dynamic Strategy Selection for optimal exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8654156628884216, 0.8505577733650087, 0.8629165407617487, 0.8380421862650951, 0.8456388156840458, 0.8587296791285854, 0.8527912259306096, 0.8559354413193545, 0.8534634313822277, 0.7396929881209096, 0.7341634510349436, 0.7092094663753394, 0.7154728891383115, 0.7193812497122521, 0.7182816213467694, 0.6967750011711794, 0.7069553883493507, 0.7000883977891325, 0.1114105147072143, 0.1481172016688579, 0.1526431654403636, 0.13387851849765897, 0.5442252168246698, 0.14871135036606575, 0.14941128180821783, 0.17945018706496574, 0.1721961393818332, 0.11263438928044145, 0.1503320556503278, 0.11906872559250425, 0.07768433680669018, 0.123196329897314, 0.08839246620613794, 0.10215271061855224, 0.136861489246068, 0.16872141851491052, 0.9553658555778358, 0.962358918073187, 0.94632188274503, 0.9478315924386019, 0.933922097238991, 0.931645767660017, 0.9331854407292095, 0.9361184003567173, 0.9475659196534141, 0.6944265741588745, 0.6856320914341114, 0.6895938036266172, 0.6512602616989766, 0.6877164471456558, 0.6968459829021534, 0.6826596919438079, 0.6890696982652229, 0.6820549676551929, 0.22635534559259274, 0.2395695445189302, 0.871631368557718, 0.27643157799925233, 0.3776060212088548, 0.3654865471871893, 0.22726557497574373, 0.23187077237783693, 0.8641424405872651, 0.11911049122598305, 0.40253532485593235, 0.18724974672384187, 0.18685655018194935, 0.1762400387692964, 0.1677187013488063, 0.20015727878600587, 0.13013515604564707, 0.19273282982800555, 0.13054336021097146, 0.20357835941169955, 0.18189917360312102, 0.20288068384517965, 0.21443735838623112, 0.2665297124948879, 0.10045236270221536, 0.22433507035561873, 0.24968235924269622, 0.04569264568070608, 0.046478388727113074, 0.009403796381180163, 0.11558206670531146, 0.022272836136776775, 9.999999999998899e-05, 9.999999999998899e-05, 0.010927236322666789, 9.999999999998899e-05, 0.09869799781293243, 0.1090027274030263, 0.05063311386168057, 0.04550856712314999, 0.04423383431881778, 0.06882428231234117, 0.08488780433257614, 0.06915948266957872, 0.05616918626292622, 0.09745344578854442, 0.14266038440678452, 0.056123739872517175, 0.07390068554872598, 0.11734251827298636, 0.12287962955005238, 0.0980558089589878, 0.313793869868884, 0.08787551386325854, 0.2917486797997608, 0.07946991282739091, 0.17224156652019373, 0.05828027627746901, 0.1303077885280134, 0.11646763760169576, 0.08124608208620498, 0.09380995154813043, 0.11633120525826257, 0.555773540156163, 0.5361648390238402, 0.5955635893097015, 0.5903343412986675, 0.5705534059184401, 0.5907928198654778, 0.5864770506960435, 0.5807836462029989, 0.5758600831607168, 0.10120420675667552, 0.12293330861734575, 0.08053869524767177, 0.12354207506704484, 0.08073736346821536, 0.10272482608129685, 0.1532115312741822, 0.1360901696747585, 0.11231936726528802, 0.2996945930024152, 0.15036461848789773, 0.29192725793646557, 0.586998814628755, 0.2399129418500099, 0.1898988614820507, 0.27985674526575943, 0.3083813152828182, 0.5046665857709443, 0.37562013603185973, 0.6232592500722111, 0.3557764990869141, 0.5437494596585588, 0.3267962797244046, 0.5034191970719868, 0.2674787778771113, 0.5388690396864722, 0.6257347160992258, 0.23055603168705607, 0.2447596166552669, 0.39697389969629493, 0.2625329956848663, 0.40754650098073675, 0.29008056153170936, 0.1751376443979058, 0.30452850055108005, 0.23510988528554233, 0.19668727799983587, 0.20910730931872668, 0.2175758334347292, 0.20338777031504363, 0.18505592405916904, 0.23282516743307258, 0.23561468261837826, 0.2084214935526616, 0.1992958345658873, 0.22347397714813655, 0.775697066021013, 0.7596980411140908, 0.19538432929097282, 0.2243522715669185, 0.2028591502542586, 0.2386133439715501, 0.19782069255035517, 0.24194431253744464, 0.16480578984400673, 0.18666277229218065, 0.14688420848316563, 0.9098379302694619, 0.1982514777222646, 0.1475028254563553, 0.8731942555370419, 0.16665056287172852, 0.8805288423103896, 0.20927865953032454, 0.21108787377126625, 0.8533564639442084, 0.763389303028059, 0.16733100051057104, 0.8613345632732998, 0.7485132509000212, 0.8102590047437631, 0.7780868464822436, 0.17160405761841613, 0.18127479983452888, 0.18169009769591782, 0.1879575855717499, 0.18826675033422202, 0.18053776450857095, 0.18172286449606012, 0.18021609380021242, 0.18721428705009724, 0.09942796858883207, 0.08282587662772478, 0.09296007929933059, 0.08365309054045356, 0.09063972579928448, 0.10307454917509362, 0.09162982471474646, 0.0995422377362134, 0.08839800323757774]}, "mutation_prompt": null}
{"id": "028ffaa5-4392-4e9c-a28b-a6a07210a02f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5 + 0.3 * np.random.rand()  # Stochastic Differential weight\n        self.CR = 0.9 # Higher Crossover probability for diversity\n        self.w = 0.3 + 0.2 * np.random.rand()  # Adaptive Inertia weight\n        self.c1 = 1.5 # Moderate emphasis on cognitive learning\n        self.c2 = 1.5 # Balanced emphasis on social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # Randomize within a range\n                self.CR = 0.8 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Hybrid Optimization using Adaptive Strategies with Stochastic Initialization and Dynamic Exploration-Exploitation Control.", "configspace": "", "generation": 15, "fitness": 0.30745968598567874, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7766359832726564, 0.7879294109845869, 0.8145426774555067, 0.7935227760973252, 0.7726711952247949, 0.8271349025000171, 0.7824324517199236, 0.7843089230853407, 0.7973262716629108, 0.5895488684740597, 0.6000233356185037, 0.6785153928972186, 0.5669294377792089, 0.5840770410264249, 0.6568604720684701, 0.5721774756087206, 0.5652888732303891, 0.6594958511279114, 0.1564164439043767, 0.15128717049459062, 0.13385491701060637, 0.15933980835105432, 0.14950840542224142, 0.3557938732296596, 0.13512068828741663, 0.1279557765265641, 0.1486262930557285, 0.11312938924550398, 0.1336878649782126, 0.09527683379971608, 0.14087738370537284, 0.1002656873385418, 0.14031514767389364, 0.10272773648223488, 0.1053951279762636, 0.11629340527931165, 0.9588230436869162, 0.9725359962270712, 0.945705153667955, 0.9477106321189641, 0.9545660421269335, 0.9536028138659177, 0.9442669065684567, 0.956496701428564, 0.9552758198674571, 0.49972451055714806, 0.5126701997018479, 0.5791184843844353, 0.5654029256108661, 0.5768119168167307, 0.586324449341825, 0.5033048505988316, 0.45522425528004984, 0.5624958712940351, 0.22272458513264792, 0.372385599759964, 0.7823325745795626, 0.27072192304236, 0.74882214554728, 0.35771670017574875, 0.23314411531777324, 0.23196587084578746, 0.8205549200959269, 0.2044631439704796, 0.2015071554470712, 0.2558376520314116, 0.2089640791495101, 0.12749478497084077, 0.1948516832303755, 0.19959625036344997, 0.2157173454972624, 0.18437451164862595, 0.20143009295521708, 0.214289530458882, 0.2380310612649157, 0.22315947830908955, 0.21151321776881027, 0.21115086811847872, 0.2255531826813505, 0.23981559741080494, 0.13748246014295895, 0.009024367958652357, 0.0508980405416809, 0.0366335799179095, 0.09810002577866672, 0.0018504378513338748, 9.999999999998899e-05, 0.015818603845330514, 0.026507299613953927, 9.999999999998899e-05, 0.03941496278355572, 0.06395252173819266, 0.0923212200355853, 0.04377121328321498, 0.07437557178970655, 0.056692465873470765, 0.12148845976147893, 0.11105421185421605, 0.09565639808492865, 0.10999666384493156, 0.25368894364631367, 0.16030308437581187, 0.07637763386907903, 0.19172975763987088, 0.07194257960382222, 0.09865655362008274, 0.08454149292910274, 0.17725731882276174, 0.10775883071512238, 0.1428370005028764, 0.14602233264619446, 0.08520011778914227, 0.20620543203878539, 0.12292115831829376, 0.1124954447475679, 0.09401472693451651, 0.2000388164349055, 0.5115723828681117, 0.48975469389535997, 0.5441812378327937, 0.5294094184366869, 0.5347900783363728, 0.5766151104778852, 0.533327815034526, 0.5056459558106017, 0.5851963060974499, 0.08905719737320417, 0.10098732572986135, 0.1500955012402193, 0.1259653049319095, 0.11272298599135211, 0.12644103326819223, 0.12819494291877132, 0.10011172162775817, 0.10438728098114824, 0.31554099578264094, 0.17456876986309944, 0.3486707912178012, 0.1402916344790387, 0.2758589481625854, 0.15292189302019255, 0.30467064395252985, 0.1788196172579053, 0.1627137620103979, 0.47708566682654574, 0.4450417105591218, 0.5270400858968102, 0.43316462028296543, 0.48021461512699015, 0.44627037034580386, 0.46127655464775963, 0.48192153990506104, 0.5625634383516236, 0.37623290600125525, 0.3565649741800424, 0.3654865946642146, 0.301673375158513, 0.2756563211289971, 0.23571806646493543, 0.39181114237344805, 0.21579029659673032, 0.24642107813487146, 0.21207763489622244, 0.1966214184175985, 0.2096856912971653, 0.201095527654238, 0.20965107111211356, 0.23149308683742653, 0.20567422691480508, 0.20640802833501104, 0.19454086930131576, 0.22514292772802802, 0.18720795274507485, 0.19732259974639854, 0.2153863672017886, 0.22991744800221336, 0.1957594925499634, 0.2015868182397612, 0.19802474769143363, 0.21551920365216826, 0.17346740557040574, 0.1847645971325237, 0.18247901738780314, 0.812026049225433, 0.16674907142074258, 0.1647974874340281, 0.8158279229954695, 0.1401150558259494, 0.8668057518597425, 0.15398681283916338, 0.12381005681069346, 0.7570348441946415, 0.08218244490801041, 0.16604950273508368, 0.16663511671979647, 0.1658672654018737, 0.1562994004618704, 0.15469149290469308, 0.18476952399502755, 0.18609989440789465, 0.18762443462435907, 0.18937726425911083, 0.17496660821018617, 0.1802517862891857, 0.2058079638253636, 0.21550629966143187, 0.17343860995381233, 0.09607702967237108, 0.0882897421778307, 0.08421706144612418, 0.08754213164016911, 0.08518719601182534, 0.09248143433077005, 0.10125780224474912, 0.08987623229218356, 0.11866837962257759]}, "mutation_prompt": null}
{"id": "86964b4a-6645-4024-8395-4bb6899c6236", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly larger population for diversity\n        self.F = 0.5 + 0.3 * np.random.rand()  # Randomized within a range for adaptive differential weight\n        self.CR = 0.9  # Increased Crossover probability for more mixing\n        self.w = 0.3  # Lowered Inertia weight for improved exploitation\n        self.c1 = 1.5  # Balanced cognitive learning\n        self.c2 = 1.5  # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Higher velocity clamp for broader exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.8 + 0.1 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization combining Differential Evolution and Particle Swarm with Adaptive Strategy for Improved Convergence and Diversity Maintenance.", "configspace": "", "generation": 16, "fitness": 0.33105743521872105, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8387610429086307, 0.8262783472620964, 0.8132433127214258, 0.8148805395811318, 0.8288974491565133, 0.801266148395656, 0.8121542934194171, 0.8172954725448812, 0.8170379715006731, 0.6663850763175574, 0.6727495461164901, 0.6976146113232294, 0.669154737245074, 0.6657074652630329, 0.6806477341492692, 0.6637517402102708, 0.682141298181935, 0.6417183114404603, 0.17203105836311494, 0.12069512430041562, 0.14227030726780054, 0.13809642938960165, 0.1552901990701726, 0.15989950194051705, 0.14436348490158957, 0.1505823610356909, 0.11426844743130227, 0.11562772317270043, 0.11104398414592287, 0.11871379386526404, 0.12153641573428253, 0.12100827186180907, 0.12019113393213754, 0.15842308695872287, 0.13977867676306432, 0.09210697884159513, 0.9625086088315704, 0.9279650749475036, 0.9463593409658553, 0.9454632037325079, 0.9579229940246559, 0.9194650233982795, 0.9193951363231379, 0.930277820404882, 0.9280816785243431, 0.5799031063401003, 0.6306170929517277, 0.5839001925544038, 0.5504456225395413, 0.5268978279619715, 0.6170467866529319, 0.5696877418227001, 0.6170625292098348, 0.5405841831724911, 0.775603357004118, 0.8307412328341744, 0.36805991457871057, 0.16046690375495687, 0.18990879427896767, 0.1900999866178742, 0.24302699108080006, 0.23263020810924628, 0.16296700384363572, 0.17920723895168722, 0.20260477868827698, 0.19088210657382065, 0.18381190535315095, 0.11670750730094681, 0.1988865622080912, 0.20904436777174473, 0.22269176350689235, 0.19095669652125102, 0.14582042811635365, 0.20644709658365934, 0.12997001180953505, 0.12545995616650285, 0.20522767587969315, 0.22415250481504245, 0.2293138249847796, 0.2166329133480791, 0.21983264522218482, 0.08693048765855471, 9.999999999998899e-05, 0.10149763429173986, 0.021689849127096372, 0.01682920265777066, 0.03632236463723382, 0.03367587538984296, 9.999999999998899e-05, 0.10720163153777107, 0.12143418832281949, 0.16296896773543157, 0.1237586233092467, 0.09272601079718823, 0.09624335695246722, 0.023848476186919876, 0.09565501559697365, 0.07488856357327045, 0.12988169652060655, 0.05921513728541361, 0.09482760066170937, 0.10049437611499124, 0.12941852793035924, 0.12851660977558987, 0.07400049492299354, 0.13175041264995657, 0.1928355655580375, 0.15243566372601747, 0.06663886144126496, 0.18714727291038125, 0.19082481434143894, 0.13873448630817753, 0.11104232806136549, 0.28454616236117214, 0.11579915747827729, 0.2109082084782974, 0.09706245665532187, 0.5574463306250623, 0.5624223525037975, 0.5374985609711107, 0.5606075536001698, 0.5527187860305567, 0.5593988871677925, 0.5540309836891972, 0.539110599790466, 0.5844073009250245, 0.11418276597022847, 0.09839000788813645, 0.08997144102319055, 0.1310049002557393, 0.13071022534151766, 0.16500175967171404, 0.14988216457220882, 0.13894583588451004, 0.08365197550114589, 0.20972858802330852, 0.24188096005906068, 0.18435184240673808, 0.446142554974332, 0.24682317854485225, 0.3030153711939132, 0.3346923536842731, 0.4718817573789448, 0.33496217542335627, 0.49868020678320346, 0.42084444503947294, 0.4918708508651609, 0.2926213476868478, 0.4983382818589448, 0.4430391317670782, 0.5343377816749246, 0.5247623620811839, 0.5130248503789214, 0.233595210684719, 0.23952302127006275, 0.25647103183281883, 0.22516332526409955, 0.3251373274387196, 0.2277044154078861, 0.26038025280293775, 0.4221561562335524, 0.32637554319401463, 0.2341054063024366, 0.19530023641004668, 0.20313862719624853, 0.19956775625497425, 0.21883282117092118, 0.20622051242280381, 0.22518470323341944, 0.25381084403832443, 0.2033468845368187, 0.20505177419887477, 0.1960658155228373, 0.23978144867223217, 0.2164526344252058, 0.18988213886665273, 0.19319342804882367, 0.19805186259175922, 0.1906966532172093, 0.21442402051672138, 0.8681873266856162, 0.17415518266200614, 0.893892236757727, 0.8696882063353577, 0.8778695716710125, 0.2049762828630184, 0.8660849426016204, 0.16990174587112794, 0.7800107787850288, 0.20752425093108584, 0.7718588853566926, 0.2086140907373094, 0.12532420575822378, 0.20885838719313665, 0.15214415623301614, 0.8039989075873909, 0.7203619344257628, 0.8027785528918261, 0.19244636780646895, 0.19283598954676995, 0.1727505766232611, 0.2048250953004196, 0.17378426442205785, 0.18238255969564288, 0.2021785295465044, 0.19308607665559663, 0.18665032037495788, 0.09232436619563833, 0.0820764103886269, 0.10637223724377942, 0.10292060090009547, 0.1187756982473337, 0.11488275393723124, 0.08775028645328875, 0.09945582479933834, 0.09438358283681303]}, "mutation_prompt": null}
{"id": "0e25ef15-dd08-4e24-bc63-2e9952ce3918", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.3 * np.random.rand()  # Wider range for F\n        self.CR = 0.8  # Fixed crossover probability for stability\n        self.w = 0.5  # Balanced inertia weight\n        self.c1 = 1.5 # Slightly reduced cognitive learning\n        self.c2 = 1.5 # Equal emphasis on social learning\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound) # Reduced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.3 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Dynamic Strategy Selection and Adaptive Learning Rates for robust exploration-exploitation balance.", "configspace": "", "generation": 17, "fitness": 0.33494448324931014, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8194435342595663, 0.8366122321835069, 0.8124031859201399, 0.8253020340216478, 0.8229558397636314, 0.8186325964155691, 0.8190177462077638, 0.8360837974816664, 0.8435982634478256, 0.6474404581684683, 0.6929870623143766, 0.6726716742825904, 0.6532957617798754, 0.692686863185101, 0.654281320667863, 0.6634366455540814, 0.6674383768182037, 0.6688112491392151, 0.1153262741113198, 0.17321123844260145, 0.13687161961824168, 0.11162061092189868, 0.13598487127519565, 0.17598771878864006, 0.14846982013520316, 0.17483790381089825, 0.14421062068954305, 0.12054394527868839, 0.10943034367928306, 0.13669722340714574, 0.1036430833759967, 0.1335898921341686, 0.11495147954600649, 0.07900177821888188, 0.12207833753783104, 0.11874823543278712, 0.9095979405923429, 0.8913216626093029, 0.9386704767580665, 0.9412187817574921, 0.9441491601334127, 0.9419394565380429, 0.9347808052757667, 0.9355791729908635, 0.9309357314003409, 0.6116921974222447, 0.6593532441484126, 0.6168066698366449, 0.6250682890198187, 0.6077029704454902, 0.6234326340692786, 0.596359606140791, 0.6334388176082615, 0.6008136622867186, 0.22406269557620073, 0.7776078877632904, 0.38127761928682147, 0.8428317480753409, 0.2112275540199574, 0.27144402796320544, 0.8344928419540396, 0.23133540230707705, 0.7989954439875377, 0.2097719332595861, 0.10661176487555424, 0.1287334524115742, 0.2226075777285017, 0.13322107224723512, 0.20837088923599467, 0.1999706520031591, 0.19880793550293607, 0.20795924329925952, 0.20378480760714546, 0.2099960838484185, 0.21662195027576414, 0.25317172617624784, 0.19688535177666, 0.21295066039175048, 0.23148879231737085, 0.1919486540956551, 0.24622673981667498, 9.999999999998899e-05, 0.021922703353710826, 0.06508425504413484, 9.999999999998899e-05, 0.07041385133409128, 0.030570346023178208, 0.007263453404621423, 9.999999999998899e-05, 0.03177457894375779, 0.21085871808077528, 0.08771582927788624, 0.0893029618770772, 0.0610087161928865, 0.07496800386663016, 0.07616227863307645, 0.18806539342725193, 0.15408755101229255, 0.0859596483712407, 0.19285347837105815, 0.1879422300836655, 0.26870230694026254, 0.10386604990747617, 0.16539163371522303, 0.07026231976823927, 0.1576753074543582, 0.16728467618256548, 0.08970889588108133, 0.10385542671821424, 0.24368269569547296, 0.1057691044012361, 0.1582265434018465, 0.23549411511373086, 0.0723546463906376, 0.10272856229825156, 0.09924566948257985, 0.19392894265297222, 0.5727503142412502, 0.5901638712464184, 0.5657167780017778, 0.5369304873136921, 0.5552109392941433, 0.5719280077629847, 0.5751035132394677, 0.5554063905454989, 0.5516842084685953, 0.11999615572839972, 0.11809893637632518, 0.13207934649593278, 0.14229107430999088, 0.13234358920083122, 0.13803026003873087, 0.11318826917303126, 0.10502366675166663, 0.125624051295947, 0.4310294871426017, 0.592312187597884, 0.34019566275158974, 0.39004220329283634, 0.28325504738885443, 0.45012808913466584, 0.36404591079410487, 0.36633491341380586, 0.17062011079349015, 0.2623108056531701, 0.31510515780005677, 0.5224800507592006, 0.5734610073382728, 0.5097032718620678, 0.48207266349668254, 0.4250910916031022, 0.6049685244807266, 0.6087030963158351, 0.3071486160903615, 0.31476224905918204, 0.4129903012130922, 0.3933555103852122, 0.35236433188501337, 0.25624641815466276, 0.40012682074177597, 0.23671698743515057, 0.41950522378241917, 0.2653551527697603, 0.2066812842493556, 0.2372706629349779, 0.22635911462217884, 0.2234362761764237, 0.1966857003563739, 0.202870614955995, 0.24600893536065715, 0.23336716952566772, 0.21493224861909244, 0.24002739193424139, 0.21973563392728301, 0.20568073487282068, 0.22177843861384272, 0.23713968911596917, 0.24243073262229586, 0.2106871792744115, 0.21889852544450294, 0.17148125118918778, 0.1739853269097168, 0.1859062621505203, 0.8749592116845871, 0.8763436266555775, 0.16656420518015236, 0.15889153674545964, 0.17569359523210282, 0.8620770510516258, 0.8281100825777454, 0.5396641784876703, 0.2081064225496464, 0.12716671844781757, 0.16751618891501274, 0.20930912862258433, 0.1543264847567103, 0.8068777241429191, 0.15430032990720577, 0.18075621674991094, 0.18448021598641662, 0.1771196529747796, 0.17914631019397076, 0.22156989143571393, 0.17699825873225383, 0.20083243659701544, 0.19047443498282224, 0.19062124278000958, 0.09021910173149061, 0.09116477627416919, 0.08321843387842365, 0.0981869442545451, 0.08475734326050255, 0.09042793682694683, 0.09189987094288676, 0.18723446240489472, 0.07963012325848773]}, "mutation_prompt": null}
{"id": "963425b7-be69-4882-b422-602b96e71f40", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased population size\n        self.F = 0.5  # Adaptive Differential weight\n        self.CR = 0.9 # Higher Crossover probability\n        self.w = 0.3  # Further decreased Inertia weight for faster convergence\n        self.c1 = 1.8 # Further emphasis on cognitive learning\n        self.c2 = 1.2 # Slight further decrease in social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Further increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection with adaptive parameters\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Randomize within a wider range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Randomize with a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Hybrid Optimization using Adaptive Differential Evolution and Particle Swarm with Dynamic Strategy and Adaptive Parameters for optimal convergence speed and solution quality.", "configspace": "", "generation": 18, "fitness": 0.31545432032462567, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8525730944684244, 0.8588810904992967, 0.8564856775137488, 0.8580602950392456, 0.8572589105059282, 0.8496422887350217, 0.8540321601257662, 0.8630085656952817, 0.8466374417785595, 0.7090432142908022, 0.20940820922319503, 0.7109483414088944, 0.660655994127561, 0.6983706391580786, 0.7381879908513754, 0.727995285532145, 0.7227661945640934, 0.6994143394538614, 0.14008539103107376, 0.13668901555766155, 0.13182555225951287, 0.10246884102204545, 0.1551950101627868, 0.15197246258448616, 0.14687324868521068, 0.15204188988522438, 0.1550137240269701, 0.11462046563265393, 0.1122591462959468, 0.11101889935554121, 0.13382881699262184, 0.1060148378801683, 0.11129404682790878, 0.15215652888262832, 0.09517255526086443, 0.14977691467191434, 0.899764479172938, 0.9164853115673541, 0.8895289354626414, 0.9452969471541862, 0.9068275373627029, 0.9383374684856597, 0.930420594273317, 0.956047621705313, 0.9473594847686402, 0.6036169596010171, 0.6546356653523906, 0.671891821222357, 0.6788430040076313, 0.6997017977357591, 0.6340144011443142, 0.6246856930572078, 0.648064207235096, 0.6117352404608202, 0.22644553353953356, 0.21229524284685253, 0.2206708505588708, 0.2725270485141321, 0.8268831890266062, 0.27110496372910786, 0.2389795556888984, 0.21921165529894382, 0.23265586160845453, 0.19633700536756937, 0.14125751815573673, 0.19282435335785242, 0.15858907748570783, 0.1303864079328263, 0.1272778073126607, 0.20125058779980998, 0.13072735412766323, 0.17456162253127927, 0.21062693748626982, 0.13424770016318632, 0.15405294380928913, 0.175157874059913, 0.12480003926147742, 0.1872407437076392, 0.13120174582715227, 0.4690000637269497, 0.19195860698343326, 0.07081358571070562, 0.03418682792866512, 0.017772896031753027, 0.0069756306991747286, 0.004323627195132795, 0.04929151310735669, 0.04392523790004821, 9.999999999998899e-05, 0.074450947231538, 0.09063857048938939, 0.10765254083173825, 0.16168776260665485, 0.047423346773470265, 0.04231198628689492, 0.04089339449184559, 0.11794241296802321, 0.0635339497109706, 0.12449328212017607, 0.2590080250664212, 0.19838175235059852, 0.15455636343642987, 0.07480661363030672, 0.10906331285638449, 0.2650287003588011, 0.07375963801675645, 0.41463093990619293, 0.14364805430750327, 0.26626207770076027, 0.14379659371495324, 0.18253179515685192, 0.17539689490486288, 0.08617173500606401, 0.10693339953264291, 0.17258893805591669, 0.08955347782341905, 0.11063959070016716, 0.5338179199674971, 0.5046182046786479, 0.5278513508971507, 0.5461084829471659, 0.5247793278823305, 0.5844247914484817, 0.5512899123845818, 0.5447191011939541, 0.5416084057707531, 0.17275264354989672, 0.10277198854502512, 0.105824862957698, 0.08366523306472695, 0.09125447513740492, 0.13663518231925942, 0.12479728764312481, 0.11561852883670143, 0.11016735477292727, 0.15576104103184096, 0.2213890529899808, 0.2909273139869015, 0.2765418096675758, 0.18768764289441564, 0.3262798308278311, 0.36402177803540303, 0.19386430030857327, 0.16122593981661337, 0.33069072947522404, 0.3160534850597918, 0.49304531402768503, 0.5314177438480583, 0.39621989290773807, 0.3584742632669876, 0.5248745030973605, 0.5112266140976065, 0.3030620151706137, 0.3233047791433332, 0.22626800150341775, 0.3383356427333699, 0.3486263987595142, 0.33530532018930514, 0.31606700867554793, 0.2089480005942137, 0.35715532549462037, 0.21967033519055335, 0.21344124351618854, 0.20202590664135145, 0.24413086870137135, 0.21188380572018017, 0.23759394000484202, 0.20994750763244607, 0.19650488437515456, 0.2111763010948412, 0.20913432590151126, 0.2030181448652736, 0.19588170102171865, 0.7647621918552495, 0.20576156558668113, 0.20848892108451422, 0.2354458366602522, 0.22595011722876301, 0.24843767224902147, 0.2021729840567723, 0.8884042295043363, 0.18567717980186393, 0.18725671907437835, 0.15384560191265773, 0.20820182227240935, 0.14750081220765932, 0.15992020226714432, 0.885316884747062, 0.16605152661258415, 0.8172348125290105, 0.2101525289430879, 0.6659589581117507, 0.27167808434175, 0.16691458381555235, 0.48751810030827436, 0.1675562335443478, 0.6058038428893306, 0.10482039992669889, 0.18138202892009703, 0.18927972596063591, 0.18498551851308653, 0.18101619469919772, 0.19366825320240333, 0.1765531278179875, 0.20623971274458786, 0.19281538220441619, 0.1836660855511958, 0.09556683677383093, 0.12025621238990858, 0.12002866309859306, 0.08012606540384126, 0.09363811499857, 0.07511788615394799, 0.1087873070267742, 0.08597058544303493, 0.0779339571473825]}, "mutation_prompt": null}
{"id": "60eb555b-e808-4a53-bb4c-4c8cfbc3b9c9", "solution": "import numpy as np\n\nclass ImprovedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.3 * np.random.rand()  # More adaptive Differential weight\n        self.CR = 0.75 + 0.15 * np.random.rand() # Slightly narrower range for Crossover probability\n        self.w = 0.5  # Adjusted Inertia weight for balance\n        self.c1 = 1.5 # Lowered cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Decreased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # More adaptive range for F\n                self.CR = 0.75 + 0.15 * np.random.rand()  # Slightly narrower range for CR\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "ImprovedAdaptiveHyDEPSO", "description": "Improved Hybrid Optimization using Adaptive Differential Evolution and Particle Swarm with Enhanced Strategy Adaptation for Diverse Optimization Tasks.", "configspace": "", "generation": 19, "fitness": 0.3149740725918298, "feedback": "The algorithm ImprovedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8186178242772633, 0.8059981001632863, 0.816171360348496, 0.8042371045529644, 0.7964192250430557, 0.799523794242639, 0.8146556526897144, 0.7972443093661186, 0.8118659779510793, 0.6066416822756029, 0.6181060351742201, 0.6325860889693056, 0.6558784493753826, 0.6466880752845665, 0.5807411659137771, 0.6177637785350947, 0.6186782881713783, 0.6133651887706735, 0.12305219856436611, 0.5808057443028255, 0.169607434328775, 0.1116656575796724, 0.14044537031569615, 0.13595892411364507, 0.11565804338150354, 0.12791056700921855, 0.14597534997079764, 0.10591308802559996, 0.1335970299465158, 0.12277675638715624, 0.12605506369322006, 0.12569951359191656, 0.12232269806765039, 0.10161177802028976, 0.12534199041762095, 0.10825773807859895, 0.9497966882037377, 0.9606213364746801, 0.948394659887498, 0.9362972491407999, 0.9504693180086095, 0.9614612522792072, 0.9327906410863956, 0.9602464372382269, 0.9481300900444205, 0.5655862416853188, 0.5481076881609974, 0.5829505162667556, 0.5801694916797193, 0.5567129487301162, 0.5798803264725669, 0.5634024232102517, 0.49206628162240573, 0.5190864998105209, 0.22170819693476507, 0.7679878961038262, 0.782907100045723, 0.21123802401161296, 0.2758531491089309, 0.274348672312241, 0.22959128399113993, 0.7590510702415277, 0.24163465456713318, 0.20011693402728759, 0.21173364824807672, 0.3196024394938396, 0.12735209569064831, 0.20314169640458735, 0.19622517770460846, 0.1983773915782352, 0.22253328996131605, 0.2026821034516162, 0.20773473056525493, 0.2140939062910966, 0.21255139095656883, 0.22603454096542308, 0.24146227699685863, 0.22401590262885684, 0.25130493199496395, 0.12600451735658658, 0.2221387516587643, 0.09794203036448668, 0.010316625565007453, 0.027066275874994217, 9.999999999998899e-05, 0.034231645398443256, 0.10228536346002437, 0.0130514756509168, 0.059841214502433626, 0.0011724781126492, 0.14022585675201504, 0.059505132270841976, 0.04913016418911442, 0.1246962569839698, 0.01947236354970605, 0.0638025838031413, 0.09967803172867784, 0.09888947439526585, 0.16885863100515874, 0.14201612171053934, 0.050914672894619595, 0.16298731623166218, 0.17187103612808952, 0.25889608602671954, 0.13899156939074697, 0.08850102998233267, 0.1058181161099998, 0.14622291171663582, 0.1625696801339367, 0.14354126471175654, 0.12452768007548531, 0.10308555323290514, 0.10723614896260691, 0.1544483746507762, 0.1597829613182572, 0.10861085940292814, 0.16750603733120983, 0.5341800069488856, 0.512799411661033, 0.5486959904386767, 0.5319341184445421, 0.5496295724214793, 0.5743635334314645, 0.5737789725601279, 0.6000777166627145, 0.5671750833519126, 0.10083080509287157, 0.10548182139432416, 0.1324956053183567, 0.16845917080735673, 0.10233316453937968, 0.1444612771143029, 0.1491672136749801, 0.08004164415471571, 0.13589925953078563, 0.3317753418852417, 0.4981295263625418, 0.5758936003731827, 0.31864825878188374, 0.22528696102902446, 0.3951897379264173, 0.1907981103181553, 0.1847009022013626, 0.2533444294647743, 0.5178473231328751, 0.31117955592367197, 0.359518972494721, 0.52163059505046, 0.29331835314806776, 0.5089039140722494, 0.5039072498743519, 0.4730383271959535, 0.4947434868676772, 0.35682031568190065, 0.2973078963278677, 0.3609872658189768, 0.27896227559135245, 0.3076916642822898, 0.2867943334453549, 0.23742201783278327, 0.26192321862407075, 0.23262651153975666, 0.21944095713858602, 0.1958765115177148, 0.2187151575305616, 0.22913146942542895, 0.2220922721876012, 0.21735928363283674, 0.21061226690375112, 0.2253792384507557, 0.23055623375180945, 0.2411002708034271, 0.20450376382306668, 0.2133677252123133, 0.18190828314882546, 0.21531608325331053, 0.18377922104375832, 0.2172176612868444, 0.21060465418483765, 0.6713012092287023, 0.1856370012903067, 0.1937390472167585, 0.15523711487533942, 0.1710519285319282, 0.1980253303988515, 0.1976909380081453, 0.1306746326440027, 0.1510590875793425, 0.8490434261654569, 0.16654023451304933, 0.207593364186632, 0.823136812200484, 0.16708565385753738, 0.2073628636525574, 0.20810733786415736, 0.21045461102104357, 0.167353719576111, 0.8028105731893589, 0.17992309295254183, 0.17959135754259947, 0.17924989478262965, 0.1738071644086141, 0.18217582682646905, 0.21147155075943114, 0.19557118736686196, 0.18970213631494914, 0.1748865293364834, 0.08164832269966138, 0.09101561492410182, 0.10477140643670535, 0.0921804083274399, 0.09238596352115347, 0.08778691558768137, 0.09402221750063477, 0.09289567338170468, 0.08702803126404302]}, "mutation_prompt": null}
{"id": "5e7e0239-0acc-49e6-a1df-8bf0e70a30e8", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSOv2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.7  # Further increased Differential weight\n        self.CR = 0.9 # Higher Crossover probability\n        self.w = 0.5  # Increased Inertia weight for enhanced exploration\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Further increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Keep dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # Expanded randomization range\n                self.CR = 0.8 + 0.2 * np.random.rand()  # Randomize within an adjusted range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSOv2", "description": "Adaptive Selection of Differential Evolution and Particle Swarm Strategies with Enhanced Randomization for Robust Optimization.", "configspace": "", "generation": 20, "fitness": 0.31517427599027914, "feedback": "The algorithm AdaptiveHyDEPSOv2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8040757538381886, 0.8032497299954464, 0.8025300747661033, 0.8046325297495238, 0.8101458761235937, 0.7952101049417102, 0.8089078497229684, 0.8037717154871648, 0.7862325123361215, 0.620261152501957, 0.6224607079780077, 0.5819052151547497, 0.6159187007585613, 0.6423416820992824, 0.5979134505192778, 0.6235578781602436, 0.6020463888780926, 0.6241275949150435, 0.13392489523411333, 0.1483235158433034, 0.11107544219463017, 0.15528274661792585, 0.10537992034275234, 0.07182436793544966, 0.15699963368713765, 0.38596238643976877, 0.13397646660308493, 0.12038188219263046, 0.12671177907837905, 0.11483187641881665, 0.10793715120198144, 0.12870468544055802, 0.1260275846442277, 0.10847185079123023, 0.13066800451123217, 0.11733763373044725, 0.9476208103822737, 0.9621780906902171, 0.9309048442894237, 0.9618473796042255, 0.9306897251380912, 0.9696607267061745, 0.9472487177788586, 0.9658702654693834, 0.9676162962550408, 0.5845286288008286, 0.5491021501290337, 0.5060236234735058, 0.5482003891113923, 0.5788193120950662, 0.5452354515004256, 0.5366283049370233, 0.4847111050950256, 0.4959642824098247, 0.22042544349141258, 0.829117364625144, 0.21688497670272555, 0.1907255377236733, 0.2110132315348786, 0.7036757084293028, 0.8122800754976324, 0.7635089092224803, 0.23094655622270144, 0.21536524700534343, 0.1420586216015125, 0.11942120529492872, 0.12384445873456118, 0.2219659854746464, 0.10098692138287768, 0.19876457197666797, 0.20019118498523036, 0.20345998445198243, 0.22341446951515231, 0.20879640223426543, 0.20863181247382268, 0.23646572463065385, 0.24206640673291624, 0.24140737713474547, 0.23832928606036818, 0.23612444773954488, 0.23124299803637738, 0.054203217136014614, 0.005402937276151376, 0.048649045876894115, 0.001486795677705377, 0.06409895049803438, 9.999999999998899e-05, 0.0471663388903939, 9.999999999998899e-05, 0.0002832072650386097, 0.06339405365529749, 0.11596224017174572, 0.11327250539085487, 0.05485571918752907, 0.07965967028726084, 0.08016810879197889, 0.1023434096830198, 0.07700859516018332, 0.07806303835974426, 0.04233707578852064, 0.08585368989143138, 0.07924290102424425, 0.11424809452379248, 0.09257235523890706, 0.11158787438662965, 0.11199571933463681, 0.09687313979033374, 0.1957064772012086, 0.21217492104668323, 0.13140790930948676, 0.020703237419786302, 0.1381890525958852, 0.16836351289880347, 0.18510798972094233, 0.0815841608530804, 0.26675565064103635, 0.07983170452750998, 0.5792982821404138, 0.5338978027482746, 0.5236108931225323, 0.5475333301845313, 0.5526110612020694, 0.5728180820336222, 0.5562009605592335, 0.5486292923711973, 0.5825049107342359, 0.12462522896221928, 0.17054538263217311, 0.0844497930157011, 0.13266209698580655, 0.10770019617763849, 0.11694619479030355, 0.12947496132298042, 0.1312387977668401, 0.11454647466802637, 0.5064940243051559, 0.2073133594279517, 0.1429186793695204, 0.14822331712102255, 0.15904664396544033, 0.3022189842937332, 0.15595229025430568, 0.36903688959444403, 0.2365415762938996, 0.48117208096269337, 0.3657323738122016, 0.40899642925944113, 0.5050580863558265, 0.4450995252943176, 0.4443654381793666, 0.4697814481523229, 0.45127827970292933, 0.5018187481871942, 0.24787408020051616, 0.28302880388292395, 0.2759543955066318, 0.2862560766831176, 0.3188734276123536, 0.21031348756512658, 0.2351507663472786, 0.36065529024039444, 0.20560343242630597, 0.23487455734504825, 0.21427021214588482, 0.20646121334070033, 0.21816827468784739, 0.2076126615916566, 0.21488958676507264, 0.20092319162295302, 0.21269750905420992, 0.21077401937646123, 0.23794964379507832, 0.5709958953718363, 0.186168396209616, 0.20739311905620872, 0.21684992378948276, 0.21625617571675937, 0.20629260002698147, 0.6043958996011201, 0.20446577785267128, 0.18346428953577743, 0.1759570329281399, 0.19299979585262217, 0.8608256214881351, 0.8380468433702862, 0.169675863333843, 0.18792253550955107, 0.1698322831055391, 0.843229596154815, 0.5500210277172646, 0.21067624457276246, 0.20895856011676628, 0.6010110962571416, 0.16557797966090215, 0.5866195098723785, 0.21113013196264951, 0.21027533926290176, 0.21023010549819698, 0.1969800112841794, 0.18868485200459562, 0.1862365862451818, 0.19082789507392117, 0.17147461669102582, 0.17844037556689107, 0.1800506505166426, 0.17615515885289534, 0.18856251491980602, 0.0941277080856533, 0.12541322780093211, 0.0771898082578345, 0.08272162469772792, 0.0970436979838607, 0.07948843714851261, 0.09296644758773731, 0.09049461149913729, 0.08101214660445133]}, "mutation_prompt": null}
{"id": "76548dc6-eb72-4c77-9869-d31829b93d80", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Adjusted population size for better resource allocation\n        self.F = 0.5 + 0.1 * np.random.rand()  # Dynamic Differential weight based on iterations\n        self.CR = 0.8  # Increased Crossover probability for better exploration\n        self.w = 0.6  # Adjusted Inertia weight for stable convergence\n        self.c1 = 1.5  # Balanced cognitive learning\n        self.c2 = 1.5  # Equal emphasis on social learning\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Randomize F within a narrow range for stability\n                self.CR = 0.75 + 0.1 * np.random.rand()  # Randomize CR within a range\n                \n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization using Differential Evolution and Particle Swarm with Dynamic Strategy and Adaptive Learning Rates for robust balance between exploration and exploitation.", "configspace": "", "generation": 21, "fitness": 0.3314023293389608, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8196711342516857, 0.8150518797586612, 0.8265895520072469, 0.8265271474071669, 0.8267389900258996, 0.8178753746232513, 0.8346731488470298, 0.8229446763673871, 0.8308057699210571, 0.6193097211937648, 0.6488088317567526, 0.6768833554930533, 0.6380121267726084, 0.6638678351299364, 0.6553420444741151, 0.629891516093077, 0.6112728964696743, 0.6452456616692652, 0.14984992256682494, 0.15145247333620337, 0.1345391939868218, 0.11397016322855613, 0.15460602485138808, 0.17618271167359312, 0.1356524874006496, 0.11068336646072108, 0.1707403567621104, 0.08193289441635987, 0.11064358679075392, 0.1368994914216608, 0.14277363860961867, 0.1421341458510258, 0.12076979838895874, 0.11143136947252474, 0.10901223526332937, 0.11701835015236361, 0.9569633912753679, 0.9382404869366967, 0.9542559501124838, 0.9346757731740164, 0.9526777824119814, 0.9553878412631219, 0.9439868192757702, 0.9528804840467704, 0.9384524412099532, 0.6283573157991457, 0.5935275581363051, 0.6072672957366219, 0.6248509319466391, 0.6099754688474187, 0.6176102096789251, 0.5808381198978151, 0.560922696187167, 0.6229141650380579, 0.7627040965305331, 0.3767567412343332, 0.2257482062000714, 0.8772196016738013, 0.3787211236352289, 0.27616512854417163, 0.8406538072817167, 0.24288281356614094, 0.1493262891447784, 0.2945899195781435, 0.13133994736204946, 0.21330634573564722, 0.2008373459805881, 0.20500942678716716, 0.2120885829206699, 0.1275657194238562, 0.3148494140793291, 0.21451724038740538, 0.22405121779204917, 0.22209668399254856, 0.2170702756053533, 0.219048848397976, 0.22599008725119485, 0.22904065497268322, 0.13271280277729625, 0.21754038597328496, 0.2480488137737581, 0.04478577757344737, 0.015900139576166317, 0.10881135870961611, 0.08064856285350108, 0.056899771816567024, 0.007443663268131839, 0.005337209853748748, 0.009843405998564037, 0.0028846757339173745, 0.11264344023871198, 0.14584129186540762, 0.08917559417508802, 0.09039320795209582, 0.08965118938776506, 0.012819804695943793, 0.1175481372699354, 0.22673475438714374, 0.12610129385325963, 0.2631527554114037, 0.17789122654208078, 0.09759451442347367, 0.11515643389443808, 0.16111962464081697, 0.2110432013372341, 0.06674384982591941, 0.0663851161106952, 0.17021685280177157, 0.1481097678388662, 0.16144865533651087, 0.24493254673751852, 0.05236090013310646, 0.02731417145541104, 0.2360165886945872, 0.11890728993580812, 0.13016790806432255, 0.1791351560984733, 0.5483048050201503, 0.5390958802625978, 0.5366622435685067, 0.5976120101494207, 0.5350746398002311, 0.5348045887695009, 0.565669184685954, 0.5325060285580681, 0.5445623205578148, 0.13299597187891177, 0.1339658330450595, 0.1084390628686629, 0.1403043926014378, 0.1756979826078825, 0.15224041525337706, 0.1061446882487902, 0.13670203591880348, 0.15033430725101427, 0.31630500832044184, 0.2580126107168127, 0.5946437140281855, 0.314946981901603, 0.30213741723734033, 0.5057138390477012, 0.3167212372006517, 0.32369165995747573, 0.21345811400890757, 0.49386022729321244, 0.45726006080452886, 0.38407976313490166, 0.5415353802643788, 0.5532634215966722, 0.43679417653472663, 0.5196377954979793, 0.23376592937348284, 0.24073033147019673, 0.41686923799630904, 0.27935747378547227, 0.28091906887395357, 0.24115367716008484, 0.19811875812967417, 0.19583908497838565, 0.3323668233882934, 0.24086992194774215, 0.2382462594445014, 0.21170911937697012, 0.21030327402865245, 0.21076476231320018, 0.24918338737429135, 0.21986462614058933, 0.25650912352758215, 0.20408312672883644, 0.18773142885848604, 0.23612432458495491, 0.20587172814566534, 0.20447191331745085, 0.2124098095572995, 0.21771649701332463, 0.24434066854756398, 0.24422172082594718, 0.1991131029879849, 0.18672531319544505, 0.2458963849329694, 0.18570521757283875, 0.8665933620185282, 0.18774876222096581, 0.19874789300877482, 0.1682939259844457, 0.09520204821984712, 0.8799743726247751, 0.885448596064725, 0.17738278441071653, 0.7633096989515455, 0.7316619759307418, 0.8368681155801994, 0.5160851268843785, 0.20926524031308136, 0.1273776970621886, 0.20980566431969383, 0.861494546334936, 0.15472755819422312, 0.17828616641121298, 0.18911811378577204, 0.18198692721397747, 0.20561373940309635, 0.17838280008765928, 0.1768329044641168, 0.1869391054939673, 0.16697782099194414, 0.17341858597865756, 0.09115878154478907, 0.094865257397039, 0.08796243476535548, 0.0859970845417134, 0.09364735460703355, 0.08515513988990586, 0.0957319340456324, 0.10410456408276092, 0.09794719725469736]}, "mutation_prompt": null}
{"id": "bcf9075a-471c-4d8b-97a4-8cbcf0d8e3d7", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly larger population\n        self.F = 0.5 + 0.1 * np.random.rand()  # Dynamic Differential weight\n        self.CR = 0.8  # Higher Crossover probability for exploration\n        self.w = 0.3 + 0.1 * np.random.rand()  # Dynamic inertia weight\n        self.c1 = 1.5  # Balance cognitive learning\n        self.c2 = 1.5  # Balance social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.dynamic_learning_rate = True  # Enable dynamic learning strategy\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.dynamic_learning_rate:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Wider range\n                self.w = 0.2 + 0.3 * np.random.rand()  # Adjust inertia randomly\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization combining Differential Evolution and Particle Swarm with dynamic learning rate adjustment for improved convergence.", "configspace": "", "generation": 22, "fitness": 0.3285013475359712, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8497757624367471, 0.8540518692716791, 0.828332500342662, 0.844031855105876, 0.83806372835675, 0.8223854864134084, 0.8396534358169786, 0.8503958140278453, 0.8272827721031953, 0.6021541787456982, 0.6909644861313905, 0.6795617604397151, 0.6894110624688261, 0.6638919460147901, 0.6855084931243962, 0.6737481611036688, 0.6816033912672346, 0.6601210775530301, 0.1330421464408943, 0.11299977588317944, 0.1370374030925694, 0.6460743885631983, 0.176029823546893, 0.14232397416353537, 0.14745139092479453, 0.556733114051096, 0.14984593096177745, 0.11521413492114208, 0.10942637554765866, 0.17016942360603915, 0.0901149826111417, 0.09524854168699926, 0.1378601102916729, 0.1046305350187009, 0.15321484594474588, 0.10525433151100838, 0.9470634256608452, 0.929066606586906, 0.9284906655241776, 0.9370229576684347, 0.9325679038182811, 0.950647328033654, 0.937734025387939, 0.9403585129398746, 0.9460353686877832, 0.6659044556594795, 0.6496209638951124, 0.5206561203539117, 0.6341994446728074, 0.6493325241240593, 0.6361657894366408, 0.6295778798499814, 0.6417229335427855, 0.6303497057861374, 0.2250202609982328, 0.2272773766102718, 0.22433979118991976, 0.27267933598660277, 0.8676862647843036, 0.21319722054748347, 0.8277077167986142, 0.2331149356089769, 0.15727205544395007, 0.1840567786485241, 0.35040051028222274, 0.19101726341016068, 0.1892908612385239, 0.18905330752939875, 0.1810911296007306, 0.19341055945208474, 0.1770756696382696, 0.18432523305859982, 0.19445467990224463, 0.09604035184102289, 0.18805807525919216, 0.18953115223165728, 0.1711110822560088, 0.17832338828111716, 0.18347709353235164, 0.12751480314776487, 0.25228336543888685, 0.00839748952296726, 0.00020886769947514594, 9.999999999998899e-05, 0.010387205831555946, 0.046193625593291876, 9.999999999998899e-05, 0.018109627227296365, 0.019835967117318942, 9.999999999998899e-05, 0.05603386134797472, 0.05249921112780298, 0.0983576561035927, 0.10059317870859086, 0.1360085380707784, 0.08306757757502359, 0.10039859248524752, 0.12000005578148498, 0.06713562519974181, 0.13969151821934356, 0.36263239787959023, 0.1256653414969694, 0.08081171385684116, 0.0899794294714853, 0.19516165151491482, 0.06859177715619458, 0.09435429514235838, 0.06854963487412546, 0.1711134628895672, 0.11099099793374967, 0.1599419051266494, 0.10215677860754024, 0.06919543787442439, 0.05533519960381328, 0.10788562577446903, 0.08203273454633331, 0.1872654484529217, 0.5578212053862722, 0.5237644079898256, 0.5120513015467849, 0.5649361930120274, 0.5310737795740196, 0.6107069093149201, 0.5806888155547245, 0.5483728172099345, 0.5803493058280514, 0.13759735297035458, 0.0674949170015634, 0.14988831170188788, 0.06836346450843667, 0.10425874601626584, 0.11337654632469607, 0.11974498075099094, 0.12658975996911537, 0.1314385482649716, 0.36078450962754127, 0.31641661716434233, 0.45490243999435886, 0.37799217906621985, 0.3212907707402082, 0.1990540681340941, 0.2633148574434764, 0.23227924523453924, 0.20617637964413638, 0.45558389552425127, 0.5260970505466909, 0.3218360699054371, 0.425303269880256, 0.5434355763944794, 0.674994380882613, 0.2266682483267648, 0.4993570865191582, 0.6061426553726392, 0.2710017321606134, 0.2042782788825478, 0.30458875700534516, 0.23628353717558714, 0.28933179513213914, 0.28597057151175564, 0.22050526572574547, 0.2715179646696715, 0.15411780213543735, 0.21571564031955404, 0.2166282250498558, 0.22676628802011678, 0.20929347325800607, 0.23505626949171576, 0.2344942872981841, 0.18159235617288783, 0.21945245481749975, 0.2119813777152706, 0.21020146939333395, 0.226465985471489, 0.1883557289586728, 0.17695291799029933, 0.18968121950396932, 0.218943005416956, 0.7155903873834307, 0.6273362557069955, 0.1919759367631224, 0.1967890462780305, 0.15610336781461043, 0.8865524651746852, 0.16915307694881632, 0.8810017224086716, 0.8549698644889194, 0.1692551019873274, 0.1772911524379206, 0.8480050469722276, 0.8318162517796359, 0.7801436346331072, 0.7465864225766263, 0.20379108752997233, 0.20883653760410315, 0.14990159167923411, 0.10475716083009778, 0.15650481869760768, 0.15548587493370158, 0.20168748036344863, 0.1765192708491491, 0.19986545475372253, 0.17691512126367848, 0.18334871747885728, 0.17468033741622513, 0.1730202407537772, 0.19956290344912087, 0.18939324143073866, 0.09088475371259941, 0.08220251368567111, 0.0990973868505105, 0.08995047593827932, 0.08899854421088604, 0.08674765737160328, 0.08531841604351065, 0.09648926986442241, 0.08262109745173729]}, "mutation_prompt": null}
{"id": "922d3aec-8097-42c8-9b02-8766d77373c5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = 0.5 + 0.1 * np.random.rand()  # Dynamic Differential weight\n        self.CR = 0.9  # Increased Crossover probability for diversity\n        self.w = 0.5  # Moderate Inertia weight for balanced exploration\n        self.c1 = 1.5  # Balanced cognitive learning factor\n        self.c2 = 1.7  # Increased emphasis on social learning for convergence\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)  # Reduced velocity clamp for precision\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_switch_prob = 0.3  # Probability to switch strategy\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if np.random.rand() < self.strategy_switch_prob:\n                self.F = 0.5 + 0.2 * np.random.rand()\n                self.CR = 0.8 + 0.1 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveDEPSO", "description": "Enhanced Hybrid Optimization integrating Adaptive Differential Evolution and Particle Swarm dynamics with probabilistic strategy switching.", "configspace": "", "generation": 23, "fitness": 0.3206911081729835, "feedback": "The algorithm EnhancedAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8411816033660545, 0.8583938079668303, 0.819483458101628, 0.8308330195776491, 0.8471114728849004, 0.829271942494902, 0.8296196237276983, 0.8380750900986188, 0.8348890878072038, 0.6702495612964925, 0.6329046343873906, 0.6599272638333691, 0.6562147750239918, 0.7039843784453834, 0.6719766210062844, 0.6822040409561931, 0.665459493016281, 0.6775226474597061, 0.17324349501502967, 0.1720581683972987, 0.1531123634733461, 0.1200307191863681, 0.11213942747719952, 0.10807359528390703, 0.13941499362869558, 0.13466842837488935, 0.17630490154433942, 0.17213199451267558, 0.09245287554797033, 0.12184845461050287, 0.12827531906708278, 0.11048919038363403, 0.11833976260410328, 0.15165154143606574, 0.10422450913853265, 0.14564907728046161, 0.9479596662526111, 0.9396343240775139, 0.9524809842479585, 0.9275524893692538, 0.9480499465058336, 0.9331855150868166, 0.9365204581150273, 0.945204823516099, 0.9214187746864455, 0.6176154464274708, 0.6628687567004848, 0.599585396075768, 0.5970613535209428, 0.5968401314371661, 0.5799485623931028, 0.6097344647320024, 0.6504770275339111, 0.6255888110913823, 0.22536093378976774, 0.22348198634031846, 0.22554402560080955, 0.1624994134083828, 0.2768290788099783, 0.7972341348008949, 0.2319690200834148, 0.8379053833590899, 0.7492564770343311, 0.2320550356013722, 0.20961881785460068, 0.19792933583946104, 0.2321743949013898, 0.22232043102352694, 0.21409108895191542, 0.2123010388209019, 0.2325536511227122, 0.12998484633283647, 0.23725132760714074, 0.22968745350741526, 0.22067082083529477, 0.12816528748560396, 0.232306943003175, 0.2557506826374544, 0.2519195471672655, 0.2703171959695677, 0.245057414345917, 0.0399451705639724, 0.07168199753639692, 0.019223661211156595, 9.999999999998899e-05, 0.09171384836583052, 0.01970782713913577, 0.009917857274851505, 0.09882500090974677, 0.06076621773208701, 0.11250311951922431, 0.09330054301953383, 0.07013658600656036, 0.07118832179686974, 0.04940049885290898, 0.06408076552503494, 0.08711651591753888, 0.07617107138882107, 0.0693631256673678, 0.20277352939183524, 0.06815406013434877, 0.04554554960341661, 0.12503609184423659, 0.2412221177333459, 0.15085088024127202, 0.17097922867867688, 0.20139873037181166, 0.2196801286094946, 0.17956405802190634, 0.20577936743158476, 0.13359807315353633, 0.125209652504793, 0.0342501846605896, 0.13335191169296245, 0.16540403667894865, 0.2831606370151143, 0.3824122947815798, 0.5641571177094067, 0.5170832533661431, 0.5292759212668977, 0.5813130273950564, 0.5758925062817817, 0.5977158074191914, 0.540040530728479, 0.5775998493520591, 0.5389785987466389, 0.1442298989080586, 0.13929388926715003, 0.11492962286065689, 0.1362543362641211, 0.10373273258682891, 0.1381320296340529, 0.17502513990107527, 0.14176888903004414, 0.1360852131928747, 0.37059473810710475, 0.44199231000531347, 0.5209949011621957, 0.3213850637118977, 0.5619828704201466, 0.21209831014491876, 0.17554779191697067, 0.24808912069431233, 0.21656638906448944, 0.3668294523285657, 0.2910084741440794, 0.4095244197130843, 0.4696883365407597, 0.5469031333437122, 0.35933064200624343, 0.537893984219558, 0.5311390302793657, 0.5838565520663477, 0.23706282830175907, 0.3100625597769726, 0.24438624270060694, 0.19397683587489878, 0.29485799063435725, 0.2519133590161382, 0.32661063919748545, 0.2234255880703797, 0.408188886537602, 0.21597013628635187, 0.20702758987130532, 0.2416551798511054, 0.21118718879517118, 0.20822214535501893, 0.2372093358969516, 0.22322780054183688, 0.21372091612116684, 0.2040863053791382, 0.19421481672216923, 0.20768531782829913, 0.20641663204370497, 0.24748019549157274, 0.20146678194837198, 0.24734656735819682, 0.6028423604818626, 0.22212842245386322, 0.6687524248230348, 0.16589557486205464, 0.18677718530172283, 0.18667528627965757, 0.17166099699451787, 0.11458825747337598, 0.12238547246251297, 0.12299462430888908, 0.16444638651351473, 0.8870417603478084, 0.7382738097850594, 0.15471060070183063, 0.2095375392953185, 0.1673358711570927, 0.20918141094635412, 0.21099720857706228, 0.2096177542801395, 0.09413870297854976, 0.1542059499932471, 0.19547928947738769, 0.1899824351443331, 0.18109510885862523, 0.18495943578009078, 0.18579459179018143, 0.18855797788879514, 0.17170360070924895, 0.19920442127113525, 0.17597668640552855, 0.09611792728853852, 0.09317486041829948, 0.07614194355950077, 0.08407272966117851, 0.08739972645037364, 0.10766124995529591, 0.08894157705686934, 0.11103289202631117, 0.08057289083163377]}, "mutation_prompt": null}
{"id": "69b88562-10b5-4e62-ac73-3e09a4689f9d", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 # Crossover probability for exploration\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.5 # Cognitive learning rate\n        self.c2 = 1.5 # Social learning rate\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Moderate velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Randomize within a range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "HybridSwarmOptimizer", "description": "Hybrid Swarm Optimization integrating Differential Evolution with Dynamic Adaptation and Particle Swarm approaches for improved convergence and robustness.", "configspace": "", "generation": 24, "fitness": 0.3187563680179182, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8072516356422735, 0.8155979519037263, 0.8017135978070904, 0.8112123498711168, 0.8283208126129111, 0.8027246039015711, 0.7837170048231736, 0.8041740902538468, 0.7933045537356938, 0.5769533905221871, 0.5965998506907155, 0.5771025632642948, 0.5974551354708302, 0.6305443570819551, 0.6001130302909397, 0.5843859176585482, 0.584103670236282, 0.6125789693209206, 0.14986888066215398, 0.13787617811378583, 0.1449943044113503, 0.11999710415168141, 0.13426900161699618, 0.14840401022130867, 0.13267603786527304, 0.6042452618623388, 0.12906818004521992, 0.15444677584484212, 0.0951236969002881, 0.11566493416512491, 0.1257311794475734, 0.095317813240417, 0.10029716076676742, 0.12395195800491887, 0.13057418345471217, 0.11549985348607228, 0.9363730321317978, 0.8741835929774651, 0.9242262617230088, 0.9505803589458653, 0.919327385132345, 0.9118565663025993, 0.9380126843146391, 0.9646766733233018, 0.9400400714440456, 0.57129767062432, 0.5845276006253004, 0.5892724114070295, 0.5697465571256861, 0.6000598712924374, 0.5818165819311478, 0.5493614287489658, 0.5526526077128402, 0.5439023733924138, 0.7587142375245454, 0.8057829088366495, 0.2235130333613542, 0.3441761552758795, 0.8101638907508619, 0.18751856746083906, 0.8176404964906414, 0.2331273860594063, 0.22191834000941824, 0.16404915562171596, 0.1854809943304795, 0.12704937946960837, 0.2017318166852089, 0.17855229335888856, 0.21788387347118676, 0.19267380956529145, 0.18990822477507763, 0.1640078243897628, 0.13006852038082328, 0.2050484649931057, 0.14432362969639712, 0.22896220025679737, 0.20672741809018258, 0.21188822299482524, 0.25119877906615884, 0.22145371788922952, 0.22238290053510024, 0.06040641944200065, 9.999999999998899e-05, 9.999999999998899e-05, 0.09028299037378074, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028667713278596185, 0.0022708195170946244, 0.08571645485122792, 0.18155256303139777, 0.14609201426719187, 0.042127577720929565, 0.04721457695230857, 0.04924289542132487, 0.13860304984529936, 0.05188197207141054, 0.09237333425366157, 0.1439671425394785, 0.08769187197110895, 0.09979650466141154, 0.0674140877528765, 0.10922057018886677, 0.09324148058204484, 0.18845785512628976, 0.15070681594353064, 0.23471808033138863, 0.14997764628228616, 0.16652109634547707, 0.2594266406641209, 0.05792177340037652, 0.06898152266932667, 0.12252814137228074, 0.3116558671679399, 0.18038713717554855, 0.22734694788962484, 0.5291447889813847, 0.5480598572804611, 0.5111329536291453, 0.5315647781991701, 0.5533252170936687, 0.519899254156112, 0.5937514657115965, 0.5269052979651947, 0.5501985729442533, 0.0828583436095649, 0.09589015948688173, 0.10919454197788525, 0.16657895467920192, 0.12830470503124403, 0.13693978169997556, 0.11798175048113824, 0.1105794781776851, 0.14762207120033743, 0.260483144484264, 0.23385202554089424, 0.20497947312127007, 0.3010061673823812, 0.18649265210731492, 0.252726294782067, 0.24828264954559398, 0.2714600125870751, 0.2637041271928555, 0.5062033465251268, 0.28892080753181615, 0.45062885851219925, 0.5267617086935223, 0.314604080817694, 0.5237585773405635, 0.5215719992623378, 0.5408875619418201, 0.5259956049074341, 0.23460558671248932, 0.25453597840892794, 0.2954631270483, 0.23914072539615405, 0.3874472856153911, 0.2983326568363275, 0.31852366166890944, 0.2702011870104555, 0.23661970617445016, 0.2504442679506399, 0.20317029103938145, 0.23694474007859845, 0.22518639008073005, 0.21206911515647398, 0.23914993897889636, 0.1875955889232076, 0.23180262044568845, 0.18939240668013113, 0.19354605843552686, 0.17247817942420118, 0.2220650326644964, 0.2092254890668368, 0.20343894450567812, 0.21377020944356095, 0.23389065708963108, 0.2056650599046259, 0.19124207695942896, 0.8836864366143911, 0.185847709817883, 0.849655490733475, 0.17042170831712555, 0.14766937085410503, 0.19532346292024827, 0.8517800476726365, 0.8626054721809056, 0.1560340771789155, 0.5970518297201818, 0.20922102316699398, 0.5798625902867482, 0.1663395576180543, 0.16670724263051429, 0.681802913288821, 0.16766498750277736, 0.2091447227870572, 0.10489542650809713, 0.1715118640411185, 0.17858796438209135, 0.18896442097605837, 0.174988419342479, 0.18465250944030454, 0.18564429498885227, 0.19083001974135627, 0.19116824750349248, 0.18460660723609568, 0.0850444669425835, 0.09088998839898943, 0.0957035694559294, 0.09422412207293951, 0.08679384231088638, 0.0893994728095533, 0.08959160078163386, 0.09559664769311349, 0.09865178473991332]}, "mutation_prompt": null}
{"id": "014c89ca-8d68-4699-8ab8-3be05f04c520", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.6  # Slightly increased Differential weight\n        self.CR = 0.85 # Adjusted Crossover probability\n        self.w = 0.4  # Decreased Inertia weight for quicker convergence\n        self.c1 = 1.7 # Higher emphasis on cognitive learning\n        self.c2 = 1.3 # Slight decrease in social learning\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization employing Differential Evolution and Particle Swarm with Dynamic Strategy Selection for optimal exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8654156628884216, 0.8505577733650087, 0.8629165407617487, 0.8380421862650951, 0.8456388156840458, 0.8587296791285854, 0.8527912259306096, 0.8559354413193545, 0.8534634313822277, 0.7396929881209096, 0.7341634510349436, 0.7092094663753394, 0.7154728891383115, 0.7193812497122521, 0.7182816213467694, 0.6967750011711794, 0.7069553883493507, 0.7000883977891325, 0.1114105147072143, 0.1481172016688579, 0.1526431654403636, 0.13387851849765897, 0.5442252168246698, 0.14871135036606575, 0.14941128180821783, 0.17945018706496574, 0.1721961393818332, 0.11263438928044145, 0.1503320556503278, 0.11906872559250425, 0.07768433680669018, 0.123196329897314, 0.08839246620613794, 0.10215271061855224, 0.136861489246068, 0.16872141851491052, 0.9553658555778358, 0.962358918073187, 0.94632188274503, 0.9478315924386019, 0.933922097238991, 0.931645767660017, 0.9331854407292095, 0.9361184003567173, 0.9475659196534141, 0.6944265741588745, 0.6856320914341114, 0.6895938036266172, 0.6512602616989766, 0.6877164471456558, 0.6968459829021534, 0.6826596919438079, 0.6890696982652229, 0.6820549676551929, 0.22635534559259274, 0.2395695445189302, 0.871631368557718, 0.27643157799925233, 0.3776060212088548, 0.3654865471871893, 0.22726557497574373, 0.23187077237783693, 0.8641424405872651, 0.11911049122598305, 0.40253532485593235, 0.18724974672384187, 0.18685655018194935, 0.1762400387692964, 0.1677187013488063, 0.20015727878600587, 0.13013515604564707, 0.19273282982800555, 0.13054336021097146, 0.20357835941169955, 0.18189917360312102, 0.20288068384517965, 0.21443735838623112, 0.2665297124948879, 0.10045236270221536, 0.22433507035561873, 0.24968235924269622, 0.04569264568070608, 0.046478388727113074, 0.009403796381180163, 0.11558206670531146, 0.022272836136776775, 9.999999999998899e-05, 9.999999999998899e-05, 0.010927236322666789, 9.999999999998899e-05, 0.09869799781293243, 0.1090027274030263, 0.05063311386168057, 0.04550856712314999, 0.04423383431881778, 0.06882428231234117, 0.08488780433257614, 0.06915948266957872, 0.05616918626292622, 0.09745344578854442, 0.14266038440678452, 0.056123739872517175, 0.07390068554872598, 0.11734251827298636, 0.12287962955005238, 0.0980558089589878, 0.313793869868884, 0.08787551386325854, 0.2917486797997608, 0.07946991282739091, 0.17224156652019373, 0.05828027627746901, 0.1303077885280134, 0.11646763760169576, 0.08124608208620498, 0.09380995154813043, 0.11633120525826257, 0.555773540156163, 0.5361648390238402, 0.5955635893097015, 0.5903343412986675, 0.5705534059184401, 0.5907928198654778, 0.5864770506960435, 0.5807836462029989, 0.5758600831607168, 0.10120420675667552, 0.12293330861734575, 0.08053869524767177, 0.12354207506704484, 0.08073736346821536, 0.10272482608129685, 0.1532115312741822, 0.1360901696747585, 0.11231936726528802, 0.2996945930024152, 0.15036461848789773, 0.29192725793646557, 0.586998814628755, 0.2399129418500099, 0.1898988614820507, 0.27985674526575943, 0.3083813152828182, 0.5046665857709443, 0.37562013603185973, 0.6232592500722111, 0.3557764990869141, 0.5437494596585588, 0.3267962797244046, 0.5034191970719868, 0.2674787778771113, 0.5388690396864722, 0.6257347160992258, 0.23055603168705607, 0.2447596166552669, 0.39697389969629493, 0.2625329956848663, 0.40754650098073675, 0.29008056153170936, 0.1751376443979058, 0.30452850055108005, 0.23510988528554233, 0.19668727799983587, 0.20910730931872668, 0.2175758334347292, 0.20338777031504363, 0.18505592405916904, 0.23282516743307258, 0.23561468261837826, 0.2084214935526616, 0.1992958345658873, 0.22347397714813655, 0.775697066021013, 0.7596980411140908, 0.19538432929097282, 0.2243522715669185, 0.2028591502542586, 0.2386133439715501, 0.19782069255035517, 0.24194431253744464, 0.16480578984400673, 0.18666277229218065, 0.14688420848316563, 0.9098379302694619, 0.1982514777222646, 0.1475028254563553, 0.8731942555370419, 0.16665056287172852, 0.8805288423103896, 0.20927865953032454, 0.21108787377126625, 0.8533564639442084, 0.763389303028059, 0.16733100051057104, 0.8613345632732998, 0.7485132509000212, 0.8102590047437631, 0.7780868464822436, 0.17160405761841613, 0.18127479983452888, 0.18169009769591782, 0.1879575855717499, 0.18826675033422202, 0.18053776450857095, 0.18172286449606012, 0.18021609380021242, 0.18721428705009724, 0.09942796858883207, 0.08282587662772478, 0.09296007929933059, 0.08365309054045356, 0.09063972579928448, 0.10307454917509362, 0.09162982471474646, 0.0995422377362134, 0.08839800323757774]}, "mutation_prompt": null}
{"id": "224b825b-2fa5-4aea-aa99-d8c4d9bc5461", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.1 * np.random.rand()  # Dynamic Differential weight\n        self.CR = 0.9 # Increased Crossover probability for diversity\n        self.w = 0.5 + 0.3 * np.random.rand()  # Adaptive Inertia weight for balance\n        self.c1 = 1.5 # Adjusted cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Maintain dynamic strategy\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Further dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # Broaden differential weight range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Reduce range for crossover probability\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using an improved Differential Evolution and Particle Swarm with Adaptive Velocity and Strategy Tuning.", "configspace": "", "generation": 26, "fitness": 0.2760420686287106, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.6438619928826029, 0.61161371752844, 0.7772209557851831, 0.6387686828001726, 0.6224142823392795, 0.7960175421437781, 0.6305607089273444, 0.6218899189054619, 0.8006612760655398, 0.32859262782850696, 0.25389894532900925, 0.596743636353062, 0.26217471974776185, 0.2943362961276432, 0.6092385277413243, 0.28313007834056547, 0.30398003283283737, 0.5864945193799036, 0.10256394350166775, 0.11526405993634359, 0.14598986141190984, 0.10924911682534877, 0.09927934171083908, 0.11813383743327122, 0.09464995145613608, 0.11963196021432543, 0.13286327035765277, 0.08556135854238545, 0.09700893762367269, 0.10763041870772727, 0.09633894724702818, 0.10197212809622147, 0.13227727150047208, 0.10247295241444954, 0.09483358798841057, 0.13724051430963624, 0.964567572708209, 0.9609063966257799, 0.963732162467997, 0.9475752842420883, 0.9616925621778144, 0.9573832877176056, 0.9624966106947371, 0.9594198121748402, 0.9577463153719227, 0.30705801284899115, 0.2936077982902552, 0.5268836312079714, 0.3037898376520225, 0.28061611993734037, 0.5462322886547804, 0.3281391526533153, 0.28835545284685404, 0.499116297652791, 0.48430057439898233, 0.6252544526326169, 0.6665383562607736, 0.5898432666654114, 0.3179828511942835, 0.3533244593814716, 0.4973942177498222, 0.5842444935339905, 0.7628660044014983, 0.10408566860649648, 0.1662434468611016, 0.24391936570527506, 0.09475189068268208, 0.1564429485783947, 0.21826793506856434, 0.1682703703014251, 0.1568125251658199, 0.20607504050282, 0.052219480188192224, 0.09310529077701069, 0.2115997724427714, 0.173636317930426, 0.14615666038168984, 0.2185241739732191, 0.18503382071742158, 0.08207464663767294, 0.219824123005262, 0.004703469082230516, 0.0032567668582450526, 0.0011734723913082723, 9.999999999998899e-05, 0.013710598813139185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06771032700541013, 0.036388651479823286, 0.09497073015554724, 0.05638122355158881, 0.019571395807596148, 0.08463368279615113, 0.11134833443669379, 0.08467100779330772, 0.1089791501230074, 0.0641688599772442, 0.0699488517657082, 0.08928282678308008, 0.04706834283283712, 0.05603730419733732, 0.08159477218413935, 0.028298896881128854, 0.04838197774787656, 0.08584354011082773, 0.12142356381858066, 0.09140049034530473, 0.10671389187892533, 0.1211004679705473, 0.10087326944804154, 0.051939032980286126, 0.05321878397832536, 0.15010119737173866, 0.16733375440447196, 0.41321010793098134, 0.45290339804161384, 0.5242233361958422, 0.43857106502509635, 0.45367511926643034, 0.5287200489072764, 0.4625145169976431, 0.4343573521653724, 0.5491675340719081, 0.11300517706559898, 0.1087534387562733, 0.10699324180112413, 0.09214548897175956, 0.09777435429512094, 0.13111259565959932, 0.11177721939247931, 0.08752817206534858, 0.10444436294875736, 0.15993864080356723, 0.17860718917900575, 0.32053927154945594, 0.11740242465452899, 0.16491458072219045, 0.19985781669710634, 0.16603805684535533, 0.18924964934998223, 0.16754403176332, 0.3005005424425957, 0.311496400059617, 0.4110777023412594, 0.27477128247420357, 0.25758880543151286, 0.4371027432500513, 0.3377254551192126, 0.33414404473185555, 0.5235983324047846, 0.20877552151826007, 0.2110585747340603, 0.30867203697463996, 0.24839016205472564, 0.22217631066716526, 0.33066158693382175, 0.18268603417465812, 0.23585999278360004, 0.35466312305634295, 0.21093992140871098, 0.18699576649128125, 0.2211307570030201, 0.1907761727222259, 0.2093784694890659, 0.21997676627459928, 0.2122586438909695, 0.2468377738410772, 0.22299510788750243, 0.27644683635770684, 0.18403799646980656, 0.21476092197026186, 0.2417637122234756, 0.25513178838044115, 0.2168194809940387, 0.19222887162663294, 0.1782851220188515, 0.23227951330919816, 0.20796337367561435, 0.16148790583944428, 0.19326276111362184, 0.6981677792984551, 0.7254180059561137, 0.19804006006851305, 0.6654388597695299, 0.7324316798511689, 0.16037374099881108, 0.20736835100552853, 0.37086801574299566, 0.7353716953101368, 0.379941528608436, 0.15010326865343226, 0.1260441168623394, 0.20827168995589695, 0.6023026065742494, 0.7662376265106561, 0.19213938393723995, 0.18278825731510395, 0.17979855594435246, 0.1843058480292793, 0.19215947899611674, 0.1802291630561349, 0.1830239607352837, 0.17831412408839264, 0.1974509423293025, 0.08351246785409272, 0.07747159624267608, 0.0785088890178689, 0.08912398601015814, 0.07705379928023426, 0.08767816518955518, 0.07560042874548778, 0.0723501963814831, 0.08012474524303803]}, "mutation_prompt": null}
{"id": "5f16c9a3-86f4-4e72-9482-a367c8bb7626", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Adjusted Differential weight for fine-tuning\n        self.CR = 0.8 # Optimized Crossover probability\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.8 # Enhanced cognitive learning\n        self.c2 = 1.4 # Enhanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Continue dynamic strategy selection\n        self.learning_rate = 0.8 # Initial learning rate for adaptation\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation with learning rate adjustment\n                self.F = 0.3 + self.learning_rate * np.random.rand()  # Using learning rate\n                self.CR = 0.6 + self.learning_rate * np.random.rand()  # Using learning rate\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Incremental learning rate adjustments\n            self.learning_rate = np.clip(self.learning_rate * 0.99, 0.1, 1.0)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Hybrid Optimization integrating Adaptive Differential Evolution and Particle Swarm with Incremental Learning Rate Adjustments for improved convergence.", "configspace": "", "generation": 27, "fitness": 0.3151891799778481, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8029320253260508, 0.8020596911367294, 0.7779751067554495, 0.7940974052191034, 0.8024627612827482, 0.7928689531784847, 0.7932562260909009, 0.7911891350047442, 0.7980584531866265, 0.6257465931946098, 0.6017924727946786, 0.5922972105749545, 0.6278163046320189, 0.6274679187880824, 0.6052507496949014, 0.6074766109684291, 0.6229656485126981, 0.5954570371899564, 0.1337867070298987, 0.15420586793767144, 0.14080858578091515, 0.14111920461551197, 0.16478630584766374, 0.12417585986971247, 0.13517917388893053, 0.16119419356971576, 0.35156537703891266, 0.13209611628201123, 0.1343188865568784, 0.11089974098979494, 0.10823458885015058, 0.1094685492457731, 0.1334972521087353, 0.12628931696149726, 0.15402425118194718, 0.1498431564327427, 0.9563850447513751, 0.9563697679020313, 0.9656312300617508, 0.9643898656625168, 0.9336790887949873, 0.9545766091629211, 0.9463884508008937, 0.9644088988049133, 0.9608697769252477, 0.6088050961383233, 0.5612340355536102, 0.5366810575722119, 0.5938376806310317, 0.5499123127271628, 0.5530373487897013, 0.5285002846119964, 0.5232682869654307, 0.4837108711928113, 0.2327265928720269, 0.7430855421404254, 0.7890067181175356, 0.8304248399254771, 0.7769564807952023, 0.8040205006760652, 0.8274103926378543, 0.23421971100845607, 0.7611377924280189, 0.183248727750299, 0.2637336917630799, 0.19647341563884524, 0.18315633958974797, 0.1163571679596338, 0.18661359931875454, 0.2031625190345856, 0.1993680180933225, 0.19891538571849154, 0.20488050311442485, 0.19458349825138488, 0.2216423037761982, 0.2355550582864837, 0.20114256693807786, 0.19307507129422896, 0.12618616107017622, 0.21885203031333844, 0.22731422138191582, 0.03061731088933961, 0.04505608461741595, 0.0055549247415116465, 0.06659631288124424, 0.0040760809231311645, 9.999999999998899e-05, 0.05091522198943654, 0.0023765742129866485, 9.999999999998899e-05, 0.06699084832558311, 0.14798887773000347, 0.08835313148621704, 0.023153773486170537, 0.08851288582935946, 0.09168033163111666, 0.04298625568140524, 0.15777277156772074, 0.13168520070858192, 0.05650600833197894, 0.0811884539000326, 0.03605493141497751, 0.08021087249673364, 0.10400751817740861, 0.10285272507149001, 0.0853408158955381, 0.08698722607708076, 0.0658049853286562, 0.13464188977899594, 0.1593858834906945, 0.16958859290570438, 0.11340682465843188, 0.15059555740363195, 0.12592086211453457, 0.21509128111682407, 0.14864095765054575, 0.08359361429880574, 0.5073480847327538, 0.5603905774961319, 0.5646670245588675, 0.5596364713641464, 0.5178682919300148, 0.519962199494662, 0.5546336452816193, 0.5352056950494591, 0.5463781842969415, 0.09869726283569302, 0.12730394741653506, 0.09730523108401701, 0.12878737042721222, 0.10246132453518131, 0.1125818450867544, 0.11744407395240908, 0.14880981516543756, 0.12704942463478475, 0.17623351464045756, 0.4572990440564625, 0.15585466993677877, 0.2939926299052862, 0.18740258511703356, 0.19479522124155335, 0.3374728490129485, 0.22117764211684476, 0.26178096908847803, 0.441687397859826, 0.49611509811187227, 0.36540387389185636, 0.26320610389075394, 0.24516825262159614, 0.458555925240933, 0.5336133168095856, 0.5246176174544636, 0.524608000147762, 0.2397146994064525, 0.22278002828329446, 0.3543915957876831, 0.262216361464898, 0.29510525214294836, 0.22034645508503192, 0.26797105417251166, 0.23819842195754026, 0.2878561010373095, 0.20209142971187144, 0.2028849137049934, 0.22206569330717707, 0.22440836247873974, 0.18924674733153857, 0.2176941797653159, 0.23007619145309832, 0.18607683978324085, 0.19618580243972783, 0.20927761525731126, 0.20333181323960148, 0.5502743082549493, 0.24229923894904826, 0.23450192360927702, 0.23354715568741136, 0.2134542787495498, 0.19598243551932182, 0.18945296925539534, 0.16650218209888568, 0.18505522244881156, 0.14598374924446922, 0.8679660934098969, 0.19668298881669644, 0.14605768050478596, 0.18708054506075267, 0.17636317772643761, 0.1518076183084206, 0.5714721356522992, 0.5822592781117222, 0.5547748960094016, 0.7491683757329799, 0.16288530117500655, 0.20347523116274546, 0.1647349625051827, 0.15363758868089006, 0.1536621651986243, 0.180463367001792, 0.19336253022751948, 0.17646162279050748, 0.20704647313144664, 0.19189238315348944, 0.17489477097109885, 0.18394953379266765, 0.18415945745989015, 0.19932839277157544, 0.0823032637109482, 0.12363298906091313, 0.09478234750186654, 0.09548716170851423, 0.09156234667932694, 0.07689297747862489, 0.08964072811021107, 0.07067236364320961, 0.08188034437534264]}, "mutation_prompt": null}
{"id": "3c7a86c1-4e12-4cca-acb3-a12092f61ada", "solution": "import numpy as np\n\nclass DynamicCoEvoOpt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F_base = 0.5  # Base Differential weight\n        self.CR_base = 0.8 # Base Crossover probability\n        self.w_base = 0.5  # Base Inertia weight\n        self.c1_base = 1.5 # Base cognitive learning weight\n        self.c2_base = 1.5 # Base social learning weight\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            # Adaptive control parameters\n            self.F = self.F_base + 0.2 * np.sin(evals / self.budget * np.pi)\n            self.CR = self.CR_base + 0.1 * np.cos(evals / self.budget * np.pi)\n            self.w = self.w_base - 0.1 * np.sin(evals / self.budget * np.pi)\n\n            # Hybrid strategy\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1_base * r1 * (self.personal_best - self.population)\n            social = self.c2_base * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "DynamicCoEvoOpt", "description": "Dynamic Co-evolutionary Optimization using adaptive mutation and cooperative learning for robust search performance.", "configspace": "", "generation": 28, "fitness": 0.3228539902847337, "feedback": "The algorithm DynamicCoEvoOpt got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8209947970776124, 0.8263064284865804, 0.8177619968437106, 0.8241461303321707, 0.8170131562939191, 0.8212340014905115, 0.826822541830526, 0.8120060327971317, 0.8315989350807151, 0.6514001718737031, 0.6265133865886426, 0.6037916675796426, 0.6147229884346871, 0.6434013546460772, 0.6425516374893046, 0.6530869302926597, 0.662543039875664, 0.6517308516961191, 0.49351051468700224, 0.13874788634979474, 0.14465374187383662, 0.1473106788822902, 0.12988125056500688, 0.13383841146066533, 0.14308947586156395, 0.13466837441916357, 0.14465654402811523, 0.11263348475243751, 0.10834797851823386, 0.13291058641638953, 0.11754605184991618, 0.12781280664673011, 0.1446102761969964, 0.1514346179345828, 0.11605184742582553, 0.11988437986525646, 0.9678413119975187, 0.948501889468384, 0.9541285109502412, 0.9612586713986727, 0.9504355037741726, 0.9527150435581135, 0.9544750697208643, 0.9477601908673297, 0.9679905006683881, 0.5952817226930898, 0.6353963454098401, 0.5630784632974597, 0.5861461160251078, 0.608091416684369, 0.5988220894725889, 0.5630989386846719, 0.6164908085703892, 0.5933172075011792, 0.22544570005422016, 0.7915245389551744, 0.22323304526903032, 0.20859728098787078, 0.2710128654242052, 0.21017542413635182, 0.8195049252074132, 0.8205001986211231, 0.13683342572829793, 0.21859189077241248, 0.13096419262456804, 0.12842294298642687, 0.1943924763615652, 0.2254394721936429, 0.2234960209823632, 0.19855032618892088, 0.20060760117943088, 0.19714401102300116, 0.10033937195210951, 0.22223352022834109, 0.20903590751498902, 0.2328114437916421, 0.20520811814830153, 0.24908460107537023, 0.2222295689659195, 0.2337460378794476, 0.23080230301997384, 0.0674783353620858, 0.029932550899377075, 0.005302379160735282, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07700535035282141, 0.09565494167970467, 0.13466576042721645, 0.08543013104724251, 0.08669367201671319, 0.06822262718584282, 0.09062891442227194, 0.07735664875496406, 0.06714133396726663, 0.19237623159513983, 0.1545651950081054, 0.1615606766136185, 0.32252606376389026, 0.10874608335062297, 0.08018637485340929, 0.09061264950871495, 0.18857434238286364, 0.19912245269120799, 0.1374129576069545, 0.11126410355528427, 0.14155712987289049, 0.2508176830907165, 0.07333094047407829, 0.16579814240357005, 0.16437027907970347, 0.10576477880563984, 0.04947511552690498, 0.5486731938786203, 0.5486810031703568, 0.5118995966488364, 0.5107159391708929, 0.5543121887989102, 0.575572826938129, 0.5602273308814653, 0.5571322503122367, 0.6152704324010272, 0.10994027807948592, 0.09385156352225932, 0.11869251872713393, 0.09558035222662498, 0.08659546663914897, 0.14165027762492832, 0.12278903624939053, 0.1401792331715045, 0.14211302142953997, 0.31056275081313245, 0.3002687883193482, 0.26966340044613624, 0.14725613081987343, 0.3448389780558908, 0.3762781540827176, 0.23706521048726892, 0.5709874469625619, 0.34339429754170114, 0.39305299618371137, 0.528385328558326, 0.3820442456291375, 0.5333204442604198, 0.5654912595693384, 0.5103665374269953, 0.5766589889999517, 0.5703985966565821, 0.556220343992571, 0.3147638885333378, 0.36059009290225474, 0.21298356651094463, 0.26593603879627803, 0.20538897150221047, 0.39190646928434925, 0.20489146938917802, 0.22796482763387327, 0.20249654120382565, 0.2116603635240245, 0.26278750414623786, 0.18590513688874188, 0.18336759092419253, 0.21299590551671144, 0.20022613996531613, 0.21678571561466964, 0.204532132265839, 0.2157586395412735, 0.21319213280521154, 0.21404318043458148, 0.6679415733355891, 0.21276046040243313, 0.24168193797600912, 0.2047680970762793, 0.21642069475536496, 0.24381353317638, 0.21832074880905672, 0.18616799090958525, 0.17690215948095978, 0.19891758584770747, 0.8585419762632606, 0.8682072137926895, 0.14375446837110484, 0.16919783314760573, 0.8300176077139112, 0.17432233843605904, 0.7173258842083297, 0.16762660111722094, 0.12650125955853841, 0.776616217295373, 0.16731015286859763, 0.16769159782142562, 0.16495395349172726, 0.21034903838702557, 0.16656129226038796, 0.17952220849662848, 0.1769238294090475, 0.1855801985535509, 0.18395999727943224, 0.1763773707608578, 0.18151418057150126, 0.18909299264375412, 0.17448629174260533, 0.18889165004592134, 0.08853441526320349, 0.09318760292199146, 0.08705473534133235, 0.08847952321459795, 0.08947720578181584, 0.0815461907943913, 0.09291252122483473, 0.0819697071071459, 0.09382653387080209]}, "mutation_prompt": null}
{"id": "dd6d0be0-491c-4ed3-8ebb-47987ddc89ab", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.3 * np.random.rand()  # Increased randomness in Differential weight\n        self.CR = 0.8 + 0.1 * np.random.rand() # Fine-tuned Crossover probability\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.5 # Adjusted cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.5 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([float('inf')] * self.population_size)]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.75 + 0.15 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization utilizing Adaptive Mutation and Intelligent Velocity Control for robust exploration-exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.3121591878690345, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8109969256408716, 0.8164570068071239, 0.8223209036640655, 0.8157231732676616, 0.8205085313360799, 0.8169174217974731, 0.8195917548009537, 0.8104576797444786, 0.8082322096696276, 0.6569743116845819, 0.6634740146937061, 0.6252905882892399, 0.6319290302466409, 0.6459988478517373, 0.634217765888778, 0.6338877999139283, 0.6458678642719242, 0.6275947265709939, 0.14613097782205986, 0.14466071287500493, 0.14092175630226755, 0.072982564812765, 0.14846745825916985, 0.13012018485853571, 0.1259621497708051, 0.17576073890421395, 0.15173137693807892, 0.13101808255469571, 0.10793456347284625, 0.12222050330200729, 0.13304339593855674, 0.10390609123265693, 0.13101810269159309, 0.137576270695982, 0.12910121198578184, 0.10328784703143734, 0.9784266455890482, 0.9551138128560139, 0.9600634728883286, 0.9576841842609707, 0.9592779023643879, 0.9708901005746681, 0.9663882530636061, 0.9662204750984897, 0.9689741662755372, 0.6243826220706417, 0.618845599914911, 0.5900882216120134, 0.6209157462870101, 0.6119900955503307, 0.609545500942406, 0.6315002000420907, 0.5548000549947353, 0.59494866323561, 0.22256786246514693, 0.206733829664279, 0.3794934955084922, 0.2080407733589672, 0.2712223870820105, 0.8129636857505714, 0.7626572115883195, 0.2371508046897709, 0.8280341413121982, 0.11673902401602299, 0.1886870450884891, 0.217046798934595, 0.11906031426185804, 0.1248441862966736, 0.126367837121674, 0.20889855271998692, 0.2097804083902386, 0.23553340847026827, 0.10425450034779626, 0.1980984700702797, 0.2959468610177599, 0.21377681860522235, 0.2078337344938308, 0.23396928546094775, 0.20678881761834578, 0.20946448026883713, 0.20830659347334346, 9.999999999998899e-05, 0.011900620482105162, 0.00316925076389285, 9.999999999998899e-05, 9.999999999998899e-05, 0.04114059688504623, 9.999999999998899e-05, 0.003812897209058641, 0.008870216844290346, 0.06582643301267199, 0.05670072052283559, 0.07026514522935756, 0.10771227875688949, 0.04305343460476796, 0.0413797228565278, 0.10705301714790749, 0.052741410911650966, 0.08544951884488727, 0.10214304554055564, 0.10663935699496074, 0.031085158341827124, 0.12457014228282859, 0.15274952186206592, 0.08173194647478554, 0.3026107824240848, 0.10020266024190716, 0.17842235147730412, 0.17282889949205604, 0.10332220268552028, 0.12329243412956026, 0.13232172063791914, 0.1501492974669172, 0.09700326424796168, 0.07963785019753544, 0.06064310833025577, 0.07381187020294178, 0.5538024807373283, 0.5324571127732185, 0.514390940035631, 0.5128936826727197, 0.5809029951667821, 0.5277984220845529, 0.5455535680455669, 0.5652096934329105, 0.5488628600429661, 0.12365505143805144, 0.0986433194689662, 0.0760418363695311, 0.13418492314273756, 0.14218722607559975, 0.15360165963805483, 0.13437198402015837, 0.16711483150306872, 0.12406653030347348, 0.24348974613921603, 0.19727386131897506, 0.2902341807186086, 0.27698736421036185, 0.2866746830591246, 0.1347756992654282, 0.2903182951291984, 0.38541157130995574, 0.3364553373453907, 0.5334351018958088, 0.24102116838502174, 0.5172929467374967, 0.535865032844228, 0.502327423367517, 0.31136272178801483, 0.503894876168412, 0.5337280549036425, 0.5324738111406236, 0.34411201298424043, 0.21599416598863408, 0.2141167111023351, 0.2438724057497359, 0.3519542811513565, 0.27221738297001696, 0.2401576069939092, 0.20537750587229853, 0.3170816680300903, 0.23984141781996648, 0.2186456513060835, 0.21990851908317854, 0.2015398571412751, 0.21256904608301064, 0.2135543238886467, 0.19637702453283634, 0.2400549574957518, 0.20442887938334198, 0.1924556854136732, 0.2166714270923351, 0.20430302011981827, 0.23945060754308578, 0.1983514698325144, 0.2080208179592714, 0.21182631836371124, 0.630355197977007, 0.19858594204238478, 0.11239380334104754, 0.20928998662119547, 0.8780206201784743, 0.16882928479216808, 0.15513658643047712, 0.8705342963696195, 0.17562585320725943, 0.1348510365495511, 0.17046698342109334, 0.08249707863562727, 0.20640414033271637, 0.6094511186438325, 0.1665680757688418, 0.15479207655463545, 0.12590940956364216, 0.11249696844336854, 0.7593742472238403, 0.6900370725134897, 0.17676183036541193, 0.1838327845388702, 0.19320535136481887, 0.20316910966005408, 0.18025183780120624, 0.18005659817672093, 0.1794314488694585, 0.18543057872983737, 0.1772045277820412, 0.0882013160175531, 0.08707268439540017, 0.08555871140021531, 0.08357581550314497, 0.0915946831495188, 0.09377434356085901, 0.09211435576054883, 0.09161505115513213, 0.12102754790301384]}, "mutation_prompt": null}
{"id": "a8dbbe0c-e337-4df4-8b83-9e0fc54a0888", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.2 * np.random.rand()  # Randomized Differential weight\n        self.CR = 0.8  # Fixed Crossover probability\n        self.w = 0.3 + 0.1 * np.random.rand()  # Randomized Inertia weight\n        self.c1 = 1.5 + 0.3 * np.random.rand() # Randomized cognitive learning factor\n        self.c2 = 1.5  # Fixed social learning factor\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = np.random.rand() > 0.3  # 70% probability dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation with randomness\n                self.F = 0.4 + 0.3 * np.random.rand()  # Randomize within a broader range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Randomize within a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Hybrid Optimization using Adaptive Differential Evolution and Particle Swarm with Randomized Strategy Switching for enhanced solution diversity.", "configspace": "", "generation": 30, "fitness": 0.3274690988499927, "feedback": "The algorithm AdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8467618291787822, 0.8541753681304157, 0.8606564347262411, 0.8470962870587392, 0.8349040527938308, 0.8537099869978978, 0.8494179962108499, 0.840105744136878, 0.8464675933278937, 0.7102011063333806, 0.7183337129522729, 0.7335049919708091, 0.7021565876366679, 0.7153482347379629, 0.6529903881438021, 0.6872540232756662, 0.7140563913794278, 0.5103549760571245, 0.14363646401737062, 0.18131026716289056, 0.12652993976132132, 0.16769874032831344, 0.15217569005193854, 0.17879540948977302, 0.1782036887403392, 0.10667900858076429, 0.15655743003212896, 0.11157054704852198, 0.1442937120966037, 0.0922293405858512, 0.10133476728031188, 0.10144501260225514, 0.1069070856055585, 0.06963412466298957, 0.14844488582947835, 0.11799201942940474, 0.9282097855256497, 0.9309565546648315, 0.9742212837340158, 0.9374426170892918, 0.9624355991533297, 0.9471734014977412, 0.9539966508625684, 0.9528012587383491, 0.9462609766569017, 0.6271687200939149, 0.6648614128726777, 0.6937429562204598, 0.629271422382142, 0.6355518209888582, 0.6527157225030924, 0.64384791906421, 0.653329161604375, 0.6441536331585128, 0.22200347841967716, 0.3815751157793664, 0.8192053932225661, 0.3737738496137045, 0.1883185896699553, 0.2115085007031411, 0.1638655019349441, 0.23157643891956003, 0.23433025891344028, 0.20578312995380432, 0.21140341784078331, 0.1975458999091918, 0.18774319339548462, 0.1435878686353309, 0.1997235461391852, 0.204238580641651, 0.2148423242414037, 0.20161520399021948, 0.2081104889511053, 0.20080899959315457, 0.13358092518318831, 0.2365932353027107, 0.19999689556362477, 0.19062762782832499, 0.23009911900621005, 0.12413547335036679, 0.21200010239923217, 0.0018120172538906854, 0.04725854450780809, 0.0002087279205652548, 9.999999999998899e-05, 0.003860479831458319, 9.999999999998899e-05, 0.0038510170790928555, 0.016465670859812764, 0.035216499994655925, 0.07959888960545436, 0.06447387838730467, 0.1090656379647007, 0.08599426129351107, 0.06801209613126591, 0.06298764232865584, 0.07554238024807569, 0.11210582029319571, 0.06778437807781845, 0.04598431728548946, 0.07008572328145424, 0.2929508777454336, 0.3851788161107631, 0.07537567999354577, 0.07480374498670173, 0.13769623192646652, 0.13707000483669984, 0.15672196862325039, 0.1081708257967764, 0.20442187066221262, 0.06055765370818367, 0.08788159504147008, 0.09532120751202788, 0.23271793188445544, 0.08095847876108198, 0.13497893430508356, 0.08332138639254572, 0.5164926088097644, 0.5759799042570247, 0.5404650122802537, 0.5817197618901577, 0.5463292824441975, 0.574596008382869, 0.5434351377734927, 0.5637829669587642, 0.6410158617227699, 0.17093290105881753, 0.10528800062794175, 0.12384286555990365, 0.17205371963484684, 0.12815120315815387, 0.1359256558147861, 0.10861486410572285, 0.1065282151464253, 0.15402824512587798, 0.3117667401499393, 0.2560334085893785, 0.21757745171999454, 0.40071833264681944, 0.3990070728944326, 0.16945322843603283, 0.4710562839969361, 0.13374052803030267, 0.26010822060384886, 0.5821812476781791, 0.6072637922376389, 0.49450882724109224, 0.4757809300730712, 0.3583033615883706, 0.5236829121293837, 0.2704080596700549, 0.6543780034385309, 0.5973509073623797, 0.20922834759320008, 0.29375327421641517, 0.1124810810848661, 0.4102793699501641, 0.25314976997496286, 0.3538065117805458, 0.23467422280409145, 0.3259394501284828, 0.205680416876324, 0.2321441060284848, 0.2002274169052798, 0.22246921857231194, 0.19138674988303006, 0.20834105129308633, 0.2553814776079172, 0.20295043597658835, 0.21447770817809264, 0.2291074241037595, 0.20448949436490071, 0.2047058679656204, 0.1751962185481465, 0.6611665278333687, 0.19797851120614673, 0.23706935846883082, 0.20866768057133644, 0.22244469784090948, 0.2195453951101325, 0.9032120915574828, 0.18563184827750523, 0.16385693086550424, 0.16398824444490323, 0.15841619919899808, 0.20973417939330952, 0.9024742169813413, 0.8805295029766158, 0.16301921439183553, 0.5026279914203569, 0.6500225588934714, 0.5147505269255461, 0.6842971583505488, 0.49481235345986874, 0.1680692466227709, 0.21002616495348814, 0.16814316141242414, 0.7863585842971073, 0.1772807111252518, 0.1797975889420066, 0.18794433783594144, 0.1768942954241567, 0.17219424861964794, 0.21641648992242835, 0.1772180953778536, 0.19568115912121253, 0.18604790885305755, 0.08697918945057359, 0.08838998384513219, 0.09724323137423507, 0.0907845510626788, 0.08424456415914594, 0.09491748903308128, 0.08076420364382197, 0.08748150394615184, 0.11552923243621627]}, "mutation_prompt": null}
{"id": "9018adb2-cf69-419c-9709-2a7958aba361", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size for increased diversity\n        self.F = 0.5 + 0.1 * np.random.rand()  # Stochastic Differential weight\n        self.CR = 0.8  # Fixed Crossover probability\n        self.w = 0.5  # Adjusted Inertia weight for balanced exploration\n        self.c1 = 1.5 # Reduced cognitive component\n        self.c2 = 1.5 # Equal emphasis on social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Increased velocity clamp for wider search\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Maintain dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Stochastic adjustment within a tighter range\n                self.CR = 0.75 + 0.15 * np.random.rand()  # Stochastic adjustment within a tighter range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization leveraging Adaptive Differential Evolution and Particle Swarm with Stochastic Strategy Tuning for robust convergence.", "configspace": "", "generation": 31, "fitness": 0.3138844729985627, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7693959576040056, 0.7877602128173327, 0.7775269005148838, 0.7743444695220397, 0.7975720103165582, 0.7856702879434546, 0.771409325159794, 0.7726846882437483, 0.7901416226343749, 0.5804697528629963, 0.5409118669368325, 0.5692845711117536, 0.5628891941368341, 0.5766932452483435, 0.5819845436514693, 0.5680496917611031, 0.5571822202792278, 0.5643789565400886, 0.09213809748982693, 0.1439340167227332, 0.10104415237350173, 0.14716893039636758, 0.13665979315558285, 0.13929703196978827, 0.14082802227885427, 0.1245915611519236, 0.13107694432269512, 0.09148297276282424, 0.13026578634528596, 0.13529503036934998, 0.096380176167838, 0.11164698339952606, 0.11998672610705086, 0.12605149122263304, 0.13959320946452403, 0.12733775535789205, 0.9749135311133003, 0.9435845924892431, 0.9451391839364568, 0.9426399811562832, 0.9473694571309054, 0.9539217563787152, 0.9559112777063434, 0.947174490205468, 0.950474274090643, 0.5289442453560613, 0.4979693680936037, 0.5016167940132721, 0.5197452678467254, 0.538537935715131, 0.5061218636834218, 0.4958695147757981, 0.5092614874597735, 0.4956928025938543, 0.2191717480434423, 0.8174513577703053, 0.7839382621260202, 0.2087353135889639, 0.2060499220936748, 0.2666706342354952, 0.22536230125381274, 0.7631732140428287, 0.783370950158526, 0.19338682922824546, 0.1499265574231633, 0.1809263259293694, 0.19157087554185226, 0.19201254170426596, 0.1275769555355437, 0.19270140478260123, 0.1858753354378906, 0.19623661611505516, 0.21013944367068071, 0.21517318298106025, 0.13241075113181833, 0.2374623393614982, 0.1257491201730898, 0.1252775013916878, 0.21070846986171088, 0.23431172634040087, 0.21868753310284572, 0.033378090301635854, 9.999999999998899e-05, 0.13167684283910497, 0.018650924193099994, 9.999999999998899e-05, 0.0002457331078093983, 0.1471946041247656, 0.003478363870836776, 9.999999999998899e-05, 0.12491349719540701, 0.09890109115465695, 0.06790255958869496, 0.06832095078097444, 0.06070987133171091, 0.14295796163457963, 0.0889487294286242, 0.0847722393104019, 0.09777544601075783, 0.23823690215571502, 0.15918789775852815, 0.04832553002280038, 0.15012889144220187, 0.07861598327292374, 0.06669102536298432, 0.08614360681066868, 0.10008685955466023, 0.08086685513767478, 0.12137841654938641, 0.04036345445671363, 0.17960485748775246, 0.141496962773618, 0.18160777049765042, 0.1273812236201638, 0.11008617123786446, 0.15972184478433848, 0.2384598367909705, 0.5479830374208388, 0.519737976925207, 0.5293386407020086, 0.5400251249389871, 0.5198145234587275, 0.5104968545318584, 0.5275772009100347, 0.5340414916960023, 0.5379540919732777, 0.12994208212318448, 0.09482065413983876, 0.07877346918637629, 0.11889049305512145, 0.10232768102750711, 0.1471434580831179, 0.09044134543191251, 0.12488348857949494, 0.1428823185412501, 0.17511121805035346, 0.4396385237902387, 0.3396697334575175, 0.24673744348687932, 0.22625650645370288, 0.1730088337343606, 0.1879339063659229, 0.18129255290879842, 0.46991024076040677, 0.28550701565643744, 0.4588076755779721, 0.29647751456291216, 0.4919299164599593, 0.48299115490399913, 0.480344470056578, 0.2334042389538512, 0.507499563713822, 0.45208475198089904, 0.2753571900260815, 0.27177889421339596, 0.2689968159398377, 0.25512186152650473, 0.27583144439307494, 0.28162209035938757, 0.25380841526416353, 0.24422768371694714, 0.22063894143729423, 0.2619666266470664, 0.21451096487499888, 0.24947585009639628, 0.19262567814811393, 0.21141080264105439, 0.20445324317485547, 0.19479691182077252, 0.2196158681014232, 0.217468325753029, 0.6087537381398122, 0.22838424964915272, 0.19846128481498326, 0.23617567047589438, 0.23863625138703426, 0.21111840662065862, 0.1976009827893307, 0.2009999322945638, 0.18884825814574702, 0.16453022162256403, 0.13030360411338482, 0.8557289931499645, 0.8305446344908358, 0.8584394917541198, 0.20437100446441014, 0.8515353953934901, 0.8497237682510664, 0.8369062960024511, 0.7943847270170783, 0.1532894825037998, 0.5529643541783822, 0.12663298742440132, 0.1672577864570569, 0.1668079155753871, 0.15420641028505355, 0.20975900510819612, 0.15468427079065228, 0.18937243274462723, 0.18334964410624466, 0.20458093155906254, 0.1763143134396461, 0.19429656624932334, 0.17305167886747408, 0.1970568742292378, 0.18178707203920164, 0.192343014537516, 0.08496437949649338, 0.09517435890108861, 0.12598068461714906, 0.08987780028459513, 0.1410142014805329, 0.10781918363903209, 0.0862052508333474, 0.09095460496831642, 0.0838830213598627]}, "mutation_prompt": null}
{"id": "ead66f92-baf6-4b17-936d-d480cd621118", "solution": "import numpy as np\n\nclass QuantumHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.4 * np.random.rand()  # Dynamically adjusted Differential weight\n        self.CR = 0.9  # Increased Crossover probability for better diversity\n        self.w = 0.5  # Balanced Inertia weight for stability\n        self.c1 = 1.5 # Refined cognitive learning factor\n        self.c2 = 1.5 # Balanced social learning factor\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def quantum_tunneling(self, solution):\n        tunneling_factor = 0.05\n        perturbation = np.random.normal(0, tunneling_factor, self.dim)\n        return np.clip(solution + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Randomize within a range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Quantum Tunneling\n                if np.random.rand() < 0.05:  # Small probability for quantum tunneling\n                    trial = self.quantum_tunneling(trial)\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "QuantumHyDEPSO", "description": "Quantum-Inspired Hybrid Optimization leveraging Differential Evolution, Particle Swarm, and Quantum Tunneling for enhanced global convergence.", "configspace": "", "generation": 32, "fitness": 0.3245983156897161, "feedback": "The algorithm QuantumHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8245196378157347, 0.8201805911067199, 0.8116601591694959, 0.8253134065350931, 0.8130609590825881, 0.823330762563446, 0.8164997039267318, 0.8253639483311292, 0.8128185344907365, 0.6516158083592708, 0.6706904674560752, 0.6355155813216591, 0.6819301076921997, 0.5594760932822663, 0.6070757336659731, 0.6539449162056465, 0.6597173261089218, 0.5332511175737108, 0.15637549701851472, 0.1596619807349362, 0.17078270532418516, 0.16811654477649496, 0.1233721029763275, 0.16696676833520374, 0.14873962656917317, 0.5843663948153746, 0.13946534547975553, 0.1090145313387757, 0.1446485766216974, 0.16483602830633992, 0.10235968796730499, 0.13890685028569838, 0.10914079028001322, 0.14345396057148063, 0.1310661600152242, 0.14018819542118433, 0.949988264580737, 0.9394584743098472, 0.9401590242910289, 0.9527856457515476, 0.923136495774642, 0.9534714729890077, 0.9616362480882326, 0.9561165988756203, 0.9477536551583868, 0.605354778091694, 0.6294257835171346, 0.6280701128456947, 0.6124974352412337, 0.608698819921127, 0.6384237353755733, 0.6351705683303914, 0.47977420161574225, 0.5997061424950153, 0.80654366607016, 0.1664276383575528, 0.16851198165010972, 0.21153237597834273, 0.21113625826747406, 0.1591517562537974, 0.23008621124987638, 0.7326369691592466, 0.8385731658882802, 0.2091547935413539, 0.20817322345686007, 0.12402558913825434, 0.12618000598713075, 0.23883803429302153, 0.19452352213534818, 0.19700469094790551, 0.21352537445201392, 0.21291062237888214, 9.999999999998899e-05, 0.2113601916454243, 0.22555272956816308, 0.20818106799304137, 0.2333701870985747, 0.19232518977861035, 0.24747859265137706, 0.23724022992444982, 0.12688077282446464, 0.010665550644934796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011108560349264884, 9.999999999998899e-05, 0.008909124683567415, 0.04262502515284561, 0.009751188759144824, 0.05273988383300643, 0.08435537760458722, 0.08936145448812771, 0.12923610058796653, 0.012265458253806316, 0.10010304566705275, 0.09563443922984083, 0.16455149350326048, 0.06697364019435559, 0.10080750959063267, 0.41039428066667594, 0.17047220338150237, 0.2066540808814472, 0.07089559066774365, 0.08462046308443405, 0.3062638662449908, 0.19663442544541, 0.17784184505568668, 0.17452866648682464, 0.15532981780093036, 0.20739483854413432, 0.0870692477825078, 0.1621081305552472, 0.13553424962417304, 0.08211703384766422, 0.13426167476674833, 0.0560412759837573, 0.5477723675101881, 0.5825391708748174, 0.51957680366383, 0.5512975102858326, 0.5562401522111181, 0.5811114285465536, 0.5622201707301092, 0.5540986964554857, 0.5620090407114855, 0.12632474635741042, 0.1525010852598211, 0.11774965753430455, 0.1705610143736872, 0.13010290265622892, 0.11526766808721856, 0.16792081080475108, 0.14635827253692946, 0.16807976641704114, 0.34180148727325965, 0.43567782213770256, 0.18375228607837457, 0.22272335092088213, 0.42388083568501844, 0.29738155515061593, 0.2690705594511472, 0.24437248491713548, 0.39647959943704925, 0.5292617976844092, 0.3346293597183424, 0.3722341093214666, 0.4245324709295277, 0.5341417117178693, 0.3522149481213743, 0.6146543257046804, 0.4301838173615834, 0.550332815106209, 0.25743958278599666, 0.22483398315768122, 0.36750376816981933, 0.3578221510440607, 0.4134938195184812, 0.19853755090340652, 0.3160815394738936, 0.33482359386095406, 0.2741512069142247, 0.2261364977837007, 0.22107288902729805, 0.22462950484014987, 0.19500590294913167, 0.2027905827140578, 0.21819696401151956, 0.20845515565195571, 0.23117548284913347, 0.19758514952800255, 0.24186189551890636, 0.21814125745047563, 0.24010393533233232, 0.6923122099906727, 0.19023692375254575, 0.24534912130421838, 0.2438170170008227, 0.24025410201030517, 0.24402790852492995, 0.1469649668556, 0.15651952585138784, 0.19782784219513527, 0.8459724569813086, 0.1715132832711448, 0.8891786975788056, 0.16570886003908492, 0.17128095566023127, 0.16892567867879826, 0.8406049910366304, 0.7071546208939159, 0.16839363230310134, 0.7725467106593824, 0.21106133198287758, 0.1666427751026548, 0.21021666768327718, 0.21014642651855042, 0.16657164580050632, 0.20352242164078316, 0.1798644022138558, 0.1946410848149397, 0.19476096208899385, 0.18902414735761375, 0.17791556084515525, 0.181753501073887, 0.20126947123757877, 0.18950921441053348, 0.08798091310319256, 0.09735375565621229, 0.08186318622349387, 0.08377062023859505, 0.11556822056922778, 0.0963113111413495, 0.08409552179708257, 0.08536440332067885, 0.08841168152125434]}, "mutation_prompt": null}
{"id": "beb65606-97fe-42c5-bfb0-9d637ea393cb", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.2 * np.random.rand()  # More dynamic range for Differential weight\n        self.CR = 0.8  # Fine-tuned Crossover probability\n        self.w = 0.3 + 0.1 * np.random.rand()  # Randomized inertia for variance reduction\n        self.c1 = 1.8  # Fine-tuned cognitive learning\n        self.c2 = 1.5  # Fine-tuned social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.zeros((self.population_size, dim))  # Start with zero velocities\n        self.personal_best = np.copy(self.population)\n        self.fitness = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        for i in range(self.population_size):\n            self.fitness[i] = func(self.population[i])\n            evals += 1\n            if self.fitness[i] < self.best_fitness:\n                self.global_best = self.population[i]\n                self.best_fitness = self.fitness[i]\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization with Adaptive Differential Evolution and Particle Swarm featuring Stochastic Variance Reduction for improved convergence and stability.", "configspace": "", "generation": 33, "fitness": 0.32455044149900364, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8331439986359619, 0.8388534025083161, 0.8507214514188705, 0.8267631463047785, 0.8375429458978307, 0.8446214534302624, 0.8275375470751185, 0.8302869399050915, 0.8408529000917017, 0.6732655760585666, 0.6500300679109607, 0.7365554298011592, 0.6908595236476414, 0.6523286520500609, 0.6889982833478538, 0.6691437319786913, 0.6570530458336274, 0.6938419253202981, 0.1423055297121788, 0.14650394896567964, 0.15356607495279218, 0.1473270351780961, 0.14352074956354832, 0.15072207331933263, 0.26445695875250697, 0.6022197004187899, 0.1639000312809601, 0.1108739692481171, 0.12626114069100547, 0.10357118788519215, 0.1470698057942047, 0.13996808124843518, 0.11530475695344755, 0.10534729283853428, 0.1295064630418603, 0.11651438141581816, 0.9493384411278171, 0.9454422142914336, 0.9511687623715008, 0.9515776004935228, 0.9598808471052791, 0.964336837099361, 0.9641260865197421, 0.9346701579030396, 0.941935066981352, 0.5836661086241199, 0.5729638474609214, 0.6028271028340597, 0.6026319368883633, 0.5904163587950293, 0.6066943945769572, 0.5165690236193985, 0.5600691792957229, 0.6358175381357656, 0.22241270780425904, 0.372714863568947, 0.22465926109761103, 0.2078090846664743, 0.21846886014923572, 0.2791429490984698, 0.7492625457073505, 0.3661230924492337, 0.7905228900546263, 0.2107697972297291, 0.3687589500711611, 0.20704715584957456, 0.18085747991874457, 0.1969409410919668, 0.3091046926449381, 0.2095492742757259, 0.19992182654298318, 0.20312066683432206, 0.18847875647563173, 0.1287118989130127, 0.13320144842220016, 0.21075244098961188, 0.22963471108579514, 0.21164195426546817, 0.12718978122450442, 0.127830651591188, 0.1956339858919709, 0.024174377810075254, 0.0014162490149653983, 0.0008828177946055282, 0.08245215722398536, 9.999999999998899e-05, 9.999999999998899e-05, 0.02067181854078859, 0.006607468303912567, 0.0026925703316679206, 0.07501511368947744, 0.10546623976107239, 0.08049269559583949, 0.06631887205889819, 0.04414813321317412, 0.07526115823356738, 0.2038566484896035, 0.0759235119185403, 0.12148465359345173, 0.24101897078420487, 0.2352158358040911, 0.03622340659425738, 0.07298744061060547, 0.23378687588832814, 0.07662315781199325, 0.0953630703617877, 0.15362305848957947, 0.09584119207159492, 0.14994346732815922, 0.24739400398501488, 0.06034081248132839, 0.13812284119236684, 0.09173400054190783, 0.1507422429662829, 0.11261464729945403, 0.08016198501620042, 0.07583679884443884, 0.5156276597039788, 0.5346225065935355, 0.5299034665842168, 0.5468687883006599, 0.5579039206150873, 0.5478876688428018, 0.5570309650061521, 0.5865891522383248, 0.5956883488946558, 0.12615452288374562, 0.13544604496054036, 0.13300968854127937, 0.12582071921794125, 0.1165717297555724, 0.1265516407413224, 0.14323772629747733, 0.1081750304060024, 0.6109187263152549, 0.27004390059691197, 0.27116758719332934, 0.22051994405205866, 0.18522893954857855, 0.15866555209270683, 0.30275363915974896, 0.1974689327497715, 0.3392504023186568, 0.38458492188098303, 0.48690676445256076, 0.3147817014549005, 0.31736946724124704, 0.4636345121030312, 0.41417356294735885, 0.25825698564083466, 0.5062215863164585, 0.5194289457541659, 0.587586875615744, 0.3633101987949, 0.3682169669209907, 0.3262848083947202, 0.27706634057371304, 0.35217537247612063, 0.21698854245072308, 0.3149644542847704, 0.2949921795532777, 0.2919813324637416, 0.20072794489826684, 0.22533390736492476, 0.2035068769868701, 0.18962409029575822, 0.20558004854333445, 0.217631640082958, 0.1972809391847845, 0.23395059231534765, 0.19679519958298486, 0.6348873333207936, 0.650097539523911, 0.1927152507323755, 0.23304987486365103, 0.1982649298484933, 0.6624452860883887, 0.22351329701355893, 0.20522600012977088, 0.23711948672339545, 0.1869236878516154, 0.15728250206928407, 0.19763331338217827, 0.16808678128567767, 0.12457551992177851, 0.1877293612626204, 0.17337741042007315, 0.17172559178687585, 0.16808391134817813, 0.6887114466871009, 0.16749920220063397, 0.7329818941504613, 0.20942090075031206, 0.20904141989727443, 0.7758330615990704, 0.16826650450482117, 0.8002282483845927, 0.7490859909794123, 0.17677134083169732, 0.18442196270995026, 0.18890195696491197, 0.1816437545181414, 0.1834266452566944, 0.17554160779674655, 0.18626977730574268, 0.17411945601020873, 0.18480217538149746, 0.08341887571493534, 0.08628995106857451, 0.08918756188860955, 0.09228930452336204, 0.08406190758849752, 0.11707665649597854, 0.11044045313808859, 0.0790691606576045, 0.08852143886082631]}, "mutation_prompt": null}
{"id": "8dac12f3-a95d-4160-80cf-4e23b8b2fe10", "solution": "import numpy as np\n\nclass DynamicHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased population size for diversity\n        self.F = 0.5 + 0.2 * np.random.rand()  # Randomized Differential weight\n        self.CR = 0.8  # Balanced crossover probability\n        self.w = 0.5  # Adjusted inertia weight\n        self.c1 = 1.6  # Cognitive component\n        self.c2 = 1.4  # Social component\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([float('inf')] * self.population_size)]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Dynamic strategy toggling\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic strategy\n                self.F = 0.45 + 0.25 * np.random.rand()  # Further randomized\n                self.CR = 0.75 + 0.15 * np.random.rand()  # Random crossover rate\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "DynamicHybridOptimizer", "description": "Dynamic Hybrid Optimization leveraging Adaptive Strategy Switching between Differential Evolution and Particle Swarm for improved convergence across complex landscapes.", "configspace": "", "generation": 34, "fitness": 0.3091732070376786, "feedback": "The algorithm DynamicHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7707552623413989, 0.7826170164875577, 0.7805368262993864, 0.7748880269038322, 0.7806534639964343, 0.767771082672091, 0.776432120605121, 0.7798752351838585, 0.794007183543526, 0.554469624186817, 0.5810878272360983, 0.5591242161118473, 0.5763152408698128, 0.5853699524722009, 0.5573180753416342, 0.5810016187776668, 0.5366583408494041, 0.5621319607097448, 0.12545694807385321, 0.13002925310945013, 0.1454412322147426, 0.1578013780730778, 0.23108607185650176, 0.147455318197807, 0.1429492071239401, 0.14240491293853463, 0.1510651695036036, 0.10623371956713512, 0.1380067127455703, 0.12319756960421713, 0.13514027594717937, 0.11268298475644678, 0.10930067299466117, 0.10915670641053443, 0.11927659661211343, 0.11682348990026059, 0.9574188321511385, 0.9380891582162554, 0.9460314329541742, 0.9459351413174393, 0.9460804672748069, 0.9591044037390037, 0.9558557002353911, 0.9471577098115319, 0.9338644547881174, 0.4487768478506642, 0.486740853196179, 0.5164214059806944, 0.48959524163310075, 0.559917812748095, 0.5178765596219705, 0.5226806582361053, 0.5444493068704908, 0.4672670063136539, 0.3605195201869218, 0.3581424566644422, 0.22037127577085547, 0.791710967223479, 0.27362027719623006, 0.7317051684807478, 0.21416234177137983, 0.36675366551585975, 0.7970189551911677, 0.19723532696019486, 0.19592172046495482, 0.17823919751106954, 0.1964014128904077, 0.19065091089249253, 0.17609193057170947, 0.20752352709256994, 0.21005592580751986, 0.19156780328280854, 0.18710981514719893, 0.127188286000691, 0.1274731816145519, 0.1273532217029506, 0.20379342043205895, 0.19916100182595275, 0.20245354642933078, 0.09005963676154949, 0.22598703322978309, 0.018707274807457708, 0.05648183837318743, 0.0005980584110831799, 0.03393981491195808, 0.0727665752069484, 9.999999999998899e-05, 0.09059835260402849, 0.0008857724061471783, 9.999999999998899e-05, 0.1344983087610775, 0.06324319365491571, 0.1290962839904488, 0.0882756832069197, 0.07619662153533269, 0.04992233173494898, 0.09377267993524185, 0.06286715605314164, 0.07534503953093696, 0.08335028864236427, 0.18957027358651757, 0.04508436394236981, 0.13027577158796233, 0.06679358781939737, 0.06420992956424176, 0.12167241964110431, 0.08926394652540837, 0.06217418919537121, 0.12520507712121176, 0.09353428443180856, 0.10534420218161145, 0.19063215465284788, 0.12630109259900968, 0.13850458878900607, 0.09273113332532634, 0.11848934398112432, 0.22905348029430128, 0.5500350612541859, 0.5058505354295892, 0.5117065329239052, 0.534430072388992, 0.5059189405852529, 0.5377908750090227, 0.5624320720926189, 0.5944147226916083, 0.5248390189236826, 0.1098561197372715, 0.11566116070954102, 0.10817779274934436, 0.1504698969714422, 0.16049077418889623, 0.15291070035520204, 0.09080688637673151, 0.105491070180319, 0.12113343339550353, 0.33161079410396055, 0.36739230406890655, 0.21395772038843752, 0.27214024045040475, 0.36200618755913616, 0.2315574118768533, 0.3134086136533183, 0.13896130382442606, 0.22413821122013233, 0.3613581105237794, 0.4275234158336164, 0.3998613095436251, 0.4864735694745498, 0.3820030870482769, 0.45347990572753527, 0.4634087220791544, 0.4949175542898876, 0.4428163819638029, 0.2836882398596299, 0.2632038311785404, 0.26608055307541567, 0.3699128791791674, 0.24668502824784, 0.32101505638680194, 0.23001345815994445, 0.31664924450607745, 0.23723078070816206, 0.21423305187099217, 0.21178043670969726, 0.21354486097612002, 0.1966158671517666, 0.19318924641557944, 0.2122904974406914, 0.19166379302567027, 0.19978797039088125, 0.19194189058134092, 0.20134078602190564, 0.23184813843645014, 0.19889091918374802, 0.19262477419116109, 0.19676443302185453, 0.22947784394149895, 0.200238543722271, 0.22998808114368818, 0.5083055969806376, 0.16458581540118322, 0.17609010350032972, 0.8464530609783797, 0.8274074916533898, 0.17715274531968628, 0.8227727176749668, 0.8491610429383852, 0.16990122458648838, 0.17382617568396197, 0.6487977916653734, 0.16677640082153156, 0.7392123664412571, 0.7184811602970889, 0.20665362802948528, 0.16292263863680545, 0.15453467779309027, 0.2107149958311646, 0.15461708955055442, 0.1763341221008683, 0.18141652518211082, 0.169762062371005, 0.1860765834315462, 0.17805073799128257, 0.19960281264998325, 0.199100949295278, 0.18202715787630475, 0.19403559539881388, 0.0834178350110093, 0.08006664541689335, 0.08718059612488338, 0.0896962354230516, 0.09928652915644198, 0.09676767749752602, 0.07686885406751298, 0.08561826976442932, 0.09196516569555313]}, "mutation_prompt": null}
{"id": "79f0b676-b0fd-47ba-a6db-dea6c3dd0d98", "solution": "import numpy as np\n\nclass AdaptiveDualStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9 # Crossover probability\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5 # Cognitive learning factor\n        self.c2 = 1.5 # Social learning factor\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound) # Velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.dynamic_learning = True # Dynamic learning rate adjustment\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.dynamic_learning:  # Adaptive learning rates\n                self.F = 0.5 + 0.1 * np.random.rand()  # Adjusted range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Adjusted range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection via competition\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveDualStrategy", "description": "Adaptive Dual Strategy Optimization leveraging dynamic learning rates and competition-based selection to enhance convergence efficiency.", "configspace": "", "generation": 35, "fitness": 0.319497449783617, "feedback": "The algorithm AdaptiveDualStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7939984506682954, 0.7861080309155986, 0.8069060785192363, 0.7926632646070184, 0.7877627276016257, 0.7918580347598643, 0.797879272122874, 0.7842178400824147, 0.7915559821393289, 0.5996820530861964, 0.5764972013660974, 0.5822730020303329, 0.5840229065230935, 0.6003184813404557, 0.5878300262562313, 0.5779411366699247, 0.579861079942269, 0.5299960018497629, 0.14614689651197532, 0.14980172129677571, 0.1479325299040265, 0.1681480504475199, 0.13063785124488148, 0.15013836670372716, 0.14655798533147468, 0.1712177918478328, 0.1428136392206688, 0.10552143281153203, 0.11695744665433816, 0.12331345568972452, 0.10797691831114775, 0.10398105594105689, 0.1307414156370711, 0.1145325938188878, 0.10954223819452369, 0.11070641409902782, 0.9309012601135132, 0.9014882380055055, 0.920451070285981, 0.8938676430175889, 0.9002130913510507, 0.9310444277445111, 0.9123564739275922, 0.9347089821666097, 0.9570733795242419, 0.5528410159854608, 0.5554956163449094, 0.5332482619900262, 0.5542157154568451, 0.5116033457907003, 0.5538978693329613, 0.5276352075673645, 0.497911459927584, 0.554843134941597, 0.22676204981101034, 0.7775392316082261, 0.7892469819277312, 0.27130454819839767, 0.8511208446868539, 0.20648251611191215, 0.2160065092146115, 0.23073784852766444, 0.22763191182820486, 0.21093761537522493, 0.20994300142297062, 0.21804644038679843, 0.22226031694096815, 0.19224932200417577, 0.1896791277822819, 0.22528475258163871, 0.19663980742187603, 0.2026650975949853, 0.20707886882944115, 0.20373418981202285, 0.2107135161675966, 0.20004533549010006, 0.2053456639703064, 0.17960664045391916, 0.23017330436876338, 0.2327977313346168, 0.23202487604013777, 0.01102409525907444, 0.016195322867918027, 0.052015839735382596, 0.02914832428729075, 0.0011863829998121078, 0.03812893177384036, 0.020477960094041237, 0.018506801742263046, 0.09237196697326888, 0.11022589950720907, 0.15905974537369605, 0.12335440482825144, 0.10751022159010193, 0.18101007653765955, 0.09073884395788923, 0.1055233902075624, 0.07901815185180805, 0.12640251425483295, 0.15187770484030372, 0.057311102487579424, 0.2700090772918281, 0.06974992942123859, 0.20978242598574182, 0.06330822169250883, 0.22809662347158244, 0.1235630044900139, 0.21367154932672427, 0.0694981940497097, 0.1871188112332598, 0.15249490389887255, 0.1632080966461794, 0.149748132991656, 0.06600277237743268, 0.10823306045335412, 0.08223639193200394, 0.11080754305058893, 0.5342076608358177, 0.5088993470157329, 0.5793590010122724, 0.5179806126022093, 0.5889641501506335, 0.5754403727103616, 0.560431673129792, 0.5280341996115159, 0.5598212870841843, 0.14956395941611866, 0.10909811037777672, 0.1211815666881243, 0.13052799012865857, 0.10080989339720858, 0.13411790870330154, 0.11810798249880794, 0.11339517978856561, 0.11591212558548103, 0.2161074958310537, 0.27795217753187684, 0.28938920321759065, 0.334566725674072, 0.16227782097368237, 0.4437729548017937, 0.37256644282233153, 0.291957780562189, 0.34967073989097675, 0.43680850091077617, 0.3721205820650597, 0.39762702048821597, 0.48100701735537255, 0.3112891530341889, 0.4569930510034874, 0.4762425816997443, 0.5061057739303612, 0.4861276450559384, 0.1732054644249985, 0.2972594213361397, 0.31934576822418803, 0.3345089588059452, 0.298392214765004, 0.3043838009210488, 0.3471513288959892, 0.34856595621241293, 0.19517002470571287, 0.21680553439850458, 0.22650322315564408, 0.19806737300533095, 0.22773481064002976, 0.21871441104734102, 0.23184767211592705, 0.23160057126008293, 0.22345067799245388, 0.22321719229928094, 0.21493911102243823, 0.21431582488133705, 0.19826386939087215, 0.24189146063404388, 0.1995243799930717, 0.21440637942743257, 0.19745227275478472, 0.19863552974396437, 0.24115625170894084, 0.16698760952648117, 0.18576810358814777, 0.1561577025178672, 0.8618958635166418, 0.8280059453101961, 0.19858635452356088, 0.853057930419743, 0.8719555489733666, 0.8139438354725633, 0.15505310690938057, 0.5567923194219734, 0.726435679049507, 0.2084914456481165, 0.151823536017631, 0.16559706948810404, 0.10427218310958797, 0.20828841669010356, 0.7603357137687812, 0.1757342746717302, 0.18481110477963525, 0.18525127265172392, 0.18208418762996137, 0.1793114555294374, 0.1769031185561769, 0.21860237584134123, 0.18670223302304279, 0.18871110714836148, 0.08588738362755799, 0.11266952762584992, 0.09294640180459424, 0.08673553681743795, 0.1004903519340552, 0.10979445819386058, 0.08430520043366163, 0.08391004566030769, 0.10169554503681544]}, "mutation_prompt": null}
{"id": "d9ea3c22-e1dc-403a-a4cc-3ba4f5c763b6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = 0.5  # Further adjusted Differential weight\n        self.CR = 0.9 # Increased Crossover probability\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.3 + 0.3 * np.random.rand()  # More variability in the range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Slightly more stable range\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            momentum = np.exp(-fitness / np.max(fitness))  # New momentum factor\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = (self.w + momentum) * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Dynamic Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Enhanced Strategy and Momentum Control for robust exploration-exploitation.", "configspace": "", "generation": 36, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (40,) (40,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (40,) (40,5) ')", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {}, "mutation_prompt": null}
{"id": "f70381fb-e496-41ee-bdb2-a2e15673e6e0", "solution": "import numpy as np\n\nclass ImprovedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced population to increase convergence speed\n        self.F = 0.5  # Maintain flexibility in Differential weight\n        self.CR = 0.9 # Increased Crossover probability for diversity\n        self.w = 0.5  # Slightly higher inertia weight to balance exploration\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.7 # Increased emphasis on social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Higher velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Continue dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Broader range for adaptation\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Narrow range for stability\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "ImprovedAdaptiveHyDEPSO", "description": "Improved Adaptive Hybrid Optimization incorporating Differential Evolution and Particle Swarm with Enhanced Dynamic Strategy and Parameter Tuning.", "configspace": "", "generation": 37, "fitness": 0.3208944659652857, "feedback": "The algorithm ImprovedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8213447859930492, 0.8263136724538918, 0.8385145599575141, 0.8209704877604556, 0.8394738376632612, 0.8312933602976232, 0.8244339969687154, 0.8214180738522869, 0.8284504516408524, 0.6679955542361355, 0.6944991430068018, 0.6794509264941568, 0.6849441170902385, 0.6594020931029747, 0.6760511629069623, 0.6901807272539432, 0.6744184890024897, 0.6651475788169106, 0.17617398169273524, 0.12359024093495463, 0.10495652939127254, 0.15472616733063538, 0.12859742058273804, 0.1373781716332949, 0.15232645808295053, 0.16967134417983265, 0.17734739545163614, 0.1545632896423389, 0.16459787000072268, 0.11135413876273248, 0.11489779589524529, 0.1347846376116546, 0.13731547625760265, 0.11527005649167565, 0.10272992599029074, 0.14939142186688492, 0.9628793890456204, 0.9517479397051201, 0.9524110193636588, 0.9588335891767947, 0.9698467963366011, 0.9501665157477285, 0.9579995569198776, 0.9563235588483325, 0.9670281034734413, 0.6275064841264202, 0.6397999676042017, 0.6292468728859925, 0.6333446837100939, 0.6644711235388558, 0.6647337484303277, 0.6286674246740472, 0.5971069199800624, 0.6332404992205696, 0.38001881426552586, 0.17022246049621192, 0.21162684403549392, 0.19404635252323255, 0.37263446430083025, 0.2107231756559217, 0.21567121115714216, 0.37925639170653824, 0.2323119920661002, 0.09881246228392793, 0.27420616165028344, 0.19631372789897628, 0.20954306961525182, 0.2116858922755338, 0.21487567806834573, 0.12881396952949853, 0.23443215962188724, 0.12956929478968227, 0.19874551271213758, 0.21737952058998822, 0.20848211178634757, 0.20607002593463186, 0.3181453196942121, 0.42059883856210023, 0.20799546254937673, 0.2634019907363755, 0.24592314313020613, 0.04729169188983573, 0.09644825808306523, 0.06393068714646144, 0.00011395991976537179, 0.00020037456409194299, 9.999999999998899e-05, 0.018346752981076464, 0.008268831830123835, 0.014076872806867535, 0.13173422702923743, 0.09376606090226947, 0.08198856217377415, 0.12263940219331326, 0.0978019704427725, 0.129175964388218, 0.045250255979865095, 0.07697333231209214, 0.14974333857573763, 0.04740434275771532, 0.12722553714664686, 0.04511363614636599, 0.09682989984654, 0.08898861209411657, 0.14754416077325183, 0.34236108509695484, 0.08099346629187132, 0.06953710404984503, 0.08899184868640642, 0.1367863241095465, 0.08566847623469853, 0.16589349146803556, 0.12466702922223538, 0.2267531519342315, 0.10020265733986455, 0.10692899897014707, 0.08679817117865973, 0.5902366247776722, 0.5592551544987454, 0.5591929872038729, 0.5900397320195645, 0.5906193679867693, 0.5629063524554807, 0.5946880581500371, 0.5356963675266058, 0.5651757642379889, 0.07981832305825898, 0.13683111118656655, 0.1495550225939496, 0.138607488437137, 0.12025959711895828, 0.48233431472682875, 0.1385921513622732, 0.1511760037791371, 0.1443958196899917, 0.20934834772206412, 0.18712506712326438, 0.4296377827652359, 0.2026822259686072, 0.2616627015612141, 0.24485622611708147, 0.19218072258809138, 0.18415555683046914, 0.3664766901064318, 0.3256076270549565, 0.5381194701294536, 0.25987275257532383, 0.47471822590337986, 0.4100407641762205, 0.468267842397894, 0.5527516893219273, 0.6346494272904983, 0.6107316470887102, 0.27885527584801983, 0.24340050970812266, 0.25477069997764745, 0.3516501991813067, 0.33888299320190796, 0.35832021317466933, 0.21652322773701183, 0.2977844226785078, 0.21993891390410625, 0.2146164466556506, 0.21445430307086222, 0.19424257891521257, 0.23742149259664125, 0.2453022093429409, 0.22097166420982717, 0.19525602758619232, 0.21341237265770607, 0.2373941120035057, 0.22019543176171275, 0.19077180933792848, 0.22143530932022426, 0.20527862078054038, 0.7256662201526272, 0.24717968674697788, 0.19216892854426793, 0.21177536352573445, 0.21935464097783608, 0.15710320412149303, 0.19882566787751488, 0.1537040864068424, 0.1985467674334892, 0.8841075142318652, 0.16606153849965, 0.16473405338624414, 0.1613634320795262, 0.17585567394261958, 0.7741154215979429, 0.5496651767930724, 0.15449791335492424, 0.8437213445232, 0.15427318460282713, 0.16802307658909654, 0.10483169504944567, 0.7802173148385445, 0.728565529876049, 0.18296130240635788, 0.17903923093790564, 0.18556423998303717, 0.1946045507172932, 0.20080614591501666, 0.18736885653704427, 0.17881625660445954, 0.1759340131175039, 0.18398408442970937, 0.09088806497487623, 0.08323142430910879, 0.08903927712030002, 0.10116668302088039, 0.09188555548271649, 0.11807045093226787, 0.08431850402145924, 0.07955169573515519, 0.08109891863724605]}, "mutation_prompt": null}
{"id": "644d1250-4ef1-46b5-a885-7c31431ec5ba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diversity\n        self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive differential weight\n        self.CR = 0.8 + 0.1 * np.random.rand()  # Adaptive crossover probability\n        self.w = 0.5  # Adjusted inertia weight for balanced exploration\n        self.c1 = 1.5 # Moderated emphasis on cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Keep dynamic strategy selection\n        self.local_search_prob = 0.1 # Probability of applying local search\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.8 + 0.1 * np.random.rand()\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n                # Stochastic Local Search\n                if np.random.rand() < self.local_search_prob:\n                    local_trial = trial + np.random.uniform(-0.1, 0.1, self.dim)\n                    local_trial_fitness = func(np.clip(local_trial, self.lower_bound, self.upper_bound))\n                    evals += 1\n                    if local_trial_fitness < trial_fitness:\n                        self.population[i] = local_trial\n                        fitness[i] = local_trial_fitness\n                        if local_trial_fitness < self.best_fitness:\n                            self.global_best = local_trial\n                            self.best_fitness = local_trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization with Multi-faceted Strategy Selection using Differential Evolution, Particle Swarm, and Stochastic Local Search for diverse exploration-exploitation coordination.", "configspace": "", "generation": 38, "fitness": 0.28213755100306676, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7360776276103331, 0.7285912890647759, 0.7429748319442495, 0.7254951434380934, 0.7359093587557599, 0.7438158257018788, 0.7049783550812729, 0.7302927691841, 0.7459379631129346, 0.44415682223550357, 0.47703089813749844, 0.4418616615018125, 0.5027205665007937, 0.4899195803679528, 0.49619874185096635, 0.5407746407286428, 0.4867375581188662, 0.5236515169061587, 0.13750915179908607, 0.11154213737027607, 0.09795009737749583, 0.1068301642069982, 0.1114499115294999, 0.13201360826362285, 0.13722439206621206, 0.11986522683346301, 0.1287668160120835, 0.08915402674823614, 0.08716755289317246, 0.09941112458367374, 0.09521450720239755, 0.12477661014723673, 0.11873194387971908, 0.10613947980152283, 0.0884268696462912, 0.08539910429058473, 0.9454128083782136, 0.9478734756710108, 0.9777990311193822, 0.9546023812941637, 0.9529860362803377, 0.9445347463526748, 0.9607144441904865, 0.9437243898069968, 0.9397652092441763, 0.33753679533502223, 0.41931008704164663, 0.35946178725381406, 0.40501399253555315, 0.41215177904809797, 0.37941799568330237, 0.39926659657032837, 0.3648319570742602, 0.3654467354054416, 0.6060696671478021, 0.2233649970358481, 0.21972506321952368, 0.7162217515633159, 0.7012727326673645, 0.25699945838871585, 0.6969282347469106, 0.7267757210323538, 0.646677731391022, 0.1694234027572793, 0.19594137599484374, 0.1921805351507433, 0.16634971895890616, 0.16748541410883222, 0.18605362543193293, 0.19096756543212035, 0.1828640683805859, 0.16375246656366071, 0.21002430594483334, 0.18417305463569977, 0.17897196617484512, 0.1839263002540098, 0.10108272648698424, 0.1921240177703929, 0.21343654591008587, 0.20056850017399108, 0.21444924721290537, 0.012351089124570724, 9.999999999998899e-05, 0.021866323102094576, 0.007659638522329315, 0.029973204957638888, 0.00017347710091020208, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035348916374192796, 0.1026122171990339, 0.09636669689095811, 0.08443057880208127, 0.05332321595292522, 0.030504427904489817, 0.05637962853312106, 0.09110660385084224, 0.08326146814321145, 0.06578643388299987, 0.12718429871453663, 0.04091896645122528, 0.0595779959546997, 0.05980764374815373, 0.06134865965570846, 0.07408445835489552, 0.23993843502181567, 0.15028619730856785, 0.11096067084780392, 0.09298887026474478, 0.12303706285322769, 0.11318155244431505, 0.12271060334965334, 0.04150159096363082, 0.08362299246359739, 0.05824946302177325, 0.1550120314937683, 0.45581073676272044, 0.47111174265177735, 0.5085282302612815, 0.4959097525767917, 0.49957466782360527, 0.49551170577728954, 0.4927015416821846, 0.526501171222121, 0.5009696479284107, 0.09205901135610695, 0.10141331728659586, 0.08748306714031007, 0.09078749610474113, 0.09023851411723227, 0.09195363820323432, 0.08429016160204772, 0.10057383312584611, 0.08909755948185538, 0.16995420713263953, 0.16415601162819826, 0.14556106024628312, 0.15661612659759305, 0.21052148967430007, 0.156713216096798, 0.14958864012548734, 0.14018455204385005, 0.12437689809846342, 0.394353158807185, 0.3898406459175954, 0.3774775326055476, 0.38123473803478214, 0.380723867900038, 0.33879270032979036, 0.4335783193943583, 0.39385631807592614, 0.446535791458297, 0.2945140891194068, 0.23650469831811782, 0.29664889129793315, 0.18751137263452122, 0.2399152977464124, 0.2721631807149041, 0.28109325554938014, 0.3292872564316869, 0.3008120847402326, 0.18965070604359724, 0.2546546143951598, 0.20927071469789493, 0.19077880243089795, 0.20784549866217972, 0.19233880121011082, 0.20549390270737178, 0.18914209123873393, 0.19932977188276624, 0.4481875503951849, 0.2042578324247074, 0.2072553038695042, 0.18701045489359025, 0.36880890606977923, 0.19629168337082825, 0.22818016792897766, 0.2219734839867592, 0.27768240479143014, 0.12855608221251058, 0.16086505177703603, 0.18481290114316196, 0.1651907318225998, 0.7998098081014998, 0.14813051773846198, 0.12982072975153403, 0.7853256128985366, 0.17036061739401942, 0.6399806709802378, 0.3636207488950135, 0.5953774248418573, 0.11104382273425217, 0.2066006276534832, 0.16573151811867626, 0.15462744092054492, 0.5092968918154399, 0.7113829446813016, 0.17669174495044337, 0.18117566516127193, 0.17941051341593706, 0.20745529445618627, 0.19148020485521744, 0.18458569369417832, 0.18358932689267105, 0.17513686735262635, 0.19460549824361695, 0.0860472402561212, 0.08377122487563649, 0.08441798186613303, 0.08518234840552463, 0.07675491531256362, 0.08112739877337027, 0.0820764840979622, 0.08033432512601335, 0.07383652765632231]}, "mutation_prompt": null}
{"id": "a01463c4-9d77-49f7-8414-9663d76df1f6", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Adaptive Differential weight\n        self.CR = 0.9 # Increased Crossover probability\n        self.w = 0.5  # Adaptive Inertia weight\n        self.c1 = 1.5 # Reduced emphasis on cognitive learning for better exploration\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp for stability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.fitness_memory = np.full(self.population_size, np.inf)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Randomize within a range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Hybrid Optimization with Dynamic Strategy and Adaptive Parameters for Enhanced Exploration-Exploitation Harmony.", "configspace": "", "generation": 39, "fitness": 0.32621899372122815, "feedback": "The algorithm AdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8116504718482992, 0.8099681384737613, 0.8148978929323203, 0.8270944709571375, 0.8013356893970793, 0.8289932402074389, 0.8106849152084431, 0.7968342555405349, 0.8093014501858043, 0.6311463617068589, 0.6463638019432656, 0.6048956042666804, 0.6096272734037385, 0.6530451650387175, 0.6374494358659242, 0.6195988485771231, 0.6320268903323609, 0.6409658812050663, 0.1447603014941704, 0.13519916563264, 0.13704689057310138, 0.13383331806076781, 0.6064696637670826, 0.40804302161028483, 0.13259582554619997, 0.1399318995644797, 0.12784162094638596, 0.13678270138309923, 0.12997996833660475, 0.10514196322995573, 0.10388059363969915, 0.128296957170277, 0.13413346796991932, 0.10575632729902518, 0.1070717015514625, 0.10552915819457254, 0.9615576801104821, 0.9617871628626411, 0.9523625086927714, 0.9560449196462277, 0.9455323943686611, 0.9552688002678829, 0.9407876357168038, 0.9596287316745481, 0.9713340063006476, 0.5898975133494446, 0.5835824935429451, 0.5656537924722398, 0.5916494810382544, 0.6012323682508569, 0.56478139649707, 0.5625930593868478, 0.577762651533486, 0.5470465101384518, 0.22437130176987863, 0.7290245772331121, 0.35277490206036677, 0.8332425255397152, 0.8114222217213641, 0.21014898850668373, 0.38245752685880174, 0.23403207806041093, 0.3865791422453809, 0.11974272514995299, 0.1503505969958021, 0.217751417435604, 0.19883570412277662, 0.21104400773961096, 0.21202250531841949, 0.1983033211938442, 0.23524481622959748, 0.20469839672594892, 0.1272306199537796, 0.21283655451022387, 0.12498897234728157, 0.1267913496924712, 0.23178053988481995, 0.24503569477188147, 0.25670123597399463, 0.26596376996868465, 0.22551996026188248, 0.03467810991394127, 0.035040283346475354, 9.999999999998899e-05, 0.029045122212171592, 0.01323489045990156, 0.05527111662049322, 9.999999999998899e-05, 0.010283710203964458, 0.01090439099949303, 0.07184505233327743, 0.09458240664338935, 0.08778810203370013, 0.0015570361922804254, 0.08140618846595771, 0.09721471858103337, 0.10499560322643042, 0.05097295129687207, 0.11357864360295755, 0.13503508560285626, 0.04482995340347229, 0.032591871239605275, 0.07024280754561218, 0.09681877391956173, 0.2855540015627549, 0.13407277551751773, 0.08366853495352355, 0.06630690991447041, 0.17475823810412783, 0.10656602259389836, 0.04621058662871258, 0.2580104585736148, 0.08921614962118873, 0.05462559569307979, 0.13364180660820513, 0.09465613337700218, 0.13380320145347246, 0.5141150087124877, 0.5837261242944095, 0.606826473135212, 0.5529453948396248, 0.6197203615027524, 0.5269006972792045, 0.5833548018644674, 0.5452939598729256, 0.5716583894001077, 0.1115493562823141, 0.13862242421540583, 0.11833028208931196, 0.16595606524971407, 0.11654898829798621, 0.13523842256685947, 0.13015443861324927, 0.11127295081823885, 0.10907627330358316, 0.5292189320327125, 0.4173095699865653, 0.19077920616071975, 0.5253119073635326, 0.31429560140477675, 0.15774855282543498, 0.41294965518294324, 0.45510753245535485, 0.3482486017571149, 0.2783554311385019, 0.24911054190896798, 0.402611146433387, 0.5222067626090232, 0.48132367990951674, 0.5564377246857586, 0.5403938891416653, 0.5933867856561275, 0.5559081883914061, 0.24833839448759365, 0.2534015632175406, 0.27988020617533715, 0.3445524666795591, 0.25094853131120043, 0.29152879665012577, 0.3846212978201874, 0.41527824681640746, 0.37497197486094125, 0.23422462516951104, 0.2088792258601947, 0.21977374870068245, 0.1828286773521458, 0.21006603701954996, 0.19384660857762082, 0.2072839654652695, 0.20706795527420307, 0.2064597649224874, 0.22513911522069707, 0.2382800668880507, 0.19085877696332776, 0.6293416683862794, 0.24269194128957539, 0.21954311332472487, 0.6439065165353139, 0.19616302604061908, 0.2047748000800872, 0.1667967174845888, 0.8567987335761119, 0.11195203245424856, 0.8804305970513827, 0.16203186681992288, 0.15101467236718358, 0.18715727415596373, 0.17698269229513386, 0.16583236489357112, 0.7324322628245077, 0.20838277635838387, 0.20555538075652413, 0.16704756355642625, 0.16715843041091882, 0.747635225169607, 0.2115479790505842, 0.2094069855225391, 0.7927660613128316, 0.183547709068555, 0.1903694873208478, 0.1761839322826434, 0.18033407600957674, 0.17664764892169693, 0.1813978138255925, 0.18043204753294062, 0.17811685243116904, 0.18352460051564967, 0.093698194753837, 0.08079244663899221, 0.08725240295700387, 0.08609640937032725, 0.08812464250794305, 0.08987593150020401, 0.09321700062560123, 0.0919133383484203, 0.08542313701539495]}, "mutation_prompt": null}
{"id": "8a3e03ab-ddd3-4fdd-91dc-e8240aa6f708", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased population size\n        self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive Differential weight\n        self.CR = 0.8  # Crossover probability slightly adjusted\n        self.w = 0.5  # Dynamically adjusted Inertia weight\n        self.c1 = 2.0  # Higher cognitive component for individual learning\n        self.c2 = 1.5  # Moderate social component\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin(np.full(self.population_size, float('inf')))]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.75 + 0.2 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n                \n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Augmented Hybrid Optimization utilizing Adaptive Differential Evolution and Particle Swarm with Enhanced Strategy and Learning for Superior Convergence.", "configspace": "", "generation": 40, "fitness": 0.2848138659955108, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.6942334612089616, 0.7191069092901894, 0.6986346985519886, 0.7151633128994139, 0.6936844031273972, 0.7278941518479367, 0.7034882584693056, 0.7192298836445472, 0.7084832979764099, 0.4192330717720689, 0.3686482712378979, 0.42761734178437105, 0.4333594786218792, 0.4845528571254124, 0.4207754593351716, 0.42741918899465303, 0.4103107804297771, 0.42584217724404894, 0.13845127802521784, 0.21528575845440456, 0.10721977581063524, 0.12974412555993298, 0.11787483227979334, 0.11466121440041166, 0.15807705919551007, 0.14776351267916665, 0.1136098939582918, 0.11026820607172216, 0.12359858166164073, 0.10202219306467175, 0.10204309350424079, 0.09669590886267565, 0.11241628635273515, 0.12136818573129893, 0.1218053481143857, 0.10513004506517121, 0.9489486387656683, 0.9329746754706134, 0.9451085721678041, 0.9255459287309753, 0.9414532376661632, 0.9285056203134595, 0.9112549061284442, 0.939336818102109, 0.9192009237585246, 0.3047491310713335, 0.3610351332484095, 0.3682913554222649, 0.3310205934835164, 0.39817267956369096, 0.3424384415630438, 0.3614135519442814, 0.35240532921237844, 0.33646180263956615, 0.6155471939082724, 0.3544054940418013, 0.5491964829455254, 0.6395970515424869, 0.21055205915716924, 0.6529470905268484, 0.3353086471370377, 0.704443502012385, 0.7009322248503298, 0.16456389898162338, 0.22796102842433652, 0.14146208491628076, 0.20289969248577222, 0.244935731429491, 0.12107297043070664, 0.17169499110535802, 0.18873984812575817, 0.18003671457985038, 0.18673532214154653, 0.18101025209345323, 0.18225427202886813, 0.21994999500507606, 0.18479842590960993, 0.186797373432404, 0.127088814677341, 0.0914627927996371, 0.21228505011065735, 0.07161731462265819, 0.002161031798884494, 0.01569007429900282, 0.010839295733812482, 9.999999999998899e-05, 0.0013472562170876445, 9.999999999998899e-05, 0.036554298124063855, 0.07211659355087285, 0.14440474311586915, 0.09752290785163498, 0.1355458286699026, 0.07305739426567925, 0.06625626293583242, 0.10190636548405052, 0.11505305688601619, 0.07525614868981012, 0.11183362805521369, 0.023506323310755084, 0.0955857440862552, 0.03741211788345333, 0.04688314404842675, 0.09239940513313938, 0.10463523675117226, 0.11819345923419444, 0.0778785043454514, 0.04498802015969072, 0.11082264317380108, 0.0912178901661782, 0.13895521820192802, 0.17421159693724186, 0.13432041218868784, 0.0995235281808462, 0.15040677930853164, 0.12222269587504031, 0.07657128966137461, 0.5018599689749281, 0.4717845183178915, 0.5027349043781919, 0.4708580179031018, 0.4808353527069066, 0.4796649221217475, 0.48468521963844224, 0.467416175758813, 0.4761761552852902, 0.1145390730375615, 0.09828697676792475, 0.08474016549260288, 0.11448703065270527, 0.08511736639797596, 0.10252228341660807, 0.10407738497531105, 0.08761024276123208, 0.09932054648613298, 0.24627553544230307, 0.13217163721220238, 0.1697412104610374, 0.15824243672933958, 0.15482842505835193, 0.16499259781882358, 0.15604874200527608, 0.17163781264090516, 0.21699983787063315, 0.3630703061174344, 0.34312669595532896, 0.36850333913070765, 0.3613736320435539, 0.31803913124091765, 0.38920043616420585, 0.38655111443628565, 0.3923934909516563, 0.3806299386438099, 0.299021015889002, 0.2646558551774545, 0.2525533551550888, 0.26588295282523644, 0.2673202047373705, 0.3083231164134661, 0.2164666506803311, 0.2713793828561186, 0.20957700713332883, 0.20656594303189957, 0.21533547681087095, 0.183537347582868, 0.19277525902578085, 0.19943894290126807, 0.21740261994654553, 0.22599932694142422, 0.20869854743619665, 0.2181678268205739, 0.3104808578403313, 0.34759641998913837, 0.31831329485818116, 0.3921273900884822, 0.20252489094401582, 0.2323323412967988, 0.22430251050672456, 0.21324965557569286, 0.18934851240809858, 0.16365967535093928, 0.16339798882198198, 0.7742164784897807, 0.8077261981006774, 0.8303004858770023, 0.1513010826633696, 0.7850798551615131, 0.16975235160523205, 0.7766343132241027, 0.16708569603258294, 0.15123951828845605, 0.20728012078712477, 0.1658581823762395, 0.20715707455925825, 0.4674465472033289, 0.657082513042425, 0.6471803358776542, 0.15425398290246461, 0.1817643698467618, 0.19488089698744793, 0.1687009065921411, 0.18696559163436433, 0.16981658246114073, 0.1917204698305346, 0.20742185342764186, 0.1822485122664097, 0.1864591019734344, 0.09281616500224676, 0.0840238322831337, 0.08330665051175079, 0.08525425446862833, 0.07953837344757453, 0.10679967109950417, 0.11338204455798828, 0.08761271191949649, 0.08270648113580026]}, "mutation_prompt": null}
{"id": "df7ab980-0934-46cc-a019-725e7c2a2abe", "solution": "import numpy as np\n\nclass DynamicHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased population size for better diversity\n        self.F = 0.5  # Balanced Differential weight\n        self.CR = 0.9 # Increased Crossover probability for more mixing\n        self.w = 0.3  # Further decreased Inertia weight for faster convergence\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound) # Decreased velocity clamp for stability\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Expanded randomization range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Slightly higher minimum crossover rate\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "DynamicHyDEPSO", "description": "Dynamic Hybrid Optimization leveraging Adaptive Differential Evolution and Particle Swarm with Reinforced Strategy Adjustment for enhanced performance.", "configspace": "", "generation": 41, "fitness": 0.3195343624757551, "feedback": "The algorithm DynamicHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8515307969371857, 0.8530479157753099, 0.8505713653509299, 0.8553200479390384, 0.8571225578490944, 0.8491997817393924, 0.8485207518696221, 0.8397516492457652, 0.8282740485853695, 0.712820193441514, 0.6440407606002025, 0.7150268001002942, 0.6644546248928191, 0.712113710558155, 0.723946371756238, 0.7191665866009, 0.6228363178711521, 0.5952337188127296, 0.15154026100901297, 0.10908317064189654, 0.09058703549130098, 0.1070579587463526, 0.09413735771037823, 0.11168531181514996, 0.13808998923673388, 0.13901547521256963, 0.14984784759350367, 0.09883948164964218, 0.0971377929528271, 0.09356982801130542, 0.08666975423126555, 0.17558534869327636, 0.09147598005997604, 0.09980796142451565, 0.10166645053981216, 0.11970372980549471, 0.9030143688780845, 0.8970099796313766, 0.8949892995674741, 0.8447081049764119, 0.8710207101612776, 0.8777425001677913, 0.8862533639433338, 0.9266248248152118, 0.9151026650098179, 0.6703501732722935, 0.6545000852560856, 0.6409503666004748, 0.6336478301902231, 0.7044470480253313, 0.6877363767932158, 0.6402222966527877, 0.6281798794174611, 0.684649585048998, 0.8736015156352673, 0.8743489618321343, 0.3807395030353693, 0.2750242880164243, 0.36608565171631713, 0.20916190342445684, 0.18804876411779992, 0.8565263503651062, 0.21953558883447377, 0.16783155855878884, 0.11410859495683912, 0.205651032290727, 0.2105506848146993, 0.2028492105462587, 0.19455936878495872, 0.17053804079861767, 0.16145019667244165, 0.20117910771787106, 0.18898634542433446, 0.12376563685697806, 0.1278522255108936, 0.16325843237762216, 0.17671015243488963, 0.16436906607826018, 0.22820545844997986, 0.13091310346954466, 0.1966992169769568, 0.059612217333489204, 9.999999999998899e-05, 0.014077130049507502, 0.04954098177282462, 0.12477504944267115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02652990057167004, 0.15922958548678212, 0.08251192614285863, 0.10120592320154154, 0.07762662457714409, 0.07971283343647051, 0.0902392908550892, 0.11519964370211688, 0.17624986223162686, 0.10994957909320147, 0.14407438335902756, 0.09497130736218262, 0.33591979771339797, 0.1373064976489965, 0.20279614634505239, 0.08246259572802372, 0.08504211820860785, 0.09698543167676965, 0.12381568439330004, 0.09930022704459285, 0.30213558579764555, 0.18922476325589843, 0.08394808062044745, 0.17855212143962695, 0.19824608272803468, 0.10095399343128242, 0.27777142709171176, 0.09963313569027321, 0.57218426224471, 0.57666150683568, 0.56562808825299, 0.5216497913046207, 0.5313634052985696, 0.5217453010039006, 0.5274122312562354, 0.5642712667434306, 0.546029858599028, 0.10671596808894812, 0.13299827164286904, 0.11097464148058223, 0.1367267481611072, 0.09386489388743324, 0.12353677904105298, 0.14820698689611655, 0.11979628437681078, 0.10307901294673616, 0.1778838005864707, 0.5847499765725928, 0.29702944134948717, 0.21124671271212014, 0.5007237948844792, 0.3282494064156296, 0.20424525605577304, 0.2898517341025115, 0.5243931367247896, 0.3075609460484555, 0.45365778960303116, 0.3058680948174439, 0.2670008816618451, 0.2734536021860037, 0.6080821358334946, 0.2637854891476802, 0.38387361059778, 0.6426633533226249, 0.28057982918616486, 0.18477488951608956, 0.29277769705236123, 0.1458663247725197, 0.28407899051335794, 0.2320877797750852, 0.45048516058115307, 0.2983589470031317, 0.23900462068116302, 0.22188295690289983, 0.21465556227988936, 0.22876857938550443, 0.2284607019717131, 0.22198874642481725, 0.2412729609193086, 0.19934541368010605, 0.21249637636499386, 0.2354239616875896, 0.19512507061326778, 0.2241558960455894, 0.17677919795246488, 0.20266800174826405, 0.22421010014665843, 0.1818672454024789, 0.20676322102663158, 0.18797744141527717, 0.18381925053678694, 0.1851447381908068, 0.18564996597137884, 0.15682375767405587, 0.892451744161835, 0.8801262966200304, 0.19860480105866352, 0.13013220263596126, 0.8827080853029341, 0.17587047042549364, 0.7030094437243035, 0.15473122875552325, 0.8752100035546797, 0.20930859288353398, 0.2039681879726163, 0.166476940639798, 0.10398300392605886, 0.20749450755652343, 0.10419590313344906, 0.17985447236547858, 0.19360040505371168, 0.19973423571192894, 0.17344436160527732, 0.1881368688134657, 0.18588326020075174, 0.18343526677147448, 0.18108725766507427, 0.19227366627984388, 0.09685628155639825, 0.13679559483199044, 0.09084254818128135, 0.09839915249996234, 0.08434533641918551, 0.08952316638681967, 0.0919874515400334, 0.08531790483284751, 0.09699772530337158]}, "mutation_prompt": null}
{"id": "b6f9f980-2c72-4c05-ae12-5f57ffb48d3d", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = 0.5 + 0.3 * np.random.rand()  # Adaptive DE weight\n        self.CR = 0.8 + 0.1 * np.random.rand() # Adaptive crossover probability\n        self.w = 0.5  # Slightly increased Inertia weight\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Moderated velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.adaptive_strategy = True # Enable multi-strategy adaptation\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.adaptive_strategy:  # Dynamic adaptation\n                self.F = 0.4 + 0.4 * np.random.rand()  # Randomize within a wider range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Optimization using Multi-Strategy Adaptation with Dynamic Learning Rates for Improved Convergence.", "configspace": "", "generation": 42, "fitness": 0.31623963028430824, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8505504005775965, 0.8386785294698207, 0.8427403101608942, 0.855581155058303, 0.8315588320976776, 0.8489129749496701, 0.8366771261408112, 0.8466948555635609, 0.8501168707787757, 0.6991148224989048, 0.6860792596150302, 0.679319519635023, 0.706566145309653, 0.7041452988994634, 0.6973040881119867, 0.7245819498345698, 0.706627551119464, 0.7068013090103533, 0.14396557774063234, 0.12460973178669432, 0.09743505428511612, 0.15371804251848475, 0.12965534799726997, 0.10721327290053417, 0.15115468675253374, 0.14205557507481203, 0.1726878895475107, 0.14501848296947917, 0.14418994628221082, 0.14764718544703592, 0.1031830319353747, 0.12426983006186343, 0.12516003716271484, 0.09895361002895553, 0.11674894608095288, 0.14254572705285795, 0.9575952862455785, 0.9702284262217789, 0.9599780020137523, 0.9586237740436924, 0.976731219215854, 0.9704734305821945, 0.9627571515936922, 0.9647020328165533, 0.9607287691406973, 0.6374217281023813, 0.6475255694512447, 0.6522681613724302, 0.6625070765666337, 0.6713895987649032, 0.6467876823560128, 0.6466028328506779, 0.613661196964075, 0.6688360950396535, 0.21267951288731657, 0.2236440522944455, 0.8665625848835758, 0.27814718023020446, 0.8204673414049409, 0.2743478095127957, 0.23096827808853992, 0.23552795778851687, 0.8616202201145764, 0.19986450826487112, 0.19052322842543212, 0.1927022202627826, 0.2261617639464385, 0.12717830816358777, 0.12792323189689903, 0.2084934343056294, 0.1924919680394196, 0.20319771282458732, 0.11907995351391587, 0.20682687937408373, 0.2132729685200324, 0.2351186977021379, 0.19951277669907164, 0.22163081942006857, 0.23751383469427267, 0.10201668019778265, 0.2490984443259734, 0.06375178014864102, 0.021594659923649617, 0.03817017770091502, 0.04726059921582959, 0.003156680951361124, 0.044441502493630436, 0.0027780239730486045, 0.053966322628294816, 9.999999999998899e-05, 0.07518136309464718, 0.10288641816041166, 0.03426670068733417, 0.0389249838262864, 0.018640665235459153, 0.07277313938549723, 0.13408696143632937, 0.10431895330449537, 0.042564335811741016, 0.24716932736215935, 0.04741590379618632, 0.03255861035828622, 0.07472865021552189, 0.07325085596595204, 0.07642898894943206, 0.14815745708150463, 0.19051414796133304, 0.10910257002174617, 0.11424875468495121, 0.11207269708872991, 0.37860977896574677, 0.21742965380931223, 0.1511738643244076, 0.18775637588797722, 0.10847181429573305, 0.07937790325108196, 0.16815452342227077, 0.5871725977523699, 0.5719990130259538, 0.5606845532709902, 0.5651047132721839, 0.5502620579535809, 0.5354441773019636, 0.5723689941802654, 0.5713887881367836, 0.5875311935995733, 0.09642178813331115, 0.10901586186805745, 0.10387582692192521, 0.1718601533820815, 0.11283959746927519, 0.13432741062197961, 0.12150504857317701, 0.11034099672402609, 0.11724979324644103, 0.3141404100605679, 0.1357414871189334, 0.4560750386165454, 0.3832362026646938, 0.19163457657182603, 0.20884541997205908, 0.2292674211030239, 0.3258229223564377, 0.27173389990617425, 0.27449514508780315, 0.271073347680144, 0.4110178224052069, 0.616467334723748, 0.2697287961681579, 0.5524645914619293, 0.3727831302687209, 0.5414524764979795, 0.6029288853130461, 0.3264199511569089, 0.22103679263027376, 0.24502195793613069, 0.37919574986942384, 0.3697154193527654, 0.22840264350269446, 0.1891525339354353, 0.20518786026040847, 0.32066922633226247, 0.21902597919337818, 0.1870475036564715, 0.20034189466890617, 0.24562204136713972, 0.2114631756064388, 0.24735865089588938, 0.22916429967022067, 0.20884220525847963, 0.19735938219683058, 0.20876367949250618, 0.18689931793037406, 0.19558088518995909, 0.2505395582616302, 0.21931375660032604, 0.19348910748184078, 0.20812676809550312, 0.1923347666866949, 0.22308955745328918, 0.1685285888382938, 0.20851408820289807, 0.8733496198265613, 0.14689319563777337, 0.1775868714607044, 0.14875047038799272, 0.17683382973064177, 0.1718729959862183, 0.8930377991926829, 0.2096955605201104, 0.20882953332569865, 0.21044302962909078, 0.15381336761089204, 0.7501772543281161, 0.1689568249673643, 0.15533861974117424, 0.21279282138488964, 0.165156012752537, 0.1853335366932749, 0.1872329596328901, 0.19497201817602539, 0.22326163735127724, 0.18363428801156856, 0.19426618086084424, 0.17119180275114976, 0.16932391053474416, 0.1817102624499265, 0.09717528531094999, 0.08869692535560347, 0.08459931949537536, 0.09999934115108611, 0.0861268506580587, 0.08831288193343567, 0.0870502802376022, 0.09068260826542496, 0.09301490992439065]}, "mutation_prompt": null}
{"id": "f6609e40-a41a-492d-a142-ade07288563a", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Adaptive Differential weight\n        self.CR = 0.8  # Crossover probability\n        self.w = 0.5  # Inertia weight\n        self.c1 = 1.5  # Cognitive learning factor\n        self.c2 = 1.7  # Social learning factor\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.75 + 0.25 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridDEPSO", "description": "Enhanced Diversity and Inertia Strategy with Self-Adaptive Parameters for Robust Convergence in Hybrid Differential Evolution and Particle Swarm Optimization.", "configspace": "", "generation": 43, "fitness": 0.32015243874845106, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.776332455792299, 0.7771852758870219, 0.7933782626401972, 0.8003612676901398, 0.7679855712968463, 0.7798893162837836, 0.8007261941101351, 0.7770595375971796, 0.781194381646134, 0.5819532949764248, 0.5559237829084422, 0.5651033646766352, 0.5438120266502602, 0.575412071401542, 0.572185846808236, 0.5830506963403377, 0.59889333631082, 0.5537853510017382, 0.1594626772695783, 0.16622486332078656, 0.13106465942927736, 0.14302427757241654, 0.1460522918610253, 0.1651990328104579, 0.15973653980554936, 0.1494900211581628, 0.15308532298970368, 0.08402187743054401, 0.10553170262915579, 0.14777630050071855, 0.11947900802273903, 0.11629141210109284, 0.11013859985096064, 0.129570901070018, 0.13254497828099443, 0.11755412376008023, 0.9485992584264324, 0.9441822816669458, 0.9562422130185481, 0.9580703799051825, 0.9613787595830962, 0.959908940020787, 0.9476736673610585, 0.9619329840227235, 0.9559060475196132, 0.5326106685279076, 0.43477549805776217, 0.48028065611064363, 0.40615119418274725, 0.4631374604148496, 0.47530305927433913, 0.47680608874498354, 0.45340558154501753, 0.47734750722587915, 0.7984466065036775, 0.7497904414322754, 0.6702512435555421, 0.26943182992607473, 0.19143788975524467, 0.1902985653656022, 0.8111018922846384, 0.7670179657665808, 0.7693186401955077, 0.19709708481787613, 0.20387412376244352, 0.1788450622697514, 0.18636000619080906, 0.12667943009913218, 0.17731182441718663, 0.19497813519342255, 0.21379888647257717, 0.20365118273273286, 0.2025396480943551, 0.28046793343876764, 0.11812832025928854, 0.2051964450116548, 0.20199055239235664, 0.2150517348848764, 0.2176765068737313, 0.2357047281814304, 0.22409009177392336, 0.005935023876264878, 0.007664977334147838, 0.09142538848714998, 9.999999999998899e-05, 0.03985062234615944, 0.03841117715351661, 0.12373785879285693, 0.02636424578497132, 0.05571794047845324, 0.05900706411500434, 0.06790205099619395, 0.08955771955424097, 0.05343701665574829, 0.06884281972205841, 0.0714706508692663, 0.07561429238496398, 0.1533894997037769, 0.07376268153177334, 0.08302974911377836, 0.28467395643650695, 0.03309082249291606, 0.1310585642313099, 0.06612989236146782, 0.08290683508980068, 0.1602409097098505, 0.11446391200244921, 0.09251865767394352, 0.171078660897786, 0.13917431564122418, 0.24907700067067584, 0.16440171931319014, 0.28997359088343966, 0.23381182905432574, 0.1293020861882278, 0.2063430942556782, 0.09688898675921942, 0.4875336372386907, 0.5314942528534983, 0.5180064707909362, 0.5520595224557263, 0.5062850079982374, 0.5667532452604567, 0.5520499972586379, 0.5529707156808001, 0.5168197997189061, 0.11848826428568249, 0.11015995164289327, 0.12869706928706182, 0.10717051705288738, 0.10276134090661215, 0.11629367405356494, 0.07961173970762903, 0.12949013350802885, 0.09990786586091305, 0.2977650778876241, 0.256949699902682, 0.25573726490392057, 0.2941298175597168, 0.16367863258004622, 0.37574492382490376, 0.3283863832411683, 0.1606366781916797, 0.43338526217131357, 0.4300069725115466, 0.2714637778535911, 0.45270211961144957, 0.39966958343732306, 0.43395367229822035, 0.3850120167329325, 0.478547246609735, 0.44595406337488197, 0.4408256201891352, 0.28565033629310976, 0.2565946483299203, 0.2126502542426919, 0.25756322156607636, 0.2474093469615497, 0.27561201951260794, 0.29509797364753576, 0.3226161528747348, 0.2131548992574127, 0.21387196962454114, 0.2020409163181034, 0.26217752652407966, 0.21039602320587047, 0.1886381017710963, 0.20582414352001388, 0.2236098230110738, 0.19843592548843358, 0.1976375449194102, 0.24099075011594107, 0.44656345813720677, 0.2059979474240491, 0.21263233492566302, 0.4494350453729079, 0.23193975810582212, 0.2120364686972671, 0.2128118585512917, 0.21581394085996064, 0.18686663204952825, 0.18473894720814754, 0.15227102314023866, 0.8629880804817235, 0.8380171718538141, 0.16543498115738986, 0.18763043770039722, 0.1609606465587078, 0.8279753717784823, 0.7310432649217748, 0.211145457041381, 0.72734839325248, 0.1673511693959474, 0.1665631961832269, 0.6590030727832645, 0.6837621886128827, 0.7490614631454675, 0.20965180050978416, 0.18586235808161422, 0.17804771325164415, 0.18938228877191632, 0.1751003390911794, 0.1868178566528662, 0.18747394452494204, 0.2039689752880045, 0.17190516627358465, 0.18229082401456287, 0.09384414052110901, 0.09212019928114856, 0.0809100677447313, 0.08728034104961024, 0.08841849904312271, 0.08730707815415029, 0.0910495287114873, 0.09558305953151502, 0.08036143049844846]}, "mutation_prompt": null}
{"id": "54040937-f82b-4007-b13e-cd387d0df7a6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.2 * np.random.rand()  # Dynamic Differential weight\n        self.CR = 0.75 + 0.1 * np.random.rand() # Dynamic Crossover probability\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.8 # Further emphasis on cognitive learning\n        self.c2 = 1.5 # Increased social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Dynamic strategy remains enabled\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.75 + 0.1 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice([idx for idx in range(self.population_size) if idx != i], 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Reinforced Dynamic Strategy and Diversity Maintenance.", "configspace": "", "generation": 44, "fitness": 0.3061508818165414, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7861768097504138, 0.7785755236446035, 0.7738868017844174, 0.7788050547853329, 0.7687924254733878, 0.7951135756175516, 0.7743703022694133, 0.7781643340227353, 0.7793015514290065, 0.5295365574893758, 0.5499648381964908, 0.5707425699687539, 0.5748810651165848, 0.5395294413726137, 0.5613374756972934, 0.5988989561007321, 0.59724328066934, 0.561111905689428, 0.13089392163637237, 0.14695046002874168, 0.13066906579486914, 0.10867864072540045, 0.16367267651509154, 0.38289642857564254, 0.1438166247298579, 0.13391164177240733, 0.1332876000717863, 0.1346072632245907, 0.10778583263801123, 0.13856392437448262, 0.13979963050911715, 0.10864991472266261, 0.10308143252726454, 0.10212277700375583, 0.13959212147335898, 0.13136260942671818, 0.9664906194028863, 0.9562962877816843, 0.9642220506460755, 0.9550293132212264, 0.9351179093653119, 0.9721307514469822, 0.96105847883284, 0.9541805131797265, 0.9550968719869328, 0.48945205111641843, 0.4509999441427849, 0.48179840324560275, 0.48503798357482597, 0.5160822795029285, 0.4837207686991478, 0.45967283872833564, 0.4463806463103345, 0.4576713905289205, 0.22182816257466398, 0.5534847404121682, 0.756435857768627, 0.26847714613788853, 0.1907331757552121, 0.6955079726668632, 0.501893259216093, 0.33881309661600256, 0.7703554227303676, 0.24046635790012905, 0.1282138579536477, 0.19473266227556962, 0.1822431464218338, 0.19397536329460752, 0.1956853939276787, 0.1937903426194686, 0.1940866752749022, 0.16164048708509615, 0.20374868288763281, 0.22094772330145307, 0.17321785314382454, 0.22401863621169993, 0.12868918390041095, 0.20609226815747594, 0.22646277322804242, 0.22002592738569215, 0.22057662737934658, 0.028812924584271205, 0.01674600453064834, 0.013204810041784865, 0.0013628130401474037, 0.01676199238158005, 9.999999999998899e-05, 0.03156159878053855, 0.039795628274030825, 0.005343876636168865, 0.11627263097675333, 0.110064301603786, 0.04316784447949917, 0.1047417253025329, 0.05461803387775399, 0.054463287152786366, 0.14482203841888897, 0.09488918082975983, 0.10741184484592103, 0.15044067108255388, 0.11988478035790218, 0.03157016596418094, 0.08107125433614515, 0.07860774585581187, 0.09171853954884557, 0.06772625186572423, 0.11836733930969034, 0.09261304085754729, 0.11484886648890458, 0.13738571702240465, 0.16781041698920274, 0.2257111992151304, 0.08330454832704781, 0.19303296388527114, 0.10041789714405003, 0.18664553673258455, 0.24226243402436487, 0.5588094569049167, 0.4877619657716602, 0.5122168804446836, 0.5083409744122183, 0.5152957937677936, 0.5453985106563768, 0.5380826183726393, 0.5465786686447789, 0.5438575074829536, 0.1658835230394059, 0.07877129225640167, 0.09662800813894301, 0.11189691059524653, 0.11955476913799379, 0.13869267430060395, 0.11775501517486775, 0.1379934470865828, 0.13134084009315738, 0.12675101561566482, 0.19338506001503675, 0.13626929392656462, 0.17790642518020816, 0.15036824497290657, 0.18895821721241357, 0.21378202268863034, 0.2112122449671322, 0.1472429652067394, 0.4045598076276786, 0.3861931883414642, 0.41942387910382284, 0.4571590011269443, 0.4620783287312321, 0.39250357349274934, 0.45146971805500447, 0.4454892036175876, 0.500709557730582, 0.21448106708698067, 0.23588663126982934, 0.29589581678502863, 0.28918604718372865, 0.26325612533608944, 0.24329333302247025, 0.3404198008329168, 0.3894160397396166, 0.27897696308613684, 0.23003586295761314, 0.20932517557408947, 0.2003806136941868, 0.23537828290315232, 0.2330434375625614, 0.23288510135662155, 0.1954381176665757, 0.23468439707504862, 0.18824570682674668, 0.5508074952933335, 0.23158219289652893, 0.21758825886948074, 0.1885267531470982, 0.18277538784768999, 0.21328177852781605, 0.1981998232357911, 0.22766339183797657, 0.49684886283664786, 0.7601895422400364, 0.16597445805909739, 0.18039525906878584, 0.16429123322597483, 0.1970051492418644, 0.17272023441039075, 0.8416476286654601, 0.8320873065809344, 0.13536166099927016, 0.15463230398040073, 0.7294422176865868, 0.69571672596151, 0.2081404159666601, 0.20946932012157649, 0.2087157986198963, 0.12727361322536912, 0.7422023342562918, 0.15499750491123465, 0.1794568308394623, 0.18291531738631983, 0.18700336480283308, 0.19090653753190767, 0.17400075943470183, 0.18670382527371376, 0.18128847099581546, 0.2086733196078394, 0.19692558000733773, 0.08229142368594344, 0.09836529301182961, 0.08197258954330044, 0.0911336493595829, 0.08622160985143346, 0.08258928188300219, 0.08823087512803218, 0.08492559293089308, 0.08598353800112035]}, "mutation_prompt": null}
{"id": "84e552f8-24d5-4282-b34c-06dd1c60c222", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = 0.55  # Slightly decreased Differential weight for stability\n        self.CR = 0.9  # Increased Crossover probability for diversity\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.6 # Fine-tuned cognitive learning\n        self.c2 = 1.4 # Balanced social learning\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)  # Reduced velocity clamp for control\n        self.dynamic_mutation_prob = 0.1  # Probability for adaptive mutation\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection and mutation\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Randomize within a narrower range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Randomize within a narrower range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Adaptive Mutation\n                if np.random.rand() < self.dynamic_mutation_prob:\n                    mutation_vector = np.random.uniform(-0.1, 0.1, self.dim)\n                    trial = np.clip(trial + mutation_vector, self.lower_bound, self.upper_bound)\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization integrating Differential Evolution, Particle Swarm, and Adaptive Mutation for balanced exploration-exploitation and faster convergence.", "configspace": "", "generation": 45, "fitness": 0.31808218999020643, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8577621245486851, 0.840417140514575, 0.8534656606619144, 0.8480018910049139, 0.8566173477205017, 0.8554045869713265, 0.8511343165000256, 0.8481674977536832, 0.852627475483519, 0.7046017300262886, 0.6910353482586282, 0.7188108034890605, 0.7125301968084846, 0.6783359676106722, 0.7056628483018595, 0.6958125854990642, 0.6230276342838761, 0.6706510418917396, 0.1497557849708986, 0.17450734591048744, 0.14980517586910824, 0.14139299282826034, 0.11765337252342811, 0.15164547833802755, 0.16094625739125934, 0.14115424316925962, 0.14871058259018932, 0.1260930026306034, 0.14523725204794868, 0.15016532570615604, 0.14288131493737077, 0.0552715011259346, 0.10674403035937774, 0.1326171388756051, 0.1255318195371803, 0.14280845541639775, 0.9576973930749525, 0.9394068359767973, 0.9383743070635313, 0.9526301329150696, 0.8932782656866662, 0.9537021269861043, 0.9560732771080227, 0.9623509671476508, 0.9462739448579369, 0.6892642268724523, 0.6466058065334828, 0.6257767844672838, 0.6801135012205346, 0.6627759900528987, 0.623947670400296, 0.6637419202361311, 0.6502817151574793, 0.6026513169853388, 0.2237137702674583, 0.37471424794344144, 0.8111429792056438, 0.27749145174749623, 0.2186849998127438, 0.21767759761840444, 0.8194000269543948, 0.8255943421891409, 0.2332383012558341, 0.22573663258819843, 0.21046430462593868, 0.12924016958683515, 0.21325789089057268, 0.20442404188912733, 0.20681373162240002, 0.26918345097695295, 0.13006375413828575, 0.21252073211023115, 0.22706531242848593, 0.11962430126560952, 0.17291768157106657, 0.22322842575602553, 0.2115514626405034, 0.23370240788714514, 0.24319656271411727, 0.22949952718385191, 0.24305724398580097, 0.09974279708024192, 0.07156718858617439, 9.999999999998899e-05, 0.05838048170259247, 9.999999999998899e-05, 0.02053683678230156, 0.20044746662950563, 0.014648784707554707, 0.04018270893603526, 0.15160277341255568, 0.07282861072860647, 0.15693716618322284, 0.030620564563123898, 0.16239857422322768, 0.06625058891387492, 0.09122368342562481, 0.10626092683729671, 0.13277878230920692, 0.10005480476627693, 0.03433960946415204, 0.047135776983384337, 0.0939636715095894, 0.11810030284125839, 0.13601592218341318, 0.24332403978184847, 0.09535709820102023, 0.11991634429183629, 0.1477411504774926, 0.07647627140014868, 0.08913176474339912, 0.25784206500746654, 0.1740549203458328, 0.13364072896851742, 0.08190881472283362, 0.1620008357513758, 0.13422731609595862, 0.5384108914286589, 0.5921136756513784, 0.5985438367449609, 0.5637960441714596, 0.614461817952668, 0.5235667712172167, 0.5746901733268224, 0.5652203511784342, 0.5535439177662231, 0.10966760675491039, 0.1305387039026087, 0.10949029111434283, 0.16987654415308207, 0.14295314051134045, 0.13080076634776072, 0.13003887790334012, 0.15493998783489482, 0.14051127025992005, 0.18887515254025722, 0.18872453777708176, 0.32931157111903775, 0.395514717728788, 0.2637426787079702, 0.23605027023239333, 0.18735654033078553, 0.23954349233738825, 0.3178524815843251, 0.548612371172136, 0.42955872372504855, 0.5077123587603739, 0.4984244595908188, 0.24093617571081638, 0.4033690858824065, 0.6652151141599087, 0.6148754344170341, 0.5956228209737114, 0.24097734336193544, 0.27425969121300187, 0.3072136936888873, 0.20914812121383208, 0.3795859851154283, 0.1861316629795583, 0.2568219564296953, 0.3139928526009136, 0.3086730312396506, 0.208773408646297, 0.21737810415968184, 0.2369510845682522, 0.2254749676343718, 0.231377846402952, 0.2528004508265017, 0.2089261801137, 0.22616143456244509, 0.24495241208466, 0.21016357175041278, 0.21854762268505468, 0.19636938970821705, 0.19824739762427168, 0.21737720439966712, 0.19919060913707476, 0.20436992872084225, 0.20747854303036906, 0.20535762756529974, 0.1605924363089083, 0.16771592312446215, 0.20880448078242386, 0.14549697922067606, 0.15088607456531355, 0.1516823448894956, 0.15276500213137356, 0.1359925528706728, 0.1530859220949522, 0.1555912136986226, 0.11325346382997814, 0.6547310794358538, 0.20976102740481706, 0.20965096296400265, 0.15495026574549942, 0.6088105267737456, 0.21091165124080125, 0.7801163769821654, 0.20538846590241577, 0.18131401423427362, 0.1896689348037276, 0.19074777115574637, 0.19768389566200772, 0.2066874065811658, 0.19436608970986757, 0.1725618482025657, 0.19493658170017303, 0.09040883342867712, 0.09123376677076145, 0.07512855079710412, 0.08480353018044973, 0.07977248014504623, 0.07904071292930259, 0.08998496279051504, 0.08406126446140438, 0.09102269022075538]}, "mutation_prompt": null}
{"id": "8ccfc157-f35e-45d8-b917-b7891f48769b", "solution": "import numpy as np\n\nclass EnhancedHyDEPAM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased to enhance diversity\n        self.F_base = 0.5\n        self.CR_base = 0.8\n        self.w = 0.3  # Further decreased inertia for faster convergence\n        self.c1 = 1.5 # Adjusted cognitive influence\n        self.c2 = 1.5 # Balanced social influence\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Further increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = self.F_base + 0.2 * np.random.rand()\n                self.CR = self.CR_base + 0.2 * np.random.rand()\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation with adaptive strategy\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPAM", "description": "Enhanced Hybrid Optimization combining Differential Evolution, Particle Swarm, and Adaptive Mutation for robust global search and local refinement.", "configspace": "", "generation": 46, "fitness": 0.3193149461222247, "feedback": "The algorithm EnhancedHyDEPAM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8340005127223936, 0.833208293989943, 0.8390439134304107, 0.8368865576556566, 0.832964150842756, 0.8287023513960948, 0.8210435686933126, 0.8292882133362028, 0.8282278229002284, 0.6434678157610342, 0.6824073982353965, 0.6636566914769011, 0.6722573003724784, 0.6887542236752703, 0.6527073582512, 0.6849713391520504, 0.6690596653529866, 0.670067568523903, 0.1410966612145791, 0.16803200318327038, 0.14844154528182574, 0.13376159311829683, 0.17604452693513595, 0.15328854612412157, 0.17131971587064765, 0.13461700073264582, 0.14466388229844673, 0.1370792347853792, 0.10438789532079173, 0.10475579971253723, 0.12961716743255325, 0.10374025500920236, 0.1250558728494614, 0.12169898416725633, 0.09675407006663395, 0.12340208219195992, 0.9548706527534303, 0.9204422705817137, 0.9444477763755976, 0.9441198220646192, 0.9182130785385293, 0.9390382192301713, 0.9251599270501314, 0.9942870780073477, 0.9471388039195395, 0.5287466861862655, 0.643729547651274, 0.5997970867584191, 0.6038481276929775, 0.5496070280879308, 0.637490024986166, 0.5747472433633736, 0.5259457378159789, 0.5832387443217029, 0.223904412123054, 0.38196337557092586, 0.7813739625303927, 0.2733319513034712, 0.2049262605576826, 0.20744648770180663, 0.13611919363126812, 0.23151443010949813, 0.3526203761312453, 0.1950627581350034, 0.2312094935886978, 0.12819633604211955, 0.12133891391715113, 0.20033247898472117, 0.1274613174052709, 0.21254583519785242, 0.1202746961394685, 0.21939230658757602, 0.18909617528341993, 0.1300628635057023, 0.21047514487790098, 0.2329428590139484, 0.20376478899892791, 0.18910460122950157, 0.19521580310898612, 0.12066344791469252, 0.2371448953862738, 0.05772593297890982, 0.021938985782416265, 0.0761467235431903, 0.06271699030857325, 0.007337594168699391, 0.031475255238384126, 0.055514263918561846, 0.04013932592395397, 0.08260577672720903, 0.10208269543466086, 0.10099251375693563, 0.0808321549519464, 0.09540478576734546, 0.08574228349809343, 0.13336113710257447, 0.1277061447654131, 0.07477481591929813, 0.037274051114100204, 0.1635985891354268, 0.22917428808371332, 0.060402908730811555, 0.07140161786369259, 0.2609789157341289, 0.0698988208028164, 0.09730479560109229, 0.1451676683087909, 0.14151019828951994, 0.09207582779350032, 0.1539626738799028, 0.1280176559752616, 0.104089664650025, 0.10310216590988419, 0.2102075126918841, 0.18095939567656938, 0.056869743913061765, 0.12272027598039115, 0.55107689844652, 0.58241710622131, 0.6076375968691374, 0.5782016963509103, 0.5855093016197992, 0.5694408477831843, 0.5383469236121357, 0.585757341260192, 0.5502928772765519, 0.11535881869761289, 0.12966171288645478, 0.12093832703290286, 0.11114091523286485, 0.14582332043106494, 0.1146338354806723, 0.11135817552678196, 0.13299269785667112, 0.09618035209620412, 0.14151325917442192, 0.23544922484133335, 0.2207441308060457, 0.18817718207565104, 0.5225827388983348, 0.19284015965953094, 0.5192177251147354, 0.1549404092166693, 0.24093564485728813, 0.5549889106280432, 0.5241511806676331, 0.4265348708705611, 0.4325003715306559, 0.5474213699974186, 0.46210815240920433, 0.5884341187036446, 0.5527959385940087, 0.5888271861295273, 0.2380902090728243, 0.33819774443706363, 0.23436098497393953, 0.2034081785813907, 0.22306038769862824, 0.34652821064521067, 0.2389699243025163, 0.3162825021925596, 0.22242013378430092, 0.23004495868271824, 0.23382872450027414, 0.22164451490299397, 0.24497843813687648, 0.20697399599981625, 0.22633818371848669, 0.24514320671500844, 0.23144788437437547, 0.21705171745726315, 0.6487306409551685, 0.19894229847210632, 0.2421023590158795, 0.18886388271928423, 0.20403296956589312, 0.1835147669673698, 0.21164707273665606, 0.23815511302393644, 0.21617444648791884, 0.8823029497099947, 0.20726222133806071, 0.18646443401165447, 0.12494121722886864, 0.16644153896855696, 0.19878179771470805, 0.8204489200338844, 0.15025517818321243, 0.8116131042684661, 0.15520491583396756, 0.2077849497980695, 0.7964290120902351, 0.209558673760744, 0.20702725487559215, 0.20083485348324426, 0.10429204931089409, 0.7309624804936137, 0.7752528949949853, 0.195832805401862, 0.18160074722190322, 0.19237283074826084, 0.18818458803955496, 0.1846360675713915, 0.19330477880131802, 0.17687718461654078, 0.18614708481157372, 0.20314879099869754, 0.09136187098726678, 0.08624656865669877, 0.09432088661941385, 0.08427137058707579, 0.13507334530664594, 0.10562078278495812, 0.09022854980523132, 0.09245773569424431, 0.0965804063275797]}, "mutation_prompt": null}
{"id": "df646ca8-47cc-4983-ab0d-bb7ec668f51f", "solution": "import numpy as np\n\nclass EnhancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Adjusted population size\n        self.F = 0.5 + np.random.rand() * 0.2  # Dynamic Differential weight\n        self.CR = 0.7 + np.random.rand() * 0.3  # Dynamic Crossover probability\n        self.w = 0.3 + np.random.rand() * 0.2  # Dynamic Inertia weight\n        self.c1 = 1.5  # Balanced cognitive learning\n        self.c2 = 1.5  # Balanced social learning\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                self.F = 0.5 + 0.2 * np.random.rand()  # Randomize Differential weight within a range\n                self.CR = 0.6 + 0.4 * np.random.rand()  # Randomize Crossover probability\n\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHyDEPSO", "description": "Enhanced Hybrid Metaheuristic combining Differential Evolution, Particle Swarm, and Adaptive Learning Rates for robust optimization.", "configspace": "", "generation": 47, "fitness": 0.3328814005758583, "feedback": "The algorithm EnhancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8752971768713654, 0.8853222247694608, 0.8771908594562883, 0.857894728194991, 0.8823688052126815, 0.8735554487334898, 0.8538106960558429, 0.8750758272290932, 0.8819650265154982, 0.7390931540277808, 0.7668370184099608, 0.7513646844047668, 0.7440982744065499, 0.747178193373747, 0.7251840249800137, 0.7267447570817849, 0.7738766963014054, 0.7594627581315534, 0.1498909005993022, 0.17911187354190172, 0.17788833914154023, 0.13896243364546312, 0.1804848835175915, 0.12860385177119837, 0.13972918876958662, 0.14397968507920655, 0.14354412364129332, 0.10610046770346548, 0.11367746065850681, 0.09874828073676545, 0.12421032415772604, 0.11405633432065698, 0.15717361933413887, 0.10974816913489227, 0.13554282239093596, 0.11400231868519695, 0.9374859667675673, 0.9319400807107386, 0.9497144288373014, 0.9277420631177528, 0.9528673600621805, 0.9362282533258122, 0.9561245709993713, 0.9569196861129234, 0.9319132257550441, 0.715051064567039, 0.7001253330430798, 0.6892914599599915, 0.6827955154214103, 0.7598636307449562, 0.7281326045046399, 0.6532936273362879, 0.7166070082535567, 0.6988225216613575, 0.38409503586140914, 0.2223554216858713, 0.22547558524126698, 0.37273407593707064, 0.2757950953960413, 0.27626496671121126, 0.23410182143917946, 0.2212362876341769, 0.9034351581340709, 0.13161866815868817, 0.24867721037046775, 0.19820833605211918, 0.27335342921119177, 0.38466201047129056, 0.1958301611841653, 0.21367033407952363, 0.17950213335514742, 0.20216786903477257, 0.21241041659329307, 0.18310766844552495, 0.11799843266813403, 0.1301774079639072, 0.19569811215917154, 0.22412717234910584, 0.13367491901770467, 0.22007740965583833, 0.22873749542624378, 0.013256248216628963, 0.0483227221235315, 0.013244050536535545, 0.04167117231853712, 0.030790933564662226, 0.06469318516600686, 0.025754707070172245, 0.00895533073588961, 0.0028552700576103263, 0.0710829385273517, 0.03477417195576782, 0.02179679895805986, 0.13480459646967158, 0.04362011384745945, 0.041093702245368346, 0.10765983306521099, 0.10254476163775339, 0.09679861797177236, 0.25256659220731204, 0.0948793335864353, 0.05028679108022838, 0.11894410732492378, 0.09686927412484514, 0.07657903814714828, 0.1483981595114615, 0.22935711548387006, 0.23441638363773454, 0.144856286618269, 0.019241188219822458, 0.24748875038044427, 0.1584890034931301, 0.19140684376983808, 0.1544265487153107, 0.09397032610287193, 0.09664267257598536, 0.36029873083582775, 0.5415880225915851, 0.5312634268020839, 0.5758992071744953, 0.6241874362871149, 0.5720104467327111, 0.5609802936314516, 0.5930693312336883, 0.5763179607867316, 0.5936683336977754, 0.13989470506639445, 0.15439214314748329, 0.10575380624359898, 0.09850922419708918, 0.1792789748254925, 0.16788734120917304, 0.12194449451959422, 0.12216876252822562, 0.17669330381897141, 0.5185690698168666, 0.25451990323007656, 0.29265270122200426, 0.2978329932761755, 0.4714446361546635, 0.31456559541305174, 0.22709518476169366, 0.2068013765099187, 0.22037047706751933, 0.47323776257057915, 0.465262008889039, 0.38697852359442875, 0.3645184781642402, 0.4772116512343293, 0.3984565186337766, 0.5974237634778143, 0.5823932223166195, 0.5123453565837977, 0.35169730762538143, 0.22540101705341908, 0.16329800148584728, 0.26899147123799627, 0.18177844801040444, 0.24133543714938288, 0.3395126147908061, 0.19907004891460012, 0.46013843305749924, 0.2410001536119023, 0.2101168277663532, 0.26025841924156046, 0.24275648610562983, 0.18131029061617232, 0.2072697580592845, 0.22496357556809143, 0.20229333089587642, 0.21564107251696307, 0.17770930195734602, 0.19597597031316483, 0.19736373510270855, 0.2030746068357111, 0.2493811456068099, 0.24718455477972145, 0.18315392743247372, 0.20610658355742806, 0.1764441746135491, 0.18548330882264696, 0.8999226702110888, 0.8772985364375402, 0.16904819398716264, 0.16551333620570563, 0.16876804930037137, 0.899771370040552, 0.1612295821440124, 0.13070286012804555, 0.8262730979858532, 0.15337274054316552, 0.7780562356233465, 0.5280261652660537, 0.1547627811862421, 0.2088121069861687, 0.7832598989008632, 0.15503196729584467, 0.10566903323102084, 0.17997275603653162, 0.18613666775963178, 0.1748122618596375, 0.19081790891935035, 0.17662228084105558, 0.18364404429910142, 0.19295827444419245, 0.1797515602958214, 0.20550132554698264, 0.10621903610543337, 0.09528382770296717, 0.07920085262051269, 0.08192812782543912, 0.09485186112564281, 0.08362106084561505, 0.09036002766809648, 0.07914771910593188, 0.0814150990847391]}, "mutation_prompt": null}
{"id": "5e3bdc93-e448-4ac1-866d-a2eebd033bbf", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced population size for faster convergence\n        self.F = 0.5  # Adjusted Differential weight\n        self.CR = 0.9 # Increased Crossover probability for more mixing\n        self.w = 0.3  # Further reduced Inertia weight\n        self.c1 = 2.0 # Increased cognitive learning factor\n        self.c2 = 1.5 # Slightly increased social learning\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Decreased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Maintain dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic and np.random.rand() < 0.3:  # Probabilistic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Narrower range\n                self.CR = 0.8 + 0.1 * np.random.rand()  # Slightly narrower range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO_Refined", "description": "A Hybrid Optimization blending Adaptive Differential Evolution and Particle Swarm with a Probabilistic Strategy Adjustment for enhanced search efficiency.", "configspace": "", "generation": 48, "fitness": 0.340886340747275, "feedback": "The algorithm AdaptiveHyDEPSO_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8649080357906114, 0.881319337939756, 0.8644809782868087, 0.8572360195033155, 0.8583770669458822, 0.8773378581649104, 0.8775048878101535, 0.8761922300798988, 0.8569081157595944, 0.7367264835649268, 0.7589692009885797, 0.7627489285785292, 0.7348705648010632, 0.7381071623244302, 0.7368810774896675, 0.7735572262458186, 0.7550510733571628, 0.7408107889447242, 0.13028117605469558, 0.15132666121100125, 0.14176305073959683, 0.17054242153513155, 0.1529436957932061, 0.15427282036516787, 0.09066766873245946, 0.13624506215044474, 0.17125755304741797, 0.13602105278285614, 0.1082204139272982, 0.13030208609357308, 0.1128945025231689, 0.13268177104114642, 0.08721214409325784, 0.11653731374785825, 0.11146908404032363, 0.12154674457410497, 0.9297904136407538, 0.9593060525177941, 0.913832986598419, 0.9136546005452851, 0.9205767735750185, 0.912970483552859, 0.9304520230596552, 0.9017906678247739, 0.9250679576199619, 0.6427925982802987, 0.6305969515310694, 0.6851266736280495, 0.6643414497697033, 0.7035350379095295, 0.5970386531798333, 0.666450162393747, 0.6560066260165771, 0.6313412131240982, 0.2258733471311547, 0.8276803907063772, 0.8680171352044229, 0.2771256204826176, 0.27974911950060555, 0.35101634804826776, 0.7352442244204865, 0.2348501944126118, 0.8347585301845275, 0.30448206430936486, 0.19423528954752478, 0.1232552334341328, 0.12953766875039874, 0.20120376538347307, 0.21980237994793317, 0.20171344803688895, 0.1808435816639209, 0.22100949222160837, 0.22656353004273944, 0.21003662883414287, 0.23137293614957521, 0.23298608501076856, 0.19352499146997038, 0.13351931125611005, 0.2502794723831605, 0.19752541461395223, 0.22116698110581623, 9.999999999998899e-05, 0.0334226806323642, 0.02815531127886206, 0.0346380710264792, 0.08942686905988373, 0.0016716992692711319, 9.999999999998899e-05, 9.999999999998899e-05, 0.13018840702604428, 0.13863947354232953, 0.20147160707218725, 0.10099573803623896, 0.0707600188060411, 0.07243793477583027, 0.08779505897632878, 0.09798533158794476, 0.15938120862604555, 0.12298856931114766, 0.089658952072037, 0.04953371225257741, 0.18206761659271187, 0.07755191568902153, 0.10877504230207347, 0.13420342321552858, 0.08546092728092392, 0.34853505080153513, 0.1710462996034059, 0.1651422865622364, 0.12795670427485273, 0.3909744049849524, 0.15846204274724773, 0.039506315987554275, 0.10016057595158001, 0.18173938999549166, 0.36788074724145736, 0.13003713772529224, 0.5360609154556807, 0.583229643472597, 0.5580331892602205, 0.5283537005360146, 0.5584357724047776, 0.5851134758871817, 0.573841315614481, 0.5813101302426271, 0.5732051644213336, 0.1470545297340239, 0.12377474876760586, 0.611629581467864, 0.13528488997243893, 0.13576406142388475, 0.12085345122783875, 0.0997151692640067, 0.11264009023070953, 0.09043849508963431, 0.34733030390345654, 0.18874822086527587, 0.4979990732035324, 0.2629487369502952, 0.2099762351687967, 0.28105313475537974, 0.23724073775195642, 0.27881037803832665, 0.22471073152168475, 0.45888307918812, 0.6085402889069125, 0.49608986552379386, 0.5524139433333488, 0.518597344712922, 0.6648473930341399, 0.6005354866562411, 0.5741608754703127, 0.5835690545117046, 0.3036026012293721, 0.27668253966772616, 0.37370574002340706, 0.2679007902474583, 0.2766664838579551, 0.3235494871597925, 0.48550002944333437, 0.2452718897676447, 0.34454776765426554, 0.22949871626287455, 0.21547820934922401, 0.2220551157118409, 0.20292306222483836, 0.20009200939121674, 0.20915980171657578, 0.20847273575945668, 0.25468774360638335, 0.25078118409241235, 0.1919963430787549, 0.22249673961755356, 0.20120411187050546, 0.24740789803499552, 0.19842502991811084, 0.2213200880990076, 0.2194445834198544, 0.20124496284808335, 0.18357969850484968, 0.8913422302357052, 0.18590693048570162, 0.8984660260383174, 0.9038173316582598, 0.1664525308265351, 0.17074226958042948, 0.1997192549154464, 0.9159826805715546, 0.14753638888946718, 0.6512963390388324, 0.16894686156464922, 0.12613785032623748, 0.20694031914406308, 0.20992438028110583, 0.1672244967666171, 0.10456297767446199, 0.21017827002529765, 0.10443158926224838, 0.1929100811916472, 0.20649856897402674, 0.18608217914670588, 0.18293105981665259, 0.18822410156245306, 0.18032956975077774, 0.20263415829042575, 0.18711236918441454, 0.1784209484876339, 0.08696002071078801, 0.08662333407426981, 0.09043157326933104, 0.0982282132408242, 0.0815926189002687, 0.08845943370896836, 0.0893312294908688, 0.09068052111990232, 0.08633503032388234]}, "mutation_prompt": null}
{"id": "45a7ce1e-f2a6-4ec1-81ce-96a436b02812", "solution": "import numpy as np\n\nclass SynergisticEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = 0.5  # Adaptive Differential weight\n        self.CR = 0.8 # Increased Crossover probability\n        self.w = 0.5  # Inertia weight for balance between exploration-exploitation\n        self.c1 = 2.0 # Emphasis on cognitive learning\n        self.c2 = 1.5 # Emphasis on social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Randomize within a wider range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Diversity preservation\n            diversity_threshold = 0.1\n            if np.std(fitness) < diversity_threshold:\n                self.population += np.random.uniform(-0.1, 0.1, self.population.shape)\n\n        return self.global_best, self.best_fitness", "name": "SynergisticEvolutionaryOptimizer", "description": "Synergistic Evolutionary Optimization combining Adaptive Differential Evolution and Particle Swarm with Enhanced Diversity Preservation to tackle diverse optimization landscapes.", "configspace": "", "generation": 49, "fitness": 0.2502667463319977, "feedback": "The algorithm SynergisticEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.43788323835560017, 0.43649456662879627, 0.43010850962837954, 0.4475024594374266, 0.40638303948728616, 0.44977472914691075, 0.4725763869062727, 0.43007061966264315, 0.45358450819874807, 0.3216259338987094, 0.3294912083806437, 0.271554244304517, 0.2831351920721594, 0.3468283813406695, 0.3402341240780279, 0.2696367801901183, 0.33824943832648835, 0.3133367550723156, 0.15793319468759748, 0.1445916497893318, 0.13452436229276643, 0.1433996787863009, 0.13885468266951972, 0.1274366463187967, 0.1305847473317815, 0.14439598683408839, 0.1508109482045451, 0.16256234037670547, 0.10746429604161911, 0.12015887048906793, 0.13450362402223015, 0.12748456896143512, 0.10345267679548575, 0.1268407604855989, 0.15853397776653055, 0.10389270976605225, 0.9635768250665331, 0.9664848815182346, 0.9450180745932006, 0.958293890031092, 0.9622651004654732, 0.9698647822229866, 0.9572086170676766, 0.9624443477324159, 0.9671472388294876, 0.31228296621212825, 0.28940976754444714, 0.29591953212763933, 0.3349419963332856, 0.3505641888500216, 0.3200971045837053, 0.3310514198313338, 0.29916546443538405, 0.30499460927558575, 0.37062232520006233, 0.5716536597057302, 0.2188880797253362, 0.3111003924248916, 0.5639905053607175, 0.35636035109754516, 0.2267730434368862, 0.37184932124806835, 0.31494829078430586, 0.18326982971717165, 0.1632384961818678, 0.1802728302745974, 0.12653413973883998, 0.1298927866408507, 0.1271482157620527, 0.16237726714814382, 0.16922674906057855, 0.17891997813104932, 0.20444957903288286, 0.1803372312556778, 0.14318589270558968, 0.17794202083730837, 0.18455186290039427, 0.12434790601175705, 0.1913103002738329, 0.19407427338291705, 0.19149148871581323, 0.07369292018884666, 0.0025678514929039498, 0.057649437417442106, 0.06179549643227733, 0.02132461941747621, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002943070599256137, 9.999999999998899e-05, 0.0825846674122408, 0.06831160257806335, 0.07678711829087459, 0.10422030797034787, 0.07894104786537459, 0.09622989827386097, 0.0946155432361222, 0.06678123930008384, 0.0899733200332874, 0.09046806248625305, 0.04488147386990027, 0.020467592872402407, 0.07097339631070643, 0.12805548559626534, 0.08915595642733065, 0.08105477283709384, 0.17148682557086925, 0.066397941226366, 0.11386506571056032, 0.059235484618661016, 0.09988068095131353, 0.12693833466245474, 0.15608201992993875, 0.11289131130392238, 0.11966284942536476, 0.07277964874716636, 0.08281287615991928, 0.42145678761524563, 0.393627978759194, 0.40295398433353213, 0.385308513097414, 0.4038764148706596, 0.4158352503983297, 0.41941361744105254, 0.4123205015640219, 0.4051835833492512, 0.12619865900366345, 0.1243649163028433, 0.11062329586164232, 0.11194221509856017, 0.12237021725236119, 0.13376384134756758, 0.11317525262502659, 0.14447999534797928, 0.12473972458567772, 0.2805251843056583, 0.23571514417046247, 0.18874561886941132, 0.15450848615436807, 0.16580594443906171, 0.3132980895414146, 0.2400447233210301, 0.2303750953926944, 0.14688959244288757, 0.30443961543713094, 0.3000862264454943, 0.29163464918734805, 0.30108022266772194, 0.24674295372933652, 0.2802539055737755, 0.2866145780728231, 0.2946914152304534, 0.30880689424947716, 0.22426175937079174, 0.2473522606931251, 0.2564241849807509, 0.2553291322550897, 0.2501012356658139, 0.21854107449097004, 0.2630764628449046, 0.27111717614615727, 0.25995034483992785, 0.21238545683536492, 0.2063351633074818, 0.24773298715154402, 0.20846141007373675, 0.20374573126755646, 0.20742064277626737, 0.18707617197695958, 0.22603049313731305, 0.1923673659198215, 0.2961291245556624, 0.21580024685367216, 0.22823743531583085, 0.19436575805769374, 0.23158346849677014, 0.3377177461919587, 0.21648489474818178, 0.19431250217314788, 0.22700272277297884, 0.1570960570179204, 0.19797205783830518, 0.18559764010045843, 0.6324120115152281, 0.6184686793640422, 0.6404821494786699, 0.16018345450652904, 0.6220863847429207, 0.17555311008752505, 0.15485224185550528, 0.20987459173419443, 0.570140332073177, 0.5759245108434259, 0.5157124072667589, 0.16755166119703757, 0.10496430022547154, 0.501353714309689, 0.09366522728510296, 0.1809205419164882, 0.17817303210133162, 0.1746974152212062, 0.19440379998877833, 0.20739245748458668, 0.17991700293946544, 0.1794419567639105, 0.1991134153873313, 0.18193247324276363, 0.09056016163160985, 0.08539917933186425, 0.09407048221435965, 0.08836729842476565, 0.09151263324142278, 0.082400103363931, 0.0876007545887556, 0.0861762470848445, 0.08186906447179265]}, "mutation_prompt": null}
{"id": "7739b4c2-6684-4e41-ac66-982b032427e9", "solution": "import numpy as np\n\nclass SynergisticEvoPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.F = 0.5 + 0.1 * np.random.rand()  # Adaptive Differential weight\n        self.CR = 0.7 + 0.1 * np.random.rand() # Adaptive Crossover probability\n        self.w = 0.5  # Inertia weight for balanced convergence\n        self.c1 = 1.5 # Cognitive learning factor\n        self.c2 = 1.5 # Social learning factor\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.2 * np.random.rand()\n                self.CR = 0.6 + 0.1 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "SynergisticEvoPSO", "description": "Synergistic Evolutionary Algorithm leveraging Dual Strategy Mutation and Adaptive PSO for dynamic optimization control.", "configspace": "", "generation": 50, "fitness": 0.31341915266968506, "feedback": "The algorithm SynergisticEvoPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7991315414320445, 0.7900243587368846, 0.7942770806124833, 0.7802921197293244, 0.7952693952566697, 0.8098903090638065, 0.7808195493896293, 0.7902819596323654, 0.8065996331605427, 0.544097558147363, 0.5734947420349531, 0.5772237601385546, 0.5747871635161417, 0.6230498132484514, 0.5756013271528102, 0.5831492679889039, 0.5673776244910095, 0.592677424799321, 0.47386377336789554, 0.1684290530772221, 0.3552811811969664, 0.145855194105995, 0.4392179145391145, 0.17068292487939385, 0.14386668580523676, 0.13551882033312634, 0.16992985765386348, 0.16202524755249903, 0.14766938322395562, 0.09898373059111887, 0.15082536037938044, 0.1407258707412149, 0.10831458740762845, 0.12796177815395893, 0.17295815296414274, 0.15459330329747323, 0.9352078026356984, 0.9359097370451186, 0.9369218717610318, 0.8985909985626976, 0.9563982630573575, 0.9437080426796323, 0.9425077921505594, 0.9344303853993557, 0.9243204248846092, 0.5301084189581257, 0.5221175399725859, 0.5183040725709034, 0.5406088264043248, 0.5395886120034112, 0.558334225901818, 0.5141547419919942, 0.5259312560601148, 0.5220242546878728, 0.16697325821055586, 0.3722044817059702, 0.3626099161170969, 0.21418904870567024, 0.20926353188960256, 0.2669979289756981, 0.17361169831168222, 0.81140445682298, 0.7970730858964346, 0.12849807006080083, 0.18731127814788984, 0.20095484928588891, 0.20435227477545304, 0.17762324236963856, 0.22611627125236078, 0.21985866082578265, 0.20458176789584992, 0.12473881453339741, 0.20500865163914128, 0.20988654900129877, 0.13001597918884578, 0.324564149786997, 0.12839377685605746, 0.2125208334380716, 0.2303042741071123, 0.22763020367415798, 0.21781492358775656, 0.0050511393335589405, 0.018480229068046028, 0.05541187297986394, 9.999999999998899e-05, 9.999999999998899e-05, 0.035117670857938044, 0.00031525344377481, 0.046150103312590396, 0.007785876477038989, 0.03465756831636302, 0.08774918216392236, 0.16049228374139968, 0.07912036885812501, 0.015537746093764349, 0.04614902950799227, 0.07513648305428355, 0.12646758057858554, 0.07291397378337094, 0.18681604104346283, 0.10679595857264434, 0.15234445422931453, 0.06508983070016416, 0.2056655280137485, 0.1200883725483034, 0.08860678617955853, 0.08812741525156775, 0.23751364353380955, 0.13714275048122238, 0.23526681745537315, 0.15554207548149201, 0.16302254724319187, 0.1478877030502379, 0.05231906571352718, 0.07896914185898607, 0.07768049426305801, 0.20082328913001768, 0.5393837444709486, 0.4969143418733337, 0.5249065873924754, 0.5259232529823643, 0.5046194074033724, 0.5546186230628771, 0.5269898652631503, 0.5368656990974523, 0.5545787188264929, 0.11006622082815687, 0.14081143928094786, 0.11271179985366109, 0.08652936329138106, 0.13818234801887996, 0.13404154374147748, 0.17151678003425008, 0.14992826544875404, 0.16881779466148306, 0.15433453840591393, 0.2464681421866428, 0.18289446590787184, 0.21559304448416572, 0.14348926955171537, 0.3389580457303656, 0.18020490227872576, 0.19277064524917353, 0.3963475574321731, 0.37666403933784853, 0.4682861649434856, 0.4807847408920889, 0.2566501302746156, 0.4573237869035458, 0.39999564254512, 0.4945554925660619, 0.5093701886284219, 0.4612591038433984, 0.3228464479391583, 0.3435367656883629, 0.4068815292211092, 0.23772620244283438, 0.28439143268372413, 0.2638841336237703, 0.2156149418979164, 0.3405468423201963, 0.2802315598570819, 0.21135013785247247, 0.21786344424477877, 0.19865539071344118, 0.22378583165320665, 0.20954204187788406, 0.20854690440119006, 0.20047407320662913, 0.19625028876021355, 0.21706393642093158, 0.19880770026134964, 0.6662439996312226, 0.21652280599861984, 0.23842957237528795, 0.2173867885423596, 0.21586098379726604, 0.21359729763595414, 0.5257564736678724, 0.2051039381045473, 0.18591823025953635, 0.1853084897289864, 0.18479042099860188, 0.16395856770780992, 0.16472131113442245, 0.16911217304860005, 0.15169295366942226, 0.830511826781086, 0.8816038949642686, 0.599731314167471, 0.07310965179823159, 0.20972914018833821, 0.8116329610053417, 0.7825911150794915, 0.20871675809116863, 0.2099782000529864, 0.16850800878512695, 0.7250739930144607, 0.18554184353862524, 0.1786675577401271, 0.18005004795163293, 0.19359334636040781, 0.20109865062361099, 0.18645952589686998, 0.18352011970508775, 0.1730206391572383, 0.18318086111495513, 0.09118740158637506, 0.08657695680576705, 0.09668410023610707, 0.07942010091009066, 0.09346047897646093, 0.08361780569266097, 0.09005898933729983, 0.09665181704477122, 0.0939455940752163]}, "mutation_prompt": null}
{"id": "fae78a19-bc60-4719-9750-04b35cbc7007", "solution": "import numpy as np\n\nclass QuantumHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diversity\n        self.F = 0.5  # Balanced Differential weight\n        self.CR = 0.9  # Enhanced Crossover probability\n        self.w = 0.5  # Medium Inertia weight\n        self.c1 = 1.5  # Balanced cognitive learning\n        self.c2 = 1.5  # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Medium velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([float('inf')] * self.population_size)]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                q_rand = np.random.normal(0, 1)  # Quantum random number\n                self.F = 0.3 + 0.3 * np.abs(q_rand)\n                self.CR = 0.8 + 0.1 * np.abs(q_rand)\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "QuantumHyDEPSO", "description": "Quantum-Enhanced Differential Evolution and Particle Swarm Algorithm with Quantum-inspired Strategy Selection for high-dimensional and complex optimization.", "configspace": "", "generation": 51, "fitness": 0.32109505567003893, "feedback": "The algorithm QuantumHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.7897580370172961, 0.7747522151294822, 0.7613693821458354, 0.7927772944361591, 0.8054118644571144, 0.7623530393847879, 0.7821098078585554, 0.7833804043952001, 0.7710037293167944, 0.5707376196049111, 0.5539961200993462, 0.5818019920578713, 0.5241816098295015, 0.580818951925098, 0.5549838562865216, 0.5831177455495151, 0.4604371492739803, 0.53695674297965, 0.15839640378117148, 0.13251345669025416, 0.14225933746353314, 0.14945384577995902, 0.16157714520074584, 0.1356712612187514, 0.13493359615024658, 0.12834339973516307, 0.2353219915727086, 0.09619015980913281, 0.11162122846961042, 0.12753476304283173, 0.11075024676277767, 0.1056341566519059, 0.1318976408422723, 0.10766109855151695, 0.12349287622474547, 0.11151298347601901, 0.9363002180716702, 0.9363677218433722, 0.9481936065680316, 0.9555125945468894, 0.9295004610637728, 0.9600396298383587, 0.9339986421910476, 0.9942870780073477, 0.9453748205119756, 0.491107944401427, 0.4910832813135777, 0.4877944476330882, 0.5180839379025086, 0.5065231582388667, 0.46838177868184727, 0.5185527047182821, 0.5207326087165627, 0.4733307116746316, 0.7574650607413651, 0.3613006306103337, 0.7902333890302242, 0.20845579290367722, 0.7740279611755579, 0.26243564937189434, 0.22713246141598165, 0.7393928186192325, 0.7768161742604869, 0.1874565162137789, 0.19387751179021018, 0.19580117729575652, 0.1202406742416533, 0.17754704768376162, 0.1261786051530409, 0.12669817614959555, 0.20661467088077057, 0.19356395294105344, 0.1952698499050579, 0.21361773520513083, 0.1579257716627288, 0.20676728161268942, 0.23562228539544194, 0.21165601267005008, 0.20568196293687468, 0.21779797536397427, 0.22196258467743257, 0.06354081696996361, 0.09273003386678125, 0.025073309964372625, 9.999999999998899e-05, 0.049713750320038, 0.015692985663308345, 0.0017478725686400631, 9.999999999998899e-05, 0.005444149083889682, 0.07767078679149741, 0.10560494211324878, 0.11236333298040246, 0.05692763440726556, 0.047353245963425605, 0.1451416830260005, 0.06683486595636567, 0.09976881593010223, 0.0550768425085989, 0.15234765734135014, 0.030856887584997494, 0.03747288500414703, 0.1513457547763426, 0.1895844855115031, 0.12994920012197797, 0.13945687666370943, 0.1442424813536367, 0.08790943951503416, 0.138114810918199, 0.07245900037957742, 0.08434965355451773, 0.17737156526200293, 0.145581517982021, 0.24199410836426727, 0.09286808001980773, 0.061936842284668114, 0.07736416341475794, 0.550274212209495, 0.5464120082268569, 0.49439113566369486, 0.5948741153998636, 0.5153492812306653, 0.5283537387777136, 0.572518642913741, 0.5310558381653767, 0.5228791675146622, 0.06937926722425325, 0.12416179299681518, 0.08348175722704965, 0.12063649679272714, 0.1335355957212634, 0.3895066252933851, 0.49923431414984876, 0.09814438628813582, 0.1260643186535324, 0.24755774811352727, 0.3747175347672148, 0.19365407084300934, 0.3956241086912402, 0.16820316817249992, 0.19963819556700735, 0.4337945196853058, 0.2545283155832, 0.23945765984986145, 0.4075594809659697, 0.35621244696670873, 0.4770305498549021, 0.5162593397869681, 0.3567011185122324, 0.3554451084484208, 0.5005370806883925, 0.31863852782174895, 0.4898993708727072, 0.18980554593496612, 0.2719126819833526, 0.26474317695269434, 0.33509539234529284, 0.3656869179164255, 0.331684502182802, 0.3058129281195241, 0.3372046779427146, 0.22711276361794563, 0.2429730167165458, 0.23032924608588323, 0.20740601948947868, 0.2500029645408517, 0.24815077652441664, 0.2602225603094458, 0.20762030228626727, 0.20890920090692444, 0.2425508762269981, 0.5623371787314813, 0.21007376577923742, 0.23928058937023622, 0.20028559947210878, 0.1971587845615873, 0.23287765280963635, 0.18583233166574764, 0.18543571641051027, 0.2378803597807846, 0.8511041374293482, 0.18365842798278065, 0.15931892057199093, 0.8470130094515793, 0.8340053149522602, 0.14675872825288938, 0.8362470231045982, 0.8589208656763938, 0.1692089078104131, 0.739109972742555, 0.1682356090455196, 0.6207692311479707, 0.5873847628849358, 0.16509183834054675, 0.1657839551722644, 0.629414836672793, 0.20784158076632808, 0.1124435877915183, 0.17783669551963976, 0.19261488740809418, 0.17513978762589488, 0.186595392750606, 0.18461873821947383, 0.18718279423079764, 0.20037990029749764, 0.19467910508799158, 0.17529651661467216, 0.0876401319892911, 0.08526385090784716, 0.08195167264035808, 0.08433699880500867, 0.09336400660650235, 0.08339117330093737, 0.07967969336822955, 0.0823714030694076, 0.10027329101721827]}, "mutation_prompt": null}
{"id": "c287b9a0-5c5d-413f-8168-a7aece9a3cad", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased population size\n        self.F = 0.5 + 0.3 * np.random.rand()  # Self-adaptive Differential weight\n        self.CR = 0.8  # Adjusted Crossover probability\n        self.w = 0.5  # Increased Inertia weight for better balance\n        self.c1 = 1.4  # Balanced cognitive learning\n        self.c2 = 1.6  # Increased social learning factor\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.triple_agent_strategy = True  # Introduce triple agent strategy\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.3 * np.random.rand()  # Randomize within a range\n                self.CR = 0.75 + 0.2 * np.random.rand()  # Randomize within a range\n\n            agents = np.random.choice(['DE', 'PSO', 'Hybrid'], size=self.population_size, p=[0.3, 0.3, 0.4])\n            for i in range(self.population_size):\n                if agents[i] == 'DE':\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    x_r1, x_r2, x_r3 = self.population[indices]\n                    mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    trial = np.where(crossover, mutant, self.population[i])\n                elif agents[i] == 'PSO':\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    cognitive = self.c1 * r1 * (self.personal_best[i] - self.population[i])\n                    social = self.c2 * r2 * (self.global_best - self.population[i])\n                    self.velocities[i] = self.w * self.velocities[i] + cognitive + social\n                    self.velocities[i] = np.clip(self.velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                    trial = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    x_r1, x_r2, x_r3 = self.population[indices]\n                    mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n                    crossover = np.random.rand(self.dim) < self.CR\n                    trial = np.where(crossover, mutant, self.population[i])\n                    r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                    cognitive = self.c1 * r1 * (self.personal_best[i] - trial)\n                    social = self.c2 * r2 * (self.global_best - trial)\n                    trial_velocity = self.w * self.velocities[i] + cognitive + social\n                    self.velocities[i] = np.clip(trial_velocity, -self.velocity_clamp, self.velocity_clamp)\n                    trial = np.clip(trial + self.velocities[i], self.lower_bound, self.upper_bound)\n                    \n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization with Triple Agent Strategy and Self-Adaptive Mechanism for Robust Exploration and Exploitation.", "configspace": "", "generation": 52, "fitness": 0.2770568873600411, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.6731838228125531, 0.7033665430760458, 0.6936102994603045, 0.6729094062701392, 0.6717121364886205, 0.6696986866436496, 0.6573468671342335, 0.6737527562708108, 0.6930171018973135, 0.36012509060148645, 0.37089808125125523, 0.3994446414740792, 0.33945376762234003, 0.35595901956599096, 0.38678748625890946, 0.3711449023755288, 0.41318220472836575, 0.3800571262523269, 0.07079456432696474, 0.10893913669515243, 0.10093795828861463, 0.0943144971225307, 0.1102232620295257, 0.1432922255856598, 0.08367225610614792, 0.11067420697946295, 0.11425895602178171, 0.10413046761624611, 0.09385209928720395, 0.09299993234155024, 0.10349892359116841, 0.09385566321196637, 0.11413568200604773, 0.10624023130622229, 0.0911824655103024, 0.08603172079143517, 0.956777519155779, 0.9422088347191964, 0.93172303370697, 0.938804295913955, 0.9421138606263673, 0.9515826537377032, 0.9443323413508137, 0.9576255324205821, 0.9299989233714497, 0.320801400944121, 0.2851276087893456, 0.3100250656178539, 0.2889260662431805, 0.3055939486793694, 0.3086745553193655, 0.2790134337698239, 0.2716060785876966, 0.2969937456503833, 0.4719883581257138, 0.5833474840402448, 0.4860812559175671, 0.5237681595993908, 0.20350444415079594, 0.6324643196222335, 0.5983023559945232, 0.5078007634981014, 0.5540669566358241, 0.19235402679205849, 0.1962510662666146, 0.21351507441432582, 0.20192725999594074, 0.1722178625423756, 0.19684544012598548, 0.2249264389958171, 0.17362014704166373, 0.18795228814874754, 0.1843097454686411, 0.20856883648401348, 0.18118843749692326, 0.19258246482810704, 0.14858855403468774, 0.12387347351370603, 0.19567947637496763, 0.23874877159736962, 0.21676312774917383, 0.05226185340397538, 0.07476498379291718, 0.010354780389511875, 0.052895659337794276, 0.04179853969210412, 0.04989997229119547, 0.0336377762942941, 0.03664898866731037, 0.04906428666164042, 0.17948640549386308, 0.18966013065789034, 0.17733248398877277, 0.18303515409185978, 0.16473850551185587, 0.16005133034399022, 0.20847018177519272, 0.15173086006544512, 0.18835631198988723, 0.02688498093547753, 0.015405620956226662, 0.013740331328398137, 0.021420354763425742, 0.05037970207459619, 0.039479703314930004, 0.029545696958375278, 0.05299123790043925, 0.06293387258893157, 0.11706249955592607, 0.14935055296109645, 0.13662398143913634, 0.13502412446301426, 0.14215693627769288, 0.12421729915042012, 0.08883268411050105, 0.09646226516069112, 0.07512379260405633, 0.4676201175459519, 0.49233267711220985, 0.4934625985830621, 0.45689968445082885, 0.48786882224771455, 0.46680468750372717, 0.5116696306976468, 0.49726895387131986, 0.5102754771524515, 0.0937670515027037, 0.09006620213589234, 0.09598614718929455, 0.10081957295288524, 0.08901207613383699, 0.10004171549030305, 0.09278262797570935, 0.10848424480589669, 0.08945368394451647, 0.23508648229219342, 0.16575244223164787, 0.1687373976256331, 0.15125041620889002, 0.16530199928378608, 0.155840275665736, 0.16788309697863002, 0.27251385317689547, 0.15480060298639453, 0.3245477715471293, 0.3547244158867253, 0.3419772226231905, 0.3451096110212114, 0.34035522653173444, 0.3450749496110709, 0.33111259445107266, 0.35502847249307656, 0.3551163649659981, 0.2499392718553467, 0.21168683841847824, 0.2422564885334857, 0.2650283411636809, 0.2327033246803123, 0.26699907528769196, 0.25277522010175546, 0.24016871109467886, 0.2558133470629633, 0.1960961702207913, 0.21116177264626534, 0.18896773552224866, 0.21814953976756724, 0.20083414185070592, 0.20053570768883522, 0.20119829645295062, 0.20881046297862105, 0.20254789362040693, 0.22194487747153913, 0.19252542655767002, 0.21088437807529203, 0.19651244385627176, 0.2263739690906469, 0.20784368843576662, 0.21123845316595802, 0.2156976360955668, 0.19821360120804898, 0.17583905473472228, 0.15347563913466988, 0.18607370045273663, 0.7762209318219675, 0.16395162289431264, 0.7534248208386068, 0.7972530230686874, 0.7835215355589872, 0.1522816044191999, 0.6335555825968519, 0.1658058906056189, 0.20725833593752618, 0.20740770407911935, 0.5934747357994787, 0.11182687473114494, 0.5697557380547126, 0.6260789631498523, 0.5926510927681475, 0.1842395905239662, 0.18540289799233656, 0.18093554581357763, 0.1917829215996092, 0.18477530922226026, 0.19241965680928197, 0.18914180042893325, 0.1843334597707451, 0.1829809338546503, 0.07676417704219618, 0.08930218539218682, 0.07314314781905396, 0.07987509937365245, 0.0856871694399377, 0.09062998377156806, 0.09282162491263612, 0.08897827875679232, 0.07580753876439916]}, "mutation_prompt": null}
{"id": "9484de6f-f92d-437d-aa36-7a4f740c45f1", "solution": "import numpy as np\n\nclass StochasticHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.3 * np.random.rand()  # Dynamic Differential weight adaptation\n        self.CR = 0.9  # Slightly increased Crossover probability\n        self.w = 0.5  # Adjusted Inertia weight for better balance\n        self.c1 = 1.5 # Slightly reduced cognitive emphasis\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection with random factor\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Vary within a broader range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Vary within a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "StochasticHyDEPSO", "description": "Stochastic Hybrid Optimizer integrating Differential Evolution and Particle Swarm with dynamic adaptation for diverse exploration and balanced convergence.", "configspace": "", "generation": 53, "fitness": 0.3135729747346667, "feedback": "The algorithm StochasticHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.82833029071646, 0.8207748292288706, 0.8342866845847848, 0.8303959190520682, 0.829817073416484, 0.8090296132878299, 0.825983418695327, 0.8277843434463551, 0.8345910479418822, 0.666697471746112, 0.6453197835571642, 0.6764476071638307, 0.662065062863226, 0.6738365057215031, 0.6537001419607095, 0.6859957275222457, 0.6871569341360095, 0.6559040419167512, 0.1356396645837714, 0.1480714852084185, 0.16976696613850817, 0.12806276536214167, 0.5601227671470876, 0.1357888927887556, 0.1261803215228987, 0.1556828137434566, 0.1632358258587041, 0.10240427203628566, 0.12340070467341668, 0.12264337171607131, 0.1022077589603656, 0.09998943937361959, 0.1243252712963887, 0.13586991359484424, 0.10573174090138837, 0.10329281385396683, 0.9516976811184262, 0.96302028421412, 0.95551385988614, 0.9389619985315346, 0.9420905275218585, 0.9508361831186509, 0.9457783434235554, 0.9654346766761771, 0.9419300927503957, 0.6133507714762871, 0.6395883686280075, 0.6257192162566809, 0.6604088423445496, 0.6372539357220313, 0.6417040120258837, 0.6250195387338884, 0.5992762565734682, 0.604056216485447, 0.3838369044200346, 0.16691702628732707, 0.22454478083425677, 0.27664528971764535, 0.21063649899781378, 0.2724978433828268, 0.7277121475630224, 0.23206963583810736, 0.2207806627601424, 0.20310624385446707, 0.17830645190924954, 0.18835298179686, 0.19343245549510923, 0.18916805659961167, 0.19814115021701806, 0.19265922549020698, 0.1920120888889565, 0.2689303871010239, 0.20621197204495434, 0.21752497499468648, 0.13165167875589012, 0.20758321578586014, 0.19043152810227415, 0.4067745551654396, 0.2355552097179202, 0.20365223415720735, 0.22015784700279828, 9.999999999998899e-05, 9.999999999998899e-05, 0.04394072632042867, 0.0002368869812944263, 9.999999999998899e-05, 0.037573925220143245, 0.0014199347992104316, 0.034432886181367195, 0.060065914636342366, 0.07198969800323252, 0.08787977622120469, 0.049130980278626724, 0.06856353005115601, 0.058738251516254225, 0.10324683249471689, 0.06531136270343318, 0.11159636165471076, 0.12294203116657276, 0.03761230006296645, 0.157790318077059, 0.07746706599790942, 0.09944932822841368, 0.08427982193852279, 0.1861736630275761, 0.07258366097475066, 0.13526168462722454, 0.06548844491994532, 0.21712794403600355, 0.0854831075446304, 0.15201042278570653, 0.12022051375033627, 0.07196971257875884, 0.11451986821818427, 0.1410751677433757, 0.11180458142467542, 0.2714477521537615, 0.5341639967460045, 0.5068545565566641, 0.5721406157632019, 0.549385172764518, 0.5495275722024484, 0.5535088741561217, 0.5501801041850396, 0.5750202391632011, 0.5513813443836226, 0.12176767662402566, 0.11399491462776457, 0.10054541316030297, 0.1712821691924501, 0.09785597400891166, 0.10884212460756537, 0.08523190899347066, 0.14582731967288054, 0.14455560204747397, 0.2640244451984025, 0.5964171140467551, 0.27620371725518167, 0.47072223421200676, 0.3022605855846022, 0.30702873686924825, 0.2168684754666097, 0.3217842615606492, 0.23693389923169483, 0.36851763460440734, 0.4030691019150422, 0.3161214978156369, 0.30937909271438124, 0.4430429123075843, 0.5418084173047972, 0.5932097365261992, 0.44215919690483785, 0.26017528049977623, 0.206802979854807, 0.34393604594321125, 0.3328425293731475, 0.25251840205268294, 0.18897039558277584, 0.21185995717987183, 0.3407757842780581, 0.23214435268027356, 0.2860662959151755, 0.20647503339693007, 0.19616669277865806, 0.2137854217644799, 0.20288994261605475, 0.19674214134852308, 0.24117973203105758, 0.22083168348183257, 0.22974943409516668, 0.21341340797827835, 0.19728176362684446, 0.7122758007801403, 0.21902387259235678, 0.24206008886943742, 0.22374255019643585, 0.2060021734570191, 0.19351335713719497, 0.1992321402899332, 0.24377112364252707, 0.15754018980945583, 0.19716314992067352, 0.18547617848405762, 0.16235966533640944, 0.19834631983635076, 0.8860251136009465, 0.16859683923957658, 0.15159106085523055, 0.1971989010571067, 0.11260093925018133, 0.167033096312467, 0.20980830165984365, 0.8318684397111066, 0.16702572211107258, 0.736048756479178, 0.20893383192376946, 0.8592641509567429, 0.15476310754788725, 0.17032588042180907, 0.1960009811364546, 0.17806978075081092, 0.18390689034888708, 0.177728890953193, 0.18067102935105428, 0.18370614898144566, 0.19109075688242982, 0.1808906394258103, 0.08627786389498249, 0.08768863700433216, 0.08722444588910316, 0.08866232647054562, 0.1261818910609036, 0.08502753387819006, 0.09336900505375467, 0.08544795550729245, 0.09140150536460401]}, "mutation_prompt": null}
{"id": "03b1ba91-a30d-4ac3-8c7f-a22264b2d094", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10 * dim, 50)  # Ensuring a minimum population size\n        self.F = 0.5 + 0.2 * np.random.rand()  # Adaptive Differential weight\n        self.CR = 0.8  # Stabilized Crossover probability\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.8  # Emphasized cognitive learning\n        self.c2 = 1.4  # Increased social learning\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best = np.copy(self.population[np.argmin(self.personal_best_fitness)])\n        self.best_fitness = np.inf\n        self.strategy_dynamic = True  # Enable enhanced dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        # Update personal best fitness records\n        self.personal_best_fitness = np.minimum(self.personal_best_fitness, fitness)\n        idx = self.personal_best_fitness < np.array([func(x) for x in self.personal_best])\n        self.personal_best[idx] = self.population[idx]\n\n        # Update global best\n        min_idx = np.argmin(fitness)\n        if fitness[min_idx] < self.best_fitness:\n            self.global_best = self.population[min_idx]\n            self.best_fitness = fitness[min_idx]\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Enhanced dynamic adaptation\n                self.F = 0.4 + 0.3 * np.random.rand()  # Adapt within a new range\n                self.CR = 0.75 + 0.1 * np.random.rand()  # Adapt within a new range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_best_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_best_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Enhanced Dynamic Strategy and Memory for Efficient Exploration and Convergence.", "configspace": "", "generation": 54, "fitness": 0.33895860945108763, "feedback": "The algorithm AdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8720467786006467, 0.8668748411741246, 0.8588930633450633, 0.8694846290755041, 0.8614039880326574, 0.8447227671913041, 0.8721382467113576, 0.8601976018289801, 0.8631727478411131, 0.7402715645329989, 0.7229936914805667, 0.7343185407877516, 0.7465922399503426, 0.7466530717853466, 0.7405815237410853, 0.7450376680221262, 0.7391445939640053, 0.7159641736807323, 0.13688442250373922, 0.6129339631936497, 0.1283546264539207, 0.17685648177772417, 0.16184297074243026, 0.1380375060901664, 0.1511185186326165, 0.14966907627124892, 0.5799232009118027, 0.12509601805144066, 0.13421332815985498, 0.11150788720929194, 0.14927889662552296, 0.11294462985540432, 0.13295856805295736, 0.11371008386931769, 0.14249353378150376, 0.16048860920007102, 0.9666522263474795, 0.9715355053418441, 0.9591071830254355, 0.9507229105074382, 0.9533213563804258, 0.9531481716434211, 0.9558814855147977, 0.9660456534229136, 0.9530519307014439, 0.6575023965935204, 0.6669824661609316, 0.6407302882776907, 0.6375107865464718, 0.6213911108922178, 0.6199571687160343, 0.6359412105737823, 0.6108191864342739, 0.6193534431485292, 0.22525281517618678, 0.3771227233203097, 0.7846155413940592, 0.21387256708317925, 0.27457893349524076, 0.21280285184051684, 0.8759280073340439, 0.825161955481586, 0.8329256883627472, 0.20820391446595565, 0.22679012940772492, 0.26432394672471726, 0.22028333514609377, 0.2140813742082852, 0.1311979336282071, 0.22944185582415444, 0.2589619674081701, 0.18610606796418439, 0.15451907682592847, 0.2053140492295472, 0.20562463844747458, 0.22434004047989942, 0.22709375055201342, 0.20822227848607522, 0.13268912458168214, 0.23806640362140485, 0.10342177625921689, 9.999999999998899e-05, 0.04265525797711345, 0.03501350924927371, 9.999999999998899e-05, 0.0316285057002067, 0.03994201574237721, 0.004233689326288537, 0.09379268414635411, 0.08218586680162332, 0.0684724586453116, 0.12340220838830951, 0.10152660551254067, 0.060379756991095546, 0.14545198684755611, 0.06294814742278287, 0.1293756707652648, 0.19153664956893712, 0.08908833906124214, 0.0467956734543552, 0.09388604477370832, 0.2419860629399615, 0.07591538753625826, 0.1290951069165821, 0.18160005703673243, 0.2615741414551209, 0.14195675461906432, 0.0893420961227055, 0.07069143564149438, 0.19596926670426806, 0.17225524730593356, 0.12253322304503, 0.1801116122139954, 0.14378667738957518, 0.13726899029019168, 0.13424985815713297, 0.1713051242524014, 0.5283608047776305, 0.5308661870200369, 0.5829321933264326, 0.5402554497917205, 0.554969074987967, 0.6120806025294256, 0.5941609572079564, 0.6041594804753188, 0.5791998516546468, 0.15305986961507134, 0.11523083428993852, 0.12875031320032415, 0.1272188135608614, 0.12013894434541927, 0.1540424659776516, 0.10732577333042315, 0.11852816317055315, 0.1605002671475666, 0.19906096892328873, 0.1828395738339348, 0.4997685093950419, 0.24911207688252002, 0.39031673553062207, 0.12692072472113325, 0.24005830984900545, 0.22475843032007037, 0.21152481618910002, 0.47523851967906916, 0.521402326540066, 0.47073728245144464, 0.546265604955974, 0.5893258516591913, 0.5228345337078816, 0.5462694319223531, 0.5701113472121824, 0.6283908016879859, 0.2848037809545647, 0.30506545386205697, 0.22808059041953688, 0.24356650023587767, 0.25388448022671706, 0.23137089425843815, 0.25740359313539596, 0.24708355925375147, 0.3692780764799236, 0.20720355732831608, 0.24099161028906135, 0.2134023912346612, 0.23188382464993662, 0.20767310989510968, 0.2090855320648186, 0.24377791870090226, 0.20663102441639325, 0.21669628318344025, 0.1878169140995647, 0.20497321369222143, 0.2373639913736837, 0.2431212294923163, 0.21822444879438785, 0.6912047821159396, 0.2017938238261432, 0.20254015954631377, 0.20859117272134786, 0.19754484025709984, 0.19646971283969905, 0.1851415131977464, 0.16105266862180523, 0.17070557939771747, 0.1709260870658219, 0.135286466075062, 0.17557507702354236, 0.17496702120440555, 0.1270709618364092, 0.8171442367035231, 0.167873205466456, 0.12701714297661149, 0.16814158035613203, 0.7555944562917132, 0.7703390407480022, 0.7754852221325281, 0.7825530373320408, 0.17534297340268024, 0.18999619101870724, 0.20137179893114987, 0.18878973546237954, 0.19544040337456725, 0.19261416119696106, 0.1768320010004103, 0.18492931637540633, 0.18089145676800422, 0.0961458346148274, 0.08599347529491574, 0.08551456246523426, 0.10171260372531865, 0.09374226627519966, 0.09373617874422269, 0.11697482398456738, 0.08366127623972841, 0.10069753280730198]}, "mutation_prompt": null}
{"id": "4187d632-d287-4ae4-9185-9821e322161d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = 0.5 + 0.1 * np.random.rand()  # Increased randomization for exploration\n        self.CR = 0.75 + 0.1 * np.random.rand()  # Adjusted for balancing exploration-exploitation\n        self.w = 0.5  # Adjusted inertia for stability\n        self.c1 = 1.5  # Rebalanced learning coefficients\n        self.c2 = 1.5\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.1 * np.random.rand()\n                self.CR = 0.75 + 0.1 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization with Multi-swarm Strategy and Improved Parameter Tuning for Superior Exploration-Exploitation.", "configspace": "", "generation": 55, "fitness": 0.32952949002396026, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8591962444271741, 0.852475293409108, 0.8617134175790822, 0.8609249013123186, 0.8512175210169801, 0.8587646457748296, 0.8550206877300294, 0.8659958034710109, 0.8467309704848257, 0.6922460429831385, 0.7239224388579408, 0.7132785419883546, 0.7238054303764003, 0.719547358427103, 0.7189421920888702, 0.7192738312739722, 0.7199598564670137, 0.7254017399712183, 0.13061359351839963, 0.11612681025781313, 0.09222034479308172, 0.11964681615081085, 0.12951606970410534, 0.15629815995888385, 0.11393969796538239, 0.17022314262403015, 0.15574135715894333, 0.11491081245811674, 0.11546443971433351, 0.14074238057798738, 0.14002468768284393, 0.13793118970221951, 0.128957195377584, 0.11034957866445116, 0.11895668532981929, 0.10711703973315634, 0.951846469681015, 0.9596568303770647, 0.9491329990500474, 0.9529667178353779, 0.9737106671655876, 0.9524165667668851, 0.979473111806362, 0.941361648504521, 0.9435049918877961, 0.7084374853341167, 0.6619388556632948, 0.708419549257133, 0.6582301838667421, 0.694960554941731, 0.6105798357611574, 0.638571303970175, 0.6651489530007266, 0.6634258020044219, 0.2088369725507776, 0.3771525938372411, 0.38170459308668025, 0.8277330597294945, 0.8974637510632192, 0.21057815516664746, 0.2424637793612593, 0.884053592486876, 0.3953587440903831, 0.2141485359412839, 0.12992581358462973, 0.21145281090221768, 0.20717028934468085, 0.2042510587910018, 0.18584002278010214, 0.21924180630389745, 0.21350261916982627, 0.12941952518593647, 0.22414043901573955, 0.22417466460415603, 0.22905670098185427, 0.2213904525135677, 0.23895383299297412, 0.22615155217911398, 0.23502053170867343, 0.22306955277775897, 0.2266772594357025, 0.009199629052822234, 0.045571402175324294, 0.06590217534343756, 0.00864363719779504, 0.0032244291368686007, 0.014133360105863413, 0.0002656268983893817, 0.05797824242498595, 0.062854939926837, 0.09121094145832287, 0.1619055871505889, 0.11806533697638677, 0.07843445903704505, 0.126493113379046, 0.010833834464825887, 0.10529569827704999, 0.060844048038213305, 0.05985544873783688, 0.07635919004013847, 0.07397727341457716, 0.08921621284251413, 0.07563404707770094, 0.08054384330126085, 0.07908722237109, 0.3360480922603095, 0.07012534673835435, 0.2745085915781067, 0.15037492113644457, 0.09217573488937947, 0.11651372935431448, 0.16261324431409352, 0.13756987226841633, 0.232924823168577, 0.14481791173485525, 0.10120268386182985, 0.15009094797999334, 0.6003543902736208, 0.560425175733039, 0.570052191932062, 0.5898714920864407, 0.5679320490707899, 0.6097705505869966, 0.5720397059353648, 0.5714625455376422, 0.5844673442036841, 0.12077428204917684, 0.10966646965387628, 0.11273887520436254, 0.14418254579707424, 0.12757881040637808, 0.12743163765810717, 0.08966272953439369, 0.06942207216662233, 0.11601832673860046, 0.1467339275677224, 0.25726464157936557, 0.5646982091811696, 0.21213815582047624, 0.430217014706079, 0.19744000346576018, 0.3249431213548647, 0.6321428156630323, 0.2445942663645725, 0.6210805257308967, 0.26057592625839665, 0.6208674397732159, 0.36876242938111614, 0.4915656944367953, 0.6332944963718785, 0.6286972864221909, 0.6662443466271606, 0.6658637009530197, 0.26371189494323255, 0.44320950128616454, 0.30963321496929097, 0.3489087439042343, 0.2522416120172364, 0.39874661093637565, 0.20548748834542352, 0.30948218207300526, 0.22134553891180608, 0.2593954369364254, 0.22641704205956126, 0.2684168101580051, 0.21525213650598096, 0.2105072645241215, 0.21414077926583397, 0.25928911794064446, 0.19545493869446773, 0.2298694350906102, 0.24714302308412794, 0.19427686627306917, 0.1874760535668919, 0.19489679935876425, 0.1959986675553399, 0.2065036629427468, 0.19031875562427103, 0.20198347740065303, 0.18838114020371555, 0.18671243612418897, 0.208736374552267, 0.17052705217668807, 0.8900897535290473, 0.177160364092392, 0.17296465060036081, 0.11438593499864513, 0.13121438362477966, 0.16306477389643736, 0.11245084296311147, 0.20893349280364115, 0.7118421694968748, 0.8276696964946914, 0.2101577770064822, 0.16708778677674652, 0.16521973278238833, 0.2121224871976316, 0.16565529404271218, 0.17254296514635514, 0.19900892560359307, 0.1913874241343667, 0.19105359655598042, 0.20440884674530657, 0.17331559890122317, 0.21158268140931435, 0.18674591762541048, 0.20212496912058364, 0.08374827692874898, 0.10252943006120407, 0.08111850551469235, 0.08799781166092657, 0.08147872098900533, 0.09642502225979466, 0.08678653889203725, 0.09677760004193847, 0.08947086604313514]}, "mutation_prompt": null}
{"id": "4be2e0d3-25e1-4ff2-ba2f-3894c1ea208a", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.6  # Slightly increased Differential weight\n        self.CR = 0.85 # Adjusted Crossover probability\n        self.w = 0.4  # Decreased Inertia weight for quicker convergence\n        self.c1 = 1.7 # Higher emphasis on cognitive learning\n        self.c2 = 1.3 # Slight decrease in social learning\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization employing Differential Evolution and Particle Swarm with Dynamic Strategy Selection for optimal exploration-exploitation balance.", "configspace": "", "generation": 10, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8654156628884216, 0.8505577733650087, 0.8629165407617487, 0.8380421862650951, 0.8456388156840458, 0.8587296791285854, 0.8527912259306096, 0.8559354413193545, 0.8534634313822277, 0.7396929881209096, 0.7341634510349436, 0.7092094663753394, 0.7154728891383115, 0.7193812497122521, 0.7182816213467694, 0.6967750011711794, 0.7069553883493507, 0.7000883977891325, 0.1114105147072143, 0.1481172016688579, 0.1526431654403636, 0.13387851849765897, 0.5442252168246698, 0.14871135036606575, 0.14941128180821783, 0.17945018706496574, 0.1721961393818332, 0.11263438928044145, 0.1503320556503278, 0.11906872559250425, 0.07768433680669018, 0.123196329897314, 0.08839246620613794, 0.10215271061855224, 0.136861489246068, 0.16872141851491052, 0.9553658555778358, 0.962358918073187, 0.94632188274503, 0.9478315924386019, 0.933922097238991, 0.931645767660017, 0.9331854407292095, 0.9361184003567173, 0.9475659196534141, 0.6944265741588745, 0.6856320914341114, 0.6895938036266172, 0.6512602616989766, 0.6877164471456558, 0.6968459829021534, 0.6826596919438079, 0.6890696982652229, 0.6820549676551929, 0.22635534559259274, 0.2395695445189302, 0.871631368557718, 0.27643157799925233, 0.3776060212088548, 0.3654865471871893, 0.22726557497574373, 0.23187077237783693, 0.8641424405872651, 0.11911049122598305, 0.40253532485593235, 0.18724974672384187, 0.18685655018194935, 0.1762400387692964, 0.1677187013488063, 0.20015727878600587, 0.13013515604564707, 0.19273282982800555, 0.13054336021097146, 0.20357835941169955, 0.18189917360312102, 0.20288068384517965, 0.21443735838623112, 0.2665297124948879, 0.10045236270221536, 0.22433507035561873, 0.24968235924269622, 0.04569264568070608, 0.046478388727113074, 0.009403796381180163, 0.11558206670531146, 0.022272836136776775, 9.999999999998899e-05, 9.999999999998899e-05, 0.010927236322666789, 9.999999999998899e-05, 0.09869799781293243, 0.1090027274030263, 0.05063311386168057, 0.04550856712314999, 0.04423383431881778, 0.06882428231234117, 0.08488780433257614, 0.06915948266957872, 0.05616918626292622, 0.09745344578854442, 0.14266038440678452, 0.056123739872517175, 0.07390068554872598, 0.11734251827298636, 0.12287962955005238, 0.0980558089589878, 0.313793869868884, 0.08787551386325854, 0.2917486797997608, 0.07946991282739091, 0.17224156652019373, 0.05828027627746901, 0.1303077885280134, 0.11646763760169576, 0.08124608208620498, 0.09380995154813043, 0.11633120525826257, 0.555773540156163, 0.5361648390238402, 0.5955635893097015, 0.5903343412986675, 0.5705534059184401, 0.5907928198654778, 0.5864770506960435, 0.5807836462029989, 0.5758600831607168, 0.10120420675667552, 0.12293330861734575, 0.08053869524767177, 0.12354207506704484, 0.08073736346821536, 0.10272482608129685, 0.1532115312741822, 0.1360901696747585, 0.11231936726528802, 0.2996945930024152, 0.15036461848789773, 0.29192725793646557, 0.586998814628755, 0.2399129418500099, 0.1898988614820507, 0.27985674526575943, 0.3083813152828182, 0.5046665857709443, 0.37562013603185973, 0.6232592500722111, 0.3557764990869141, 0.5437494596585588, 0.3267962797244046, 0.5034191970719868, 0.2674787778771113, 0.5388690396864722, 0.6257347160992258, 0.23055603168705607, 0.2447596166552669, 0.39697389969629493, 0.2625329956848663, 0.40754650098073675, 0.29008056153170936, 0.1751376443979058, 0.30452850055108005, 0.23510988528554233, 0.19668727799983587, 0.20910730931872668, 0.2175758334347292, 0.20338777031504363, 0.18505592405916904, 0.23282516743307258, 0.23561468261837826, 0.2084214935526616, 0.1992958345658873, 0.22347397714813655, 0.775697066021013, 0.7596980411140908, 0.19538432929097282, 0.2243522715669185, 0.2028591502542586, 0.2386133439715501, 0.19782069255035517, 0.24194431253744464, 0.16480578984400673, 0.18666277229218065, 0.14688420848316563, 0.9098379302694619, 0.1982514777222646, 0.1475028254563553, 0.8731942555370419, 0.16665056287172852, 0.8805288423103896, 0.20927865953032454, 0.21108787377126625, 0.8533564639442084, 0.763389303028059, 0.16733100051057104, 0.8613345632732998, 0.7485132509000212, 0.8102590047437631, 0.7780868464822436, 0.17160405761841613, 0.18127479983452888, 0.18169009769591782, 0.1879575855717499, 0.18826675033422202, 0.18053776450857095, 0.18172286449606012, 0.18021609380021242, 0.18721428705009724, 0.09942796858883207, 0.08282587662772478, 0.09296007929933059, 0.08365309054045356, 0.09063972579928448, 0.10307454917509362, 0.09162982471474646, 0.0995422377362134, 0.08839800323757774]}, "mutation_prompt": null}
{"id": "28f4ae43-fff5-463c-b2c4-5e5ca5e3b40c", "solution": "import numpy as np\n\nclass QuantumHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5  # Balanced Differential weight\n        self.CR = 0.9 # Higher Crossover probability to encourage diversity\n        self.w = 0.5  # Balanced Inertia weight\n        self.c1 = 1.5 # Slightly decreased cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.4 * (self.upper_bound - self.lower_bound) # Increased velocity clamp for wider search\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Keep dynamic strategy selection\n        self.qbits = np.random.uniform(0, np.pi, (self.population_size, dim)) # Quantum superposition states\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.4 * np.random.rand()  # Wider range for randomization\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Wider range for randomization\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Quantum-inspired variation\n            self.qbits = (self.qbits + np.pi * (np.random.rand(self.population_size, self.dim) - 0.5)) % (2 * np.pi)\n            quantum_variation = self.lower_bound + (self.upper_bound - self.lower_bound) * (np.sin(self.qbits) ** 2)\n            self.population = np.clip(quantum_variation, self.lower_bound, self.upper_bound)\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "QuantumHyDEPSO", "description": "Quantum-Inspired Hybrid Optimization leveraging Differential Evolution, Particle Swarm, and Quantum Superposition for enhanced diversity and convergence.", "configspace": "", "generation": 57, "fitness": 0.14450819922883412, "feedback": "The algorithm QuantumHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.17.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.23453662435727618, 0.22716736459323106, 0.23046924652768752, 0.1874397413652371, 0.23179410582896975, 0.1938818064536818, 0.20863735902351144, 0.21758587654099404, 0.2256341073618947, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05915150421475979, 0.07247463786890751, 0.0707182460470831, 0.05400619476203994, 0.06284911656970837, 0.06103222148148124, 0.06971165608876839, 0.0829521777650627, 0.051096623064809554, 0.05290080000052333, 0.06259390941353682, 0.047301661612366486, 0.05625542653787996, 0.05725170165808757, 0.05283429085025548, 0.042939335290107516, 0.05453009362127126, 0.04758347874699298, 0.9019164581688088, 0.8641263511897865, 0.8753900229952809, 0.8419489840888126, 0.9081908947231837, 0.9165096437804894, 0.8758408831453044, 0.8296841848707975, 0.8956885569861938, 0.132912286596225, 0.11553084270409542, 0.09256282334359767, 0.1261685666732545, 0.15559279806127868, 0.11174876834910041, 0.10201664139771949, 0.09003419683648195, 0.11450541021998595, 0.1663745843201495, 0.1706981045795607, 0.15481097574754332, 0.1522895170406855, 0.16403636583216574, 0.17055729336085101, 0.17134474821319967, 0.1749179501895033, 0.1601615265277616, 0.04079518699827078, 0.04832473228852108, 0.03213113244461496, 0.04076698866647843, 0.014617519045546423, 0.06346774403403377, 0.016502872969839877, 0.03769805964064721, 0.0338844239894337, 0.057099146847258475, 0.06932181565628692, 0.03881346698948418, 0.07868444953896214, 0.060521535775783786, 0.08168656655523288, 0.04179797477595293, 0.06857240778498419, 0.07107458738608452, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08129806820340779, 0.09051389898820128, 0.10293707649000772, 0.06793213496489248, 0.0714739633089585, 0.06896385743796163, 0.07113305822649485, 0.053612986382799654, 0.0657130288556178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005576762041825889, 0.004409264070569963, 0.0025614006886791607, 9.999999999998899e-05, 0.0009402024817196653, 0.006510711738009545, 0.009277233207898083, 0.027570259709019274, 0.004589920418855087, 0.22953769351647657, 0.2322988342210477, 0.23679654440842401, 0.2327853627762242, 0.24666071177011084, 0.21596653714151237, 0.25135185165670204, 0.24523099246000069, 0.2291188465705859, 0.05592451266910792, 0.0595390340466907, 0.049765406360276265, 0.08604835827332513, 0.055875803725161655, 0.06574793781465471, 0.06861516885499963, 0.06020662480723149, 0.06797615222853748, 0.13600082602627683, 0.16897834070450135, 0.1457528706308151, 0.16529170852799002, 0.1263684074855943, 0.14650204423997581, 0.13512747639123923, 0.1267314253585724, 0.13235394729739003, 0.17325776621352762, 0.17970499443660115, 0.17442205437260094, 0.18768976301996287, 0.2008793850718844, 0.18623149263758465, 0.1727310625977465, 0.2077056066377695, 0.1750630761573213, 0.13000362185178294, 0.1323166307474969, 0.1407795508651437, 0.14890739283711796, 0.13967430057054497, 0.1397509297985694, 0.12620129625377408, 0.14007324838570434, 0.14242895765119135, 0.19690858683532686, 0.18101136766709813, 0.1962408678128429, 0.21280006140615182, 0.17649325163547114, 0.19319982526939972, 0.18704744522625627, 0.19033580382341975, 0.18095331037060158, 0.15608058317054763, 0.15916631375654122, 0.1841740027632074, 0.16349274282577042, 0.16613838609432918, 0.1668051004111316, 0.16081751504088748, 0.17206383855690077, 0.16316305471882842, 0.19770328433475215, 0.15985142843368705, 0.16457636153071797, 0.22378460528612965, 0.21903953449967317, 0.20967678570852666, 0.21485406610126667, 0.20234379055153395, 0.12762002295377783, 0.24588958822179585, 0.17398387682598404, 0.2580884381778523, 0.21384072638071117, 0.29651508937106685, 0.18547161852352234, 0.22887528939275603, 0.235974107897013, 0.20880042570842938, 0.18625217838866115, 0.20037142765926064, 0.18062164855652663, 0.20262661488618483, 0.18421038500689424, 0.17991434502173054, 0.17214338402428497, 0.1890410706179515, 0.1725388776690201, 0.05880249746260802, 0.07052364992062243, 0.07924536798660953, 0.0672723768668162, 0.05937672324975707, 0.06422506622814617, 0.07402943041556498, 0.07565341539963644, 0.06830380052395868]}, "mutation_prompt": null}
{"id": "c0bb114e-7c17-4f38-9347-c214629b5bad", "solution": "import numpy as np\n\nclass AdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for better diversity\n        self.F = 0.5 + 0.3 * np.random.rand()  # Wider range for dynamic F\n        self.CR = 0.75 + 0.15 * np.random.rand()  # Adjusted Crossover probability for adaptability\n        self.w = 0.3 + 0.1 * np.random.rand()  # Dynamic inertia weight for better balance\n        self.c1 = 1.8  # Increased cognitive learning\n        self.c2 = 1.2  # Reduced social learning for exploration\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp for control\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Dynamic strategy remains enabled\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.45 + 0.25 * np.random.rand()  # Further fine-tuned randomization range\n                self.CR = 0.65 + 0.3 * np.random.rand()  # Adjusted randomization range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHyDEPSO", "description": "Adaptive Hybrid Optimization using Enhanced Differential Evolution and Particle Swarm with Reinforced Dynamic Strategy Selection for improved convergence and diversity.", "configspace": "", "generation": 58, "fitness": 0.3133207507872471, "feedback": "The algorithm AdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8368169946048394, 0.8449047268708535, 0.8209938062750639, 0.828382955399487, 0.842923836639144, 0.8141663149894172, 0.8374908700681601, 0.8485522203107014, 0.8378636752509467, 0.6532814421599306, 0.7172708975762618, 0.6338334953567119, 0.6867647767321368, 0.7167490719501123, 0.6789381730953938, 0.6398719269886821, 0.6216132967072004, 0.6783565647261249, 0.1369511079246517, 0.17561621293108998, 0.1515247449323076, 0.1478330117410953, 0.15446164067887636, 0.1590659837168814, 0.153221042350845, 0.1431759705700011, 0.17295633605787009, 0.126880370608904, 0.1245123644863968, 0.13458211855537283, 0.13187696219908918, 0.11232921240032245, 0.0921238564860698, 0.1108454215217749, 0.1360983466878164, 0.10940019435914494, 0.9425673272276197, 0.938832107675123, 0.9381848814024943, 0.9303404468219475, 0.9572016320612775, 0.9087345971481708, 0.9408201444264896, 0.9459039327607695, 0.9076697975837165, 0.6066095560625793, 0.6374447914750896, 0.6144743510733073, 0.579515645315561, 0.6295092634353823, 0.6048452077041514, 0.5799640128216155, 0.6154446344209888, 0.5935304943017052, 0.16571482520783665, 0.22384254535973547, 0.372142894853669, 0.19066974625962863, 0.20777714297083238, 0.8318780173112771, 0.8132687128593289, 0.23218762394566206, 0.7395172625391006, 0.11908512312191544, 0.12813506476124914, 0.17879331156344036, 0.12057358816493047, 0.17450756890284214, 0.1659540309399794, 0.1642069861576121, 0.17008215102553004, 0.11992840654884951, 0.12806860844502277, 0.12595492002818065, 0.18740557560866478, 0.2050296573880973, 0.12534845437499376, 0.18483768736808592, 0.2133943123788904, 0.1925977673404422, 0.18459998689397628, 0.09328325950784633, 9.999999999998899e-05, 0.08766750599105522, 0.07881171602345749, 9.999999999998899e-05, 9.999999999998899e-05, 0.026521332280826426, 0.014128616483805478, 0.09834623958934985, 0.034707015672842734, 0.10338927170010137, 0.11664306694547633, 0.08986302816840852, 0.04785692277097042, 0.08137937817860352, 0.11053385730684573, 0.10200480052884653, 0.09786075621478485, 0.04493607725277504, 0.08560804378460796, 0.12471980000611893, 0.1575456004315754, 0.32217466130097705, 0.21551605930616102, 0.0672433020899712, 0.09985243267282118, 0.12787883979492654, 0.18499755065454115, 0.2821810286002062, 0.13086734868377314, 0.14662543821398233, 0.16044934416774959, 0.13220910075465309, 0.10916992355178046, 0.08566418727863734, 0.1151128047442821, 0.5829988061793681, 0.5493454286354169, 0.5556206516607696, 0.5651111773145481, 0.5138006167731689, 0.5290931315072478, 0.577008539300814, 0.5861381610373163, 0.5616046350421503, 0.5395548703319151, 0.16439330381398054, 0.11119695370084115, 0.1087363289856419, 0.13701230882946314, 0.11342332381881459, 0.13145748836890603, 0.09128581872658958, 0.13122809629025145, 0.19729155549994837, 0.22018211916686525, 0.14680161586249274, 0.2420000955624908, 0.18229871895155358, 0.1749883387511978, 0.1369999550728921, 0.17428378063033145, 0.18046803970340752, 0.27310084660107237, 0.3617013791491086, 0.5194540354334733, 0.48556546702506354, 0.3683027793860536, 0.546868649105985, 0.4995237395049824, 0.4516149766034415, 0.6043485003478759, 0.3257683865017368, 0.29302186025296273, 0.24530710818590495, 0.22873180238334034, 0.33485489179163763, 0.20300310485084616, 0.2357934452006999, 0.30110136821061684, 0.1930517825430087, 0.23477379009963328, 0.23569836306866288, 0.235514589964405, 0.20394699238556746, 0.1986261760989031, 0.21412072237638435, 0.2113743225416148, 0.20456831115188912, 0.22352824295263551, 0.21891795354934074, 0.21954494044851824, 0.6353190870313263, 0.2398572504567551, 0.19025445738991853, 0.7113833479880352, 0.23445874249237786, 0.21988697796660395, 0.2145366393811673, 0.17037940189177458, 0.18595906131336015, 0.18460718592076997, 0.2019935722973517, 0.14688175663479774, 0.14743156385990153, 0.8568777237863525, 0.15066519604545925, 0.1629130542752356, 0.08271118536048938, 0.20826530309705737, 0.2063295005402498, 0.7697455379563836, 0.7635743550077068, 0.1668373903173741, 0.6812628336598567, 0.16677970473347703, 0.12791096623884146, 0.1768880019342257, 0.18285567550477522, 0.18270530546016117, 0.17035478481337918, 0.1963371425981687, 0.18248622966323957, 0.17879681112820867, 0.18132158265959042, 0.17896043823711594, 0.08464896972895608, 0.08092033607542559, 0.0901852139103817, 0.092298415852753, 0.08733057602097505, 0.08673599675956467, 0.08789880394367477, 0.09497382984887859, 0.1133368224293183]}, "mutation_prompt": null}
{"id": "dbf3da30-e2af-4c2e-97bf-9b4453bca849", "solution": "import numpy as np\n\nclass QuantumAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced population size for efficiency\n        self.F = 0.5 + 0.1 * np.random.rand()  # Variable Differential weight\n        self.CR = 0.8  # Slightly adjusted Crossover probability\n        self.w = 0.5  # Slightly increased inertia for a balance\n        self.c1 = 1.5  # Adjusted cognitive learning factor\n        self.c2 = 1.5  # Equalized social learning factor\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.q_tunnel_prob = 0.05  # Probability for quantum tunneling\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Randomize within a narrower range\n                self.CR = 0.75 + 0.15 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n                # Quantum tunneling\n                if np.random.rand() < self.q_tunnel_prob:\n                    tunnel_candidate = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    tunnel_fitness = func(tunnel_candidate)\n                    evals += 1\n                    if tunnel_fitness < fitness[i]:\n                        self.population[i] = tunnel_candidate\n                        fitness[i] = tunnel_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "QuantumAdaptiveHyDEPSO", "description": "Quantum-inspired Adaptive Hybrid Optimization integrating Differential Evolution and Particle Swarm with Quantum Tunneling for enhanced exploration.", "configspace": "", "generation": 59, "fitness": 0.3232244652829428, "feedback": "The algorithm QuantumAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8446287330372299, 0.8637313154236838, 0.8475649190606995, 0.8311721714975582, 0.8476302195090928, 0.8516772006139023, 0.846548644905494, 0.8506488164653752, 0.8544219971416827, 0.7069113015213657, 0.70321049074679, 0.6732146212413945, 0.6805291880502773, 0.7057599932221643, 0.7286144758131833, 0.6954288789651717, 0.6927771566783935, 0.7072215427422548, 0.13079515959478227, 0.13659894850963938, 0.12747090159901386, 0.11852600506403355, 0.1290751207398907, 0.11241543181552494, 0.15328393801685813, 0.17355072261489024, 0.09702086693473344, 0.08994039720538549, 0.13695358741329455, 0.10207156281966456, 0.11252788223996646, 0.12661547541204765, 0.10193635237211784, 0.13521604846689805, 0.10528135673791894, 0.13857715037624274, 0.9383209285023988, 0.9550520079765376, 0.9564156805638393, 0.9370460822839393, 0.9586202784405775, 0.953028949826305, 0.9490780724947776, 0.9447909917066898, 0.9446552719008403, 0.657648133269843, 0.6831301754783038, 0.6639736181567488, 0.6870923270763156, 0.6766745023703385, 0.6515900880724746, 0.6413086989712451, 0.6362780269102383, 0.6313062282588685, 0.8623106064041511, 0.22164322776329282, 0.22459486984071064, 0.28089304948175664, 0.27728264140502856, 0.27150867840459125, 0.34815263117473794, 0.824686603851793, 0.23124664440729725, 0.20541134284681628, 0.21962440340910128, 0.2211566632941092, 0.2106605764183077, 0.2073492052616447, 0.20839374587830906, 0.12965143071451035, 0.21530153574965438, 0.2108474826028618, 0.21095772404199176, 0.21082667627940366, 0.13260734161713594, 0.22789565831843595, 0.22592768607052316, 0.21395837674638918, 0.2629168956427663, 0.24763201716069994, 0.12909909797777308, 0.036627506553021494, 0.02110633626294567, 0.06886718475664566, 0.005401193321019182, 9.999999999998899e-05, 9.999999999998899e-05, 0.09484022653476676, 0.00013444762156178403, 0.005014375833046647, 0.05391069460071485, 0.09219039620379332, 0.09687201340114948, 0.05248905107779245, 0.04785264375651099, 0.09226843688063568, 0.08398217744667114, 0.10015074510865274, 0.07100373924156234, 0.10969482632424588, 0.08423460254108572, 0.09260711073081407, 0.16281441544614428, 0.08404493663854751, 0.20285735935781402, 0.18820124868694033, 0.1333918460062571, 0.09493183991112841, 0.18718641732850405, 0.09112867003788505, 0.11717447368394218, 0.08744460602402848, 0.08551265024853871, 0.127173406406771, 0.11741132754507377, 0.28056791989664687, 0.07788412379488285, 0.5402951288169602, 0.5545730370862034, 0.5294279974581125, 0.5618815815823084, 0.5420945241272814, 0.5901980099323627, 0.5457450244920994, 0.5657504290937723, 0.5723017696295771, 0.12173432943422535, 0.09228085165950273, 0.10386063048428773, 0.11820692094050478, 0.1367573701296111, 0.14636225045216977, 0.1597386037461962, 0.1525237723891163, 0.1068551541999101, 0.2926906932920832, 0.6092516684077868, 0.33366944530904297, 0.35429967554357067, 0.18164929950459396, 0.4115344638781896, 0.5692259549495522, 0.25949489745497856, 0.5180770034247566, 0.5140713730138344, 0.5760735093059763, 0.4498541947481939, 0.5977692345712352, 0.33504101260900354, 0.5743469961667362, 0.5957736497895862, 0.28432032380930006, 0.25452508696027776, 0.22255535869273524, 0.30897967455184516, 0.3812673971224816, 0.4037871747090708, 0.25625155316992376, 0.3299308134274269, 0.25144380934385047, 0.27868822085377654, 0.2736219340937187, 0.23793618709478492, 0.2278395105408455, 0.21138062964026794, 0.2254999714726572, 0.22144077005653884, 0.24042890904666836, 0.21694030889204008, 0.23542945035560958, 0.20719175101353193, 0.21645323474412492, 0.23839475771589125, 0.22336191049190923, 0.21968413111085583, 0.6691697047163729, 0.7073885173757517, 0.20694729721674376, 0.19393519674519522, 0.24351182158120932, 0.18657175924222014, 0.15617356159619755, 0.1879960435535386, 0.1682384577988698, 0.19900962256116062, 0.16894699078231556, 0.15187236774242996, 0.8866025184442929, 0.17547101354700823, 0.15405601722890128, 0.20805515534426167, 0.6109395080111077, 0.1540025440031001, 0.6584229037100395, 0.1683124683181335, 0.15411559944718978, 0.14634528156237536, 0.15529764687482417, 0.21094023641855852, 0.17894560770257462, 0.18371900759669058, 0.19800083386300715, 0.18805272509969595, 0.19306423886377366, 0.19414118544513592, 0.1857663215763251, 0.19174793962678605, 0.1070885993374675, 0.07557215245616733, 0.08917719607744168, 0.07429969372015566, 0.0956786292307612, 0.08278048033341001, 0.10054459437775698, 0.08613298527057145, 0.08341835138024711]}, "mutation_prompt": null}
{"id": "900054c4-621d-47e4-99f8-936f63665971", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly larger population for diversity\n        self.F = 0.5  # Adjusted Differential weight\n        self.CR = 0.9  # Higher Crossover probability for more combinations\n        self.w = 0.3  # Reduced Inertia weight for faster convergence\n        self.c1 = 2.0  # Increased emphasis on cognitive learning\n        self.c2 = 1.0  # Slightly reduced social learning emphasis\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Larger velocity clamp for wider search\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.3 * np.random.rand()  # Randomize within a range\n                self.CR = 0.8 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < func(self.personal_best[i]):\n                        self.personal_best[i] = trial\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Dynamic Hybrid Optimization using Adaptive Differential Evolution and Particle Swarm with Enhanced Exploration-Exploitation via Adaptive Parameters.", "configspace": "", "generation": 60, "fitness": 0.3119748669120324, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8619051859763556, 0.8503941520907273, 0.8537863224649769, 0.8558466973295558, 0.8559299489455412, 0.8598837512142108, 0.8548246447399205, 0.848751435863935, 0.8595480463901924, 0.3592448660362293, 0.11309831301945228, 0.7374506273727842, 0.19134742688524897, 0.22279490641697786, 0.7209786328361534, 0.701478569655799, 0.27714492345315767, 0.5895673946276951, 0.13382384631307598, 0.13853518266378173, 0.6420465212909843, 0.13764321206716779, 0.14981143915799144, 0.14022916887634895, 0.1376020521087863, 0.1490267252430516, 0.17272134311299048, 0.13312284571520072, 0.09488222069833296, 0.11030288407962685, 0.10382991143076159, 0.10501012867621762, 0.12529942928983018, 0.10994843190694648, 0.13699877230869983, 0.1395347800311405, 0.897907985526863, 0.4129737341787726, 0.886774286823591, 0.9372909812874598, 0.8373949615458985, 0.8735891985904108, 0.9224737358741294, 0.9573310212500128, 0.9375226568796419, 0.6366685563100811, 0.6880766616715728, 0.6285536329471364, 0.6230805452878582, 0.2840205959734049, 0.6691883469954485, 0.6730172953079638, 0.4999854719458928, 0.3002185852684006, 0.22411130875926266, 0.8197490709890108, 0.22057528208111532, 0.35778464286801615, 0.2713371111147561, 0.21553439883088832, 0.16449224491035874, 0.3859748145011527, 0.23311225693243243, 0.14329868757344644, 0.14644461437134682, 0.15089679869692751, 0.18887205097571413, 0.1274144807767954, 0.16831116292419845, 0.1493856758283657, 0.1379571909950562, 0.16412051971686392, 0.13632474418002294, 0.12901377411951565, 0.17437336677503879, 0.19985669916449555, 0.13816072130652535, 0.1595028451234055, 0.16993935504389823, 0.19223057393918752, 0.1818020967869316, 0.00840259153817402, 0.034361424644437255, 0.04259054772707915, 0.13853236130937208, 0.07458105306562379, 0.017828659227325794, 0.02878551278864161, 0.00807234196939921, 0.010301174016799863, 0.1327324780523741, 0.09453363711434881, 0.13042239688909651, 0.09087165131833685, 0.03541997210034242, 0.10414222774861792, 0.07104965993345935, 0.12898049650454524, 0.21120379456990013, 0.12474191017322733, 0.1516913088689953, 0.05505366462785555, 0.0856895948504458, 0.2871094481662567, 0.10755763899679915, 0.0841608062661191, 0.11676639320801319, 0.15011368412157156, 0.1107458232603089, 0.18237761435764144, 0.08609999109750277, 0.08679003281749387, 0.05127620695598811, 0.13222206993589003, 0.09068965787288796, 0.11844612350069306, 0.08337294869777434, 0.6011631816320907, 0.5526807571609373, 0.545337068609385, 0.5581810408424541, 0.5577258998119778, 0.6083007900432185, 0.5798638877249835, 0.5848972192802391, 0.5743809013823378, 0.08284152201094253, 0.14489563982585552, 0.102687821523061, 0.1146322585632803, 0.13703933755471975, 0.1743045431507062, 0.11633926558801455, 0.13481381991585617, 0.13935169219378474, 0.15513991684848039, 0.2208480601127336, 0.22692891482515354, 0.31168979114926765, 0.24020160060227957, 0.19968399732889908, 0.42260931446699546, 0.41865004456333355, 0.28821186476498484, 0.31487735470401634, 0.647683209109402, 0.6395136015521119, 0.621471699793498, 0.2890279379698534, 0.5803904251870124, 0.6578529222821876, 0.46542325943422924, 0.4986341422094276, 0.32907590824044286, 0.2949197185248761, 0.24732802613914562, 0.3568002717507439, 0.2596387833066378, 0.40527911719265797, 0.1981681837798338, 0.2339444633546499, 0.2404189380413544, 0.21954908236101012, 0.23260534512544884, 0.3206386231791952, 0.20842441526614497, 0.21600381141346447, 0.22546189292199603, 0.21997911216956156, 0.21577030370868322, 0.24082819737765682, 0.20377301955854232, 0.20581265442369812, 0.22054892605836507, 0.1972780327765703, 0.21487536590417355, 0.24006518856882553, 0.20652098025114674, 0.2035408739009923, 0.6561121761321319, 0.8976574235508804, 0.18535518320493516, 0.8678287794988264, 0.8996100826493465, 0.8726573073229973, 0.1991077191422922, 0.1227549017631383, 0.14121722236383571, 0.15486603946868038, 0.6926402027639931, 0.2102056647207302, 0.4695353125222085, 0.2098298266172245, 0.314267348006416, 0.16921363356513752, 0.1637904572906611, 0.6247628311600997, 0.738675773253165, 0.17881880358058133, 0.19329388307978723, 0.19337662586159898, 0.17717794095354567, 0.17422511947434938, 0.1913625324569248, 0.19324740998532453, 0.18485851967893951, 0.1846604580683402, 0.08528143264540722, 0.09827764898332536, 0.10776174365071622, 0.09351565855553912, 0.10219117674673495, 0.11199737894788264, 0.09834342809954799, 0.08817057629063818, 0.11569271039713458]}, "mutation_prompt": null}
{"id": "79e7aaaf-ccce-40f1-bf20-76068f717294", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = 0.5 + 0.1 * np.random.rand()  # Randomized Differential weight\n        self.CR = 0.8 + 0.1 * np.random.rand() # Slightly adjusted Crossover probability\n        self.w = 0.5  # Adjusted inertia weight to balance exploration and exploitation\n        self.c1 = 1.5 # Balanced cognitive learning\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.temperature = 100.0 # Initial temperature for Simulated Annealing\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation with Simulated Annealing dynamics\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Simulated Annealing acceptance criterion\n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.personal_best[i] = trial if trial_fitness < func(self.personal_best[i]) else self.personal_best[i]\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n            \n            # Decrease temperature\n            self.temperature *= 0.99\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization with integrated Simulated Annealing dynamics for improved exploration and convergence.", "configspace": "", "generation": 61, "fitness": 0.1930691782712857, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.31085802131930484, 0.2910182280538739, 0.30068322616793053, 0.34130574580968, 0.29836269198591725, 0.2716198444037776, 0.28751331013599457, 0.28299765706421476, 0.2955360081694802, 0.16796759202435008, 0.1869499096506817, 0.1653613071492771, 0.16823776666170165, 0.16655775508971726, 0.16085547539035105, 0.1440279195893438, 0.18183205531470714, 0.16920137073187214, 0.0941209500491299, 0.0796736061826947, 0.08230571062121794, 0.08519241434525027, 0.09722722883148094, 0.09296015091285315, 0.08022012153210634, 0.08303198702313963, 0.08776896017812108, 0.07787289493957472, 0.09385701610961517, 0.09706100649240323, 0.07715652290903274, 0.08017215662516042, 0.09068583021106502, 0.08271928125701089, 0.102979984443062, 0.08537165024942117, 0.9060616693618745, 0.92683886476817, 0.9340255378242186, 0.9005275769951963, 0.8925143744924262, 0.9100855298627158, 0.8896753097129271, 0.8913114413879221, 0.9002746845328238, 0.26967449191718806, 0.28564271783632844, 0.27239858221508795, 0.2626680493318112, 0.25528752721015513, 0.30005021395997256, 0.2863696427424397, 0.30390005880133497, 0.2989905602722912, 0.18690996907084878, 0.21138857529901411, 0.22710164611084194, 0.2579210608355179, 0.21024131689456993, 0.2361508185051614, 0.21769492916085809, 0.2521261397931428, 0.2539432847401558, 0.12878618824364074, 0.12905037138959674, 0.1450036791353383, 0.14275283073444023, 0.16792651594532726, 0.14047585240542793, 0.14281322859036372, 0.15952525913585724, 0.13461278824864753, 0.1675178381897916, 0.13780945978057357, 0.1610911943190465, 0.14355560782538745, 0.14787897068337097, 0.14540011599670521, 0.13515411267765942, 0.09829386686181807, 0.14705881804701748, 0.020518395252683508, 0.04950406607726565, 0.0027744269443017444, 0.018045152675149057, 0.009802564032292294, 0.0005198752109909499, 9.999999999998899e-05, 0.05531023939908697, 0.000715792583736774, 0.07521727586930116, 0.0975309219667182, 0.20625989153187285, 0.11328639582650535, 0.06089803480624356, 0.03968584403483988, 0.11767489165072043, 0.07465464796641497, 0.1129172660150971, 0.14391486329258696, 0.1552571609590392, 0.045941071305613645, 0.08135779609695037, 0.09017787024339063, 0.08206810606666404, 0.09043499259890375, 0.09940433321171604, 0.14083044962841107, 0.06837833519932335, 0.0780710768789411, 0.07685164811196432, 0.07322124993889245, 0.08804547219021674, 0.06935986714369158, 0.08239695424301263, 0.05741022635837767, 0.07452217411774475, 0.2834810387724911, 0.29994922595747364, 0.2884528143936361, 0.29444027891022906, 0.2936300718955873, 0.2970147839126679, 0.3041946193804884, 0.30823558215172275, 0.29595444009008187, 0.07942672137655393, 0.09508639486308201, 0.07967978214203653, 0.0792723398702061, 0.0869205452596209, 0.07793674067245593, 0.08590422180468704, 0.08759488330815857, 0.08139433949063135, 0.13408497095232197, 0.11879480210034032, 0.12603926535138887, 0.13974053389644048, 0.12633470998490426, 0.13011640351189746, 0.11838904365734049, 0.11556492420846665, 0.1370202274681076, 0.22881939471707868, 0.22453929992338206, 0.2169663006122935, 0.22927703090557172, 0.22847341229297757, 0.21193877016136164, 0.2261107267059188, 0.21323603298860783, 0.20962158664163733, 0.16089996319786404, 0.16031102254821528, 0.16125323258845803, 0.17283322307701654, 0.16940785918139067, 0.1730802459169567, 0.16764129890681156, 0.1720644744890515, 0.15622414522661532, 0.2070580251818872, 0.18213508670949807, 0.221821118589292, 0.18891417058462767, 0.1827831778380793, 0.19244247473627296, 0.2204423159836889, 0.19366577083472936, 0.18097104763717753, 0.18579948966825077, 0.17672222276528426, 0.20240995811926044, 0.17995975665949704, 0.18513762334821382, 0.17601382795611897, 0.20471090408195747, 0.1825883153288025, 0.19338682467728618, 0.17967853352756524, 0.16964156318626833, 0.1766948713422194, 0.18180114078940368, 0.18286776541027727, 0.34064013147018135, 0.15727207137549215, 0.34822655802727187, 0.1549791176410843, 0.18938235914776458, 0.3061561310288534, 0.1647792015653986, 0.251275900923133, 0.367312123043945, 0.1390489302853235, 0.3272773260584506, 0.3425155046400893, 0.14908011073322636, 0.1805750179461818, 0.1846372718055842, 0.17420713846919644, 0.17107135786200234, 0.18642659791955785, 0.17417254594636344, 0.1715946354702672, 0.18831001423945515, 0.18314487702942162, 0.07868230465337944, 0.08203828530245061, 0.09836454985018395, 0.07450555770813139, 0.08564512311813921, 0.06911143720336188, 0.07384139537896894, 0.07554395476077591, 0.08932330667601096]}, "mutation_prompt": null}
{"id": "7c1add7b-ad0e-4545-80c1-708afa637045", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Large population for diversity\n        self.F = np.random.uniform(0.4, 0.8)  # Wider variation in Differential weight\n        self.CR = np.random.uniform(0.7, 0.9) # Slightly wider crossover probability\n        self.w = 0.5  # Balanced inertia weight\n        self.c1 = 1.5 # Slightly adjusted cognitive learning for balance\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Further increase in velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Adaptive Strategy and Confidence-based Search.", "configspace": "", "generation": 62, "fitness": 0.3500932596873941, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "987bf8f0-b711-4d5d-a7f2-c7c3bf2b70a7", "metadata": {"aucs": [0.8865070555711643, 0.8757487028477543, 0.8775493866891063, 0.883605938904218, 0.8737454560895896, 0.881927769350898, 0.8871249488120752, 0.8722992287444463, 0.883807452518728, 0.7717413795093288, 0.7674682987844863, 0.768058305409878, 0.7512174101170309, 0.7610168184756897, 0.751453722280385, 0.7648425940326775, 0.746598679451494, 0.7785747924390123, 0.6953928634143988, 0.16980858522769926, 0.13665700476120768, 0.14042999786412036, 0.17061247311757743, 0.15218464267760157, 0.6811858256330012, 0.5809270417925839, 0.11307840247732315, 0.12576646912622114, 0.13879384104958026, 0.14956750069943103, 0.13509483829599012, 0.13532877559546252, 0.11112843755540414, 0.10545684226529939, 0.12144290387188761, 0.1131587072472705, 0.9737319716857231, 0.9774455021948065, 0.9728919973095774, 0.9721413541490507, 0.9716829293034545, 0.9777847890586789, 0.967537822453255, 0.9767763712270838, 0.9771928098437072, 0.7232828555184807, 0.7062847509083255, 0.6685364761801085, 0.7015105499090053, 0.6992109092902872, 0.6969379595484717, 0.6670274319920089, 0.6443439528007091, 0.6859232937950777, 0.16882076947028146, 0.3660433732582943, 0.8372978929004482, 0.21123874580684654, 0.8910797757523908, 0.21257782381000911, 0.3862588531186941, 0.23386430428896954, 0.8570314647277812, 0.22911524713097875, 0.2168234896046527, 0.22821024477911955, 0.24844280607586433, 0.24673854884633428, 0.2258365825894495, 0.20764005019541987, 0.23135352736809478, 0.12992324745275086, 0.12184935188016877, 0.23894541961354177, 0.19894766697449995, 0.24519592609843233, 0.20284827864119348, 0.22768269067108193, 0.26820714278339697, 0.10478482300248637, 0.27368954479734675, 9.999999999998899e-05, 9.999999999998899e-05, 0.10577114646272912, 9.999999999998899e-05, 0.0023380217855026864, 0.055939973319716785, 0.0027729964483665936, 0.08574717503600282, 0.10005997518839738, 0.10210659842686787, 0.10962245018560357, 0.05991788863715397, 0.07665600266041295, 0.032186765124977534, 0.04841816647301034, 0.11385938705177356, 0.1735159252016174, 0.11855926683382534, 0.16712978873181694, 0.049958197076165556, 0.13886977605354967, 0.07789995211817913, 0.142861610585446, 0.09971502794551379, 0.12898089107491228, 0.09480863751304036, 0.07196666429064447, 0.16662523763685133, 0.14402308502490668, 0.16078265233031364, 0.06364992217922905, 0.0810649024886223, 0.0877012467453151, 0.12969802734302815, 0.22248090184543012, 0.05694311721110645, 0.6404668040241892, 0.5976209934225178, 0.6062747057245319, 0.5455307841744248, 0.541722765794701, 0.6389711282346586, 0.5788309322703428, 0.6275249859167691, 0.5946176600613395, 0.12157124781620421, 0.14030569087187195, 0.13488472382838468, 0.17330677842997688, 0.13895183513101672, 0.10837671111227609, 0.14424832149418176, 0.1380939225156146, 0.12264377415490801, 0.5356425708380808, 0.23924621628482423, 0.29216938320019314, 0.3255639823366897, 0.19550667688838486, 0.6875186764560267, 0.5057028004051591, 0.2510649322450238, 0.2381981511043637, 0.49733907348957596, 0.5802435894446938, 0.2399480839880479, 0.48322407701573944, 0.3714858567017888, 0.3324811223264097, 0.6286991505866144, 0.5278512435549774, 0.5846991173322131, 0.18676793312235362, 0.18870334634246244, 0.28023552722504486, 0.27894535632254824, 0.32807831760860695, 0.1580373847871006, 0.2106182371597799, 0.580613274675602, 0.32135965686418266, 0.20144365472605108, 0.22559189123221046, 0.21531389679342317, 0.2004193255337413, 0.19659189758078066, 0.23151770455253595, 0.1914955900616917, 0.20619646464539731, 0.2240168779685895, 0.21040243671219183, 0.20706758521103918, 0.7251167719170813, 0.6216715113861038, 0.20105233904865838, 0.24137670871118866, 0.22305152490433544, 0.7225380790852707, 0.2153228772264013, 0.11268522610657639, 0.17656185375544886, 0.1874299851371808, 0.19864610952855588, 0.14715852749142155, 0.919750376047302, 0.1307648726585996, 0.13573354882319566, 0.15275703642338834, 0.8153330355968438, 0.21211485412333286, 0.21052448212220753, 0.16835123616939962, 0.10216976862638782, 0.7655914243705766, 0.11294144249404148, 0.8215631438385649, 0.8215696486735155, 0.20002850047733822, 0.18973284990848682, 0.18365694342118777, 0.17372339581252927, 0.18433806904810857, 0.17257810788424155, 0.1869866692709906, 0.19410294244313786, 0.18204163712112087, 0.09164645072204003, 0.08887110119920094, 0.08798424699705087, 0.11304713079140127, 0.08329012630638011, 0.08900776547279188, 0.0961995681088762, 0.09492229904834604, 0.10933928733987464]}, "mutation_prompt": null}
{"id": "92f2698a-d602-4d25-8dbf-297860bce1d0", "solution": "import numpy as np\n\nclass DynamicAdaptiveEvoSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Adjusted population size for faster convergence\n        self.F = np.random.uniform(0.5, 0.9)  # Adjustable Differential weight for more exploration\n        self.CR = np.random.uniform(0.6, 0.8) # Crossover probability tuned for better exploration\n        self.w = 0.4  # Lower inertia for more responsive particles\n        self.c1 = 1.7 # Enhanced cognitive learning\n        self.c2 = 1.3 # Reduced social learning for individual exploration\n        self.velocity_clamp = 0.1 * (self.upper_bound - self.lower_bound) # Reduced velocity clamp for fine-tuning\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic and np.random.rand() < 0.3:  # Probabilistic dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.6 + 0.2 * np.random.rand()\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "DynamicAdaptiveEvoSwarm", "description": "Dynamic Adaptive Evolutionary and Swarm Algorithm with Probabilistic Strategy Update and Context-Aware Adjustments.", "configspace": "", "generation": 63, "fitness": 0.34611645301544847, "feedback": "The algorithm DynamicAdaptiveEvoSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.9213064434033258, 0.909691134619502, 0.9223916505206202, 0.9049180349154959, 0.9083415164020653, 0.9147852749524272, 0.9231107866364794, 0.9059746303845032, 0.9112073767978649, 0.8394526108577843, 0.8332602626527619, 0.8378936192969828, 0.8307739382671585, 0.8360921951981308, 0.8349619527587605, 0.8389988293152301, 0.8221997374210401, 0.8247505815053079, 0.6443733664815572, 0.518213593163295, 0.1573719301269959, 0.15571457559770274, 0.7510167327451366, 0.17712576569918548, 0.13579169913041278, 0.17698992499898158, 0.09164609786079725, 0.08689191941951036, 0.11494147614566697, 0.13905661560852334, 0.09925958280911795, 0.10751073674329381, 0.1589910840412998, 0.13253701842518972, 0.14273643741955022, 0.0950629142550371, 0.9558591439952062, 0.9723420745195582, 0.9513714652041653, 0.9742884516653679, 0.9634917701419942, 0.9687650385287158, 0.9713560012871933, 0.9654675751237604, 0.9535116607998118, 0.7645928186410689, 0.7696811924986061, 0.7725267608900577, 0.7881833853302842, 0.748985345804156, 0.7647697650654269, 0.7433492256768116, 0.7510982428992179, 0.7606731011593624, 0.37588554164699794, 0.8764988282218107, 0.22513993481897954, 0.379676724518474, 0.2754967030396134, 0.21222253423232473, 0.22614888363500252, 0.38542028939237993, 0.22326106911591626, 0.3399380703220002, 0.18767025470691634, 0.20036212934020314, 0.24615424390742302, 0.13027882720646466, 0.21047836125799646, 0.12331284671184695, 0.21325627170438777, 0.2171558660431835, 0.18618249647946428, 0.1868553197269549, 0.13305179417270863, 0.13403891140473767, 0.217155456584877, 0.1349827705483343, 0.25267501346285526, 0.24472944692919163, 0.25338851577512433, 0.03051337672259191, 0.017651923025402194, 0.0407921469974466, 9.999999999998899e-05, 0.05537908148652915, 0.051202564988339194, 9.999999999998899e-05, 0.04311535786887011, 0.169236207472091, 0.061686595309214276, 0.13390346885353632, 0.17294790029160845, 0.0621178462680364, 0.07521122931304891, 0.06793265139880478, 0.0913813471231395, 0.09150038250887738, 0.09143897954602509, 0.18543851640748132, 0.17660716023604905, 0.17784906455842064, 0.24907249690224442, 0.2211050300426245, 0.09811073989883057, 0.23395374324387908, 0.19928848064930094, 0.1723406090593469, 0.21497137840797298, 0.2383475568083554, 0.15727262893673888, 0.1203618146047869, 0.17601345727841977, 0.13082462384844706, 0.08839761573220839, 0.22376979722674617, 0.1986989453732677, 0.6220854914027992, 0.5830256081337446, 0.5963789234566604, 0.547458012259793, 0.5719913809311898, 0.5780325524401451, 0.5832908474523626, 0.6529287603344813, 0.6187961518926945, 0.15944442895754396, 0.11247206909915786, 0.12151170756889351, 0.1357002530701963, 0.11379507356162355, 0.13772475581872912, 0.1290885371349061, 0.17598962652918837, 0.14856352627714864, 0.38985990121297043, 0.17547227246139596, 0.2280896407666856, 0.35026736063887387, 0.2661318046474206, 0.31365586457422356, 0.591734196598652, 0.21185717314538477, 0.22646684613745127, 0.7803366898804514, 0.32063027357869844, 0.5832266217741646, 0.34632233200531215, 0.4237738667161163, 0.6053351162193927, 0.48064222407408486, 0.5917210610968393, 0.4915189192744214, 0.2771975222551437, 0.22725525004939728, 0.2749459551807445, 0.31757449096297163, 0.2507456241909034, 0.261402225122781, 0.3863264121843911, 0.3162102830728202, 0.20047331164820192, 0.20687532291938582, 0.21845703230923053, 0.22468252091586716, 0.2037150616870156, 0.25222023126266535, 0.2118171873389566, 0.20340084014585524, 0.20754155190251378, 0.21840234686433702, 0.20648372732328402, 0.22187558086628, 0.22467935546668005, 0.22203004055796172, 0.19710025447461066, 0.21541740121818342, 0.22016782067688057, 0.20115243630373336, 0.19084490051190273, 0.1675572170000098, 0.1874102384680354, 0.1755663358928381, 0.9149243081933566, 0.8990845995036164, 0.19990206770923502, 0.17605204972770194, 0.9137971191296014, 0.19789284983201194, 0.12653879965745962, 0.16969142101122092, 0.2109679514322531, 0.1673241518731493, 0.20898835478644417, 0.2106845617896227, 0.1629484595769396, 0.21223220289692246, 0.21205578526825408, 0.1853283816543586, 0.1851983884847619, 0.18333114037942566, 0.17637461219169348, 0.18922856872582028, 0.18592233142349812, 0.18536882486267214, 0.1815217862295443, 0.18196751400589672, 0.08526535202342744, 0.09312362301100441, 0.09241772950068805, 0.08793235517861886, 0.09688124224382977, 0.08974332215865177, 0.09189451504749535, 0.085355219108048, 0.09065902371995527]}, "mutation_prompt": null}
{"id": "2c397bdd-8a82-483d-acd6-0ef274d535f1", "solution": "import numpy as np\n\nclass AdaptiveSelfTuningHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = np.random.uniform(0.4, 0.9)  # Broader range for F\n        self.CR = np.random.uniform(0.6, 0.95) # Wider range for CR\n        self.w = np.random.uniform(0.4, 0.6)  # Randomized inertia weight\n        self.c1 = np.random.uniform(1.3, 1.7) # Diverse cognitive learning\n        self.c2 = np.random.uniform(1.3, 1.7) # Diverse social learning\n        self.velocity_clamp = 0.4 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.4 + 0.5 * np.random.rand()\n                self.CR = 0.6 + 0.35 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveSelfTuningHyDEPSO", "description": "Adaptive Strategy Self-tuning for Enhanced Hybrid Optimization utilizing DE and PSO with Probabilistic Exploration.", "configspace": "", "generation": 64, "fitness": 0.3329233732246446, "feedback": "The algorithm AdaptiveSelfTuningHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8496213547635534, 0.9010462306383514, 0.8475141253458498, 0.8651046138394698, 0.9049568551560347, 0.8650519702221131, 0.8631295853314138, 0.9094123898885522, 0.8616936745658119, 0.7179540772227232, 0.8004985506654717, 0.7158311829464918, 0.7177445057826154, 0.7994336141061733, 0.6927439918572995, 0.6857425218564863, 0.8079167224208734, 0.6777905069157573, 0.6902411821889574, 0.1548658159040649, 0.45926943950560983, 0.17832245703255756, 0.1373365494943959, 0.07360721246147406, 0.1689623107156536, 0.13578298982334203, 0.11777668258743412, 0.11699254880889043, 0.16513045105301194, 0.14028698120682515, 0.14729715305530644, 0.13513700537140627, 0.14846796524207329, 0.1154357969536215, 0.15582278513755476, 0.11720033271633001, 0.9687238318720374, 0.9875627209460647, 0.9724368548698241, 0.9710383735522881, 0.9745051461285826, 0.9762064224381126, 0.9819994695915316, 0.9723340117682739, 0.9772929035256244, 0.5957561230690052, 0.7653139863208394, 0.6511218326141512, 0.5827504870927671, 0.7375672285414492, 0.6392754157913014, 0.6361176117164157, 0.7534187284578857, 0.6478658492176952, 0.35790886957474977, 0.22621976369148855, 0.822620362451368, 0.19181304699549018, 0.9076142413579765, 0.21893740603712708, 0.2339711612581783, 0.21928272151953843, 0.2321141842064367, 0.2309767657035512, 0.2094814534963897, 0.21426210474153495, 0.20978908926356843, 0.20557326125759667, 0.22512073568595248, 0.20356654352885095, 0.13118872448903918, 0.204671074477486, 0.13121269335018637, 0.24989176492697895, 0.22973277525462188, 0.23391862867038649, 0.258111953896513, 0.22598127018887204, 0.11991793278213136, 0.274826975095093, 0.24242505437398543, 0.023930223089909664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11058541584306658, 0.05888364060628226, 0.002641599932907357, 9.999999999998899e-05, 0.003955300542990536, 0.08619538188120046, 0.07321503261385132, 0.1106719027215215, 0.07203146980774944, 0.09988943572908515, 0.07374300824096425, 0.08941544343364716, 0.14102209168902413, 0.13380337002612308, 0.1764008216823546, 0.04202294967211384, 0.035597938061356804, 0.07530959600008935, 0.10708418034388778, 0.0913023290434779, 0.09701334022266639, 0.07544562127374632, 0.07905119574942199, 0.20346166152359746, 0.21619348823362483, 0.08825340083031663, 0.2027122802229051, 0.14668067238117788, 0.16861325397524762, 0.22507610564550007, 0.12184626843466084, 0.0842996269223617, 0.5145642706109703, 0.6421564745780206, 0.5487664397296476, 0.5813022672207836, 0.5807880505031224, 0.5469315255382649, 0.5798219383715504, 0.5897451831797971, 0.6133760214062596, 0.10233326116921959, 0.0946126641588928, 0.13558383222737935, 0.14989650007982258, 0.1772943925189404, 0.10935806057291686, 0.0837156293939344, 0.13678322834903012, 0.17013115551266378, 0.32557080908976, 0.3212866908477625, 0.44535358465485997, 0.14794083389391544, 0.32157925952502453, 0.5244074973396269, 0.15132517491954767, 0.2551783848163782, 0.14342017231620396, 0.5192157716450062, 0.5375243624109776, 0.4603883155965819, 0.2171662586101628, 0.42692046883836665, 0.4786543132674559, 0.621110747856243, 0.2801710668037607, 0.623730276138998, 0.38230718184894075, 0.33516967468159653, 0.26542235871353714, 0.20857697223898208, 0.22190668512236167, 0.26478346873909464, 0.35844612994964486, 0.296143050469151, 0.27121818959247435, 0.19343772209143195, 0.22024201643053232, 0.20613543891468056, 0.18766111749512648, 0.23342125661182644, 0.18679923340219662, 0.20654407377889006, 0.20690233125671897, 0.19723347337396113, 0.17983248184593126, 0.18926869964335635, 0.5543679468290813, 0.2029584250973686, 0.20560780463237693, 0.19411930066486616, 0.20475392437389828, 0.1867304212707671, 0.687957908003383, 0.16175892609560227, 0.9132990868710569, 0.1761179139964959, 0.8496191668908449, 0.17270704486703237, 0.18731109133688406, 0.13610989409832508, 0.11142939250375272, 0.15132862571095662, 0.529513591188272, 0.2121622781836403, 0.8367693537999334, 0.8116769320680414, 0.12762786457978326, 0.16729996821708137, 0.1279590888896167, 0.15572514094496837, 0.2119823636611715, 0.18127490285992376, 0.1796861891395951, 0.17609957468200577, 0.18183872476879903, 0.18295352170365042, 0.2085336093930158, 0.20461582313295623, 0.2092057256503438, 0.18346782206226364, 0.07735985538484924, 0.10050628282903085, 0.07892236826957488, 0.08729268793316824, 0.09396027456922706, 0.11138377037105618, 0.07286114099884067, 0.08722020814821096, 0.0875285050099186]}, "mutation_prompt": null}
{"id": "06f68448-5569-4d1c-8512-594343cd8907", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Large population for diversity\n        self.F = np.random.uniform(0.4, 0.8)  # Wider variation in Differential weight\n        self.CR = np.random.uniform(0.7, 0.9) # Slightly wider crossover probability\n        self.w = 0.5  # Balanced inertia weight\n        self.c1 = 1.5 # Slightly adjusted cognitive learning for balance\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Further increase in velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Adaptive Strategy and Confidence-based Search.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8865070555711643, 0.8757487028477543, 0.8775493866891063, 0.883605938904218, 0.8737454560895896, 0.881927769350898, 0.8871249488120752, 0.8722992287444463, 0.883807452518728, 0.7717413795093288, 0.7674682987844863, 0.768058305409878, 0.7512174101170309, 0.7610168184756897, 0.751453722280385, 0.7648425940326775, 0.746598679451494, 0.7785747924390123, 0.6953928634143988, 0.16980858522769926, 0.13665700476120768, 0.14042999786412036, 0.17061247311757743, 0.15218464267760157, 0.6811858256330012, 0.5809270417925839, 0.11307840247732315, 0.12576646912622114, 0.13879384104958026, 0.14956750069943103, 0.13509483829599012, 0.13532877559546252, 0.11112843755540414, 0.10545684226529939, 0.12144290387188761, 0.1131587072472705, 0.9737319716857231, 0.9774455021948065, 0.9728919973095774, 0.9721413541490507, 0.9716829293034545, 0.9777847890586789, 0.967537822453255, 0.9767763712270838, 0.9771928098437072, 0.7232828555184807, 0.7062847509083255, 0.6685364761801085, 0.7015105499090053, 0.6992109092902872, 0.6969379595484717, 0.6670274319920089, 0.6443439528007091, 0.6859232937950777, 0.16882076947028146, 0.3660433732582943, 0.8372978929004482, 0.21123874580684654, 0.8910797757523908, 0.21257782381000911, 0.3862588531186941, 0.23386430428896954, 0.8570314647277812, 0.22911524713097875, 0.2168234896046527, 0.22821024477911955, 0.24844280607586433, 0.24673854884633428, 0.2258365825894495, 0.20764005019541987, 0.23135352736809478, 0.12992324745275086, 0.12184935188016877, 0.23894541961354177, 0.19894766697449995, 0.24519592609843233, 0.20284827864119348, 0.22768269067108193, 0.26820714278339697, 0.10478482300248637, 0.27368954479734675, 9.999999999998899e-05, 9.999999999998899e-05, 0.10577114646272912, 9.999999999998899e-05, 0.0023380217855026864, 0.055939973319716785, 0.0027729964483665936, 0.08574717503600282, 0.10005997518839738, 0.10210659842686787, 0.10962245018560357, 0.05991788863715397, 0.07665600266041295, 0.032186765124977534, 0.04841816647301034, 0.11385938705177356, 0.1735159252016174, 0.11855926683382534, 0.16712978873181694, 0.049958197076165556, 0.13886977605354967, 0.07789995211817913, 0.142861610585446, 0.09971502794551379, 0.12898089107491228, 0.09480863751304036, 0.07196666429064447, 0.16662523763685133, 0.14402308502490668, 0.16078265233031364, 0.06364992217922905, 0.0810649024886223, 0.0877012467453151, 0.12969802734302815, 0.22248090184543012, 0.05694311721110645, 0.6404668040241892, 0.5976209934225178, 0.6062747057245319, 0.5455307841744248, 0.541722765794701, 0.6389711282346586, 0.5788309322703428, 0.6275249859167691, 0.5946176600613395, 0.12157124781620421, 0.14030569087187195, 0.13488472382838468, 0.17330677842997688, 0.13895183513101672, 0.10837671111227609, 0.14424832149418176, 0.1380939225156146, 0.12264377415490801, 0.5356425708380808, 0.23924621628482423, 0.29216938320019314, 0.3255639823366897, 0.19550667688838486, 0.6875186764560267, 0.5057028004051591, 0.2510649322450238, 0.2381981511043637, 0.49733907348957596, 0.5802435894446938, 0.2399480839880479, 0.48322407701573944, 0.3714858567017888, 0.3324811223264097, 0.6286991505866144, 0.5278512435549774, 0.5846991173322131, 0.18676793312235362, 0.18870334634246244, 0.28023552722504486, 0.27894535632254824, 0.32807831760860695, 0.1580373847871006, 0.2106182371597799, 0.580613274675602, 0.32135965686418266, 0.20144365472605108, 0.22559189123221046, 0.21531389679342317, 0.2004193255337413, 0.19659189758078066, 0.23151770455253595, 0.1914955900616917, 0.20619646464539731, 0.2240168779685895, 0.21040243671219183, 0.20706758521103918, 0.7251167719170813, 0.6216715113861038, 0.20105233904865838, 0.24137670871118866, 0.22305152490433544, 0.7225380790852707, 0.2153228772264013, 0.11268522610657639, 0.17656185375544886, 0.1874299851371808, 0.19864610952855588, 0.14715852749142155, 0.919750376047302, 0.1307648726585996, 0.13573354882319566, 0.15275703642338834, 0.8153330355968438, 0.21211485412333286, 0.21052448212220753, 0.16835123616939962, 0.10216976862638782, 0.7655914243705766, 0.11294144249404148, 0.8215631438385649, 0.8215696486735155, 0.20002850047733822, 0.18973284990848682, 0.18365694342118777, 0.17372339581252927, 0.18433806904810857, 0.17257810788424155, 0.1869866692709906, 0.19410294244313786, 0.18204163712112087, 0.09164645072204003, 0.08887110119920094, 0.08798424699705087, 0.11304713079140127, 0.08329012630638011, 0.08900776547279188, 0.0961995681088762, 0.09492229904834604, 0.10933928733987464]}, "mutation_prompt": null}
{"id": "ce6ffbe4-c716-473b-b636-fcf125b4bbc5", "solution": "import numpy as np\n\nclass AdaptiveBiPhaseHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Slightly smaller population for faster convergence\n        self.F = np.random.uniform(0.5, 0.9)  # Adjusted F range for better exploration\n        self.CR = np.random.uniform(0.6, 0.9)  # Broader crossover probability\n        self.w = 0.6  # Higher inertia weight for improved exploration\n        self.c1 = 1.8  # Increased cognitive learning factor\n        self.c2 = 1.3  # Decreased social learning factor for balance\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)  # Decreased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.local_search_prob = 0.3  # Probability of local search execution\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # Randomize within a range\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Local search phase with probability\n            if np.random.rand() < self.local_search_prob:\n                for i in range(self.population_size):\n                    candidate = self.population[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[i]:\n                        self.population[i] = candidate\n                        fitness[i] = candidate_fitness\n                        if candidate_fitness < self.best_fitness:\n                            self.global_best = candidate\n                            self.best_fitness = candidate_fitness\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveBiPhaseHyDEPSO", "description": "Adaptive Bi-phase Hybrid Evolution using Dynamic Strategy Adaptation and Local Search Integration.", "configspace": "", "generation": 66, "fitness": 0.31294320135130227, "feedback": "The algorithm AdaptiveBiPhaseHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.7875366104052703, 0.8013485802108903, 0.7879840271719352, 0.7870207834940518, 0.7912169081207503, 0.8060968438069401, 0.7649256624732911, 0.7630000300734749, 0.7872689015085786, 0.6106390190379852, 0.6192705759819194, 0.5876747882994534, 0.5863453377729303, 0.5973944417847109, 0.589963800800122, 0.6000078666715452, 0.5982356276980121, 0.6080995766189834, 0.14006723643337604, 0.15153786042419304, 0.1567177944524175, 0.14120654771584795, 0.12508888211348235, 0.13477851817261088, 0.15277846428930864, 0.09819172922806207, 0.11419102405902593, 0.1281220683362031, 0.11324336813255942, 0.11280376736369002, 0.11979040897487414, 0.10491092334443897, 0.12793024673035702, 0.10640090595650076, 0.09656568646156449, 0.09890610992086024, 0.9697490425899031, 0.9678540136520911, 0.9607657351114662, 0.9758565602332222, 0.9641832899831716, 0.9738247181739897, 0.9730298461813905, 0.9435203843403868, 0.9604206940138789, 0.4469232545205907, 0.356097445745326, 0.38868308340054747, 0.46208864743625633, 0.4025864228055799, 0.4506474541436849, 0.406275067410807, 0.39183169093335535, 0.41440266555171235, 0.6353803391179227, 0.22443259695974016, 0.7035618894519746, 0.7356734364278519, 0.7282041648521308, 0.21160284128712392, 0.6817255167757221, 0.6575208593153987, 0.7420989861392671, 0.1851459393587076, 0.17547947446246692, 0.18336234509944027, 0.1820221094602983, 0.19012660974531015, 0.30634799183582184, 0.18606852434555943, 0.1942636552893956, 0.22003887999008875, 0.18505582829589617, 0.18103888195592033, 0.16782412667723567, 0.19084842888684006, 0.18950565088024818, 0.18984534954209498, 0.20471244411061218, 0.21479078726591538, 0.2107008618432833, 0.011385817468431036, 0.018855503858029254, 9.999999999998899e-05, 0.04282004569389952, 0.014732948442308769, 0.028526175907248708, 0.027617238106978914, 9.999999999998899e-05, 0.015437818488840849, 0.15962556263743133, 0.07987012200893018, 0.1097795714629175, 0.10162708778938523, 0.09844884453609104, 0.05274400360009679, 0.11481714941850041, 0.08790657401770607, 0.10127064067657188, 0.060102811963592684, 0.028822812112201834, 0.05307793512959802, 0.05715865389345076, 0.06269644692515053, 0.10132635348278674, 0.11449928337566029, 0.114675087110934, 0.16425635131288796, 0.18906799108835703, 0.11585676789033494, 0.07924909080470355, 0.10439307315510482, 0.08191948897379675, 0.21052047061734613, 0.1358858716217164, 0.1372179070289261, 0.15757416075843844, 0.496515759185318, 0.49016661624018476, 0.48201491117721995, 0.5496749203864095, 0.5268741228704237, 0.5184849359859767, 0.49486068276202044, 0.5319706481626612, 0.5319255066295471, 0.11788251296476882, 0.1069413360327881, 0.11150826553315729, 0.11139741736578324, 0.12969624014782288, 0.11139105784951442, 0.10551157279840151, 0.11038904891651269, 0.10309964104399205, 0.15849301574798969, 0.20919661814515234, 0.1427447852422674, 0.16547413442102188, 0.14490564883704848, 0.19269597457588894, 0.2277863074610239, 0.18914215453921546, 0.17311450402162487, 0.47473203856810475, 0.3956212315054082, 0.4180706300676318, 0.500074471694776, 0.39143478723471525, 0.4234853719226217, 0.45869665496208856, 0.4695490287080225, 0.41957726041110777, 0.30150165265944495, 0.2070881328400873, 0.24633962389536457, 0.264028672997733, 0.276930411733013, 0.23304496327696778, 0.2545715825391277, 0.1997394335339926, 0.21697369146311052, 0.24293129185843154, 0.23097497473139506, 0.22260681005920258, 0.22547915011678699, 0.2020598728914207, 0.2355261823046244, 0.22100657647674504, 0.1950812433339607, 0.20863318312379897, 0.20444711973497076, 0.19539766671364145, 0.21059239272144692, 0.21624215133587688, 0.20059584622032423, 0.4498419791380809, 0.30212835421495865, 0.23849123323377208, 0.20066672427254384, 0.17111786852556543, 0.18455912097591975, 0.8224069346726701, 0.8067302745133116, 0.8226586903134155, 0.8943718429377239, 0.17764961160598702, 0.8100316483159367, 0.8457108930568991, 0.20193006449571382, 0.2068407799135552, 0.7197586459307249, 0.20826566859514428, 0.2074338530454649, 0.1679097324498685, 0.4916274511598261, 0.21260433904281129, 0.56659934289794, 0.1946400444826435, 0.2026368974195477, 0.1778029348656972, 0.18679903232633743, 0.18516886939858712, 0.17651993825338774, 0.18056951074081462, 0.18589167999093992, 0.1741381385699684, 0.1019536687020618, 0.09016050827587918, 0.07914946311121385, 0.10353527167647603, 0.08872594302875791, 0.08509959413864376, 0.08809258409631893, 0.08787693247394768, 0.08339786534436111]}, "mutation_prompt": null}
{"id": "77d80d60-b676-479c-b8b2-2215195403a2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Large population for diversity\n        self.F = np.random.uniform(0.4, 0.8)  # Wider variation in Differential weight\n        self.CR = np.random.uniform(0.7, 0.9) # Slightly wider crossover probability\n        self.w = 0.5  # Balanced inertia weight\n        self.c1 = 1.5 # Slightly adjusted cognitive learning for balance\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Further increase in velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Adaptive Strategy and Confidence-based Search.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8865070555711643, 0.8757487028477543, 0.8775493866891063, 0.883605938904218, 0.8737454560895896, 0.881927769350898, 0.8871249488120752, 0.8722992287444463, 0.883807452518728, 0.7717413795093288, 0.7674682987844863, 0.768058305409878, 0.7512174101170309, 0.7610168184756897, 0.751453722280385, 0.7648425940326775, 0.746598679451494, 0.7785747924390123, 0.6953928634143988, 0.16980858522769926, 0.13665700476120768, 0.14042999786412036, 0.17061247311757743, 0.15218464267760157, 0.6811858256330012, 0.5809270417925839, 0.11307840247732315, 0.12576646912622114, 0.13879384104958026, 0.14956750069943103, 0.13509483829599012, 0.13532877559546252, 0.11112843755540414, 0.10545684226529939, 0.12144290387188761, 0.1131587072472705, 0.9737319716857231, 0.9774455021948065, 0.9728919973095774, 0.9721413541490507, 0.9716829293034545, 0.9777847890586789, 0.967537822453255, 0.9767763712270838, 0.9771928098437072, 0.7232828555184807, 0.7062847509083255, 0.6685364761801085, 0.7015105499090053, 0.6992109092902872, 0.6969379595484717, 0.6670274319920089, 0.6443439528007091, 0.6859232937950777, 0.16882076947028146, 0.3660433732582943, 0.8372978929004482, 0.21123874580684654, 0.8910797757523908, 0.21257782381000911, 0.3862588531186941, 0.23386430428896954, 0.8570314647277812, 0.22911524713097875, 0.2168234896046527, 0.22821024477911955, 0.24844280607586433, 0.24673854884633428, 0.2258365825894495, 0.20764005019541987, 0.23135352736809478, 0.12992324745275086, 0.12184935188016877, 0.23894541961354177, 0.19894766697449995, 0.24519592609843233, 0.20284827864119348, 0.22768269067108193, 0.26820714278339697, 0.10478482300248637, 0.27368954479734675, 9.999999999998899e-05, 9.999999999998899e-05, 0.10577114646272912, 9.999999999998899e-05, 0.0023380217855026864, 0.055939973319716785, 0.0027729964483665936, 0.08574717503600282, 0.10005997518839738, 0.10210659842686787, 0.10962245018560357, 0.05991788863715397, 0.07665600266041295, 0.032186765124977534, 0.04841816647301034, 0.11385938705177356, 0.1735159252016174, 0.11855926683382534, 0.16712978873181694, 0.049958197076165556, 0.13886977605354967, 0.07789995211817913, 0.142861610585446, 0.09971502794551379, 0.12898089107491228, 0.09480863751304036, 0.07196666429064447, 0.16662523763685133, 0.14402308502490668, 0.16078265233031364, 0.06364992217922905, 0.0810649024886223, 0.0877012467453151, 0.12969802734302815, 0.22248090184543012, 0.05694311721110645, 0.6404668040241892, 0.5976209934225178, 0.6062747057245319, 0.5455307841744248, 0.541722765794701, 0.6389711282346586, 0.5788309322703428, 0.6275249859167691, 0.5946176600613395, 0.12157124781620421, 0.14030569087187195, 0.13488472382838468, 0.17330677842997688, 0.13895183513101672, 0.10837671111227609, 0.14424832149418176, 0.1380939225156146, 0.12264377415490801, 0.5356425708380808, 0.23924621628482423, 0.29216938320019314, 0.3255639823366897, 0.19550667688838486, 0.6875186764560267, 0.5057028004051591, 0.2510649322450238, 0.2381981511043637, 0.49733907348957596, 0.5802435894446938, 0.2399480839880479, 0.48322407701573944, 0.3714858567017888, 0.3324811223264097, 0.6286991505866144, 0.5278512435549774, 0.5846991173322131, 0.18676793312235362, 0.18870334634246244, 0.28023552722504486, 0.27894535632254824, 0.32807831760860695, 0.1580373847871006, 0.2106182371597799, 0.580613274675602, 0.32135965686418266, 0.20144365472605108, 0.22559189123221046, 0.21531389679342317, 0.2004193255337413, 0.19659189758078066, 0.23151770455253595, 0.1914955900616917, 0.20619646464539731, 0.2240168779685895, 0.21040243671219183, 0.20706758521103918, 0.7251167719170813, 0.6216715113861038, 0.20105233904865838, 0.24137670871118866, 0.22305152490433544, 0.7225380790852707, 0.2153228772264013, 0.11268522610657639, 0.17656185375544886, 0.1874299851371808, 0.19864610952855588, 0.14715852749142155, 0.919750376047302, 0.1307648726585996, 0.13573354882319566, 0.15275703642338834, 0.8153330355968438, 0.21211485412333286, 0.21052448212220753, 0.16835123616939962, 0.10216976862638782, 0.7655914243705766, 0.11294144249404148, 0.8215631438385649, 0.8215696486735155, 0.20002850047733822, 0.18973284990848682, 0.18365694342118777, 0.17372339581252927, 0.18433806904810857, 0.17257810788424155, 0.1869866692709906, 0.19410294244313786, 0.18204163712112087, 0.09164645072204003, 0.08887110119920094, 0.08798424699705087, 0.11304713079140127, 0.08329012630638011, 0.08900776547279188, 0.0961995681088762, 0.09492229904834604, 0.10933928733987464]}, "mutation_prompt": null}
{"id": "447a2b9b-ccba-43a4-a30d-89be4b903179", "solution": "import numpy as np\n\nclass AdvancedStochasticSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(12.5 * dim)  # Adjusted population size for scalability\n        self.F = np.random.uniform(0.3, 0.9)  # Extended range for differential weight\n        self.CR = np.random.uniform(0.6, 0.95) # Broadened crossover probability\n        self.w = np.random.uniform(0.4, 0.7)  # Dynamic inertia weight\n        self.c1 = 1.4 # Slightly reduced cognitive learning factor\n        self.c2 = 1.7 # Slightly increased social learning factor\n        self.velocity_clamp = 0.35 * (self.upper_bound - self.lower_bound) # Modified velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Dynamic strategy adaptation enabled\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.3 * np.random.rand()  # More variance in F\n                self.CR = 0.6 + 0.3 * np.random.rand()  # More variance in CR\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdvancedStochasticSearch", "description": "Advanced Stochastic Search Optimization with Adaptive Differential Evolution and Confidence-Driven Particle Swarm.", "configspace": "", "generation": 68, "fitness": 0.31867153528446834, "feedback": "The algorithm AdvancedStochasticSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8234027844320289, 0.8692810419091324, 0.7944536747372863, 0.8256433613042803, 0.8818492868696517, 0.8137743387891845, 0.8077051273013373, 0.8886033574439338, 0.8249676506491517, 0.5990617306859968, 0.7690844502237469, 0.6367980501236807, 0.619106233234367, 0.7762744097516461, 0.660176936602275, 0.42206439947245744, 0.7513911897634825, 0.6282797645300691, 0.16944021256049036, 0.09172344735982207, 0.15190295203842163, 0.15678318676236136, 0.15432474899706283, 0.13036084639282286, 0.32588049998996593, 0.15552742771280303, 0.13500301371683376, 0.12563566606212428, 0.06966497083660017, 0.12507182034915876, 0.1030978779620102, 0.10960583628495513, 0.13081418620107266, 0.12753232126188452, 0.12686512244411585, 0.10961987059216194, 0.9701112740920881, 0.9686415189732398, 0.960948584870128, 0.9780923229866884, 0.9673842612415634, 0.9630037635160775, 0.9723692253490197, 0.9707271387189207, 0.9633431063704649, 0.47594945085688767, 0.7008009490340394, 0.5353346477912444, 0.5012348770378334, 0.6345589834444549, 0.5784618106443895, 0.4558319598116918, 0.6615257587298098, 0.5099883697663117, 0.34658729952165734, 0.20669333949183766, 0.2256952319259985, 0.19163545979345786, 0.8579377506374125, 0.16111080350731843, 0.8046764332965828, 0.2285677618211216, 0.8321358608871706, 0.21926815994701376, 0.1216169092185384, 0.19916225443324742, 0.20019376924878762, 0.23454593365729304, 0.2608110684243423, 0.1924378941935162, 0.21529045974297667, 0.20118991162489996, 0.11833874060154104, 0.22466965921959547, 0.21033751011084756, 0.12803612879155846, 0.24671033214953908, 0.23295807357635245, 0.1295338840099568, 0.12808228719230852, 0.25411532339658316, 0.0009231727222324126, 0.05193729036506067, 9.999999999998899e-05, 0.043382157546537514, 9.999999999998899e-05, 0.03868439798394829, 9.999999999998899e-05, 0.010027405006313495, 0.04158722507786439, 0.10387811276512515, 0.06436650564445157, 0.08515659095625616, 0.022439690514360122, 0.04668676400054661, 0.03750408601744659, 0.05989080247499823, 0.04694259689606328, 0.0828542515890085, 0.05729152232428991, 0.17052275560953734, 0.22376312000402043, 0.0851845908649278, 0.14667527273020464, 0.07394096158241192, 0.27107263726612973, 0.1610883285245963, 0.06876882385171357, 0.104022120919676, 0.07093118356761752, 0.10612171289215444, 0.2236467744476326, 0.11507766609679781, 0.18198578840303914, 0.052716024706191855, 0.08842033392284443, 0.05653104515225893, 0.5537164682430556, 0.6220372287599121, 0.5275960571118488, 0.5470902261903479, 0.5935394111268515, 0.5831076070890298, 0.5356971722456356, 0.5832776708036418, 0.5787173582608457, 0.09402706294070085, 0.1185253841873316, 0.1260080573776866, 0.11055603637932576, 0.11589734493984893, 0.15050674658107033, 0.11667453919178838, 0.16931280243802682, 0.1134516245266084, 0.22094949208750747, 0.26806964784529275, 0.5221205092159544, 0.19144342179073415, 0.4879254495737695, 0.2535476669573864, 0.25017556537734786, 0.16737528215110686, 0.22706811616347755, 0.465412121413458, 0.3779207158089296, 0.35221632916373546, 0.40271371291487645, 0.34734271346058565, 0.47307372544928317, 0.5106705979887585, 0.6020839273165923, 0.5078464210370206, 0.28993948012956694, 0.3267314725580013, 0.27307221136793447, 0.3939438039599489, 0.15798320137663235, 0.25747008080079703, 0.19110984929638308, 0.4124420257100536, 0.30142741305511467, 0.2076279366187016, 0.22510001091016774, 0.21478430819183625, 0.20512562982588578, 0.21665290104805324, 0.20270397709174903, 0.1961209639917446, 0.20850410081318171, 0.2401799859481113, 0.22904914122564068, 0.2265676995872865, 0.2132219529581323, 0.19779009570703787, 0.22192386522734897, 0.5741245566233173, 0.21792792194991573, 0.19704628267928515, 0.2177231539305362, 0.17380025267271326, 0.17260791154518573, 0.17173171293947176, 0.19877811570271364, 0.16801277500979428, 0.17161072299969016, 0.8535162244023791, 0.9143269853064323, 0.17158270298050649, 0.5149807481935724, 0.11251866031228452, 0.6480762122050986, 0.21054588710342093, 0.16786882938055736, 0.7245174356935167, 0.21221480348107558, 0.8399143205875026, 0.16853473403718855, 0.17344995277764796, 0.18791005687479523, 0.1812484653474845, 0.20924174112969185, 0.1908216051299556, 0.1771923489210382, 0.19213059591101378, 0.18830426562619806, 0.1965409406437516, 0.0902566087241119, 0.09438312589424025, 0.09702446740122339, 0.1044233094202307, 0.09528796526768257, 0.08869146755041035, 0.09502712852615036, 0.08033824539840917, 0.08591230822534979]}, "mutation_prompt": null}
{"id": "82530194-7cab-4527-b250-dc7346fe29aa", "solution": "import numpy as np\n\nclass AdaptiveGaussianDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Slightly reduced population for efficiency\n        self.F = np.random.uniform(0.5, 0.9)  # Increased range for Differential weight\n        self.CR = np.random.uniform(0.6, 0.85) # Modified crossover probability\n        self.w = 0.4  # Adjusted inertia weight\n        self.c1 = 1.3 # Adjusted cognitive learning\n        self.c2 = 1.7 # Slightly increased social learning\n        self.velocity_clamp = 0.4 * (self.upper_bound - self.lower_bound) # Tweaked velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Dynamic strategy selection enabled\n        self.gaussian_mutation_prob = 0.2 # Probability of applying Gaussian mutation\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.6 + 0.25 * np.random.rand()\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Apply Gaussian mutation with a probability\n                if np.random.rand() < self.gaussian_mutation_prob:\n                    gaussian_noise = np.random.normal(0, 0.1, self.dim)\n                    mutant = np.clip(mutant + gaussian_noise, self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveGaussianDEPSO", "description": "Adaptive Gaussian-Mutated Differential Evolution and Particle Swarm for Improved Convergence with Dynamic Strategy Selection and Velocity Control.", "configspace": "", "generation": 69, "fitness": 0.33211838422826756, "feedback": "The algorithm AdaptiveGaussianDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.899172705081914, 0.8968544767705054, 0.9027610270540276, 0.9028896695236333, 0.8931217669711671, 0.8999783805836726, 0.8924565365208217, 0.9039053099944527, 0.9037494902439306, 0.811601762353074, 0.8087270467011145, 0.795831307341219, 0.8130716222827883, 0.7831887841401394, 0.8038175963949314, 0.8092158860440772, 0.7838714508617648, 0.7719442234770515, 0.1150078391415551, 0.13684826659057325, 0.17267658935506092, 0.11441191041920995, 0.15589530154728815, 0.1811355611066986, 0.1427390570399132, 0.1542872137843082, 0.13084367802839048, 0.13080688369061266, 0.1298591659459658, 0.11538844374723889, 0.13765414467061676, 0.0851884005796062, 0.13781408628585645, 0.15016243897673598, 0.10882248115121507, 0.13969927426292283, 0.9841827300294842, 0.9831342537642063, 0.977643253026981, 0.973421767047608, 0.9819604266245792, 0.9786294441900316, 0.9701034209054451, 0.9739844796947428, 0.9818682612037983, 0.7124681915972635, 0.7472274775339338, 0.6885133800129245, 0.7282596955896871, 0.7177992264912318, 0.744308359735026, 0.7097804470782894, 0.7218957182469887, 0.6697390081523292, 0.22885407552045978, 0.2093707897094571, 0.1181933277080559, 0.7162436636590463, 0.2189910893596141, 0.3791788301863619, 0.39085325623191525, 0.4556936083560844, 0.23389000921180403, 0.2154344941570795, 0.3024421028931473, 0.2122080282756451, 0.39978931124357064, 0.22843337944515973, 0.2556086632189374, 0.20561429017211008, 0.20716492175803758, 0.2117440378995199, 0.21990261710558545, 0.12059242976318596, 0.23837423217778198, 0.22062867792629326, 0.29645476678574734, 0.2167795101471749, 0.23492351647860177, 0.2570215245936254, 0.2647206828928409, 0.06716668968192463, 0.03613120826810623, 0.03742921088199036, 0.017592759013388637, 9.999999999998899e-05, 0.0003017452515323704, 9.999999999998899e-05, 0.13411180435803072, 9.999999999998899e-05, 0.022700731386925188, 0.03157303836995928, 0.0450454255079763, 0.10254709393962824, 0.05984376602269981, 0.06647830839469004, 0.05852798654449254, 0.073398394342581, 0.09216816878980427, 0.12475849472867617, 0.0819737591843428, 0.07972535344395126, 0.0798561583298506, 0.08404481806312414, 0.09127955541733668, 0.19868435638502857, 0.07891494281448719, 0.10310986581221038, 0.14761908462124085, 0.049610549994740016, 0.05198807670166916, 0.07759361051803748, 0.23127111858649707, 0.11909692409303607, 0.22678456806156377, 0.09435467334032255, 0.21197923238005356, 0.5368486417028591, 0.5756912811140057, 0.5898243840490565, 0.540267677921006, 0.5663985791065151, 0.5881019975903585, 0.5879018187347322, 0.5964874887901894, 0.5654516067644193, 0.13739005252555359, 0.11514582166287946, 0.11250966284210351, 0.10868720601455317, 0.1472857529787972, 0.1520099678923078, 0.1045621849947087, 0.13240280226624923, 0.13931482187391153, 0.20203566885144775, 0.25358345309082986, 0.2339324604606935, 0.3693797044815412, 0.2236899027638356, 0.2547303262591837, 0.16581182979964648, 0.5919184431165312, 0.18653201894399685, 0.7156026429405941, 0.392151558283784, 0.5784788626819601, 0.4948232943173557, 0.4594496167745391, 0.387461835952973, 0.41153693139119685, 0.17926884099376073, 0.6024631492622852, 0.3284182735686171, 0.38782298963679673, 0.2286340957908476, 0.3174185757391731, 0.2796315602546958, 0.26911402643417015, 0.46065328503865977, 0.22236054707027064, 0.21367821161119072, 0.19936554862463873, 0.19571053819737405, 0.2093293435175373, 0.20182156501359727, 0.20597007529598355, 0.22992034261212013, 0.18321736417153012, 0.2363868302924106, 0.25950995662533594, 0.2087017390245567, 0.22564188201653956, 0.21041451160688296, 0.2082014980171759, 0.22763226730957398, 0.20933103649032903, 0.8051520905306582, 0.20505141052529496, 0.20861618302259755, 0.1678323270728802, 0.15382073924373474, 0.9310635200520787, 0.15888781731074564, 0.1517752917072407, 0.2000553642039461, 0.11447817800586613, 0.17128217886136865, 0.16712879549600002, 0.21186079454590145, 0.15634495945483873, 0.7037561919027712, 0.2078059518588431, 0.15590356689137153, 0.9048530566193427, 0.8335879558326381, 0.16881858081004653, 0.21270448951436616, 0.18237347634371048, 0.18265883258979565, 0.18661743684174548, 0.17834727716072318, 0.18904288828357485, 0.205356944305787, 0.18771314340702205, 0.21242312571999256, 0.18249004907559419, 0.14793872316662182, 0.11231840093002354, 0.08826003203306265, 0.09372313307703428, 0.08926462075814257, 0.09795387407993528, 0.09686186300592803, 0.11447542521130893, 0.08356732100753983]}, "mutation_prompt": null}
{"id": "cd2136f8-06ae-43f5-8153-633e6c0a1c9d", "solution": "import numpy as np\n\nclass AdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Adjust population size for faster convergence\n        self.F = np.random.uniform(0.5, 0.9)  # Adjust range for differential weight\n        self.CR = np.random.uniform(0.6, 0.8) # Adjust crossover probability\n        self.w = 0.6  # Increment inertia weight for exploration\n        self.c1 = 1.7 # Increment cognitive learning\n        self.c2 = 1.3 # Decrement social learning\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Adjust velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = False # Disable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if not self.strategy_dynamic:  # Static strategy\n                self.F = 0.5 + 0.3 * np.random.rand()  # Keep differential weight constant\n                self.CR = 0.6 + 0.2 * np.random.rand()  # Keep crossover probability constant\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "AdaptiveHybridDEPSO", "description": "Adaptive Hybrid Algorithm using Differential Evolution and Particle Swarm with Progressive Learning and Variable Strategies.", "configspace": "", "generation": 70, "fitness": 0.34035852769374697, "feedback": "The algorithm AdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8756836780235188, 0.8580008644108366, 0.8612289991297858, 0.87306277383796, 0.8564345445750214, 0.8707034914931284, 0.8742816648844877, 0.8696321033015766, 0.8452606565920691, 0.6873333159965448, 0.7284624789330834, 0.7295748600286331, 0.7285554835450203, 0.7139306609239406, 0.727019183695712, 0.7275768280478025, 0.7095820276353711, 0.7327016154493471, 0.3987996076413456, 0.1491783772999099, 0.24628257209741822, 0.5383439030175705, 0.1690996206037586, 0.1244725670426855, 0.4086207843250136, 0.15076024701956814, 0.17203546885413323, 0.11662877351848988, 0.12786344029917418, 0.16870970343857428, 0.12915962033878203, 0.1389141251589734, 0.1357889615285558, 0.11957545365684186, 0.16860945916561143, 0.1372197867589382, 0.967513873269319, 0.9753124113070235, 0.9727070215259791, 0.9774044837899527, 0.9740732746214847, 0.9804543908983551, 0.976500768350053, 0.9777152405718941, 0.9715991275466738, 0.6049668979758689, 0.638744924878695, 0.6205538058404589, 0.6544907087935213, 0.6463028695141384, 0.6828026574851533, 0.5867439449639849, 0.5690693962502109, 0.6074362630626636, 0.8042205657261313, 0.7524259868523988, 0.22582396124188808, 0.28007392800914355, 0.21185352535643143, 0.2749581537345658, 0.8353545458093057, 0.7610674181506458, 0.8276030114369737, 0.20661599049962642, 0.2032723889378082, 0.21405711011718664, 0.12185212929047262, 0.22678825052287344, 0.20841821248467396, 0.21303216485743848, 0.19978183399651694, 0.20453494726953292, 0.20528704731480218, 0.21766280859601994, 0.22488593439817472, 0.25275738425233873, 0.22845725264535832, 0.2235118820426174, 0.24235380302405007, 0.44657948647931944, 0.23604796338320988, 0.012461269317648793, 9.999999999998899e-05, 0.053948540260486566, 0.021038389934082247, 0.030351347038507392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03874568372191911, 0.03842962725496468, 0.11156219083708452, 0.0772554891586964, 0.043779354150587424, 0.10348417262420861, 0.05287660939709238, 0.10397336098990673, 0.10252404680152483, 0.10702445272912742, 0.11045268652051177, 0.1809772573973053, 0.1007982729299709, 0.1915274654451694, 0.09251687779809292, 0.07786163329236295, 0.11783849321255979, 0.07051022898716508, 0.13676284574037323, 0.10298126563308774, 0.032755778241103095, 0.11692107516395667, 0.03480902629914695, 0.10422359633264389, 0.18732460688688357, 0.08255547367526728, 0.10574021866060357, 0.09220139392532001, 0.5286880771304532, 0.5111357235737769, 0.509000330603229, 0.5664320642240082, 0.5516614231868124, 0.5620459269175625, 0.549777541504691, 0.5960535149923809, 0.5508546488713445, 0.13414034908346362, 0.3251826319051655, 0.11862045675952526, 0.10457358823184237, 0.1291936819043238, 0.14646800309420327, 0.10970392921296623, 0.10586942784720177, 0.1384714313118831, 0.24378007292825576, 0.3002531422534498, 0.43325552780015764, 0.21401691334684259, 0.36147160291969116, 0.21628506884658905, 0.14366737693533593, 0.24176028419562434, 0.1554167384741615, 0.35179090928292667, 0.5807237019458671, 0.3795655479697755, 0.5652689873370207, 0.352384958304361, 0.49531794613067714, 0.5590948154460528, 0.6010010575938113, 0.6078124990859226, 0.33629605230863757, 0.23768589047104594, 0.3307441409617674, 0.24161423677563165, 0.4794896828641888, 0.30715683324909615, 0.21806650206485112, 0.3845364102985712, 0.34986316330355927, 0.22196302526334344, 0.20106385833636375, 0.22224464318631187, 0.21075357200980893, 0.2073929921298221, 0.22526850483375704, 0.20734118041414606, 0.21383628994541437, 0.1943045108844762, 0.2287753611119493, 0.21183102314418434, 0.23701161746029464, 0.7562486410083133, 0.219767503079481, 0.2439974724884021, 0.2377938503230388, 0.20775640927813976, 0.23045891219987868, 0.18764342338307827, 0.17592869705038816, 0.19139257883451977, 0.9059645509726583, 0.8778633260268217, 0.197650645052169, 0.2114459259365783, 0.1734803437301078, 0.1770295384734225, 0.6677681602553986, 0.2099541607486506, 0.2116803103179722, 0.2090736492417583, 0.1681908732222679, 0.6816765274853477, 0.1651253096845945, 0.21245459212965756, 0.8149804165805212, 0.18693156775011177, 0.1996111128436724, 0.18456611892415153, 0.18500980230504016, 0.21457698039115525, 0.1863040329718566, 0.18172890337539183, 0.18575736436869672, 0.18750575641619038, 0.09363008210811308, 0.09484548905367007, 0.08069272999554344, 0.09784783973291777, 0.09152058742308, 0.09066181486808489, 0.08536755261404683, 0.0942483611554068, 0.09396049617898972]}, "mutation_prompt": null}
{"id": "866b8af4-1fea-4fa5-99e1-66073fee2a68", "solution": "import numpy as np\n\nclass MultiStrategyHyDEPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Slightly reduced population for computational efficiency\n        self.F = np.random.uniform(0.5, 0.9)  # Increased range for mutation factor\n        self.CR = np.random.uniform(0.6, 0.95) # Wider crossover probability range\n        self.w = 0.4  # Slightly reduced inertia for faster convergence\n        self.c1 = 1.4 # Lower cognitive learning factor\n        self.c2 = 1.6 # Higher social learning factor\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Reduced velocity clamp for finer adjustments\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.temp = 1.0  # Initial temperature for simulated annealing\n        self.cooling_rate = 0.99  # Cooling rate for temperature decay\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection using simulated annealing\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / self.temp):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            self.temp *= self.cooling_rate  # Update temperature\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "MultiStrategyHyDEPSO_SA", "description": "Multi-strategy hybrid optimization blending Differential Evolution, Particle Swarm Optimization, and Simulated Annealing for adaptive convergence.", "configspace": "", "generation": 71, "fitness": 0.26919607177285143, "feedback": "The algorithm MultiStrategyHyDEPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.3968765319688212, 0.41699865259415203, 0.45552640521404597, 0.42550313599283696, 0.4113937754663404, 0.45759398127228545, 0.4094974898244108, 0.40833896249400947, 0.4679279165077508, 0.36172459319064854, 0.37861419590170053, 0.4201600946783335, 0.38007521097843855, 0.3558174307431655, 0.42137614212257557, 0.3775520019608357, 0.3592812336414615, 0.40295400619912214, 0.1420384790577095, 0.36942776161233615, 0.1580750194613496, 0.13575644958125976, 0.14896150727538404, 0.15728915642841113, 0.14934242838942646, 0.14048320134570202, 0.14205515071255193, 0.12543618699683834, 0.08034500493194285, 0.11528445412485144, 0.11069693237134581, 0.14863656166193018, 0.12163012409369589, 0.13291616119013527, 0.09768539048527525, 0.10929236568602796, 0.9683585854929734, 0.9848010623301411, 0.9710683016573978, 0.974018992650929, 0.978066518679996, 0.9673111112128299, 0.9743697581302927, 0.963518455502249, 0.9734067950269756, 0.48431184378210423, 0.4846804651927845, 0.5435330813397263, 0.44067439795229724, 0.4845457645455129, 0.47994175742087386, 0.4457950008998227, 0.5034531122252299, 0.5158875954125348, 0.22900698185892843, 0.5800544204487881, 0.2258334686744191, 0.2779667212257918, 0.6535619520813727, 0.6764359074597699, 0.7408235293988683, 0.6277617608534076, 0.6473137442555357, 0.22379278216591914, 0.13075286922076335, 0.13537361899722533, 0.29454319083644764, 0.23066730188064144, 0.20818754487392388, 0.223957452224685, 0.12867928714360755, 0.23639244444312535, 0.24055860101055282, 0.12345538428165492, 0.23005218291147034, 0.2400992680865336, 0.2672751218493431, 0.1351372570253061, 0.25064294999625014, 0.2599609552484703, 0.24341809692256589, 9.999999999998899e-05, 9.999999999998899e-05, 0.1900433570001433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05783439680061142, 0.012607871531880699, 9.999999999998899e-05, 0.12575156443339386, 0.04436555222653227, 0.12701889332867777, 0.07923629070511395, 0.06570687851040058, 0.028682422968772103, 0.1241805842346112, 0.13235509739825468, 0.0843522875028, 0.08757586286486929, 0.05240165451364698, 0.22121794225638103, 0.08059454551757939, 0.08854954351461253, 0.14698487913715363, 0.274666620835635, 0.10282213165500054, 0.1277168528578333, 0.13290947662377517, 0.19475012810058334, 0.10531685727959916, 0.10688014731556794, 0.20305907047161775, 0.30568392562763325, 0.08734439662936788, 0.08593196929578895, 0.05780583537472905, 0.3783992302655034, 0.37648325027811813, 0.3959657133411071, 0.36569638252108483, 0.374416516854046, 0.42473911948516296, 0.3689241948608164, 0.38835658038858123, 0.41647656004904254, 0.09207092074960033, 0.1781686684486412, 0.09482261928846436, 0.13955066211863143, 0.10752884114542482, 0.14486180014954586, 0.08903569379569376, 0.14829990596759435, 0.09918733089245069, 0.15311410266808012, 0.2859710551776854, 0.20078027922668384, 0.21071977458962943, 0.3266211663028936, 0.2510059003264752, 0.19155163859615576, 0.24150205819884596, 0.3820366758778768, 0.2981131307497623, 0.297778199162141, 0.3179674119849025, 0.30187274270502795, 0.2985556773397965, 0.32940926379187785, 0.3016085243338982, 0.3083658419019305, 0.2406487546060252, 0.2760740056779708, 0.25798222016781747, 0.2508553288606552, 0.29232998426690515, 0.21314990144366575, 0.3220132464295349, 0.2919554380247059, 0.2963887768073278, 0.23732611962304595, 0.23726100138552597, 0.22092424123224907, 0.23433504824984241, 0.19704714191909867, 0.22898546031000255, 0.21735519807738524, 0.2217633139319365, 0.19649712268175312, 0.22022916703803996, 0.3490733462207376, 0.21962927954808098, 0.23631909873970192, 0.22195004230808535, 0.22269234461026077, 0.21863198218244728, 0.20549187764631427, 0.3585062344127887, 0.2088591102916293, 0.1714463732003786, 0.1873726460189541, 0.18778424658960102, 0.6002868444755463, 0.19841522674062895, 0.7069772563784034, 0.17184868103020923, 0.15798944183276487, 0.13653742006434955, 0.113294484349175, 0.21081069168113387, 0.6442800070056205, 0.11176467203723428, 0.15421511208656868, 0.20944784594449495, 0.15615110677200705, 0.09450306558185617, 0.15614650974509403, 0.18273448549665006, 0.19763024653854733, 0.19479775349080675, 0.21242577776930316, 0.17502823985159688, 0.18047548856863882, 0.19206878137582206, 0.17803366480830285, 0.2078493439129584, 0.09481431887137881, 0.08456428982867659, 0.0960237294902132, 0.10969525841429784, 0.08848251720402711, 0.10386063372728782, 0.09152800654454663, 0.09997583393173048, 0.0859007538506823]}, "mutation_prompt": null}
{"id": "9902c85b-48bd-4349-9b8f-f8a5fe094e9e", "solution": "import numpy as np\n\nclass SynergisticDEPSOHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Reduced size for focused search\n        self.F = np.random.uniform(0.3, 0.9)  # Extended range for differential weight\n        self.CR = np.random.uniform(0.6, 1.0)  # Broader crossover probability\n        self.w = 0.4  # Lower inertia for rapid adaptation\n        self.c1 = 1.3  # Slightly lower cognitive learning\n        self.c2 = 1.7  # Higher social learning for better convergence\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)  # Modified velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Keep dynamic strategy selection\n        self.adaptive_population = np.random.choice([True, False], p=[0.7, 0.3])  # Adaptive strategy for population\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.3 + 0.6 * np.random.rand()  # Extended range adjustment\n                self.CR = 0.6 + 0.4 * np.random.rand()  # Broader range for crossover\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Adaptive population strategy\n            if self.adaptive_population and evals < self.budget * 0.8:  # Apply only in the initial 80% of evaluations\n                best_half_idx = np.argsort(fitness)[:self.population_size // 2]\n                self.population[best_half_idx] = self.population[best_half_idx] + np.random.normal(0, 0.1, (self.population_size // 2, self.dim))\n                fitness[best_half_idx] = [func(ind) for ind in self.population[best_half_idx]]\n                evals += len(best_half_idx)\n\n        return self.global_best, self.best_fitness", "name": "SynergisticDEPSOHybrid", "description": "Synergistic DE-PSO Hybrid Optimization with Dynamic Parameter Tuning and Adaptive Population Strategy for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 72, "fitness": 0.2323442206358486, "feedback": "The algorithm SynergisticDEPSOHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.5297357889267388, 0.5062934505044627, 0.5067156792288778, 0.5174664222504501, 0.4961420651590718, 0.5263406089304222, 0.4999830840499665, 0.5135724662759344, 0.5070378729175276, 0.06257207965731015, 0.17483488205024245, 0.11892105302053202, 0.13108224547229597, 0.11422252703686586, 0.10805708534468872, 0.1629059823899648, 0.09897558169956278, 0.09919653762483538, 0.11622812668994098, 0.11769233915823885, 0.10160970823073201, 0.08515581442806852, 0.11891547181973205, 0.12642097167067945, 0.10126063549755437, 0.08040476443890732, 0.11680591260976814, 0.11414601203831476, 0.11038176736456684, 0.09928775432559178, 0.09879870588474127, 0.09427100922791054, 0.10226998713320967, 0.09069315307272774, 0.09045722667573941, 0.10204171764572656, 0.9524646462931622, 0.9597528638761759, 0.9624266957550772, 0.9126204173285423, 0.9789773681594036, 0.9557974808406797, 0.9691652083999999, 0.9469507899138108, 0.9559255048456097, 0.3068216048055292, 0.29747247924776943, 0.37279704439096817, 0.30527215801098984, 0.2959101773700933, 0.3000269066606893, 0.2848832349986439, 0.3079644781989328, 0.3034418846218824, 0.3345659981374337, 0.2676954974007092, 0.34762473292173124, 0.3344800313938997, 0.2852227377773553, 0.2780041430430371, 0.3012619035812063, 0.29895887590936254, 0.41565110727185306, 0.17103996921210474, 0.1130388622440196, 0.15165481171463258, 0.2119016862508325, 0.19181917430856743, 0.1685966823640781, 0.16756274217500866, 0.2041714359703577, 0.16747393430829038, 0.20719017581159416, 0.12350886580408116, 0.195756004429822, 0.18206134307673105, 0.170415089349924, 0.1779097322836256, 0.167686408841356, 0.16731176478810683, 0.19042242681449073, 0.0312202483474201, 0.00010447562976800828, 0.0030220525193459524, 0.007853152928436802, 0.0011742952818353247, 0.0015780536538891887, 0.006649912320472184, 0.028147520340108367, 0.0058780251537693395, 0.08337366624206022, 0.03449687323005235, 0.12957438451900016, 0.031441097315151434, 0.07843194559767197, 0.02596971939839987, 0.06053040803329224, 0.06780772006590563, 0.10904109169126219, 0.010320058699070045, 0.020028894157734234, 0.009876952643198433, 0.02228572759923264, 0.020062488776887433, 0.01384068381652137, 0.018053688382383526, 0.01227088812455146, 0.016082071591412617, 0.12123417050558749, 0.1275519176379294, 0.089566977205641, 0.10364219247245732, 0.08790763370923615, 0.1092692644362151, 0.08642432533871547, 0.13007677541191953, 0.12175578981837099, 0.4226314922771749, 0.4286387277124264, 0.44034295878842, 0.4381611192656165, 0.4465021303642639, 0.4059945319070273, 0.4314908503810563, 0.43801988905745015, 0.419957676397806, 0.11917783860244857, 0.10925660261211001, 0.10132650444784796, 0.09644169451067408, 0.12939138023262875, 0.09160299813169837, 0.10399561899652365, 0.09583942858468275, 0.09142430892568554, 0.34058605904732653, 0.16864411078144603, 0.23352125546825764, 0.16560373600388556, 0.2298781713509439, 0.26172859936390347, 0.1354638937119309, 0.31053156200821586, 0.20541772523487767, 0.3261290887403576, 0.32179744545876554, 0.30822361200342996, 0.3130292649333932, 0.31207426145654715, 0.254821353671144, 0.3068532730229223, 0.3120982241345629, 0.2752900645675297, 0.20537844539123895, 0.2324623728207037, 0.2510539815686029, 0.2579016146451907, 0.2307576026004844, 0.26243450274832125, 0.1907671641518034, 0.23554547613290844, 0.2010187292437463, 0.2378645586333732, 0.2126366739056159, 0.21450229009173893, 0.20778947956310778, 0.24034518857964582, 0.20859075369675695, 0.21145686631214677, 0.1937523361714938, 0.2188007229399339, 0.1885675656042266, 0.21228517228687604, 0.19641819961702534, 0.27875627373234024, 0.21692116948330908, 0.19163714767511653, 0.26888135243665623, 0.24027831450280523, 0.18980467966961334, 0.1591922547936072, 0.18368647647409975, 0.15880519473207455, 0.16712474536306232, 0.1692135315361225, 0.701358215089766, 0.17871901951823788, 0.16792905692009497, 0.7211598754075563, 0.11297130554258494, 0.5457799097139759, 0.21088888006458406, 0.21029615565383475, 0.2111632015302468, 0.16834163519462086, 0.5378257761034386, 0.21229002196979951, 0.5684302830941366, 0.19654533946907415, 0.1886704823798665, 0.18346449837666357, 0.19420229967491198, 0.19397583595567358, 0.18889425721576802, 0.17152640134982944, 0.1740185880407189, 0.17113320680104038, 0.0888400307203625, 0.08963545249894944, 0.08596089154049147, 0.08851165786819237, 0.08505831272928976, 0.11434039103156446, 0.08738587650561147, 0.0845929357421159, 0.09682486043259286]}, "mutation_prompt": null}
{"id": "e86e86c2-f606-4187-80a2-5b8fefd882a9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population for more diversity\n        self.F = np.random.uniform(0.3, 0.9)  # Wider range for differential weight\n        self.CR = np.random.uniform(0.6, 0.95) # Extended crossover probability range\n        self.w = 0.6  # Modified inertia weight for PSO\n        self.c1 = 1.6 # Higher cognitive learning factor\n        self.c2 = 1.4 # Lower social learning factor for balance\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([func(ind) for ind in self.population])]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.3 + 0.6 * np.random.rand()\n                self.CR = 0.6 + 0.35 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Hybrid Metaheuristic using Adaptive Differential Evolution and Particle Swarm Optimization with Randomized Strategy Adjustments and Velocity Clamping.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {}, "mutation_prompt": null}
{"id": "609929c6-ed36-4b4a-b45f-5314222e0ec3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Large population for diversity\n        self.F = np.random.uniform(0.4, 0.8)  # Wider variation in Differential weight\n        self.CR = np.random.uniform(0.7, 0.9) # Slightly wider crossover probability\n        self.w = 0.5  # Balanced inertia weight\n        self.c1 = 1.5 # Slightly adjusted cognitive learning for balance\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Further increase in velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.2 * np.random.rand()  # Randomize within a range\n                self.CR = 0.7 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced Adaptive Hybrid Optimization using Differential Evolution and Particle Swarm with Adaptive Strategy and Confidence-based Search.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8865070555711643, 0.8757487028477543, 0.8775493866891063, 0.883605938904218, 0.8737454560895896, 0.881927769350898, 0.8871249488120752, 0.8722992287444463, 0.883807452518728, 0.7717413795093288, 0.7674682987844863, 0.768058305409878, 0.7512174101170309, 0.7610168184756897, 0.751453722280385, 0.7648425940326775, 0.746598679451494, 0.7785747924390123, 0.6953928634143988, 0.16980858522769926, 0.13665700476120768, 0.14042999786412036, 0.17061247311757743, 0.15218464267760157, 0.6811858256330012, 0.5809270417925839, 0.11307840247732315, 0.12576646912622114, 0.13879384104958026, 0.14956750069943103, 0.13509483829599012, 0.13532877559546252, 0.11112843755540414, 0.10545684226529939, 0.12144290387188761, 0.1131587072472705, 0.9737319716857231, 0.9774455021948065, 0.9728919973095774, 0.9721413541490507, 0.9716829293034545, 0.9777847890586789, 0.967537822453255, 0.9767763712270838, 0.9771928098437072, 0.7232828555184807, 0.7062847509083255, 0.6685364761801085, 0.7015105499090053, 0.6992109092902872, 0.6969379595484717, 0.6670274319920089, 0.6443439528007091, 0.6859232937950777, 0.16882076947028146, 0.3660433732582943, 0.8372978929004482, 0.21123874580684654, 0.8910797757523908, 0.21257782381000911, 0.3862588531186941, 0.23386430428896954, 0.8570314647277812, 0.22911524713097875, 0.2168234896046527, 0.22821024477911955, 0.24844280607586433, 0.24673854884633428, 0.2258365825894495, 0.20764005019541987, 0.23135352736809478, 0.12992324745275086, 0.12184935188016877, 0.23894541961354177, 0.19894766697449995, 0.24519592609843233, 0.20284827864119348, 0.22768269067108193, 0.26820714278339697, 0.10478482300248637, 0.27368954479734675, 9.999999999998899e-05, 9.999999999998899e-05, 0.10577114646272912, 9.999999999998899e-05, 0.0023380217855026864, 0.055939973319716785, 0.0027729964483665936, 0.08574717503600282, 0.10005997518839738, 0.10210659842686787, 0.10962245018560357, 0.05991788863715397, 0.07665600266041295, 0.032186765124977534, 0.04841816647301034, 0.11385938705177356, 0.1735159252016174, 0.11855926683382534, 0.16712978873181694, 0.049958197076165556, 0.13886977605354967, 0.07789995211817913, 0.142861610585446, 0.09971502794551379, 0.12898089107491228, 0.09480863751304036, 0.07196666429064447, 0.16662523763685133, 0.14402308502490668, 0.16078265233031364, 0.06364992217922905, 0.0810649024886223, 0.0877012467453151, 0.12969802734302815, 0.22248090184543012, 0.05694311721110645, 0.6404668040241892, 0.5976209934225178, 0.6062747057245319, 0.5455307841744248, 0.541722765794701, 0.6389711282346586, 0.5788309322703428, 0.6275249859167691, 0.5946176600613395, 0.12157124781620421, 0.14030569087187195, 0.13488472382838468, 0.17330677842997688, 0.13895183513101672, 0.10837671111227609, 0.14424832149418176, 0.1380939225156146, 0.12264377415490801, 0.5356425708380808, 0.23924621628482423, 0.29216938320019314, 0.3255639823366897, 0.19550667688838486, 0.6875186764560267, 0.5057028004051591, 0.2510649322450238, 0.2381981511043637, 0.49733907348957596, 0.5802435894446938, 0.2399480839880479, 0.48322407701573944, 0.3714858567017888, 0.3324811223264097, 0.6286991505866144, 0.5278512435549774, 0.5846991173322131, 0.18676793312235362, 0.18870334634246244, 0.28023552722504486, 0.27894535632254824, 0.32807831760860695, 0.1580373847871006, 0.2106182371597799, 0.580613274675602, 0.32135965686418266, 0.20144365472605108, 0.22559189123221046, 0.21531389679342317, 0.2004193255337413, 0.19659189758078066, 0.23151770455253595, 0.1914955900616917, 0.20619646464539731, 0.2240168779685895, 0.21040243671219183, 0.20706758521103918, 0.7251167719170813, 0.6216715113861038, 0.20105233904865838, 0.24137670871118866, 0.22305152490433544, 0.7225380790852707, 0.2153228772264013, 0.11268522610657639, 0.17656185375544886, 0.1874299851371808, 0.19864610952855588, 0.14715852749142155, 0.919750376047302, 0.1307648726585996, 0.13573354882319566, 0.15275703642338834, 0.8153330355968438, 0.21211485412333286, 0.21052448212220753, 0.16835123616939962, 0.10216976862638782, 0.7655914243705766, 0.11294144249404148, 0.8215631438385649, 0.8215696486735155, 0.20002850047733822, 0.18973284990848682, 0.18365694342118777, 0.17372339581252927, 0.18433806904810857, 0.17257810788424155, 0.1869866692709906, 0.19410294244313786, 0.18204163712112087, 0.09164645072204003, 0.08887110119920094, 0.08798424699705087, 0.11304713079140127, 0.08329012630638011, 0.08900776547279188, 0.0961995681088762, 0.09492229904834604, 0.10933928733987464]}, "mutation_prompt": null}
{"id": "59933526-fb83-4ea3-887d-25a6e4b28826", "solution": "import numpy as np\n\nclass DynamicDiverseHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = max(10, 5 * dim)  # Ensure a minimum population size for smaller dimensions\n        self.F = np.random.uniform(0.5, 0.9)  # Broaden range for DE variation\n        self.CR = np.random.uniform(0.6, 0.95) # Wider crossover probability range\n        self.w = 0.4  # Slightly reduced inertia for quicker adaptation\n        self.c1 = 1.7 # Increased cognitive learning for exploration\n        self.c2 = 1.3 # Decreased social learning for better balance\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Moderately increase velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([float('inf')] * self.population_size)]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Dynamic strategy adaptation enabled\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.3 * np.random.rand()  # Dynamic scaling factor\n                self.CR = 0.6 + 0.3 * np.random.rand()  # Dynamic crossover rate\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "DynamicDiverseHyDEPSO", "description": "Dynamic Diverse Hybrid Optimization using Adaptive Differential Evolution and Particle Swarm with Confidence-based Search.", "configspace": "", "generation": 75, "fitness": 0.34998752914184056, "feedback": "The algorithm DynamicDiverseHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.31.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.9428343166962996, 0.9392617691939749, 0.9440510307827052, 0.940267040221678, 0.9394478324108307, 0.9411653245041391, 0.9432776686351826, 0.9394477673096314, 0.9429092784378392, 0.892272312050802, 0.856345985523409, 0.8846278068611676, 0.8982067879147277, 0.8947206677809444, 0.886025484113935, 0.8958708075418459, 0.8921211139793686, 0.8932449532311593, 0.13456624174355802, 0.16240646604871778, 0.15550794024872572, 0.16028980378361246, 0.8010766301206054, 0.1874269942444644, 0.14750878548818314, 0.18892793078492098, 0.13554735085601133, 0.12395295634281978, 0.11189857219752297, 0.11909117682293147, 0.1438139862690394, 0.11819312632341794, 0.13223041023250592, 0.13237760474663396, 0.12827293521450578, 0.14024224147983133, 0.9770810231711348, 0.9892680116389696, 0.9796585688107048, 0.966709492360209, 0.9605092210437871, 0.9797411678778342, 0.9790808226369341, 0.9765541448398304, 0.977676864957916, 0.8467023569324507, 0.8390686427860875, 0.22700401401596437, 0.8355616525070355, 0.770444620793618, 0.8495541975579897, 0.8176974997497363, 0.8027986774838003, 0.821520161335167, 0.22794153770575687, 0.2137587774233125, 0.16913944217449373, 0.36470703437748797, 0.38843923129043023, 0.282894597031235, 0.9407135926422445, 0.23754595440198034, 0.24573103518592276, 0.18332872313477921, 0.13466870798511432, 0.17784809067938823, 0.12703137112757013, 0.12753308499219074, 0.13060068432816807, 0.4003472955823434, 0.1664936211101975, 0.19395133349430793, 0.1746834058936525, 0.13505808190259527, 0.18163726391882495, 0.13463545774878694, 0.15623782426387478, 0.2303327755543343, 0.21173689425143616, 0.15128190981958156, 0.2074060140292444, 0.018980262320996588, 0.025880766773490937, 0.0019646441190219743, 0.020302096290763405, 9.999999999998899e-05, 0.060135851068853885, 9.999999999998899e-05, 9.999999999998899e-05, 0.006374534228550721, 0.0830637886964507, 0.07470273719401521, 0.240736089467656, 0.08317903444214536, 0.05641603083042368, 0.05954927772856222, 0.06766042274827411, 0.17870273186296048, 0.08588467027697311, 0.1116806772639064, 0.057448298445598955, 0.15713561561801503, 0.08400624181861638, 0.14925083494713454, 0.10300475135797293, 0.11491029662394503, 0.07868853940707798, 0.5189931585750281, 0.07993819106400957, 0.0978127865795515, 0.20151685054319346, 0.10540499811049353, 0.1415679071845961, 0.13610507716966003, 0.09417131870153861, 0.09454307787287164, 0.1602262880123908, 0.5804956923683213, 0.5807642125212966, 0.5938468585817619, 0.5490008058430242, 0.5541240972617596, 0.5855576261723989, 0.621684372382662, 0.5821929157456783, 0.6314069981928825, 0.09089833928670721, 0.15545393592893597, 0.14673872305383306, 0.838695342602418, 0.11514827441053, 0.08854771319242993, 0.09463429551758296, 0.1618302979467211, 0.14764040073605278, 0.16988482410012895, 0.31091750346980385, 0.2672895409024775, 0.22082813021498982, 0.5186997723831721, 0.23322366384540827, 0.20325645604352305, 0.6285586068914785, 0.29475192879651657, 0.5703174530034401, 0.5563294865284338, 0.3344754618779371, 0.3181499585454711, 0.5779445757758398, 0.48978535318980343, 0.6180730243945407, 0.23692473233633105, 0.2501550632875764, 0.36994772424672295, 0.3073277911294393, 0.23084432184418902, 0.37173030751840375, 0.2956784993938485, 0.42942125886225424, 0.37052727338466374, 0.2974623865897055, 0.3195125634019247, 0.20562340743447372, 0.2254666487868784, 0.2644547251087144, 0.20254584009271737, 0.21963868345201154, 0.21613331097698174, 0.2136093062743235, 0.2175704755988891, 0.2695522890296047, 0.1773899497429906, 0.21192902382017909, 0.18211341092897226, 0.20281746561446967, 0.2086184956844903, 0.2232522040869831, 0.21874813820786843, 0.2236342409289458, 0.2036704640861422, 0.18718724967167788, 0.18784278080010386, 0.20066562255994203, 0.20074382067373764, 0.14802069647948446, 0.20085918153450688, 0.9516061702506603, 0.2121673194485153, 0.9618088158853915, 0.21293514877107533, 0.21381232248586668, 0.7721906316884077, 0.21268130925032747, 0.17007546793047734, 0.21340318162544458, 0.9090544991624875, 0.16774650810062863, 0.8804595717085858, 0.19116413178465474, 0.18264771910055966, 0.19010334952661556, 0.1738137767835507, 0.18318054155972585, 0.17802335125056357, 0.21456870506127934, 0.1930367374977776, 0.17981481039941283, 0.13768326135318099, 0.103167171442904, 0.08961268505555109, 0.11503973345273555, 0.12149591176823216, 0.10830903791353308, 0.11686187580289098, 0.0962268010460533, 0.08986792222156037]}, "mutation_prompt": null}
{"id": "4cf395ca-423e-4848-9283-b572b0698cf7", "solution": "import numpy as np\n\nclass EvolutionaryCoopDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Large population for diversity\n        self.F = np.random.uniform(0.5, 0.9)  # Slightly wider variation in Differential weight\n        self.CR = np.random.uniform(0.6, 0.95) # Wider crossover probability for exploration\n        self.w = 0.4  # Slightly lower inertia weight for exploration\n        self.c1 = 1.7 # Slightly more cognitive learning\n        self.c2 = 1.3 # Slightly less social learning to avoid premature convergence\n        self.velocity_clamp = 0.4 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.boost_factor = 1.2  # Velocity boost factor for exploitation\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.4 * np.random.rand()  # Randomize within an extended range\n                self.CR = 0.6 + 0.35 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities *= self.boost_factor  # Apply velocity boost\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "EvolutionaryCoopDEPSO", "description": "Evolutionary Cooperative Algorithm combining Differential Evolution and Particle Swarm with Adaptive Strategy and Velocity Boost.", "configspace": "", "generation": 76, "fitness": 0.2952606629474915, "feedback": "The algorithm EvolutionaryCoopDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.7965082480918966, 0.8148187917467778, 0.8000564260468959, 0.7962206734087047, 0.7985753488139571, 0.7900610120364412, 0.7975270482135332, 0.7999840174830541, 0.7820065328274826, 0.5936103642031044, 0.6037602893225393, 0.581959688384353, 0.6070034813141892, 0.6301018166179824, 0.6125880615126401, 0.6058721552014339, 0.5649810100872261, 0.5829824803433283, 0.13398978545838724, 0.14252137912083185, 0.13320225597930635, 0.13332325180374005, 0.1537349792657131, 0.12863727017193993, 0.11126334352023137, 0.14735459906908233, 0.24697912877733308, 0.12002165730183001, 0.14267636588503196, 0.11253769739952935, 0.12092003660583306, 0.12148634833066063, 0.10524479454824343, 0.11691557819435838, 0.11940890789809877, 0.10970481944992427, 0.979944689743419, 0.971781447518956, 0.9699535166257642, 0.9770822291755298, 0.9749677552806507, 0.9766463083239475, 0.9769403743737161, 0.9742920822050694, 0.9771037578368643, 0.38437018241315213, 0.40956145363875596, 0.37434953603715004, 0.45997886270710175, 0.4274892307513486, 0.4411368070689674, 0.39434356384316893, 0.3632746618262237, 0.3817385654416362, 0.22543759206852643, 0.6106104177824411, 0.6185664843958171, 0.7524398467113773, 0.3600734544250186, 0.26684933782366516, 0.33199814525848725, 0.23208230860711787, 0.7019253745976086, 0.17570580660126967, 0.18756716667508455, 0.21223730594091061, 0.22934353168832644, 0.12300534125824092, 0.17686109099736513, 0.2160904455772238, 0.195687840179953, 0.11849272395555632, 0.32261126459988887, 0.17412373200719544, 0.22354703447766844, 0.19158280716593212, 0.16773860443063893, 0.20410695159161052, 0.2186738420040092, 0.2141656244397827, 0.19921159773178465, 9.999999999998899e-05, 9.999999999998899e-05, 0.024257175830055933, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08980491598787921, 0.07399971031355967, 0.1234101424208055, 0.07747543696926007, 0.09163367927155863, 0.025199920831962985, 0.09238179400351487, 0.07946975285976787, 0.09641668814644122, 0.030732333115242372, 0.12603704488410328, 0.09061787873938842, 0.16036699121421627, 0.17861425189782132, 0.08397068441965416, 0.1181171515944558, 0.05736572171205989, 0.06432362355333698, 0.15831457167778207, 0.21538058358240608, 0.09807866125563991, 0.19398767959466456, 0.1273667975729098, 0.2328801099702652, 0.056558691536671035, 0.14973392054310264, 0.09909088240087549, 0.4857127431098779, 0.481936338988597, 0.48397802963173764, 0.5099742639512471, 0.4897263749954406, 0.4953063471250002, 0.5286955378232578, 0.5251927748439273, 0.5202184477324564, 0.10145742206197117, 0.10533232418533567, 0.10864352595583404, 0.09140894258817223, 0.0937445608674281, 0.09101455050597451, 0.08806064758384291, 0.09801433432378959, 0.1129731614053433, 0.14584169169754735, 0.36942933439483616, 0.1792116345942144, 0.17907121584592767, 0.15595533748635715, 0.13431834230443052, 0.41611906084281414, 0.14551687253737633, 0.2168364168291551, 0.43604330830583793, 0.3716580495459302, 0.4434741036793667, 0.31616327852692716, 0.4276593820906621, 0.3889671453165471, 0.41138363850276727, 0.4112895946229863, 0.44574163652322585, 0.28190824769303013, 0.24580623364961274, 0.2850875906737217, 0.2677528213487219, 0.24097377045025292, 0.29330015551032307, 0.30367820666389644, 0.3501844624452899, 0.2841758038349411, 0.20416033204887718, 0.1770064027424716, 0.20973031412532406, 0.19645912225353168, 0.19797276438734968, 0.1899505294530015, 0.1978805998344545, 0.21963267499326888, 0.1907033154379204, 0.5370544752629138, 0.21876553261028908, 0.3458979575191058, 0.1945575077464854, 0.19001504969860727, 0.49785310026514384, 0.19573521132405314, 0.4400151395526356, 0.22131444024669633, 0.15299221174365762, 0.18599469237082533, 0.1639941937842252, 0.16250409082911688, 0.16597926669227459, 0.8569656848467455, 0.13092080324388333, 0.13511332826495404, 0.19271522767501215, 0.20927733771903945, 0.11195136901504099, 0.15103164669016056, 0.6959973138333464, 0.16530165984302037, 0.12627105021613005, 0.21229331713898136, 0.5372427425137161, 0.7634198054362623, 0.1732996876445081, 0.1772282380392427, 0.1918478722738931, 0.1805909478923997, 0.16783664610991544, 0.1880053649830009, 0.1945648513044308, 0.19349461186630745, 0.19141609249017155, 0.08396914470623107, 0.08866256223732416, 0.08326165955884612, 0.08162541341376872, 0.07780175987812932, 0.07677780069105322, 0.11089887227957917, 0.08708032855300496, 0.0837163296429706]}, "mutation_prompt": null}
{"id": "3671ab27-a301-4fd4-8139-ac6f82bd4ce1", "solution": "import numpy as np\n\nclass HybridAdaptiveDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Slightly reduced population size to allocate more evaluations\n        self.F = np.random.uniform(0.5, 0.9)  # Adjusted differential weight range\n        self.CR = np.random.uniform(0.6, 0.8) # Narrow crossover probability for exploration-exploitation balance\n        self.w = 0.6  # Adjusted inertia weight for faster convergence\n        self.c1 = 1.4 # Adjusted cognitive coefficient\n        self.c2 = 1.7 # Enhanced social coefficient for stronger global guidance\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Balanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True # Enable dynamic strategy selection\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.1 * np.random.rand()  # Randomize within a new range\n                self.CR = 0.6 + 0.1 * np.random.rand()  # Randomize within a new range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n        return self.global_best, self.best_fitness", "name": "HybridAdaptiveDEPSO", "description": "Hybrid Adaptive Differential Evolution and Particle Swarm Optimization with Dynamic Strategy Selection and Fitness-Based Learning.", "configspace": "", "generation": 77, "fitness": 0.33586292925116285, "feedback": "The algorithm HybridAdaptiveDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.8662857564411591, 0.8499484278763734, 0.8585736872048363, 0.8403102787608734, 0.8618294828565952, 0.8712050539785433, 0.8713578954056439, 0.8591620002796978, 0.8672240386204992, 0.6491108514210091, 0.7254592321695661, 0.5902437349880427, 0.7222223486030854, 0.7049463526711154, 0.7372239255583988, 0.7210744612455146, 0.707939847280212, 0.723079853856978, 0.5947998615732943, 0.14680741749873394, 0.11933486524955128, 0.49987786644165033, 0.14932808030089817, 0.16777379878521692, 0.1375760388699453, 0.1502690855590587, 0.13590145728833702, 0.12634444666913913, 0.11197838982651043, 0.112305562780181, 0.11640729953562445, 0.1335000287215573, 0.09787562406243511, 0.12150096009740319, 0.1528262731145298, 0.11821985006987457, 0.9745769327514424, 0.9759137340493065, 0.9744721589790506, 0.9728877615885674, 0.9673830880628883, 0.9783974868514876, 0.9748908477871987, 0.9732740709040979, 0.9738123659693602, 0.6739960004562169, 0.6851832824369699, 0.6050531918483955, 0.6592348471128222, 0.6586642022239313, 0.6620585014269595, 0.5618688006478219, 0.5975737281949989, 0.642440828466631, 0.22813198671797486, 0.7573025525925992, 0.7688889045848093, 0.21251481920386084, 0.3646301368780802, 0.8396994034388602, 0.2353816647070338, 0.24440076425934287, 0.23713333299977102, 0.32182296272800537, 0.24513323404450804, 0.13178788073422476, 0.21207362476690705, 0.1410218863954904, 0.20812941615966252, 0.21124253982568353, 0.20413039406439637, 0.27833179035559497, 0.1311548583417298, 0.22864769025821807, 0.21975370563444563, 0.21651396420047275, 0.2690078538235142, 0.273172185774466, 0.24988899602029957, 0.22162868637237376, 0.23447486898117298, 9.999999999998899e-05, 0.0005049976891911001, 0.009353205335555281, 0.0008181784897649536, 0.04579422980158088, 0.0702984140341989, 9.999999999998899e-05, 9.999999999998899e-05, 0.009790431290939927, 0.1557157391420022, 0.0769628699706364, 0.0982361496164782, 0.17580512902721224, 0.05576094330317427, 0.10474761516855846, 0.19736804876175806, 0.1552282476392951, 0.11797552629265573, 0.03604299395314392, 0.06458344251991655, 0.09771287146014851, 0.11561846655991015, 0.08113217319896848, 0.14394281011489474, 0.18343035974064814, 0.07115921156982163, 0.07191205576014303, 0.1316151725428374, 0.1677427833959778, 0.1289628792956874, 0.12977047821677656, 0.28469389564276804, 0.22055086858720252, 0.08103866170125018, 0.17949079482771535, 0.11765087261852913, 0.5758022451144758, 0.543428148064399, 0.5275275635158068, 0.5522593333249832, 0.6046797978093821, 0.631819526203164, 0.5941677907478635, 0.5383079315553774, 0.5517300428087294, 0.13147175649022524, 0.0988641670794741, 0.15510627038718827, 0.15253355387497103, 0.12118978493966548, 0.10285245487636452, 0.14146752954666209, 0.16431113371738015, 0.11072745762133018, 0.6530760280011986, 0.2287398579788763, 0.19569159335209596, 0.24799411590574305, 0.19955532487688354, 0.36343263524819935, 0.25479266061482553, 0.2734680744897181, 0.3143384997263161, 0.32345235167691755, 0.434240705211711, 0.3644059969807152, 0.4867722249352965, 0.27370135334709045, 0.3341884067185059, 0.41440991395201565, 0.553525242642517, 0.4058557356074589, 0.21405881528068804, 0.2599712702428978, 0.2817244016973971, 0.27326956158151705, 0.2706111128110542, 0.322580534987997, 0.284142344626526, 0.2983200906143738, 0.24170439783949693, 0.21469851268754525, 0.2564083952031797, 0.21459776190390234, 0.20772833208162111, 0.19895930811882123, 0.24921457289614657, 0.19808994396652535, 0.2435734396826399, 0.2591143991583341, 0.22538413675018742, 0.7207713139846156, 0.19867370232416115, 0.18778077981921537, 0.2209351273871315, 0.2040334468913415, 0.25054882290472513, 0.21921000291097903, 0.20179938563473088, 0.1748889761968463, 0.17478961827818706, 0.15858947387573064, 0.8979186007604917, 0.919698103394478, 0.9012798700936353, 0.16486553370448653, 0.9127674848708219, 0.13638791536333283, 0.07348278009096798, 0.16974090240225703, 0.8327167839667625, 0.211991922578613, 0.11292145797314024, 0.210565633060679, 0.15664368936953255, 0.21328892432095448, 0.8232094047084442, 0.20110420856704447, 0.19771539893397172, 0.19789334674109227, 0.1857312540576358, 0.19092725838240787, 0.20318512237507502, 0.1789947117875469, 0.1999237476304141, 0.17589916447073195, 0.11767412678354106, 0.0913079051595641, 0.08780575344800712, 0.09319496119396076, 0.08425068892836629, 0.10171665005334452, 0.08497563864403168, 0.08608718468655274, 0.08525081191417216]}, "mutation_prompt": null}
{"id": "8004a28f-0727-4f34-aa88-1e9c1844201b", "solution": "import numpy as np\n\nclass DynamicSelfAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.F = np.random.uniform(0.5, 0.9)  # Adjusted variation range\n        self.CR = np.random.uniform(0.6, 0.8) # Adjusted crossover probability range\n        self.w = np.random.uniform(0.4, 0.6)  # Dynamic inertia weight\n        self.c1 = 1.2  # Adjusted cognitive learning\n        self.c2 = 1.7  # Adjusted social learning\n        self.velocity_clamp = 0.4 * (self.upper_bound - self.lower_bound) # Modified velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        self.learning_rate = 0.1  # New adaptive learning rate\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.5 + 0.3 * np.random.rand()\n                self.CR = 0.6 + 0.2 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Adaptive learning rate influence\n            self.w = np.clip(self.w + self.learning_rate * (self.best_fitness - np.min(fitness)), 0.1, 0.9)\n\n        return self.global_best, self.best_fitness", "name": "DynamicSelfAdaptiveHyDEPSO", "description": "Dynamic Self-Adaptive Hybrid Optimization combining Differential Evolution, Particle Swarm, and Adaptive Learning Rate.", "configspace": "", "generation": 78, "fitness": 0.23873501669379313, "feedback": "The algorithm DynamicSelfAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.25.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.721092232443884, 0.2671560201157386, 0.2792998715557339, 0.8625266851695882, 0.9018767833982682, 0.31217195235831874, 0.2889334637378467, 0.8461703810511683, 0.31515554150288894, 0.6753009007252108, 0.7964918802688428, 0.7272763152134394, 0.000932560346773248, 9.999999999998899e-05, 0.7347241364043227, 0.0003252864790181942, 0.7893881105962035, 0.7336370420073908, 0.13750697005215584, 0.14115145009716923, 0.0631467651864015, 0.1314833770483107, 0.11093482275090305, 0.0644009670560286, 0.12075067994875066, 0.08388727929414486, 0.08444168799052787, 0.11027123500570746, 0.594129010675758, 0.06858105801145031, 0.07496311298834857, 0.10856111721409267, 0.06246072017361626, 0.06916076077166855, 0.07030160425355592, 0.08166922220898054, 0.9773885120441121, 0.9745315108962257, 0.9862603246220953, 0.9678501576605771, 0.9763075675845201, 0.9791640022265401, 0.9770631045941732, 0.9765162274696316, 0.97639824261742, 0.1717032363114116, 0.7348279922406634, 0.3529155924672649, 0.13161766754143844, 0.14186513947560886, 0.13189479393833303, 0.16375423604093864, 0.6993719536051974, 0.680281513165789, 0.18952345824285333, 0.16434941276747284, 0.19430245606330787, 0.1657611861884405, 0.20362712711043252, 0.1840171710494024, 0.12217936486748149, 0.8529159804825711, 0.1908496909559424, 0.06318686090231551, 0.05327771559024841, 0.0745161749642903, 0.06350405178079255, 0.12852127818616466, 0.23204058022037344, 0.06966528987386666, 0.05095464761153001, 0.23594800231888757, 0.19752074196179137, 0.2068065000674827, 0.05885288464818694, 0.061375948813855774, 0.006097902359152085, 0.25340637160150326, 0.09289984083188663, 0.04212760162994178, 0.25256435196991067, 0.00010269941378915348, 9.999999999998899e-05, 9.999999999998899e-05, 0.03301671848533205, 0.0005604809801781352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008601304578162439, 0.06496188601323594, 0.03113979876953421, 0.07792673525555216, 0.007940598984489733, 0.01010704736707757, 0.12685356144814175, 0.07883285169360865, 0.13015007842575288, 0.04303458871980825, 0.09935731790246793, 0.05920009243968494, 9.999999999998899e-05, 9.999999999998899e-05, 0.09619893122073375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020134308652646538, 0.13514129772251582, 0.025720348410749994, 0.04430930277299394, 0.02894677510024335, 0.11139309317732282, 0.047738610398440184, 0.03689765615363272, 0.03993701523389259, 0.5367508901390313, 0.5395224388871298, 0.5459751755031991, 0.489886461787699, 0.5721320092485831, 0.5709734267694444, 0.6078563405083376, 0.25989379266654367, 0.28252218673045815, 0.0877102416348402, 0.08548756408856828, 0.12286685535717101, 0.0664814090558119, 0.07313876827750843, 0.1308263062113605, 0.10569625721848408, 0.07780497844998224, 0.08101546235871104, 0.25513012507391963, 0.2694300430102464, 0.3109803997943017, 0.30593931542995256, 0.14294916969894655, 0.43437188759792356, 0.1411213648917845, 0.26562172756077873, 0.1578157760504475, 0.2715470576649559, 0.23248973202830503, 0.523763444143323, 0.21293969791031853, 0.41376060350975385, 0.4658928763523269, 0.22764589113811107, 0.6330627294433012, 0.38846025516333316, 0.22915607249628633, 0.14364103457001187, 0.1638537930200208, 0.15262438180293358, 0.15078343997774102, 0.1257526397215577, 0.17904286940609504, 0.16663150885002576, 0.19978748531631507, 0.19936533625362773, 0.19895569869432572, 0.18051120536311716, 0.20021991372294523, 0.21557015002313995, 0.21147983360887024, 0.1800838155463782, 0.20692917685976786, 0.21272336643614287, 0.16313646509839652, 0.24548643219107802, 0.1632781028402004, 0.16836325832508559, 0.2203253115612096, 0.16852866555621127, 0.17309437837173425, 0.1617554846372714, 0.17850454619867817, 0.34838218326267856, 0.18497454440355177, 0.3411794647897841, 0.14674475995625613, 0.18604327496878992, 0.15428201603239955, 0.2597667658756284, 0.15896686656446235, 0.16200942604637514, 0.20215272719797417, 0.1907653630370333, 0.18996685637331445, 0.15415540632716207, 0.16878809440946885, 0.6822682245678326, 0.1574181545628306, 0.16633996796453088, 0.28564531537988247, 0.18759146272355476, 0.20461159497006942, 0.1818972890757382, 0.18289686358689572, 0.20082371756150863, 0.19164492545420786, 0.18837228592838162, 0.19529040093337147, 0.19026431833057367, 0.06387388689884133, 0.0866452730574625, 0.06236634679434938, 0.060431718194610906, 0.083774475435893, 0.061478703220717246, 0.06584807988739849, 0.0690982866865455, 0.10078906661095788]}, "mutation_prompt": null}
{"id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "solution": "import numpy as np\n\nclass ImprovedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Smaller population to increase selection pressure\n        self.F = np.random.uniform(0.5, 0.9)  # Further increased variation in Differential weight\n        self.CR = np.random.uniform(0.6, 0.8) # Adjusted crossover probability for exploration\n        self.w = 0.4  # Lower inertia weight for faster convergence\n        self.c1 = 1.6 # Slightly increased cognitive learning to encourage exploration\n        self.c2 = 1.4 # Slightly decreased social learning to manage diversity\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.1 * self.population_size  # Threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.3 * np.random.rand()  # Randomize within a range\n                self.CR = 0.6 + 0.2 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "ImprovedAdaptiveHyDEPSO", "description": "An improved hybrid optimization algorithm blending Differential Evolution and Particle Swarm with adaptive parameters and a novel reinitialization mechanism to escape local optima.", "configspace": "", "generation": 79, "fitness": 0.36816958746513606, "feedback": "The algorithm ImprovedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "7c1add7b-ad0e-4545-80c1-708afa637045", "metadata": {"aucs": [0.9152762004010888, 0.9130777446153221, 0.9124590791860074, 0.9145023167864993, 0.9147408318682991, 0.9078108028688411, 0.9082164957491634, 0.9111903963581661, 0.9116823683763827, 0.8213189521823597, 0.8359550087856128, 0.8380337906941677, 0.8129876937246838, 0.8248428711601935, 0.827614221252543, 0.8294013537613542, 0.839332967886433, 0.8322073863127647, 0.15924161455141006, 0.391582339649748, 0.4532158102927165, 0.3426842694748027, 0.16281607392062947, 0.16593855564502014, 0.17096197965942717, 0.5824946165159285, 0.3995835789506603, 0.13820281288090885, 0.11445811152027585, 0.14318100916265086, 0.15798551890627965, 0.14870614202108334, 0.14797886749591727, 0.4963860614449589, 0.1527284960442572, 0.10630080946807718, 0.9609525557902937, 0.977200317232144, 0.9668873334283354, 0.9714674944568967, 0.9683560909531569, 0.9737591334586403, 0.9743020953406903, 0.9764303517986123, 0.9672002760345448, 0.7395028252905905, 0.7680385179698832, 0.7174474707778108, 0.6945123464229133, 0.764925217049174, 0.7594338826430221, 0.7287334331372313, 0.7587773527053876, 0.7240017740736757, 0.8797349546826186, 0.7990013820347561, 0.8586767362097243, 0.3830256564143161, 0.9245258772544501, 0.19363404981438292, 0.8907605930738276, 0.23745323190789291, 0.19551508533233108, 0.2999229995542433, 0.20936563859931412, 0.19633028889611726, 0.13401704513195833, 0.21061272252374197, 0.12773718270017276, 0.1313362920071004, 0.2275539116528098, 0.2218922905856705, 0.1768472588273764, 0.24365419761972673, 0.21556042299405997, 0.23489097369748646, 0.1343191337398255, 0.13340004476420475, 0.2450991503359392, 0.2593454120129238, 0.2600667046500178, 0.001298428207030855, 0.0908882868219707, 0.04397310108510988, 0.007041725868362159, 0.07014033873770531, 0.12761949316903975, 0.0525454765144594, 0.038590166483539856, 9.999999999998899e-05, 0.15259971688112695, 0.13868400076653398, 0.05693350502903127, 0.08394030786180151, 0.003943882863914561, 0.062454893517468135, 0.08269837151425019, 0.039741033784138735, 0.17751477790456915, 0.15054460669096714, 0.06995270317300495, 0.27530187382869775, 0.10621572437273574, 0.08482358294747938, 0.0952564865538238, 0.10501993486091576, 0.15779836074142617, 0.2426978803766352, 0.07671513195848456, 0.06900482871832503, 0.3583897190936768, 0.06630994319561123, 0.08570006334497426, 0.18232375176015414, 0.09176900719577785, 0.45341553979684257, 0.09433497654220824, 0.5643672828482045, 0.5663615758948926, 0.5482949449911803, 0.5794107057833617, 0.6613366858673406, 0.6485610242009353, 0.6168113214424424, 0.5820951837644326, 0.6117172337403527, 0.10270575065051057, 0.11751580775002368, 0.14285917340153742, 0.1818937415186338, 0.11825765661955778, 0.16766584559096098, 0.1545878319070607, 0.15178025660801264, 0.15678926111046987, 0.3393850947813204, 0.36791017136641124, 0.27688526836897764, 0.27161369597119145, 0.1955822410485405, 0.31695101189087116, 0.2353992467550704, 0.2696800118500403, 0.2364561708713947, 0.5350230641149698, 0.281216265905456, 0.4257943752253782, 0.316430079924652, 0.5604908371189209, 0.39317291707123625, 0.5847273978097961, 0.5563673777131736, 0.5874977151355147, 0.2949967424275949, 0.3213311503899223, 0.2965586202881424, 0.3262769498623057, 0.3363064588389265, 0.2973938218991793, 0.24059138856480744, 0.32182875091797714, 0.25414044145834014, 0.23266967893371793, 0.22224903985952515, 0.21671397685493865, 0.2202097035726741, 0.1985970012377427, 0.24930757082215638, 0.19813937120267966, 0.21877236527570587, 0.22400512399866523, 0.8381719277982146, 0.19466878074088467, 0.19393075033068718, 0.2503235564969244, 0.8021385086625388, 0.22391868830937334, 0.22784666415573174, 0.30846556458613505, 0.1970358655791239, 0.18767192345983685, 0.16347825888115353, 0.9083159672172675, 0.9425032071778554, 0.17786162828911833, 0.20068619564647927, 0.16799267755048308, 0.9207363111940536, 0.14171424183352188, 0.7791556549947889, 0.16840251698961728, 0.2123082714121297, 0.2102156694160997, 0.16934638413738246, 0.6824072944956452, 0.16564142706735874, 0.21235921000169433, 0.7989360142952012, 0.18837495509047963, 0.17706611493681723, 0.1815391630486597, 0.18063049240654805, 0.18352098958415997, 0.19915575881100944, 0.1767420980463148, 0.1877403789563653, 0.1812557416175129, 0.08878811583775426, 0.08270783904713241, 0.08677401480179014, 0.08807968660157472, 0.08873133392824606, 0.10109871159603157, 0.09190003831317028, 0.092885973216289, 0.09013746557599611]}, "mutation_prompt": null}
{"id": "2c496439-4185-4631-ad5f-79276cd6f134", "solution": "import numpy as np\n\nclass RefinedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = np.random.uniform(0.4, 0.9)  # Broadened the range for F to explore more\n        self.CR = np.random.uniform(0.5, 0.8)  # Broadened CR range for enhanced exploration\n        self.w = 0.5  # Adjusted inertia weight for balanced exploration and exploitation\n        self.c1 = 1.7  # Enhanced cognitive learning factor\n        self.c2 = 1.3  # Reduced social learning factor for diversity\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = self.population[np.argmin([func(ind) for ind in self.population])]\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        self.reinit_threshold = 0.15 * self.population_size  # Increased threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.4 + 0.5 * np.random.rand()\n                self.CR = 0.5 + 0.3 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "RefinedAdaptiveHyDEPSO", "description": "A refined adaptive hybrid algorithm combining Differential Evolution and Particle Swarm Optimization with adaptive parameters, dynamic strategy selection, and stagnation-based population reinitialization.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {}, "mutation_prompt": null}
{"id": "fa46ecaf-70bd-4ad4-8472-4fdd55688d2c", "solution": "import numpy as np\n\nclass EnhancedStochasticHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = np.random.uniform(0.5, 0.9)\n        self.CR = np.random.uniform(0.6, 0.9)  # Increased upper bound for crossover probability\n        self.w = 0.3 + 0.1 * np.random.rand()  # Stochastic inertia weight\n        self.c1 = 1.5 + 0.4 * np.random.rand()  # Stochastic cognitive learning factor\n        self.c2 = 1.2 + 0.6 * np.random.rand()  # Stochastic social learning factor\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.energy_level = np.zeros(self.population_size)\n        self.reinit_threshold = np.percentile(self.energy_level, 10)\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            energy_change = np.abs(fitness - self.personal_fitness)\n            self.energy_level = 0.5 * self.energy_level + 0.5 * energy_change  # Update energy level\n\n            if np.any(self.energy_level < self.reinit_threshold):\n                reinit_indices = np.where(self.energy_level < self.reinit_threshold)[0]\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedStochasticHyDEPSO", "description": "An enhanced hybrid optimization algorithm combining advanced DE and PSO with stochastic parameters and an energy-based reinitialization approach for escaping local minima.", "configspace": "", "generation": 81, "fitness": 0.3495249195981017, "feedback": "The algorithm EnhancedStochasticHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.30.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8993725645077473, 0.9293152910216097, 0.9143563632980125, 0.9015268794617963, 0.9201999382073259, 0.9153482055131198, 0.8924090459849318, 0.9269203531202903, 0.9172363788699999, 0.781584121086554, 0.8625467798458382, 0.8489866601509981, 0.8017238840214658, 0.8431818189690946, 0.841382129763505, 0.7694867955474763, 0.8533128183041498, 0.8450287635903064, 0.16137382017185375, 0.13053141012955072, 0.1780292796145142, 0.15107238007569812, 0.1286054322592357, 0.16052021992723609, 0.13671872820454622, 0.12358194721185789, 0.1432954042797019, 0.12826975397331664, 0.10918326770745534, 0.15177087273756895, 0.11076280824920726, 0.1154401045712099, 0.10507153376109746, 0.1162038787338906, 0.1195730812393202, 0.11980604837991815, 0.9805918682469852, 0.9739882454217078, 0.9832888071625112, 0.9716503242200117, 0.9699999078579628, 0.966641442884693, 0.9747535063525987, 0.9583909280736551, 0.9779831440713458, 0.6941080610868712, 0.7953243463391853, 0.7843298095771114, 0.698635665360402, 0.7909840460923919, 0.7417185353769018, 0.6703995875659869, 0.7820845919899133, 0.731803040772928, 0.3853415492021859, 0.6108045874264035, 0.13998872534884654, 0.2803695202801699, 0.9204853385412521, 0.37995542632710433, 0.39611336801648844, 0.24437768976301233, 0.2410935000880131, 0.214477016354492, 0.21406523752343043, 0.24737166403265853, 0.23971603068103675, 0.12975207295925995, 0.22788727094360572, 0.3810173089288419, 0.20001402165289817, 0.2070958459188671, 0.23430525099251986, 0.1231359514221364, 0.2266508660069133, 0.2341470707358294, 0.1737165351047928, 0.22397745488752685, 0.25668309622418806, 0.24146839718408541, 0.1927804161890777, 0.015888047630161606, 0.06266023068253523, 9.999999999998899e-05, 0.09810101299167473, 0.0472386614011544, 0.03189869946715429, 0.00011064130473825706, 0.010217512702523135, 0.009597352866014486, 0.09272025743158152, 0.09647035754135891, 0.1230760734583497, 0.10376013516988458, 0.1359659535646398, 0.08907094680314898, 0.02560078865022608, 0.05987070537364947, 0.06823553533660431, 0.05048603777997229, 0.18219561471345092, 0.21256583949613006, 0.15128883644791913, 0.08295512150402262, 0.0947010124918457, 0.21350527471336922, 0.1366219286859317, 0.2956034532996008, 0.0638845670485787, 0.358099762842931, 0.06656869428680023, 0.20031871486269182, 0.1862381950784484, 0.095921044178784, 0.16099968091687822, 0.06527473873179879, 0.0901660751462714, 0.5623089898842958, 0.5696173572604247, 0.5491172535590895, 0.6157046585880273, 0.6170219600797686, 0.6610864223740354, 0.6098105129692415, 0.5916018368695775, 0.597360798387178, 0.1377091602043864, 0.10769535372762784, 0.09071231456829987, 0.13450761229006292, 0.1134222958943032, 0.1452961334638403, 0.1133214677736265, 0.1422576033176045, 0.18041075275586316, 0.2272349547077609, 0.179476216519035, 0.23228522384436967, 0.2931889427199823, 0.2507143976059335, 0.27098536688391783, 0.15988998920771358, 0.2456987920316125, 0.3398339056426295, 0.3809003841106047, 0.24418718576842346, 0.3280126421107147, 0.3413361158897831, 0.25550182147181966, 0.41169846933679155, 0.6848507198049194, 0.6608283770729229, 0.6331315047746684, 0.36465553242569915, 0.1708339773300519, 0.2761093140887295, 0.34640197119257243, 0.224636545086199, 0.35594577991677545, 0.2803606581410202, 0.37695221458165795, 0.28734429988214116, 0.22037676412128715, 0.21545371639734534, 0.21152147640972385, 0.22033943764732566, 0.22063643458256044, 0.24634272197673202, 0.2038722073605479, 0.2060622777987553, 0.2428466585528375, 0.18728926273073154, 0.2226166105733226, 0.24547608732177828, 0.2163976818128297, 0.19778056612505512, 0.8268057461626817, 0.2158922325773045, 0.1878429205295996, 0.18902668112116694, 0.1582134883847044, 0.16749446049634464, 0.908234732263591, 0.8974527844676337, 0.16941213918231512, 0.12546413565706316, 0.8853535923680427, 0.9168775984263634, 0.1537334382133695, 0.6903949345670835, 0.21083735654355173, 0.12579860222072292, 0.838244245160063, 0.8826753661261064, 0.6841104224252036, 0.16789439320359345, 0.16516400437756296, 0.1558270078356807, 0.17961953394139707, 0.19069293768745776, 0.1894945129783303, 0.18714928405796905, 0.18023281876693797, 0.18128222037757225, 0.1832691550525476, 0.18469330859536703, 0.1871193807969025, 0.0898288839373641, 0.09203304550768576, 0.08043955713096407, 0.09084813200674347, 0.08729855030268885, 0.12926101504831855, 0.1066790044179643, 0.08834659600214201, 0.08220138646430697]}, "mutation_prompt": null}
{"id": "e99d95ef-112c-4e82-932c-0f73296c9fb2", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = np.random.uniform(0.5, 0.9)\n        self.CR = np.random.uniform(0.6, 0.8)\n        self.w = 0.3  # Adjusted for better convergence\n        self.c1 = 2.0 # Increased to enhance exploration\n        self.c2 = 1.2 # Decreased to maintain diversity\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Modified velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.dynamic_F_CR = True  # Enable dynamic strategy adaptation\n        self.reinit_threshold = 0.15 * self.population_size  # Adjusted reinitialization threshold\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.dynamic_F_CR:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Expanded range for more adaptability\n                self.CR = 0.5 + 0.3 * np.random.rand()  # Expanded range for crossover\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-6:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "A hybrid optimization algorithm that dynamically adjusts Differential Evolution parameters and integrates Particle Swarm Optimization with adaptive reinitialization to efficiently explore and exploit search spaces.", "configspace": "", "generation": 82, "fitness": 0.3382417254451482, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9330197479694293, 0.9096940126980523, 0.9186601513740403, 0.9251080525563102, 0.915499220292962, 0.92179432179542, 0.9264439178986332, 0.923650546705624, 0.9218838375173944, 0.8598966095434744, 0.8540631411530021, 0.8503008252794494, 0.8380480430962579, 0.8528425064077735, 0.8540468099469153, 0.8553341398322407, 0.8429803800335086, 0.8524062898214957, 0.38680557030698437, 0.3196397757529197, 0.4608909445613635, 0.15342531948056748, 0.17534508783316738, 0.14562362446377775, 0.15670472102074928, 0.5933024000515432, 0.17681547335141823, 0.1627583405255857, 0.1666177261479601, 0.14614624481553107, 0.1594674874840657, 0.1360605478404674, 0.11474955735795933, 0.10971212920830986, 0.16340631871091937, 0.13303251950413286, 0.9618468607290006, 0.9673033697141056, 0.9749355089956853, 0.9683216563744804, 0.9712495114076344, 0.9730223018512963, 0.9619214471823372, 0.9589942186309949, 0.9766312586405193, 0.745366281405086, 0.7729332660920001, 0.7161860486291936, 0.7856414638725943, 0.7896544166396894, 0.7481927107582031, 0.7275807250547663, 0.7486455649440185, 0.7418948075921564, 0.2268429251417915, 0.9136636818394169, 0.24673840206978948, 0.28146762421293503, 0.9233275904500142, 0.21311072282157784, 0.24578343054115703, 0.24729498708543918, 0.23721614295596516, 0.16847699609797606, 0.13207412613168035, 0.1637678034987099, 0.1836901859130593, 0.3278626519324688, 0.18111598011802799, 0.18092022085977255, 0.194190879049414, 0.1816864833334253, 0.19892381444688545, 0.2220982544516643, 0.17147847732637478, 0.13406545620597732, 0.155531470024046, 0.13242505573233665, 0.24648284041954294, 0.22889337760634898, 0.22233839900907337, 9.999999999998899e-05, 0.0427562587800403, 0.0020628353637088814, 0.0013174403066928964, 9.999999999998899e-05, 0.013070029659073779, 0.0004128335754365331, 0.022564624846881265, 0.04449561511141875, 0.13353213751189674, 0.12840000310293653, 0.06786033754449838, 0.024785992005373236, 0.09893275615299313, 0.10271830045125774, 0.04200410127339271, 0.1323967057444777, 0.07671653030989511, 0.1130448347052585, 0.1644923256052755, 0.03776457742592465, 0.17355923205370616, 0.08105548968956078, 0.22005337596433294, 0.08788761099295805, 0.07587907191695664, 0.189924827860247, 0.2362479742550827, 0.12465294758973522, 0.2305680289276365, 0.06541272517213292, 0.06653174116074312, 0.04766358852040298, 0.08501871273344097, 0.2004192158940702, 0.08486124833467568, 0.5858279014220412, 0.6459346476043513, 0.5648750730115908, 0.5854020391097401, 0.6111209765678962, 0.5684044987038961, 0.6008854511988481, 0.5841311502555122, 0.628039462901212, 0.12235619989394542, 0.13330607207522027, 0.10015368933012436, 0.14473075677498037, 0.1442852448908708, 0.10631145928257413, 0.11026304595405256, 0.13145445500049535, 0.13266380617402918, 0.3422172215915026, 0.193549324389784, 0.25909622586154524, 0.14292200562172053, 0.21242556276261215, 0.28917590168351304, 0.2045758417508189, 0.3407216692513938, 0.254271860239107, 0.38209642930935805, 0.5813731779170768, 0.3381628353264198, 0.3023453103066157, 0.463479034898053, 0.3561308958851077, 0.7142892581457851, 0.5511620381804371, 0.44654632217425505, 0.24185996362290962, 0.26963206437667675, 0.40816957202313, 0.26298981671192, 0.2297120940376972, 0.43633984189045194, 0.15608696750112028, 0.29730452241707794, 0.22425076724575266, 0.23954487899699417, 0.22617083240313962, 0.24505474043672792, 0.21906044031452931, 0.20162639729032494, 0.20162736444576634, 0.20943141748246275, 0.22801901427105387, 0.20722836358547192, 0.22294616231714537, 0.20976025228515605, 0.22190181662013664, 0.2098477555996665, 0.22927941778310224, 0.2217212754631367, 0.2122838231446662, 0.22431853631917498, 0.22205488937071016, 0.18811243160924374, 0.17439131089612803, 0.18488989339482553, 0.17235424112284958, 0.1770478877092293, 0.9243162099991724, 0.20985108804584895, 0.1749603223921118, 0.13646839204751016, 0.21111889478398504, 0.6846261603933383, 0.1692667810327967, 0.16860547592478925, 0.2102748496643586, 0.8006577380430783, 0.1680390716580279, 0.2126308519988862, 0.7691384203309828, 0.18053805255355238, 0.20290006687942586, 0.17699260440542408, 0.1777735914253813, 0.19020315475366756, 0.17225325142126224, 0.19969089703743803, 0.18225895744704945, 0.17782464212915017, 0.09315797412849347, 0.08767342832613356, 0.09193507262668832, 0.09049779566898086, 0.08718023743532488, 0.09322840824162681, 0.08106288460623712, 0.09393336986119849, 0.10421868208507201]}, "mutation_prompt": null}
{"id": "dedc91d1-3241-4007-af40-5089d3134bb5", "solution": "import numpy as np\n\nclass RefinedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population for better diversity\n        self.F = np.random.uniform(0.6, 0.8)  # Balanced variation in Differential weight\n        self.CR = np.random.uniform(0.5, 0.9)  # Wider range for crossover probability to enhance exploration\n        self.w = 0.5  # Moderate inertia weight to balance exploration and exploitation\n        self.c1 = 1.5  # Balanced cognitive learning\n        self.c2 = 1.5  # Balanced social learning\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.15 * self.population_size  # Increased threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.5 + 0.4 * np.random.rand()  # Randomize within a broader range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-6:  # Increased sensitivity to stagnation\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "RefinedAdaptiveHyDEPSO", "description": "A refined hybrid optimization algorithm integrating enhanced Differential Evolution and Particle Swarm mechanisms with adaptive strategies and advanced exploration capabilities.", "configspace": "", "generation": 83, "fitness": 0.3529038625693515, "feedback": "The algorithm RefinedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8650121567138858, 0.8604817664349552, 0.8704788288217034, 0.8655174403205013, 0.8607987462715275, 0.8539052904436871, 0.8634691824927468, 0.8607619986350186, 0.8482576337891062, 0.7422529052611994, 0.7336501799171791, 0.7410713572653181, 0.7234638879861264, 0.7526853819705264, 0.7168904907790142, 0.7427018557444839, 0.7364861957235129, 0.7381738673427749, 0.1693888279102077, 0.2263664352816941, 0.17627432941648635, 0.15574532601651425, 0.3508778014862354, 0.21829266105070833, 0.15242906830530267, 0.17252884833124804, 0.1595470187225334, 0.15789765791248644, 0.13883017081954496, 0.13211460717367207, 0.1150418804144141, 0.13807245167965554, 0.1338975901393611, 0.5627283663775215, 0.1373116097900272, 0.13696550618870662, 0.9731981553598306, 0.9631121786353449, 0.9743024720240157, 0.9681083081096695, 0.9772973239191025, 0.9772874037228608, 0.9732328625181362, 0.9746817940331213, 0.9693875655867323, 0.6493429117935381, 0.6486390437325869, 0.6557605020903692, 0.6537822285914013, 0.6429889406910549, 0.6465901613391702, 0.6210683689030717, 0.5613021187673093, 0.6222745403362551, 0.7771533870875971, 0.23013351604777477, 0.794729204159257, 0.20957896146485422, 0.27391873036470693, 0.3724534913223291, 0.2336849494234654, 0.8927874591463029, 0.5806813966004074, 0.21540668396102614, 0.2172047683065239, 0.21382507978372045, 0.13138331101128387, 0.20366527655648647, 0.20962025879184532, 0.24017694044388926, 0.20482990720840333, 0.20521350869292543, 0.22646824694188372, 0.23448645364059872, 0.23352728045284654, 0.23484890572863837, 0.1307848530673127, 0.24037464585384272, 0.24535007405523124, 0.2782145115801713, 0.24236114017765809, 0.09160934524460007, 0.07842366735244344, 0.05786385606683231, 9.999999999998899e-05, 9.999999999998899e-05, 0.1500773108251311, 0.024997224061600876, 0.005169634203301077, 0.0001495362622676577, 0.05989535027280113, 0.12234231424405628, 0.030560972074352266, 0.14792966862896995, 0.07743928059575023, 0.030571365769595515, 0.11137294483728788, 0.09946916707109954, 0.07234210860247547, 0.05068994464040988, 0.058414741488335364, 0.04844439683058177, 0.1684636674954343, 0.07810375154272042, 0.20205049250303087, 0.38211608925543183, 0.12616217867677892, 0.08484460062718513, 0.14559290253356416, 0.14797017219112762, 0.10436493694801952, 0.16357386651572392, 0.1524308853049311, 0.12072059911281774, 0.21433325815922766, 0.13659456053662256, 0.18778219649624905, 0.5283645666248002, 0.5873475617667725, 0.603655283752405, 0.5522170238787815, 0.5902814896917968, 0.595160801036714, 0.5497117081421201, 0.5815285571774884, 0.5613461217327516, 0.09441801285420337, 0.15248607094427824, 0.11131466047960581, 0.09491450380574129, 0.1418065028141995, 0.08919278175861423, 0.13968942452106836, 0.13587003572774026, 0.1224874344381417, 0.30075070043801944, 0.34778096119116, 0.24942929982976325, 0.1822954159743042, 0.2658632715090069, 0.1515534604441875, 0.5234399914839645, 0.2931922032900004, 0.2100641811021866, 0.4389463252697573, 0.4535500824030132, 0.5084822539786855, 0.5953509612091361, 0.5439479093928719, 0.44939173915705244, 0.5556212928668749, 0.5630720286174073, 0.5671100088290433, 0.21432490388618142, 0.31111836346604305, 0.321322909629034, 0.3378375293715902, 0.24564541572178922, 0.3098395371879621, 0.24964064371968864, 0.246145023440013, 0.3141792255649455, 0.1982442096092415, 0.17346727814857443, 0.20555408555058174, 0.207635986752567, 0.1944812958316987, 0.19693593673761478, 0.20455475477653817, 0.23578423057328401, 0.21408990835478603, 0.24304711765040343, 0.24020688022184866, 0.2225678565724597, 0.666401965259495, 0.6937640397679852, 0.24343392175867906, 0.23272242625820283, 0.7071694614898123, 0.7320948155003222, 0.1472380237382751, 0.18728012633350077, 0.1762061026158397, 0.878845318445503, 0.19512933210536587, 0.9039223001022281, 0.8661900246312256, 0.12447431590507352, 0.16215362123042398, 0.16770231890035392, 0.16831059636620627, 0.7777156765783113, 0.8341554525766012, 0.2108780759824216, 0.1272812832538337, 0.1558967477614529, 0.7373441070659896, 0.8608139493329154, 0.1915964440985909, 0.18447978514110408, 0.1881830587323049, 0.17550019988043064, 0.18324645582731414, 0.1753703397141395, 0.18972257440053197, 0.20070380974706659, 0.19142548418512262, 0.07772157488992792, 0.09539218305378871, 0.10964423234066567, 0.08593097259669447, 0.08973310361332765, 0.08918800878057753, 0.08494195385689074, 0.08267215909422032, 0.08774411924181624]}, "mutation_prompt": null}
{"id": "73010bb1-7154-422d-8147-a60d5f335ac0", "solution": "import numpy as np\n\nclass RefinedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population for diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Wider range for Differential weight variation\n        self.CR = np.random.uniform(0.5, 0.9) # Wider range for crossover probability\n        self.w = 0.5  # Adjusted inertia weight for balanced convergence\n        self.c1 = 1.5 # Adjusted cognitive learning factor\n        self.c2 = 1.5 # Adjusted social learning factor\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Increased velocity clamp for exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.2 * self.population_size  # Increased reinitialization threshold\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Randomize within a wider range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-4:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "RefinedAdaptiveHyDEPSO", "description": "A refined hybrid optimizer combining Differential Evolution and Particle Swarm with dynamic parameter tuning and strategic reinitialization for robust exploration and exploitation.", "configspace": "", "generation": 84, "fitness": 0.3357049007116031, "feedback": "The algorithm RefinedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8510150903589497, 0.8516495400019337, 0.8539772225259905, 0.8619249093195245, 0.8425627738473112, 0.8676899170892605, 0.8650083184613717, 0.8626956983880555, 0.8501437399549197, 0.7000595687907484, 0.6698252790651674, 0.7288680108574321, 0.7292010754440013, 0.7321504013418616, 0.6844015611800929, 0.7065755264992006, 0.6868285976592492, 0.7159756583820257, 0.3939143655430041, 0.570080425062318, 0.16732484570325434, 0.13942852877434708, 0.15264723702549854, 0.3959627393151711, 0.17686010491595194, 0.16896509392115788, 0.15664657928527193, 0.14635863406494098, 0.13557971881005737, 0.14252026947603824, 0.12849120263666847, 0.1112092067711401, 0.15391794025248495, 0.12194915932689909, 0.15325621717589133, 0.14947808877291757, 0.9776752281308823, 0.9677734652245288, 0.9726942979968092, 0.9714446805169499, 0.975296507772834, 0.9816425108771162, 0.9655402409717081, 0.9737411264211109, 0.9728136671609047, 0.6426521762951023, 0.5846129870026628, 0.6280423688161332, 0.5992334259404257, 0.6305709452059627, 0.5791352888261059, 0.5788092201989731, 0.6391334014200859, 0.5731755418303979, 0.3810823963420611, 0.20092503418049312, 0.8286777682002764, 0.2760550030248631, 0.2792837147530405, 0.8406114943268723, 0.2343270997167327, 0.7737836008193545, 0.23163011396191036, 0.1287956557842348, 0.23981821466060504, 0.2070250390701318, 0.13127876838997765, 0.207234288597673, 0.26031989997621896, 0.21035813715093954, 0.2145884793567011, 0.24242728707087036, 0.2232334004597326, 0.13311945999354635, 0.2405072806882662, 0.12526270539935613, 0.13317343417242444, 0.15527826356824304, 0.2519000572468165, 0.2392076790090586, 0.25831377656351984, 0.042360776169106384, 9.999999999998899e-05, 0.03525976367433126, 9.999999999998899e-05, 0.0841704536442548, 0.07205381615577444, 0.07831879460907243, 0.11270934072584282, 0.02248335386871203, 0.05706021498360647, 0.1107773851309376, 0.10781482153238398, 0.10908958542475755, 0.14430848336408109, 0.024146104717847616, 0.07836516794085013, 0.1406516134609166, 0.04669448571797297, 0.28740956978847754, 0.04988059896929409, 0.049326899099230825, 0.1509747615657645, 0.1050723618792424, 0.27925630603907214, 0.21296260571608383, 0.24889083391893707, 0.12496848306515362, 0.2716112142386601, 0.08628333579673508, 0.09181530866320953, 0.2509633501855544, 0.13719807761682423, 0.04687730545235813, 0.1618455284096384, 0.22356993555569027, 0.2258916162871878, 0.5654752629128659, 0.6040977909223393, 0.5227619602859113, 0.6276131293280518, 0.5715299056030811, 0.5468086386046901, 0.5455443035455545, 0.6101750212796979, 0.5780925561047896, 0.1063529381828221, 0.11357605163248641, 0.13122460458433638, 0.14335059298099784, 0.1081100167876079, 0.08698753646958779, 0.10969476330095718, 0.13552125170621165, 0.11004565367794272, 0.18257443980257382, 0.2479162042384896, 0.1563430852105181, 0.17877043496800948, 0.2598573946663849, 0.43937373072276364, 0.23281522220920214, 0.21829540396166236, 0.24629786383262697, 0.5514753448810732, 0.4762706110360233, 0.4557991281065158, 0.4849144998333591, 0.4815781754391426, 0.5493710538542873, 0.5207265317936994, 0.4998766054254272, 0.5979286884567754, 0.3393562708663507, 0.324811366687072, 0.3592611885855991, 0.20543969095263215, 0.19848022523884745, 0.1837258011595322, 0.2908864517697386, 0.2252900260472832, 0.3266472223539988, 0.23011717878814364, 0.19827432602621653, 0.2336718216415602, 0.21337574938429948, 0.22418282872733586, 0.20960100454718922, 0.19914555378852594, 0.22941633438189124, 0.2653175649855657, 0.2028416937202373, 0.24326902860975852, 0.1987341378860984, 0.21465295494507963, 0.216219502349266, 0.23640335410057223, 0.22161128230818672, 0.7359481771113934, 0.20543102306520344, 0.16197437719645913, 0.16474802639181763, 0.19869993283550846, 0.16113559348765105, 0.14762679852798788, 0.8715021433606673, 0.13120701163870452, 0.8997495619441226, 0.16248512238395796, 0.21043656743377148, 0.1681340264459379, 0.2112188338163734, 0.16867275884705235, 0.15390183966778748, 0.12749322537388852, 0.6201897742337361, 0.8457899874240158, 0.8473310981285593, 0.1798236778277985, 0.19022964456436187, 0.18041227507238167, 0.1911519013091747, 0.17818155332160857, 0.21660327951269753, 0.1798850312634117, 0.20087919402474652, 0.1856408663700646, 0.09041342860804757, 0.09430728505394637, 0.0864530909504565, 0.08827958407741787, 0.09271348092460119, 0.10840823195292648, 0.10799685219571142, 0.08541221522514353, 0.11530149347744212]}, "mutation_prompt": null}
{"id": "01ab0d08-f79d-45db-97ef-72ce1819c43c", "solution": "import numpy as np\n\nclass DynamicBalancedHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = np.random.uniform(0.4, 0.9)  # Broadened range for F to enhance exploration\n        self.CR = np.random.uniform(0.5, 0.8)  # Broadened CR range for exploration and exploitation balance\n        self.w = 0.5  # Slightly increased inertia weight to enhance exploration phase\n        self.c1 = 1.5  # Enhanced cognitive learning slightly to maintain diversity\n        self.c2 = 1.5  # Balanced social learning to improve stability\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp for finer movements\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        self.reinit_threshold = 0.05 * self.population_size # Adjusted reinitialization threshold for finer control\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.4 + 0.5 * np.random.rand()  # Adjusted range for dynamic F adaptation\n                self.CR = 0.5 + 0.3 * np.random.rand()  # Adjusted range for dynamic CR adaptation\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "DynamicBalancedHyDEPSO", "description": "A dynamically balanced hybrid of Differential Evolution and Particle Swarm Optimization with adaptive parameters and intelligent reinitialization to maintain diversity and prevent premature convergence.", "configspace": "", "generation": 85, "fitness": 0.34589201180178325, "feedback": "The algorithm DynamicBalancedHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8963848688160304, 0.8878041377704918, 0.8983640767073431, 0.8938167868548487, 0.888722636687144, 0.8947090610794357, 0.9024949807660286, 0.8955520892151526, 0.893993137483913, 0.8090186898072547, 0.7787014492806226, 0.7982906723023958, 0.8054837572219007, 0.7837382799778256, 0.7860457164449547, 0.787305242379972, 0.7999817898509582, 0.803191089623025, 0.40308835248687425, 0.18059205628505193, 0.39355208696195987, 0.14349959739124074, 0.1551939258365066, 0.15915115924883505, 0.29151809385219507, 0.09875529579130293, 0.16369800641184007, 0.127370774049694, 0.1070520818328381, 0.15075705207902934, 0.24578533787100887, 0.15057193678337621, 0.13986901926623418, 0.14044479253800546, 0.12855955639310146, 0.1541107489372745, 0.9578338379984337, 0.9751344270653708, 0.9622005086160434, 0.9681943316830341, 0.9685202011588736, 0.9796716390707392, 0.976624011499477, 0.9633664697459942, 0.9593317392934553, 0.73411023804938, 0.749241259261259, 0.7513521745599933, 0.7391913320896899, 0.7301999442554483, 0.7212457302792004, 0.6773374645478517, 0.6870335950747588, 0.7285814987279176, 0.22520934447264684, 0.22612761183855434, 0.8955704115956297, 0.2138197179755874, 0.2786873722008141, 0.2799749807694848, 0.23647768233819466, 0.23794326502051888, 0.22863685765202257, 0.2788418973577811, 0.26437993394819337, 0.2590104287045437, 0.21620718459098864, 0.23580640108255735, 0.2269212741735932, 0.21464753514049528, 0.29964296387999967, 0.30581225788602995, 0.2266800983866103, 0.24922944018254733, 0.23927533156629066, 0.1346898574883818, 0.26157140591236183, 0.24046644565456476, 0.27210257859574305, 0.2434783627808088, 0.24979673730945984, 0.022202470050129652, 9.999999999998899e-05, 9.999999999998899e-05, 0.12181058286283186, 0.03781343932102521, 0.05221371841113376, 0.010001362904069389, 9.999999999998899e-05, 0.010416146336569176, 0.12432945590742528, 0.1627326250488098, 0.1058658356132286, 0.03584159217172178, 0.11536966686396499, 0.0898391752190042, 0.060589826543615, 0.10138079742165718, 0.072602724173229, 0.13388296861176974, 0.09638068842039016, 0.10706676646192137, 0.12472441561237979, 0.09757821462513927, 0.2509451410632533, 0.0748070982558271, 0.1455850779525516, 0.29394945244329707, 0.23767598882359076, 0.1292508652293216, 0.11548432635293704, 0.1654100539022516, 0.08944513321378122, 0.33192690752806087, 0.08401682437433722, 0.11812820530258017, 0.22377496057649937, 0.5865872358812372, 0.5378080220856207, 0.5950194168941133, 0.5364716584914342, 0.6391033040056806, 0.5737840176770066, 0.6021417176500967, 0.5717128476908104, 0.5704788681664346, 0.6231751830992978, 0.13908515075328232, 0.09275255195877585, 0.0989007018048822, 0.13780283593881393, 0.08575370954459993, 0.12829775707247681, 0.14502897009595273, 0.1085038842296222, 0.5837516776869072, 0.26627911817455074, 0.4350602061720208, 0.22206846861384588, 0.2047192893627946, 0.49074182530598565, 0.2859546292143951, 0.29604931966196035, 0.5184420095077666, 0.5319513250857413, 0.5810711289967718, 0.3008380424955447, 0.6667532277088002, 0.4942058509138435, 0.5313048813516127, 0.7119179890624764, 0.7254748299407359, 0.2535946621587315, 0.33312496350611676, 0.29226586826046064, 0.29064454779284077, 0.20452577550827522, 0.36219885547445885, 0.2636029019162939, 0.24293035933968132, 0.2735867227607617, 0.22987226763716528, 0.23065648017805618, 0.21973672130899247, 0.2270352527858508, 0.2044146667975063, 0.2733730724885153, 0.21107103429034813, 0.22450409822742323, 0.21332937781349448, 0.22380337562578223, 0.7601207381294448, 0.2084203186652751, 0.20692451337065, 0.2141097679344297, 0.20454068582905094, 0.1887774096312459, 0.24535889476955508, 0.1885346805732655, 0.20817483923374558, 0.18806631289619102, 0.21104297483695922, 0.18709263479009974, 0.1693105773934278, 0.1782838104253709, 0.9271534407359256, 0.17191773163141932, 0.13606297581251214, 0.15294460987173775, 0.8674508769663909, 0.1698801779375575, 0.21151911045311356, 0.16791773585072334, 0.2124928673383113, 0.21037782010704953, 0.8555897116142962, 0.21258497107286456, 0.21108356904450865, 0.1931934125482918, 0.1809601284996969, 0.1939860005232048, 0.19052242844269962, 0.17722597038865728, 0.1729132419161189, 0.18923865422055342, 0.19790103775797796, 0.1868545662464256, 0.09188568900433425, 0.08863469230907595, 0.08221848252950026, 0.08711542496850111, 0.08407597864451688, 0.10224266356945866, 0.08618075590635421, 0.09280615465875475, 0.10503422860400058]}, "mutation_prompt": null}
{"id": "1888443b-2c3b-4497-a196-2ea0fafa68ca", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population size for better diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Expanded range for differential weight\n        self.CR = np.random.uniform(0.5, 0.9)  # Broadened crossover probability range\n        self.w = 0.5  # Adjusted inertia weight for improved convergence\n        self.c1 = 1.5  # Balanced cognitive learning factor\n        self.c2 = 1.7  # Increased social learning factor for better global influence\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)  # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = np.random.rand() < 0.3  # Probabilistic dynamic strategy\n        self.reinit_threshold = 0.2 * self.population_size  # Higher threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Wider randomization range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Wider randomization range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridDEPSO", "description": "A multi-strategy optimization algorithm combining Differential Evolution and Particle Swarm dynamics with adaptive parameters and periodic population rejuvenation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 86, "fitness": 0.3261578609556897, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8094251108407443, 0.8322875994678666, 0.8290843649891488, 0.8281848968213579, 0.8358582027460115, 0.8344544867553915, 0.8024485036291659, 0.8501057903871815, 0.8406682100031682, 0.6847544106129868, 0.7036732093415783, 0.6632654932357924, 0.6766001051629043, 0.682002384347283, 0.6859542424159477, 0.6460548611622927, 0.6860793282676549, 0.6881867295647828, 0.3128729101845049, 0.4545506874418308, 0.3534013004800992, 0.21168698642666928, 0.14330738195941106, 0.5397690149323944, 0.5089383403706529, 0.14792890938270498, 0.49428733433983985, 0.12282264353958194, 0.12403072214862298, 0.14839108497862186, 0.12889476338944839, 0.14044969822977582, 0.15361617774019432, 0.15823515161149948, 0.13022947324656942, 0.12803994197305835, 0.9777300141330763, 0.9772503070347258, 0.9729645249699734, 0.9710620252810807, 0.9688703382993157, 0.9766988828954498, 0.9667478719260023, 0.9726533541121818, 0.972603517000233, 0.5185890812695668, 0.5834282021374493, 0.5427797464383878, 0.5429415759684248, 0.5549843439034643, 0.5723093029528862, 0.5345806258953825, 0.5111986993978825, 0.5310552333126897, 0.2228945543462847, 0.2254315267196646, 0.2253683606289093, 0.21854344563584904, 0.37072398863771405, 0.27032676556580837, 0.8074166377870905, 0.8006119200422792, 0.24211902089843074, 0.20137555950751762, 0.23779307936943528, 0.2553202753492465, 0.19390193242737863, 0.21833981584494422, 0.19061367373989546, 0.20285906394819875, 0.2212332488358637, 0.23490140392766823, 0.20356573933508593, 0.11532878305792871, 0.1635131347895965, 0.1286307279959612, 0.23314494622188697, 0.22204528891299746, 0.2404584650693684, 0.2195602423226689, 0.16737788399396136, 0.022587729986639382, 0.0051823357211278065, 0.004468994399181581, 9.999999999998899e-05, 0.0024820363806901113, 9.999999999998899e-05, 0.034641515424608915, 9.999999999998899e-05, 0.08642630524920936, 0.10474042612719792, 0.06764785839083831, 0.09656380110774265, 0.03605737255995756, 0.09496495345551648, 0.045403654411370176, 0.040550996930534544, 0.07038743223949806, 0.09556339924788737, 0.19317763949492162, 0.22216470483225226, 0.14201757712879293, 0.09552539635337676, 0.11262711613232546, 0.08235185780478405, 0.09519832522304528, 0.1605695292859547, 0.13053724811362877, 0.20717448682272932, 0.08229765975683534, 0.115629910538667, 0.20748897199697436, 0.10830621111948147, 0.16543879100113623, 0.08076129860372272, 0.20514846943103093, 0.08058036103576671, 0.5439306786552767, 0.5610443786772794, 0.5516559826796339, 0.5507631293637216, 0.5808905424036058, 0.5590873268645375, 0.5235946013500026, 0.5540552300270539, 0.5665532373077705, 0.12926452143339506, 0.1128042040912216, 0.1410739648455277, 0.14533661723569802, 0.11170855194153284, 0.11093483022589024, 0.11242207698107942, 0.13628855287844432, 0.12486095409325881, 0.13642982115987434, 0.33081784093891864, 0.22706242952345124, 0.18818033631288844, 0.24599508246213464, 0.2791719273070441, 0.12258370448899314, 0.25070993700761257, 0.19817543308612562, 0.2969001525145003, 0.287715498795337, 0.40500737219718586, 0.3113917114930501, 0.46667729673193625, 0.49135287786545445, 0.4640269724199898, 0.5540875458009822, 0.4995386775168964, 0.2858626594103524, 0.3668384998545594, 0.34349641962480504, 0.1828990273978729, 0.21338066219560015, 0.25843334324199685, 0.3173616480076036, 0.21363330713761874, 0.30481853821458527, 0.191760267771381, 0.21024139551277787, 0.2076376940578446, 0.19884543329039606, 0.21856312955336699, 0.21970989294652943, 0.23171001007476166, 0.20214891107011157, 0.20416991769112747, 0.20941657819925086, 0.1970414245393738, 0.18605227107246347, 0.48392051033305705, 0.21430855266091908, 0.23011224627883686, 0.5921509787268096, 0.20866315090486065, 0.1927158319696325, 0.14641140162510913, 0.18668743958303502, 0.17197018049508983, 0.8656997272265217, 0.16519189160570713, 0.1698044564303255, 0.13100691634601846, 0.818232839758913, 0.177423737045997, 0.75763222322928, 0.6827463844435606, 0.6510183958335283, 0.5905293330609273, 0.5983867205495228, 0.20584400659103508, 0.11289323195125411, 0.1265608417731957, 0.710858339235698, 0.18421197698643177, 0.1957039544422332, 0.1766265743364449, 0.18900457354400935, 0.18220708475479575, 0.18295403242503205, 0.18233952770819428, 0.1873567939381946, 0.17484581180112269, 0.08779817033823778, 0.08945674800659564, 0.08642713467730367, 0.08240317857753432, 0.07664271323858796, 0.09241913885907904, 0.08594835103425735, 0.1279629429379533, 0.08155294134849067]}, "mutation_prompt": null}
{"id": "050ceabe-fa5a-47d7-a737-d28fba86c174", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Population size carefully chosen for balance\n        self.F = np.random.uniform(0.4, 0.9)  # Wider range for Differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # Wider range for crossover probability\n        self.w = 0.5  # Moderate inertia weight for balanced exploration and exploitation\n        self.c1 = 1.7 # Enhanced cognitive component for personal exploration\n        self.c2 = 1.3 # Reduced social learning for diversity\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Maintain dynamic strategy adaptation\n        self.reinit_threshold = 0.15 * self.population_size  # Increased threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Enhanced dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Wider randomization range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Wider randomization range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Neighborhood-based Reinitialization\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                for idx in reinit_indices:\n                    neighbors = np.random.choice(self.population_size, 3, replace=False)\n                    self.population[idx] = np.mean(self.population[neighbors], axis=0) + np.random.normal(0, 0.1, self.dim)\n                    self.population[idx] = np.clip(self.population[idx], self.lower_bound, self.upper_bound)\n                    fitness[idx] = func(self.population[idx])\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Hybrid Metaheuristic Algorithm combining Differential Evolution and Particle Swarm with enhanced adaptive parameters and innovative neighborhood-based reinitialization strategy to improve exploration and convergence.", "configspace": "", "generation": 87, "fitness": 0.3474999462297589, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.890639609535133, 0.8901703606381159, 0.8794150433507801, 0.8858034320043517, 0.8938643157303129, 0.8939921574709189, 0.8789782402262807, 0.8998874518012531, 0.8941859913860265, 0.7681705264799028, 0.7989561658045161, 0.7813538472103635, 0.7910050565572817, 0.7761489829611387, 0.7901959695341011, 0.7881732680141598, 0.7827388943529886, 0.7733597481770209, 0.6499644223156495, 0.13993547519475724, 0.6883486692786689, 0.4915447312052723, 0.16212943385050071, 0.13634225595746707, 0.17899373001341046, 0.16163188293830877, 0.18594286800982618, 0.11468614414189382, 0.15274522058342777, 0.11946943465460624, 0.14295259515203274, 0.14201167712629836, 0.12206654199285272, 0.1515732143544425, 0.11390581983565973, 0.11529510887337968, 0.9702549171075534, 0.977504618061375, 0.9738618207580076, 0.9731823815125743, 0.9790667498285236, 0.9771969267617145, 0.9784856149148755, 0.9813697226866361, 0.977962763597348, 0.6980259581569364, 0.693129260937708, 0.7251646681707071, 0.6908013379369791, 0.7313191271677966, 0.7219565853321063, 0.6442506559116754, 0.6782595538110316, 0.6756040472244309, 0.38825363333702567, 0.22704497773084575, 0.2264535551339384, 0.36160656642867106, 0.8530358230656503, 0.27854005000332294, 0.3889874705785915, 0.8806753964729283, 0.8878875312719682, 0.2240546801941281, 0.2344573524030481, 0.24491923887872014, 0.24733386729616924, 0.2088515140217081, 0.23161880050838102, 0.37814597915373305, 0.2476684263573824, 0.13058467313080746, 0.1344889714641908, 0.22195814744204923, 0.1240762635489524, 0.2623780680077016, 0.23188149648859413, 0.3308509178049035, 0.24409893922870485, 0.23040761104898433, 0.259145254861072, 0.010809057885083906, 9.999999999998899e-05, 9.999999999998899e-05, 0.06640556020746202, 0.09655624417724307, 0.05589848462494196, 0.0026398575451556106, 0.049405960934292725, 9.999999999998899e-05, 0.17218084236312337, 0.09642685169516862, 0.11810469814669045, 0.0520009978661059, 0.04376650462784437, 0.07253125552195527, 0.09413608685601105, 0.07615464444018893, 0.03873818212496205, 0.1536499097272256, 0.043162555075642706, 0.2076981219350711, 0.0799422307926223, 0.11472713539846113, 0.16459425390222127, 0.35995125191181476, 0.19990059508183444, 0.12187888351135168, 0.28680486958033835, 0.11009102947454319, 0.17476764033155856, 0.1752856435022312, 0.02682456110696474, 0.2776238245401208, 0.1558740425330576, 0.18290591409145918, 0.1300487000660736, 0.5533187377883644, 0.5380657194692262, 0.5219485760406125, 0.5617265091069013, 0.5665322412147222, 0.5544467238493218, 0.5828790572146219, 0.6236008402198462, 0.566593893733953, 0.11624484769069843, 0.1388380619899553, 0.1185761328872681, 0.14794665787807904, 0.12273436113392067, 0.10504440170334017, 0.10974498535431976, 0.128436537239507, 0.11467676839570995, 0.19390750367691367, 0.3180900954931508, 0.3010994227657082, 0.2937131718392796, 0.18784234954183865, 0.33806315288458966, 0.19307013043721433, 0.16477398240769692, 0.25127466971854207, 0.3265445242381809, 0.2638993675187977, 0.39966652992968676, 0.6542527565874643, 0.6232135286570464, 0.6078107158805166, 0.22749473266796183, 0.4787309257600567, 0.5549838380666938, 0.3169131818620188, 0.32114103184199116, 0.37146290840662133, 0.26367963078994394, 0.24760924714486687, 0.3653636702984583, 0.23187834326601842, 0.4842561894610383, 0.21491664324136572, 0.22798564861252713, 0.21123522546061613, 0.22928896328743553, 0.246284445002234, 0.1910307474750801, 0.21074287823200943, 0.24145849465577562, 0.2133664793505573, 0.25245145107460243, 0.24122538245991387, 0.2082166523183634, 0.2174592272807564, 0.24501076430579838, 0.24012753975092427, 0.20520794999035286, 0.19176139135250403, 0.20821264432973308, 0.7169943274963333, 0.16837900176120169, 0.21183711463173915, 0.18614396544807166, 0.1473544272557218, 0.1780029472979573, 0.17040558602806033, 0.17708880098869872, 0.19539604961408363, 0.9097516530211294, 0.20930179692190842, 0.21050448022513268, 0.4746898340695803, 0.1544730148353881, 0.2116423066361306, 0.6673779396720562, 0.1559005588412803, 0.7178818883745344, 0.7168924617798416, 0.18031607450243992, 0.18674482653750923, 0.17615501171411507, 0.18996741800965988, 0.20712462569163137, 0.20412660347056255, 0.19768554007709493, 0.20650604507007342, 0.1816167282395733, 0.10610775588797827, 0.08655662087751947, 0.09480473215440366, 0.08979554699987857, 0.08397728535332571, 0.09277639180821406, 0.10695658681961917, 0.08055097829907898, 0.09496168295110619]}, "mutation_prompt": null}
{"id": "9230199a-c082-4e98-a6af-274b929e8081", "solution": "import numpy as np\n\nclass ImprovedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population for better exploration\n        self.F = np.random.uniform(0.4, 0.9)  # Broader variation in Differential weight for diversity\n        self.CR = np.random.uniform(0.5, 0.9) # Expanded crossover probability for exploration-exploitation balance\n        self.w = 0.5  # Slightly increased inertia weight for improved balance between exploration and exploitation\n        self.c1 = 1.8 # Further increased cognitive learning to enhance individual search\n        self.c2 = 1.2 # Further decreased social learning to preserve diversity\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Expanded velocity clamp for enhanced movement\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Dynamic strategy selection\n        self.reinit_threshold = 0.2 * self.population_size  # Increased reinitialization threshold for improved exploration\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Increased range for adaptation\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Increased range for adaptation\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-6:  # Tighter threshold for stagnation\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "ImprovedAdaptiveHyDEPSO", "description": "A refined hybrid algorithm integrating adaptive Differential Evolution and Particle Swarm Optimization with enhanced reinitialization and diversity maintenance for improved exploration and convergence.", "configspace": "", "generation": 88, "fitness": 0.3389283027178665, "feedback": "The algorithm ImprovedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8733640106490297, 0.8738780589173202, 0.8692783484694784, 0.879552712293392, 0.8621532311785858, 0.8723012509750471, 0.8835139552882382, 0.8776173056698858, 0.869642616770583, 0.761080208859257, 0.7463041924821138, 0.7495083674024482, 0.7465347265828388, 0.7359825215895017, 0.7394373268656371, 0.741744025349188, 0.7491197618693086, 0.7404823560219278, 0.16272283541154198, 0.4850466153935896, 0.1527922963428564, 0.14444432369332827, 0.6114366966217707, 0.3167668812840443, 0.15631656541603423, 0.16211041138572724, 0.12851295430672494, 0.16172128551223164, 0.11824167131027519, 0.1374515045679916, 0.15257197341197404, 0.12468648880334077, 0.13643679763174965, 0.14625108794800457, 0.1361403359701333, 0.13674289346534496, 0.9766281563231988, 0.9621247083427374, 0.9690041878869218, 0.966876953600052, 0.9739769267258908, 0.9708058974701274, 0.9633335258335637, 0.9748400262605474, 0.9751994691483407, 0.6868658694589728, 0.6206522871774413, 0.6105813662605486, 0.6653902712448405, 0.6492566691022059, 0.6110894114138942, 0.626562816181543, 0.6595397134165564, 0.6341525241008179, 0.3828735173366634, 0.364869319640417, 0.21996996257782464, 0.1939477325974882, 0.3612029593770667, 0.277604005223403, 0.38430817581133436, 0.85307864409284, 0.23484021582682812, 0.20888310262507814, 0.19903567924401377, 0.2328458527020697, 0.20863705583685388, 0.22297352243214863, 0.2118170305768352, 0.2020759588616221, 0.23384192383923186, 0.21567104299131168, 0.21751848983636868, 0.22090170176047508, 0.22778800751488748, 0.2559217929236388, 0.16589514671026284, 0.1326778391239417, 0.24330187089495925, 0.23165124705314621, 0.2529530064269534, 0.051420159625685136, 9.999999999998899e-05, 0.009322744801521732, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0348662794305612, 0.04196544448894368, 9.999999999998899e-05, 0.13176877182012903, 0.1322981615098161, 0.08409693597431778, 0.1734625929640521, 0.0811371882523958, 0.04184868123258889, 0.13759085496598522, 0.0921806895396523, 0.1337903696085616, 0.06272205942385622, 0.06746880471543537, 0.03329437141976399, 0.29452891178124896, 0.07705887780269949, 0.12107826965565294, 0.21547616906677658, 0.11416025428039989, 0.10234216837953958, 0.10043593447381094, 0.15794290123101473, 0.12135304986876183, 0.12577471264973805, 0.16633807134709555, 0.20756517610692515, 0.13515373483701676, 0.09141280549946773, 0.09484794177384992, 0.5462171033705745, 0.560114659860417, 0.5505171475051374, 0.5918720713066153, 0.5586217586918699, 0.5714076660912322, 0.6159492601573009, 0.5794666612409489, 0.5778958062405337, 0.1253678751638283, 0.11767482628566395, 0.1266906814284765, 0.12729568050969042, 0.12294683942176088, 0.12324732728527032, 0.13656277611547774, 0.10507176896599046, 0.1314785747770395, 0.21757114027154623, 0.4939556905045226, 0.220715888512393, 0.3682906827785959, 0.3676601209285575, 0.13990696057430851, 0.14387400153866514, 0.23169748503745846, 0.15313256700252387, 0.5709457351962302, 0.4808460111594548, 0.5063956445938621, 0.5638628627376034, 0.5692398589836094, 0.3795985696208023, 0.6543922331511509, 0.5402343506194174, 0.4541582252162035, 0.29411277706161354, 0.29040669472470104, 0.2649717949720106, 0.33423474863125646, 0.3729563349677093, 0.23763888328167537, 0.2333573989808334, 0.44233954572114886, 0.3285491583465254, 0.2214622610496374, 0.19795652534761188, 0.2270258745009912, 0.2058148758504562, 0.25107953108971737, 0.19578089456678094, 0.20427773899822843, 0.21986765235714079, 0.22628485820827804, 0.18380956688177508, 0.6378902276306146, 0.5273316633952783, 0.1953295602479257, 0.2397797103035676, 0.20856422842533173, 0.21877980882584736, 0.23472158974160973, 0.2312395120556131, 0.1597561552901432, 0.16474756225661435, 0.19590369687033005, 0.8526342037562104, 0.1969377485221614, 0.17264488986687643, 0.13104344088296838, 0.8735709138676382, 0.16685771236334623, 0.2102398208002847, 0.16858447167538992, 0.16788926647433478, 0.16847840526381774, 0.15529645234838296, 0.6362593204691774, 0.7231120867085911, 0.7959039137122127, 0.7875037068448787, 0.1824542180690899, 0.1790808391755816, 0.1790795754598986, 0.1803963991771954, 0.18138888135159936, 0.19948344431666098, 0.1974936432628075, 0.19109528412790144, 0.17962392726072263, 0.08399033456736127, 0.0926195394818029, 0.09352255954367772, 0.07792422830549384, 0.09163483587629995, 0.08816428189648196, 0.09132838701192103, 0.08725095705859498, 0.12312108611053374]}, "mutation_prompt": null}
{"id": "fc130182-2d25-4d64-adcc-0d0e3bed02e3", "solution": "import numpy as np\n\nclass ImprovedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Adjusted population size for more diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Expanded range for differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # Expanded range for crossover probability\n        self.w = 0.3  # Further reduced inertia weight for quicker convergence\n        self.c1 = 1.8 # Enhanced cognitive learning component for better exploration\n        self.c2 = 1.2 # Reduced social learning component for diversity\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.15 * self.population_size  # Increased threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Randomize within an expanded range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within an expanded range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population to maintain diversity\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "ImprovedAdaptiveHyDEPSO", "description": "An enhanced hybrid optimization algorithm combining Differential Evolution and Particle Swarm with adaptive operators and periodic diversity injection to improve exploration and convergence.", "configspace": "", "generation": 89, "fitness": 0.3505231292623606, "feedback": "The algorithm ImprovedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9206257246184277, 0.9167657973057122, 0.9095209129509704, 0.9173974072145796, 0.9002335592367579, 0.9158383614276204, 0.911352260693423, 0.914561814575867, 0.9095285532698698, 0.8311291538830121, 0.8377426673065654, 0.8380840750077269, 0.8338357066117509, 0.8292733626898046, 0.8185789208688709, 0.8319439153162267, 0.8094976848247578, 0.8378908146108632, 0.17077875923463748, 0.2013418559686384, 0.24530536529618163, 0.232955059266452, 0.43528855856620285, 0.18505833559778906, 0.1587002336828527, 0.18145666003585204, 0.2341722049175352, 0.12958198438100155, 0.16220602082046776, 0.10941769569778204, 0.11396587685010562, 0.13410360646744357, 0.1507891186476742, 0.1411170856187538, 0.1349784799821464, 0.13602223218882192, 0.9675271670697891, 0.9501383669739958, 0.9601768183279209, 0.9594386423533132, 0.9713304551431738, 0.9753337453786922, 0.9681084938545614, 0.9584855602457641, 0.9658609389861699, 0.7620199809880617, 0.7586543971784017, 0.7258853962904264, 0.7638537377816931, 0.7065935939121829, 0.736991718947858, 0.6952679644682485, 0.6910898831573544, 0.7106136281952198, 0.3926766628256424, 0.22586092195524277, 0.3091803973842937, 0.37846142242820446, 0.27426877173937847, 0.8835230058194681, 0.2349927489809588, 0.23711792143320043, 0.8629936858709212, 0.18501867787138193, 0.2036996709839637, 0.19141178225833144, 0.19095607007444648, 0.13433780441619547, 0.16272509978307392, 0.13031624645090123, 0.3655739115232144, 0.19443885355055468, 0.22058979867127415, 0.1296726132932221, 0.1982783387467716, 0.23262498077655003, 0.19895486695401965, 0.20848756329840612, 0.13124582251926165, 0.20632463831591374, 0.24004670441067488, 0.02004973244341457, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04630913450291896, 0.0010427621743079873, 0.16078666072965642, 9.999999999998899e-05, 0.07956895167898115, 0.06208937638719492, 0.08155847113312442, 0.08771053582039112, 0.08016029372389089, 0.08700859503048308, 0.03182809486487004, 0.11833294010725115, 0.15963704761982556, 0.09195621048145475, 0.1313324598175628, 0.32327994789558434, 0.05080434970873904, 0.38002683177377417, 0.08333525434251987, 0.10625348371979892, 0.20230251140730748, 0.29353044712674903, 0.16760214601052814, 0.2538076925024292, 0.2906374330073024, 0.13945881821588413, 0.02228506587731749, 0.2457438665561742, 0.09198234399060179, 0.11410784656807427, 0.2328157880663494, 0.24647927608000142, 0.5934279811444383, 0.5870371430732169, 0.5660013971794849, 0.6284616683445805, 0.5960749668790927, 0.5654413354370165, 0.627827752214388, 0.5687910669390482, 0.5900751447330106, 0.1307390019322271, 0.17630271964480693, 0.13641229353147932, 0.17052208210810582, 0.15672315302280038, 0.092625428810441, 0.13588051841842974, 0.12658289237087628, 0.1055398987904449, 0.2966325874293664, 0.1957870319921695, 0.1897450631058356, 0.25795545071063475, 0.3009954790528474, 0.2258695570426068, 0.42718003663991255, 0.3176843312207178, 0.31880360852892575, 0.5661974706833901, 0.5490949648828761, 0.45169085845830437, 0.5731657963129935, 0.5042633185472828, 0.5737078234068704, 0.7022602915847713, 0.23010623777258976, 0.7085232671968742, 0.2995903155824836, 0.2704423871306507, 0.3048731247974612, 0.32324357963137573, 0.30463415852787534, 0.2199735049649173, 0.24430689252772264, 0.24758285307084815, 0.13921443016416857, 0.22703197274358433, 0.23849919644811812, 0.19072361854886244, 0.19818870761506668, 0.19400852143465763, 0.20501616004181744, 0.2220192857194797, 0.22352387521466177, 0.22256462589921633, 0.16835063195971667, 0.2527874718401848, 0.24534135302504578, 0.23690167731492806, 0.21999888039017013, 0.19867996763184426, 0.19936262377269132, 0.18825755246601272, 0.2251893156855047, 0.16047850537244035, 0.9088708307840208, 0.19394008672365315, 0.1612770565735504, 0.19727988583577705, 0.910436415045731, 0.16621125059609854, 0.8993767317674619, 0.16245437723583311, 0.21016332565762386, 0.1684744652830048, 0.21045075122668144, 0.6636545748630768, 0.1265918158070941, 0.13439849112582236, 0.11496249047612017, 0.8688811371708552, 0.8129134036458445, 0.19044102403142726, 0.1899911427410913, 0.18867618746258885, 0.17934313423527837, 0.17765142629107555, 0.18835056984694498, 0.17800169572283864, 0.17692357533506908, 0.17985215771805885, 0.08832541835455598, 0.0888695831412144, 0.0939747812407783, 0.08760229723552837, 0.09696269208001451, 0.09471672548410426, 0.08739050294330031, 0.10560328278689124, 0.11865415895063147]}, "mutation_prompt": null}
{"id": "2b3509ef-1eae-497d-a936-22330652c261", "solution": "import numpy as np\n\nclass RefinedDynamicHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population for better diversity\n        self.F = np.random.uniform(0.4, 0.8)  # Adjusted differential weight range for flexibility\n        self.CR = np.random.uniform(0.5, 0.9) # Wider crossover range for exploration\n        self.w = 0.5  # Adjusted inertia weight for balance\n        self.c1 = 1.5 # Balanced cognitive parameter\n        self.c2 = 1.5 # Balanced social parameter\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.15 * self.population_size  # Slightly increased reinitialization threshold\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.4 * np.random.rand()  # Randomize within a broader range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "RefinedDynamicHyDEPSO", "description": "A refined hybrid optimization algorithm integrating Dynamic Differential Evolution and Particle Swarm with adaptive strategies and a diversity-preserving mechanism.", "configspace": "", "generation": 90, "fitness": 0.35838855662351926, "feedback": "The algorithm RefinedDynamicHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8670006398583244, 0.8773861565940437, 0.8616572220202038, 0.8676008435929787, 0.8728510539883831, 0.8736647494060064, 0.8672622402469982, 0.8764008816851204, 0.8624454506936159, 0.7188002485985606, 0.7424504790530866, 0.7352465632330936, 0.7568577147189905, 0.7468032449653637, 0.7531038345717721, 0.7606326249520127, 0.7294839016538399, 0.7350239381169508, 0.181967776305214, 0.3399107234783708, 0.15435187768410652, 0.1427991117797699, 0.10499718679358716, 0.5156592924712744, 0.15601973481012155, 0.4078674243708521, 0.15826886780228633, 0.34152836346554716, 0.13560192778554137, 0.14001221523505414, 0.33225941121646596, 0.13754905135444329, 0.1589659870443193, 0.1337328905530749, 0.14160753175608265, 0.13773755840971136, 0.9797688816067174, 0.9682187482528537, 0.9725701610761065, 0.9682825335555313, 0.976353558373316, 0.9816929712604395, 0.9613355808157371, 0.97428374189786, 0.9735152650432177, 0.6782182830131691, 0.6663682559449742, 0.6632000816126721, 0.69246141424793, 0.6482689583358013, 0.6166580736295271, 0.6536035962409447, 0.6508921598545878, 0.6354193734214344, 0.8730470747109955, 0.8145338235236715, 0.2256559864408475, 0.21530925884674212, 0.8663780795886211, 0.21157492344524687, 0.8739099121226211, 0.23072475714362928, 0.3857997401922225, 0.23590670570784655, 0.22115971427330217, 0.2238120516627623, 0.21249308808472855, 0.21527780298871257, 0.21671934288304662, 0.2092038069551374, 0.2318919099510377, 0.21878130907868976, 0.17139339875319148, 0.23247881840429652, 0.19254859810999725, 0.26240653500894107, 0.2243621554587305, 0.2519126077222774, 0.2290443113260051, 0.24293947472691724, 0.2504880432190425, 0.10263784200647585, 0.004362819049122613, 0.04853450561209849, 9.999999999998899e-05, 0.03550680238641957, 0.04153454246146482, 9.999999999998899e-05, 0.007868800011211374, 0.08828345662934167, 0.04891268576096941, 0.16587503560243, 0.06282245124559305, 0.04416909790951962, 0.06965950885671901, 0.13358646941073438, 0.06386054969580035, 0.06865511480383502, 0.03758328607679562, 0.3422485116653716, 0.2675661131920647, 0.1031277174528279, 0.11846767094754196, 0.09281973982001235, 0.08025689346589426, 0.2021066807259797, 0.2605172927098671, 0.11931145978361146, 0.11691612939395057, 0.1317759960033864, 0.24991000545744269, 0.26243521384203106, 0.0781768819851959, 0.07133591778412052, 0.08336129198406239, 0.09332910216179224, 0.10128037198987239, 0.5211924665997355, 0.5674501763415918, 0.5343428878675911, 0.5731703799319176, 0.5632239249154944, 0.5680624621706407, 0.5701483349545233, 0.6013867751492503, 0.6227756962301763, 0.11899527596722781, 0.13201725019507027, 0.1125931437849218, 0.15407954464295903, 0.12726655926472463, 0.18253667621366532, 0.11380025004486327, 0.14889348847127581, 0.37812753203055394, 0.1550062330111991, 0.325593316958273, 0.17475524872731552, 0.6077353450279623, 0.22762497185052266, 0.5127319288112706, 0.1748053609862742, 0.35751596774724426, 0.1636585656889742, 0.40444623849986727, 0.5561373118569387, 0.5805564180340066, 0.4951490901891301, 0.34289314476571786, 0.4691698115377144, 0.552591141297984, 0.5012762183283566, 0.56540807861929, 0.2943305415956198, 0.29048234926775396, 0.42107838243518914, 0.4128171459758818, 0.40193078156970896, 0.17619503986459017, 0.22071031785407969, 0.2557038993258659, 0.22517884122543885, 0.197021813952847, 0.22486771553051188, 0.22059925953800197, 0.24911155304190913, 0.2140527964784903, 0.19777893292508053, 0.21292840349647046, 0.23793904910809616, 0.20607987822339313, 0.22029321199468965, 0.19832598869500684, 0.24841543574449743, 0.6934629501683256, 0.6695509715193134, 0.20661283085848814, 0.20789943782225073, 0.20843628968916905, 0.19671224083394678, 0.1873100671571497, 0.1763900274943353, 0.19857540006910845, 0.904932879148209, 0.8751325540025899, 0.855545265194561, 0.13108709264574026, 0.8967464402580985, 0.14203010442075392, 0.6474996191297907, 0.16879248921396794, 0.1681464213159639, 0.16777051125452358, 0.15422644817935527, 0.13483588817513703, 0.5754598306366827, 0.9014982264465118, 0.8487853579044276, 0.18152422349735875, 0.18160952533830854, 0.2041392392066388, 0.1874254837115914, 0.17956952923247915, 0.18072758202313977, 0.18012352794862763, 0.18589502866439478, 0.18244920329791792, 0.09689134036241198, 0.09070820774152966, 0.08669661588307698, 0.08167107736969426, 0.08706460932833071, 0.08763908891156202, 0.09775246022378947, 0.08287773070672444, 0.11139631247603898]}, "mutation_prompt": null}
{"id": "0739c3f0-4af1-4848-85c7-47a8277e1345", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = int(10 * dim)  # Larger population for increased diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Wider range for Differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # Wider range for crossover probability\n        self.w = 0.5  # Adjusted inertia weight\n        self.c1 = 1.5 # Balanced cognitive component\n        self.c2 = 1.5 # Balanced social component\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        self.reinit_threshold = 0.15 * self.population_size  # Higher reinitialization threshold\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.4 + 0.5 * np.random.rand()\n                self.CR = 0.5 + 0.4 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "An enhanced hybrid optimization algorithm combining Differential Evolution and Particle Swarm Optimization with adaptive strategies and a randomized subpopulation reinitialization for better exploration.", "configspace": "", "generation": 91, "fitness": 0.33810566932695535, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8595592571748197, 0.8689914638611358, 0.8671761583073593, 0.8769195151744893, 0.8617490988050326, 0.8752502611304451, 0.8625463571938442, 0.869442144992528, 0.8617112962057141, 0.7011664991623392, 0.6879561559067302, 0.7334328804634014, 0.7462566629252163, 0.7391821568607952, 0.7033322134268741, 0.7217734117037614, 0.6946141082227189, 0.7188582407269408, 0.190515988037544, 0.5870526489241366, 0.15676889052067322, 0.14026474220778895, 0.22932174653316695, 0.40518112220400804, 0.16065329599730227, 0.1689651175198731, 0.17131637762001006, 0.1409299823833231, 0.13557972457720713, 0.1402510644322159, 0.12575614024591086, 0.11358111625956313, 0.154601108731935, 0.1118278710990579, 0.15325622067782863, 0.14423757423586991, 0.9776752281308823, 0.9677734652245288, 0.9726942979968092, 0.9714446805169499, 0.975296507772834, 0.9816425108771162, 0.9655402409717081, 0.9737411264211109, 0.9728136671609047, 0.6828989585396932, 0.6359952790460528, 0.6495185881461252, 0.6184377829166787, 0.6607986499919805, 0.6118402144440194, 0.6053581759066484, 0.6459122549705194, 0.5852476351439837, 0.5733981008927498, 0.1803931455942407, 0.8286777682002764, 0.2760550030248631, 0.2792837147530405, 0.8406114943268723, 0.2343270997167327, 0.39095318761496123, 0.23163011396191036, 0.12879572492191005, 0.23981821466060504, 0.2070250390701318, 0.13127876838997765, 0.207234288597673, 0.26031989997621896, 0.21035813715093954, 0.2145884793567011, 0.24242728707087036, 0.2232334004597326, 0.13311945999354635, 0.2405072806882662, 0.12526270539935613, 0.13317343417242444, 0.15527826356824304, 0.2519000572468165, 0.2392076790090586, 0.25831377656351984, 0.042360776169106384, 9.999999999998899e-05, 0.03525976367433126, 9.999999999998899e-05, 0.0841704536442548, 0.07205381615577444, 0.07831879460907243, 0.11270934072584282, 0.02248335386871203, 0.05706021498360647, 0.1107773851309376, 0.10781482153238398, 0.10908958542475755, 0.14430848336408109, 0.024146104717847616, 0.07836516794085013, 0.1406516134609166, 0.04669448571797297, 0.2874270402776563, 0.04988059896929409, 0.049326899099230825, 0.15098020470569773, 0.10507371870436732, 0.2792584493087762, 0.21296810178684822, 0.2488957244026092, 0.124974180497745, 0.27161284573484756, 0.0862833304336702, 0.09181531305623503, 0.25096391402544227, 0.13719800179098696, 0.04687732409722434, 0.1618455555312196, 0.22357080216345715, 0.22589185888395769, 0.5711305281186192, 0.6074165774019965, 0.5288963093989143, 0.6644915784581851, 0.574153907515607, 0.5517670111927246, 0.552451658630517, 0.6130111449732609, 0.5889302203544567, 0.10635293892518183, 0.11357605233161794, 0.13122460826291604, 0.14335059336082234, 0.10811001677940035, 0.08698753583206276, 0.10969476245532495, 0.1355212486942784, 0.11004565775067132, 0.182574443255218, 0.24791621512937234, 0.1563430852105181, 0.1787704649713231, 0.2598576178081916, 0.45281076830846956, 0.23281526852709322, 0.21829540396166236, 0.24629807907909507, 0.6058489076721563, 0.4818902570491469, 0.45722073815032827, 0.4872575599650609, 0.48963213907649894, 0.5581467759245909, 0.5938920182952799, 0.5183104090686051, 0.5137314913446753, 0.33935993114223184, 0.324811366687072, 0.3593178971465838, 0.20543969095263215, 0.19848022523884745, 0.1837258011595322, 0.2908864517697386, 0.2252900260472832, 0.3266472223539988, 0.23011717878814364, 0.19827432602621653, 0.2336718216415602, 0.21337574938429948, 0.22418282872733586, 0.20960100454718922, 0.19914555378852594, 0.22941633438189124, 0.2653175649855657, 0.20284169726762868, 0.24326902832688446, 0.1987341574927487, 0.21465299742764554, 0.21621951133004402, 0.36427152262940266, 0.22161131472102902, 0.7503196258375958, 0.20543102986647144, 0.16197438987522272, 0.16474803709437114, 0.19869994530513357, 0.16113559626617713, 0.1476267993998137, 0.8757469314512746, 0.13120701821116276, 0.903333132350787, 0.23812525253582417, 0.21043659036954476, 0.16813402902347918, 0.21121884223992504, 0.16867276226635186, 0.15390183893442133, 0.12749322987440426, 0.643126453658794, 0.8456539269518717, 0.8512734325784582, 0.1798236778277985, 0.19022964456436187, 0.18041227507238167, 0.1911519013091747, 0.17818155332160857, 0.21660327951269753, 0.1798850312634117, 0.20087919402474652, 0.1856408663700646, 0.09041342860804757, 0.09430728505394637, 0.0864530909504565, 0.08827958407741787, 0.09271348092460119, 0.10840823195292648, 0.10799685219571142, 0.08541221522514353, 0.11530149347744212]}, "mutation_prompt": null}
{"id": "c6e4a7ca-6ce6-4b1d-ac76-7f6f8a4009f8", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increase population to enhance diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Broadened variation range for more flexibility\n        self.CR = np.random.uniform(0.5, 0.8) # Broadened crossover probability\n        self.w = 0.5  # Slightly increased inertia weight for balance\n        self.c1 = 1.5 # Slightly more balanced cognitive learning factor\n        self.c2 = 1.5 # Balanced social learning factor\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Adjusted velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.2 * self.population_size  # Increased threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Randomize within a broader range\n                self.CR = 0.5 + 0.3 * np.random.rand()  # Randomize within a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridPSO_DE", "description": "EnhancedHybridPSO-DE: An enhanced hybrid algorithm combining Particle Swarm Optimization with Differential Evolution and adaptive tuning for improved exploration and exploitation.", "configspace": "", "generation": 92, "fitness": 0.33656176399769916, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8733036785394267, 0.8687519949624105, 0.8731988636480251, 0.8724416468621947, 0.8610954060070177, 0.8760396509373107, 0.8856843000310888, 0.8584833680109814, 0.8469473989877496, 0.738110864370203, 0.7219334369674932, 0.748548715020492, 0.7379024340927203, 0.7417451490598074, 0.7435603641923292, 0.7425477622057766, 0.7524141778285376, 0.7455361374851088, 0.161603639896871, 0.16411523564682917, 0.1198312950817193, 0.35779945362519194, 0.5923130203489979, 0.19044485714535764, 0.1373319187330837, 0.12144862868394668, 0.1368638686824435, 0.14837159195141392, 0.12062944152514432, 0.13637484450622106, 0.13168703437624552, 0.1737179227353468, 0.15356557423250228, 0.11704149957260579, 0.14128662893836086, 0.13445113464639802, 0.9721810695859677, 0.9674491264136772, 0.9727328146121221, 0.9715534426123008, 0.9722926966200164, 0.9767640167177553, 0.9631264825283172, 0.9687853587836461, 0.9751051990265901, 0.615590766339249, 0.673765867068293, 0.61551581005743, 0.6807350345934682, 0.6484278317156669, 0.6135049444780643, 0.6713553694325203, 0.6643030103582536, 0.638531132479448, 0.22383765052314997, 0.22655843547728705, 0.22589382342937137, 0.8957604178667543, 0.3801038902220949, 0.2118256029463781, 0.734511336230345, 0.232925936510754, 0.8423598997539754, 0.2415930150505894, 0.21974046947531656, 0.20981763653075658, 0.13040019033293848, 0.2134265964710933, 0.11924081732014746, 0.22933334320138388, 0.21299685785742217, 0.46827092323395036, 0.21883386627982016, 0.22961292616909335, 0.12974689863834843, 0.1275730529172352, 0.11536508067719642, 0.19542787560513675, 0.22188736829208677, 0.2396049802806235, 0.24405724056488876, 9.999999999998899e-05, 0.052475175094930826, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014987690931429487, 9.999999999998899e-05, 0.11773313815758846, 9.999999999998899e-05, 0.07451521101133662, 0.09000619115990449, 0.11687682088222517, 0.08161775554725192, 0.07310104328958555, 0.10738164030428121, 0.03008023660727377, 0.05579159156512303, 0.06547610039098017, 0.050353555284342155, 0.10715731721227018, 0.15154660225685657, 0.04760946998697402, 0.1613415343886362, 0.15360576510984736, 0.09149596779239821, 0.09316449223600576, 0.12058494533478292, 0.09335708466990489, 0.11204506787346469, 0.21335467604818925, 0.08956532215925561, 0.06306461619915282, 0.10854643599305891, 0.11299651909611552, 0.4106554284168187, 0.10719562994277898, 0.1672045068676824, 0.5573435933967263, 0.5535740399554496, 0.6111977179898509, 0.6115036778250806, 0.6188638290017963, 0.6054507581904421, 0.577124032334625, 0.5630644775495346, 0.585993613245986, 0.11569595360655038, 0.17613605022981615, 0.1558221778040133, 0.1252810089637687, 0.11807593999192978, 0.11823319462104331, 0.12136628029466523, 0.12458993187745349, 0.14537132490190086, 0.28017959130728287, 0.26047976861661504, 0.3314133070751413, 0.19198659257101958, 0.2735769877509798, 0.18119151553002566, 0.13759819403543994, 0.2823029784122536, 0.17335401865783862, 0.515973117590498, 0.6168490973007421, 0.30812551732663973, 0.2642104500328406, 0.4869911847015417, 0.44405093864242084, 0.5700727794851757, 0.3016661879783278, 0.5598193150562085, 0.2618217012592784, 0.45229343951471523, 0.2882346868911241, 0.3720631155246983, 0.21748566850321083, 0.23974357882117625, 0.2407872135445841, 0.3049330860999244, 0.3989547017124626, 0.21677960452421496, 0.20816593526336624, 0.20664618594186157, 0.21998481525669766, 0.2074157962266232, 0.2085211384900434, 0.23130778208623715, 0.25848958630056396, 0.21350519148788494, 0.2133184670902296, 0.24999803109297725, 0.24345822892763413, 0.21560411306431138, 0.1994069466655125, 0.6583487291575116, 0.20722327656934603, 0.2069407446275653, 0.2134467511202588, 0.18524410733515873, 0.1871590755430984, 0.17627417095862508, 0.9031104140599725, 0.13525794920988288, 0.9139654557715707, 0.13123891464555548, 0.859450716589637, 0.14231854503713437, 0.6516462249081736, 0.2097631133500042, 0.21060739982065357, 0.1681964988699921, 0.15511183079763546, 0.21030077242213618, 0.11297673578424838, 0.8031448158916441, 0.8006550252149413, 0.1819504090643067, 0.18761945342756337, 0.20947345522611216, 0.19196705536865843, 0.19342307911445678, 0.189593124121183, 0.17958087544302603, 0.18325727180561624, 0.20805795614916345, 0.0877294704375774, 0.08955822153310966, 0.08255143638358609, 0.09131513189277052, 0.09259226284978717, 0.11599542180226075, 0.09605623458685786, 0.08737652165159471, 0.10196656202924625]}, "mutation_prompt": null}
{"id": "f390cd4b-abb9-4d8b-9270-5f87855fb625", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population for more diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Increased range for Differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # Broadened crossover probability for exploration\n        self.w = 0.3  # Lower inertia weight for rapid convergence\n        self.c1 = 1.7 # Increased cognitive learning for better exploration\n        self.c2 = 1.3 # Further decreased social learning for diversity\n        self.velocity_clamp = 0.15 * (self.upper_bound - self.lower_bound) # Tighter velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.2 * self.population_size  # Higher threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Randomize within a broader range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a broader range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "An enhanced adaptive hybrid algorithm combining Differential Evolution and Particle Swarm Optimization with adaptive strategies and a dynamic reinitialization mechanism for improved convergence and diversity management.", "configspace": "", "generation": 93, "fitness": 0.3514949442581124, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9161384102943402, 0.9128311704862481, 0.9133933942250467, 0.9095460130434248, 0.9010044893055843, 0.9127112152586832, 0.901964243882685, 0.9214047453442167, 0.9158568479877833, 0.8268051662460004, 0.8346081115115016, 0.8329737505169018, 0.83103514896488, 0.829259869660101, 0.8271185017334329, 0.8175687328132972, 0.8032622715242135, 0.8211757341301451, 0.18487037596718325, 0.18611946620979358, 0.13818191465575258, 0.2812292636854099, 0.16900273855975978, 0.1549046206093051, 0.30785231644194977, 0.15167998122022985, 0.1908664491127643, 0.1420993064326671, 0.16388028752773642, 0.16657898177553343, 0.14027917779636268, 0.11595560506222413, 0.13720764683221387, 0.16036935451265721, 0.11945042170773645, 0.13830097703353716, 0.9645502459463351, 0.9535428768925188, 0.9379878998454034, 0.956905141024558, 0.9759982816047121, 0.9695983893934422, 0.9628191178525118, 0.9629985327194301, 0.9693805212132911, 0.7484915214586872, 0.7259114775473731, 0.7378515554735914, 0.6984768953054656, 0.7323976920442372, 0.7371817385185868, 0.7391385698821267, 0.7000785916516002, 0.7366942768221371, 0.8941070204093012, 0.22504676206817353, 0.3805933889374453, 0.38153763741138247, 0.27937363442322494, 0.16074840019579062, 0.2073448238061142, 0.23809847429258457, 0.19715402922343073, 0.25178903199245783, 0.17647463861207002, 0.12254511187050554, 0.011128868315880891, 0.18523600938166107, 0.18718769857962236, 0.18596878015725504, 0.1820734681991114, 0.19094117788799048, 0.16924400425037, 0.22642639677487975, 0.21873992887142846, 0.207636545289536, 0.12115863201809718, 0.17955972926696284, 0.1824313268994442, 0.12967332300839607, 0.24989950633536762, 0.022667069680617935, 0.07058478834477522, 0.021888282722758556, 0.06198467821977249, 0.020631227395562002, 0.02415406091360206, 0.07629695064916009, 0.0031298069002763107, 0.14332587704722954, 0.10385463761598146, 0.10839683001734379, 0.1472561072689741, 0.09531354748465115, 0.061594561403069736, 0.031802780948081644, 0.12088319214301968, 0.11617648585432128, 0.05388695201213578, 0.13852189471397136, 0.16215352807325412, 0.062148869819130814, 0.0997540419580275, 0.12025013649185057, 0.1918964563035609, 0.2298557173731608, 0.10436221219808561, 0.1315548073783246, 0.08578127693718784, 0.22947159472453238, 0.13397252115644864, 0.3191091040045543, 0.29766030990915415, 0.31260919454472236, 0.11768001497652092, 0.12027165381285099, 0.08597110393252494, 0.53680762693492, 0.5614441484415007, 0.593079923295404, 0.6012355489784145, 0.6137871430831063, 0.5866552140485073, 0.5700150511990738, 0.5971980948617248, 0.574759269231313, 0.13421377471121232, 0.1417147249094871, 0.14612381022379872, 0.11451486392089372, 0.11363766915279017, 0.17329284012334323, 0.1292295125472841, 0.12967071198459124, 0.12209397490054141, 0.43901981992720407, 0.3509203212822867, 0.40092808217183284, 0.3097568584303352, 0.25552713637396796, 0.18825485488236837, 0.4676882738500997, 0.33669418824951003, 0.33236895974181735, 0.32513271751581885, 0.4072535611016812, 0.6049116554099274, 0.618092014655448, 0.6171963865651678, 0.35322086976319655, 0.453976595184996, 0.23974589721999573, 0.7016866145864868, 0.2651678339189678, 0.3821240487395404, 0.4009683696388844, 0.3012260369923623, 0.34769075976961117, 0.35210451761828376, 0.2599122287140193, 0.2255722863254166, 0.28360740373513305, 0.21459975462303593, 0.22012380199210702, 0.24882574716801042, 0.21274454392140119, 0.21007270899430563, 0.2023185439754428, 0.2149803514867552, 0.24071855504713413, 0.20685064453570512, 0.2218379209356628, 0.1960467374944973, 0.21523465664099373, 0.20069300098482024, 0.22193538472750796, 0.20698952481865895, 0.17603225346938034, 0.2497266268989793, 0.19856923092307122, 0.17744592727271757, 0.1648594624604942, 0.19906060501659117, 0.9164412380152236, 0.19920908730137654, 0.9341454228494748, 0.15416159243496208, 0.8725187440069553, 0.8975941234902994, 0.2107379265561231, 0.1687472225527359, 0.21008650989926314, 0.36236794578403875, 0.1679071379719579, 0.7973088011520464, 0.6716312503519299, 0.737675715224686, 0.7613090235979645, 0.17886675278748387, 0.18259058350384183, 0.18977398163213965, 0.18499481453452782, 0.18002720608016698, 0.194829441712564, 0.18445315002914398, 0.18916824772416962, 0.18382053052386205, 0.09194880095294888, 0.09114362282797828, 0.08244738173135191, 0.09340163588002437, 0.10172737460844761, 0.089463116737865, 0.08615076245425535, 0.1214437672987142, 0.11846621856924178]}, "mutation_prompt": null}
{"id": "220e2092-ab5d-4fc6-b413-d43fab9abc14", "solution": "import numpy as np\n\nclass RefinedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Smaller population for increased pressure\n        self.F = np.random.uniform(0.4, 0.9)  # Broaden range for more diversity\n        self.CR = np.random.uniform(0.5, 0.9)  # Increase range for crossover probability\n        self.w = 0.4  # Inertia weight for convergence\n        self.c1 = 1.6  # Cognitive component\n        self.c2 = 1.4  # Social component\n        self.velocity_clamp = 0.2 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        self.reinit_threshold = 0.15 * self.population_size  # Increased threshold for more reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.4 + 0.5 * np.random.rand()  # Broadened range for F\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Broadened range for CR\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "RefinedAdaptiveHyDEPSO", "description": "A refined hybrid optimization combining Differential Evolution and Particle Swarm with dynamic strategy adjustment and diversity enhancement to better escape local optima.", "configspace": "", "generation": 94, "fitness": 0.3424669073309004, "feedback": "The algorithm RefinedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9125647147720934, 0.9114958512056578, 0.9096412192931063, 0.9156345013695174, 0.8970472668084766, 0.916812606476479, 0.908233688919412, 0.9134994797140715, 0.9043166555917637, 0.8452701580726751, 0.8347780841574268, 0.8213891374184418, 0.8222203796741123, 0.8343502353800564, 0.8249484203743429, 0.8296445981974999, 0.8411990338625994, 0.8362517659001228, 0.14648215677743626, 0.19881777141426293, 0.46929680647977134, 0.1601672663686663, 0.15757402901853113, 0.1650311499912206, 0.41810739162803434, 0.207678392244248, 0.2587768920157617, 0.16586203109986764, 0.11946707820816149, 0.13554803734563303, 0.12531958778587227, 0.1413463385404582, 0.15050220614899024, 0.10641151932252702, 0.15268920687757914, 0.14689309781803417, 0.9698559544087514, 0.9714218639204912, 0.967099347094013, 0.9728156301707356, 0.9780092873642332, 0.9749073485356716, 0.97202578194339, 0.9647357592657524, 0.9682579075135296, 0.7716799991605315, 0.767782917953302, 0.7720467462761508, 0.735842271511245, 0.7601439183934078, 0.7929260240912657, 0.7297614891572325, 0.7256016828134748, 0.7471161277795615, 0.39392981940650584, 0.22763005804032732, 0.2296302645034224, 0.38407664571808253, 0.36589175334214763, 0.2820734104943893, 0.2207255434409442, 0.23498819732969123, 0.2369153954523352, 0.3354735040611869, 0.22976765710214453, 0.2216416861742012, 0.22654557283286136, 0.23077833029160133, 0.21804270927859937, 0.12483213068815491, 0.13067572086592405, 0.20565121325669866, 0.13060655213437256, 0.1780148245582781, 0.1345820099496401, 0.24047219973306355, 0.2243917950052886, 0.22920549354836905, 0.2707961068024374, 0.2714221394832915, 0.2142581317169836, 0.044178748217717057, 9.999999999998899e-05, 0.045071162177309665, 0.04604026528037797, 0.03596422588995951, 9.999999999998899e-05, 0.01553072639861608, 0.06783488560487949, 0.004708157820512704, 0.15872754649614995, 0.1338995473060811, 0.17555252135118005, 0.07852770527431363, 0.04911779908274272, 0.073376084263293, 0.13485138612299885, 0.1352453465320579, 0.05312917333327116, 0.067232302280405, 0.26619913450591226, 0.0983865021988426, 0.08170513132800039, 0.11258251391938756, 0.08049034912273934, 0.1047826737048907, 0.0837046431247429, 0.1414869075650531, 0.23114974954638656, 0.1783231520810057, 0.24896174576739782, 0.2177306266224569, 0.037346685805707436, 0.19993992022613993, 0.09131972562626434, 0.15560805933142252, 0.1868987814763008, 0.6626804165017289, 0.6193648987757825, 0.7067328056538246, 0.6011137907052941, 0.623235621760663, 0.5926134479741122, 0.5853301985569439, 0.595614036041187, 0.5779417242120064, 0.11615813484226278, 0.10234853606331107, 0.1438437979142142, 0.14232993253543447, 0.1256052736237605, 0.14792038020812037, 0.12556402984946258, 0.1446121618229811, 0.1300326458709682, 0.7851317479350377, 0.2367772224822653, 0.2530844724073973, 0.380872700778659, 0.18032717981958102, 0.45988642082722775, 0.1831879002164506, 0.17513262877615088, 0.3012028498144881, 0.2916202307476976, 0.6487309729118893, 0.32969903463992234, 0.43304809182112347, 0.3274713747446013, 0.41483211305437606, 0.25542771798872055, 0.5672186017032159, 0.5765420219553592, 0.28610734855008135, 0.28076539061982353, 0.2968763255017418, 0.3932878367369417, 0.39758801564524304, 0.32827875523547256, 0.21039007819940025, 0.376358178637215, 0.27945992161731503, 0.2136346215181968, 0.22433643709401108, 0.23864796982421443, 0.203740911045039, 0.22513912836749383, 0.2282097506649312, 0.24738197541295692, 0.22956650182881144, 0.22372783808784313, 0.20674622639745133, 0.19649747769570824, 0.20908722690119608, 0.2063837702210909, 0.20829495594089165, 0.8025683117251676, 0.20843270825359916, 0.21823814068739278, 0.21038677586375776, 0.15763843329601546, 0.18766749662616666, 0.19680472605706678, 0.1485790584412946, 0.17808777185388114, 0.9056077840194774, 0.17822933812577668, 0.1727832100162956, 0.14186955760384934, 0.20542514766207154, 0.16015071445693008, 0.21161605728563515, 0.15555095182102452, 0.20991419441457493, 0.688617859663445, 0.15698136932834628, 0.8077444102278868, 0.7711267402237918, 0.18953841247047643, 0.19154169178918412, 0.1840021440232409, 0.186340395865789, 0.1918015943729794, 0.1820606355962291, 0.1853123472364694, 0.18664048561129865, 0.1875895043430622, 0.12089043246450693, 0.10330678047073161, 0.1209631281260346, 0.08462840616223744, 0.08301043335460201, 0.08085677613669517, 0.10750621271959993, 0.09279303302847786, 0.09018549054902125]}, "mutation_prompt": null}
{"id": "8b0dadfb-f149-42a5-b795-72467c0ab7ae", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Larger population for better diversity\n        self.F = np.random.uniform(0.4, 0.9)  # Wider range for Differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # Enhanced crossover probability for exploration\n        self.w = 0.3  # Lower inertia weight to favor exploration\n        self.c1 = 1.8 # Increased cognitive learning to boost individual exploration\n        self.c2 = 1.2 # Reduced social learning to maintain diversity\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Enhanced velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.15 * self.population_size  # Higher reinitialization threshold\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Randomize within a wider range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridDEPSO", "description": "A synergistic metaheuristic algorithm that dynamically integrates Differential Evolution and Particle Swarm Optimization with adaptive learning rates and a diversity enhancement technique ensuring robust performance over diverse optimization landscapes.", "configspace": "", "generation": 95, "fitness": 0.3505231292623606, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9206257246184277, 0.9167657973057122, 0.9095209129509704, 0.9173974072145796, 0.9002335592367579, 0.9158383614276204, 0.911352260693423, 0.914561814575867, 0.9095285532698698, 0.8311291538830121, 0.8377426673065654, 0.8380840750077269, 0.8338357066117509, 0.8292733626898046, 0.8185789208688709, 0.8319439153162267, 0.8094976848247578, 0.8378908146108632, 0.17077875923463748, 0.2013418559686384, 0.24530536529618163, 0.232955059266452, 0.43528855856620285, 0.18505833559778906, 0.1587002336828527, 0.18145666003585204, 0.2341722049175352, 0.12958198438100155, 0.16220602082046776, 0.10941769569778204, 0.11396587685010562, 0.13410360646744357, 0.1507891186476742, 0.1411170856187538, 0.1349784799821464, 0.13602223218882192, 0.9675271670697891, 0.9501383669739958, 0.9601768183279209, 0.9594386423533132, 0.9713304551431738, 0.9753337453786922, 0.9681084938545614, 0.9584855602457641, 0.9658609389861699, 0.7620199809880617, 0.7586543971784017, 0.7258853962904264, 0.7638537377816931, 0.7065935939121829, 0.736991718947858, 0.6952679644682485, 0.6910898831573544, 0.7106136281952198, 0.3926766628256424, 0.22586092195524277, 0.3091803973842937, 0.37846142242820446, 0.27426877173937847, 0.8835230058194681, 0.2349927489809588, 0.23711792143320043, 0.8629936858709212, 0.18501867787138193, 0.2036996709839637, 0.19141178225833144, 0.19095607007444648, 0.13433780441619547, 0.16272509978307392, 0.13031624645090123, 0.3655739115232144, 0.19443885355055468, 0.22058979867127415, 0.1296726132932221, 0.1982783387467716, 0.23262498077655003, 0.19895486695401965, 0.20848756329840612, 0.13124582251926165, 0.20632463831591374, 0.24004670441067488, 0.02004973244341457, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04630913450291896, 0.0010427621743079873, 0.16078666072965642, 9.999999999998899e-05, 0.07956895167898115, 0.06208937638719492, 0.08155847113312442, 0.08771053582039112, 0.08016029372389089, 0.08700859503048308, 0.03182809486487004, 0.11833294010725115, 0.15963704761982556, 0.09195621048145475, 0.1313324598175628, 0.32327994789558434, 0.05080434970873904, 0.38002683177377417, 0.08333525434251987, 0.10625348371979892, 0.20230251140730748, 0.29353044712674903, 0.16760214601052814, 0.2538076925024292, 0.2906374330073024, 0.13945881821588413, 0.02228506587731749, 0.2457438665561742, 0.09198234399060179, 0.11410784656807427, 0.2328157880663494, 0.24647927608000142, 0.5934279811444383, 0.5870371430732169, 0.5660013971794849, 0.6284616683445805, 0.5960749668790927, 0.5654413354370165, 0.627827752214388, 0.5687910669390482, 0.5900751447330106, 0.1307390019322271, 0.17630271964480693, 0.13641229353147932, 0.17052208210810582, 0.15672315302280038, 0.092625428810441, 0.13588051841842974, 0.12658289237087628, 0.1055398987904449, 0.2966325874293664, 0.1957870319921695, 0.1897450631058356, 0.25795545071063475, 0.3009954790528474, 0.2258695570426068, 0.42718003663991255, 0.3176843312207178, 0.31880360852892575, 0.5661974706833901, 0.5490949648828761, 0.45169085845830437, 0.5731657963129935, 0.5042633185472828, 0.5737078234068704, 0.7022602915847713, 0.23010623777258976, 0.7085232671968742, 0.2995903155824836, 0.2704423871306507, 0.3048731247974612, 0.32324357963137573, 0.30463415852787534, 0.2199735049649173, 0.24430689252772264, 0.24758285307084815, 0.13921443016416857, 0.22703197274358433, 0.23849919644811812, 0.19072361854886244, 0.19818870761506668, 0.19400852143465763, 0.20501616004181744, 0.2220192857194797, 0.22352387521466177, 0.22256462589921633, 0.16835063195971667, 0.2527874718401848, 0.24534135302504578, 0.23690167731492806, 0.21999888039017013, 0.19867996763184426, 0.19936262377269132, 0.18825755246601272, 0.2251893156855047, 0.16047850537244035, 0.9088708307840208, 0.19394008672365315, 0.1612770565735504, 0.19727988583577705, 0.910436415045731, 0.16621125059609854, 0.8993767317674619, 0.16245437723583311, 0.21016332565762386, 0.1684744652830048, 0.21045075122668144, 0.6636545748630768, 0.1265918158070941, 0.13439849112582236, 0.11496249047612017, 0.8688811371708552, 0.8129134036458445, 0.19044102403142726, 0.1899911427410913, 0.18867618746258885, 0.17934313423527837, 0.17765142629107555, 0.18835056984694498, 0.17800169572283864, 0.17692357533506908, 0.17985215771805885, 0.08832541835455598, 0.0888695831412144, 0.0939747812407783, 0.08760229723552837, 0.09696269208001451, 0.09471672548410426, 0.08739050294330031, 0.10560328278689124, 0.11865415895063147]}, "mutation_prompt": null}
{"id": "624e32d3-fed6-4dfc-b39f-a1c5cb568fa7", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population for diversity\n        self.F = np.random.uniform(0.6, 0.9)  # Increased range for mutation factor\n        self.CR = np.random.uniform(0.5, 0.9) # Broader crossover probability for flexibility\n        self.w = 0.3  # Lower inertia weight for quicker response to changes\n        self.c1 = 1.5 # Balanced cognitive factor for individual learning\n        self.c2 = 1.5 # Balanced social factor for global learning\n        self.velocity_clamp = 0.25 * (self.upper_bound - self.lower_bound) # Increased velocity limits\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enables dynamic adaptation of strategies\n        self.reinit_threshold = 0.1 * self.population_size  # Threshold for reinitializing stagnant solutions\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.6 + 0.3 * np.random.rand()  # Randomize within a range\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a range\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Gradient-like stochastic update for local refinement\n            if np.random.rand() < 0.2:\n                random_individuals = np.random.choice(self.population_size, size=int(0.1 * self.population_size))\n                for idx in random_individuals:\n                    gradient_step = np.random.normal(0, 1, self.dim) * 0.05  # Small step with normal distribution\n                    candidate = self.population[idx] + gradient_step\n                    candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    evals += 1\n                    if candidate_fitness < fitness[idx]:\n                        self.population[idx] = candidate\n                        fitness[idx] = candidate_fitness\n                        if candidate_fitness < self.personal_fitness[idx]:\n                            self.personal_best[idx] = candidate\n                            self.personal_fitness[idx] = candidate_fitness\n                        if candidate_fitness < self.best_fitness:\n                            self.global_best = candidate\n                            self.best_fitness = candidate_fitness\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridDEPSO", "description": "An improved hybrid optimization algorithm combining Differential Evolution, Particle Swarm, and stochastic gradient-like updates with adaptive exploration strategies to enhance convergence speed and robustness.", "configspace": "", "generation": 96, "fitness": 0.35574887785667325, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9050236502622768, 0.8995215419654319, 0.9111004855734808, 0.8980905776930072, 0.8975222442508777, 0.9070793193260096, 0.8982458039437974, 0.8982841972300062, 0.896800495285786, 0.8102520148192265, 0.8006895261486144, 0.7923632500170837, 0.8059032004342922, 0.8145199076745623, 0.8156037406021808, 0.8174180816862581, 0.821250323823646, 0.8173861313878399, 0.15064973211546928, 0.1532179366626797, 0.6640142234125743, 0.1311431357245214, 0.15193312188837793, 0.19438793790087816, 0.1762696458241746, 0.1727074673343183, 0.15811955570024439, 0.1587273426014404, 0.16221858912572862, 0.3039960989369097, 0.3511017010691967, 0.10797434818157403, 0.13645320993373367, 0.13278897753037566, 0.1271203156405296, 0.1292588198902207, 0.9727874055934564, 0.9778343628238733, 0.9597636645967922, 0.9598468297334769, 0.9634048509775791, 0.9692313757010175, 0.9662521406019478, 0.969339897408482, 0.9640397070039495, 0.7022365632736491, 0.7126042352130952, 0.706286739680803, 0.6367700608529338, 0.7176071324081981, 0.7229347702330085, 0.709656652643835, 0.6816394618233294, 0.6876401731356976, 0.8674693805171299, 0.816197207271822, 0.35635768683729674, 0.27872774177222115, 0.21202412769024392, 0.27642297170526486, 0.22043221544235725, 0.2347085266241079, 0.8764405473473957, 0.2101409422257542, 0.21592609168367827, 0.22200450849701492, 0.20567980148249287, 0.12661948118353483, 0.22439480165526426, 0.1334303610191504, 0.21217399465583353, 0.2173079326090488, 0.2300608139349335, 0.23563257833410367, 0.24317820356690978, 0.13384340882225532, 0.2137396708902758, 0.1608685421570486, 0.2303083292004886, 0.23447983576290055, 0.2621524823436242, 9.999999999998899e-05, 0.002292963802330683, 0.00851890840954217, 0.09545499706599803, 0.0750746333425848, 0.07044595212016902, 0.009409293639547456, 9.999999999998899e-05, 0.04224662023385228, 0.08992265174587277, 0.14745361780424504, 0.05439336367890868, 0.07514854064403476, 0.033021533993914276, 0.07288544204640224, 0.08395807162977975, 0.0959076859338982, 0.0704229086307605, 0.17100369321858067, 0.26087423172436464, 0.15202853435912234, 0.08060360290545832, 0.12081218838666663, 0.09993309548390883, 0.25472247382386337, 0.23821899527898327, 0.09298429950982534, 0.176461770200106, 0.17463883365780297, 0.0612764877345624, 0.09496793712377072, 0.09814913788237611, 0.11425108148546881, 0.08375772535259207, 0.11696931064655514, 0.10343118942690488, 0.5558214594575808, 0.5433640002651334, 0.5604212043097679, 0.6224777182157042, 0.5504217478427953, 0.6028845072990701, 0.5714822721266237, 0.6128759778913847, 0.6047140840734316, 0.09784290518558714, 0.10526539964799853, 0.13671425291664874, 0.15985507416697042, 0.14937945648568607, 0.10833384363457821, 0.13014587325366267, 0.10242808766378808, 0.13098543290946585, 0.5709963000294708, 0.399402971031403, 0.4242896964896551, 0.4161410980465662, 0.22947122883296245, 0.15619652306755838, 0.4021307410127595, 0.3663589130545004, 0.4171276703071374, 0.5201124529563981, 0.5768240859234723, 0.5612095092431726, 0.5664390118402387, 0.38371684553036467, 0.31522250268933405, 0.6193901603545584, 0.2652954684570038, 0.5291284111332573, 0.2593576137839102, 0.2794258233011181, 0.26682118411314915, 0.308549756308548, 0.17614526931106156, 0.20472917595177587, 0.18059774307012144, 0.32194534251044804, 0.30345053595659965, 0.22420032905402898, 0.20627510031966945, 0.21416849781922087, 0.2348691011302131, 0.2019623899060966, 0.20125375570399084, 0.2255630256624106, 0.20599038384444812, 0.22897661881369846, 0.22595972058089608, 0.1945283776686848, 0.21660976614524163, 0.24599611810210031, 0.21643678484706863, 0.7915861930329445, 0.389613521808737, 0.20815327671731942, 0.20840395048473337, 0.15292991356954644, 0.18728404426535383, 0.17530456131101635, 0.8836775639678613, 0.14690672932121107, 0.14919731146922077, 0.306979888494611, 0.898526410310108, 0.15300852083048666, 0.21039611494757615, 0.21146619811040168, 0.8656239376205533, 0.8703213906287999, 0.5687638616219657, 0.21108288536320952, 0.4390800867713881, 0.7325337573296051, 0.7654920169901241, 0.1789256147695052, 0.23817617331273733, 0.18957692567638995, 0.1797636452959851, 0.18377502259100054, 0.1905338076459253, 0.17845795923828123, 0.17608927154406595, 0.20151176054672704, 0.08853387783301536, 0.08942652004151042, 0.11051433091633567, 0.08337061301769833, 0.12214788629365647, 0.097334064788282, 0.0852813071734021, 0.08465372395891557, 0.10709704272366705]}, "mutation_prompt": null}
{"id": "9f9e4eb5-20e0-453e-b5b0-bd64c6a966c3", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population for better exploration\n        self.F = np.random.uniform(0.4, 0.9)  # Wider range for differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # More flexibility in crossover probability\n        self.w = 0.5  # Balanced inertia weight for exploration and exploitation\n        self.c1 = 1.7 # Slightly higher cognitive component for exploration\n        self.c2 = 1.3 # Slightly lower social component to manage convergence\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Increased velocity clamp for larger steps\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True  # Enable dynamic strategy selection\n        self.reinit_threshold = 0.05 * self.population_size  # Lower threshold for more frequent reinitialization\n        self.reinit_congestion_threshold = dim * 0.2 # Congestion level to trigger reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:  # Dynamic adaptation\n                self.F = 0.4 + 0.5 * np.random.rand()  # Randomized differential weight\n                self.CR = 0.5 + 0.4 * np.random.rand()  # Randomized crossover probability\n\n            for i in range(self.population_size):\n                # Differential Evolution mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                # Crossover\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                # Evaluate trial solution\n                trial_fitness = func(trial)\n                evals += 1\n\n                # Selection\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                # Update global best\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            # Particle Swarm Optimization update\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            # Reinitialization of a portion of the population if stagnation is detected\n            if np.std(fitness) < 1e-5 or np.count_nonzero(np.abs(self.velocities) < 1e-6) > self.reinit_congestion_threshold:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimization algorithm combining Differential Evolution and Particle Swarm, featuring dynamic parameter tuning and a congestion-aware reinitialization method for persistent exploration.", "configspace": "", "generation": 97, "fitness": 0.322020095512499, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.8699279494881809, 0.8715682195344603, 0.869363740679119, 0.8707371541713799, 0.8640608887085236, 0.8702463310231161, 0.8740296696922686, 0.8846777567946611, 0.8721250792836276, 0.5267810965714343, 0.5592870769579923, 0.5685496239990242, 0.5397833093081703, 0.5529201772845596, 0.5418073107956001, 0.5341129587210287, 0.5236452866450088, 0.5408236207085012, 0.2053687833562261, 0.28503082326178897, 0.20123541465413375, 0.13961374306460295, 0.38255487144101485, 0.1699033899944905, 0.16019209630909825, 0.18726754601765538, 0.21764202865777238, 0.14214010106090902, 0.2551384812523295, 0.1622239800130284, 0.1521110353743783, 0.1296435887355818, 0.10610452296720818, 0.16478418681614782, 0.14092845882634486, 0.15170223794160798, 0.9769299339754296, 0.9650468226306126, 0.969022174307974, 0.9701082877311368, 0.9760636092051408, 0.9816085797776783, 0.9633892806416074, 0.9742980791408637, 0.9716212216143403, 0.5974917887742037, 0.5899607206019203, 0.5897883550006664, 0.577413756690186, 0.5763705375261436, 0.5557363732692147, 0.605399975018276, 0.5767004292600328, 0.5887112931858508, 0.3674431790007464, 0.22085157977952607, 0.37267224653895914, 0.37077777330847694, 0.2758545808219566, 0.8642993010835932, 0.24632466029719413, 0.814173383793154, 0.8457088362794918, 0.23603422237839822, 0.3285048354543586, 0.2133580767811889, 0.12868533263724258, 0.13180607772480635, 0.20252755453192683, 0.21941647623448357, 0.20468629855816267, 0.20576654105852077, 0.22701635292345967, 0.21624040633275243, 0.21986314927097506, 0.2584420935059061, 0.23092475556311187, 0.2185195941139375, 0.23043690846066578, 0.2560465109525336, 0.23394012716942014, 0.0012650060799280771, 0.06441546584570967, 0.022912739518989866, 9.999999999998899e-05, 9.999999999998899e-05, 0.06647153707943931, 0.04034475857629527, 0.027270096370930474, 0.046916114902971984, 0.14159656910610652, 0.1198569530157263, 0.10573435771606021, 0.09061916272095683, 0.11981635802573487, 0.0484804519747668, 0.10240213631529882, 0.07308880651630911, 0.11858115605094321, 0.1683475688479037, 0.09677462920913693, 0.08199436719392217, 0.16052689739227444, 0.07766681892180782, 0.12642911154673753, 0.24477283424610774, 0.09349572092022185, 0.06856247824580752, 0.14799765001820175, 0.10088911132784883, 0.17324659084977045, 0.17948545070399524, 0.21035631501661922, 0.2637279412352108, 0.10353773563622926, 0.0956717252319842, 0.1142501242664985, 0.5470918896273639, 0.543112640074799, 0.5586633806909609, 0.5731650869498722, 0.5727474527198027, 0.5393369285163774, 0.5713423617747639, 0.6007820329705682, 0.5380421995416109, 0.10441676373856046, 0.14917297935783425, 0.10661350853115492, 0.10741148971853276, 0.1495699458878742, 0.09616258787557086, 0.12051403563276708, 0.12681660295281927, 0.11111822035014196, 0.16991507292291952, 0.5463852785993111, 0.18790366316222284, 0.2277157944956384, 0.1351961736906957, 0.12854796104848143, 0.1375210436025751, 0.44463334590926573, 0.13678185792395214, 0.46714588101294796, 0.45584452421027255, 0.3539047466722266, 0.37958600741671866, 0.49591437945748296, 0.41702160395454435, 0.5057799841438875, 0.5175022547459205, 0.5022686898864857, 0.3589779261817666, 0.2405769521268425, 0.23156379582491482, 0.31484823204070433, 0.3411137941901675, 0.2801719301693786, 0.26107532562944447, 0.3787634739968039, 0.3273792159317942, 0.2102718776068786, 0.21803763869011106, 0.18406842648952992, 0.22226287943481493, 0.20359899273413218, 0.20891629827216984, 0.21024781334774645, 0.21051885879232257, 0.2217577179604191, 0.21304263583300465, 0.21823407006956164, 0.20430987362881503, 0.24328118438639312, 0.21589461440366553, 0.20243114221869296, 0.2156833945035681, 0.2102778530842203, 0.18929645340496826, 0.1599330797071965, 0.16454965375332964, 0.1623720160016333, 0.5816871679023516, 0.1678503314532238, 0.9048400846379935, 0.13163411701719108, 0.16589217549526525, 0.15206426676403295, 0.2114061538418589, 0.16814983425529262, 0.21092777647993466, 0.1684706376250118, 0.15511142965931668, 0.13710467787947078, 0.8081660434548517, 0.8334327971572446, 0.7851520450633755, 0.1854073090780355, 0.18530947257285424, 0.1790567121228892, 0.1880836457568278, 0.18776008401165245, 0.18699149401234427, 0.16992322396595405, 0.18736048942838168, 0.18733418535505686, 0.09604447067010968, 0.08806913296553354, 0.08848277528978143, 0.0974344547984527, 0.08680551054756902, 0.0881376899460059, 0.0965002332106717, 0.08924812117919156, 0.10567724327649286]}, "mutation_prompt": null}
{"id": "dd1caa69-ade3-49bb-8f53-c57a6efb23de", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increase population size for better exploration\n        self.F = np.random.uniform(0.4, 0.9)  # Wider variation in Differential weight for flexibility\n        self.CR = np.random.uniform(0.4, 0.9) # Broadened crossover probability range\n        self.w = 0.5  # Minor increase in inertia weight for balanced exploration\n        self.c1 = 1.5 # Reduced cognitive learning to stabilize search\n        self.c2 = 1.5 # Balanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound) # Increased velocity clamp\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.strategy_dynamic = True\n        self.reinit_threshold = 0.2 * self.population_size  # Higher threshold for reinitialization\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            if self.strategy_dynamic:\n                self.F = 0.4 + 0.5 * np.random.rand()\n                self.CR = 0.4 + 0.5 * np.random.rand()\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                x_r1, x_r2, x_r3 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.std(fitness) < 1e-5:\n                survivor_count = int(self.reinit_threshold)\n                survivors = np.argsort(fitness)[:self.population_size - survivor_count]\n                self.population[survivors] = np.random.uniform(self.lower_bound, self.upper_bound, (len(survivors), self.dim))\n                fitness[survivors] = [func(ind) for ind in self.population[survivors]]\n                evals += len(survivors)\n\n        return self.global_best, self.best_fitness", "name": "EnhancedAdaptiveHyDEPSO", "description": "Enhanced hybrid algorithm with adaptive learning rates and survivor-based selection to improve diversity and convergence.", "configspace": "", "generation": 98, "fitness": 0.328270557930219, "feedback": "The algorithm EnhancedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.757266266671337, 0.7292283174608779, 0.7863777948331858, 0.7457123574137692, 0.7498858781896751, 0.729990802437471, 0.7697521093547377, 0.7245693296002262, 0.742651125093635, 0.6328545059077263, 0.6488261463561991, 0.635500233239591, 0.6347295281427856, 0.6259046954357557, 0.6191441221873797, 0.6441709134086394, 0.6313971312285409, 0.6284249784694027, 0.1254031864478542, 0.15073393071178065, 0.1421601225005623, 0.18210680980570693, 0.1676922596846171, 0.17040184345271903, 0.1576118999172722, 0.5647030653485798, 0.15919484197644018, 0.1278695123457605, 0.1351626980244005, 0.1307048862566118, 0.1374036136153527, 0.1398757902270652, 0.10587485389391749, 0.13109424001978875, 0.12471351584349799, 0.2048070812873739, 0.9704158013058204, 0.9728764604813012, 0.9730251953516866, 0.9626282897420955, 0.9649739780092201, 0.9779862601120748, 0.962242569952753, 0.9750723536714889, 0.9689275417082467, 0.6203851445606854, 0.6251443865957295, 0.5524815873368324, 0.565722944348793, 0.6308109547921628, 0.5618069830885408, 0.6158309451171644, 0.5217724055818282, 0.5464798008572039, 0.8580184706645579, 0.20499163950813704, 0.8785080259061536, 0.8106152853356758, 0.6355588301252095, 0.20008026269001988, 0.8716282468964516, 0.8679499296019622, 0.8683435230067366, 0.21524132074588365, 0.21442776029571953, 0.2143202917360576, 0.20719106471152038, 0.1308293056316132, 0.20593630719770806, 0.22095226453102745, 0.21073203053297918, 0.21445206060841093, 0.13035818838235302, 0.24272360627133815, 0.1641283544889216, 0.13110021969321206, 0.23279174107619527, 0.21369283294226182, 0.2282300835653256, 0.23158400251756106, 0.13107027441120622, 0.06607447617563722, 9.999999999998899e-05, 0.0333963893028284, 0.003871943708417036, 0.05176246221451497, 0.056103015822802416, 9.999999999998899e-05, 9.999999999998899e-05, 0.0067413963692993795, 0.09512845208065623, 0.12964877098742122, 0.047556602804047166, 0.11832304160983476, 0.16919340455868037, 0.027472826090089275, 0.0632617921554085, 0.04436059885511534, 0.17176605588824534, 0.037717187505571736, 0.10143954788888931, 0.3034730232627375, 0.09357986953315633, 0.18722104246584925, 0.115267682438558, 0.10042449369194673, 0.22702873788073086, 0.1316106583407134, 0.21096332408486385, 0.14093830812277264, 0.24387721155891418, 0.10860135832813689, 0.11962510598375209, 0.12579624252092814, 0.1036170700452076, 0.056531613453252416, 0.08324401778454726, 0.5626852664986997, 0.5738164326076176, 0.5296522830032495, 0.5853355213987292, 0.5770853399069193, 0.5752907247914087, 0.5484642162500497, 0.6595593073133394, 0.6191670859913632, 0.12887427184241096, 0.09903180852478521, 0.11281845099284127, 0.11576378705962631, 0.14742050391371808, 0.13459860481013386, 0.12733829720452727, 0.10614986592383358, 0.13350385253909225, 0.5215253754830669, 0.1843457294122055, 0.1969583890756148, 0.2728812953471558, 0.18029423869323946, 0.17453369004389607, 0.23056027443305516, 0.19050913429411676, 0.4013021695299732, 0.5372697112692486, 0.41155904166077706, 0.3907297487439054, 0.5405634150849533, 0.5446847475487233, 0.4628545499514354, 0.4304128506930811, 0.2534704748589015, 0.5441319662554026, 0.28846606727828217, 0.2545183879475438, 0.2685777226922914, 0.3076219021376525, 0.2365230400853826, 0.3208494284767347, 0.24818758601791435, 0.284632872886046, 0.1421771715387855, 0.20652894254548249, 0.21847197919573136, 0.19339182867856963, 0.23821589552650357, 0.22800821497935775, 0.2072711100418041, 0.22530580030470237, 0.24687768218565032, 0.19744768554771386, 0.248656750241685, 0.21623060494663227, 0.22125751758159462, 0.6439246766729332, 0.1939246660720424, 0.2447655098481789, 0.20945325215276112, 0.21880912219876514, 0.19689259430166517, 0.18692722419465424, 0.1670161506789456, 0.19889293268464625, 0.16069084043051518, 0.12451791010897417, 0.8799374236580197, 0.13120496548542648, 0.38798591350275236, 0.16192447918573338, 0.7117583184418974, 0.168491010073354, 0.2112654255902977, 0.17074206018570715, 0.21029846773340866, 0.21026215898401046, 0.31533101173046363, 0.8533078985986925, 0.7822439970882785, 0.1819469129523984, 0.18601033191918992, 0.20567241196921493, 0.20063560318679674, 0.1821340740682048, 0.1934448707835541, 0.20173242080131082, 0.1804039328259549, 0.20574642577692426, 0.08694626684124906, 0.1017511993734399, 0.09270355887182902, 0.09185621311052494, 0.09332730250473886, 0.09075452338538981, 0.08284944528203209, 0.11313545201587039, 0.09660330787780436]}, "mutation_prompt": null}
{"id": "0ae2d654-1946-40e8-ba13-63604374e6da", "solution": "import numpy as np\n\nclass RefinedAdaptiveHyDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.F = np.random.uniform(0.4, 0.9)  # Wider range for Differential weight\n        self.CR = np.random.uniform(0.5, 0.9) # Increased range of crossover probability\n        self.w = 0.5  # Adjusted inertia weight\n        self.c1 = 1.5 # Enhanced cognitive learning\n        self.c2 = 1.5 # Enhanced social learning\n        self.velocity_clamp = 0.3 * (self.upper_bound - self.lower_bound)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim)) * self.velocity_clamp\n        self.personal_best = np.copy(self.population)\n        self.global_best = np.copy(self.population[np.argmin([float('inf')] * self.population_size)])\n        self.best_fitness = float('inf')\n        self.reinit_threshold = 0.15 * self.population_size\n\n    def __call__(self, func):\n        evals = 0\n        fitness = np.array([func(ind) for ind in self.population])\n        self.personal_fitness = np.copy(fitness)\n        evals += self.population_size\n\n        while evals < self.budget:\n            self.F = 0.4 + 0.5 * np.random.rand()  # Randomize within a wider range\n            self.CR = 0.5 + 0.4 * np.random.rand()  # Randomize within a wider range\n\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                x_r1, x_r2, x_r3, x_r4 = self.population[indices]\n                mutant = np.clip(x_r1 + self.F * (x_r2 - x_r3) + self.F * (x_r3 - x_r4), self.lower_bound, self.upper_bound)\n\n                crossover = np.random.rand(self.dim) < self.CR\n                trial = np.where(crossover, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evals += 1\n\n                if trial_fitness < fitness[i]:\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < self.personal_fitness[i]:\n                        self.personal_best[i] = trial\n                        self.personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.global_best = trial\n                    self.best_fitness = trial_fitness\n\n            r1, r2 = np.random.rand(self.population_size, self.dim), np.random.rand(self.population_size, self.dim)\n            cognitive = self.c1 * r1 * (self.personal_best - self.population)\n            social = self.c2 * r2 * (self.global_best - self.population)\n            self.velocities = self.w * self.velocities + cognitive + social\n            self.velocities = np.clip(self.velocities, -self.velocity_clamp, self.velocity_clamp)\n            self.population = np.clip(self.population + self.velocities, self.lower_bound, self.upper_bound)\n\n            if np.std(fitness) < 1e-5:\n                reinit_indices = np.random.choice(self.population_size, int(self.reinit_threshold), replace=False)\n                self.population[reinit_indices] = np.random.uniform(self.lower_bound, self.upper_bound, (len(reinit_indices), self.dim))\n                fitness[reinit_indices] = [func(ind) for ind in self.population[reinit_indices]]\n                evals += len(reinit_indices)\n\n        return self.global_best, self.best_fitness", "name": "RefinedAdaptiveHyDEPSO", "description": "A refined hybrid optimization algorithm merging Differential Evolution and Particle Swarm with adaptive parameters, enhanced mutation strategies, and a novel stagnation detection approach to improve global search capabilities.", "configspace": "", "generation": 99, "fitness": 0.3600749166657281, "feedback": "The algorithm RefinedAdaptiveHyDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "5e4b6d1b-d0e1-46f9-995b-59f9f1ffd6f3", "metadata": {"aucs": [0.9002341065451014, 0.877413275006307, 0.8868775275479628, 0.8918750485365482, 0.8875240505238073, 0.8881726017695132, 0.8856529601376828, 0.8911146545755607, 0.8810699561671229, 0.7867188508915742, 0.7572364330962498, 0.7802461207520011, 0.7769819497065416, 0.7848273779884821, 0.7876332330303848, 0.7790049359516225, 0.6685601172171955, 0.7842170656846783, 0.17375171256599298, 0.3699516496086037, 0.16281258100144602, 0.19237833274947957, 0.2537054972277635, 0.4328751897104973, 0.14303512625946657, 0.44162761894297964, 0.15950213365468136, 0.14874572574310463, 0.13894368094609677, 0.34209659844719054, 0.1538985111193788, 0.14935206715555904, 0.14988658906704877, 0.1486398269312187, 0.11948214342575558, 0.14344839275449972, 0.9742126396214367, 0.9793731714762233, 0.9772786394469958, 0.977370415029353, 0.9745021690710312, 0.9677628337230105, 0.9780168202045487, 0.9852088127394479, 0.9841961166974975, 0.7029380647927351, 0.7274606498210672, 0.7045280822520632, 0.7310156578993446, 0.7077625331333357, 0.6992514765083377, 0.6784933971354037, 0.6843348295595706, 0.7019006763763795, 0.22724537770438258, 0.22574147149937995, 0.22649826040129362, 0.906717309565991, 0.8729400490357669, 0.383899197452779, 0.178906554575892, 0.22589121537275136, 0.8878620223969739, 0.2604885223592385, 0.21114602666415905, 0.2283703336684625, 0.21542077064416398, 0.2261744360984954, 0.21826992117614352, 0.22884239200222933, 0.2252964740447192, 0.24010816736812057, 0.24033449015333785, 0.2461736337820556, 0.22716467604182433, 0.21350220612251747, 0.2560354342541129, 0.13319169040943923, 0.2540110896261314, 0.2469789051269251, 0.2595199330893717, 0.006938422792176047, 0.008400734483289152, 0.0086841252367722, 0.02919578547192192, 0.0035097743668613957, 0.08288081787906887, 0.022591878802189824, 0.012036381953931974, 0.010635038703159294, 0.043948505483668465, 0.07651746527270331, 0.08009154516058625, 0.07066729521656323, 0.10678918552362116, 0.024770734115152515, 0.12164595688949253, 0.08494001119259265, 0.14232126170048176, 0.0830427163106493, 0.3774147002981141, 0.05509737392181835, 0.138642132520845, 0.14394487761072305, 0.14225191055651998, 0.07448520523423208, 0.09936012112731818, 0.0999198008741603, 0.09571082301561595, 0.17961485756630935, 0.1384205678716658, 0.12900942419813088, 0.14155015003147275, 0.1872705766137973, 0.0875078124176274, 0.09008985333071218, 0.11969379758416798, 0.5727953129214856, 0.548600490541294, 0.5563411794804234, 0.6136953184682086, 0.5849993983674644, 0.6053503504958231, 0.6161073596616022, 0.5969174901967882, 0.589588227697249, 0.11164737917221668, 0.08247707774192314, 0.5193628121994689, 0.0883419397990074, 0.12879812519950629, 0.15638376498043383, 0.1355425335630187, 0.1362359382459596, 0.09549671221094158, 0.36983121095084204, 0.3164729921594339, 0.2771211668663186, 0.6401339679382638, 0.6665760631618427, 0.23670979521804458, 0.6745890409725284, 0.1915628253843623, 0.19188769544256878, 0.33089595922743464, 0.6048658869625083, 0.5454448780875658, 0.4769508893306439, 0.20096877965720072, 0.5243653842298832, 0.5997897940957829, 0.5570467333035602, 0.6520492682130886, 0.24412294752391683, 0.3922643717904166, 0.28562356865328753, 0.18191267779122955, 0.30111579044847814, 0.29849993364584493, 0.24986288712301796, 0.24610870207591795, 0.4466562514192546, 0.22657304483319696, 0.2383502928588498, 0.22794284794854847, 0.24316041888434314, 0.18366447061061097, 0.20671151435204282, 0.25775057049624106, 0.2147956942211482, 0.2193947652672108, 0.19818161028495473, 0.20721806185751568, 0.22084030207268024, 0.2106119320471348, 0.2495952509477184, 0.18915940176153778, 0.22180562683691174, 0.2081180524245264, 0.7761249182947096, 0.1873821340023395, 0.18746642781280798, 0.1744832996382163, 0.9291593481176482, 0.19810291620471665, 0.9010755759476371, 0.9092926761814448, 0.9121745883292145, 0.9105102308204751, 0.21260977487740162, 0.6702283958588878, 0.2108536562568315, 0.15638206496316487, 0.21172608456510933, 0.21099681783740187, 0.5905630993913132, 0.21298835281020911, 0.10476151547072654, 0.1877116220400239, 0.18540024967644764, 0.18179132402406006, 0.17449692320809684, 0.186664654916471, 0.17912145207357366, 0.18503090828060964, 0.1901684442387317, 0.17613361870697575, 0.0940493017847388, 0.10120048422000494, 0.09460401113443073, 0.11059804182844313, 0.08253479643096817, 0.08955197171600304, 0.09483164003150468, 0.102427187112202, 0.08557595078084579]}, "mutation_prompt": null}
