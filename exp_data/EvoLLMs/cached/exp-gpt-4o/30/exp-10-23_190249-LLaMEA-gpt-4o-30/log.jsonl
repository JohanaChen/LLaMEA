{"id": "2c4a4cc8-0e9e-47b2-98c9-98417ab6fb35", "solution": "import numpy as np\n\nclass DMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Split particles into dynamic swarms\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, self.num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0][0]\n                    if value < personal_best_values[idx]:\n                        personal_best_values[idx] = value\n                        personal_best_positions[idx] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0][0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Update global best\n            for i in range(self.num_particles):\n                value = func(positions[i])\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(positions[i])\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "DMSPSO", "description": "A dynamic multi-swarm particle swarm optimization (DMS-PSO) with adaptive velocity control, which divides the population into dynamic swarms to explore and exploit the search space efficiently.", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "An exception occured: Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 51, in __call__\nIndexError: index 0 is out of bounds for axis 0 with size 0\n.", "error": "IndexError('index 0 is out of bounds for axis 0 with size 0')Traceback (most recent call last):\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 187, in initialize_single\n    new_individual = self.evaluate_fitness(new_individual)\n  File \"/scratch/hyin/LLaMEA/llamea/llamea.py\", line 264, in evaluate_fitness\n    updated_individual = self.f(individual, self.logger)\n  File \"mutation_exp.py\", line 52, in evaluateBBOB\n    algorithm(problem)\n  File \"<string>\", line 51, in __call__\nIndexError: index 0 is out of bounds for axis 0 with size 0\n", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "51d6c07a-1e1c-4424-9334-31b7e3e79047", "solution": "import numpy as np\n\nclass EPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.initial_inertia = 0.9\n        self.final_inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Adaptive inertia calculation\n            inertia = self.initial_inertia - (self.initial_inertia - self.final_inertia) * (eval_count / self.budget)\n            \n            # Split particles into dynamic swarms\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, self.num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0][0]\n                    if value < personal_best_values[idx]:\n                        personal_best_values[idx] = value\n                        personal_best_positions[idx] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0][0]\n                    velocities[particle_idx] = (\n                        inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Update global best\n            for i in range(self.num_particles):\n                value = func(positions[i])\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(positions[i])\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EPSO", "description": "An enhanced particle swarm optimization (EPSO) with adaptive inertia and cooperative multi-swarm strategy to efficiently explore and exploit the search space.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 0 is out of bounds for axis 0 with size 0').", "error": "IndexError('index 0 is out of bounds for axis 0 with size 0')", "parent_id": "2c4a4cc8-0e9e-47b2-98c9-98417ab6fb35", "metadata": {}, "mutation_prompt": null}
{"id": "89285117-f443-4352-827d-cefe84d37975", "solution": "import numpy as np\n\nclass EnhancedDMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.9  # Initialize with higher inertia for exploration\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            if value < personal_best_values[i]:\n                personal_best_values[i] = value\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            self.inertia = 0.5 + np.random.rand() * 0.4  # Adapt inertia dynamically\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, self.num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0][0]\n                    if value < personal_best_values[idx]:\n                        personal_best_values[idx] = value\n                        personal_best_positions[idx] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0][0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    perturbation = np.random.normal(0, 0.1, self.dim)  # Add local perturbation\n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx] + perturbation\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            for i in range(self.num_particles):\n                value = func(positions[i])\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(positions[i])\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedDMSPSO", "description": "A stochastic dynamic multi-swarm approach with adaptive inertia and local perturbation to improve convergence diversity.", "configspace": "", "generation": 2, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 0 is out of bounds for axis 0 with size 0').", "error": "IndexError('index 0 is out of bounds for axis 0 with size 0')", "parent_id": "2c4a4cc8-0e9e-47b2-98c9-98417ab6fb35", "metadata": {}, "mutation_prompt": null}
{"id": "a63957ef-b8d0-4125-8872-6f98a1a92264", "solution": "import numpy as np\n\nclass HAMsPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Dynamically adjust swarms based on performance\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions with elitist approach\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Merge the best performing swarms and update global best\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "HAMsPSO", "description": "A hybrid adaptive multi-swarm particle swarm optimization (HA-MSPSO) with elitist selection and dynamic swarm merging for enhanced exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.09873127732799593, "feedback": "The algorithm HAMsPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "2c4a4cc8-0e9e-47b2-98c9-98417ab6fb35", "metadata": {"aucs": [0.12704200535492727, 0.12704200535492727, 0.12704200535492727, 0.1352167913959329, 0.1352167913959329, 0.1352167913959329, 0.12532665182135683, 0.12532665182135683, 0.12532665182135683, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014990515603120036, 0.014990515603120036, 0.014990515603120036, 0.02984008201585986, 0.02984008201585986, 0.02984008201585986, 0.026972349854353928, 0.026972349854353928, 0.026972349854353928, 0.005353581074770242, 0.005353581074770242, 0.005353581074770242, 0.01959972157639278, 0.01959972157639278, 0.01959972157639278, 0.0005977993287664685, 0.0005977993287664685, 0.0005977993287664685, 0.9823969647416468, 0.9823969647416468, 0.9823969647416468, 0.9518265544781465, 0.9518265544781465, 0.9518265544781465, 0.9762422976508073, 0.9762422976508073, 0.9762422976508073, 0.06274794416174423, 0.06274794416174423, 0.06274794416174423, 0.025857820319043268, 0.025857820319043268, 0.025857820319043268, 0.03019071802324491, 0.03019071802324491, 0.03019071802324491, 0.10027683525177622, 0.10027683525177622, 0.10027683525177622, 0.07813231062882298, 0.07813231062882298, 0.07813231062882298, 0.08319505127091875, 0.08319505127091875, 0.08319505127091875, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027789836400814227, 0.027789836400814227, 0.027789836400814227, 0.03069088432760181, 0.03069088432760181, 0.03069088432760181, 0.0064802275170579016, 0.0064802275170579016, 0.0064802275170579016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.17577641961277446, 0.17577641961277446, 0.17577641961277446, 0.15246526501856772, 0.15246526501856772, 0.15246526501856772, 0.2241338926276809, 0.2241338926276809, 0.2241338926276809, 0.038846685280758186, 0.038846685280758186, 0.038846685280758186, 0.03266886175302153, 0.03266886175302153, 0.03266886175302153, 0.014639741757941915, 0.014639741757941915, 0.014639741757941915, 0.14659443147939855, 0.14659443147939855, 0.14659443147939855, 0.12484833673585927, 0.12484833673585927, 0.12484833673585927, 0.13426733335164043, 0.13426733335164043, 0.13426733335164043, 0.12295985326739678, 0.12295985326739678, 0.12295985326739678, 0.13800672315110074, 0.13800672315110074, 0.13800672315110074, 0.12869632812857945, 0.12869632812857945, 0.12869632812857945, 0.0673626440471522, 0.0673626440471522, 0.0673626440471522, 0.06872099511231167, 0.06872099511231167, 0.06872099511231167, 0.09420282388642753, 0.09420282388642753, 0.09420282388642753, 0.12175066324840245, 0.12175066324840245, 0.12175066324840245, 0.12565636032389016, 0.12565636032389016, 0.12565636032389016, 0.12245976138762271, 0.12245976138762271, 0.12245976138762271, 0.013731534793318678, 0.013731534793318678, 0.013731534793318678, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10498459598242627, 0.10498459598242627, 0.10498459598242627, 0.10976347753021365, 0.10976347753021365, 0.10976347753021365, 0.11067209852294813, 0.11067209852294813, 0.11067209852294813, 0.11040265245322212, 0.11040265245322212, 0.11040265245322212, 0.05511252523668431, 0.05511252523668431, 0.05511252523668431, 0.11740624993665938, 0.11740624993665938, 0.11740624993665938, 0.17853331691939, 0.17853331691939, 0.17853331691939, 0.1671326425618297, 0.1671326425618297, 0.1671326425618297, 0.17171604502893933, 0.17171604502893933, 0.17171604502893933, 0.02237224351422351, 0.02237224351422351, 0.02237224351422351, 0.027808519392987008, 0.027808519392987008, 0.027808519392987008, 0.04219200277523394, 0.04219200277523394, 0.04219200277523394]}, "mutation_prompt": null}
{"id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "solution": "import numpy as np\n\nclass GenAMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.mutation_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Dynamically adjust swarms based on performance\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions with elitist approach\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    # Introduce mutation for enhanced exploration\n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 1, self.dim)\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Merge the best performing swarms and update global best\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "GenAMSPSO", "description": "A genetically enhanced adaptive multi-swarm particle swarm optimization with mutation-induced exploration and dynamic swarm stabilization for improved convergence.", "configspace": "", "generation": 4, "fitness": 0.09994797687694035, "feedback": "The algorithm GenAMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "a63957ef-b8d0-4125-8872-6f98a1a92264", "metadata": {"aucs": [0.15288621704388639, 0.15288621704388639, 0.15288621704388639, 0.13652804323776835, 0.13652804323776835, 0.13652804323776835, 0.12191259316789005, 0.12191259316789005, 0.12191259316789005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01989512136452376, 0.01989512136452376, 0.01989512136452376, 0.025053152218861396, 0.025053152218861396, 0.025053152218861396, 0.02082616783313118, 0.02082616783313118, 0.02082616783313118, 0.012947616288294217, 0.012947616288294217, 0.012947616288294217, 0.01959972157639278, 0.01959972157639278, 0.01959972157639278, 0.006984691355532258, 0.006984691355532258, 0.006984691355532258, 0.9839318116761551, 0.9839318116761551, 0.9839318116761551, 0.967587369327232, 0.967587369327232, 0.967587369327232, 0.9535861907031206, 0.9535861907031206, 0.9535861907031206, 0.06274794416174423, 0.06274794416174423, 0.06274794416174423, 0.020636325076626605, 0.020636325076626605, 0.020636325076626605, 0.05510489552288178, 0.05510489552288178, 0.05510489552288178, 0.10027683525177622, 0.10027683525177622, 0.10027683525177622, 0.07953472583179466, 0.07953472583179466, 0.07953472583179466, 0.06849624803426346, 0.06849624803426346, 0.06849624803426346, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007115482355170899, 0.007115482355170899, 0.007115482355170899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006342751986417872, 0.0006342751986417872, 0.0006342751986417872, 0.04201331710100986, 0.04201331710100986, 0.04201331710100986, 0.01783196227316386, 0.01783196227316386, 0.01783196227316386, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12257520773366837, 0.12257520773366837, 0.12257520773366837, 0.1370057780957319, 0.1370057780957319, 0.1370057780957319, 0.1909449140893581, 0.1909449140893581, 0.1909449140893581, 0.025662821580844875, 0.025662821580844875, 0.025662821580844875, 0.03266886175302153, 0.03266886175302153, 0.03266886175302153, 0.014367556024523553, 0.014367556024523553, 0.014367556024523553, 0.13129228066218634, 0.13129228066218634, 0.13129228066218634, 0.1163251796078153, 0.1163251796078153, 0.1163251796078153, 0.1286562253272241, 0.1286562253272241, 0.1286562253272241, 0.1152660203751471, 0.1152660203751471, 0.1152660203751471, 0.13800672315110074, 0.13800672315110074, 0.13800672315110074, 0.1376022539725591, 0.1376022539725591, 0.1376022539725591, 0.1006556126902105, 0.1006556126902105, 0.1006556126902105, 0.07435135055566555, 0.07435135055566555, 0.07435135055566555, 0.08589952641538312, 0.08589952641538312, 0.08589952641538312, 0.12000258410221953, 0.12000258410221953, 0.12000258410221953, 0.16253699471358596, 0.16253699471358596, 0.16253699471358596, 0.1245314405660729, 0.1245314405660729, 0.1245314405660729, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.062166964664837954, 0.062166964664837954, 0.062166964664837954, 0.11979552264934301, 0.11979552264934301, 0.11979552264934301, 0.13518499619443536, 0.13518499619443536, 0.13518499619443536, 0.1127261850011162, 0.1127261850011162, 0.1127261850011162, 0.12960863155605873, 0.12960863155605873, 0.12960863155605873, 0.059553459160744726, 0.059553459160744726, 0.059553459160744726, 0.12445280341315557, 0.12445280341315557, 0.12445280341315557, 0.1771642810770716, 0.1771642810770716, 0.1771642810770716, 0.17233876821994987, 0.17233876821994987, 0.17233876821994987, 0.17470263846215472, 0.17470263846215472, 0.17470263846215472, 0.04100412949157528, 0.04100412949157528, 0.04100412949157528, 0.027015293023570086, 0.027015293023570086, 0.027015293023570086, 0.02415862420951198, 0.02415862420951198, 0.02415862420951198]}, "mutation_prompt": null}
{"id": "fdb399e6-ac47-4079-a7fa-91b8d7f8fb7d", "solution": "import numpy as np\n\nclass EntropyGuidedMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.8\n        self.cognitive = 2.0\n        self.social = 1.5\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n\n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Entropy-based adjustment for swarms\n            adaptive_num_swarms = np.random.randint(2, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions with elitist approach\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    # Adaptive mutation strategy\n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 0.5, self.dim)\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Merge the best performing swarms and update global best\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EntropyGuidedMSPSO", "description": "An entropy-guided multi-swarm particle swarm optimization using adaptive mutation and elitism for robust convergence.", "configspace": "", "generation": 5, "fitness": 0.09400737206582727, "feedback": "The algorithm EntropyGuidedMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.09 with standard deviation 0.19.", "error": "", "parent_id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "metadata": {"aucs": [0.1811205295225493, 0.1811205295225493, 0.1811205295225493, 0.12857779677028702, 0.12857779677028702, 0.12857779677028702, 0.1179596823648964, 0.1179596823648964, 0.1179596823648964, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012843048854694783, 0.012843048854694783, 0.012843048854694783, 0.013724475154345828, 0.013724475154345828, 0.013724475154345828, 0.018248263482334326, 0.018248263482334326, 0.018248263482334326, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.01959972157639278, 0.01959972157639278, 0.01135608786467801, 0.01135608786467801, 0.01135608786467801, 0.9753963729456808, 0.9753963729456808, 0.9753963729456808, 0.8924370803989033, 0.8924370803989033, 0.8924370803989033, 0.965909715766725, 0.965909715766725, 0.965909715766725, 0.06274794416174423, 0.06274794416174423, 0.06274794416174423, 0.013749277306767338, 0.013749277306767338, 0.013749277306767338, 0.045328201665375545, 0.045328201665375545, 0.045328201665375545, 0.10027683525177622, 0.10027683525177622, 0.10027683525177622, 0.0667108215001172, 0.0667108215001172, 0.0667108215001172, 0.06306693394304874, 0.06306693394304874, 0.06306693394304874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027333614266844553, 0.0027333614266844553, 0.0027333614266844553, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004383305528864678, 0.004383305528864678, 0.004383305528864678, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11018194216940991, 0.11018194216940991, 0.11018194216940991, 0.15422313266627663, 0.15422313266627663, 0.15422313266627663, 0.16112956940342849, 0.16112956940342849, 0.16112956940342849, 0.025751963022126456, 0.025751963022126456, 0.025751963022126456, 0.03266886175302153, 0.03266886175302153, 0.03266886175302153, 0.02628837941065465, 0.02628837941065465, 0.02628837941065465, 0.1363901855045455, 0.1363901855045455, 0.1363901855045455, 0.11977140528190233, 0.11977140528190233, 0.11977140528190233, 0.12258534109648789, 0.12258534109648789, 0.12258534109648789, 0.12034566968291582, 0.12034566968291582, 0.12034566968291582, 0.13800672315110074, 0.13800672315110074, 0.13800672315110074, 0.12706310680785315, 0.12706310680785315, 0.12706310680785315, 0.0578749577318709, 0.0578749577318709, 0.0578749577318709, 0.06978237066599613, 0.06978237066599613, 0.06978237066599613, 0.0837317855149382, 0.0837317855149382, 0.0837317855149382, 0.11943364695601921, 0.11943364695601921, 0.11943364695601921, 0.11668643183173122, 0.11668643183173122, 0.11668643183173122, 0.12245976138762271, 0.12245976138762271, 0.12245976138762271, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09998646533556188, 0.09998646533556188, 0.09998646533556188, 0.10824255656620785, 0.10824255656620785, 0.10824255656620785, 0.1070176662487543, 0.1070176662487543, 0.1070176662487543, 0.11040265245322212, 0.11040265245322212, 0.11040265245322212, 0.06455183881835147, 0.06455183881835147, 0.06455183881835147, 0.12542530153757603, 0.12542530153757603, 0.12542530153757603, 0.1819377301803956, 0.1819377301803956, 0.1819377301803956, 0.16855910865463009, 0.16855910865463009, 0.16855910865463009, 0.18136665510304417, 0.18136665510304417, 0.18136665510304417, 0.018960304503162106, 0.018960304503162106, 0.018960304503162106, 0.027015293023570086, 0.027015293023570086, 0.027015293023570086, 0.032220526791319704, 0.032220526791319704, 0.032220526791319704]}, "mutation_prompt": null}
{"id": "b6015656-a307-4238-802a-99558bedf704", "solution": "import numpy as np\n\nclass DynamicEliteMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.num_swarms = 4\n        self.inertia = 0.6\n        self.cognitive = 1.7\n        self.social = 1.8\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(2, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 0.5, self.dim)\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "DynamicEliteMSPSO", "description": "A dynamic elite-guided multi-swarm particle swarm optimization with adaptive velocity control and stochastic position perturbation for enhanced exploration and faster convergence.", "configspace": "", "generation": 6, "fitness": 0.09916180623778272, "feedback": "The algorithm DynamicEliteMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "metadata": {"aucs": [0.12508240404756343, 0.12508240404756343, 0.12508240404756343, 0.14016982224555163, 0.14016982224555163, 0.14016982224555163, 0.14647115849748082, 0.14647115849748082, 0.14647115849748082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026263578152453948, 0.026263578152453948, 0.026263578152453948, 0.022041105593842092, 0.022041105593842092, 0.022041105593842092, 0.012245413936356808, 0.012245413936356808, 0.012245413936356808, 0.008245664030359534, 0.008245664030359534, 0.008245664030359534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01225373580774669, 0.01225373580774669, 0.01225373580774669, 0.9264965152896087, 0.9264965152896087, 0.9264965152896087, 0.9590615692675108, 0.9590615692675108, 0.9590615692675108, 0.9788106086531255, 0.9788106086531255, 0.9788106086531255, 0.030623389111998023, 0.030623389111998023, 0.030623389111998023, 0.060242131669095755, 0.060242131669095755, 0.060242131669095755, 0.051485473513365965, 0.051485473513365965, 0.051485473513365965, 0.05496212273548429, 0.05496212273548429, 0.05496212273548429, 0.0788292811270519, 0.0788292811270519, 0.0788292811270519, 0.0702759914863813, 0.0702759914863813, 0.0702759914863813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0061813581946773555, 0.0061813581946773555, 0.0061813581946773555, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009371773395563499, 0.009371773395563499, 0.009371773395563499, 0.010817926870884897, 0.010817926870884897, 0.010817926870884897, 0.004781987278568933, 0.004781987278568933, 0.004781987278568933, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1738992314838229, 0.1738992314838229, 0.1738992314838229, 0.151416585653398, 0.151416585653398, 0.151416585653398, 0.16062786252463612, 0.16062786252463612, 0.16062786252463612, 0.03280747475698609, 0.03280747475698609, 0.03280747475698609, 0.03679521537676789, 0.03679521537676789, 0.03679521537676789, 0.016358237435033174, 0.016358237435033174, 0.016358237435033174, 0.14351517566048444, 0.14351517566048444, 0.14351517566048444, 0.10676317296602733, 0.10676317296602733, 0.10676317296602733, 0.11268051389441458, 0.11268051389441458, 0.11268051389441458, 0.12661753353750393, 0.12661753353750393, 0.12661753353750393, 0.14183908659026878, 0.14183908659026878, 0.14183908659026878, 0.1536893010168675, 0.1536893010168675, 0.1536893010168675, 0.07910490777861834, 0.07910490777861834, 0.07910490777861834, 0.08292041181701593, 0.08292041181701593, 0.08292041181701593, 0.07624108805157481, 0.07624108805157481, 0.07624108805157481, 0.10824433217934115, 0.10824433217934115, 0.10824433217934115, 0.1296378304020689, 0.1296378304020689, 0.1296378304020689, 0.10661817027027831, 0.10661817027027831, 0.10661817027027831, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10440593093438333, 0.10440593093438333, 0.10440593093438333, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1303692316653443, 0.1303692316653443, 0.1303692316653443, 0.10243348147764175, 0.10243348147764175, 0.10243348147764175, 0.15349837467600136, 0.15349837467600136, 0.15349837467600136, 0.10456025156114734, 0.10456025156114734, 0.10456025156114734, 0.11742123793182457, 0.11742123793182457, 0.11742123793182457, 0.1198645621987473, 0.1198645621987473, 0.1198645621987473, 0.16093428671697807, 0.16093428671697807, 0.16093428671697807, 0.17532311562584513, 0.17532311562584513, 0.17532311562584513, 0.18206214664083276, 0.18206214664083276, 0.18206214664083276, 0.03681995327163823, 0.03681995327163823, 0.03681995327163823, 0.03666557420395744, 0.03666557420395744, 0.03666557420395744, 0.03880275991623516, 0.03880275991623516, 0.03880275991623516]}, "mutation_prompt": null}
{"id": "eb2e5ccd-910e-4ae6-b74c-a4c6bb5c2ec6", "solution": "import numpy as np\n\nclass AdaptiveAMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.729  # Modified for stability\n        self.cognitive = 1.49445  # Modified for exploration\n        self.social = 1.49445  # Modified for exploitation\n        self.mutation_prob = 0.2  # Adjusted mutation probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(42)  # Changed seed for different random sequences\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))  # Initialized to zero for a start\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(2, self.num_swarms + 2)  # Adjusted swarm range\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] *= np.random.uniform(0.5, 1.5, self.dim)  # Scaled mutation\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "AdaptiveAMSPSO", "description": "A probabilistically adaptive multi-swarm particle swarm optimization with dynamic velocity scaling and selective mutation for enhanced convergence.", "configspace": "", "generation": 7, "fitness": 0.09836014824029055, "feedback": "The algorithm AdaptiveAMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.18.", "error": "", "parent_id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "metadata": {"aucs": [0.17919919605392498, 0.17919919605392498, 0.17919919605392498, 0.19141513168134217, 0.19141513168134217, 0.19141513168134217, 0.14647115849748082, 0.14647115849748082, 0.14647115849748082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029273860726217737, 0.029273860726217737, 0.029273860726217737, 0.028718701861032647, 0.028718701861032647, 0.028718701861032647, 0.028461122377982262, 0.028461122377982262, 0.028461122377982262, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011402831134044611, 0.011402831134044611, 0.011402831134044611, 0.9754126022179199, 0.9754126022179199, 0.9754126022179199, 0.8944039454224026, 0.8944039454224026, 0.8944039454224026, 0.920232475742793, 0.920232475742793, 0.920232475742793, 0.028353403977381286, 0.028353403977381286, 0.028353403977381286, 0.04716343567950021, 0.04716343567950021, 0.04716343567950021, 0.05414441771375844, 0.05414441771375844, 0.05414441771375844, 0.049491981030189924, 0.049491981030189924, 0.049491981030189924, 0.0759855248987158, 0.0759855248987158, 0.0759855248987158, 0.08710324706829686, 0.08710324706829686, 0.08710324706829686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004307945830082316, 0.004307945830082316, 0.004307945830082316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016793809275846394, 0.016793809275846394, 0.016793809275846394, 0.016077818976851455, 0.016077818976851455, 0.016077818976851455, 0.00993198742038981, 0.00993198742038981, 0.00993198742038981, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1738992314838229, 0.1738992314838229, 0.1738992314838229, 0.1554685903740578, 0.1554685903740578, 0.1554685903740578, 0.15846645068518084, 0.15846645068518084, 0.15846645068518084, 0.02431287246749403, 0.02431287246749403, 0.02431287246749403, 0.03139487609036773, 0.03139487609036773, 0.03139487609036773, 0.01687201244182235, 0.01687201244182235, 0.01687201244182235, 0.12798261307409553, 0.12798261307409553, 0.12798261307409553, 0.1052832079252557, 0.1052832079252557, 0.1052832079252557, 0.11113049023064181, 0.11113049023064181, 0.11113049023064181, 0.13332403481338662, 0.13332403481338662, 0.13332403481338662, 0.13657276237750426, 0.13657276237750426, 0.13657276237750426, 0.1364966032430417, 0.1364966032430417, 0.1364966032430417, 0.06316747149706858, 0.06316747149706858, 0.06316747149706858, 0.07871911578954227, 0.07871911578954227, 0.07871911578954227, 0.09128088900307174, 0.09128088900307174, 0.09128088900307174, 0.1386967403057322, 0.1386967403057322, 0.1386967403057322, 0.11580379262363205, 0.11580379262363205, 0.11580379262363205, 0.11800533322699158, 0.11800533322699158, 0.11800533322699158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15196341151521042, 0.15196341151521042, 0.15196341151521042, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13273655577533505, 0.13273655577533505, 0.13273655577533505, 0.10873525914809201, 0.10873525914809201, 0.10873525914809201, 0.09720098724733928, 0.09720098724733928, 0.09720098724733928, 0.0943850378081541, 0.0943850378081541, 0.0943850378081541, 0.07692580378040548, 0.07692580378040548, 0.07692580378040548, 0.1079948402357388, 0.1079948402357388, 0.1079948402357388, 0.18198445126679041, 0.18198445126679041, 0.18198445126679041, 0.1716937361037164, 0.1716937361037164, 0.1716937361037164, 0.1581766223845883, 0.1581766223845883, 0.1581766223845883, 0.040301172643750216, 0.040301172643750216, 0.040301172643750216, 0.024952183872692824, 0.024952183872692824, 0.024952183872692824, 0.02155892628024414, 0.02155892628024414, 0.02155892628024414]}, "mutation_prompt": null}
{"id": "81b6b5c3-9fe1-489c-a6d7-2a066cd3302a", "solution": "import numpy as np\n\nclass EnhancedDynamicSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6\n        self.cognitive = 1.7\n        self.social = 1.8\n        self.global_mutation_prob = 0.15\n        self.local_mutation_prob = 0.05\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Dynamically adjust swarms based on performance\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions with elitist approach\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    # Introduce adaptive mutation for enhanced exploration\n                    if np.random.rand() < self.local_mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 0.5, self.dim)\n                        \n                    if np.random.rand() < self.global_mutation_prob:\n                        velocities[particle_idx] += np.random.uniform(-0.5, 0.5, self.dim)\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Merge the best performing swarms and update global best\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedDynamicSwarmPSO", "description": "An enhanced dynamic swarm optimization with adaptive mutation factors and improved inter-swarm communication for accelerated convergence.", "configspace": "", "generation": 8, "fitness": 0.09935368125250192, "feedback": "The algorithm EnhancedDynamicSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "metadata": {"aucs": [0.11869729595922507, 0.11869729595922507, 0.11869729595922507, 0.13532197730309914, 0.13532197730309914, 0.13532197730309914, 0.11508291838072726, 0.11508291838072726, 0.11508291838072726, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012038184483408987, 0.012038184483408987, 0.012038184483408987, 0.02550292038481039, 0.02550292038481039, 0.02550292038481039, 0.02156443474946279, 0.02156443474946279, 0.02156443474946279, 0.0014061472377477902, 0.0014061472377477902, 0.0014061472377477902, 0.01959972157639278, 0.01959972157639278, 0.01959972157639278, 0.007451398623112615, 0.007451398623112615, 0.007451398623112615, 0.9671537388849313, 0.9671537388849313, 0.9671537388849313, 0.9589576526438753, 0.9589576526438753, 0.9589576526438753, 0.9656835353333806, 0.9656835353333806, 0.9656835353333806, 0.069641409403426, 0.069641409403426, 0.069641409403426, 0.017921023593364005, 0.017921023593364005, 0.017921023593364005, 0.03829372634098305, 0.03829372634098305, 0.03829372634098305, 0.10027683525177622, 0.10027683525177622, 0.10027683525177622, 0.07617593010800405, 0.07617593010800405, 0.07617593010800405, 0.08395303667134246, 0.08395303667134246, 0.08395303667134246, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029013784173146373, 0.0029013784173146373, 0.0029013784173146373, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.016982451110485797, 0.016982451110485797, 0.016982451110485797, 0.01522022681536106, 0.01522022681536106, 0.01522022681536106, 0.010307146257725996, 0.010307146257725996, 0.010307146257725996, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13125791224457484, 0.13125791224457484, 0.13125791224457484, 0.15216113071609794, 0.15216113071609794, 0.15216113071609794, 0.16401299280448167, 0.16401299280448167, 0.16401299280448167, 0.02795322431129499, 0.02795322431129499, 0.02795322431129499, 0.03469143237840999, 0.03469143237840999, 0.03469143237840999, 0.01598177764051667, 0.01598177764051667, 0.01598177764051667, 0.12613463891345122, 0.12613463891345122, 0.12613463891345122, 0.1428014565670066, 0.1428014565670066, 0.1428014565670066, 0.12011947217951258, 0.12011947217951258, 0.12011947217951258, 0.13000857793041543, 0.13000857793041543, 0.13000857793041543, 0.13967618627423994, 0.13967618627423994, 0.13967618627423994, 0.12951169615746172, 0.12951169615746172, 0.12951169615746172, 0.07369589869402604, 0.07369589869402604, 0.07369589869402604, 0.08089296740148189, 0.08089296740148189, 0.08089296740148189, 0.0837317855149382, 0.0837317855149382, 0.0837317855149382, 0.11943364695601921, 0.11943364695601921, 0.11943364695601921, 0.12314426380726906, 0.12314426380726906, 0.12314426380726906, 0.12245976138762271, 0.12245976138762271, 0.12245976138762271, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12205729657083086, 0.12205729657083086, 0.12205729657083086, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1248500646345152, 0.1248500646345152, 0.1248500646345152, 0.11247603501170977, 0.11247603501170977, 0.11247603501170977, 0.11113455874618139, 0.11113455874618139, 0.11113455874618139, 0.12457020146755149, 0.12457020146755149, 0.12457020146755149, 0.06821342986817891, 0.06821342986817891, 0.06821342986817891, 0.1660154212559095, 0.1660154212559095, 0.1660154212559095, 0.17376904949918337, 0.17376904949918337, 0.17376904949918337, 0.16935208130376944, 0.16935208130376944, 0.16935208130376944, 0.19067006639762007, 0.19067006639762007, 0.19067006639762007, 0.03162148195180692, 0.03162148195180692, 0.03162148195180692, 0.03369331918410157, 0.03369331918410157, 0.03369331918410157, 0.025340132880001476, 0.025340132880001476, 0.025340132880001476]}, "mutation_prompt": null}
{"id": "5b3f0b25-ba90-4f5c-8aa7-305c1bbf734d", "solution": "import numpy as np\n\nclass MutBoostAMSPSO_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6  # Altered inertia for better balance\n        self.cognitive = 1.8  # Adjusted cognitive component\n        self.social = 1.9  # Adjusted social component\n        self.mutation_prob = 0.15  # Increased mutation probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.temperature = 100  # Initial temperature for simulated annealing\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n\n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n\n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n\n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n\n                    if eval_count >= self.budget:\n                        break\n\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) *\n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) *\n                        (local_best_position - swarm[idx])\n                    )\n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 0.5, self.dim)\n                    \n                    new_position = positions[particle_idx] + velocities[particle_idx]\n                    # Simulated annealing acceptance criterion\n                    delta = func(new_position) - func(positions[particle_idx])\n                    if delta < 0 or np.random.rand() < np.exp(-delta / self.temperature):\n                        positions[particle_idx] = new_position\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n\n                self.temperature *= 0.95  # Cooling schedule\n\n                if eval_count >= self.budget:\n                    break\n\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best_position, self.global_best_value", "name": "MutBoostAMSPSO_SA", "description": "A mutation-boosted adaptive multi-swarm particle swarm optimization that dynamically adjusts velocities and integrates simulated annealing for enhanced global convergence.", "configspace": "", "generation": 9, "fitness": 0.08218167177381298, "feedback": "The algorithm MutBoostAMSPSO_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.16.", "error": "", "parent_id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "metadata": {"aucs": [0.11869729595922507, 0.11869729595922507, 0.11869729595922507, 0.1038727526675457, 0.1038727526675457, 0.1038727526675457, 0.16480861107826872, 0.16480861107826872, 0.16480861107826872, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0291001239239167, 0.0291001239239167, 0.0291001239239167, 0.010643411704069683, 0.010643411704069683, 0.010643411704069683, 0.047583400009968635, 0.047583400009968635, 0.047583400009968635, 0.023916256948787296, 0.023916256948787296, 0.023916256948787296, 0.01959972157639278, 0.01959972157639278, 0.01959972157639278, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.9653781144576425, 0.9653781144576425, 0.9653781144576425, 0.21392159917708087, 0.21392159917708087, 0.21392159917708087, 0.9606937102831604, 0.9606937102831604, 0.9606937102831604, 0.06758490084853586, 0.06758490084853586, 0.06758490084853586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10027683525177622, 0.10027683525177622, 0.10027683525177622, 0.0667108215001172, 0.0667108215001172, 0.0667108215001172, 0.04478057074497266, 0.04478057074497266, 0.04478057074497266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025346154246547292, 0.025346154246547292, 0.025346154246547292, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12100016277063808, 0.12100016277063808, 0.12100016277063808, 0.13954369177344528, 0.13954369177344528, 0.13954369177344528, 0.16112956940342849, 0.16112956940342849, 0.16112956940342849, 0.033435905075309025, 0.033435905075309025, 0.033435905075309025, 0.03266886175302153, 0.03266886175302153, 0.03266886175302153, 0.013408028603510536, 0.013408028603510536, 0.013408028603510536, 0.10327018645262287, 0.10327018645262287, 0.10327018645262287, 0.1136781389111109, 0.1136781389111109, 0.1136781389111109, 0.12044522158568494, 0.12044522158568494, 0.12044522158568494, 0.1202534627865891, 0.1202534627865891, 0.1202534627865891, 0.1594869812365045, 0.1594869812365045, 0.1594869812365045, 0.12615897421104527, 0.12615897421104527, 0.12615897421104527, 0.06051721403456922, 0.06051721403456922, 0.06051721403456922, 0.07070556131372574, 0.07070556131372574, 0.07070556131372574, 0.0837317855149382, 0.0837317855149382, 0.0837317855149382, 0.14133560604167683, 0.14133560604167683, 0.14133560604167683, 0.12016661343050072, 0.12016661343050072, 0.12016661343050072, 0.12245976138762271, 0.12245976138762271, 0.12245976138762271, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04723513911385069, 0.04723513911385069, 0.04723513911385069, 0.08288743374568608, 0.08288743374568608, 0.08288743374568608, 0.09029808364849545, 0.09029808364849545, 0.09029808364849545, 0.1070176662487543, 0.1070176662487543, 0.1070176662487543, 0.11040265245322212, 0.11040265245322212, 0.11040265245322212, 0.05086723631024437, 0.05086723631024437, 0.05086723631024437, 0.06487976636862025, 0.06487976636862025, 0.06487976636862025, 0.15235701807183122, 0.15235701807183122, 0.15235701807183122, 0.16623741747691567, 0.16623741747691567, 0.16623741747691567, 0.1500413474630533, 0.1500413474630533, 0.1500413474630533, 0.012092520191867129, 0.012092520191867129, 0.012092520191867129, 0.04343550213824843, 0.04343550213824843, 0.04343550213824843, 0.0305185778197945, 0.0305185778197945, 0.0305185778197945]}, "mutation_prompt": null}
{"id": "db77c267-c787-4c0a-b3d2-34657471fd5f", "solution": "import numpy as np\n\nclass GenAMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.mutation_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        # Initialize particles' positions and velocities\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        # Evaluate initial positions\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            # Dynamically adjust swarms based on performance\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                # Update velocities and positions with elitist approach\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    # Introduce mutation for enhanced exploration\n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 1, self.dim)\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            # Merge the best performing swarms and update global best\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "GenAMSPSO", "description": "A genetically enhanced adaptive multi-swarm particle swarm optimization with mutation-induced exploration, adaptive velocity clamping, and dynamic swarm merging for improved convergence.", "configspace": "", "generation": 10, "fitness": 0.10615862512569661, "feedback": "The algorithm GenAMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.08.", "error": "", "parent_id": "a6a8b877-26fe-4c1c-9a0b-544a637295bb", "metadata": {"aucs": [0.22570420537748637, 0.22570420537748637, 0.22570420537748637, 0.18041236129195037, 0.18041236129195037, 0.18041236129195037, 0.21563659913443733, 0.21563659913443733, 0.21563659913443733, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051967082085959015, 0.051967082085959015, 0.051967082085959015, 0.06261668379070184, 0.06261668379070184, 0.06261668379070184, 0.06542465363618322, 0.06542465363618322, 0.06542465363618322, 0.04395237489262904, 0.04395237489262904, 0.04395237489262904, 0.051932171170844366, 0.051932171170844366, 0.051932171170844366, 0.06259557341968591, 0.06259557341968591, 0.06259557341968591, 0.08094850548629495, 0.08094850548629495, 0.08094850548629495, 0.08081528011606931, 0.08081528011606931, 0.08081528011606931, 0.08850721239007486, 0.08850721239007486, 0.08850721239007486, 0.10714294356983645, 0.10714294356983645, 0.10714294356983645, 0.10171334050984493, 0.10171334050984493, 0.10171334050984493, 0.09184512984488413, 0.09184512984488413, 0.09184512984488413, 0.17434060196355672, 0.17434060196355672, 0.17434060196355672, 0.1603449084282862, 0.1603449084282862, 0.1603449084282862, 0.1383046120091056, 0.1383046120091056, 0.1383046120091056, 0.03216572956932706, 0.03216572956932706, 0.03216572956932706, 0.017066083916811303, 0.017066083916811303, 0.017066083916811303, 0.006617885193810236, 0.006617885193810236, 0.006617885193810236, 0.035062096084373606, 0.035062096084373606, 0.035062096084373606, 0.060064551086057905, 0.060064551086057905, 0.060064551086057905, 0.10054323470412874, 0.10054323470412874, 0.10054323470412874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07820071368289505, 0.07820071368289505, 0.07820071368289505, 0.03956387140210904, 0.03956387140210904, 0.03956387140210904, 0.07548939482250827, 0.07548939482250827, 0.07548939482250827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00016853448505649293, 0.00016853448505649293, 0.00016853448505649293, 0.23192867852558952, 0.23192867852558952, 0.23192867852558952, 0.19809057001248853, 0.19809057001248853, 0.19809057001248853, 0.2324228201992855, 0.2324228201992855, 0.2324228201992855, 0.042816767295592584, 0.042816767295592584, 0.042816767295592584, 0.05484045952868688, 0.05484045952868688, 0.05484045952868688, 0.05911691056722701, 0.05911691056722701, 0.05911691056722701, 0.1162758833521691, 0.1162758833521691, 0.1162758833521691, 0.1099444834505846, 0.1099444834505846, 0.1099444834505846, 0.11508289553791495, 0.11508289553791495, 0.11508289553791495, 0.17422109912598205, 0.17422109912598205, 0.17422109912598205, 0.18797307341563918, 0.18797307341563918, 0.18797307341563918, 0.17482585177965904, 0.17482585177965904, 0.17482585177965904, 0.14465587220741805, 0.14465587220741805, 0.14465587220741805, 0.13377199461315326, 0.13377199461315326, 0.13377199461315326, 0.13817592328055872, 0.13817592328055872, 0.13817592328055872, 0.17355345759152319, 0.17355345759152319, 0.17355345759152319, 0.20194487591542643, 0.20194487591542643, 0.20194487591542643, 0.21762062198693088, 0.21762062198693088, 0.21762062198693088, 0.16808660524968855, 0.16808660524968855, 0.16808660524968855, 0.16173773058632068, 0.16173773058632068, 0.16173773058632068, 0.16156501408659496, 0.16156501408659496, 0.16156501408659496, 0.1670966412058862, 0.1670966412058862, 0.1670966412058862, 0.2172983480662748, 0.2172983480662748, 0.2172983480662748, 0.23712092660352657, 0.23712092660352657, 0.23712092660352657, 0.24768598437289324, 0.24768598437289324, 0.24768598437289324, 0.24365220760729234, 0.24365220760729234, 0.24365220760729234, 0.14362553782253074, 0.14362553782253074, 0.14362553782253074, 0.1813067170528183, 0.1813067170528183, 0.1813067170528183, 0.17767746309927912, 0.17767746309927912, 0.17767746309927912, 0.2067196545116865, 0.2067196545116865, 0.2067196545116865, 0.0620896391877126, 0.0620896391877126, 0.0620896391877126, 0.0684918598758335, 0.0684918598758335, 0.0684918598758335, 0.06175810727108033, 0.06175810727108033, 0.06175810727108033]}, "mutation_prompt": null}
{"id": "9fdcff5d-9998-4505-8618-4351e7f8d721", "solution": "import numpy as np\n\nclass EnhancedAMSPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6\n        self.cognitive = 1.7\n        self.social = 1.8\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.1\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, 0.5, self.dim)\n                    \n                    positions[particle_idx] += velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedAMSPSO", "description": "A mutation-enhanced adaptive multi-swarm particle swarm optimization with velocity control, dynamic swarm merging, and sporadic position perturbation for robust convergence.", "configspace": "", "generation": 11, "fitness": 0.10495375723277066, "feedback": "The algorithm EnhancedAMSPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.08.", "error": "", "parent_id": "db77c267-c787-4c0a-b3d2-34657471fd5f", "metadata": {"aucs": [0.28684585867944634, 0.28684585867944634, 0.28684585867944634, 0.14776848006905108, 0.14776848006905108, 0.14776848006905108, 0.15671544456035447, 0.15671544456035447, 0.15671544456035447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06270625906398852, 0.06270625906398852, 0.06270625906398852, 0.07821937196153517, 0.07821937196153517, 0.07821937196153517, 0.06072442428795599, 0.06072442428795599, 0.06072442428795599, 0.05290604146235489, 0.05290604146235489, 0.05290604146235489, 0.06461661046905032, 0.06461661046905032, 0.06461661046905032, 0.04531597926415021, 0.04531597926415021, 0.04531597926415021, 0.05191730802007, 0.05191730802007, 0.05191730802007, 0.05935311950325761, 0.05935311950325761, 0.05935311950325761, 0.06766409912659288, 0.06766409912659288, 0.06766409912659288, 0.09698484122024364, 0.09698484122024364, 0.09698484122024364, 0.08944874481439546, 0.08944874481439546, 0.08944874481439546, 0.09648129715812304, 0.09648129715812304, 0.09648129715812304, 0.18177144620590957, 0.18177144620590957, 0.18177144620590957, 0.13033380473033795, 0.13033380473033795, 0.13033380473033795, 0.0992336345467949, 0.0992336345467949, 0.0992336345467949, 0.052127456516402715, 0.052127456516402715, 0.052127456516402715, 0.006692646680921621, 0.006692646680921621, 0.006692646680921621, 0.03157196390045103, 0.03157196390045103, 0.03157196390045103, 0.09775485060177747, 0.09775485060177747, 0.09775485060177747, 0.08153314176712956, 0.08153314176712956, 0.08153314176712956, 0.0741303313384134, 0.0741303313384134, 0.0741303313384134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08624147220477285, 0.08624147220477285, 0.08624147220477285, 0.0325101114458235, 0.0325101114458235, 0.0325101114458235, 0.06526133369254006, 0.06526133369254006, 0.06526133369254006, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019595204179348236, 0.019595204179348236, 0.019595204179348236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.23340760283587236, 0.23340760283587236, 0.23340760283587236, 0.18132493227303126, 0.18132493227303126, 0.18132493227303126, 0.23154548287258303, 0.23154548287258303, 0.23154548287258303, 0.028467034853594808, 0.028467034853594808, 0.028467034853594808, 0.056411690292235694, 0.056411690292235694, 0.056411690292235694, 0.05833328936639559, 0.05833328936639559, 0.05833328936639559, 0.14748284128333622, 0.14748284128333622, 0.14748284128333622, 0.10539736519449983, 0.10539736519449983, 0.10539736519449983, 0.12090625889151574, 0.12090625889151574, 0.12090625889151574, 0.1492678341143594, 0.1492678341143594, 0.1492678341143594, 0.19103671593827765, 0.19103671593827765, 0.19103671593827765, 0.1595068830331573, 0.1595068830331573, 0.1595068830331573, 0.10940464647678072, 0.10940464647678072, 0.10940464647678072, 0.14569468544059438, 0.14569468544059438, 0.14569468544059438, 0.09624184746570286, 0.09624184746570286, 0.09624184746570286, 0.1923293625362683, 0.1923293625362683, 0.1923293625362683, 0.19155025714907392, 0.19155025714907392, 0.19155025714907392, 0.22398269099897272, 0.22398269099897272, 0.22398269099897272, 0.1558846321373567, 0.1558846321373567, 0.1558846321373567, 0.15844483710844137, 0.15844483710844137, 0.15844483710844137, 0.16639368096602358, 0.16639368096602358, 0.16639368096602358, 0.16265035597972965, 0.16265035597972965, 0.16265035597972965, 0.2645735434059546, 0.2645735434059546, 0.2645735434059546, 0.1936629043177176, 0.1936629043177176, 0.1936629043177176, 0.2688251786635235, 0.2688251786635235, 0.2688251786635235, 0.28911199089153816, 0.28911199089153816, 0.28911199089153816, 0.16608131720563157, 0.16608131720563157, 0.16608131720563157, 0.18410344133004863, 0.18410344133004863, 0.18410344133004863, 0.16947886596849981, 0.16947886596849981, 0.16947886596849981, 0.16457376991758632, 0.16457376991758632, 0.16457376991758632, 0.06572452604401624, 0.06572452604401624, 0.06572452604401624, 0.06991019125300313, 0.06991019125300313, 0.06991019125300313, 0.07743458708297168, 0.07743458708297168, 0.07743458708297168]}, "mutation_prompt": null}
{"id": "6bf8cb03-ee82-4602-8971-e9f17e032dd1", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.num_swarms = 6\n        self.inertia = 0.6\n        self.cognitive = 2.0\n        self.social = 1.5\n        self.learning_rate = 0.01\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.1\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        velocities[particle_idx] += np.random.normal(0, self.learning_rate, self.dim)\n                        \n                    positions[particle_idx] = positions[particle_idx] + velocities[particle_idx]\n                    positions[particle_idx] = np.clip(positions[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "HybridAdaptiveSwarmOptimizer", "description": "A hybrid adaptive swarm optimizer incorporating dynamic learning rates and stochastic convergence enhancement for improved performance across diverse optimization scenarios.", "configspace": "", "generation": 12, "fitness": 0.09873217737508261, "feedback": "The algorithm HybridAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.08.", "error": "", "parent_id": "db77c267-c787-4c0a-b3d2-34657471fd5f", "metadata": {"aucs": [0.2334877547381441, 0.2334877547381441, 0.2334877547381441, 0.11576910040776511, 0.11576910040776511, 0.11576910040776511, 0.2068399773260613, 0.2068399773260613, 0.2068399773260613, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04074886815096612, 0.04074886815096612, 0.04074886815096612, 0.057151974421294494, 0.057151974421294494, 0.057151974421294494, 0.05070946667302889, 0.05070946667302889, 0.05070946667302889, 0.04495184453836487, 0.04495184453836487, 0.04495184453836487, 0.06365436839922989, 0.06365436839922989, 0.06365436839922989, 0.04865216491773372, 0.04865216491773372, 0.04865216491773372, 0.04646900644808105, 0.04646900644808105, 0.04646900644808105, 0.05553305414967924, 0.05553305414967924, 0.05553305414967924, 0.07059572542624659, 0.07059572542624659, 0.07059572542624659, 0.08191627825648806, 0.08191627825648806, 0.08191627825648806, 0.10036794906379387, 0.10036794906379387, 0.10036794906379387, 0.06069811200931452, 0.06069811200931452, 0.06069811200931452, 0.17674704675517638, 0.17674704675517638, 0.17674704675517638, 0.08446070692447616, 0.08446070692447616, 0.08446070692447616, 0.09213425064828518, 0.09213425064828518, 0.09213425064828518, 0.044297001997124386, 0.044297001997124386, 0.044297001997124386, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03842244031745834, 0.03842244031745834, 0.03842244031745834, 0.0848889049097723, 0.0848889049097723, 0.0848889049097723, 0.07704393639904661, 0.07704393639904661, 0.07704393639904661, 0.064344577459307, 0.064344577459307, 0.064344577459307, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06146047969956925, 0.06146047969956925, 0.06146047969956925, 0.02497828512344835, 0.02497828512344835, 0.02497828512344835, 0.05824440880458859, 0.05824440880458859, 0.05824440880458859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.21744890512948845, 0.21744890512948845, 0.21744890512948845, 0.17667473183474847, 0.17667473183474847, 0.17667473183474847, 0.24425511171589553, 0.24425511171589553, 0.24425511171589553, 0.015985342931520985, 0.015985342931520985, 0.015985342931520985, 0.08042448866067375, 0.08042448866067375, 0.08042448866067375, 0.06348432765106404, 0.06348432765106404, 0.06348432765106404, 0.1271069723951086, 0.1271069723951086, 0.1271069723951086, 0.12876567899711322, 0.12876567899711322, 0.12876567899711322, 0.12467952931724735, 0.12467952931724735, 0.12467952931724735, 0.16080390920018894, 0.16080390920018894, 0.16080390920018894, 0.194669854298965, 0.194669854298965, 0.194669854298965, 0.15388631756782856, 0.15388631756782856, 0.15388631756782856, 0.12216308923484698, 0.12216308923484698, 0.12216308923484698, 0.1339641346548437, 0.1339641346548437, 0.1339641346548437, 0.09112405515172972, 0.09112405515172972, 0.09112405515172972, 0.2129366929708042, 0.2129366929708042, 0.2129366929708042, 0.1843187738129387, 0.1843187738129387, 0.1843187738129387, 0.23569351733054933, 0.23569351733054933, 0.23569351733054933, 0.15528428990081133, 0.15528428990081133, 0.15528428990081133, 0.1586731327081845, 0.1586731327081845, 0.1586731327081845, 0.15789680084849367, 0.15789680084849367, 0.15789680084849367, 0.15989677914853362, 0.15989677914853362, 0.15989677914853362, 0.25753416993724343, 0.25753416993724343, 0.25753416993724343, 0.2122013349917543, 0.2122013349917543, 0.2122013349917543, 0.21890537734598348, 0.21890537734598348, 0.21890537734598348, 0.1486202353514915, 0.1486202353514915, 0.1486202353514915, 0.166435380026006, 0.166435380026006, 0.166435380026006, 0.16238258911965842, 0.16238258911965842, 0.16238258911965842, 0.1784617274492959, 0.1784617274492959, 0.1784617274492959, 0.18905756763309778, 0.18905756763309778, 0.18905756763309778, 0.06779120227582058, 0.06779120227582058, 0.06779120227582058, 0.061089072981776904, 0.061089072981776904, 0.061089072981776904, 0.06023399446779654, 0.06023399446779654, 0.06023399446779654]}, "mutation_prompt": null}
{"id": "bf79b861-0962-467e-a184-23004899604e", "solution": "import numpy as np\n\nclass HybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.mutation_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.7\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "HybridSwarmDE", "description": "A hybrid swarm optimization enhanced with differential evolution and adaptive inertia for improved exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.14522395889148187, "feedback": "The algorithm HybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "db77c267-c787-4c0a-b3d2-34657471fd5f", "metadata": {"aucs": [0.2317876116033203, 0.2317876116033203, 0.2317876116033203, 0.2314460840655027, 0.2314460840655027, 0.2314460840655027, 0.23450015358322873, 0.23450015358322873, 0.23450015358322873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07884943886156048, 0.07884943886156048, 0.07884943886156048, 0.07731089995179241, 0.07731089995179241, 0.07731089995179241, 0.0738369730937406, 0.0738369730937406, 0.0738369730937406, 0.06030644711526967, 0.06030644711526967, 0.06030644711526967, 0.061508424003005935, 0.061508424003005935, 0.061508424003005935, 0.05391240566313005, 0.05391240566313005, 0.05391240566313005, 0.7224972330520433, 0.7224972330520433, 0.7224972330520433, 0.8215954107726677, 0.8215954107726677, 0.8215954107726677, 0.858066550671311, 0.858066550671311, 0.858066550671311, 0.1105538614954068, 0.1105538614954068, 0.1105538614954068, 0.10367212355581545, 0.10367212355581545, 0.10367212355581545, 0.12085641518161916, 0.12085641518161916, 0.12085641518161916, 0.17864519816064783, 0.17864519816064783, 0.17864519816064783, 0.1891075351264423, 0.1891075351264423, 0.1891075351264423, 0.14012191784804506, 0.14012191784804506, 0.14012191784804506, 0.05900822066336242, 0.05900822066336242, 0.05900822066336242, 0.07191132872432482, 0.07191132872432482, 0.07191132872432482, 0.07577089764880252, 0.07577089764880252, 0.07577089764880252, 0.07252358743227161, 0.07252358743227161, 0.07252358743227161, 0.047008348050496696, 0.047008348050496696, 0.047008348050496696, 0.05947355822247247, 0.05947355822247247, 0.05947355822247247, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08434004437073395, 0.08434004437073395, 0.08434004437073395, 0.06350594286657452, 0.06350594286657452, 0.06350594286657452, 0.1088455392433112, 0.1088455392433112, 0.1088455392433112, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008879422293389005, 0.008879422293389005, 0.008879422293389005, 0.007101389660259194, 0.007101389660259194, 0.007101389660259194, 0.011732090956683927, 0.011732090956683927, 0.011732090956683927, 0.29003073851540506, 0.29003073851540506, 0.29003073851540506, 0.25715537641957986, 0.25715537641957986, 0.25715537641957986, 0.25162416032765444, 0.25162416032765444, 0.25162416032765444, 0.059366164075421834, 0.059366164075421834, 0.059366164075421834, 0.07662252462270203, 0.07662252462270203, 0.07662252462270203, 0.06984230358016141, 0.06984230358016141, 0.06984230358016141, 0.1242002488776357, 0.1242002488776357, 0.1242002488776357, 0.13495814441941678, 0.13495814441941678, 0.13495814441941678, 0.12561031538748413, 0.12561031538748413, 0.12561031538748413, 0.18991352648133064, 0.18991352648133064, 0.18991352648133064, 0.18614234211914182, 0.18614234211914182, 0.18614234211914182, 0.19799161309497315, 0.19799161309497315, 0.19799161309497315, 0.13474354583233616, 0.13474354583233616, 0.13474354583233616, 0.14059627543859843, 0.14059627543859843, 0.14059627543859843, 0.13248162854128676, 0.13248162854128676, 0.13248162854128676, 0.20032255298304302, 0.20032255298304302, 0.20032255298304302, 0.18835194417808443, 0.18835194417808443, 0.18835194417808443, 0.18439308511282748, 0.18439308511282748, 0.18439308511282748, 0.1761601620812009, 0.1761601620812009, 0.1761601620812009, 0.16647724897380523, 0.16647724897380523, 0.16647724897380523, 0.16263109577174906, 0.16263109577174906, 0.16263109577174906, 0.16521463061945763, 0.16521463061945763, 0.16521463061945763, 0.2563434171243282, 0.2563434171243282, 0.2563434171243282, 0.21634897347362936, 0.21634897347362936, 0.21634897347362936, 0.24631437453839466, 0.24631437453839466, 0.24631437453839466, 0.21794628002281646, 0.21794628002281646, 0.21794628002281646, 0.13229230911980394, 0.13229230911980394, 0.13229230911980394, 0.18753502092081642, 0.18753502092081642, 0.18753502092081642, 0.17486602328881673, 0.17486602328881673, 0.17486602328881673, 0.16773750958638267, 0.16773750958638267, 0.16773750958638267, 0.08035091862168864, 0.08035091862168864, 0.08035091862168864, 0.06579400156334303, 0.06579400156334303, 0.06579400156334303, 0.07619153053614713, 0.07619153053614713, 0.07619153053614713]}, "mutation_prompt": null}
{"id": "80aefb27-ccc4-4411-88d4-5405ab7fb9b9", "solution": "import numpy as np\n\nclass DynamicHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.num_swarms = 7\n        self.inertia = 0.6\n        self.cognitive = 1.7\n        self.social = 2.1\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "DynamicHybridSwarm", "description": "An enhanced hybrid swarm optimization using dynamic swarm adjustment and targeted mutation for better global search and convergence.", "configspace": "", "generation": 14, "fitness": 0.13492778069395597, "feedback": "The algorithm DynamicHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.16.", "error": "", "parent_id": "bf79b861-0962-467e-a184-23004899604e", "metadata": {"aucs": [0.21230644752850758, 0.21230644752850758, 0.21230644752850758, 0.19425336926365766, 0.19425336926365766, 0.19425336926365766, 0.192841351097494, 0.192841351097494, 0.192841351097494, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06071758759369772, 0.06071758759369772, 0.06071758759369772, 0.062063067511127556, 0.062063067511127556, 0.062063067511127556, 0.07059881485034725, 0.07059881485034725, 0.07059881485034725, 0.030645695673744422, 0.030645695673744422, 0.030645695673744422, 0.04121135713442492, 0.04121135713442492, 0.04121135713442492, 0.04652813603427697, 0.04652813603427697, 0.04652813603427697, 0.8314994065833398, 0.8314994065833398, 0.8314994065833398, 0.8060449503892438, 0.8060449503892438, 0.8060449503892438, 0.8523351851637591, 0.8523351851637591, 0.8523351851637591, 0.12529287438239678, 0.12529287438239678, 0.12529287438239678, 0.0841379520883776, 0.0841379520883776, 0.0841379520883776, 0.09736285754681451, 0.09736285754681451, 0.09736285754681451, 0.14708006141150576, 0.14708006141150576, 0.14708006141150576, 0.1484506000556567, 0.1484506000556567, 0.1484506000556567, 0.14753484567094877, 0.14753484567094877, 0.14753484567094877, 0.041612799797021593, 0.041612799797021593, 0.041612799797021593, 0.04850571994503994, 0.04850571994503994, 0.04850571994503994, 0.06030228320270814, 0.06030228320270814, 0.06030228320270814, 0.032373409078072624, 0.032373409078072624, 0.032373409078072624, 0.013356353493805928, 0.013356353493805928, 0.013356353493805928, 0.017562784762930606, 0.017562784762930606, 0.017562784762930606, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10971975815097756, 0.10971975815097756, 0.10971975815097756, 0.043191537551805936, 0.043191537551805936, 0.043191537551805936, 0.1405750592597158, 0.1405750592597158, 0.1405750592597158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010116881705462988, 0.010116881705462988, 0.010116881705462988, 0.27961133282392325, 0.27961133282392325, 0.27961133282392325, 0.22917200447217223, 0.22917200447217223, 0.22917200447217223, 0.23787795249436416, 0.23787795249436416, 0.23787795249436416, 0.06041818369514729, 0.06041818369514729, 0.06041818369514729, 0.06760969514823278, 0.06760969514823278, 0.06760969514823278, 0.05812492220976473, 0.05812492220976473, 0.05812492220976473, 0.138207953611986, 0.138207953611986, 0.138207953611986, 0.13895038879653343, 0.13895038879653343, 0.13895038879653343, 0.13711725227798144, 0.13711725227798144, 0.13711725227798144, 0.18832705433440822, 0.18832705433440822, 0.18832705433440822, 0.17854616713791316, 0.17854616713791316, 0.17854616713791316, 0.17971527375589103, 0.17971527375589103, 0.17971527375589103, 0.13310528853318626, 0.13310528853318626, 0.13310528853318626, 0.12424752758175106, 0.12424752758175106, 0.12424752758175106, 0.1254677761243942, 0.1254677761243942, 0.1254677761243942, 0.15969239709407634, 0.15969239709407634, 0.15969239709407634, 0.1810077019804336, 0.1810077019804336, 0.1810077019804336, 0.17787643744257697, 0.17787643744257697, 0.17787643744257697, 0.16114980079824692, 0.16114980079824692, 0.16114980079824692, 0.1613987098865246, 0.1613987098865246, 0.1613987098865246, 0.1588976208905255, 0.1588976208905255, 0.1588976208905255, 0.16826780895518478, 0.16826780895518478, 0.16826780895518478, 0.19121650594104156, 0.19121650594104156, 0.19121650594104156, 0.1807933142980368, 0.1807933142980368, 0.1807933142980368, 0.18493092393653632, 0.18493092393653632, 0.18493092393653632, 0.17764373728267346, 0.17764373728267346, 0.17764373728267346, 0.15815608505411638, 0.15815608505411638, 0.15815608505411638, 0.16819241719360667, 0.16819241719360667, 0.16819241719360667, 0.17347436962117624, 0.17347436962117624, 0.17347436962117624, 0.1760092493917027, 0.1760092493917027, 0.1760092493917027, 0.05918125900650628, 0.05918125900650628, 0.05918125900650628, 0.0711688743131339, 0.0711688743131339, 0.0711688743131339, 0.05992307695422061, 0.05992307695422061, 0.05992307695422061]}, "mutation_prompt": null}
{"id": "4a8769d4-a693-4e4a-bf67-c4742d2a6756", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6\n        self.cognitive = 1.8\n        self.social = 1.9\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.75\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedHybridSwarmDE", "description": "An enhanced hybrid swarm algorithm with differential evolution employing adaptive learning rates for optimized exploration and faster convergence.", "configspace": "", "generation": 15, "fitness": 0.15000601314341402, "feedback": "The algorithm EnhancedHybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.14.", "error": "", "parent_id": "bf79b861-0962-467e-a184-23004899604e", "metadata": {"aucs": [0.2743989965624233, 0.2743989965624233, 0.2743989965624233, 0.2353850695627786, 0.2353850695627786, 0.2353850695627786, 0.292986785113325, 0.292986785113325, 0.292986785113325, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08109169167850483, 0.08109169167850483, 0.08109169167850483, 0.07680509719632533, 0.07680509719632533, 0.07680509719632533, 0.0704026197806914, 0.0704026197806914, 0.0704026197806914, 0.06085369920107464, 0.06085369920107464, 0.06085369920107464, 0.06929763594229155, 0.06929763594229155, 0.06929763594229155, 0.06533113408392888, 0.06533113408392888, 0.06533113408392888, 0.651966090940998, 0.651966090940998, 0.651966090940998, 0.6487303452188131, 0.6487303452188131, 0.6487303452188131, 0.6659365647049714, 0.6659365647049714, 0.6659365647049714, 0.1419894127645943, 0.1419894127645943, 0.1419894127645943, 0.11123502434877208, 0.11123502434877208, 0.11123502434877208, 0.1229233319154136, 0.1229233319154136, 0.1229233319154136, 0.19475410382878688, 0.19475410382878688, 0.19475410382878688, 0.1779830681792286, 0.1779830681792286, 0.1779830681792286, 0.16771096884729542, 0.16771096884729542, 0.16771096884729542, 0.08264082736668876, 0.08264082736668876, 0.08264082736668876, 0.08567131143801143, 0.08567131143801143, 0.08567131143801143, 0.08645705858060337, 0.08645705858060337, 0.08645705858060337, 0.08479089547856455, 0.08479089547856455, 0.08479089547856455, 0.08457797720320792, 0.08457797720320792, 0.08457797720320792, 0.07998535543638718, 0.07998535543638718, 0.07998535543638718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08539242963412308, 0.08539242963412308, 0.08539242963412308, 0.06078645100415547, 0.06078645100415547, 0.06078645100415547, 0.12227943900313354, 0.12227943900313354, 0.12227943900313354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03073894237923669, 0.03073894237923669, 0.03073894237923669, 0.013656881239085705, 0.013656881239085705, 0.013656881239085705, 0.03819557805854634, 0.03819557805854634, 0.03819557805854634, 0.2764409152476637, 0.2764409152476637, 0.2764409152476637, 0.3074036067456133, 0.3074036067456133, 0.3074036067456133, 0.2999579848977252, 0.2999579848977252, 0.2999579848977252, 0.0687247287390812, 0.0687247287390812, 0.0687247287390812, 0.06983458812398546, 0.06983458812398546, 0.06983458812398546, 0.09360773164333946, 0.09360773164333946, 0.09360773164333946, 0.12657763331131477, 0.12657763331131477, 0.12657763331131477, 0.11108563866760579, 0.11108563866760579, 0.11108563866760579, 0.14497517875713906, 0.14497517875713906, 0.14497517875713906, 0.2031035130834512, 0.2031035130834512, 0.2031035130834512, 0.21153606747446807, 0.21153606747446807, 0.21153606747446807, 0.18941133432954538, 0.18941133432954538, 0.18941133432954538, 0.15581651364547067, 0.15581651364547067, 0.15581651364547067, 0.146706081827357, 0.146706081827357, 0.146706081827357, 0.13720701858943507, 0.13720701858943507, 0.13720701858943507, 0.2074456824220854, 0.2074456824220854, 0.2074456824220854, 0.1962114288094592, 0.1962114288094592, 0.1962114288094592, 0.19567822756631026, 0.19567822756631026, 0.19567822756631026, 0.16684008848425402, 0.16684008848425402, 0.16684008848425402, 0.17843802590941993, 0.17843802590941993, 0.17843802590941993, 0.16214474029054105, 0.16214474029054105, 0.16214474029054105, 0.1709094648655166, 0.1709094648655166, 0.1709094648655166, 0.2965723111319666, 0.2965723111319666, 0.2965723111319666, 0.26658682901613384, 0.26658682901613384, 0.26658682901613384, 0.3004130722020333, 0.3004130722020333, 0.3004130722020333, 0.22801930696095007, 0.22801930696095007, 0.22801930696095007, 0.17277729375423279, 0.17277729375423279, 0.17277729375423279, 0.17990510881698496, 0.17990510881698496, 0.17990510881698496, 0.17738417544580576, 0.17738417544580576, 0.17738417544580576, 0.1823032735386979, 0.1823032735386979, 0.1823032735386979, 0.06737163786134315, 0.06737163786134315, 0.06737163786134315, 0.07166404580384877, 0.07166404580384877, 0.07166404580384877, 0.07152491167107122, 0.07152491167107122, 0.07152491167107122]}, "mutation_prompt": null}
{"id": "98395e62-cc70-4678-a2d9-36475cc030e5", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6\n        self.cognitive = 1.8\n        self.social = 1.9\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.75\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedHybridSwarmDE", "description": "An enhanced hybrid swarm algorithm with differential evolution employing adaptive learning rates for optimized exploration and faster convergence.", "configspace": "", "generation": 16, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4a8769d4-a693-4e4a-bf67-c4742d2a6756", "metadata": {"aucs": [0.2743989965624233, 0.2743989965624233, 0.2743989965624233, 0.2353850695627786, 0.2353850695627786, 0.2353850695627786, 0.292986785113325, 0.292986785113325, 0.292986785113325, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08109169167850483, 0.08109169167850483, 0.08109169167850483, 0.07680509719632533, 0.07680509719632533, 0.07680509719632533, 0.0704026197806914, 0.0704026197806914, 0.0704026197806914, 0.06085369920107464, 0.06085369920107464, 0.06085369920107464, 0.06929763594229155, 0.06929763594229155, 0.06929763594229155, 0.06533113408392888, 0.06533113408392888, 0.06533113408392888, 0.651966090940998, 0.651966090940998, 0.651966090940998, 0.6487303452188131, 0.6487303452188131, 0.6487303452188131, 0.6659365647049714, 0.6659365647049714, 0.6659365647049714, 0.1419894127645943, 0.1419894127645943, 0.1419894127645943, 0.11123502434877208, 0.11123502434877208, 0.11123502434877208, 0.1229233319154136, 0.1229233319154136, 0.1229233319154136, 0.19475410382878688, 0.19475410382878688, 0.19475410382878688, 0.1779830681792286, 0.1779830681792286, 0.1779830681792286, 0.16771096884729542, 0.16771096884729542, 0.16771096884729542, 0.08264082736668876, 0.08264082736668876, 0.08264082736668876, 0.08567131143801143, 0.08567131143801143, 0.08567131143801143, 0.08645705858060337, 0.08645705858060337, 0.08645705858060337, 0.08479089547856455, 0.08479089547856455, 0.08479089547856455, 0.08457797720320792, 0.08457797720320792, 0.08457797720320792, 0.07998535543638718, 0.07998535543638718, 0.07998535543638718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08539242963412308, 0.08539242963412308, 0.08539242963412308, 0.06078645100415547, 0.06078645100415547, 0.06078645100415547, 0.12227943900313354, 0.12227943900313354, 0.12227943900313354, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03073894237923669, 0.03073894237923669, 0.03073894237923669, 0.013656881239085705, 0.013656881239085705, 0.013656881239085705, 0.03819557805854634, 0.03819557805854634, 0.03819557805854634, 0.2764409152476637, 0.2764409152476637, 0.2764409152476637, 0.3074036067456133, 0.3074036067456133, 0.3074036067456133, 0.2999579848977252, 0.2999579848977252, 0.2999579848977252, 0.0687247287390812, 0.0687247287390812, 0.0687247287390812, 0.06983458812398546, 0.06983458812398546, 0.06983458812398546, 0.09360773164333946, 0.09360773164333946, 0.09360773164333946, 0.12657763331131477, 0.12657763331131477, 0.12657763331131477, 0.11108563866760579, 0.11108563866760579, 0.11108563866760579, 0.14497517875713906, 0.14497517875713906, 0.14497517875713906, 0.2031035130834512, 0.2031035130834512, 0.2031035130834512, 0.21153606747446807, 0.21153606747446807, 0.21153606747446807, 0.18941133432954538, 0.18941133432954538, 0.18941133432954538, 0.15581651364547067, 0.15581651364547067, 0.15581651364547067, 0.146706081827357, 0.146706081827357, 0.146706081827357, 0.13720701858943507, 0.13720701858943507, 0.13720701858943507, 0.2074456824220854, 0.2074456824220854, 0.2074456824220854, 0.1962114288094592, 0.1962114288094592, 0.1962114288094592, 0.19567822756631026, 0.19567822756631026, 0.19567822756631026, 0.16684008848425402, 0.16684008848425402, 0.16684008848425402, 0.17843802590941993, 0.17843802590941993, 0.17843802590941993, 0.16214474029054105, 0.16214474029054105, 0.16214474029054105, 0.1709094648655166, 0.1709094648655166, 0.1709094648655166, 0.2965723111319666, 0.2965723111319666, 0.2965723111319666, 0.26658682901613384, 0.26658682901613384, 0.26658682901613384, 0.3004130722020333, 0.3004130722020333, 0.3004130722020333, 0.22801930696095007, 0.22801930696095007, 0.22801930696095007, 0.17277729375423279, 0.17277729375423279, 0.17277729375423279, 0.17990510881698496, 0.17990510881698496, 0.17990510881698496, 0.17738417544580576, 0.17738417544580576, 0.17738417544580576, 0.1823032735386979, 0.1823032735386979, 0.1823032735386979, 0.06737163786134315, 0.06737163786134315, 0.06737163786134315, 0.07166404580384877, 0.07166404580384877, 0.07166404580384877, 0.07152491167107122, 0.07152491167107122, 0.07152491167107122]}, "mutation_prompt": null}
{"id": "c95f7c26-5a2e-4e04-9df8-834844345968", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6\n        self.cognitive = 1.8\n        self.social = 1.9\n        self.mutation_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.75\n        \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    if eval_count >= self.budget:\n                        break\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    adaptive_cognitive = self.cognitive * (1 - (eval_count / self.budget))\n                    adaptive_social = self.social * (eval_count / self.budget)\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        adaptive_cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        adaptive_social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                if eval_count >= self.budget:\n                    break\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedHybridSwarmDE", "description": "An enhanced hybrid swarm algorithm with differential evolution using dynamic social and cognitive factors for adaptive exploration and convergence.", "configspace": "", "generation": 17, "fitness": 0.13320493287388768, "feedback": "The algorithm EnhancedHybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.10.", "error": "", "parent_id": "4a8769d4-a693-4e4a-bf67-c4742d2a6756", "metadata": {"aucs": [0.24275939708423944, 0.24275939708423944, 0.24275939708423944, 0.21705634258875262, 0.21705634258875262, 0.21705634258875262, 0.23689398475041756, 0.23689398475041756, 0.23689398475041756, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07257472797579434, 0.07257472797579434, 0.07257472797579434, 0.07376330005529486, 0.07376330005529486, 0.07376330005529486, 0.07893626717854607, 0.07893626717854607, 0.07893626717854607, 0.05218753913171714, 0.05218753913171714, 0.05218753913171714, 0.058151119910142546, 0.058151119910142546, 0.058151119910142546, 0.05418062574129312, 0.05418062574129312, 0.05418062574129312, 0.45090198621893074, 0.45090198621893074, 0.45090198621893074, 0.48196317318242377, 0.48196317318242377, 0.48196317318242377, 0.41943042804406305, 0.41943042804406305, 0.41943042804406305, 0.11578686556730244, 0.11578686556730244, 0.11578686556730244, 0.10322643460128589, 0.10322643460128589, 0.10322643460128589, 0.11076443137034075, 0.11076443137034075, 0.11076443137034075, 0.17970339976250138, 0.17970339976250138, 0.17970339976250138, 0.1793367111160986, 0.1793367111160986, 0.1793367111160986, 0.16945464425782408, 0.16945464425782408, 0.16945464425782408, 0.07776363940906772, 0.07776363940906772, 0.07776363940906772, 0.05348298706515542, 0.05348298706515542, 0.05348298706515542, 0.06521197142098045, 0.06521197142098045, 0.06521197142098045, 0.07482903509449257, 0.07482903509449257, 0.07482903509449257, 0.05213655465862699, 0.05213655465862699, 0.05213655465862699, 0.06307451577269352, 0.06307451577269352, 0.06307451577269352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12926834312168434, 0.12926834312168434, 0.12926834312168434, 0.038098214817028575, 0.038098214817028575, 0.038098214817028575, 0.07923191412116226, 0.07923191412116226, 0.07923191412116226, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018677852973677744, 0.018677852973677744, 0.018677852973677744, 0.018394911814963222, 0.018394911814963222, 0.018394911814963222, 0.03204353356392853, 0.03204353356392853, 0.03204353356392853, 0.253258672404864, 0.253258672404864, 0.253258672404864, 0.24549781766972878, 0.24549781766972878, 0.24549781766972878, 0.2652653596923943, 0.2652653596923943, 0.2652653596923943, 0.06304353023605835, 0.06304353023605835, 0.06304353023605835, 0.06728572739774541, 0.06728572739774541, 0.06728572739774541, 0.06725851704639241, 0.06725851704639241, 0.06725851704639241, 0.10936930372140341, 0.10936930372140341, 0.10936930372140341, 0.14380679092016402, 0.14380679092016402, 0.14380679092016402, 0.11391705412398623, 0.11391705412398623, 0.11391705412398623, 0.20131326880820222, 0.20131326880820222, 0.20131326880820222, 0.20146787789925802, 0.20146787789925802, 0.20146787789925802, 0.1924995004732023, 0.1924995004732023, 0.1924995004732023, 0.13771105355039948, 0.13771105355039948, 0.13771105355039948, 0.14487263634954795, 0.14487263634954795, 0.14487263634954795, 0.12611680051017815, 0.12611680051017815, 0.12611680051017815, 0.2041695856749749, 0.2041695856749749, 0.2041695856749749, 0.18778058302597, 0.18778058302597, 0.18778058302597, 0.22058295279412554, 0.22058295279412554, 0.22058295279412554, 0.15723141189598755, 0.15723141189598755, 0.15723141189598755, 0.16526530862453603, 0.16526530862453603, 0.16526530862453603, 0.15999213729224504, 0.15999213729224504, 0.15999213729224504, 0.21062078772664927, 0.21062078772664927, 0.21062078772664927, 0.29846112794813184, 0.29846112794813184, 0.29846112794813184, 0.2440116312780628, 0.2440116312780628, 0.2440116312780628, 0.27616164772528784, 0.27616164772528784, 0.27616164772528784, 0.21659559725377653, 0.21659559725377653, 0.21659559725377653, 0.19121204351852605, 0.19121204351852605, 0.19121204351852605, 0.16626796853771808, 0.16626796853771808, 0.16626796853771808, 0.18444127581105507, 0.18444127581105507, 0.18444127581105507, 0.16490633295650492, 0.16490633295650492, 0.16490633295650492, 0.06519789994585623, 0.06519789994585623, 0.06519789994585623, 0.0709587456098919, 0.0709587456098919, 0.0709587456098919, 0.07402936612666022, 0.07402936612666022, 0.07402936612666022]}, "mutation_prompt": null}
{"id": "f7dd8862-ce35-4a98-9f80-80960024028b", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.6\n        self.cognitive = 1.5  # Adjusted cognitive factor\n        self.social = 1.7  # Adjusted social factor\n        self.mutation_prob = 0.2  # Increased mutation probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.1  # Reduced max velocity\n        self.de_mutation_factor = 0.95  # Increased mutation factor\n        self.de_crossover_rate = 0.8  # Increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "EnhancedHybridSwarmDE", "description": "Enhanced hybrid swarm with differential evolution and dynamic parameter adaptation for improved convergence speed and solution quality.", "configspace": "", "generation": 18, "fitness": 0.1595540426046109, "feedback": "The algorithm EnhancedHybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.14.", "error": "", "parent_id": "4a8769d4-a693-4e4a-bf67-c4742d2a6756", "metadata": {"aucs": [0.310692776255602, 0.310692776255602, 0.310692776255602, 0.2841296229889064, 0.2841296229889064, 0.2841296229889064, 0.28260486734738754, 0.28260486734738754, 0.28260486734738754, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08911951644134475, 0.08911951644134475, 0.08911951644134475, 0.09894236054676753, 0.09894236054676753, 0.09894236054676753, 0.10161081358525659, 0.10161081358525659, 0.10161081358525659, 0.07183554709491713, 0.07183554709491713, 0.07183554709491713, 0.07152364025206204, 0.07152364025206204, 0.07152364025206204, 0.07723086390495315, 0.07723086390495315, 0.07723086390495315, 0.6242394249902722, 0.6242394249902722, 0.6242394249902722, 0.6807118120849788, 0.6807118120849788, 0.6807118120849788, 0.6741280452850431, 0.6741280452850431, 0.6741280452850431, 0.1469530403058079, 0.1469530403058079, 0.1469530403058079, 0.1646983267993808, 0.1646983267993808, 0.1646983267993808, 0.14820953523348834, 0.14820953523348834, 0.14820953523348834, 0.2067424962931984, 0.2067424962931984, 0.2067424962931984, 0.22511544171649223, 0.22511544171649223, 0.22511544171649223, 0.19160044648792018, 0.19160044648792018, 0.19160044648792018, 0.07774080992472177, 0.07774080992472177, 0.07774080992472177, 0.08145580265931918, 0.08145580265931918, 0.08145580265931918, 0.09838954807565037, 0.09838954807565037, 0.09838954807565037, 0.09848413231246889, 0.09848413231246889, 0.09848413231246889, 0.09294630004088522, 0.09294630004088522, 0.09294630004088522, 0.10954141162423525, 0.10954141162423525, 0.10954141162423525, 0.011667736538927387, 0.011667736538927387, 0.011667736538927387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.15000514588620095, 0.15000514588620095, 0.15000514588620095, 0.047697635571466, 0.047697635571466, 0.047697635571466, 0.10487876927059392, 0.10487876927059392, 0.10487876927059392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04158163470386156, 0.04158163470386156, 0.04158163470386156, 0.035116372808786434, 0.035116372808786434, 0.035116372808786434, 0.03901712825576065, 0.03901712825576065, 0.03901712825576065, 0.29517457080281984, 0.29517457080281984, 0.29517457080281984, 0.28561110763120456, 0.28561110763120456, 0.28561110763120456, 0.2896921950479724, 0.2896921950479724, 0.2896921950479724, 0.070254477242639, 0.070254477242639, 0.070254477242639, 0.09786404414621697, 0.09786404414621697, 0.09786404414621697, 0.08799375472793236, 0.08799375472793236, 0.08799375472793236, 0.14420872823842057, 0.14420872823842057, 0.14420872823842057, 0.14526766196239538, 0.14526766196239538, 0.14526766196239538, 0.14089005128186838, 0.14089005128186838, 0.14089005128186838, 0.2420038417719974, 0.2420038417719974, 0.2420038417719974, 0.2273061949038352, 0.2273061949038352, 0.2273061949038352, 0.2065795676120451, 0.2065795676120451, 0.2065795676120451, 0.14696691397961092, 0.14696691397961092, 0.14696691397961092, 0.16948229698792616, 0.16948229698792616, 0.16948229698792616, 0.1507203228867946, 0.1507203228867946, 0.1507203228867946, 0.23794497695994432, 0.23794497695994432, 0.23794497695994432, 0.25537325043894765, 0.25537325043894765, 0.25537325043894765, 0.21031280909374717, 0.21031280909374717, 0.21031280909374717, 0.17106302007136565, 0.17106302007136565, 0.17106302007136565, 0.1673589961410813, 0.1673589961410813, 0.1673589961410813, 0.1781421528365379, 0.1781421528365379, 0.1781421528365379, 0.17766731677373815, 0.17766731677373815, 0.17766731677373815, 0.32857439887302375, 0.32857439887302375, 0.32857439887302375, 0.10752807342449522, 0.10752807342449522, 0.10752807342449522, 0.3086435301219459, 0.3086435301219459, 0.3086435301219459, 0.1931153974859674, 0.1931153974859674, 0.1931153974859674, 0.2343488499824804, 0.2343488499824804, 0.2343488499824804, 0.17086572710995152, 0.17086572710995152, 0.17086572710995152, 0.17339660108517752, 0.17339660108517752, 0.17339660108517752, 0.18961113478774128, 0.18961113478774128, 0.18961113478774128, 0.08106296609857033, 0.08106296609857033, 0.08106296609857033, 0.07969564045540634, 0.07969564045540634, 0.07969564045540634, 0.08375949128152771, 0.08375949128152771, 0.08375949128152771]}, "mutation_prompt": null}
{"id": "e886fcfa-f931-4ad0-a0ca-bbb67d8cce5a", "solution": "import numpy as np\n\nclass AdaptiveHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 45  # Adjusted number of particles\n        self.num_swarms = 6  # Adjusted number of swarms\n        self.inertia = 0.7  # Adjusted inertia weight\n        self.cognitive = 1.3  # Adjusted cognitive factor\n        self.social = 1.9  # Adjusted social factor\n        self.mutation_prob = 0.25  # Adjusted mutation probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Adjusted max velocity\n        self.de_mutation_factor = 0.9  # Adjusted mutation factor\n        self.de_crossover_rate = 0.9  # Adjusted crossover rate\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "AdaptiveHybridSwarmDE", "description": "Multi-level adaptive hybrid swarm using differential evolution with stochastic dynamic adaptation for enhanced convergence and exploration.", "configspace": "", "generation": 19, "fitness": 0.15769318939276336, "feedback": "The algorithm AdaptiveHybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "f7dd8862-ce35-4a98-9f80-80960024028b", "metadata": {"aucs": [0.2717872073867478, 0.2717872073867478, 0.2717872073867478, 0.2737721482506499, 0.2737721482506499, 0.2737721482506499, 0.2776236538057616, 0.2776236538057616, 0.2776236538057616, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.069406300209236, 0.069406300209236, 0.069406300209236, 0.07138633803118011, 0.07138633803118011, 0.07138633803118011, 0.07148474170673402, 0.07148474170673402, 0.07148474170673402, 0.06331428310140341, 0.06331428310140341, 0.06331428310140341, 0.06916430787344852, 0.06916430787344852, 0.06916430787344852, 0.06360817356976334, 0.06360817356976334, 0.06360817356976334, 0.9221731436414805, 0.9221731436414805, 0.9221731436414805, 0.6768985707812749, 0.6768985707812749, 0.6768985707812749, 0.7465812774968026, 0.7465812774968026, 0.7465812774968026, 0.1319402581596305, 0.1319402581596305, 0.1319402581596305, 0.11754876620307009, 0.11754876620307009, 0.11754876620307009, 0.15449642214104498, 0.15449642214104498, 0.15449642214104498, 0.21983375275539574, 0.21983375275539574, 0.21983375275539574, 0.2285809256038155, 0.2285809256038155, 0.2285809256038155, 0.18202516182100226, 0.18202516182100226, 0.18202516182100226, 0.08391021910304386, 0.08391021910304386, 0.08391021910304386, 0.09414740302946012, 0.09414740302946012, 0.09414740302946012, 0.09430572730259013, 0.09430572730259013, 0.09430572730259013, 0.08956179459755476, 0.08956179459755476, 0.08956179459755476, 0.07244888509524594, 0.07244888509524594, 0.07244888509524594, 0.09225387827746712, 0.09225387827746712, 0.09225387827746712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12104772670713815, 0.12104772670713815, 0.12104772670713815, 0.05870499876816815, 0.05870499876816815, 0.05870499876816815, 0.10394172075387109, 0.10394172075387109, 0.10394172075387109, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022746970904236385, 0.022746970904236385, 0.022746970904236385, 0.027661418272141414, 0.027661418272141414, 0.027661418272141414, 0.02751826443358607, 0.02751826443358607, 0.02751826443358607, 0.2651505673863308, 0.2651505673863308, 0.2651505673863308, 0.259804958365891, 0.259804958365891, 0.259804958365891, 0.2636069813296983, 0.2636069813296983, 0.2636069813296983, 0.08020337571021885, 0.08020337571021885, 0.08020337571021885, 0.08017657313974269, 0.08017657313974269, 0.08017657313974269, 0.0773161926680268, 0.0773161926680268, 0.0773161926680268, 0.13666256825331435, 0.13666256825331435, 0.13666256825331435, 0.139928583256953, 0.139928583256953, 0.139928583256953, 0.15080869007212716, 0.15080869007212716, 0.15080869007212716, 0.1991660384220768, 0.1991660384220768, 0.1991660384220768, 0.20757465182744683, 0.20757465182744683, 0.20757465182744683, 0.2065869819882702, 0.2065869819882702, 0.2065869819882702, 0.13529701610336065, 0.13529701610336065, 0.13529701610336065, 0.1536036069268163, 0.1536036069268163, 0.1536036069268163, 0.1521358449068939, 0.1521358449068939, 0.1521358449068939, 0.20591933621130853, 0.20591933621130853, 0.20591933621130853, 0.19531907659624026, 0.19531907659624026, 0.19531907659624026, 0.19966556952507664, 0.19966556952507664, 0.19966556952507664, 0.17056250069149714, 0.17056250069149714, 0.17056250069149714, 0.16909626853700988, 0.16909626853700988, 0.16909626853700988, 0.16738410513160762, 0.16738410513160762, 0.16738410513160762, 0.17408775207250782, 0.17408775207250782, 0.17408775207250782, 0.29110690974325637, 0.29110690974325637, 0.29110690974325637, 0.3025325148049378, 0.3025325148049378, 0.3025325148049378, 0.2740287271374271, 0.2740287271374271, 0.2740287271374271, 0.16095074970914525, 0.16095074970914525, 0.16095074970914525, 0.2221269467944177, 0.2221269467944177, 0.2221269467944177, 0.1684398752002666, 0.1684398752002666, 0.1684398752002666, 0.23162619231279402, 0.23162619231279402, 0.23162619231279402, 0.18827240874725804, 0.18827240874725804, 0.18827240874725804, 0.07250035985960168, 0.07250035985960168, 0.07250035985960168, 0.07700760003235552, 0.07700760003235552, 0.07700760003235552, 0.07448567303214315, 0.07448567303214315, 0.07448567303214315]}, "mutation_prompt": null}
{"id": "fc23dfd0-0b72-471c-9660-b5319ad120bd", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategySwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 4\n        self.inertia = 0.5\n        self.cognitive = 2.0\n        self.social = 1.5\n        self.mutation_prob = 0.25\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(2, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n\n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n\n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n\n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n\n                    if eval_count >= self.budget:\n                        break\n\n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n\n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n\n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n\n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n\n                if eval_count >= self.budget:\n                    break\n\n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveMultiStrategySwarm", "description": "Adaptive multi-strategy swarm optimization with enhanced differential evolution and learning factors for robust exploration-exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.15691555952890204, "feedback": "The algorithm AdaptiveMultiStrategySwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "f7dd8862-ce35-4a98-9f80-80960024028b", "metadata": {"aucs": [0.27028210939353536, 0.27028210939353536, 0.27028210939353536, 0.2596706373141088, 0.2596706373141088, 0.2596706373141088, 0.2660533695981162, 0.2660533695981162, 0.2660533695981162, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08550182099719605, 0.08550182099719605, 0.08550182099719605, 0.06902787924601672, 0.06902787924601672, 0.06902787924601672, 0.07056280766548406, 0.07056280766548406, 0.07056280766548406, 0.060577337343664106, 0.060577337343664106, 0.060577337343664106, 0.061381914780041735, 0.061381914780041735, 0.061381914780041735, 0.06708574468584394, 0.06708574468584394, 0.06708574468584394, 0.7650679605066066, 0.7650679605066066, 0.7650679605066066, 0.6990330275676595, 0.6990330275676595, 0.6990330275676595, 0.9053897408399529, 0.9053897408399529, 0.9053897408399529, 0.1257950918803401, 0.1257950918803401, 0.1257950918803401, 0.127042733169753, 0.127042733169753, 0.127042733169753, 0.13362388164185068, 0.13362388164185068, 0.13362388164185068, 0.19504160922646374, 0.19504160922646374, 0.19504160922646374, 0.19931370083652933, 0.19931370083652933, 0.19931370083652933, 0.1761195834720254, 0.1761195834720254, 0.1761195834720254, 0.0606783341552285, 0.0606783341552285, 0.0606783341552285, 0.08370373348827231, 0.08370373348827231, 0.08370373348827231, 0.08522830372631396, 0.08522830372631396, 0.08522830372631396, 0.08038009053076933, 0.08038009053076933, 0.08038009053076933, 0.07678058931534437, 0.07678058931534437, 0.07678058931534437, 0.08556611064888853, 0.08556611064888853, 0.08556611064888853, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09166475350240744, 0.09166475350240744, 0.09166475350240744, 0.05744198890430019, 0.05744198890430019, 0.05744198890430019, 0.09931769259409062, 0.09931769259409062, 0.09931769259409062, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013177966895249638, 0.013177966895249638, 0.013177966895249638, 0.022720481152282312, 0.022720481152282312, 0.022720481152282312, 0.023578361134678927, 0.023578361134678927, 0.023578361134678927, 0.2535871820192691, 0.2535871820192691, 0.2535871820192691, 0.25358606650603377, 0.25358606650603377, 0.25358606650603377, 0.29276238400278043, 0.29276238400278043, 0.29276238400278043, 0.07645416481129119, 0.07645416481129119, 0.07645416481129119, 0.08473311141534301, 0.08473311141534301, 0.08473311141534301, 0.07575017339949786, 0.07575017339949786, 0.07575017339949786, 0.13911320318390952, 0.13911320318390952, 0.13911320318390952, 0.12826261600712274, 0.12826261600712274, 0.12826261600712274, 0.15791334647970012, 0.15791334647970012, 0.15791334647970012, 0.2082017228487545, 0.2082017228487545, 0.2082017228487545, 0.22784981456406705, 0.22784981456406705, 0.22784981456406705, 0.2031376093926731, 0.2031376093926731, 0.2031376093926731, 0.15108690468776276, 0.15108690468776276, 0.15108690468776276, 0.15639997973812658, 0.15639997973812658, 0.15639997973812658, 0.1355084999696352, 0.1355084999696352, 0.1355084999696352, 0.20202022555508348, 0.20202022555508348, 0.20202022555508348, 0.20129052431412342, 0.20129052431412342, 0.20129052431412342, 0.20283573967778323, 0.20283573967778323, 0.20283573967778323, 0.16457484240375853, 0.16457484240375853, 0.16457484240375853, 0.16777146933754394, 0.16777146933754394, 0.16777146933754394, 0.16441841918211175, 0.16441841918211175, 0.16441841918211175, 0.17306356521145683, 0.17306356521145683, 0.17306356521145683, 0.3474259730065148, 0.3474259730065148, 0.3474259730065148, 0.29337305642166134, 0.29337305642166134, 0.29337305642166134, 0.28369581239109665, 0.28369581239109665, 0.28369581239109665, 0.2670650988159118, 0.2670650988159118, 0.2670650988159118, 0.21142662099933873, 0.21142662099933873, 0.21142662099933873, 0.18198409225391488, 0.18198409225391488, 0.18198409225391488, 0.1766851875371802, 0.1766851875371802, 0.1766851875371802, 0.1730935875952222, 0.1730935875952222, 0.1730935875952222, 0.07398973418961485, 0.07398973418961485, 0.07398973418961485, 0.07237777281468283, 0.07237777281468283, 0.07237777281468283, 0.07877242913496574, 0.07877242913496574, 0.07877242913496574]}, "mutation_prompt": null}
{"id": "5a677239-b659-4157-8b67-f0fdb8ea7b09", "solution": "import numpy as np\n\nclass AdaptiveSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 35  # Reduced number of particles\n        self.num_swarms = 6  # Increased number of swarms\n        self.inertia = 0.7  # Slightly increased inertia\n        self.cognitive = 1.4  # Slightly adjusted cognitive factor\n        self.social = 1.6  # Slightly adjusted social factor\n        self.mutation_prob = 0.25  # Slightly increased mutation probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2  # Increased max velocity\n        self.de_mutation_factor = 0.9  # Slightly decreased mutation factor\n        self.de_crossover_rate = 0.9  # Slightly increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) * \n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) * \n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor * \n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "AdaptiveSwarmDE", "description": "Adaptive Swarm-DE combines multiple swarm intelligence strategies with adaptive parameters to balance exploration and exploitation dynamically.", "configspace": "", "generation": 21, "fitness": 0.14602324383281967, "feedback": "The algorithm AdaptiveSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "f7dd8862-ce35-4a98-9f80-80960024028b", "metadata": {"aucs": [0.25841097781957156, 0.25841097781957156, 0.25841097781957156, 0.21675535815901736, 0.21675535815901736, 0.21675535815901736, 0.2591171504911265, 0.2591171504911265, 0.2591171504911265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06984471610248077, 0.06984471610248077, 0.06984471610248077, 0.07547859956838743, 0.07547859956838743, 0.07547859956838743, 0.06679427640342495, 0.06679427640342495, 0.06679427640342495, 0.049725224814740066, 0.049725224814740066, 0.049725224814740066, 0.050910087529707604, 0.050910087529707604, 0.050910087529707604, 0.04630650056258401, 0.04630650056258401, 0.04630650056258401, 0.807915794511279, 0.807915794511279, 0.807915794511279, 0.7908163983180028, 0.7908163983180028, 0.7908163983180028, 0.7785784862504332, 0.7785784862504332, 0.7785784862504332, 0.09838632492443244, 0.09838632492443244, 0.09838632492443244, 0.09478928935572295, 0.09478928935572295, 0.09478928935572295, 0.11114729584821703, 0.11114729584821703, 0.11114729584821703, 0.1641327183389365, 0.1641327183389365, 0.1641327183389365, 0.1693673686704288, 0.1693673686704288, 0.1693673686704288, 0.1742072412371113, 0.1742072412371113, 0.1742072412371113, 0.031826828711813526, 0.031826828711813526, 0.031826828711813526, 0.08024991591995057, 0.08024991591995057, 0.08024991591995057, 0.05919479409026085, 0.05919479409026085, 0.05919479409026085, 0.06743970742839067, 0.06743970742839067, 0.06743970742839067, 0.08448927464122824, 0.08448927464122824, 0.08448927464122824, 0.05744965898680621, 0.05744965898680621, 0.05744965898680621, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07646458112805654, 0.07646458112805654, 0.07646458112805654, 0.08627069094496143, 0.08627069094496143, 0.08627069094496143, 0.062028150176327235, 0.062028150176327235, 0.062028150176327235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.034047622113839715, 0.034047622113839715, 0.034047622113839715, 0.010015690982511094, 0.010015690982511094, 0.010015690982511094, 0.021467729747188802, 0.021467729747188802, 0.021467729747188802, 0.2561052077072158, 0.2561052077072158, 0.2561052077072158, 0.255377994591781, 0.255377994591781, 0.255377994591781, 0.25861959272367496, 0.25861959272367496, 0.25861959272367496, 0.06771465600871251, 0.06771465600871251, 0.06771465600871251, 0.07927202527275001, 0.07927202527275001, 0.07927202527275001, 0.08041115366287521, 0.08041115366287521, 0.08041115366287521, 0.1888196600472981, 0.1888196600472981, 0.1888196600472981, 0.13268816070578904, 0.13268816070578904, 0.13268816070578904, 0.15129539036631645, 0.15129539036631645, 0.15129539036631645, 0.1906470684068, 0.1906470684068, 0.1906470684068, 0.19229485193756835, 0.19229485193756835, 0.19229485193756835, 0.18936331612161417, 0.18936331612161417, 0.18936331612161417, 0.14835290532864398, 0.14835290532864398, 0.14835290532864398, 0.15884938152181516, 0.15884938152181516, 0.15884938152181516, 0.13034461982709722, 0.13034461982709722, 0.13034461982709722, 0.20738865049241706, 0.20738865049241706, 0.20738865049241706, 0.18642494615876792, 0.18642494615876792, 0.18642494615876792, 0.19040885394316898, 0.19040885394316898, 0.19040885394316898, 0.16151510732388474, 0.16151510732388474, 0.16151510732388474, 0.16211590974813972, 0.16211590974813972, 0.16211590974813972, 0.16649158420567034, 0.16649158420567034, 0.16649158420567034, 0.1646253422164604, 0.1646253422164604, 0.1646253422164604, 0.22343464991686313, 0.22343464991686313, 0.22343464991686313, 0.25298239742770945, 0.25298239742770945, 0.25298239742770945, 0.27430141649503337, 0.27430141649503337, 0.27430141649503337, 0.17248437860153443, 0.17248437860153443, 0.17248437860153443, 0.16600021690388678, 0.16600021690388678, 0.16600021690388678, 0.17988792976781187, 0.17988792976781187, 0.17988792976781187, 0.16970672375786322, 0.16970672375786322, 0.16970672375786322, 0.16482484519316876, 0.16482484519316876, 0.16482484519316876, 0.0812724602987901, 0.0812724602987901, 0.0812724602987901, 0.07227228176569822, 0.07227228176569822, 0.07227228176569822, 0.08285142373925625, 0.08285142373925625, 0.08285142373925625]}, "mutation_prompt": null}
{"id": "08c05fdb-fc6a-4778-aa41-4afce20e3f30", "solution": "import numpy as np\n\nclass AdaptiveQuantumHybridSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.num_swarms = 5\n        self.inertia = 0.7  # Slightly increased inertia for better exploration\n        self.cognitive = 1.5\n        self.social = 1.5  # Reduced social factor for better swarm balance\n        self.mutation_prob = 0.25  # Increased mutation probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Enhanced max velocity for dynamic search\n        self.de_mutation_factor = 0.9  # Adjusted mutation factor\n        self.de_crossover_rate = 0.85  # Slightly increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        \n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n        \n        eval_count = self.num_particles\n        \n        while eval_count < self.budget:\n            adaptive_num_swarms = np.random.randint(3, self.num_swarms + 1)\n            np.random.shuffle(positions)\n            swarms = np.array_split(positions, adaptive_num_swarms)\n            \n            for swarm in swarms:\n                local_best_position = None\n                local_best_value = np.inf\n                \n                for position in swarm:\n                    value = func(position)\n                    eval_count += 1\n                    if value < local_best_value:\n                        local_best_value = value\n                        local_best_position = np.copy(position)\n                    \n                    idx = np.where((personal_best_positions == position).all(axis=1))[0]\n                    if idx.size > 0 and value < personal_best_values[idx[0]]:\n                        personal_best_values[idx[0]] = value\n                        personal_best_positions[idx[0]] = np.copy(position)\n                    \n                    if eval_count >= self.budget:\n                        break\n                \n                for idx in range(len(swarm)):\n                    particle_idx = np.where((positions == swarm[idx]).all(axis=1))[0]\n                    if particle_idx.size == 0:\n                        continue\n                    particle_idx = particle_idx[0]\n                    velocities[particle_idx] = (\n                        self.inertia * velocities[particle_idx] +\n                        self.cognitive * np.random.rand(self.dim) *\n                        (personal_best_positions[particle_idx] - swarm[idx]) +\n                        self.social * np.random.rand(self.dim) *\n                        (local_best_position - swarm[idx])\n                    )\n                    \n                    velocities[particle_idx] = np.clip(velocities[particle_idx], -self.max_velocity, self.max_velocity)\n                    \n                    if np.random.rand() < self.mutation_prob:\n                        diff_individuals = np.random.choice(len(positions), 3, replace=False)\n                        donor_vector = (\n                            positions[diff_individuals[0]] +\n                            self.de_mutation_factor *\n                            (positions[diff_individuals[1]] - positions[diff_individuals[2]])\n                        )\n                        trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                                donor_vector, positions[particle_idx])\n                        trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                        \n                        trial_value = func(trial_vector)\n                        eval_count += 1\n                        if trial_value < personal_best_values[particle_idx]:\n                            positions[particle_idx] = trial_vector\n                            personal_best_positions[particle_idx] = trial_vector\n                            personal_best_values[particle_idx] = trial_value\n                    \n                    positions[particle_idx] = np.clip(positions[particle_idx] + velocities[particle_idx], self.lb, self.ub)\n                \n                if eval_count >= self.budget:\n                    break\n            \n            best_swarm = min(swarms, key=lambda swarm: min(func(pos) for pos in swarm))\n            for position in best_swarm:\n                value = func(position)\n                eval_count += 1\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(position)\n                \n                if eval_count >= self.budget:\n                    break\n        \n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumHybridSwarmDE", "description": "Adaptive Quantum-Inspired Hybrid Swarm with Differential Evolution for robust convergence by integrating quantum motion and dynamic parameter control.", "configspace": "", "generation": 22, "fitness": 0.15619855014762443, "feedback": "The algorithm AdaptiveQuantumHybridSwarmDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.15.", "error": "", "parent_id": "f7dd8862-ce35-4a98-9f80-80960024028b", "metadata": {"aucs": [0.24759647906343263, 0.24759647906343263, 0.24759647906343263, 0.23987383985598354, 0.23987383985598354, 0.23987383985598354, 0.2702246801637924, 0.2702246801637924, 0.2702246801637924, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07963395792375416, 0.07963395792375416, 0.07963395792375416, 0.07474546479155575, 0.07474546479155575, 0.07474546479155575, 0.0812598411449138, 0.0812598411449138, 0.0812598411449138, 0.05929718735275835, 0.05929718735275835, 0.05929718735275835, 0.06068510695367091, 0.06068510695367091, 0.06068510695367091, 0.07969289417349323, 0.07969289417349323, 0.07969289417349323, 0.7999260212773084, 0.7999260212773084, 0.7999260212773084, 0.6415284236547109, 0.6415284236547109, 0.6415284236547109, 0.8287774375691861, 0.8287774375691861, 0.8287774375691861, 0.1165416275759742, 0.1165416275759742, 0.1165416275759742, 0.11997710371821291, 0.11997710371821291, 0.11997710371821291, 0.13551357135536013, 0.13551357135536013, 0.13551357135536013, 0.2037852870371465, 0.2037852870371465, 0.2037852870371465, 0.18671631266027944, 0.18671631266027944, 0.18671631266027944, 0.16462741459142272, 0.16462741459142272, 0.16462741459142272, 0.08589032088571225, 0.08589032088571225, 0.08589032088571225, 0.09451522345720809, 0.09451522345720809, 0.09451522345720809, 0.10029733714672362, 0.10029733714672362, 0.10029733714672362, 0.0662904119052764, 0.0662904119052764, 0.0662904119052764, 0.08448655837407915, 0.08448655837407915, 0.08448655837407915, 0.0663751833190821, 0.0663751833190821, 0.0663751833190821, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13243624464372716, 0.13243624464372716, 0.13243624464372716, 0.07691299257186479, 0.07691299257186479, 0.07691299257186479, 0.08877785222349943, 0.08877785222349943, 0.08877785222349943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025363044709934335, 0.025363044709934335, 0.025363044709934335, 0.020850818857368725, 0.020850818857368725, 0.020850818857368725, 0.02573532848186455, 0.02573532848186455, 0.02573532848186455, 0.33022004417023065, 0.33022004417023065, 0.33022004417023065, 0.27577475078092484, 0.27577475078092484, 0.27577475078092484, 0.26316031379312843, 0.26316031379312843, 0.26316031379312843, 0.07532341509827434, 0.07532341509827434, 0.07532341509827434, 0.11040536308195437, 0.11040536308195437, 0.11040536308195437, 0.07674667231942622, 0.07674667231942622, 0.07674667231942622, 0.12238724311297866, 0.12238724311297866, 0.12238724311297866, 0.15118630183152437, 0.15118630183152437, 0.15118630183152437, 0.12248062045518149, 0.12248062045518149, 0.12248062045518149, 0.21618345493950497, 0.21618345493950497, 0.21618345493950497, 0.202787724328384, 0.202787724328384, 0.202787724328384, 0.19592420473008731, 0.19592420473008731, 0.19592420473008731, 0.15639129981504862, 0.15639129981504862, 0.15639129981504862, 0.14877489830884627, 0.14877489830884627, 0.14877489830884627, 0.13386807461708683, 0.13386807461708683, 0.13386807461708683, 0.20370355028887643, 0.20370355028887643, 0.20370355028887643, 0.20123370962019593, 0.20123370962019593, 0.20123370962019593, 0.20843512778789175, 0.20843512778789175, 0.20843512778789175, 0.16659545505195272, 0.16659545505195272, 0.16659545505195272, 0.17095734452863776, 0.17095734452863776, 0.17095734452863776, 0.1747762312742066, 0.1747762312742066, 0.1747762312742066, 0.16494845200600305, 0.16494845200600305, 0.16494845200600305, 0.31407370314573346, 0.31407370314573346, 0.31407370314573346, 0.2554917907816644, 0.2554917907816644, 0.2554917907816644, 0.31716629882784453, 0.31716629882784453, 0.31716629882784453, 0.2974609846377464, 0.2974609846377464, 0.2974609846377464, 0.17099275047576246, 0.17099275047576246, 0.17099275047576246, 0.19081127734058478, 0.19081127734058478, 0.19081127734058478, 0.1734915301929839, 0.1734915301929839, 0.1734915301929839, 0.16796965600931413, 0.16796965600931413, 0.16796965600931413, 0.07789066441555392, 0.07789066441555392, 0.07789066441555392, 0.07407096354442455, 0.07407096354442455, 0.07407096354442455, 0.07537777187770478, 0.07537777187770478, 0.07537777187770478]}, "mutation_prompt": null}
{"id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumInspiredDSO", "description": "Adaptive Quantum-Inspired Differential Swarm Optimization that leverages quantum-inspired particle dynamics and self-adaptive differential mutation for robust optimization.", "configspace": "", "generation": 23, "fitness": 0.37490925066223746, "feedback": "The algorithm AdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "f7dd8862-ce35-4a98-9f80-80960024028b", "metadata": {"aucs": [0.8365130194165616, 0.8365130194165616, 0.8365130194165616, 0.8331004541393748, 0.8331004541393748, 0.8331004541393748, 0.842833409810495, 0.842833409810495, 0.842833409810495, 0.49423169435861414, 0.49423169435861414, 0.49423169435861414, 0.5690944848871653, 0.5690944848871653, 0.5690944848871653, 0.5979900675486698, 0.5979900675486698, 0.5979900675486698, 0.1409093687496743, 0.1409093687496743, 0.1409093687496743, 0.13713620213478062, 0.13713620213478062, 0.13713620213478062, 0.4618889064153302, 0.4618889064153302, 0.4618889064153302, 0.08315939766618574, 0.08315939766618574, 0.08315939766618574, 0.08971424690825591, 0.08971424690825591, 0.08971424690825591, 0.08944162271843803, 0.08944162271843803, 0.08944162271843803, 0.955998728544283, 0.955998728544283, 0.955998728544283, 0.9647032645145731, 0.9647032645145731, 0.9647032645145731, 0.960238264698774, 0.960238264698774, 0.960238264698774, 0.5924151639224732, 0.5924151639224732, 0.5924151639224732, 0.7230018194491634, 0.7230018194491634, 0.7230018194491634, 0.6505337822387542, 0.6505337822387542, 0.6505337822387542, 0.8382071310859144, 0.8382071310859144, 0.8382071310859144, 0.8129704457230967, 0.8129704457230967, 0.8129704457230967, 0.2340927273810396, 0.2340927273810396, 0.2340927273810396, 0.45646997027321956, 0.45646997027321956, 0.45646997027321956, 0.55470487488675, 0.55470487488675, 0.55470487488675, 0.5833214740037862, 0.5833214740037862, 0.5833214740037862, 0.021180439157163944, 0.021180439157163944, 0.021180439157163944, 0.5663778644682722, 0.5663778644682722, 0.5663778644682722, 0.4259204000408089, 0.4259204000408089, 0.4259204000408089, 0.19442405631101667, 0.19442405631101667, 0.19442405631101667, 0.1461374239709785, 0.1461374239709785, 0.1461374239709785, 0.2408862342788558, 0.2408862342788558, 0.2408862342788558, 0.21520381338303618, 0.21520381338303618, 0.21520381338303618, 0.3529744177920442, 0.3529744177920442, 0.3529744177920442, 0.35352456362958984, 0.35352456362958984, 0.35352456362958984, 0.1556072886487434, 0.1556072886487434, 0.1556072886487434, 0.16067234575219358, 0.16067234575219358, 0.16067234575219358, 0.17968730028217905, 0.17968730028217905, 0.17968730028217905, 0.30749937412783035, 0.30749937412783035, 0.30749937412783035, 0.3989828747180373, 0.3989828747180373, 0.3989828747180373, 0.04830954252663633, 0.04830954252663633, 0.04830954252663633, 0.7663251025579257, 0.7663251025579257, 0.7663251025579257, 0.7470389713322851, 0.7470389713322851, 0.7470389713322851, 0.6870731712125562, 0.6870731712125562, 0.6870731712125562, 0.10348260109856344, 0.10348260109856344, 0.10348260109856344, 0.11185329530678045, 0.11185329530678045, 0.11185329530678045, 0.09877021243800643, 0.09877021243800643, 0.09877021243800643, 0.19959982653122588, 0.19959982653122588, 0.19959982653122588, 0.2089413981287208, 0.2089413981287208, 0.2089413981287208, 0.14772728733591522, 0.14772728733591522, 0.14772728733591522, 0.36055086640846234, 0.36055086640846234, 0.36055086640846234, 0.3855319966444859, 0.3855319966444859, 0.3855319966444859, 0.3722368027351507, 0.3722368027351507, 0.3722368027351507, 0.28166421138741604, 0.28166421138741604, 0.28166421138741604, 0.21711532436916225, 0.21711532436916225, 0.21711532436916225, 0.26853296684150196, 0.26853296684150196, 0.26853296684150196, 0.20188942405987464, 0.20188942405987464, 0.20188942405987464, 0.20464998998953565, 0.20464998998953565, 0.20464998998953565, 0.27484815727669787, 0.27484815727669787, 0.27484815727669787, 0.2099941035034103, 0.2099941035034103, 0.2099941035034103, 0.18764086455460005, 0.18764086455460005, 0.18764086455460005, 0.16669362341928284, 0.16669362341928284, 0.16669362341928284, 0.9128012877972214, 0.9128012877972214, 0.9128012877972214, 0.1478574983789751, 0.1478574983789751, 0.1478574983789751, 0.9085486798952012, 0.9085486798952012, 0.9085486798952012, 0.16627351818665592, 0.16627351818665592, 0.16627351818665592, 0.2106562661916178, 0.2106562661916178, 0.2106562661916178, 0.3263582704651403, 0.3263582704651403, 0.3263582704651403, 0.19248085626388423, 0.19248085626388423, 0.19248085626388423, 0.19610927034504344, 0.19610927034504344, 0.19610927034504344, 0.18086597711408636, 0.18086597711408636, 0.18086597711408636, 0.09419649824764731, 0.09419649824764731, 0.09419649824764731, 0.0932286556361589, 0.0932286556361589, 0.0932286556361589, 0.09187061146514441, 0.09187061146514441, 0.09187061146514441]}, "mutation_prompt": null}
{"id": "21b16416-16ea-48ad-ba34-4ab3bc9d79ba", "solution": "import numpy as np\n\nclass EnhancedQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased number of particles\n        self.inertia = 0.6  # Slightly increased inertia for better exploration\n        self.cognitive = 1.5  # Enhanced cognitive coefficient for individual learning\n        self.social = 1.9  # Social coefficient slightly reduced to balance exploration\n        self.quantum_prob = 0.3  # Adjusted probability for quantum-inspired moves\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9  # Slightly increased mutation factor for diversity\n        self.de_crossover_rate = 0.85  # Adjusted crossover rate for robust search\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumPSO", "description": "Enhanced Quantum Particle Swarm Optimization with Adaptive Differential Mutation for improved exploration and exploitation.", "configspace": "", "generation": 24, "fitness": 0.30809007744642053, "feedback": "The algorithm EnhancedQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7623908864223274, 0.7623908864223274, 0.7623908864223274, 0.7550064882152875, 0.7550064882152875, 0.7550064882152875, 0.75336938216583, 0.75336938216583, 0.75336938216583, 0.31405805753242055, 0.31405805753242055, 0.31405805753242055, 0.3220036948901812, 0.3220036948901812, 0.3220036948901812, 0.4312613911236318, 0.4312613911236318, 0.4312613911236318, 0.13553661977193698, 0.13553661977193698, 0.13553661977193698, 0.09635278393911084, 0.09635278393911084, 0.09635278393911084, 0.102275450701799, 0.102275450701799, 0.102275450701799, 0.11071753239019289, 0.11071753239019289, 0.11071753239019289, 0.10570224050719212, 0.10570224050719212, 0.10570224050719212, 0.12449990910224984, 0.12449990910224984, 0.12449990910224984, 0.9556184516053425, 0.9556184516053425, 0.9556184516053425, 0.9666797811484902, 0.9666797811484902, 0.9666797811484902, 0.9594880002341954, 0.9594880002341954, 0.9594880002341954, 0.5310061524136087, 0.5310061524136087, 0.5310061524136087, 0.495568683802201, 0.495568683802201, 0.495568683802201, 0.49841232740930264, 0.49841232740930264, 0.49841232740930264, 0.22242094122812428, 0.22242094122812428, 0.22242094122812428, 0.860157036926405, 0.860157036926405, 0.860157036926405, 0.8243580963594292, 0.8243580963594292, 0.8243580963594292, 0.3079981228969879, 0.3079981228969879, 0.3079981228969879, 0.22328455298097405, 0.22328455298097405, 0.22328455298097405, 0.5049962175182446, 0.5049962175182446, 0.5049962175182446, 0.3894622120628004, 0.3894622120628004, 0.3894622120628004, 0.12743271747222784, 0.12743271747222784, 0.12743271747222784, 0.1283848377538357, 0.1283848377538357, 0.1283848377538357, 0.17616339671659498, 0.17616339671659498, 0.17616339671659498, 0.03930351181724456, 0.03930351181724456, 0.03930351181724456, 0.0030483902692942655, 0.0030483902692942655, 0.0030483902692942655, 0.19430213579527822, 0.19430213579527822, 0.19430213579527822, 0.05222592347382493, 0.05222592347382493, 0.05222592347382493, 0.23801972719385645, 0.23801972719385645, 0.23801972719385645, 0.041694306236271905, 0.041694306236271905, 0.041694306236271905, 0.15293419552555043, 0.15293419552555043, 0.15293419552555043, 0.13894100917000118, 0.13894100917000118, 0.13894100917000118, 0.15271748674714802, 0.15271748674714802, 0.15271748674714802, 0.16882078612997087, 0.16882078612997087, 0.16882078612997087, 0.047818079826499216, 0.047818079826499216, 0.047818079826499216, 0.6590356277720644, 0.6590356277720644, 0.6590356277720644, 0.658789445883619, 0.658789445883619, 0.658789445883619, 0.6650660556875285, 0.6650660556875285, 0.6650660556875285, 0.14133317307868454, 0.14133317307868454, 0.14133317307868454, 0.12063262116199203, 0.12063262116199203, 0.12063262116199203, 0.09855540040262945, 0.09855540040262945, 0.09855540040262945, 0.17346955791196883, 0.17346955791196883, 0.17346955791196883, 0.28733874668046466, 0.28733874668046466, 0.28733874668046466, 0.18250831950201518, 0.18250831950201518, 0.18250831950201518, 0.3342842278374142, 0.3342842278374142, 0.3342842278374142, 0.39831944799298247, 0.39831944799298247, 0.39831944799298247, 0.37261767497349085, 0.37261767497349085, 0.37261767497349085, 0.19743685110353926, 0.19743685110353926, 0.19743685110353926, 0.2578758944521644, 0.2578758944521644, 0.2578758944521644, 0.24519810538300413, 0.24519810538300413, 0.24519810538300413, 0.22543947948345255, 0.22543947948345255, 0.22543947948345255, 0.25384802485021196, 0.25384802485021196, 0.25384802485021196, 0.21969984913066265, 0.21969984913066265, 0.21969984913066265, 0.1925456491783235, 0.1925456491783235, 0.1925456491783235, 0.18914538937075487, 0.18914538937075487, 0.18914538937075487, 0.2408047121181932, 0.2408047121181932, 0.2408047121181932, 0.8787834978546479, 0.8787834978546479, 0.8787834978546479, 0.15729324617704954, 0.15729324617704954, 0.15729324617704954, 0.16971427331368072, 0.16971427331368072, 0.16971427331368072, 0.16818920637408696, 0.16818920637408696, 0.16818920637408696, 0.21012867742073948, 0.21012867742073948, 0.21012867742073948, 0.15560296322113631, 0.15560296322113631, 0.15560296322113631, 0.20907203497873095, 0.20907203497873095, 0.20907203497873095, 0.19672487994695498, 0.19672487994695498, 0.19672487994695498, 0.1882338063614567, 0.1882338063614567, 0.1882338063614567, 0.09797831134988577, 0.09797831134988577, 0.09797831134988577, 0.09248719879141132, 0.09248719879141132, 0.09248719879141132, 0.12990170892147068, 0.12990170892147068, 0.12990170892147068]}, "mutation_prompt": null}
{"id": "e850564e-98a0-4ffe-8fff-88a95919dc63", "solution": "import numpy as np\n\nclass HybridMemeticQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6\n        self.cognitive = 1.4\n        self.social = 1.9\n        self.quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.1\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridMemeticQuantumInspiredDSO", "description": "Hybrid Memetic Quantum-Inspired Optimization that integrates local search heuristics and adaptive parameter tuning to enhance convergence.", "configspace": "", "generation": 25, "fitness": 0.3468470383642145, "feedback": "The algorithm HybridMemeticQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8410932117002039, 0.8410932117002039, 0.8410932117002039, 0.8362245899363239, 0.8362245899363239, 0.8362245899363239, 0.8368201245637246, 0.8368201245637246, 0.8368201245637246, 0.5424360828574253, 0.5424360828574253, 0.5424360828574253, 0.4977952282493934, 0.4977952282493934, 0.4977952282493934, 0.4889785243472353, 0.4889785243472353, 0.4889785243472353, 0.11272605764942578, 0.11272605764942578, 0.11272605764942578, 0.09649721524218735, 0.09649721524218735, 0.09649721524218735, 0.16003079483146376, 0.16003079483146376, 0.16003079483146376, 0.07002322085130419, 0.07002322085130419, 0.07002322085130419, 0.07598847801923725, 0.07598847801923725, 0.07598847801923725, 0.10549802789492002, 0.10549802789492002, 0.10549802789492002, 0.9483144503560513, 0.9483144503560513, 0.9483144503560513, 0.9610214312595148, 0.9610214312595148, 0.9610214312595148, 0.9618148266525884, 0.9618148266525884, 0.9618148266525884, 0.6541712790838665, 0.6541712790838665, 0.6541712790838665, 0.5590464668160986, 0.5590464668160986, 0.5590464668160986, 0.5909733873199564, 0.5909733873199564, 0.5909733873199564, 0.7801084849354543, 0.7801084849354543, 0.7801084849354543, 0.21158906848815873, 0.21158906848815873, 0.21158906848815873, 0.2332480470463596, 0.2332480470463596, 0.2332480470463596, 0.4341923086291649, 0.4341923086291649, 0.4341923086291649, 0.45677282210998305, 0.45677282210998305, 0.45677282210998305, 0.13181351893395854, 0.13181351893395854, 0.13181351893395854, 0.4722704383076448, 0.4722704383076448, 0.4722704383076448, 0.5072060801182217, 0.5072060801182217, 0.5072060801182217, 0.5100815116885722, 0.5100815116885722, 0.5100815116885722, 0.06170366613769873, 0.06170366613769873, 0.06170366613769873, 0.054832367358853995, 0.054832367358853995, 0.054832367358853995, 0.06218476113736926, 0.06218476113736926, 0.06218476113736926, 0.19676444341098387, 0.19676444341098387, 0.19676444341098387, 0.40091899998048486, 0.40091899998048486, 0.40091899998048486, 0.2432159370828696, 0.2432159370828696, 0.2432159370828696, 0.052605498762561154, 0.052605498762561154, 0.052605498762561154, 0.1928547890447032, 0.1928547890447032, 0.1928547890447032, 0.2899452664283497, 0.2899452664283497, 0.2899452664283497, 0.13321678284121752, 0.13321678284121752, 0.13321678284121752, 0.1559931130563107, 0.1559931130563107, 0.1559931130563107, 0.10031181100594766, 0.10031181100594766, 0.10031181100594766, 0.6922525502849367, 0.6922525502849367, 0.6922525502849367, 0.6286228484777141, 0.6286228484777141, 0.6286228484777141, 0.6835381539392269, 0.6835381539392269, 0.6835381539392269, 0.10876191586767159, 0.10876191586767159, 0.10876191586767159, 0.1166778328349466, 0.1166778328349466, 0.1166778328349466, 0.06562188544752479, 0.06562188544752479, 0.06562188544752479, 0.23120320664270544, 0.23120320664270544, 0.23120320664270544, 0.19801814035277598, 0.19801814035277598, 0.19801814035277598, 0.2528745475586832, 0.2528745475586832, 0.2528745475586832, 0.260387753284849, 0.260387753284849, 0.260387753284849, 0.3814485534095329, 0.3814485534095329, 0.3814485534095329, 0.27942865875322154, 0.27942865875322154, 0.27942865875322154, 0.23338698647123957, 0.23338698647123957, 0.23338698647123957, 0.2522166805742265, 0.2522166805742265, 0.2522166805742265, 0.20292783641605816, 0.20292783641605816, 0.20292783641605816, 0.22442855123805994, 0.22442855123805994, 0.22442855123805994, 0.21108250647740245, 0.21108250647740245, 0.21108250647740245, 0.22162748510060215, 0.22162748510060215, 0.22162748510060215, 0.24718543859584574, 0.24718543859584574, 0.24718543859584574, 0.19424865260484403, 0.19424865260484403, 0.19424865260484403, 0.21179495329043607, 0.21179495329043607, 0.21179495329043607, 0.9037926465611759, 0.9037926465611759, 0.9037926465611759, 0.15866781059054502, 0.15866781059054502, 0.15866781059054502, 0.8889653053669685, 0.8889653053669685, 0.8889653053669685, 0.794330539443196, 0.794330539443196, 0.794330539443196, 0.21122330417388113, 0.21122330417388113, 0.21122330417388113, 0.1654300489234649, 0.1654300489234649, 0.1654300489234649, 0.20301797664281362, 0.20301797664281362, 0.20301797664281362, 0.20491722288808778, 0.20491722288808778, 0.20491722288808778, 0.21763789204154405, 0.21763789204154405, 0.21763789204154405, 0.11595609502289195, 0.11595609502289195, 0.11595609502289195, 0.09917896255472947, 0.09917896255472947, 0.09917896255472947, 0.09085070625585323, 0.09085070625585323, 0.09085070625585323]}, "mutation_prompt": null}
{"id": "6d5cdfb6-44cb-486c-b8e8-f4309ac82ad9", "solution": "import numpy as np\n\nclass QuantumInspiredHybridDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia_min = 0.3\n        self.inertia_max = 0.9\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia = self.inertia_min + (self.inertia_max - self.inertia_min) * (1 - eval_count / self.budget)\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n            \n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumInspiredHybridDSO", "description": "Quantum-Inspired Hybrid Differential Swarm Optimization with Dynamic Inertia and Adaptive Cognitive-Social Balancing for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 26, "fitness": 0.32654223109482705, "feedback": "The algorithm QuantumInspiredHybridDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7189064211971536, 0.7189064211971536, 0.7189064211971536, 0.7207883653129544, 0.7207883653129544, 0.7207883653129544, 0.729231662064239, 0.729231662064239, 0.729231662064239, 0.31612303190354973, 0.31612303190354973, 0.31612303190354973, 0.03905965809171963, 0.03905965809171963, 0.03905965809171963, 0.37480936757031347, 0.37480936757031347, 0.37480936757031347, 0.1412325726402689, 0.1412325726402689, 0.1412325726402689, 0.08928362289609482, 0.08928362289609482, 0.08928362289609482, 0.14447108582843993, 0.14447108582843993, 0.14447108582843993, 0.11153993726582634, 0.11153993726582634, 0.11153993726582634, 0.09315597406229958, 0.09315597406229958, 0.09315597406229958, 0.08888700005975281, 0.08888700005975281, 0.08888700005975281, 0.9602785288306371, 0.9602785288306371, 0.9602785288306371, 0.9675790860400987, 0.9675790860400987, 0.9675790860400987, 0.9593448353512106, 0.9593448353512106, 0.9593448353512106, 0.5315734028913632, 0.5315734028913632, 0.5315734028913632, 0.5036378886538733, 0.5036378886538733, 0.5036378886538733, 0.5323974637476692, 0.5323974637476692, 0.5323974637476692, 0.6669749173067021, 0.6669749173067021, 0.6669749173067021, 0.7297020102537222, 0.7297020102537222, 0.7297020102537222, 0.6807978317164728, 0.6807978317164728, 0.6807978317164728, 0.33365631529079587, 0.33365631529079587, 0.33365631529079587, 0.3761810105259382, 0.3761810105259382, 0.3761810105259382, 0.46814626644719215, 0.46814626644719215, 0.46814626644719215, 0.20170309094864802, 0.20170309094864802, 0.20170309094864802, 0.3519400498711345, 0.3519400498711345, 0.3519400498711345, 0.4235483277537292, 0.4235483277537292, 0.4235483277537292, 0.04382128891846182, 0.04382128891846182, 0.04382128891846182, 0.3870390984032409, 0.3870390984032409, 0.3870390984032409, 0.14007096334318836, 0.14007096334318836, 0.14007096334318836, 0.168038493626403, 0.168038493626403, 0.168038493626403, 0.13724157917341762, 0.13724157917341762, 0.13724157917341762, 0.23526084840904982, 0.23526084840904982, 0.23526084840904982, 0.1988393239444417, 0.1988393239444417, 0.1988393239444417, 0.07564312858265299, 0.07564312858265299, 0.07564312858265299, 0.05090176228162269, 0.05090176228162269, 0.05090176228162269, 0.21816444120647693, 0.21816444120647693, 0.21816444120647693, 0.035420833642395566, 0.035420833642395566, 0.035420833642395566, 0.07482896518542259, 0.07482896518542259, 0.07482896518542259, 0.513684501960691, 0.513684501960691, 0.513684501960691, 0.5472270457853459, 0.5472270457853459, 0.5472270457853459, 0.5127320032909601, 0.5127320032909601, 0.5127320032909601, 0.09166396296756285, 0.09166396296756285, 0.09166396296756285, 0.11937599151258349, 0.11937599151258349, 0.11937599151258349, 0.09670321142889682, 0.09670321142889682, 0.09670321142889682, 0.4434449454429117, 0.4434449454429117, 0.4434449454429117, 0.3075329981522327, 0.3075329981522327, 0.3075329981522327, 0.2122182297449674, 0.2122182297449674, 0.2122182297449674, 0.361986025319201, 0.361986025319201, 0.361986025319201, 0.36498806415223717, 0.36498806415223717, 0.36498806415223717, 0.34996410767457564, 0.34996410767457564, 0.34996410767457564, 0.28229227400566825, 0.28229227400566825, 0.28229227400566825, 0.27544531956865936, 0.27544531956865936, 0.27544531956865936, 0.1339967133209139, 0.1339967133209139, 0.1339967133209139, 0.2129800386584929, 0.2129800386584929, 0.2129800386584929, 0.21104393752446937, 0.21104393752446937, 0.21104393752446937, 0.24970659836659093, 0.24970659836659093, 0.24970659836659093, 0.20641340975100597, 0.20641340975100597, 0.20641340975100597, 0.2113635067505586, 0.2113635067505586, 0.2113635067505586, 0.2062333486596616, 0.2062333486596616, 0.2062333486596616, 0.8126228013102893, 0.8126228013102893, 0.8126228013102893, 0.1587875374985882, 0.1587875374985882, 0.1587875374985882, 0.16137628689496453, 0.16137628689496453, 0.16137628689496453, 0.1685354509629604, 0.1685354509629604, 0.1685354509629604, 0.7112663792892794, 0.7112663792892794, 0.7112663792892794, 0.7533115289807679, 0.7533115289807679, 0.7533115289807679, 0.17742877984437477, 0.17742877984437477, 0.17742877984437477, 0.18561646216395244, 0.18561646216395244, 0.18561646216395244, 0.19073286606603668, 0.19073286606603668, 0.19073286606603668, 0.08476272860729062, 0.08476272860729062, 0.08476272860729062, 0.08438487700225883, 0.08438487700225883, 0.08438487700225883, 0.09099825493002522, 0.09099825493002522, 0.09099825493002522]}, "mutation_prompt": null}
{"id": "89ad9f21-2211-41b2-9d45-402b185d9064", "solution": "import numpy as np\n\nclass EnhancedQuantumDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6\n        self.cognitive = 1.5\n        self.social = 1.7\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.1\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.95\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumDSO", "description": "Enhanced Quantum Differential Swarm Optimization with adaptive velocity scaling and stochastic ranking for improved exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.3548171988893087, "feedback": "The algorithm EnhancedQuantumDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8165251517993081, 0.8165251517993081, 0.8165251517993081, 0.8047423339989763, 0.8047423339989763, 0.8047423339989763, 0.8187722842009851, 0.8187722842009851, 0.8187722842009851, 0.5418084250426844, 0.5418084250426844, 0.5418084250426844, 0.48421125546544697, 0.48421125546544697, 0.48421125546544697, 0.47852339405402156, 0.47852339405402156, 0.47852339405402156, 0.12877344119678347, 0.12877344119678347, 0.12877344119678347, 0.12135036533206511, 0.12135036533206511, 0.12135036533206511, 0.10881422655613315, 0.10881422655613315, 0.10881422655613315, 0.07111920508667768, 0.07111920508667768, 0.07111920508667768, 0.0928126444066687, 0.0928126444066687, 0.0928126444066687, 0.10440914370287524, 0.10440914370287524, 0.10440914370287524, 0.9246756209034952, 0.9246756209034952, 0.9246756209034952, 0.9529463861977219, 0.9529463861977219, 0.9529463861977219, 0.9628296311922034, 0.9628296311922034, 0.9628296311922034, 0.5831392648752225, 0.5831392648752225, 0.5831392648752225, 0.5942978892393298, 0.5942978892393298, 0.5942978892393298, 0.5683036902034798, 0.5683036902034798, 0.5683036902034798, 0.34572870151850643, 0.34572870151850643, 0.34572870151850643, 0.27356921150896274, 0.27356921150896274, 0.27356921150896274, 0.3841393953626563, 0.3841393953626563, 0.3841393953626563, 0.5878506417149507, 0.5878506417149507, 0.5878506417149507, 0.607827425701754, 0.607827425701754, 0.607827425701754, 0.4558655685068712, 0.4558655685068712, 0.4558655685068712, 0.6167212427686739, 0.6167212427686739, 0.6167212427686739, 0.4733540588268762, 0.4733540588268762, 0.4733540588268762, 0.5470810826130704, 0.5470810826130704, 0.5470810826130704, 0.35309118071966505, 0.35309118071966505, 0.35309118071966505, 0.3249895058632625, 0.3249895058632625, 0.3249895058632625, 0.2965768878514323, 0.2965768878514323, 0.2965768878514323, 0.28345961258869046, 0.28345961258869046, 0.28345961258869046, 0.16792371727590094, 0.16792371727590094, 0.16792371727590094, 0.3047399729220899, 0.3047399729220899, 0.3047399729220899, 0.12341884489151977, 0.12341884489151977, 0.12341884489151977, 0.12334383558984774, 0.12334383558984774, 0.12334383558984774, 0.09080051722706539, 0.09080051722706539, 0.09080051722706539, 0.17937936460442738, 0.17937936460442738, 0.17937936460442738, 0.03714015517408131, 0.03714015517408131, 0.03714015517408131, 0.27418030082164413, 0.27418030082164413, 0.27418030082164413, 0.6786840926827202, 0.6786840926827202, 0.6786840926827202, 0.6609606402619403, 0.6609606402619403, 0.6609606402619403, 0.6848647457323809, 0.6848647457323809, 0.6848647457323809, 0.15477497842969967, 0.15477497842969967, 0.15477497842969967, 0.173306168161799, 0.173306168161799, 0.173306168161799, 0.11232974748395663, 0.11232974748395663, 0.11232974748395663, 0.3957248285151249, 0.3957248285151249, 0.3957248285151249, 0.330397947982922, 0.330397947982922, 0.330397947982922, 0.1996190551705146, 0.1996190551705146, 0.1996190551705146, 0.4426182274663314, 0.4426182274663314, 0.4426182274663314, 0.4577924266671626, 0.4577924266671626, 0.4577924266671626, 0.28333602980036, 0.28333602980036, 0.28333602980036, 0.3277130484346461, 0.3277130484346461, 0.3277130484346461, 0.4033199799477869, 0.4033199799477869, 0.4033199799477869, 0.2723433178476934, 0.2723433178476934, 0.2723433178476934, 0.23831430471509163, 0.23831430471509163, 0.23831430471509163, 0.2366378079690863, 0.2366378079690863, 0.2366378079690863, 0.22839220234113333, 0.22839220234113333, 0.22839220234113333, 0.19812821414921766, 0.19812821414921766, 0.19812821414921766, 0.20227699585854653, 0.20227699585854653, 0.20227699585854653, 0.19717204278899048, 0.19717204278899048, 0.19717204278899048, 0.8976757516392755, 0.8976757516392755, 0.8976757516392755, 0.14783133667927595, 0.14783133667927595, 0.14783133667927595, 0.1758956004823904, 0.1758956004823904, 0.1758956004823904, 0.15501248841985094, 0.15501248841985094, 0.15501248841985094, 0.21127831831900534, 0.21127831831900534, 0.21127831831900534, 0.15598016199925713, 0.15598016199925713, 0.15598016199925713, 0.20400112410522986, 0.20400112410522986, 0.20400112410522986, 0.2031857555502815, 0.2031857555502815, 0.2031857555502815, 0.2082514696286677, 0.2082514696286677, 0.2082514696286677, 0.10222663641963503, 0.10222663641963503, 0.10222663641963503, 0.0926520526763519, 0.0926520526763519, 0.0926520526763519, 0.10490524419786995, 0.10490524419786995, 0.10490524419786995]}, "mutation_prompt": null}
{"id": "929c6fdb-c3ee-4024-ad01-389d2616caaf", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6  # Adaptive inertia change\n        self.cognitive = 1.2\n        self.social = 2.1\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.1  # Reduced max velocity\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] *= np.exp(-eval_count / self.budget)  # Adaptive velocity control\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and mutation for improved convergence.", "configspace": "", "generation": 28, "fitness": 0.3408919505565108, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.855533900293004, 0.855533900293004, 0.855533900293004, 0.8467199999275601, 0.8467199999275601, 0.8467199999275601, 0.8568464136281226, 0.8568464136281226, 0.8568464136281226, 0.6068476374848737, 0.6068476374848737, 0.6068476374848737, 0.6663695080602605, 0.6663695080602605, 0.6663695080602605, 0.6644837709296869, 0.6644837709296869, 0.6644837709296869, 0.11581683255506958, 0.11581683255506958, 0.11581683255506958, 0.11015623290923593, 0.11015623290923593, 0.11015623290923593, 0.12887137858315678, 0.12887137858315678, 0.12887137858315678, 0.11113624361142216, 0.11113624361142216, 0.11113624361142216, 0.11244609075612644, 0.11244609075612644, 0.11244609075612644, 0.09999661134327598, 0.09999661134327598, 0.09999661134327598, 0.9612851645853494, 0.9612851645853494, 0.9612851645853494, 0.9583738660313283, 0.9583738660313283, 0.9583738660313283, 0.937479908564012, 0.937479908564012, 0.937479908564012, 0.6951565443221268, 0.6951565443221268, 0.6951565443221268, 0.7273611076297454, 0.7273611076297454, 0.7273611076297454, 0.685546907924516, 0.685546907924516, 0.685546907924516, 0.8588686869874068, 0.8588686869874068, 0.8588686869874068, 0.20152960069353054, 0.20152960069353054, 0.20152960069353054, 0.1754665393971132, 0.1754665393971132, 0.1754665393971132, 0.13113385181742632, 0.13113385181742632, 0.13113385181742632, 0.2490602713793162, 0.2490602713793162, 0.2490602713793162, 0.12545400258091355, 0.12545400258091355, 0.12545400258091355, 0.11572540061981185, 0.11572540061981185, 0.11572540061981185, 0.34019988897692, 0.34019988897692, 0.34019988897692, 0.13331194949339675, 0.13331194949339675, 0.13331194949339675, 0.17099669155113084, 0.17099669155113084, 0.17099669155113084, 0.06588800551247409, 0.06588800551247409, 0.06588800551247409, 0.08511175541681382, 0.08511175541681382, 0.08511175541681382, 0.2973278266140046, 0.2973278266140046, 0.2973278266140046, 0.059183456759342, 0.059183456759342, 0.059183456759342, 0.17339947719954418, 0.17339947719954418, 0.17339947719954418, 0.0469558188006749, 0.0469558188006749, 0.0469558188006749, 0.10052088528713266, 0.10052088528713266, 0.10052088528713266, 0.12968441532388042, 0.12968441532388042, 0.12968441532388042, 0.1630561975753242, 0.1630561975753242, 0.1630561975753242, 0.33507408845993925, 0.33507408845993925, 0.33507408845993925, 0.2677579888799453, 0.2677579888799453, 0.2677579888799453, 0.6901980522593597, 0.6901980522593597, 0.6901980522593597, 0.5772913537175346, 0.5772913537175346, 0.5772913537175346, 0.6534079016876093, 0.6534079016876093, 0.6534079016876093, 0.1308789410250354, 0.1308789410250354, 0.1308789410250354, 0.10935601796105787, 0.10935601796105787, 0.10935601796105787, 0.0935196602159507, 0.0935196602159507, 0.0935196602159507, 0.5062229837527386, 0.5062229837527386, 0.5062229837527386, 0.3835143235279105, 0.3835143235279105, 0.3835143235279105, 0.3518503262144531, 0.3518503262144531, 0.3518503262144531, 0.2801342419775036, 0.2801342419775036, 0.2801342419775036, 0.4702987296588802, 0.4702987296588802, 0.4702987296588802, 0.2783980938566719, 0.2783980938566719, 0.2783980938566719, 0.4355698985940182, 0.4355698985940182, 0.4355698985940182, 0.23181766876555943, 0.23181766876555943, 0.23181766876555943, 0.19405035874009469, 0.19405035874009469, 0.19405035874009469, 0.2810432528131356, 0.2810432528131356, 0.2810432528131356, 0.2055498653202137, 0.2055498653202137, 0.2055498653202137, 0.2761060641603522, 0.2761060641603522, 0.2761060641603522, 0.19734898800658784, 0.19734898800658784, 0.19734898800658784, 0.19894629083537718, 0.19894629083537718, 0.19894629083537718, 0.18462920770626434, 0.18462920770626434, 0.18462920770626434, 0.9194667367601292, 0.9194667367601292, 0.9194667367601292, 0.17248489583407045, 0.17248489583407045, 0.17248489583407045, 0.9033550659181958, 0.9033550659181958, 0.9033550659181958, 0.155458844597813, 0.155458844597813, 0.155458844597813, 0.2111172337484346, 0.2111172337484346, 0.2111172337484346, 0.1563602092919535, 0.1563602092919535, 0.1563602092919535, 0.2408065138348039, 0.2408065138348039, 0.2408065138348039, 0.20080554059409583, 0.20080554059409583, 0.20080554059409583, 0.22886187107790412, 0.22886187107790412, 0.22886187107790412, 0.10598479112662829, 0.10598479112662829, 0.10598479112662829, 0.08425354938193863, 0.08425354938193863, 0.08425354938193863, 0.06899804864158121, 0.06899804864158121, 0.06899804864158121]}, "mutation_prompt": null}
{"id": "74515246-71d1-404e-a99f-0aca7dc2aaac", "solution": "import numpy as np\n\nclass ImprovedAdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.max_velocity, self.max_velocity, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "ImprovedAdaptiveQuantumInspiredDSO", "description": "Adaptive Quantum-Inspired Differential Swarm Optimization with enhanced exploration-exploitation balance and adaptive control parameters for improved convergence.", "configspace": "", "generation": 29, "fitness": 0.2632274937823963, "feedback": "The algorithm ImprovedAdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.6563668977686434, 0.6563668977686434, 0.6563668977686434, 0.6146337326347432, 0.6146337326347432, 0.6146337326347432, 0.6581473875557806, 0.6581473875557806, 0.6581473875557806, 0.0843659834010192, 0.0843659834010192, 0.0843659834010192, 0.1482990144945917, 0.1482990144945917, 0.1482990144945917, 0.10681353110557212, 0.10681353110557212, 0.10681353110557212, 0.09889191429053934, 0.09889191429053934, 0.09889191429053934, 0.11100942574713057, 0.11100942574713057, 0.11100942574713057, 0.08780409567425718, 0.08780409567425718, 0.08780409567425718, 0.09944799015186512, 0.09944799015186512, 0.09944799015186512, 0.09214823282939744, 0.09214823282939744, 0.09214823282939744, 0.09896651278140112, 0.09896651278140112, 0.09896651278140112, 0.9655207802856527, 0.9655207802856527, 0.9655207802856527, 0.9731288127172545, 0.9731288127172545, 0.9731288127172545, 0.9757539661544321, 0.9757539661544321, 0.9757539661544321, 0.32027474666041267, 0.32027474666041267, 0.32027474666041267, 0.36328958494639096, 0.36328958494639096, 0.36328958494639096, 0.3575176032983064, 0.3575176032983064, 0.3575176032983064, 0.7310663167666518, 0.7310663167666518, 0.7310663167666518, 0.17877368518827697, 0.17877368518827697, 0.17877368518827697, 0.6258708324906004, 0.6258708324906004, 0.6258708324906004, 0.2381632896137328, 0.2381632896137328, 0.2381632896137328, 0.12719569673950337, 0.12719569673950337, 0.12719569673950337, 0.2418012009551107, 0.2418012009551107, 0.2418012009551107, 0.2886470269925927, 0.2886470269925927, 0.2886470269925927, 0.1277524333548017, 0.1277524333548017, 0.1277524333548017, 0.2414979225282562, 0.2414979225282562, 0.2414979225282562, 0.05712804092661494, 0.05712804092661494, 0.05712804092661494, 0.07201677858636646, 0.07201677858636646, 0.07201677858636646, 0.2100374712878582, 0.2100374712878582, 0.2100374712878582, 0.17780367048025802, 0.17780367048025802, 0.17780367048025802, 0.04417450109236176, 0.04417450109236176, 0.04417450109236176, 0.11551962613651745, 0.11551962613651745, 0.11551962613651745, 0.03184566457656224, 0.03184566457656224, 0.03184566457656224, 0.09702809212973984, 0.09702809212973984, 0.09702809212973984, 0.08616207038227386, 0.08616207038227386, 0.08616207038227386, 0.18806640083848847, 0.18806640083848847, 0.18806640083848847, 0.03474138037786856, 0.03474138037786856, 0.03474138037786856, 0.050645868185964726, 0.050645868185964726, 0.050645868185964726, 0.5223704100904563, 0.5223704100904563, 0.5223704100904563, 0.5263435045353113, 0.5263435045353113, 0.5263435045353113, 0.4809240393869473, 0.4809240393869473, 0.4809240393869473, 0.13267799319836882, 0.13267799319836882, 0.13267799319836882, 0.12901038697484568, 0.12901038697484568, 0.12901038697484568, 0.08473178273350279, 0.08473178273350279, 0.08473178273350279, 0.2848949847825708, 0.2848949847825708, 0.2848949847825708, 0.2546354657395663, 0.2546354657395663, 0.2546354657395663, 0.19054679713921308, 0.19054679713921308, 0.19054679713921308, 0.35961808340430157, 0.35961808340430157, 0.35961808340430157, 0.35291344160967575, 0.35291344160967575, 0.35291344160967575, 0.31487375521018257, 0.31487375521018257, 0.31487375521018257, 0.2195054785515005, 0.2195054785515005, 0.2195054785515005, 0.272741586681861, 0.272741586681861, 0.272741586681861, 0.19188501985561002, 0.19188501985561002, 0.19188501985561002, 0.19360113824166825, 0.19360113824166825, 0.19360113824166825, 0.21509784988289604, 0.21509784988289604, 0.21509784988289604, 0.23320789801046182, 0.23320789801046182, 0.23320789801046182, 0.1982492280892726, 0.1982492280892726, 0.1982492280892726, 0.20441074561752737, 0.20441074561752737, 0.20441074561752737, 0.18461730107304675, 0.18461730107304675, 0.18461730107304675, 0.83484390348478, 0.83484390348478, 0.83484390348478, 0.1586208572210568, 0.1586208572210568, 0.1586208572210568, 0.1696708307183058, 0.1696708307183058, 0.1696708307183058, 0.20901444125658986, 0.20901444125658986, 0.20901444125658986, 0.20864968909552584, 0.20864968909552584, 0.20864968909552584, 0.15694559587714718, 0.15694559587714718, 0.15694559587714718, 0.19093956196614892, 0.19093956196614892, 0.19093956196614892, 0.21393176776417477, 0.21393176776417477, 0.21393176776417477, 0.19293244123284803, 0.19293244123284803, 0.19293244123284803, 0.0882315918995068, 0.0882315918995068, 0.0882315918995068, 0.0798027016665086, 0.0798027016665086, 0.0798027016665086, 0.12362109721336256, 0.12362109721336256, 0.12362109721336256]}, "mutation_prompt": null}
{"id": "83bea9f3-ff25-4689-8e87-0ff6de5cc9b8", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Adjusted for exploration\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.3  # Increased quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive inertia and dynamic crossover for improved exploration-exploitation balance.", "configspace": "", "generation": 30, "fitness": 0.2950582411725369, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7440177926201166, 0.7440177926201166, 0.7440177926201166, 0.7304427506984685, 0.7304427506984685, 0.7304427506984685, 0.7523530235967153, 0.7523530235967153, 0.7523530235967153, 0.03136781711885994, 0.03136781711885994, 0.03136781711885994, 0.23631552690702584, 0.23631552690702584, 0.23631552690702584, 0.27261091260075176, 0.27261091260075176, 0.27261091260075176, 0.11100184855228612, 0.11100184855228612, 0.11100184855228612, 0.10888828559386532, 0.10888828559386532, 0.10888828559386532, 0.11200154176263877, 0.11200154176263877, 0.11200154176263877, 0.10963394888727018, 0.10963394888727018, 0.10963394888727018, 0.07825395134772484, 0.07825395134772484, 0.07825395134772484, 0.13328035654528125, 0.13328035654528125, 0.13328035654528125, 0.9594049047336218, 0.9594049047336218, 0.9594049047336218, 0.9673565841420277, 0.9673565841420277, 0.9673565841420277, 0.9605523336594757, 0.9605523336594757, 0.9605523336594757, 0.4818502054000975, 0.4818502054000975, 0.4818502054000975, 0.4037098333173055, 0.4037098333173055, 0.4037098333173055, 0.47618615612439086, 0.47618615612439086, 0.47618615612439086, 0.7443728822073254, 0.7443728822073254, 0.7443728822073254, 0.20313240776248953, 0.20313240776248953, 0.20313240776248953, 0.23271501861714783, 0.23271501861714783, 0.23271501861714783, 0.1280438715126907, 0.1280438715126907, 0.1280438715126907, 0.4031608831779939, 0.4031608831779939, 0.4031608831779939, 0.33936548806509337, 0.33936548806509337, 0.33936548806509337, 0.09673421556614192, 0.09673421556614192, 0.09673421556614192, 0.13251933810439764, 0.13251933810439764, 0.13251933810439764, 0.3417769942913631, 0.3417769942913631, 0.3417769942913631, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14982710670555965, 0.14982710670555965, 0.14982710670555965, 0.10012609086336033, 0.10012609086336033, 0.10012609086336033, 0.2060596365260795, 0.2060596365260795, 0.2060596365260795, 0.15781214953612688, 0.15781214953612688, 0.15781214953612688, 0.17768188246117367, 0.17768188246117367, 0.17768188246117367, 0.08899975589714904, 0.08899975589714904, 0.08899975589714904, 0.06639808999230679, 0.06639808999230679, 0.06639808999230679, 0.06764673197655424, 0.06764673197655424, 0.06764673197655424, 0.2378382339999101, 0.2378382339999101, 0.2378382339999101, 0.035846552688398536, 0.035846552688398536, 0.035846552688398536, 0.047591809339133984, 0.047591809339133984, 0.047591809339133984, 0.5733798825623679, 0.5733798825623679, 0.5733798825623679, 0.5345009088770976, 0.5345009088770976, 0.5345009088770976, 0.539934942652422, 0.539934942652422, 0.539934942652422, 0.12062745993986568, 0.12062745993986568, 0.12062745993986568, 0.10320986713118818, 0.10320986713118818, 0.10320986713118818, 0.12404327546765559, 0.12404327546765559, 0.12404327546765559, 0.3095177299509123, 0.3095177299509123, 0.3095177299509123, 0.2092041564175633, 0.2092041564175633, 0.2092041564175633, 0.3205356682548084, 0.3205356682548084, 0.3205356682548084, 0.3168947071192709, 0.3168947071192709, 0.3168947071192709, 0.33469781070598725, 0.33469781070598725, 0.33469781070598725, 0.23517460305180138, 0.23517460305180138, 0.23517460305180138, 0.28439294140211624, 0.28439294140211624, 0.28439294140211624, 0.24114783059017375, 0.24114783059017375, 0.24114783059017375, 0.2810643336033982, 0.2810643336033982, 0.2810643336033982, 0.20346192817428488, 0.20346192817428488, 0.20346192817428488, 0.24057202863167926, 0.24057202863167926, 0.24057202863167926, 0.21571717843206972, 0.21571717843206972, 0.21571717843206972, 0.20388025746294736, 0.20388025746294736, 0.20388025746294736, 0.19877236164339573, 0.19877236164339573, 0.19877236164339573, 0.18472922905325317, 0.18472922905325317, 0.18472922905325317, 0.8537331204062749, 0.8537331204062749, 0.8537331204062749, 0.15741429648911764, 0.15741429648911764, 0.15741429648911764, 0.8482760687462733, 0.8482760687462733, 0.8482760687462733, 0.1686317708716213, 0.1686317708716213, 0.1686317708716213, 0.2105910106697395, 0.2105910106697395, 0.2105910106697395, 0.7443513956060568, 0.7443513956060568, 0.7443513956060568, 0.19998491802313068, 0.19998491802313068, 0.19998491802313068, 0.18286219269356285, 0.18286219269356285, 0.18286219269356285, 0.18158049057930603, 0.18158049057930603, 0.18158049057930603, 0.10920691096150748, 0.10920691096150748, 0.10920691096150748, 0.09251888427689503, 0.09251888427689503, 0.09251888427689503, 0.09260629107659057, 0.09260629107659057, 0.09260629107659057]}, "mutation_prompt": null}
{"id": "cf78a13e-ac73-4c8c-ab08-78325da2c981", "solution": "import numpy as np\n\nclass QuantumPerturbatedSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 35  # Slightly reduced number of particles\n        self.inertia = 0.6  # Adjusted inertia for better balance\n        self.cognitive = 1.5  # Slightly increased cognitive factor\n        self.social = 1.8  # Slightly reduced social factor\n        self.quantum_prob = 0.3  # Adjusted quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased maximum velocity\n        self.de_mutation_factor = 0.9  # Slightly increased mutation factor\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = np.copy(quantum_position)\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = np.copy(trial_vector)\n                        personal_best_positions[i] = np.copy(trial_vector)\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumPerturbatedSwarm", "description": "Quantum Perturbated Swarm with Adaptive Differential Mutation enhancing search diversity and convergence speed.", "configspace": "", "generation": 31, "fitness": 0.3266568471701013, "feedback": "The algorithm QuantumPerturbatedSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8302743870963143, 0.8302743870963143, 0.8302743870963143, 0.7990210878509896, 0.7990210878509896, 0.7990210878509896, 0.8285407785858937, 0.8285407785858937, 0.8285407785858937, 0.306384527706939, 0.306384527706939, 0.306384527706939, 0.497996505715668, 0.497996505715668, 0.497996505715668, 0.4690883820849311, 0.4690883820849311, 0.4690883820849311, 0.11605745670134893, 0.11605745670134893, 0.11605745670134893, 0.07864059731616291, 0.07864059731616291, 0.07864059731616291, 0.10910510043880517, 0.10910510043880517, 0.10910510043880517, 0.09869778712963195, 0.09869778712963195, 0.09869778712963195, 0.08167780684880255, 0.08167780684880255, 0.08167780684880255, 0.13039119231137086, 0.13039119231137086, 0.13039119231137086, 0.976122377398597, 0.976122377398597, 0.976122377398597, 0.9786676944086521, 0.9786676944086521, 0.9786676944086521, 0.966050532780147, 0.966050532780147, 0.966050532780147, 0.5274961835666455, 0.5274961835666455, 0.5274961835666455, 0.5992251431913544, 0.5992251431913544, 0.5992251431913544, 0.5688830617334987, 0.5688830617334987, 0.5688830617334987, 0.3684563971313477, 0.3684563971313477, 0.3684563971313477, 0.16162414909358902, 0.16162414909358902, 0.16162414909358902, 0.22872226055122513, 0.22872226055122513, 0.22872226055122513, 0.4476819615605949, 0.4476819615605949, 0.4476819615605949, 0.13118889390246913, 0.13118889390246913, 0.13118889390246913, 0.1329815413242761, 0.1329815413242761, 0.1329815413242761, 0.35165061129441766, 0.35165061129441766, 0.35165061129441766, 0.5102551106966307, 0.5102551106966307, 0.5102551106966307, 0.5055243973499497, 0.5055243973499497, 0.5055243973499497, 0.09093644134457357, 0.09093644134457357, 0.09093644134457357, 0.03674301709451411, 0.03674301709451411, 0.03674301709451411, 0.2506224987212008, 0.2506224987212008, 0.2506224987212008, 0.298051865912766, 0.298051865912766, 0.298051865912766, 0.24031093443434481, 0.24031093443434481, 0.24031093443434481, 0.5197924879436309, 0.5197924879436309, 0.5197924879436309, 0.11888677417786597, 0.11888677417786597, 0.11888677417786597, 0.15370911985744273, 0.15370911985744273, 0.15370911985744273, 0.1797887554619767, 0.1797887554619767, 0.1797887554619767, 0.21351780563163625, 0.21351780563163625, 0.21351780563163625, 0.038124798342205946, 0.038124798342205946, 0.038124798342205946, 0.17250897550608935, 0.17250897550608935, 0.17250897550608935, 0.7175277837218847, 0.7175277837218847, 0.7175277837218847, 0.6639231324961272, 0.6639231324961272, 0.6639231324961272, 0.7249423793835561, 0.7249423793835561, 0.7249423793835561, 0.093350203544875, 0.093350203544875, 0.093350203544875, 0.12927285204321748, 0.12927285204321748, 0.12927285204321748, 0.11650233628421813, 0.11650233628421813, 0.11650233628421813, 0.3582685421998074, 0.3582685421998074, 0.3582685421998074, 0.18966833306232045, 0.18966833306232045, 0.18966833306232045, 0.5797658640965453, 0.5797658640965453, 0.5797658640965453, 0.256041697979409, 0.256041697979409, 0.256041697979409, 0.47547839465265196, 0.47547839465265196, 0.47547839465265196, 0.45900739824152836, 0.45900739824152836, 0.45900739824152836, 0.27372765271585553, 0.27372765271585553, 0.27372765271585553, 0.20674451966433005, 0.20674451966433005, 0.20674451966433005, 0.12668791207327723, 0.12668791207327723, 0.12668791207327723, 0.22296362987543594, 0.22296362987543594, 0.22296362987543594, 0.22105947048904573, 0.22105947048904573, 0.22105947048904573, 0.20960052401478502, 0.20960052401478502, 0.20960052401478502, 0.2446455691248548, 0.2446455691248548, 0.2446455691248548, 0.24302118945930418, 0.24302118945930418, 0.24302118945930418, 0.1911641122465919, 0.1911641122465919, 0.1911641122465919, 0.8874098400294077, 0.8874098400294077, 0.8874098400294077, 0.15821399777820921, 0.15821399777820921, 0.15821399777820921, 0.19967504802582714, 0.19967504802582714, 0.19967504802582714, 0.1692220015655228, 0.1692220015655228, 0.1692220015655228, 0.21301780599449482, 0.21301780599449482, 0.21301780599449482, 0.15576169609080082, 0.15576169609080082, 0.15576169609080082, 0.19732816056906644, 0.19732816056906644, 0.19732816056906644, 0.20656509249774813, 0.20656509249774813, 0.20656509249774813, 0.222052411620549, 0.222052411620549, 0.222052411620549, 0.09399986609430833, 0.09399986609430833, 0.09399986609430833, 0.09808392401955734, 0.09808392401955734, 0.09808392401955734, 0.10120025439367897, 0.10120025439367897, 0.10120025439367897]}, "mutation_prompt": null}
{"id": "cb09c22b-f2df-43ed-bc44-b61ee4aabad3", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased particle count for better exploration\n        self.inertia = 0.7  # Increased inertia for more stable exploration\n        self.cognitive = 1.2\n        self.social = 1.8\n        self.quantum_prob = 0.3  # Increased quantum probability for more frequent global jumps\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced max velocity for finer adjustments\n        self.de_mutation_factor = 0.9  # Adjusted mutation factor for more diversity\n        self.de_crossover_rate = 0.85  # Adjusted crossover rate for more effective recombination\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.5, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with dynamic parameter tuning for improved convergence efficiency.", "configspace": "", "generation": 32, "fitness": 0.29219151512252795, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.6953957614635851, 0.6953957614635851, 0.6953957614635851, 0.7283963794017975, 0.7283963794017975, 0.7283963794017975, 0.7112999745252553, 0.7112999745252553, 0.7112999745252553, 0.2744505450043552, 0.2744505450043552, 0.2744505450043552, 0.23025758596449963, 0.23025758596449963, 0.23025758596449963, 0.25603658727527845, 0.25603658727527845, 0.25603658727527845, 0.10261070474150269, 0.10261070474150269, 0.10261070474150269, 0.10669618452058316, 0.10669618452058316, 0.10669618452058316, 0.14330788389287374, 0.14330788389287374, 0.14330788389287374, 0.13234710475324196, 0.13234710475324196, 0.13234710475324196, 0.0889905255488822, 0.0889905255488822, 0.0889905255488822, 0.11152933035229329, 0.11152933035229329, 0.11152933035229329, 0.9462719598430177, 0.9462719598430177, 0.9462719598430177, 0.9634235646840844, 0.9634235646840844, 0.9634235646840844, 0.9377851085625665, 0.9377851085625665, 0.9377851085625665, 0.4529139881677827, 0.4529139881677827, 0.4529139881677827, 0.47113951910292007, 0.47113951910292007, 0.47113951910292007, 0.45188433459450394, 0.45188433459450394, 0.45188433459450394, 0.7596265169096702, 0.7596265169096702, 0.7596265169096702, 0.16025619200599517, 0.16025619200599517, 0.16025619200599517, 0.5335263767217215, 0.5335263767217215, 0.5335263767217215, 0.12953221847488672, 0.12953221847488672, 0.12953221847488672, 0.30204744335929234, 0.30204744335929234, 0.30204744335929234, 0.1306939579842783, 0.1306939579842783, 0.1306939579842783, 0.37373661907368294, 0.37373661907368294, 0.37373661907368294, 0.29531518144856694, 0.29531518144856694, 0.29531518144856694, 0.10630420578841315, 0.10630420578841315, 0.10630420578841315, 0.22572765667336048, 0.22572765667336048, 0.22572765667336048, 0.04596523303524336, 0.04596523303524336, 0.04596523303524336, 0.18689713464484004, 0.18689713464484004, 0.18689713464484004, 0.26115997209112973, 0.26115997209112973, 0.26115997209112973, 0.04523283103943121, 0.04523283103943121, 0.04523283103943121, 0.19030076178235267, 0.19030076178235267, 0.19030076178235267, 0.050141825943755824, 0.050141825943755824, 0.050141825943755824, 0.10402304461978729, 0.10402304461978729, 0.10402304461978729, 0.12067877545413863, 0.12067877545413863, 0.12067877545413863, 0.12584290072222992, 0.12584290072222992, 0.12584290072222992, 0.18388017132219103, 0.18388017132219103, 0.18388017132219103, 0.1705522108407579, 0.1705522108407579, 0.1705522108407579, 0.5406056630696627, 0.5406056630696627, 0.5406056630696627, 0.5679019955751918, 0.5679019955751918, 0.5679019955751918, 0.5611407589044257, 0.5611407589044257, 0.5611407589044257, 0.12570474527037623, 0.12570474527037623, 0.12570474527037623, 0.11345761872732563, 0.11345761872732563, 0.11345761872732563, 0.09469000107443393, 0.09469000107443393, 0.09469000107443393, 0.4037907291717737, 0.4037907291717737, 0.4037907291717737, 0.20714256399755626, 0.20714256399755626, 0.20714256399755626, 0.39877462989781676, 0.39877462989781676, 0.39877462989781676, 0.3668265608283511, 0.3668265608283511, 0.3668265608283511, 0.29755442718629244, 0.29755442718629244, 0.29755442718629244, 0.3823827778724038, 0.3823827778724038, 0.3823827778724038, 0.19668202844114913, 0.19668202844114913, 0.19668202844114913, 0.19278330992388026, 0.19278330992388026, 0.19278330992388026, 0.30188756765027513, 0.30188756765027513, 0.30188756765027513, 0.2144811066234642, 0.2144811066234642, 0.2144811066234642, 0.224793919047099, 0.224793919047099, 0.224793919047099, 0.20296702349850193, 0.20296702349850193, 0.20296702349850193, 0.40159518522311655, 0.40159518522311655, 0.40159518522311655, 0.1905273301605671, 0.1905273301605671, 0.1905273301605671, 0.18290185674619042, 0.18290185674619042, 0.18290185674619042, 0.8350598705415732, 0.8350598705415732, 0.8350598705415732, 0.15793526349702935, 0.15793526349702935, 0.15793526349702935, 0.16961256626150312, 0.16961256626150312, 0.16961256626150312, 0.15513110001689379, 0.15513110001689379, 0.15513110001689379, 0.21153627942316477, 0.21153627942316477, 0.21153627942316477, 0.15619319600387993, 0.15619319600387993, 0.15619319600387993, 0.20640562605405655, 0.20640562605405655, 0.20640562605405655, 0.18811850746829795, 0.18811850746829795, 0.18811850746829795, 0.19194102131895474, 0.19194102131895474, 0.19194102131895474, 0.08363738758048278, 0.08363738758048278, 0.08363738758048278, 0.09454112067949538, 0.09454112067949538, 0.09454112067949538, 0.11290707875207517, 0.11290707875207517, 0.11290707875207517]}, "mutation_prompt": null}
{"id": "aa215ab4-b555-48f9-ac7d-ee39bbe7fd92", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = min(50, max(10, dim * 2))\n        self.inertia = 0.6\n        self.cognitive = 1.4\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * np.linspace(0.2, 0.05, self.budget)\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n        velocity_index = 0\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity[velocity_index], self.max_velocity[velocity_index])\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n            velocity_index = min(velocity_index + 1, len(self.max_velocity) - 1)\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity limits and dynamic population size for improved exploration and exploitation.", "configspace": "", "generation": 33, "fitness": 0.3368908982179801, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.31.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.92832480440361, 0.92832480440361, 0.92832480440361, 0.9231253380848178, 0.9231253380848178, 0.9231253380848178, 0.9338857746507188, 0.9338857746507188, 0.9338857746507188, 0.044761249329464015, 0.044761249329464015, 0.044761249329464015, 0.8160731665786971, 0.8160731665786971, 0.8160731665786971, 0.8296036407729138, 0.8296036407729138, 0.8296036407729138, 0.10066222939711245, 0.10066222939711245, 0.10066222939711245, 0.10201014063322056, 0.10201014063322056, 0.10201014063322056, 0.06972490675782606, 0.06972490675782606, 0.06972490675782606, 0.11475402915263588, 0.11475402915263588, 0.11475402915263588, 0.11150244059771286, 0.11150244059771286, 0.11150244059771286, 0.07976913965470145, 0.07976913965470145, 0.07976913965470145, 0.9759425028957148, 0.9759425028957148, 0.9759425028957148, 0.9896440457368452, 0.9896440457368452, 0.9896440457368452, 0.9891012552046858, 0.9891012552046858, 0.9891012552046858, 0.8337662448697716, 0.8337662448697716, 0.8337662448697716, 0.6331376836550353, 0.6331376836550353, 0.6331376836550353, 0.7831245638281483, 0.7831245638281483, 0.7831245638281483, 0.20776838907759043, 0.20776838907759043, 0.20776838907759043, 0.2654545373159558, 0.2654545373159558, 0.2654545373159558, 0.24691826900053748, 0.24691826900053748, 0.24691826900053748, 0.13521801126347732, 0.13521801126347732, 0.13521801126347732, 0.13660310643100615, 0.13660310643100615, 0.13660310643100615, 0.13550706251983868, 0.13550706251983868, 0.13550706251983868, 0.7630430449497073, 0.7630430449497073, 0.7630430449497073, 0.6638337359790805, 0.6638337359790805, 0.6638337359790805, 0.5544229449349937, 0.5544229449349937, 0.5544229449349937, 0.2803068227065315, 0.2803068227065315, 0.2803068227065315, 0.07971583700742157, 0.07971583700742157, 0.07971583700742157, 0.08980573170141071, 0.08980573170141071, 0.08980573170141071, 0.38630623127095276, 0.38630623127095276, 0.38630623127095276, 0.08370340444876367, 0.08370340444876367, 0.08370340444876367, 0.1717173835366217, 0.1717173835366217, 0.1717173835366217, 0.15256084279105253, 0.15256084279105253, 0.15256084279105253, 0.10483448964808872, 0.10483448964808872, 0.10483448964808872, 0.10431268146595507, 0.10431268146595507, 0.10431268146595507, 0.1354631718184508, 0.1354631718184508, 0.1354631718184508, 0.006785806987528287, 0.006785806987528287, 0.006785806987528287, 0.17660231384900416, 0.17660231384900416, 0.17660231384900416, 0.746650132675406, 0.746650132675406, 0.746650132675406, 0.595686144851924, 0.595686144851924, 0.595686144851924, 0.8664410468135864, 0.8664410468135864, 0.8664410468135864, 0.09347216999188712, 0.09347216999188712, 0.09347216999188712, 0.09712545764319436, 0.09712545764319436, 0.09712545764319436, 0.14172431972445443, 0.14172431972445443, 0.14172431972445443, 0.3525335383236371, 0.3525335383236371, 0.3525335383236371, 0.17734199607772605, 0.17734199607772605, 0.17734199607772605, 0.1668694978023243, 0.1668694978023243, 0.1668694978023243, 0.28492579048475286, 0.28492579048475286, 0.28492579048475286, 0.22093146760685667, 0.22093146760685667, 0.22093146760685667, 0.30296496139852824, 0.30296496139852824, 0.30296496139852824, 0.16047520874388155, 0.16047520874388155, 0.16047520874388155, 0.16153640872533992, 0.16153640872533992, 0.16153640872533992, 0.0971193605549403, 0.0971193605549403, 0.0971193605549403, 0.25219880480790047, 0.25219880480790047, 0.25219880480790047, 0.2133774486228509, 0.2133774486228509, 0.2133774486228509, 0.19301672959785765, 0.19301672959785765, 0.19301672959785765, 0.17765089425652147, 0.17765089425652147, 0.17765089425652147, 0.18616911560208105, 0.18616911560208105, 0.18616911560208105, 0.1872872645379714, 0.1872872645379714, 0.1872872645379714, 0.15371299380605308, 0.15371299380605308, 0.15371299380605308, 0.1664738441293624, 0.1664738441293624, 0.1664738441293624, 0.15441970291499196, 0.15441970291499196, 0.15441970291499196, 0.8644533262567013, 0.8644533262567013, 0.8644533262567013, 0.21172898676752738, 0.21172898676752738, 0.21172898676752738, 0.9463336649516635, 0.9463336649516635, 0.9463336649516635, 0.2233038762367403, 0.2233038762367403, 0.2233038762367403, 0.18983999793375683, 0.18983999793375683, 0.18983999793375683, 0.21715150277279383, 0.21715150277279383, 0.21715150277279383, 0.11096276629956825, 0.11096276629956825, 0.11096276629956825, 0.11209388535855047, 0.11209388535855047, 0.11209388535855047, 0.09037539051563181, 0.09037539051563181, 0.09037539051563181]}, "mutation_prompt": null}
{"id": "4a7a451f-e6d6-45d8-9c68-7bf705313fbd", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.quantum_prob = 0.3  # Increased initial quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9  # Adjusted DE mutation factor\n        self.de_crossover_rate = 0.85  # Adjusted DE crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n        dynamic_quantum_prob = self.quantum_prob\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Dynamic Quantum-inspired update\n                if np.random.rand() < dynamic_quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        # Reduce quantum probability as particles improve\n                        dynamic_quantum_prob = max(0.1, dynamic_quantum_prob * 0.95)\n                \n                # Velocity and position update with adaptive learning rates\n                r1, r2 = np.random.rand(), np.random.rand()\n                adaptive_cognitive = self.cognitive * (1 + np.exp(-0.1 * eval_count / self.budget))\n                adaptive_social = self.social * (1 + np.exp(-0.1 * eval_count / self.budget))\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    adaptive_cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    adaptive_social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with adaptive factor\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive learning rates and dynamic quantum probability for improved convergence.", "configspace": "", "generation": 34, "fitness": 0.24176169693631125, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.5215014286291435, 0.5215014286291435, 0.5215014286291435, 0.47898599251670204, 0.47898599251670204, 0.47898599251670204, 0.5262703722310207, 0.5262703722310207, 0.5262703722310207, 0.011301278358361921, 0.011301278358361921, 0.011301278358361921, 0.03162936439121056, 0.03162936439121056, 0.03162936439121056, 0.006210406434201232, 0.006210406434201232, 0.006210406434201232, 0.10991266944816958, 0.10991266944816958, 0.10991266944816958, 0.09901630369035541, 0.09901630369035541, 0.09901630369035541, 0.10490708015535333, 0.10490708015535333, 0.10490708015535333, 0.08509359045565179, 0.08509359045565179, 0.08509359045565179, 0.11549249891825586, 0.11549249891825586, 0.11549249891825586, 0.08816258440479485, 0.08816258440479485, 0.08816258440479485, 0.9672267573650881, 0.9672267573650881, 0.9672267573650881, 0.9783422246088582, 0.9783422246088582, 0.9783422246088582, 0.984863675467083, 0.984863675467083, 0.984863675467083, 0.2386550628353128, 0.2386550628353128, 0.2386550628353128, 0.22505261152518763, 0.22505261152518763, 0.22505261152518763, 0.27542141287422706, 0.27542141287422706, 0.27542141287422706, 0.3440868841670993, 0.3440868841670993, 0.3440868841670993, 0.20503233564210144, 0.20503233564210144, 0.20503233564210144, 0.3320244912901509, 0.3320244912901509, 0.3320244912901509, 0.1264766632938501, 0.1264766632938501, 0.1264766632938501, 0.2853419689658012, 0.2853419689658012, 0.2853419689658012, 0.16908756330802843, 0.16908756330802843, 0.16908756330802843, 0.12874830340960053, 0.12874830340960053, 0.12874830340960053, 0.1246616376928894, 0.1246616376928894, 0.1246616376928894, 0.1482605348934518, 0.1482605348934518, 0.1482605348934518, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029862046811828247, 0.0029862046811828247, 0.0029862046811828247, 0.11342710780369347, 0.11342710780369347, 0.11342710780369347, 0.08425790648230047, 0.08425790648230047, 0.08425790648230047, 0.14655924909073115, 0.14655924909073115, 0.14655924909073115, 0.0031651592869645917, 0.0031651592869645917, 0.0031651592869645917, 0.044977663935544254, 0.044977663935544254, 0.044977663935544254, 0.003044725629903544, 0.003044725629903544, 0.003044725629903544, 0.09607466963682743, 0.09607466963682743, 0.09607466963682743, 0.17493623746799458, 0.17493623746799458, 0.17493623746799458, 0.04823684312148613, 0.04823684312148613, 0.04823684312148613, 0.44062127687923835, 0.44062127687923835, 0.44062127687923835, 0.40521821579979256, 0.40521821579979256, 0.40521821579979256, 0.4142997433500726, 0.4142997433500726, 0.4142997433500726, 0.09292946798723811, 0.09292946798723811, 0.09292946798723811, 0.11208962351776808, 0.11208962351776808, 0.11208962351776808, 0.1024073919972861, 0.1024073919972861, 0.1024073919972861, 0.17250718902843387, 0.17250718902843387, 0.17250718902843387, 0.2668407143602295, 0.2668407143602295, 0.2668407143602295, 0.20014993048533747, 0.20014993048533747, 0.20014993048533747, 0.3163641518811221, 0.3163641518811221, 0.3163641518811221, 0.2612662743363824, 0.2612662743363824, 0.2612662743363824, 0.2623163637424173, 0.2623163637424173, 0.2623163637424173, 0.23746038857746288, 0.23746038857746288, 0.23746038857746288, 0.16846384484985233, 0.16846384484985233, 0.16846384484985233, 0.23117152884026826, 0.23117152884026826, 0.23117152884026826, 0.2036352921387714, 0.2036352921387714, 0.2036352921387714, 0.20419220699979124, 0.20419220699979124, 0.20419220699979124, 0.20467047648553138, 0.20467047648553138, 0.20467047648553138, 0.18930483356497396, 0.18930483356497396, 0.18930483356497396, 0.18811329408003152, 0.18811329408003152, 0.18811329408003152, 0.18892808684887874, 0.18892808684887874, 0.18892808684887874, 0.6902614906339335, 0.6902614906339335, 0.6902614906339335, 0.7398338185288418, 0.7398338185288418, 0.7398338185288418, 0.7739506504340838, 0.7739506504340838, 0.7739506504340838, 0.500859450129023, 0.500859450129023, 0.500859450129023, 0.2092417740079392, 0.2092417740079392, 0.2092417740079392, 0.36745431051006594, 0.36745431051006594, 0.36745431051006594, 0.20487047354771326, 0.20487047354771326, 0.20487047354771326, 0.20566110316298836, 0.20566110316298836, 0.20566110316298836, 0.1820230274319059, 0.1820230274319059, 0.1820230274319059, 0.08655897771375765, 0.08655897771375765, 0.08655897771375765, 0.0738921104755933, 0.0738921104755933, 0.0738921104755933, 0.07965323297910532, 0.07965323297910532, 0.07965323297910532]}, "mutation_prompt": null}
{"id": "2793f7b8-cae6-42f7-b7b2-7bc117c82df0", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.5  # Adjusted for better exploitation\n        self.social = 1.8     # Adjusted for better exploration\n        self.quantum_prob = 0.3  # Increased probability for quantum update\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased max velocity for faster exploration\n        self.de_mutation_factor = 0.9  # Slightly increased for more aggressive mutation\n        self.de_crossover_rate = 0.85  # Slightly adjusted for balance between exploration and exploitation\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update with adaptive scaling\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] *= np.random.uniform(0.9, 1.1)  # Adaptive scaling for enhanced diversity\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with Adaptive Velocity Scaling for improved convergence.", "configspace": "", "generation": 35, "fitness": 0.3586145432900186, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8231444478001148, 0.8231444478001148, 0.8231444478001148, 0.8337154925159505, 0.8337154925159505, 0.8337154925159505, 0.8415043599045956, 0.8415043599045956, 0.8415043599045956, 0.6080837044594752, 0.6080837044594752, 0.6080837044594752, 0.6446566923218378, 0.6446566923218378, 0.6446566923218378, 0.6605408934025927, 0.6605408934025927, 0.6605408934025927, 0.1413770427991462, 0.1413770427991462, 0.1413770427991462, 0.10410374184097693, 0.10410374184097693, 0.10410374184097693, 0.10883272027627588, 0.10883272027627588, 0.10883272027627588, 0.139630143375453, 0.139630143375453, 0.139630143375453, 0.10183925317710996, 0.10183925317710996, 0.10183925317710996, 0.1020706868789435, 0.1020706868789435, 0.1020706868789435, 0.9654059009735793, 0.9654059009735793, 0.9654059009735793, 0.9658164552377819, 0.9658164552377819, 0.9658164552377819, 0.9774008418310569, 0.9774008418310569, 0.9774008418310569, 0.6632057088948909, 0.6632057088948909, 0.6632057088948909, 0.6146934984041255, 0.6146934984041255, 0.6146934984041255, 0.5469205594623279, 0.5469205594623279, 0.5469205594623279, 0.2247448040785187, 0.2247448040785187, 0.2247448040785187, 0.20451071137146715, 0.20451071137146715, 0.20451071137146715, 0.23243490953644164, 0.23243490953644164, 0.23243490953644164, 0.5554928081949658, 0.5554928081949658, 0.5554928081949658, 0.5015657110772926, 0.5015657110772926, 0.5015657110772926, 0.1349795672669808, 0.1349795672669808, 0.1349795672669808, 0.5014931590667684, 0.5014931590667684, 0.5014931590667684, 0.5833994729502741, 0.5833994729502741, 0.5833994729502741, 0.6751383948048019, 0.6751383948048019, 0.6751383948048019, 0.06872508835501268, 0.06872508835501268, 0.06872508835501268, 0.289037016753214, 0.289037016753214, 0.289037016753214, 0.2070186563881432, 0.2070186563881432, 0.2070186563881432, 0.15035707850897817, 0.15035707850897817, 0.15035707850897817, 0.4224403512318541, 0.4224403512318541, 0.4224403512318541, 0.5644086046714353, 0.5644086046714353, 0.5644086046714353, 0.09828857332914032, 0.09828857332914032, 0.09828857332914032, 0.2289113033195398, 0.2289113033195398, 0.2289113033195398, 0.06581486856195284, 0.06581486856195284, 0.06581486856195284, 0.2365780805199359, 0.2365780805199359, 0.2365780805199359, 0.3880332310221073, 0.3880332310221073, 0.3880332310221073, 0.1578796728333457, 0.1578796728333457, 0.1578796728333457, 0.6960743004400898, 0.6960743004400898, 0.6960743004400898, 0.6422916330155994, 0.6422916330155994, 0.6422916330155994, 0.7152720251787936, 0.7152720251787936, 0.7152720251787936, 0.16061004127156409, 0.16061004127156409, 0.16061004127156409, 0.14851302640725006, 0.14851302640725006, 0.14851302640725006, 0.11719930370548004, 0.11719930370548004, 0.11719930370548004, 0.1702462093713999, 0.1702462093713999, 0.1702462093713999, 0.15072744282942507, 0.15072744282942507, 0.15072744282942507, 0.26662143282713835, 0.26662143282713835, 0.26662143282713835, 0.3007295405608732, 0.3007295405608732, 0.3007295405608732, 0.31061676703857144, 0.31061676703857144, 0.31061676703857144, 0.263003802831441, 0.263003802831441, 0.263003802831441, 0.2836925617008649, 0.2836925617008649, 0.2836925617008649, 0.33534401717307305, 0.33534401717307305, 0.33534401717307305, 0.17057555500490618, 0.17057555500490618, 0.17057555500490618, 0.21954858245767472, 0.21954858245767472, 0.21954858245767472, 0.24430947831093863, 0.24430947831093863, 0.24430947831093863, 0.24303184254881083, 0.24303184254881083, 0.24303184254881083, 0.2457446910623814, 0.2457446910623814, 0.2457446910623814, 0.1851759236894528, 0.1851759236894528, 0.1851759236894528, 0.21084349242485367, 0.21084349242485367, 0.21084349242485367, 0.9241340117384141, 0.9241340117384141, 0.9241340117384141, 0.16495478441633515, 0.16495478441633515, 0.16495478441633515, 0.16221174099168623, 0.16221174099168623, 0.16221174099168623, 0.868000362165753, 0.868000362165753, 0.868000362165753, 0.21070061702333953, 0.21070061702333953, 0.21070061702333953, 0.15591499088686833, 0.15591499088686833, 0.15591499088686833, 0.24502201170269045, 0.24502201170269045, 0.24502201170269045, 0.20919413339090742, 0.20919413339090742, 0.20919413339090742, 0.19005122038555022, 0.19005122038555022, 0.19005122038555022, 0.09604527615563052, 0.09604527615563052, 0.09604527615563052, 0.0849969998868837, 0.0849969998868837, 0.0849969998868837, 0.09465509088829172, 0.09465509088829172, 0.09465509088829172]}, "mutation_prompt": null}
{"id": "f3ce4e82-5bd9-4814-8d63-ff27d87f60d7", "solution": "import numpy as np\n\nclass TunedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased population for diversity\n        self.inertia = 0.6  # Slightly increased inertia for exploration\n        self.cognitive = 1.2  # Slightly reduced cognitive component\n        self.social = 2.1  # Slightly increased social component\n        self.quantum_prob = 0.25\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9  # Increased mutation factor for exploration\n        self.de_crossover_rate = 0.85  # Reduced crossover rate for better exploration-exploitation balance\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(scale=0.5, size=self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "TunedQuantumInspiredDSO", "description": "Tuned Quantum-Inspired Differential Swarm Optimization incorporating adaptive mutation scaling and diversified swarm dynamics for improved convergence.", "configspace": "", "generation": 36, "fitness": 0.31750342376441365, "feedback": "The algorithm TunedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7580843399933243, 0.7580843399933243, 0.7580843399933243, 0.7451272255673633, 0.7451272255673633, 0.7451272255673633, 0.7827810568315448, 0.7827810568315448, 0.7827810568315448, 0.035789676647769775, 0.035789676647769775, 0.035789676647769775, 0.4134111115379304, 0.4134111115379304, 0.4134111115379304, 0.37896219753585925, 0.37896219753585925, 0.37896219753585925, 0.1595491649321048, 0.1595491649321048, 0.1595491649321048, 0.09420191457545857, 0.09420191457545857, 0.09420191457545857, 0.14052053166377731, 0.14052053166377731, 0.14052053166377731, 0.10326024595030336, 0.10326024595030336, 0.10326024595030336, 0.06522073022125419, 0.06522073022125419, 0.06522073022125419, 0.10850959818944683, 0.10850959818944683, 0.10850959818944683, 0.9532313929084484, 0.9532313929084484, 0.9532313929084484, 0.9683480613753271, 0.9683480613753271, 0.9683480613753271, 0.9582816420091469, 0.9582816420091469, 0.9582816420091469, 0.535391287195875, 0.535391287195875, 0.535391287195875, 0.5391691237018841, 0.5391691237018841, 0.5391691237018841, 0.49493125675482474, 0.49493125675482474, 0.49493125675482474, 0.8079365034608121, 0.8079365034608121, 0.8079365034608121, 0.7140808932063967, 0.7140808932063967, 0.7140808932063967, 0.18076695750018357, 0.18076695750018357, 0.18076695750018357, 0.30174221673350266, 0.30174221673350266, 0.30174221673350266, 0.13077963864633146, 0.13077963864633146, 0.13077963864633146, 0.3484237435934533, 0.3484237435934533, 0.3484237435934533, 0.4470279156083834, 0.4470279156083834, 0.4470279156083834, 0.21874517069921917, 0.21874517069921917, 0.21874517069921917, 0.3695081423095826, 0.3695081423095826, 0.3695081423095826, 0.2990044062199758, 0.2990044062199758, 0.2990044062199758, 0.1099218105643891, 0.1099218105643891, 0.1099218105643891, 0.16085816943930276, 0.16085816943930276, 0.16085816943930276, 0.22977029091625711, 0.22977029091625711, 0.22977029091625711, 0.07329564793866283, 0.07329564793866283, 0.07329564793866283, 0.21172986661015558, 0.21172986661015558, 0.21172986661015558, 0.040214212772172186, 0.040214212772172186, 0.040214212772172186, 0.23284554671310376, 0.23284554671310376, 0.23284554671310376, 0.1944293668880117, 0.1944293668880117, 0.1944293668880117, 0.1807228686386969, 0.1807228686386969, 0.1807228686386969, 0.28291320429142985, 0.28291320429142985, 0.28291320429142985, 0.052092928176179165, 0.052092928176179165, 0.052092928176179165, 0.6403021478157528, 0.6403021478157528, 0.6403021478157528, 0.6814587250483687, 0.6814587250483687, 0.6814587250483687, 0.6403916164483985, 0.6403916164483985, 0.6403916164483985, 0.13997490448106142, 0.13997490448106142, 0.13997490448106142, 0.1311883870817936, 0.1311883870817936, 0.1311883870817936, 0.10515009900451389, 0.10515009900451389, 0.10515009900451389, 0.23584117547780792, 0.23584117547780792, 0.23584117547780792, 0.216346174551322, 0.216346174551322, 0.216346174551322, 0.25557408914559154, 0.25557408914559154, 0.25557408914559154, 0.4022262819207718, 0.4022262819207718, 0.4022262819207718, 0.38794527578109694, 0.38794527578109694, 0.38794527578109694, 0.28132671143067733, 0.28132671143067733, 0.28132671143067733, 0.3269825961547317, 0.3269825961547317, 0.3269825961547317, 0.2819395036713145, 0.2819395036713145, 0.2819395036713145, 0.3317962856717206, 0.3317962856717206, 0.3317962856717206, 0.2227167181360694, 0.2227167181360694, 0.2227167181360694, 0.21500814754012287, 0.21500814754012287, 0.21500814754012287, 0.24644570877605798, 0.24644570877605798, 0.24644570877605798, 0.18664857404406532, 0.18664857404406532, 0.18664857404406532, 0.24470077581368133, 0.24470077581368133, 0.24470077581368133, 0.21680137698681112, 0.21680137698681112, 0.21680137698681112, 0.888311635989062, 0.888311635989062, 0.888311635989062, 0.1580185523493859, 0.1580185523493859, 0.1580185523493859, 0.1694767532246071, 0.1694767532246071, 0.1694767532246071, 0.15528949325140406, 0.15528949325140406, 0.15528949325140406, 0.21265154256918517, 0.21265154256918517, 0.21265154256918517, 0.15560356910562512, 0.15560356910562512, 0.15560356910562512, 0.1947643144593446, 0.1947643144593446, 0.1947643144593446, 0.22095856369140388, 0.22095856369140388, 0.22095856369140388, 0.21564188139510887, 0.21564188139510887, 0.21564188139510887, 0.07745920375205728, 0.07745920375205728, 0.07745920375205728, 0.08299890918631758, 0.08299890918631758, 0.08299890918631758, 0.11672675856470338, 0.11672675856470338, 0.11672675856470338]}, "mutation_prompt": null}
{"id": "51c1f3f5-5162-4e2b-b215-6770b55f4a30", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased population for better exploration\n        self.inertia = 0.7  # Slightly increased inertia for better balance between exploration and exploitation\n        self.cognitive = 1.2  # Adjusted cognitive factor\n        self.social = 2.1  # Adjusted social factor\n        self.quantum_prob = 0.3  # Increased quantum probability for more frequent quantum updates\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased max velocity for faster convergence\n        self.de_mutation_factor = 0.9  # Adjusted differential evolution mutation factor\n        self.de_crossover_rate = 0.95  # Increased crossover rate for more aggressive trial vector generation\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.1\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity and mutation strategies for improved global search.", "configspace": "", "generation": 37, "fitness": 0.2565511740503953, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.6506972161055131, 0.6506972161055131, 0.6506972161055131, 0.684550590255147, 0.684550590255147, 0.684550590255147, 0.6439588502492848, 0.6439588502492848, 0.6439588502492848, 0.028174016716832062, 0.028174016716832062, 0.028174016716832062, 0.16022522320671506, 0.16022522320671506, 0.16022522320671506, 0.012994310873334913, 0.012994310873334913, 0.012994310873334913, 0.1481950188930361, 0.1481950188930361, 0.1481950188930361, 0.10230665731402366, 0.10230665731402366, 0.10230665731402366, 0.0933390673464457, 0.0933390673464457, 0.0933390673464457, 0.10829066142344568, 0.10829066142344568, 0.10829066142344568, 0.0834792898136788, 0.0834792898136788, 0.0834792898136788, 0.06318009877915431, 0.06318009877915431, 0.06318009877915431, 0.9532893503739821, 0.9532893503739821, 0.9532893503739821, 0.9657054512550395, 0.9657054512550395, 0.9657054512550395, 0.9686947298437703, 0.9686947298437703, 0.9686947298437703, 0.37436959603951614, 0.37436959603951614, 0.37436959603951614, 0.4081759890025459, 0.4081759890025459, 0.4081759890025459, 0.41555542535152834, 0.41555542535152834, 0.41555542535152834, 0.5609979064733349, 0.5609979064733349, 0.5609979064733349, 0.16047276614288564, 0.16047276614288564, 0.16047276614288564, 0.5105782233003765, 0.5105782233003765, 0.5105782233003765, 0.24519025469626488, 0.24519025469626488, 0.24519025469626488, 0.13015018103861697, 0.13015018103861697, 0.13015018103861697, 0.18235713795170716, 0.18235713795170716, 0.18235713795170716, 0.23799159046127438, 0.23799159046127438, 0.23799159046127438, 0.30133336286856427, 0.30133336286856427, 0.30133336286856427, 0.2202801991210075, 0.2202801991210075, 0.2202801991210075, 0.08254438209099157, 0.08254438209099157, 0.08254438209099157, 0.008934862734184423, 0.008934862734184423, 0.008934862734184423, 0.06262011139398305, 0.06262011139398305, 0.06262011139398305, 0.09971449879549166, 0.09971449879549166, 0.09971449879549166, 0.07183493495879245, 0.07183493495879245, 0.07183493495879245, 0.09166309712156251, 0.09166309712156251, 0.09166309712156251, 0.03484979540637401, 0.03484979540637401, 0.03484979540637401, 0.05511579721470228, 0.05511579721470228, 0.05511579721470228, 0.05242201825373427, 0.05242201825373427, 0.05242201825373427, 0.13753278925085655, 0.13753278925085655, 0.13753278925085655, 0.04822176745126494, 0.04822176745126494, 0.04822176745126494, 0.07885736126591014, 0.07885736126591014, 0.07885736126591014, 0.5037072466868262, 0.5037072466868262, 0.5037072466868262, 0.46324985437049804, 0.46324985437049804, 0.46324985437049804, 0.5200988407831572, 0.5200988407831572, 0.5200988407831572, 0.12447378482867388, 0.12447378482867388, 0.12447378482867388, 0.1039566937363845, 0.1039566937363845, 0.1039566937363845, 0.1140777596647109, 0.1140777596647109, 0.1140777596647109, 0.19065598542864948, 0.19065598542864948, 0.19065598542864948, 0.18276644723876412, 0.18276644723876412, 0.18276644723876412, 0.20844118974520964, 0.20844118974520964, 0.20844118974520964, 0.32470593155461414, 0.32470593155461414, 0.32470593155461414, 0.32511900521483905, 0.32511900521483905, 0.32511900521483905, 0.2921835952986306, 0.2921835952986306, 0.2921835952986306, 0.18562494082678482, 0.18562494082678482, 0.18562494082678482, 0.21162144776519975, 0.21162144776519975, 0.21162144776519975, 0.1337182189941445, 0.1337182189941445, 0.1337182189941445, 0.20016297620801715, 0.20016297620801715, 0.20016297620801715, 0.19077798688541836, 0.19077798688541836, 0.19077798688541836, 0.24788003452379426, 0.24788003452379426, 0.24788003452379426, 0.20315078810099318, 0.20315078810099318, 0.20315078810099318, 0.1976865151814533, 0.1976865151814533, 0.1976865151814533, 0.20025213513154028, 0.20025213513154028, 0.20025213513154028, 0.8583826742836268, 0.8583826742836268, 0.8583826742836268, 0.1582852928066475, 0.1582852928066475, 0.1582852928066475, 0.13550828856451647, 0.13550828856451647, 0.13550828856451647, 0.6952125668547381, 0.6952125668547381, 0.6952125668547381, 0.2118946223977356, 0.2118946223977356, 0.2118946223977356, 0.1555008397383495, 0.1555008397383495, 0.1555008397383495, 0.18301144296704264, 0.18301144296704264, 0.18301144296704264, 0.206343576839498, 0.206343576839498, 0.206343576839498, 0.2240371188716308, 0.2240371188716308, 0.2240371188716308, 0.08073711902477188, 0.08073711902477188, 0.08073711902477188, 0.09582771574964977, 0.09582771574964977, 0.09582771574964977, 0.1037873145270769, 0.1037873145270769, 0.1037873145270769]}, "mutation_prompt": null}
{"id": "90680e2d-6ae0-4fa0-92fe-aaa4ac319ab2", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased for better exploration\n        self.inertia = 0.4  # Adjusted inertia for better trade-off\n        self.cognitive = 1.5  # Enhanced cognitive factor\n        self.social = 2.1  # Enhanced social factor\n        self.quantum_prob = 0.3  # Increased probability for quantum update\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased velocity for rapid exploration\n        self.de_mutation_factor = 0.9  # Enhanced mutation factor\n        self.de_crossover_rate = 0.8  # Adjusted crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim)) * 0.5  # Damped initial velocity\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5  # Adjusted quantum step size\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveSwarm", "description": "Quantum-Enhanced Adaptive Swarm Optimization with Dynamic Parameters leveraging quantum particles and dynamic parameter adaptation for efficient search.", "configspace": "", "generation": 38, "fitness": 0.32968036718176025, "feedback": "The algorithm QuantumEnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8472397637335337, 0.8472397637335337, 0.8472397637335337, 0.8260322175113852, 0.8260322175113852, 0.8260322175113852, 0.8378101050202329, 0.8378101050202329, 0.8378101050202329, 0.400865007284368, 0.400865007284368, 0.400865007284368, 0.5660432182047398, 0.5660432182047398, 0.5660432182047398, 0.2010805198917034, 0.2010805198917034, 0.2010805198917034, 0.16522293203744343, 0.16522293203744343, 0.16522293203744343, 0.11209663403826942, 0.11209663403826942, 0.11209663403826942, 0.14188787384589063, 0.14188787384589063, 0.14188787384589063, 0.10985009309492666, 0.10985009309492666, 0.10985009309492666, 0.08790673914994274, 0.08790673914994274, 0.08790673914994274, 0.1535737269351819, 0.1535737269351819, 0.1535737269351819, 0.980407043015975, 0.980407043015975, 0.980407043015975, 0.9706485785737049, 0.9706485785737049, 0.9706485785737049, 0.9667898636672932, 0.9667898636672932, 0.9667898636672932, 0.5655583820208425, 0.5655583820208425, 0.5655583820208425, 0.5312744978213322, 0.5312744978213322, 0.5312744978213322, 0.5446989633922116, 0.5446989633922116, 0.5446989633922116, 0.7942445632639893, 0.7942445632639893, 0.7942445632639893, 0.20644370974230397, 0.20644370974230397, 0.20644370974230397, 0.275065311801466, 0.275065311801466, 0.275065311801466, 0.131651767100592, 0.131651767100592, 0.131651767100592, 0.13090868009675471, 0.13090868009675471, 0.13090868009675471, 0.13165893287294128, 0.13165893287294128, 0.13165893287294128, 0.500063661325208, 0.500063661325208, 0.500063661325208, 0.2613366199299678, 0.2613366199299678, 0.2613366199299678, 0.6298933032799413, 0.6298933032799413, 0.6298933032799413, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0936700754756985, 0.0936700754756985, 0.0936700754756985, 0.12287382671331237, 0.12287382671331237, 0.12287382671331237, 0.14889489457272653, 0.14889489457272653, 0.14889489457272653, 0.15848611299981819, 0.15848611299981819, 0.15848611299981819, 0.4849330877196688, 0.4849330877196688, 0.4849330877196688, 0.08686294526217408, 0.08686294526217408, 0.08686294526217408, 0.11159694752632532, 0.11159694752632532, 0.11159694752632532, 0.09580781003809169, 0.09580781003809169, 0.09580781003809169, 0.24378685428555036, 0.24378685428555036, 0.24378685428555036, 0.2794663917884379, 0.2794663917884379, 0.2794663917884379, 0.11419163787793818, 0.11419163787793818, 0.11419163787793818, 0.6856750621098248, 0.6856750621098248, 0.6856750621098248, 0.671921993790116, 0.671921993790116, 0.671921993790116, 0.6675074559106449, 0.6675074559106449, 0.6675074559106449, 0.09562670850778521, 0.09562670850778521, 0.09562670850778521, 0.15557895952285838, 0.15557895952285838, 0.15557895952285838, 0.11177657401110974, 0.11177657401110974, 0.11177657401110974, 0.16701743964629479, 0.16701743964629479, 0.16701743964629479, 0.2074178026675102, 0.2074178026675102, 0.2074178026675102, 0.29515604138723095, 0.29515604138723095, 0.29515604138723095, 0.48714555245054214, 0.48714555245054214, 0.48714555245054214, 0.4044460681605163, 0.4044460681605163, 0.4044460681605163, 0.4293695094756267, 0.4293695094756267, 0.4293695094756267, 0.13869472929027338, 0.13869472929027338, 0.13869472929027338, 0.25747486314193047, 0.25747486314193047, 0.25747486314193047, 0.2504559461379595, 0.2504559461379595, 0.2504559461379595, 0.22876671225429568, 0.22876671225429568, 0.22876671225429568, 0.2092461096046343, 0.2092461096046343, 0.2092461096046343, 0.22485648670509784, 0.22485648670509784, 0.22485648670509784, 0.1940723838455065, 0.1940723838455065, 0.1940723838455065, 0.23644503912627657, 0.23644503912627657, 0.23644503912627657, 0.18654741703500255, 0.18654741703500255, 0.18654741703500255, 0.9069980781940592, 0.9069980781940592, 0.9069980781940592, 0.15852532911249018, 0.15852532911249018, 0.15852532911249018, 0.16200262295183732, 0.16200262295183732, 0.16200262295183732, 0.8733848669625623, 0.8733848669625623, 0.8733848669625623, 0.21155616924943532, 0.21155616924943532, 0.21155616924943532, 0.15638794942994338, 0.15638794942994338, 0.15638794942994338, 0.20340701551538076, 0.20340701551538076, 0.20340701551538076, 0.2199251937796305, 0.2199251937796305, 0.2199251937796305, 0.19498465545391408, 0.19498465545391408, 0.19498465545391408, 0.10247839400524394, 0.10247839400524394, 0.10247839400524394, 0.10876470376022329, 0.10876470376022329, 0.10876470376022329, 0.12244931097909628, 0.12244931097909628, 0.12244931097909628]}, "mutation_prompt": null}
{"id": "87963592-557a-4d8f-8529-f0b3f86f9c10", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.4  # Adjusted inertia for better exploration\n        self.cognitive = 1.5  # Enhanced cognitive component\n        self.social = 1.8  # Slightly reduced social component\n        self.quantum_prob = 0.3  # Increased probability for quantum-inspired update\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.25  # Increased max velocity for broader exploration\n        self.de_mutation_factor = 0.9  # Enhanced mutation factor for diversity\n        self.de_crossover_rate = 0.85  # Slightly reduced crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in positions])\n\n        self.global_best_position = positions[np.argmin(personal_best_values)]\n        self.global_best_value = min(personal_best_values)\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = positions[i]\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = personal_best_positions[i]\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveDSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization integrates enhanced quantum-inspired dynamics and adaptive differential strategies for effective optimization.", "configspace": "", "generation": 39, "fitness": 0.34756492218549156, "feedback": "The algorithm QuantumEnhancedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8775901362285288, 0.8775901362285288, 0.8775901362285288, 0.8634752161901972, 0.8634752161901972, 0.8634752161901972, 0.8661390720881854, 0.8661390720881854, 0.8661390720881854, 0.581334212405566, 0.581334212405566, 0.581334212405566, 0.6774065470196563, 0.6774065470196563, 0.6774065470196563, 0.44454769180443277, 0.44454769180443277, 0.44454769180443277, 0.11236045369945258, 0.11236045369945258, 0.11236045369945258, 0.14455974988221676, 0.14455974988221676, 0.14455974988221676, 0.11565915761112933, 0.11565915761112933, 0.11565915761112933, 0.0797122995209334, 0.0797122995209334, 0.0797122995209334, 0.09996660226219845, 0.09996660226219845, 0.09996660226219845, 0.1088949365063061, 0.1088949365063061, 0.1088949365063061, 0.9599534447358395, 0.9599534447358395, 0.9599534447358395, 0.9664685207394094, 0.9664685207394094, 0.9664685207394094, 0.9548598346906786, 0.9548598346906786, 0.9548598346906786, 0.704885998734029, 0.704885998734029, 0.704885998734029, 0.7458120813990251, 0.7458120813990251, 0.7458120813990251, 0.7305341791712363, 0.7305341791712363, 0.7305341791712363, 0.22736909791067084, 0.22736909791067084, 0.22736909791067084, 0.22080237872610364, 0.22080237872610364, 0.22080237872610364, 0.11654659368944409, 0.11654659368944409, 0.11654659368944409, 0.12470399714921332, 0.12470399714921332, 0.12470399714921332, 0.5102279136012584, 0.5102279136012584, 0.5102279136012584, 0.13258321729417277, 0.13258321729417277, 0.13258321729417277, 0.38825441360855206, 0.38825441360855206, 0.38825441360855206, 0.5031307386749944, 0.5031307386749944, 0.5031307386749944, 0.5971424496030364, 0.5971424496030364, 0.5971424496030364, 0.08210543759193478, 0.08210543759193478, 0.08210543759193478, 0.07694570449631044, 0.07694570449631044, 0.07694570449631044, 0.06272227503085359, 0.06272227503085359, 0.06272227503085359, 0.17022007883022505, 0.17022007883022505, 0.17022007883022505, 0.21185156173404196, 0.21185156173404196, 0.21185156173404196, 0.27071798282642623, 0.27071798282642623, 0.27071798282642623, 0.048416281367253955, 0.048416281367253955, 0.048416281367253955, 0.1558287226897006, 0.1558287226897006, 0.1558287226897006, 0.24992071599825305, 0.24992071599825305, 0.24992071599825305, 0.20373181123036277, 0.20373181123036277, 0.20373181123036277, 0.11471123570728703, 0.11471123570728703, 0.11471123570728703, 0.3100059874977231, 0.3100059874977231, 0.3100059874977231, 0.6744213060250117, 0.6744213060250117, 0.6744213060250117, 0.7784166632520743, 0.7784166632520743, 0.7784166632520743, 0.7805599598610079, 0.7805599598610079, 0.7805599598610079, 0.11189962014201793, 0.11189962014201793, 0.11189962014201793, 0.11898618081272183, 0.11898618081272183, 0.11898618081272183, 0.12463392786158178, 0.12463392786158178, 0.12463392786158178, 0.1488715684979809, 0.1488715684979809, 0.1488715684979809, 0.16368998702419013, 0.16368998702419013, 0.16368998702419013, 0.29583074484844873, 0.29583074484844873, 0.29583074484844873, 0.2234898674602902, 0.2234898674602902, 0.2234898674602902, 0.3789890555509723, 0.3789890555509723, 0.3789890555509723, 0.2660414600826706, 0.2660414600826706, 0.2660414600826706, 0.2417484245841971, 0.2417484245841971, 0.2417484245841971, 0.12823507064850237, 0.12823507064850237, 0.12823507064850237, 0.29419012955207124, 0.29419012955207124, 0.29419012955207124, 0.2142390012166896, 0.2142390012166896, 0.2142390012166896, 0.22808455020844554, 0.22808455020844554, 0.22808455020844554, 0.24498569366357326, 0.24498569366357326, 0.24498569366357326, 0.19947397910929776, 0.19947397910929776, 0.19947397910929776, 0.20633779108994788, 0.20633779108994788, 0.20633779108994788, 0.2054322041386818, 0.2054322041386818, 0.2054322041386818, 0.9246503741615, 0.9246503741615, 0.9246503741615, 0.15834385514982363, 0.15834385514982363, 0.15834385514982363, 0.9121024578327649, 0.9121024578327649, 0.9121024578327649, 0.1686087606033665, 0.1686087606033665, 0.1686087606033665, 0.21199761212017554, 0.21199761212017554, 0.21199761212017554, 0.888386105915197, 0.888386105915197, 0.888386105915197, 0.23686553878665595, 0.23686553878665595, 0.23686553878665595, 0.22263359655867976, 0.22263359655867976, 0.22263359655867976, 0.19202673066810194, 0.19202673066810194, 0.19202673066810194, 0.09366206682779399, 0.09366206682779399, 0.09366206682779399, 0.07783331851355557, 0.07783331851355557, 0.07783331851355557, 0.09690806464056345, 0.09690806464056345, 0.09690806464056345]}, "mutation_prompt": null}
{"id": "748f912a-4eb8-4e8f-bdc4-4664d5f89ed3", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased population for diversity\n        self.inertia = 0.6  # Slightly higher inertia for stability\n        self.cognitive = 1.2\n        self.social = 1.9\n        self.quantum_prob = 0.3  # Increased quantum probability for exploration\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Adjusted velocity cap\n        self.de_mutation_factor = 0.9  # Slightly higher mutation factor\n        self.de_crossover_rate = 0.95  # Increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.5, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        if quantum_value < self.global_best_value:\n                            self.global_best_value = quantum_value\n                            self.global_best_position = quantum_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveDSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization with hybrid strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 40, "fitness": 0.33299362365843305, "feedback": "The algorithm QuantumEnhancedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7792283954305622, 0.7792283954305622, 0.7792283954305622, 0.7723480516493926, 0.7723480516493926, 0.7723480516493926, 0.7839387587600273, 0.7839387587600273, 0.7839387587600273, 0.3530930345923432, 0.3530930345923432, 0.3530930345923432, 0.4300610811989476, 0.4300610811989476, 0.4300610811989476, 0.3831190490619798, 0.3831190490619798, 0.3831190490619798, 0.1327805200232438, 0.1327805200232438, 0.1327805200232438, 0.1128625728641015, 0.1128625728641015, 0.1128625728641015, 0.10130312344446668, 0.10130312344446668, 0.10130312344446668, 0.10334917798308174, 0.10334917798308174, 0.10334917798308174, 0.10893097620270908, 0.10893097620270908, 0.10893097620270908, 0.09175484269706335, 0.09175484269706335, 0.09175484269706335, 0.9467934004693145, 0.9467934004693145, 0.9467934004693145, 0.9464662491723721, 0.9464662491723721, 0.9464662491723721, 0.9529409485647963, 0.9529409485647963, 0.9529409485647963, 0.5527905284805664, 0.5527905284805664, 0.5527905284805664, 0.5744105351095532, 0.5744105351095532, 0.5744105351095532, 0.5230485840791171, 0.5230485840791171, 0.5230485840791171, 0.36342223122950734, 0.36342223122950734, 0.36342223122950734, 0.21077661281587357, 0.21077661281587357, 0.21077661281587357, 0.7818613735385552, 0.7818613735385552, 0.7818613735385552, 0.4701267644539021, 0.4701267644539021, 0.4701267644539021, 0.40098300244603124, 0.40098300244603124, 0.40098300244603124, 0.13013652492235017, 0.13013652492235017, 0.13013652492235017, 0.43268218747013776, 0.43268218747013776, 0.43268218747013776, 0.1323400878722738, 0.1323400878722738, 0.1323400878722738, 0.41138552174931187, 0.41138552174931187, 0.41138552174931187, 0.31127760485131983, 0.31127760485131983, 0.31127760485131983, 0.15975631645363542, 0.15975631645363542, 0.15975631645363542, 0.0819181348995397, 0.0819181348995397, 0.0819181348995397, 0.282340500872061, 0.282340500872061, 0.282340500872061, 0.07959898795598364, 0.07959898795598364, 0.07959898795598364, 0.26886810235348413, 0.26886810235348413, 0.26886810235348413, 0.07546675581434303, 0.07546675581434303, 0.07546675581434303, 0.16198611206203495, 0.16198611206203495, 0.16198611206203495, 0.09856295243617819, 0.09856295243617819, 0.09856295243617819, 0.3109434013914655, 0.3109434013914655, 0.3109434013914655, 0.28350257979464566, 0.28350257979464566, 0.28350257979464566, 0.0817279870398715, 0.0817279870398715, 0.0817279870398715, 0.6473533464655052, 0.6473533464655052, 0.6473533464655052, 0.6515561817629049, 0.6515561817629049, 0.6515561817629049, 0.6107590717450418, 0.6107590717450418, 0.6107590717450418, 0.12908578937185067, 0.12908578937185067, 0.12908578937185067, 0.12869399134170378, 0.12869399134170378, 0.12869399134170378, 0.13843684782632903, 0.13843684782632903, 0.13843684782632903, 0.19699556693834852, 0.19699556693834852, 0.19699556693834852, 0.5286963554091912, 0.5286963554091912, 0.5286963554091912, 0.198406022691903, 0.198406022691903, 0.198406022691903, 0.35327532359555724, 0.35327532359555724, 0.35327532359555724, 0.40254287279528744, 0.40254287279528744, 0.40254287279528744, 0.27129708636001815, 0.27129708636001815, 0.27129708636001815, 0.16782736737102, 0.16782736737102, 0.16782736737102, 0.26780219511246284, 0.26780219511246284, 0.26780219511246284, 0.21849385739878713, 0.21849385739878713, 0.21849385739878713, 0.25629859762734875, 0.25629859762734875, 0.25629859762734875, 0.24864536034590334, 0.24864536034590334, 0.24864536034590334, 0.24926569871386817, 0.24926569871386817, 0.24926569871386817, 0.19726026733327406, 0.19726026733327406, 0.19726026733327406, 0.18373141750911393, 0.18373141750911393, 0.18373141750911393, 0.5113157316006947, 0.5113157316006947, 0.5113157316006947, 0.8559668973327899, 0.8559668973327899, 0.8559668973327899, 0.15849682332896953, 0.15849682332896953, 0.15849682332896953, 0.16964671096623984, 0.16964671096623984, 0.16964671096623984, 0.8215416970688962, 0.8215416970688962, 0.8215416970688962, 0.21064330982147694, 0.21064330982147694, 0.21064330982147694, 0.15634368620700057, 0.15634368620700057, 0.15634368620700057, 0.18122886947060446, 0.18122886947060446, 0.18122886947060446, 0.19422106701834674, 0.19422106701834674, 0.19422106701834674, 0.21564934051408013, 0.21564934051408013, 0.21564934051408013, 0.09090272677357902, 0.09090272677357902, 0.09090272677357902, 0.0878072807411554, 0.0878072807411554, 0.0878072807411554, 0.09646997264178336, 0.09646997264178336, 0.09646997264178336]}, "mutation_prompt": null}
{"id": "c032b41b-2b73-4311-aa9a-3b5ced929ce2", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 45\n        self.inertia = 0.6\n        self.cognitive = 1.4\n        self.social = 1.9\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveSO", "description": "Quantum-Enhanced Adaptive Swarm Optimization with dynamic mutation and learning coefficients to balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.34709724064065123, "feedback": "The algorithm QuantumEnhancedAdaptiveSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.778690257214279, 0.778690257214279, 0.778690257214279, 0.8071513512143382, 0.8071513512143382, 0.8071513512143382, 0.8000983055352588, 0.8000983055352588, 0.8000983055352588, 0.4670087218732881, 0.4670087218732881, 0.4670087218732881, 0.45523152040913395, 0.45523152040913395, 0.45523152040913395, 0.4140058240509953, 0.4140058240509953, 0.4140058240509953, 0.10884334600735035, 0.10884334600735035, 0.10884334600735035, 0.1441134743974659, 0.1441134743974659, 0.1441134743974659, 0.1223453784798243, 0.1223453784798243, 0.1223453784798243, 0.10830307927437621, 0.10830307927437621, 0.10830307927437621, 0.08260764343888982, 0.08260764343888982, 0.08260764343888982, 0.14316296803956297, 0.14316296803956297, 0.14316296803956297, 0.9263029332134438, 0.9263029332134438, 0.9263029332134438, 0.9574472689530279, 0.9574472689530279, 0.9574472689530279, 0.9543314557018246, 0.9543314557018246, 0.9543314557018246, 0.5440380626863492, 0.5440380626863492, 0.5440380626863492, 0.5444667374777885, 0.5444667374777885, 0.5444667374777885, 0.5790509357630065, 0.5790509357630065, 0.5790509357630065, 0.7479095942071993, 0.7479095942071993, 0.7479095942071993, 0.7703468055219493, 0.7703468055219493, 0.7703468055219493, 0.7736982333392658, 0.7736982333392658, 0.7736982333392658, 0.4249774466240148, 0.4249774466240148, 0.4249774466240148, 0.3900323765496405, 0.3900323765496405, 0.3900323765496405, 0.13249631927448047, 0.13249631927448047, 0.13249631927448047, 0.44283963965294404, 0.44283963965294404, 0.44283963965294404, 0.42192765148966527, 0.42192765148966527, 0.42192765148966527, 0.13127010333095113, 0.13127010333095113, 0.13127010333095113, 0.24388487455583818, 0.24388487455583818, 0.24388487455583818, 0.14293063869697742, 0.14293063869697742, 0.14293063869697742, 0.1572960092039961, 0.1572960092039961, 0.1572960092039961, 0.23892315519336316, 0.23892315519336316, 0.23892315519336316, 0.18800117633751745, 0.18800117633751745, 0.18800117633751745, 0.3198217019710804, 0.3198217019710804, 0.3198217019710804, 0.04306413974818146, 0.04306413974818146, 0.04306413974818146, 0.11088262117367087, 0.11088262117367087, 0.11088262117367087, 0.1352166500839277, 0.1352166500839277, 0.1352166500839277, 0.307669128478119, 0.307669128478119, 0.307669128478119, 0.03708456393560722, 0.03708456393560722, 0.03708456393560722, 0.18601922204648846, 0.18601922204648846, 0.18601922204648846, 0.6681893868590483, 0.6681893868590483, 0.6681893868590483, 0.5804146146303107, 0.5804146146303107, 0.5804146146303107, 0.647072786019375, 0.647072786019375, 0.647072786019375, 0.10668446066102422, 0.10668446066102422, 0.10668446066102422, 0.17086964174431174, 0.17086964174431174, 0.17086964174431174, 0.10208282297985594, 0.10208282297985594, 0.10208282297985594, 0.16344955759307467, 0.16344955759307467, 0.16344955759307467, 0.4793994210716861, 0.4793994210716861, 0.4793994210716861, 0.2957868871104974, 0.2957868871104974, 0.2957868871104974, 0.3033121950433256, 0.3033121950433256, 0.3033121950433256, 0.37627904757835096, 0.37627904757835096, 0.37627904757835096, 0.42032577342943, 0.42032577342943, 0.42032577342943, 0.19211281438560568, 0.19211281438560568, 0.19211281438560568, 0.30805677752164373, 0.30805677752164373, 0.30805677752164373, 0.29883265585103913, 0.29883265585103913, 0.29883265585103913, 0.20061469320904868, 0.20061469320904868, 0.20061469320904868, 0.25144625330603354, 0.25144625330603354, 0.25144625330603354, 0.23523515251503802, 0.23523515251503802, 0.23523515251503802, 0.19210547837438197, 0.19210547837438197, 0.19210547837438197, 0.24463071624896848, 0.24463071624896848, 0.24463071624896848, 0.20796201229896571, 0.20796201229896571, 0.20796201229896571, 0.8896146615084896, 0.8896146615084896, 0.8896146615084896, 0.1583354683130348, 0.1583354683130348, 0.1583354683130348, 0.1754407996874099, 0.1754407996874099, 0.1754407996874099, 0.773046972984338, 0.773046972984338, 0.773046972984338, 0.2100212623279124, 0.2100212623279124, 0.2100212623279124, 0.16817822281686856, 0.16817822281686856, 0.16817822281686856, 0.19782773619573868, 0.19782773619573868, 0.19782773619573868, 0.21430828119795453, 0.21430828119795453, 0.21430828119795453, 0.19155388494679126, 0.19155388494679126, 0.19155388494679126, 0.09507597654802702, 0.09507597654802702, 0.09507597654802702, 0.08325594649689882, 0.08325594649689882, 0.08325594649689882, 0.10598764952733053, 0.10598764952733053, 0.10598764952733053]}, "mutation_prompt": null}
{"id": "609997b0-55ae-452f-b23c-af23110e2fb1", "solution": "import numpy as np\n\nclass StochasticQuantumEnhancedDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update with chaotic map\n                if np.random.rand() < self.quantum_prob:\n                    chaotic_factor = np.sin(np.pi * np.random.rand())\n                    quantum_position = self.global_best_position + chaotic_factor * np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update with adaptive inertia\n                r1, r2 = np.random.rand(), np.random.rand()\n                adaptive_inertia = self.inertia * (1 - eval_count / self.budget)\n                velocities[i] = (\n                    adaptive_inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with adaptive strategy\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "StochasticQuantumEnhancedDSO", "description": "Stochastic Quantum-Enhanced Differential Swarm Optimizer with adaptive parameters and chaotic map initialization for improved exploration and convergence.", "configspace": "", "generation": 42, "fitness": 0.3571891786231209, "feedback": "The algorithm StochasticQuantumEnhancedDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8611856598760419, 0.8611856598760419, 0.8611856598760419, 0.8510281454401412, 0.8510281454401412, 0.8510281454401412, 0.8465868887472797, 0.8465868887472797, 0.8465868887472797, 0.6542857197088692, 0.6542857197088692, 0.6542857197088692, 0.645900927189546, 0.645900927189546, 0.645900927189546, 0.6410170918949759, 0.6410170918949759, 0.6410170918949759, 0.09761498214569841, 0.09761498214569841, 0.09761498214569841, 0.1363513691017526, 0.1363513691017526, 0.1363513691017526, 0.09703400631920434, 0.09703400631920434, 0.09703400631920434, 0.131312283697545, 0.131312283697545, 0.131312283697545, 0.10515019785457147, 0.10515019785457147, 0.10515019785457147, 0.15457412593075992, 0.15457412593075992, 0.15457412593075992, 0.9435806704141313, 0.9435806704141313, 0.9435806704141313, 0.9655755321625672, 0.9655755321625672, 0.9655755321625672, 0.9583440733214807, 0.9583440733214807, 0.9583440733214807, 0.6872652359613078, 0.6872652359613078, 0.6872652359613078, 0.6975663193293239, 0.6975663193293239, 0.6975663193293239, 0.6413179378512937, 0.6413179378512937, 0.6413179378512937, 0.6063212747803528, 0.6063212747803528, 0.6063212747803528, 0.21482737676457686, 0.21482737676457686, 0.21482737676457686, 0.5398139201250002, 0.5398139201250002, 0.5398139201250002, 0.3343889693755464, 0.3343889693755464, 0.3343889693755464, 0.1329172051577614, 0.1329172051577614, 0.1329172051577614, 0.13300749908512044, 0.13300749908512044, 0.13300749908512044, 0.593337353458401, 0.593337353458401, 0.593337353458401, 0.5852264513196759, 0.5852264513196759, 0.5852264513196759, 0.5368130922664993, 0.5368130922664993, 0.5368130922664993, 0.2182836310787084, 0.2182836310787084, 0.2182836310787084, 0.05938200344750855, 0.05938200344750855, 0.05938200344750855, 0.06805530829181516, 0.06805530829181516, 0.06805530829181516, 0.27176856144805983, 0.27176856144805983, 0.27176856144805983, 0.12044832039549624, 0.12044832039549624, 0.12044832039549624, 0.15780664003340883, 0.15780664003340883, 0.15780664003340883, 0.04804941399584517, 0.04804941399584517, 0.04804941399584517, 0.12640352045536363, 0.12640352045536363, 0.12640352045536363, 0.1568146060018375, 0.1568146060018375, 0.1568146060018375, 0.3616589219903713, 0.3616589219903713, 0.3616589219903713, 0.19138349005391198, 0.19138349005391198, 0.19138349005391198, 0.3052720796870758, 0.3052720796870758, 0.3052720796870758, 0.7721010475802047, 0.7721010475802047, 0.7721010475802047, 0.6174842143651379, 0.6174842143651379, 0.6174842143651379, 0.7474579480735797, 0.7474579480735797, 0.7474579480735797, 0.12505391767202723, 0.12505391767202723, 0.12505391767202723, 0.1220527852248059, 0.1220527852248059, 0.1220527852248059, 0.07866836175541336, 0.07866836175541336, 0.07866836175541336, 0.20447909451306623, 0.20447909451306623, 0.20447909451306623, 0.22129819619546076, 0.22129819619546076, 0.22129819619546076, 0.3462857679739427, 0.3462857679739427, 0.3462857679739427, 0.4301005885844291, 0.4301005885844291, 0.4301005885844291, 0.3392021343104763, 0.3392021343104763, 0.3392021343104763, 0.2599669732003398, 0.2599669732003398, 0.2599669732003398, 0.26881132993367907, 0.26881132993367907, 0.26881132993367907, 0.3423422794513441, 0.3423422794513441, 0.3423422794513441, 0.3448133811439016, 0.3448133811439016, 0.3448133811439016, 0.2779610407772528, 0.2779610407772528, 0.2779610407772528, 0.20285571356853016, 0.20285571356853016, 0.20285571356853016, 0.23436310317790787, 0.23436310317790787, 0.23436310317790787, 0.7708083789315978, 0.7708083789315978, 0.7708083789315978, 0.1895268866205445, 0.1895268866205445, 0.1895268866205445, 0.20174018511861536, 0.20174018511861536, 0.20174018511861536, 0.9298758633981825, 0.9298758633981825, 0.9298758633981825, 0.16504994266666762, 0.16504994266666762, 0.16504994266666762, 0.1627890047108218, 0.1627890047108218, 0.1627890047108218, 0.15524819252093092, 0.15524819252093092, 0.15524819252093092, 0.21186206694971366, 0.21186206694971366, 0.21186206694971366, 0.1556483790091383, 0.1556483790091383, 0.1556483790091383, 0.2412642148136127, 0.2412642148136127, 0.2412642148136127, 0.18817231157475367, 0.18817231157475367, 0.18817231157475367, 0.2507416892039481, 0.2507416892039481, 0.2507416892039481, 0.095033866918381, 0.095033866918381, 0.095033866918381, 0.10142313445225115, 0.10142313445225115, 0.10142313445225115, 0.08546806031521792, 0.08546806031521792, 0.08546806031521792]}, "mutation_prompt": null}
{"id": "017d0b00-9697-489f-8f47-5e3eee8e3732", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.3\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.stochastic_teleport_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        eval_count = 0\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            eval_count += 1\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        while eval_count < self.budget:\n            inertia = self.inertia_final + (self.inertia_initial - self.inertia_final) * (1 - eval_count / self.budget)\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update with adaptive inertia\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                # Stochastic teleportation to escape local optima\n                if np.random.rand() < self.stochastic_teleport_prob:\n                    positions[i] = np.random.uniform(self.lb, self.ub, self.dim)\n                    value = func(positions[i])\n                    eval_count += 1\n                    if value < personal_best_values[i]:\n                        personal_best_values[i] = value\n                        personal_best_positions[i] = np.copy(positions[i])\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumDifferentialSwarmOptimization", "description": "Hybrid Quantum Differential Swarm Optimization combining adaptive inertia and stochastic teleportation enhancing exploration and exploitation balance.", "configspace": "", "generation": 43, "fitness": 0.22014603121555307, "feedback": "The algorithm HybridQuantumDifferentialSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.5052244579970999, 0.5052244579970999, 0.5052244579970999, 0.48750172148659154, 0.48750172148659154, 0.48750172148659154, 0.5142811574936599, 0.5142811574936599, 0.5142811574936599, 0.011038832763366146, 0.011038832763366146, 0.011038832763366146, 0.05239551001930143, 0.05239551001930143, 0.05239551001930143, 0.012323031628450387, 0.012323031628450387, 0.012323031628450387, 0.1066555984634171, 0.1066555984634171, 0.1066555984634171, 0.09100611665987768, 0.09100611665987768, 0.09100611665987768, 0.0941144507028937, 0.0941144507028937, 0.0941144507028937, 0.09005461208151644, 0.09005461208151644, 0.09005461208151644, 0.0846073809308866, 0.0846073809308866, 0.0846073809308866, 0.10445763393326446, 0.10445763393326446, 0.10445763393326446, 0.9740184607615286, 0.9740184607615286, 0.9740184607615286, 0.9697632277406399, 0.9697632277406399, 0.9697632277406399, 0.9655104301938109, 0.9655104301938109, 0.9655104301938109, 0.22370940833007502, 0.22370940833007502, 0.22370940833007502, 0.26791503755965373, 0.26791503755965373, 0.26791503755965373, 0.23254299429203695, 0.23254299429203695, 0.23254299429203695, 0.3964506194054994, 0.3964506194054994, 0.3964506194054994, 0.17703051635519584, 0.17703051635519584, 0.17703051635519584, 0.21542346833060633, 0.21542346833060633, 0.21542346833060633, 0.15703604729957477, 0.15703604729957477, 0.15703604729957477, 0.14764991902008118, 0.14764991902008118, 0.14764991902008118, 0.1580174849002256, 0.1580174849002256, 0.1580174849002256, 0.15791135417380808, 0.15791135417380808, 0.15791135417380808, 0.11876281678301781, 0.11876281678301781, 0.11876281678301781, 0.048132107316063766, 0.048132107316063766, 0.048132107316063766, 0.023613753867653187, 0.023613753867653187, 0.023613753867653187, 0.0003419673570508319, 0.0003419673570508319, 0.0003419673570508319, 0.05076299151591612, 0.05076299151591612, 0.05076299151591612, 0.10895189929907645, 0.10895189929907645, 0.10895189929907645, 0.030755875283888012, 0.030755875283888012, 0.030755875283888012, 0.15800315460498127, 0.15800315460498127, 0.15800315460498127, 0.049945474152663705, 0.049945474152663705, 0.049945474152663705, 0.030285121841456597, 0.030285121841456597, 0.030285121841456597, 0.024987924861363697, 0.024987924861363697, 0.024987924861363697, 0.09673235933468949, 0.09673235933468949, 0.09673235933468949, 0.029384918915463798, 0.029384918915463798, 0.029384918915463798, 0.059042238601875074, 0.059042238601875074, 0.059042238601875074, 0.39512050600426196, 0.39512050600426196, 0.39512050600426196, 0.39003841747155477, 0.39003841747155477, 0.39003841747155477, 0.4064492122924982, 0.4064492122924982, 0.4064492122924982, 0.12198894076620803, 0.12198894076620803, 0.12198894076620803, 0.11864370592341333, 0.11864370592341333, 0.11864370592341333, 0.09781427520193198, 0.09781427520193198, 0.09781427520193198, 0.15739249800470645, 0.15739249800470645, 0.15739249800470645, 0.16117556631041807, 0.16117556631041807, 0.16117556631041807, 0.1910231595242432, 0.1910231595242432, 0.1910231595242432, 0.2773495250254403, 0.2773495250254403, 0.2773495250254403, 0.26044598466435787, 0.26044598466435787, 0.26044598466435787, 0.28537898195765166, 0.28537898195765166, 0.28537898195765166, 0.15758088172763396, 0.15758088172763396, 0.15758088172763396, 0.16790271472219043, 0.16790271472219043, 0.16790271472219043, 0.2012495570434274, 0.2012495570434274, 0.2012495570434274, 0.2125159895995704, 0.2125159895995704, 0.2125159895995704, 0.2066736471130196, 0.2066736471130196, 0.2066736471130196, 0.19109408340470568, 0.19109408340470568, 0.19109408340470568, 0.2870043085411492, 0.2870043085411492, 0.2870043085411492, 0.17980286034796522, 0.17980286034796522, 0.17980286034796522, 0.1909856998410423, 0.1909856998410423, 0.1909856998410423, 0.6669552755848198, 0.6669552755848198, 0.6669552755848198, 0.4128817787328477, 0.4128817787328477, 0.4128817787328477, 0.1689343418960112, 0.1689343418960112, 0.1689343418960112, 0.4971100291411237, 0.4971100291411237, 0.4971100291411237, 0.20447068817452296, 0.20447068817452296, 0.20447068817452296, 0.40566808076219085, 0.40566808076219085, 0.40566808076219085, 0.1940727365081515, 0.1940727365081515, 0.1940727365081515, 0.17976616395449896, 0.17976616395449896, 0.17976616395449896, 0.18348044744882752, 0.18348044744882752, 0.18348044744882752, 0.08085626143366409, 0.08085626143366409, 0.08085626143366409, 0.0775672058660617, 0.0775672058660617, 0.0775672058660617, 0.09477864627148735, 0.09477864627148735, 0.09477864627148735]}, "mutation_prompt": null}
{"id": "4a30807e-faf5-462f-bf0a-d27cff71bfb9", "solution": "import numpy as np\n\nclass EnhancedQuantumDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Increased inertia for better exploration\n        self.cognitive = 1.5  # Adjusted cognitive component\n        self.social = 1.8  # Adjusted social component\n        self.quantum_prob = 0.3  # Increased quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased max velocity\n        self.de_mutation_factor = 0.9  # Slightly increased mutation factor\n        self.de_crossover_rate = 0.8  # Adjusted crossover rate\n        self.dynamic_inertia_step = (0.3 - 0.7) / self.budget  # Dynamic inertia reduction\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            self.inertia += self.dynamic_inertia_step  # Update inertia dynamically\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.standard_t(self.dim)  # Use t-distribution for diversity\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with dynamic parameter adaptation and diversified mutation strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.2868592185895289, "feedback": "The algorithm EnhancedQuantumDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7464607383860279, 0.7464607383860279, 0.7464607383860279, 0.7413171032058388, 0.7413171032058388, 0.7413171032058388, 0.7288760502350802, 0.7288760502350802, 0.7288760502350802, 0.24157716978150956, 0.24157716978150956, 0.24157716978150956, 0.301793389849328, 0.301793389849328, 0.301793389849328, 0.0147295823745337, 0.0147295823745337, 0.0147295823745337, 0.1125995765038319, 0.1125995765038319, 0.1125995765038319, 0.1341499523546721, 0.1341499523546721, 0.1341499523546721, 0.08516042684789704, 0.08516042684789704, 0.08516042684789704, 0.1089367432387377, 0.1089367432387377, 0.1089367432387377, 0.10005432359565636, 0.10005432359565636, 0.10005432359565636, 0.08846774127614843, 0.08846774127614843, 0.08846774127614843, 0.9474598794460867, 0.9474598794460867, 0.9474598794460867, 0.9739313641250386, 0.9739313641250386, 0.9739313641250386, 0.9719143270611768, 0.9719143270611768, 0.9719143270611768, 0.3885910925190167, 0.3885910925190167, 0.3885910925190167, 0.4843961787459713, 0.4843961787459713, 0.4843961787459713, 0.4639144941158303, 0.4639144941158303, 0.4639144941158303, 0.7151983719348616, 0.7151983719348616, 0.7151983719348616, 0.1624011161721428, 0.1624011161721428, 0.1624011161721428, 0.14350463766435262, 0.14350463766435262, 0.14350463766435262, 0.3139407465518743, 0.3139407465518743, 0.3139407465518743, 0.12995249459257352, 0.12995249459257352, 0.12995249459257352, 0.3691514273007659, 0.3691514273007659, 0.3691514273007659, 0.35608403311517944, 0.35608403311517944, 0.35608403311517944, 0.270344359985505, 0.270344359985505, 0.270344359985505, 0.3057863557308873, 0.3057863557308873, 0.3057863557308873, 0.15361992631103671, 0.15361992631103671, 0.15361992631103671, 0.2631902339160669, 0.2631902339160669, 0.2631902339160669, 0.1582597744681279, 0.1582597744681279, 0.1582597744681279, 0.18000921519720836, 0.18000921519720836, 0.18000921519720836, 0.19233321173882467, 0.19233321173882467, 0.19233321173882467, 0.23911845416807564, 0.23911845416807564, 0.23911845416807564, 0.037986926318432035, 0.037986926318432035, 0.037986926318432035, 0.14039846451019744, 0.14039846451019744, 0.14039846451019744, 0.05233476832085848, 0.05233476832085848, 0.05233476832085848, 0.10415031825901677, 0.10415031825901677, 0.10415031825901677, 0.13872969802198254, 0.13872969802198254, 0.13872969802198254, 0.0778572308664709, 0.0778572308664709, 0.0778572308664709, 0.5344004909943827, 0.5344004909943827, 0.5344004909943827, 0.5176284341307862, 0.5176284341307862, 0.5176284341307862, 0.527181996248614, 0.527181996248614, 0.527181996248614, 0.12951893771483625, 0.12951893771483625, 0.12951893771483625, 0.08516375745559235, 0.08516375745559235, 0.08516375745559235, 0.1047230208903498, 0.1047230208903498, 0.1047230208903498, 0.2818443286241653, 0.2818443286241653, 0.2818443286241653, 0.1869786303326576, 0.1869786303326576, 0.1869786303326576, 0.1780254984526115, 0.1780254984526115, 0.1780254984526115, 0.27894520115838406, 0.27894520115838406, 0.27894520115838406, 0.2846557512707696, 0.2846557512707696, 0.2846557512707696, 0.35660029301900253, 0.35660029301900253, 0.35660029301900253, 0.24274950920232863, 0.24274950920232863, 0.24274950920232863, 0.2278001294476829, 0.2278001294476829, 0.2278001294476829, 0.17284938628747715, 0.17284938628747715, 0.17284938628747715, 0.2199653292341125, 0.2199653292341125, 0.2199653292341125, 0.21095938095862443, 0.21095938095862443, 0.21095938095862443, 0.23324988898493815, 0.23324988898493815, 0.23324988898493815, 0.2036741715100402, 0.2036741715100402, 0.2036741715100402, 0.18196329946218848, 0.18196329946218848, 0.18196329946218848, 0.24018093665225748, 0.24018093665225748, 0.24018093665225748, 0.8386004301027048, 0.8386004301027048, 0.8386004301027048, 0.11447087816240886, 0.11447087816240886, 0.11447087816240886, 0.17441745102065065, 0.17441745102065065, 0.17441745102065065, 0.7648289938775251, 0.7648289938775251, 0.7648289938775251, 0.20923585554530022, 0.20923585554530022, 0.20923585554530022, 0.15657816275121217, 0.15657816275121217, 0.15657816275121217, 0.1969898203033137, 0.1969898203033137, 0.1969898203033137, 0.19294424621249207, 0.19294424621249207, 0.19294424621249207, 0.21463361259133695, 0.21463361259133695, 0.21463361259133695, 0.09016390013910536, 0.09016390013910536, 0.09016390013910536, 0.07279892518474518, 0.07279892518474518, 0.07279892518474518, 0.09046119171665945, 0.09046119171665945, 0.09046119171665945]}, "mutation_prompt": null}
{"id": "6e7e5464-0931-4688-8e87-df51e2127deb", "solution": "import numpy as np\n\nclass QuantumEnhancedPSOwithAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6  # Increased inertia for exploration\n        self.cognitive = 1.5\n        self.social = 2.2  # Increased social influence to drive convergence\n        self.quantum_prob = 0.3  # Slightly higher probability for quantum leap\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced max velocity for better local exploration\n        self.adaptive_factor = 0.8  # Introduced adaptive factor for mutation\n        self.mutation_rate = 0.1  # Introduced lower mutation rate for stability\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update with adaptive enhancement\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, self.adaptive_factor, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Adaptive Mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = personal_best_positions[i] + np.random.normal(0, self.adaptive_factor, self.dim)\n                    mutation_vector = np.clip(mutation_vector, self.lb, self.ub)\n                    mutation_value = func(mutation_vector)\n                    eval_count += 1\n                    if mutation_value < personal_best_values[i]:\n                        personal_best_positions[i] = mutation_vector\n                        personal_best_values[i] = mutation_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedPSOwithAdaptiveMutation", "description": "Quantum-Enhanced Particle Swarm with Adaptive Mutation which augments quantum-inspired dynamics with adaptive mutation strategies for enhanced exploration.", "configspace": "", "generation": 45, "fitness": 0.35926554843448033, "feedback": "The algorithm QuantumEnhancedPSOwithAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8311612348216822, 0.8311612348216822, 0.8311612348216822, 0.8204121249210636, 0.8204121249210636, 0.8204121249210636, 0.8549888481555362, 0.8549888481555362, 0.8549888481555362, 0.4826322247790239, 0.4826322247790239, 0.4826322247790239, 0.5037916946304004, 0.5037916946304004, 0.5037916946304004, 0.3925825896853753, 0.3925825896853753, 0.3925825896853753, 0.11883121996775503, 0.11883121996775503, 0.11883121996775503, 0.12623478136078647, 0.12623478136078647, 0.12623478136078647, 0.13105486504135555, 0.13105486504135555, 0.13105486504135555, 0.10634908801291199, 0.10634908801291199, 0.10634908801291199, 0.07784933436705888, 0.07784933436705888, 0.07784933436705888, 0.13856136778270467, 0.13856136778270467, 0.13856136778270467, 0.9371181902733162, 0.9371181902733162, 0.9371181902733162, 0.9597166123453564, 0.9597166123453564, 0.9597166123453564, 0.9648560818373183, 0.9648560818373183, 0.9648560818373183, 0.6359106288011566, 0.6359106288011566, 0.6359106288011566, 0.5946306620128445, 0.5946306620128445, 0.5946306620128445, 0.3789926880626564, 0.3789926880626564, 0.3789926880626564, 0.19624550730025137, 0.19624550730025137, 0.19624550730025137, 0.21134010909828238, 0.21134010909828238, 0.21134010909828238, 0.21864643709626597, 0.21864643709626597, 0.21864643709626597, 0.13332984773648182, 0.13332984773648182, 0.13332984773648182, 0.6411220907504477, 0.6411220907504477, 0.6411220907504477, 0.6093612257316632, 0.6093612257316632, 0.6093612257316632, 0.4965843609541972, 0.4965843609541972, 0.4965843609541972, 0.44373504452504753, 0.44373504452504753, 0.44373504452504753, 0.49691254458530465, 0.49691254458530465, 0.49691254458530465, 0.08354788241206568, 0.08354788241206568, 0.08354788241206568, 0.3335344021510116, 0.3335344021510116, 0.3335344021510116, 0.2949951045993455, 0.2949951045993455, 0.2949951045993455, 0.18180928828941245, 0.18180928828941245, 0.18180928828941245, 0.13379846230441816, 0.13379846230441816, 0.13379846230441816, 0.20291353438049786, 0.20291353438049786, 0.20291353438049786, 0.13044336295350545, 0.13044336295350545, 0.13044336295350545, 0.21043084225072184, 0.21043084225072184, 0.21043084225072184, 0.2656432731933026, 0.2656432731933026, 0.2656432731933026, 0.16483766340186978, 0.16483766340186978, 0.16483766340186978, 0.3277471464881814, 0.3277471464881814, 0.3277471464881814, 0.08022091441625268, 0.08022091441625268, 0.08022091441625268, 0.6716897414413443, 0.6716897414413443, 0.6716897414413443, 0.7011912865515636, 0.7011912865515636, 0.7011912865515636, 0.6485130118799538, 0.6485130118799538, 0.6485130118799538, 0.11915592072029046, 0.11915592072029046, 0.11915592072029046, 0.10270563757418372, 0.10270563757418372, 0.10270563757418372, 0.13091490643930515, 0.13091490643930515, 0.13091490643930515, 0.2677461015106162, 0.2677461015106162, 0.2677461015106162, 0.734248845452864, 0.734248845452864, 0.734248845452864, 0.3318336662123085, 0.3318336662123085, 0.3318336662123085, 0.4656925200216274, 0.4656925200216274, 0.4656925200216274, 0.2320942230723917, 0.2320942230723917, 0.2320942230723917, 0.36477558266277976, 0.36477558266277976, 0.36477558266277976, 0.30594279504024413, 0.30594279504024413, 0.30594279504024413, 0.20731458285442783, 0.20731458285442783, 0.20731458285442783, 0.20193459261196067, 0.20193459261196067, 0.20193459261196067, 0.250245558288945, 0.250245558288945, 0.250245558288945, 0.2910490806676609, 0.2910490806676609, 0.2910490806676609, 0.18369613852979505, 0.18369613852979505, 0.18369613852979505, 0.20845609461325498, 0.20845609461325498, 0.20845609461325498, 0.17880544612709948, 0.17880544612709948, 0.17880544612709948, 0.207724250784443, 0.207724250784443, 0.207724250784443, 0.9231174215915752, 0.9231174215915752, 0.9231174215915752, 0.15859760591730288, 0.15859760591730288, 0.15859760591730288, 0.9013542362152138, 0.9013542362152138, 0.9013542362152138, 0.8913312184789198, 0.8913312184789198, 0.8913312184789198, 0.21244334486554095, 0.21244334486554095, 0.21244334486554095, 0.1566364382076808, 0.1566364382076808, 0.1566364382076808, 0.1926123647881074, 0.1926123647881074, 0.1926123647881074, 0.2043874978845439, 0.2043874978845439, 0.2043874978845439, 0.20616563416770095, 0.20616563416770095, 0.20616563416770095, 0.09479093595023513, 0.09479093595023513, 0.09479093595023513, 0.10223457291629634, 0.10223457291629634, 0.10223457291629634, 0.10484495176557662, 0.10484495176557662, 0.10484495176557662]}, "mutation_prompt": null}
{"id": "278319d0-9392-42af-b6ae-756e3bc029d6", "solution": "import numpy as np\n\nclass HybridQuantumSelfOrganizingDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.4  # Slightly reduced inertia for more exploration\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3  # Increased quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced max velocity\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85  # Adjusted crossover rate for diversity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        som_learning_rate = 0.3  # Self-organizing map learning rate\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update with self-organizing map influence\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                \n                # Velocity and position update with SOM effect\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Self-organizing map adaptation\n                som_adjustment = som_learning_rate * (self.global_best_position - positions[i])\n                positions[i] += som_adjustment\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with SOM influence\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumSelfOrganizingDSO", "description": "Hybrid Quantum-Self-Organizing Differential Swarm Optimization enhances exploration and exploitation through combined quantum and self-organizing map strategies.", "configspace": "", "generation": 46, "fitness": 0.3008435371196618, "feedback": "The algorithm HybridQuantumSelfOrganizingDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.9143819570614744, 0.9143819570614744, 0.9143819570614744, 0.8931077712455525, 0.8931077712455525, 0.8931077712455525, 0.9078318662972213, 0.9078318662972213, 0.9078318662972213, 0.4574004787299678, 0.4574004787299678, 0.4574004787299678, 0.7136135114827923, 0.7136135114827923, 0.7136135114827923, 0.4361962753628811, 0.4361962753628811, 0.4361962753628811, 0.11249504596744442, 0.11249504596744442, 0.11249504596744442, 0.08603885585712323, 0.08603885585712323, 0.08603885585712323, 0.11795917458116567, 0.11795917458116567, 0.11795917458116567, 0.051448161054660324, 0.051448161054660324, 0.051448161054660324, 0.06717538964811975, 0.06717538964811975, 0.06717538964811975, 0.11160387306833075, 0.11160387306833075, 0.11160387306833075, 0.9466292415474706, 0.9466292415474706, 0.9466292415474706, 0.9382299216274667, 0.9382299216274667, 0.9382299216274667, 0.9481524531773253, 0.9481524531773253, 0.9481524531773253, 0.5243577038388636, 0.5243577038388636, 0.5243577038388636, 0.46885927994740695, 0.46885927994740695, 0.46885927994740695, 0.6034971136512808, 0.6034971136512808, 0.6034971136512808, 0.131482020925902, 0.131482020925902, 0.131482020925902, 0.2112581272409837, 0.2112581272409837, 0.2112581272409837, 0.2031496665278565, 0.2031496665278565, 0.2031496665278565, 0.1839234100202789, 0.1839234100202789, 0.1839234100202789, 0.19088671643306465, 0.19088671643306465, 0.19088671643306465, 0.2077669057592879, 0.2077669057592879, 0.2077669057592879, 0.20661287269698736, 0.20661287269698736, 0.20661287269698736, 0.17110834123200724, 0.17110834123200724, 0.17110834123200724, 0.19458750302332706, 0.19458750302332706, 0.19458750302332706, 0.029696507025322894, 0.029696507025322894, 0.029696507025322894, 0.03875363665217335, 0.03875363665217335, 0.03875363665217335, 0.0980030638654027, 0.0980030638654027, 0.0980030638654027, 0.16399982026638205, 0.16399982026638205, 0.16399982026638205, 0.08825757037357163, 0.08825757037357163, 0.08825757037357163, 0.1717186336768889, 0.1717186336768889, 0.1717186336768889, 0.0532252336367357, 0.0532252336367357, 0.0532252336367357, 0.08006593571119391, 0.08006593571119391, 0.08006593571119391, 0.16923231105119807, 0.16923231105119807, 0.16923231105119807, 0.24341488854421245, 0.24341488854421245, 0.24341488854421245, 0.047932406074083556, 0.047932406074083556, 0.047932406074083556, 0.05713828133075782, 0.05713828133075782, 0.05713828133075782, 0.5541372734952752, 0.5541372734952752, 0.5541372734952752, 0.6995188849624053, 0.6995188849624053, 0.6995188849624053, 0.7395380784055037, 0.7395380784055037, 0.7395380784055037, 0.09251575961993874, 0.09251575961993874, 0.09251575961993874, 0.07437889088174066, 0.07437889088174066, 0.07437889088174066, 0.11100617009504554, 0.11100617009504554, 0.11100617009504554, 0.4182596505424502, 0.4182596505424502, 0.4182596505424502, 0.23759446885843882, 0.23759446885843882, 0.23759446885843882, 0.324006004370472, 0.324006004370472, 0.324006004370472, 0.40858032466505656, 0.40858032466505656, 0.40858032466505656, 0.39267709577675347, 0.39267709577675347, 0.39267709577675347, 0.2568828351461344, 0.2568828351461344, 0.2568828351461344, 0.23042769880753544, 0.23042769880753544, 0.23042769880753544, 0.18393357402273303, 0.18393357402273303, 0.18393357402273303, 0.18458284250898638, 0.18458284250898638, 0.18458284250898638, 0.244453934936936, 0.244453934936936, 0.244453934936936, 0.299571068157681, 0.299571068157681, 0.299571068157681, 0.22314739474873657, 0.22314739474873657, 0.22314739474873657, 0.21933950265852387, 0.21933950265852387, 0.21933950265852387, 0.17887062032179546, 0.17887062032179546, 0.17887062032179546, 0.19622920577434555, 0.19622920577434555, 0.19622920577434555, 0.9486924904529794, 0.9486924904529794, 0.9486924904529794, 0.15897097475154442, 0.15897097475154442, 0.15897097475154442, 0.17704026574612197, 0.17704026574612197, 0.17704026574612197, 0.16891224954015283, 0.16891224954015283, 0.16891224954015283, 0.21317419556608752, 0.21317419556608752, 0.21317419556608752, 0.4549599313941435, 0.4549599313941435, 0.4549599313941435, 0.22825334168896538, 0.22825334168896538, 0.22825334168896538, 0.23956597525775092, 0.23956597525775092, 0.23956597525775092, 0.2603527914323508, 0.2603527914323508, 0.2603527914323508, 0.10551298595453829, 0.10551298595453829, 0.10551298595453829, 0.10310516735672881, 0.10310516735672881, 0.10310516735672881, 0.0913510985036261, 0.0913510985036261, 0.0913510985036261]}, "mutation_prompt": null}
{"id": "0ded4a9b-3716-48ce-870c-aeade18b0997", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        eval_count = 0\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n            eval_count += 1\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.5, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization using adaptive strategies for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 47, "fitness": 0.28957412272434957, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.6903593430873022, 0.6903593430873022, 0.6903593430873022, 0.6573918705647035, 0.6573918705647035, 0.6573918705647035, 0.7020463933397405, 0.7020463933397405, 0.7020463933397405, 0.20376618995327467, 0.20376618995327467, 0.20376618995327467, 0.22772793512090217, 0.22772793512090217, 0.22772793512090217, 0.20987596417877308, 0.20987596417877308, 0.20987596417877308, 0.12231254332008379, 0.12231254332008379, 0.12231254332008379, 0.12684458065427984, 0.12684458065427984, 0.12684458065427984, 0.13614463011200295, 0.13614463011200295, 0.13614463011200295, 0.11272071524652816, 0.11272071524652816, 0.11272071524652816, 0.10684820396619799, 0.10684820396619799, 0.10684820396619799, 0.13462576167615337, 0.13462576167615337, 0.13462576167615337, 0.9460627053250455, 0.9460627053250455, 0.9460627053250455, 0.9636862286719698, 0.9636862286719698, 0.9636862286719698, 0.9570630048874297, 0.9570630048874297, 0.9570630048874297, 0.4137988690530032, 0.4137988690530032, 0.4137988690530032, 0.3927322901095951, 0.3927322901095951, 0.3927322901095951, 0.4373998614745809, 0.4373998614745809, 0.4373998614745809, 0.653500796836216, 0.653500796836216, 0.653500796836216, 0.5163864475147464, 0.5163864475147464, 0.5163864475147464, 0.6814945132671877, 0.6814945132671877, 0.6814945132671877, 0.129341461128463, 0.129341461128463, 0.129341461128463, 0.2797368830227267, 0.2797368830227267, 0.2797368830227267, 0.5012464512937143, 0.5012464512937143, 0.5012464512937143, 0.36676386319886733, 0.36676386319886733, 0.36676386319886733, 0.28537319923890037, 0.28537319923890037, 0.28537319923890037, 0.19123984138828087, 0.19123984138828087, 0.19123984138828087, 0.08110080134692144, 0.08110080134692144, 0.08110080134692144, 0.056979620404259745, 0.056979620404259745, 0.056979620404259745, 0.14336953293673926, 0.14336953293673926, 0.14336953293673926, 0.22873510161325572, 0.22873510161325572, 0.22873510161325572, 0.012411379730996819, 0.012411379730996819, 0.012411379730996819, 0.11678005933541769, 0.11678005933541769, 0.11678005933541769, 0.03835523884770753, 0.03835523884770753, 0.03835523884770753, 0.09835457456897767, 0.09835457456897767, 0.09835457456897767, 0.13132026209157577, 0.13132026209157577, 0.13132026209157577, 0.20225517929664605, 0.20225517929664605, 0.20225517929664605, 0.22515696615553493, 0.22515696615553493, 0.22515696615553493, 0.15197809084955083, 0.15197809084955083, 0.15197809084955083, 0.5594013492968029, 0.5594013492968029, 0.5594013492968029, 0.48162769705743536, 0.48162769705743536, 0.48162769705743536, 0.5246140340607129, 0.5246140340607129, 0.5246140340607129, 0.11256059074294966, 0.11256059074294966, 0.11256059074294966, 0.14910961359916386, 0.14910961359916386, 0.14910961359916386, 0.11043842239885038, 0.11043842239885038, 0.11043842239885038, 0.31126151876950503, 0.31126151876950503, 0.31126151876950503, 0.18474828558048806, 0.18474828558048806, 0.18474828558048806, 0.1908389947867487, 0.1908389947867487, 0.1908389947867487, 0.3483674736552831, 0.3483674736552831, 0.3483674736552831, 0.24843938661516551, 0.24843938661516551, 0.24843938661516551, 0.4114664252054514, 0.4114664252054514, 0.4114664252054514, 0.2304934351952983, 0.2304934351952983, 0.2304934351952983, 0.24326606607102907, 0.24326606607102907, 0.24326606607102907, 0.25697404534736124, 0.25697404534736124, 0.25697404534736124, 0.20925114130123945, 0.20925114130123945, 0.20925114130123945, 0.21778181006685504, 0.21778181006685504, 0.21778181006685504, 0.19172106491754104, 0.19172106491754104, 0.19172106491754104, 0.2519644280462989, 0.2519644280462989, 0.2519644280462989, 0.21428123111930975, 0.21428123111930975, 0.21428123111930975, 0.22228989497186025, 0.22228989497186025, 0.22228989497186025, 0.8271324353598191, 0.8271324353598191, 0.8271324353598191, 0.15816971018776516, 0.15816971018776516, 0.15816971018776516, 0.16964797170441903, 0.16964797170441903, 0.16964797170441903, 0.15525743818184123, 0.15525743818184123, 0.15525743818184123, 0.2103464096930553, 0.2103464096930553, 0.2103464096930553, 0.1564794310882136, 0.1564794310882136, 0.1564794310882136, 0.17698220861163827, 0.17698220861163827, 0.17698220861163827, 0.2002240940769281, 0.2002240940769281, 0.2002240940769281, 0.18206562018849037, 0.18206562018849037, 0.18206562018849037, 0.09216548923401902, 0.09216548923401902, 0.09216548923401902, 0.09224258468410784, 0.09224258468410784, 0.09224258468410784, 0.12443917952926908, 0.12443917952926908, 0.12443917952926908]}, "mutation_prompt": null}
{"id": "aea2bded-c4fb-449c-a38a-6c72380361b7", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n        self.levy_scale = 0.1\n\n    def levy_flight(self):\n        u = np.random.normal(0, 1, self.dim) * self.levy_scale\n        v = np.random.normal(0, 1, self.dim)\n        step = u / (np.abs(v) ** (1 / 3))\n        return step\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < 0.3:  # Introduce local search with Lévy Flights\n                    levy_step = self.levy_flight()\n                    levy_position = positions[i] + levy_step\n                    levy_position = np.clip(levy_position, self.lb, self.ub)\n                    levy_value = func(levy_position)\n                    eval_count += 1\n                    if levy_value < personal_best_values[i]:\n                        personal_best_values[i] = levy_value\n                        personal_best_positions[i] = levy_position\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumInspiredDSO", "description": "Quantum-Inspired Differential Swarm Optimization with Adaptive Local Search using Lévy Flights for enhanced exploration and exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.3655001535424735, "feedback": "The algorithm AdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8106678338165331, 0.8106678338165331, 0.8106678338165331, 0.8187802503242232, 0.8187802503242232, 0.8187802503242232, 0.8365173525010131, 0.8365173525010131, 0.8365173525010131, 0.5195018430957803, 0.5195018430957803, 0.5195018430957803, 0.5252495247780544, 0.5252495247780544, 0.5252495247780544, 0.5240510770779319, 0.5240510770779319, 0.5240510770779319, 0.11340994578553931, 0.11340994578553931, 0.11340994578553931, 0.1223880587951266, 0.1223880587951266, 0.1223880587951266, 0.13130571926842494, 0.13130571926842494, 0.13130571926842494, 0.08946140237425992, 0.08946140237425992, 0.08946140237425992, 0.08910083874771646, 0.08910083874771646, 0.08910083874771646, 0.13522078072840482, 0.13522078072840482, 0.13522078072840482, 0.9473362333755511, 0.9473362333755511, 0.9473362333755511, 0.9614841208047225, 0.9614841208047225, 0.9614841208047225, 0.9541300269513836, 0.9541300269513836, 0.9541300269513836, 0.6080282504134491, 0.6080282504134491, 0.6080282504134491, 0.6293230918906116, 0.6293230918906116, 0.6293230918906116, 0.5389979247825039, 0.5389979247825039, 0.5389979247825039, 0.5894349498080442, 0.5894349498080442, 0.5894349498080442, 0.21048797413728082, 0.21048797413728082, 0.21048797413728082, 0.22978401402834125, 0.22978401402834125, 0.22978401402834125, 0.5063700492946756, 0.5063700492946756, 0.5063700492946756, 0.4679967400991737, 0.4679967400991737, 0.4679967400991737, 0.5124675010689108, 0.5124675010689108, 0.5124675010689108, 0.5912697696843936, 0.5912697696843936, 0.5912697696843936, 0.6318361708326462, 0.6318361708326462, 0.6318361708326462, 0.1298031311422697, 0.1298031311422697, 0.1298031311422697, 0.38291352111676635, 0.38291352111676635, 0.38291352111676635, 0.14351881914707687, 0.14351881914707687, 0.14351881914707687, 0.07016737845548482, 0.07016737845548482, 0.07016737845548482, 0.46591848990181806, 0.46591848990181806, 0.46591848990181806, 0.4060885742590684, 0.4060885742590684, 0.4060885742590684, 0.4251536436728588, 0.4251536436728588, 0.4251536436728588, 0.04561012315637414, 0.04561012315637414, 0.04561012315637414, 0.14299119945738203, 0.14299119945738203, 0.14299119945738203, 0.20024119058572387, 0.20024119058572387, 0.20024119058572387, 0.19721954513618412, 0.19721954513618412, 0.19721954513618412, 0.28459207520110474, 0.28459207520110474, 0.28459207520110474, 0.2009993178243551, 0.2009993178243551, 0.2009993178243551, 0.6967198658821075, 0.6967198658821075, 0.6967198658821075, 0.6529757912761764, 0.6529757912761764, 0.6529757912761764, 0.6914796379177416, 0.6914796379177416, 0.6914796379177416, 0.13686216897277115, 0.13686216897277115, 0.13686216897277115, 0.1316993472891027, 0.1316993472891027, 0.1316993472891027, 0.13819203896258403, 0.13819203896258403, 0.13819203896258403, 0.3090345597378231, 0.3090345597378231, 0.3090345597378231, 0.39175649420754555, 0.39175649420754555, 0.39175649420754555, 0.3279525799101273, 0.3279525799101273, 0.3279525799101273, 0.38848735815511704, 0.38848735815511704, 0.38848735815511704, 0.33765386452220103, 0.33765386452220103, 0.33765386452220103, 0.3900506129639202, 0.3900506129639202, 0.3900506129639202, 0.2460536053493213, 0.2460536053493213, 0.2460536053493213, 0.2529008136856582, 0.2529008136856582, 0.2529008136856582, 0.2619273190590846, 0.2619273190590846, 0.2619273190590846, 0.24312999090992105, 0.24312999090992105, 0.24312999090992105, 0.2821916884210669, 0.2821916884210669, 0.2821916884210669, 0.22691284848229165, 0.22691284848229165, 0.22691284848229165, 0.2160642553665708, 0.2160642553665708, 0.2160642553665708, 0.17540439267256602, 0.17540439267256602, 0.17540439267256602, 0.22118470282385938, 0.22118470282385938, 0.22118470282385938, 0.9238445682428286, 0.9238445682428286, 0.9238445682428286, 0.17194354737491668, 0.17194354737491668, 0.17194354737491668, 0.8674342117327338, 0.8674342117327338, 0.8674342117327338, 0.16866310977868926, 0.16866310977868926, 0.16866310977868926, 0.21102660933216644, 0.21102660933216644, 0.21102660933216644, 0.1558228661500718, 0.1558228661500718, 0.1558228661500718, 0.20149753096150458, 0.20149753096150458, 0.20149753096150458, 0.20958794053995722, 0.20958794053995722, 0.20958794053995722, 0.20296352129103934, 0.20296352129103934, 0.20296352129103934, 0.10406304718004034, 0.10406304718004034, 0.10406304718004034, 0.09768607688225694, 0.09768607688225694, 0.09768607688225694, 0.09302563550316667, 0.09302563550316667, 0.09302563550316667]}, "mutation_prompt": null}
{"id": "e646ba62-0b57-4934-9c5e-27df29f9b61d", "solution": "import numpy as np\n\nclass QuantumInspiredDSOWithChaos:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.4  # adjusted\n        self.social = 2.0\n        self.quantum_prob = 0.3  # adjusted\n        self.chaos_factor = 0.4  # new parameter\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def logistic_map(self, x):\n        return 4.0 * x * (1.0 - x)\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n        chaos_states = np.random.rand(self.num_particles)  # new chaotic states\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                chaos_states[i] = self.logistic_map(chaos_states[i])  # updating chaotic states\n\n                # Quantum-inspired update with chaos\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + chaos_states[i] * np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i]) +\n                    self.chaos_factor * (chaos_states[i] - 0.5)  # apply chaos\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumInspiredDSOWithChaos", "description": "Quantum-Inspired Differential Swarm Optimization with Adaptive Chaos utilizes chaotic maps to enhance exploration and convergence dynamics.", "configspace": "", "generation": 49, "fitness": 0.24237519089603837, "feedback": "The algorithm QuantumInspiredDSOWithChaos got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.5949284646659021, 0.5949284646659021, 0.5949284646659021, 0.6024189240005866, 0.6024189240005866, 0.6024189240005866, 0.5827888259960572, 0.5827888259960572, 0.5827888259960572, 0.04378806500163246, 0.04378806500163246, 0.04378806500163246, 0.12569067342665907, 0.12569067342665907, 0.12569067342665907, 0.1143263700099807, 0.1143263700099807, 0.1143263700099807, 0.17508617231832813, 0.17508617231832813, 0.17508617231832813, 0.11736404835128744, 0.11736404835128744, 0.11736404835128744, 0.10432270719793268, 0.10432270719793268, 0.10432270719793268, 0.10817993621322874, 0.10817993621322874, 0.10817993621322874, 0.1499816272015505, 0.1499816272015505, 0.1499816272015505, 0.11167514748764729, 0.11167514748764729, 0.11167514748764729, 0.9553484813569311, 0.9553484813569311, 0.9553484813569311, 0.9656841752549044, 0.9656841752549044, 0.9656841752549044, 0.9632275644468606, 0.9632275644468606, 0.9632275644468606, 0.30525897713571026, 0.30525897713571026, 0.30525897713571026, 0.35666544530842925, 0.35666544530842925, 0.35666544530842925, 0.3273958338892722, 0.3273958338892722, 0.3273958338892722, 0.338299579180406, 0.338299579180406, 0.338299579180406, 0.21167488192145778, 0.21167488192145778, 0.21167488192145778, 0.6011850509561483, 0.6011850509561483, 0.6011850509561483, 0.3384116032023231, 0.3384116032023231, 0.3384116032023231, 0.1288333027795825, 0.1288333027795825, 0.1288333027795825, 0.268756333203808, 0.268756333203808, 0.268756333203808, 0.1154583439896607, 0.1154583439896607, 0.1154583439896607, 0.17219668270031052, 0.17219668270031052, 0.17219668270031052, 0.17273211145060363, 0.17273211145060363, 0.17273211145060363, 0.048197900494128976, 0.048197900494128976, 0.048197900494128976, 0.0026934899993051875, 0.0026934899993051875, 0.0026934899993051875, 0.038769131397925816, 0.038769131397925816, 0.038769131397925816, 0.09726674360306986, 0.09726674360306986, 0.09726674360306986, 0.045254960451578286, 0.045254960451578286, 0.045254960451578286, 0.08769830481755803, 0.08769830481755803, 0.08769830481755803, 0.007058949663321212, 0.007058949663321212, 0.007058949663321212, 0.05553514598978948, 0.05553514598978948, 0.05553514598978948, 0.06924888774918692, 0.06924888774918692, 0.06924888774918692, 0.14400413518287236, 0.14400413518287236, 0.14400413518287236, 0.05064427821080575, 0.05064427821080575, 0.05064427821080575, 0.05283379538414157, 0.05283379538414157, 0.05283379538414157, 0.45452214028467663, 0.45452214028467663, 0.45452214028467663, 0.4609881674863785, 0.4609881674863785, 0.4609881674863785, 0.43638499561934774, 0.43638499561934774, 0.43638499561934774, 0.08663441915294534, 0.08663441915294534, 0.08663441915294534, 0.1467013456353896, 0.1467013456353896, 0.1467013456353896, 0.09395268904622411, 0.09395268904622411, 0.09395268904622411, 0.18101047128340209, 0.18101047128340209, 0.18101047128340209, 0.23325325294515942, 0.23325325294515942, 0.23325325294515942, 0.29450537776619923, 0.29450537776619923, 0.29450537776619923, 0.32513817443848436, 0.32513817443848436, 0.32513817443848436, 0.2863851444125306, 0.2863851444125306, 0.2863851444125306, 0.22388338422774956, 0.22388338422774956, 0.22388338422774956, 0.24963493390766767, 0.24963493390766767, 0.24963493390766767, 0.22881689040559405, 0.22881689040559405, 0.22881689040559405, 0.1296585639489478, 0.1296585639489478, 0.1296585639489478, 0.20699353734274129, 0.20699353734274129, 0.20699353734274129, 0.2631966226247373, 0.2631966226247373, 0.2631966226247373, 0.19547912713256743, 0.19547912713256743, 0.19547912713256743, 0.24954458885533393, 0.24954458885533393, 0.24954458885533393, 0.19218731959485436, 0.19218731959485436, 0.19218731959485436, 0.18326558541837845, 0.18326558541837845, 0.18326558541837845, 0.8094723448543689, 0.8094723448543689, 0.8094723448543689, 0.15875746093426746, 0.15875746093426746, 0.15875746093426746, 0.17655696079362404, 0.17655696079362404, 0.17655696079362404, 0.16781227070991678, 0.16781227070991678, 0.16781227070991678, 0.21172029721708785, 0.21172029721708785, 0.21172029721708785, 0.15581935048058126, 0.15581935048058126, 0.15581935048058126, 0.20383945346848975, 0.20383945346848975, 0.20383945346848975, 0.19462282467038117, 0.19462282467038117, 0.19462282467038117, 0.21346853165971713, 0.21346853165971713, 0.21346853165971713, 0.10105899811785968, 0.10105899811785968, 0.10105899811785968, 0.08986550808864102, 0.08986550808864102, 0.08986550808864102, 0.09499796039963349, 0.09499796039963349, 0.09499796039963349]}, "mutation_prompt": null}
{"id": "aa69f960-78a0-442a-9074-74a869aaad67", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n        self.chaos_factor = 0.5\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update with chaos perturbation\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + self.chaos_factor * np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Adaptive velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia = np.random.uniform(0.5, 0.9)\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with adaptive crossover\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization using adaptive learning factors and chaos perturbation for improved convergence.", "configspace": "", "generation": 50, "fitness": 0.30758330123423433, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.7809136361226642, 0.7809136361226642, 0.7809136361226642, 0.7443312060552179, 0.7443312060552179, 0.7443312060552179, 0.7968138384492367, 0.7968138384492367, 0.7968138384492367, 0.37408623013663833, 0.37408623013663833, 0.37408623013663833, 0.3311951486189951, 0.3311951486189951, 0.3311951486189951, 0.29376459730004867, 0.29376459730004867, 0.29376459730004867, 0.10991954729944342, 0.10991954729944342, 0.10991954729944342, 0.10354716120847607, 0.10354716120847607, 0.10354716120847607, 0.1287214503800158, 0.1287214503800158, 0.1287214503800158, 0.1012535897611695, 0.1012535897611695, 0.1012535897611695, 0.11764125822082405, 0.11764125822082405, 0.11764125822082405, 0.13519993394878638, 0.13519993394878638, 0.13519993394878638, 0.973087576571244, 0.973087576571244, 0.973087576571244, 0.9768629863308289, 0.9768629863308289, 0.9768629863308289, 0.969908604252124, 0.969908604252124, 0.969908604252124, 0.4802822921483396, 0.4802822921483396, 0.4802822921483396, 0.4540575912124397, 0.4540575912124397, 0.4540575912124397, 0.45224842852270863, 0.45224842852270863, 0.45224842852270863, 0.21291937755495927, 0.21291937755495927, 0.21291937755495927, 0.6982306420386639, 0.6982306420386639, 0.6982306420386639, 0.6781324075023154, 0.6781324075023154, 0.6781324075023154, 0.3875272083064033, 0.3875272083064033, 0.3875272083064033, 0.4008501147066459, 0.4008501147066459, 0.4008501147066459, 0.1517765041081648, 0.1517765041081648, 0.1517765041081648, 0.13137602482102395, 0.13137602482102395, 0.13137602482102395, 0.3532281047574606, 0.3532281047574606, 0.3532281047574606, 0.3776084937705506, 0.3776084937705506, 0.3776084937705506, 0.0527060454575925, 0.0527060454575925, 0.0527060454575925, 0.16759617244521796, 0.16759617244521796, 0.16759617244521796, 0.07155823426248442, 0.07155823426248442, 0.07155823426248442, 0.1346767037542813, 0.1346767037542813, 0.1346767037542813, 0.19460303969024384, 0.19460303969024384, 0.19460303969024384, 0.15464627094165917, 0.15464627094165917, 0.15464627094165917, 0.04504919784045125, 0.04504919784045125, 0.04504919784045125, 0.09933466534971991, 0.09933466534971991, 0.09933466534971991, 0.25301117643450866, 0.25301117643450866, 0.25301117643450866, 0.13817784581052583, 0.13817784581052583, 0.13817784581052583, 0.2637349505019815, 0.2637349505019815, 0.2637349505019815, 0.23358432936046702, 0.23358432936046702, 0.23358432936046702, 0.5420296236035194, 0.5420296236035194, 0.5420296236035194, 0.5412753367696399, 0.5412753367696399, 0.5412753367696399, 0.6057198913369423, 0.6057198913369423, 0.6057198913369423, 0.1400612768620123, 0.1400612768620123, 0.1400612768620123, 0.12078434452041942, 0.12078434452041942, 0.12078434452041942, 0.14587514860784412, 0.14587514860784412, 0.14587514860784412, 0.2937295924969435, 0.2937295924969435, 0.2937295924969435, 0.25683628577872564, 0.25683628577872564, 0.25683628577872564, 0.18371737169674585, 0.18371737169674585, 0.18371737169674585, 0.3384181019958824, 0.3384181019958824, 0.3384181019958824, 0.4204932184954471, 0.4204932184954471, 0.4204932184954471, 0.3294427642619032, 0.3294427642619032, 0.3294427642619032, 0.25274261734159487, 0.25274261734159487, 0.25274261734159487, 0.2069778327981806, 0.2069778327981806, 0.2069778327981806, 0.27887031078625013, 0.27887031078625013, 0.27887031078625013, 0.23365840856932096, 0.23365840856932096, 0.23365840856932096, 0.26480485132198306, 0.26480485132198306, 0.26480485132198306, 0.20149769516990224, 0.20149769516990224, 0.20149769516990224, 0.19735547041505697, 0.19735547041505697, 0.19735547041505697, 0.2220009639190812, 0.2220009639190812, 0.2220009639190812, 0.22087892853328717, 0.22087892853328717, 0.22087892853328717, 0.8849822223891657, 0.8849822223891657, 0.8849822223891657, 0.15772412069991038, 0.15772412069991038, 0.15772412069991038, 0.17525339263448136, 0.17525339263448136, 0.17525339263448136, 0.15173550750508658, 0.15173550750508658, 0.15173550750508658, 0.21024093693800228, 0.21024093693800228, 0.21024093693800228, 0.1555344653720262, 0.1555344653720262, 0.1555344653720262, 0.21784140016818987, 0.21784140016818987, 0.21784140016818987, 0.18915440897529, 0.18915440897529, 0.18915440897529, 0.18667026777189055, 0.18667026777189055, 0.18667026777189055, 0.09017233210567299, 0.09017233210567299, 0.09017233210567299, 0.10953695792149554, 0.10953695792149554, 0.10953695792149554, 0.09581905514845712, 0.09581905514845712, 0.09581905514845712]}, "mutation_prompt": null}
{"id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and elite particle reinforcement.", "configspace": "", "generation": 51, "fitness": 0.393969265462034, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "c0250686-fab1-4974-8ea7-b2a6fbd345c0", "metadata": {"aucs": [0.8321186788849009, 0.8321186788849009, 0.8321186788849009, 0.8077373703110324, 0.8077373703110324, 0.8077373703110324, 0.8230672540546263, 0.8230672540546263, 0.8230672540546263, 0.5116669950722281, 0.5116669950722281, 0.5116669950722281, 0.5661560136612218, 0.5661560136612218, 0.5661560136612218, 0.6113058189557582, 0.6113058189557582, 0.6113058189557582, 0.15980213110663188, 0.15980213110663188, 0.15980213110663188, 0.15836379454087035, 0.15836379454087035, 0.15836379454087035, 0.10700891265479351, 0.10700891265479351, 0.10700891265479351, 0.12732956032599918, 0.12732956032599918, 0.12732956032599918, 0.06905195301446476, 0.06905195301446476, 0.06905195301446476, 0.1345013716819694, 0.1345013716819694, 0.1345013716819694, 0.9591111998970985, 0.9591111998970985, 0.9591111998970985, 0.9585593447047763, 0.9585593447047763, 0.9585593447047763, 0.9574263685928593, 0.9574263685928593, 0.9574263685928593, 0.6364651002009667, 0.6364651002009667, 0.6364651002009667, 0.6951144370755298, 0.6951144370755298, 0.6951144370755298, 0.6686499429390589, 0.6686499429390589, 0.6686499429390589, 0.8100450310483559, 0.8100450310483559, 0.8100450310483559, 0.2191433915634472, 0.2191433915634472, 0.2191433915634472, 0.35535998298566196, 0.35535998298566196, 0.35535998298566196, 0.5982796272612709, 0.5982796272612709, 0.5982796272612709, 0.6415045173467162, 0.6415045173467162, 0.6415045173467162, 0.6398000470576843, 0.6398000470576843, 0.6398000470576843, 0.5428928671013161, 0.5428928671013161, 0.5428928671013161, 0.5642790632999215, 0.5642790632999215, 0.5642790632999215, 0.6524933627785994, 0.6524933627785994, 0.6524933627785994, 0.3320409711584029, 0.3320409711584029, 0.3320409711584029, 0.4064992272210587, 0.4064992272210587, 0.4064992272210587, 0.0032715883739258267, 0.0032715883739258267, 0.0032715883739258267, 0.5339891197626435, 0.5339891197626435, 0.5339891197626435, 0.17748082363632034, 0.17748082363632034, 0.17748082363632034, 0.6205554758644007, 0.6205554758644007, 0.6205554758644007, 0.12699739198808058, 0.12699739198808058, 0.12699739198808058, 0.20264865332135862, 0.20264865332135862, 0.20264865332135862, 0.10359900711219672, 0.10359900711219672, 0.10359900711219672, 0.17336943788479298, 0.17336943788479298, 0.17336943788479298, 0.03797532713121943, 0.03797532713121943, 0.03797532713121943, 0.055864185337872185, 0.055864185337872185, 0.055864185337872185, 0.7251167159474545, 0.7251167159474545, 0.7251167159474545, 0.6908898067973139, 0.6908898067973139, 0.6908898067973139, 0.7367565470019714, 0.7367565470019714, 0.7367565470019714, 0.13749820551805536, 0.13749820551805536, 0.13749820551805536, 0.1826801551718401, 0.1826801551718401, 0.1826801551718401, 0.12066259163666926, 0.12066259163666926, 0.12066259163666926, 0.202893140333395, 0.202893140333395, 0.202893140333395, 0.2314563184270485, 0.2314563184270485, 0.2314563184270485, 0.38954346630555825, 0.38954346630555825, 0.38954346630555825, 0.37502158564298227, 0.37502158564298227, 0.37502158564298227, 0.3059459622620033, 0.3059459622620033, 0.3059459622620033, 0.48969630406392073, 0.48969630406392073, 0.48969630406392073, 0.2480830354911986, 0.2480830354911986, 0.2480830354911986, 0.443672575036419, 0.443672575036419, 0.443672575036419, 0.1644781920745234, 0.1644781920745234, 0.1644781920745234, 0.2843285752980297, 0.2843285752980297, 0.2843285752980297, 0.22353751179202908, 0.22353751179202908, 0.22353751179202908, 0.23127309941644802, 0.23127309941644802, 0.23127309941644802, 0.7425618916612338, 0.7425618916612338, 0.7425618916612338, 0.20694529613164991, 0.20694529613164991, 0.20694529613164991, 0.19579955627160162, 0.19579955627160162, 0.19579955627160162, 0.9081391265722403, 0.9081391265722403, 0.9081391265722403, 0.15891442399030364, 0.15891442399030364, 0.15891442399030364, 0.17133278472820113, 0.17133278472820113, 0.17133278472820113, 0.20935471733507016, 0.20935471733507016, 0.20935471733507016, 0.21098447324252212, 0.21098447324252212, 0.21098447324252212, 0.8094593742775736, 0.8094593742775736, 0.8094593742775736, 0.2177271797225232, 0.2177271797225232, 0.2177271797225232, 0.24910938126412285, 0.24910938126412285, 0.24910938126412285, 0.2474734376703408, 0.2474734376703408, 0.2474734376703408, 0.09066702526169679, 0.09066702526169679, 0.09066702526169679, 0.08767401619723092, 0.08767401619723092, 0.08767401619723092, 0.09458529381324443, 0.09458529381324443, 0.09458529381324443]}, "mutation_prompt": null}
{"id": "1cd3e287-b6b3-44e1-a5dc-33bf5c189a9a", "solution": "import numpy as np\n\nclass AdaptiveQuantumDEPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.4\n        self.cognitive = 1.4\n        self.social = 1.9\n        self.quantum_prob = 0.20\n        self.elite_quantum_prob = 0.10\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.75\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.3\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best with hierarchy consideration\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumDEPopulation", "description": "Adaptive Quantum Differential Evolution-Population Algorithm with dynamic parameter tuning and hierarchy-based reinforcement.", "configspace": "", "generation": 52, "fitness": 0.3409777907437186, "feedback": "The algorithm AdaptiveQuantumDEPopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8510892987632411, 0.8510892987632411, 0.8510892987632411, 0.8237721016823405, 0.8237721016823405, 0.8237721016823405, 0.8651338245772968, 0.8651338245772968, 0.8651338245772968, 0.612387864637879, 0.612387864637879, 0.612387864637879, 0.5659091180051892, 0.5659091180051892, 0.5659091180051892, 0.6269573529948183, 0.6269573529948183, 0.6269573529948183, 0.11666450083456437, 0.11666450083456437, 0.11666450083456437, 0.09140060798222727, 0.09140060798222727, 0.09140060798222727, 0.1307888976611712, 0.1307888976611712, 0.1307888976611712, 0.17921905239420843, 0.17921905239420843, 0.17921905239420843, 0.08232156970547044, 0.08232156970547044, 0.08232156970547044, 0.10598755183131803, 0.10598755183131803, 0.10598755183131803, 0.9742096398406875, 0.9742096398406875, 0.9742096398406875, 0.9496127229569317, 0.9496127229569317, 0.9496127229569317, 0.9578472474877539, 0.9578472474877539, 0.9578472474877539, 0.6281630488483364, 0.6281630488483364, 0.6281630488483364, 0.723345805464893, 0.723345805464893, 0.723345805464893, 0.6877490422520536, 0.6877490422520536, 0.6877490422520536, 0.8426742855266534, 0.8426742855266534, 0.8426742855266534, 0.21156128748668723, 0.21156128748668723, 0.21156128748668723, 0.2312408216558418, 0.2312408216558418, 0.2312408216558418, 0.38202463474563386, 0.38202463474563386, 0.38202463474563386, 0.13373240918617435, 0.13373240918617435, 0.13373240918617435, 0.5744076658440869, 0.5744076658440869, 0.5744076658440869, 0.1336963838000591, 0.1336963838000591, 0.1336963838000591, 0.1344307904835681, 0.1344307904835681, 0.1344307904835681, 0.4215704928867231, 0.4215704928867231, 0.4215704928867231, 0.1887975366076151, 0.1887975366076151, 0.1887975366076151, 0.039517435499037856, 0.039517435499037856, 0.039517435499037856, 0.12507888199824446, 0.12507888199824446, 0.12507888199824446, 0.3769112710606447, 0.3769112710606447, 0.3769112710606447, 0.12537095812711108, 0.12537095812711108, 0.12537095812711108, 0.22058544304693573, 0.22058544304693573, 0.22058544304693573, 0.11455067502214367, 0.11455067502214367, 0.11455067502214367, 0.09125320812451443, 0.09125320812451443, 0.09125320812451443, 0.10528084730598763, 0.10528084730598763, 0.10528084730598763, 0.2842334234770829, 0.2842334234770829, 0.2842334234770829, 0.3811194749780581, 0.3811194749780581, 0.3811194749780581, 0.08260601139402446, 0.08260601139402446, 0.08260601139402446, 0.6649324380735409, 0.6649324380735409, 0.6649324380735409, 0.7491159163628159, 0.7491159163628159, 0.7491159163628159, 0.6199543907034168, 0.6199543907034168, 0.6199543907034168, 0.1421492871093345, 0.1421492871093345, 0.1421492871093345, 0.13529302408305943, 0.13529302408305943, 0.13529302408305943, 0.0650432780517376, 0.0650432780517376, 0.0650432780517376, 0.21429715052500942, 0.21429715052500942, 0.21429715052500942, 0.4824315120226923, 0.4824315120226923, 0.4824315120226923, 0.4157995632618565, 0.4157995632618565, 0.4157995632618565, 0.38259655540005066, 0.38259655540005066, 0.38259655540005066, 0.3509058391949821, 0.3509058391949821, 0.3509058391949821, 0.4944822874840301, 0.4944822874840301, 0.4944822874840301, 0.26160019401847756, 0.26160019401847756, 0.26160019401847756, 0.2673487033643599, 0.2673487033643599, 0.2673487033643599, 0.13517923681722654, 0.13517923681722654, 0.13517923681722654, 0.20033781757939007, 0.20033781757939007, 0.20033781757939007, 0.2403793322399409, 0.2403793322399409, 0.2403793322399409, 0.23964505789156376, 0.23964505789156376, 0.23964505789156376, 0.19169044153465797, 0.19169044153465797, 0.19169044153465797, 0.22308805250821373, 0.22308805250821373, 0.22308805250821373, 0.1750747378089047, 0.1750747378089047, 0.1750747378089047, 0.9223154011463229, 0.9223154011463229, 0.9223154011463229, 0.1583397984751136, 0.1583397984751136, 0.1583397984751136, 0.1692589191076902, 0.1692589191076902, 0.1692589191076902, 0.1545816493626866, 0.1545816493626866, 0.1545816493626866, 0.20918578362758566, 0.20918578362758566, 0.20918578362758566, 0.15570885649980826, 0.15570885649980826, 0.15570885649980826, 0.20598445500669305, 0.20598445500669305, 0.20598445500669305, 0.19905939619952118, 0.19905939619952118, 0.19905939619952118, 0.2378025047827832, 0.2378025047827832, 0.2378025047827832, 0.10382345960046568, 0.10382345960046568, 0.10382345960046568, 0.10015281931375974, 0.10015281931375974, 0.10015281931375974, 0.10963988821283999, 0.10963988821283999, 0.10963988821283999]}, "mutation_prompt": null}
{"id": "ba942b8e-fb60-4350-b7c9-05b971623156", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 0.1, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveDSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization with dynamic parameter tuning and elite reinforcement.", "configspace": "", "generation": 53, "fitness": 0.3010283915981686, "feedback": "The algorithm QuantumEnhancedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.753483442641725, 0.753483442641725, 0.753483442641725, 0.7087237025889027, 0.7087237025889027, 0.7087237025889027, 0.7586397380689716, 0.7586397380689716, 0.7586397380689716, 0.22968249575020716, 0.22968249575020716, 0.22968249575020716, 0.3086652624645527, 0.3086652624645527, 0.3086652624645527, 0.041921031089176886, 0.041921031089176886, 0.041921031089176886, 0.13672015653427283, 0.13672015653427283, 0.13672015653427283, 0.1816951542590146, 0.1816951542590146, 0.1816951542590146, 0.11537335688883432, 0.11537335688883432, 0.11537335688883432, 0.05225143787871822, 0.05225143787871822, 0.05225143787871822, 0.08024149928067148, 0.08024149928067148, 0.08024149928067148, 0.08203462783117343, 0.08203462783117343, 0.08203462783117343, 0.947111223095105, 0.947111223095105, 0.947111223095105, 0.9435952082841473, 0.9435952082841473, 0.9435952082841473, 0.9613926499083459, 0.9613926499083459, 0.9613926499083459, 0.5009915743029836, 0.5009915743029836, 0.5009915743029836, 0.49336383375326875, 0.49336383375326875, 0.49336383375326875, 0.4468156644854102, 0.4468156644854102, 0.4468156644854102, 0.22365278996819637, 0.22365278996819637, 0.22365278996819637, 0.2688367639092982, 0.2688367639092982, 0.2688367639092982, 0.7342695468873133, 0.7342695468873133, 0.7342695468873133, 0.2685933977018844, 0.2685933977018844, 0.2685933977018844, 0.3893080350872591, 0.3893080350872591, 0.3893080350872591, 0.4060463373723615, 0.4060463373723615, 0.4060463373723615, 0.34006544510275716, 0.34006544510275716, 0.34006544510275716, 0.325685159590391, 0.325685159590391, 0.325685159590391, 0.3466634806694219, 0.3466634806694219, 0.3466634806694219, 0.07502260942482808, 0.07502260942482808, 0.07502260942482808, 0.14255833830533016, 0.14255833830533016, 0.14255833830533016, 0.12309962184642953, 0.12309962184642953, 0.12309962184642953, 0.15837141594719673, 0.15837141594719673, 0.15837141594719673, 0.09837994506699566, 0.09837994506699566, 0.09837994506699566, 0.2422634944556259, 0.2422634944556259, 0.2422634944556259, 0.03988144916323921, 0.03988144916323921, 0.03988144916323921, 0.10986057573100494, 0.10986057573100494, 0.10986057573100494, 0.1183447098237772, 0.1183447098237772, 0.1183447098237772, 0.13230445264154655, 0.13230445264154655, 0.13230445264154655, 0.15444324113358454, 0.15444324113358454, 0.15444324113358454, 0.08004833954115964, 0.08004833954115964, 0.08004833954115964, 0.5782946715579207, 0.5782946715579207, 0.5782946715579207, 0.5544032895684484, 0.5544032895684484, 0.5544032895684484, 0.6004996077237628, 0.6004996077237628, 0.6004996077237628, 0.1115117172325335, 0.1115117172325335, 0.1115117172325335, 0.11017771019109313, 0.11017771019109313, 0.11017771019109313, 0.08719325572769598, 0.08719325572769598, 0.08719325572769598, 0.24768636918382503, 0.24768636918382503, 0.24768636918382503, 0.20816906955848713, 0.20816906955848713, 0.20816906955848713, 0.20749068838986873, 0.20749068838986873, 0.20749068838986873, 0.33687122503430567, 0.33687122503430567, 0.33687122503430567, 0.4237788498657734, 0.4237788498657734, 0.4237788498657734, 0.29430515710506755, 0.29430515710506755, 0.29430515710506755, 0.23798460247374564, 0.23798460247374564, 0.23798460247374564, 0.2858227297554756, 0.2858227297554756, 0.2858227297554756, 0.21297683220894836, 0.21297683220894836, 0.21297683220894836, 0.21219878900006084, 0.21219878900006084, 0.21219878900006084, 0.2567115518695169, 0.2567115518695169, 0.2567115518695169, 0.2661476147913976, 0.2661476147913976, 0.2661476147913976, 0.2214929981994942, 0.2214929981994942, 0.2214929981994942, 0.2075348543248261, 0.2075348543248261, 0.2075348543248261, 0.19920251254068055, 0.19920251254068055, 0.19920251254068055, 0.901507219151273, 0.901507219151273, 0.901507219151273, 0.1582446678041266, 0.1582446678041266, 0.1582446678041266, 0.16764752316379805, 0.16764752316379805, 0.16764752316379805, 0.16834330233965555, 0.16834330233965555, 0.16834330233965555, 0.21144003812756673, 0.21144003812756673, 0.21144003812756673, 0.8167768245815776, 0.8167768245815776, 0.8167768245815776, 0.20235468172008275, 0.20235468172008275, 0.20235468172008275, 0.18943634160618272, 0.18943634160618272, 0.18943634160618272, 0.19546539410482233, 0.19546539410482233, 0.19546539410482233, 0.09864467928283871, 0.09864467928283871, 0.09864467928283871, 0.09384239253498894, 0.09384239253498894, 0.09384239253498894, 0.08948582587321652, 0.08948582587321652, 0.08948582587321652]}, "mutation_prompt": null}
{"id": "0a2f378c-574a-4815-b0d2-239bd8a3042f", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and elite particle reinforcement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8321186788849009, 0.8321186788849009, 0.8321186788849009, 0.8077373703110324, 0.8077373703110324, 0.8077373703110324, 0.8230672540546263, 0.8230672540546263, 0.8230672540546263, 0.5116669950722281, 0.5116669950722281, 0.5116669950722281, 0.5661560136612218, 0.5661560136612218, 0.5661560136612218, 0.6113058189557582, 0.6113058189557582, 0.6113058189557582, 0.15980213110663188, 0.15980213110663188, 0.15980213110663188, 0.15836379454087035, 0.15836379454087035, 0.15836379454087035, 0.10700891265479351, 0.10700891265479351, 0.10700891265479351, 0.12732956032599918, 0.12732956032599918, 0.12732956032599918, 0.06905195301446476, 0.06905195301446476, 0.06905195301446476, 0.1345013716819694, 0.1345013716819694, 0.1345013716819694, 0.9591111998970985, 0.9591111998970985, 0.9591111998970985, 0.9585593447047763, 0.9585593447047763, 0.9585593447047763, 0.9574263685928593, 0.9574263685928593, 0.9574263685928593, 0.6364651002009667, 0.6364651002009667, 0.6364651002009667, 0.6951144370755298, 0.6951144370755298, 0.6951144370755298, 0.6686499429390589, 0.6686499429390589, 0.6686499429390589, 0.8100450310483559, 0.8100450310483559, 0.8100450310483559, 0.2191433915634472, 0.2191433915634472, 0.2191433915634472, 0.35535998298566196, 0.35535998298566196, 0.35535998298566196, 0.5982796272612709, 0.5982796272612709, 0.5982796272612709, 0.6415045173467162, 0.6415045173467162, 0.6415045173467162, 0.6398000470576843, 0.6398000470576843, 0.6398000470576843, 0.5428928671013161, 0.5428928671013161, 0.5428928671013161, 0.5642790632999215, 0.5642790632999215, 0.5642790632999215, 0.6524933627785994, 0.6524933627785994, 0.6524933627785994, 0.3320409711584029, 0.3320409711584029, 0.3320409711584029, 0.4064992272210587, 0.4064992272210587, 0.4064992272210587, 0.0032715883739258267, 0.0032715883739258267, 0.0032715883739258267, 0.5339891197626435, 0.5339891197626435, 0.5339891197626435, 0.17748082363632034, 0.17748082363632034, 0.17748082363632034, 0.6205554758644007, 0.6205554758644007, 0.6205554758644007, 0.12699739198808058, 0.12699739198808058, 0.12699739198808058, 0.20264865332135862, 0.20264865332135862, 0.20264865332135862, 0.10359900711219672, 0.10359900711219672, 0.10359900711219672, 0.17336943788479298, 0.17336943788479298, 0.17336943788479298, 0.03797532713121943, 0.03797532713121943, 0.03797532713121943, 0.055864185337872185, 0.055864185337872185, 0.055864185337872185, 0.7251167159474545, 0.7251167159474545, 0.7251167159474545, 0.6908898067973139, 0.6908898067973139, 0.6908898067973139, 0.7367565470019714, 0.7367565470019714, 0.7367565470019714, 0.13749820551805536, 0.13749820551805536, 0.13749820551805536, 0.1826801551718401, 0.1826801551718401, 0.1826801551718401, 0.12066259163666926, 0.12066259163666926, 0.12066259163666926, 0.202893140333395, 0.202893140333395, 0.202893140333395, 0.2314563184270485, 0.2314563184270485, 0.2314563184270485, 0.38954346630555825, 0.38954346630555825, 0.38954346630555825, 0.37502158564298227, 0.37502158564298227, 0.37502158564298227, 0.3059459622620033, 0.3059459622620033, 0.3059459622620033, 0.48969630406392073, 0.48969630406392073, 0.48969630406392073, 0.2480830354911986, 0.2480830354911986, 0.2480830354911986, 0.443672575036419, 0.443672575036419, 0.443672575036419, 0.1644781920745234, 0.1644781920745234, 0.1644781920745234, 0.2843285752980297, 0.2843285752980297, 0.2843285752980297, 0.22353751179202908, 0.22353751179202908, 0.22353751179202908, 0.23127309941644802, 0.23127309941644802, 0.23127309941644802, 0.7425618916612338, 0.7425618916612338, 0.7425618916612338, 0.20694529613164991, 0.20694529613164991, 0.20694529613164991, 0.19579955627160162, 0.19579955627160162, 0.19579955627160162, 0.9081391265722403, 0.9081391265722403, 0.9081391265722403, 0.15891442399030364, 0.15891442399030364, 0.15891442399030364, 0.17133278472820113, 0.17133278472820113, 0.17133278472820113, 0.20935471733507016, 0.20935471733507016, 0.20935471733507016, 0.21098447324252212, 0.21098447324252212, 0.21098447324252212, 0.8094593742775736, 0.8094593742775736, 0.8094593742775736, 0.2177271797225232, 0.2177271797225232, 0.2177271797225232, 0.24910938126412285, 0.24910938126412285, 0.24910938126412285, 0.2474734376703408, 0.2474734376703408, 0.2474734376703408, 0.09066702526169679, 0.09066702526169679, 0.09066702526169679, 0.08767401619723092, 0.08767401619723092, 0.08767401619723092, 0.09458529381324443, 0.09458529381324443, 0.09458529381324443]}, "mutation_prompt": null}
{"id": "ebb128d6-09bf-4124-8ad1-3913b51aa432", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 1, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumEnhancedPSO", "description": "Adaptive Quantum-Enhanced Particle Swarm Optimization with Differential Evolution mutation and dynamic boundary adjustments.", "configspace": "", "generation": 55, "fitness": 0.32577131363750994, "feedback": "The algorithm AdaptiveQuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.25.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8251154020058135, 0.8251154020058135, 0.8251154020058135, 0.8206960557328082, 0.8206960557328082, 0.8206960557328082, 0.8327497503228474, 0.8327497503228474, 0.8327497503228474, 0.4679002601709298, 0.4679002601709298, 0.4679002601709298, 0.5229705673579652, 0.5229705673579652, 0.5229705673579652, 0.6103891454051312, 0.6103891454051312, 0.6103891454051312, 0.12247074020491822, 0.12247074020491822, 0.12247074020491822, 0.14259778566914338, 0.14259778566914338, 0.14259778566914338, 0.12092176932663556, 0.12092176932663556, 0.12092176932663556, 0.08520362377516089, 0.08520362377516089, 0.08520362377516089, 0.16105204113734994, 0.16105204113734994, 0.16105204113734994, 0.10772771530418102, 0.10772771530418102, 0.10772771530418102, 0.9308627466314642, 0.9308627466314642, 0.9308627466314642, 0.9719114788010024, 0.9719114788010024, 0.9719114788010024, 0.9768659779831285, 0.9768659779831285, 0.9768659779831285, 0.6124363835119291, 0.6124363835119291, 0.6124363835119291, 0.5764789628430181, 0.5764789628430181, 0.5764789628430181, 0.6379570505537614, 0.6379570505537614, 0.6379570505537614, 0.2226576455466207, 0.2226576455466207, 0.2226576455466207, 0.19229029177382362, 0.19229029177382362, 0.19229029177382362, 0.19238624148849925, 0.19238624148849925, 0.19238624148849925, 0.37965168391933235, 0.37965168391933235, 0.37965168391933235, 0.213233433129148, 0.213233433129148, 0.213233433129148, 0.4196104870910552, 0.4196104870910552, 0.4196104870910552, 0.42348174929026494, 0.42348174929026494, 0.42348174929026494, 0.130167489306509, 0.130167489306509, 0.130167489306509, 0.44383753883214194, 0.44383753883214194, 0.44383753883214194, 0.10254281849422986, 0.10254281849422986, 0.10254281849422986, 0.10107353833452182, 0.10107353833452182, 0.10107353833452182, 0.1506159508289524, 0.1506159508289524, 0.1506159508289524, 0.2819912951394513, 0.2819912951394513, 0.2819912951394513, 0.18787746766033842, 0.18787746766033842, 0.18787746766033842, 0.5314365068390146, 0.5314365068390146, 0.5314365068390146, 0.04662718870826155, 0.04662718870826155, 0.04662718870826155, 0.09997240735409774, 0.09997240735409774, 0.09997240735409774, 0.16124943507523637, 0.16124943507523637, 0.16124943507523637, 0.23093838359000185, 0.23093838359000185, 0.23093838359000185, 0.324475622186296, 0.324475622186296, 0.324475622186296, 0.05632499596321827, 0.05632499596321827, 0.05632499596321827, 0.6830380456255298, 0.6830380456255298, 0.6830380456255298, 0.6867984744580908, 0.6867984744580908, 0.6867984744580908, 0.6452410097090083, 0.6452410097090083, 0.6452410097090083, 0.12020670667852629, 0.12020670667852629, 0.12020670667852629, 0.12004504214121081, 0.12004504214121081, 0.12004504214121081, 0.13536654999240527, 0.13536654999240527, 0.13536654999240527, 0.2122161227654158, 0.2122161227654158, 0.2122161227654158, 0.17754139577096062, 0.17754139577096062, 0.17754139577096062, 0.2673497095541264, 0.2673497095541264, 0.2673497095541264, 0.31071063051584247, 0.31071063051584247, 0.31071063051584247, 0.3740475571259946, 0.3740475571259946, 0.3740475571259946, 0.2836534454812015, 0.2836534454812015, 0.2836534454812015, 0.4529082302148001, 0.4529082302148001, 0.4529082302148001, 0.25944614746006334, 0.25944614746006334, 0.25944614746006334, 0.21488002630289116, 0.21488002630289116, 0.21488002630289116, 0.22956774839795402, 0.22956774839795402, 0.22956774839795402, 0.24822913039519912, 0.24822913039519912, 0.24822913039519912, 0.26422943779313135, 0.26422943779313135, 0.26422943779313135, 0.20108323896863167, 0.20108323896863167, 0.20108323896863167, 0.19145600914744987, 0.19145600914744987, 0.19145600914744987, 0.19070972421160937, 0.19070972421160937, 0.19070972421160937, 0.922761911219608, 0.922761911219608, 0.922761911219608, 0.15771051961978033, 0.15771051961978033, 0.15771051961978033, 0.17505017610216822, 0.17505017610216822, 0.17505017610216822, 0.15573067403795682, 0.15573067403795682, 0.15573067403795682, 0.21118698721529394, 0.21118698721529394, 0.21118698721529394, 0.20289339172260945, 0.20289339172260945, 0.20289339172260945, 0.21197161122918373, 0.21197161122918373, 0.21197161122918373, 0.22228467710278677, 0.22228467710278677, 0.22228467710278677, 0.19942682673975132, 0.19942682673975132, 0.19942682673975132, 0.11170268907927128, 0.11170268907927128, 0.11170268907927128, 0.10176570959874576, 0.10176570959874576, 0.10176570959874576, 0.09557539823531536, 0.09557539823531536, 0.09557539823531536]}, "mutation_prompt": null}
{"id": "4a975bcf-f25f-4ed2-bebd-c0e4b2f6e5f7", "solution": "import numpy as np\n\nclass QuantumGuidedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.6\n        self.cognitive = 1.4\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                r1, r2 = np.random.rand(), np.random.rand()\n                \n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.5, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 0.5, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumGuidedAdaptiveDSO", "description": "Quantum-Guided Adaptive Differential Swarm Optimization with enhanced convergence speed and diversity maintenance.", "configspace": "", "generation": 56, "fitness": 0.31716909949547684, "feedback": "The algorithm QuantumGuidedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7783018731484374, 0.7783018731484374, 0.7783018731484374, 0.7499390645526105, 0.7499390645526105, 0.7499390645526105, 0.7985081447984466, 0.7985081447984466, 0.7985081447984466, 0.3178203022934568, 0.3178203022934568, 0.3178203022934568, 0.3750517370143347, 0.3750517370143347, 0.3750517370143347, 0.3385526628499811, 0.3385526628499811, 0.3385526628499811, 0.14093124140743007, 0.14093124140743007, 0.14093124140743007, 0.12018998278915005, 0.12018998278915005, 0.12018998278915005, 0.10797235627631652, 0.10797235627631652, 0.10797235627631652, 0.11053635807395168, 0.11053635807395168, 0.11053635807395168, 0.10461067925522016, 0.10461067925522016, 0.10461067925522016, 0.11056958836821118, 0.11056958836821118, 0.11056958836821118, 0.95803437143182, 0.95803437143182, 0.95803437143182, 0.9511371588978522, 0.9511371588978522, 0.9511371588978522, 0.9447919229294623, 0.9447919229294623, 0.9447919229294623, 0.5593722096906055, 0.5593722096906055, 0.5593722096906055, 0.5055563501796674, 0.5055563501796674, 0.5055563501796674, 0.5608868898123995, 0.5608868898123995, 0.5608868898123995, 0.7306528687530869, 0.7306528687530869, 0.7306528687530869, 0.19632294556206176, 0.19632294556206176, 0.19632294556206176, 0.796881924417835, 0.796881924417835, 0.796881924417835, 0.3770047155036138, 0.3770047155036138, 0.3770047155036138, 0.3169019940277562, 0.3169019940277562, 0.3169019940277562, 0.27446251487117157, 0.27446251487117157, 0.27446251487117157, 0.26114420060942256, 0.26114420060942256, 0.26114420060942256, 0.23240729158240891, 0.23240729158240891, 0.23240729158240891, 0.13043086150717265, 0.13043086150717265, 0.13043086150717265, 0.11244029327329097, 0.11244029327329097, 0.11244029327329097, 0.1340983758385269, 0.1340983758385269, 0.1340983758385269, 0.21738776194834564, 0.21738776194834564, 0.21738776194834564, 0.15824299971268063, 0.15824299971268063, 0.15824299971268063, 0.0508792041874101, 0.0508792041874101, 0.0508792041874101, 0.10942513325192926, 0.10942513325192926, 0.10942513325192926, 0.04145891682344349, 0.04145891682344349, 0.04145891682344349, 0.0635315666100259, 0.0635315666100259, 0.0635315666100259, 0.22384098422313314, 0.22384098422313314, 0.22384098422313314, 0.13931738834600949, 0.13931738834600949, 0.13931738834600949, 0.1252852955063265, 0.1252852955063265, 0.1252852955063265, 0.24699568055751897, 0.24699568055751897, 0.24699568055751897, 0.6134826982425574, 0.6134826982425574, 0.6134826982425574, 0.6170381637806361, 0.6170381637806361, 0.6170381637806361, 0.6056108917639293, 0.6056108917639293, 0.6056108917639293, 0.10676430583840324, 0.10676430583840324, 0.10676430583840324, 0.1476324214744389, 0.1476324214744389, 0.1476324214744389, 0.1022787479941395, 0.1022787479941395, 0.1022787479941395, 0.20016740141152178, 0.20016740141152178, 0.20016740141152178, 0.22397586735037023, 0.22397586735037023, 0.22397586735037023, 0.16927412408387388, 0.16927412408387388, 0.16927412408387388, 0.3795802725197066, 0.3795802725197066, 0.3795802725197066, 0.41421842379275065, 0.41421842379275065, 0.41421842379275065, 0.3237869973775751, 0.3237869973775751, 0.3237869973775751, 0.24503007309878644, 0.24503007309878644, 0.24503007309878644, 0.2134849377139092, 0.2134849377139092, 0.2134849377139092, 0.21970852164219346, 0.21970852164219346, 0.21970852164219346, 0.1918080543888947, 0.1918080543888947, 0.1918080543888947, 0.2053571013792297, 0.2053571013792297, 0.2053571013792297, 0.2098190946362949, 0.2098190946362949, 0.2098190946362949, 0.18529003423907464, 0.18529003423907464, 0.18529003423907464, 0.20683523824798045, 0.20683523824798045, 0.20683523824798045, 0.4899489499002654, 0.4899489499002654, 0.4899489499002654, 0.9078355942892778, 0.9078355942892778, 0.9078355942892778, 0.15771485347435266, 0.15771485347435266, 0.15771485347435266, 0.1362860529745098, 0.1362860529745098, 0.1362860529745098, 0.8218496431299469, 0.8218496431299469, 0.8218496431299469, 0.21001002490445708, 0.21001002490445708, 0.21001002490445708, 0.1555708868035055, 0.1555708868035055, 0.1555708868035055, 0.19498964953933218, 0.19498964953933218, 0.19498964953933218, 0.20032318719311504, 0.20032318719311504, 0.20032318719311504, 0.196576456103836, 0.196576456103836, 0.196576456103836, 0.09358044897626916, 0.09358044897626916, 0.09358044897626916, 0.10307273250279436, 0.10307273250279436, 0.10307273250279436, 0.115397502023879, 0.115397502023879, 0.115397502023879]}, "mutation_prompt": null}
{"id": "89023ac1-b105-481f-8d9c-d3d744eda140", "solution": "import numpy as np\n\nclass QuantumEnhancedDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update with adaptive inertia\n                inertia_weight = self.inertia - (eval_count / self.budget) * (self.inertia - 0.4)\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia_weight * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] += np.random.normal(0, 0.1, self.dim)  # Stochastic perturbation\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedDSO", "description": "Quantum-Enhanced Differential Swarm Optimization with stochastic velocity perturbations and adaptive inertia for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.20482494166972173, "feedback": "The algorithm QuantumEnhancedDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.40123861243017855, 0.40123861243017855, 0.40123861243017855, 0.3911856717459308, 0.3911856717459308, 0.3911856717459308, 0.4164287380360986, 0.4164287380360986, 0.4164287380360986, 0.010825473239355565, 0.010825473239355565, 0.010825473239355565, 0.020984878247272687, 0.020984878247272687, 0.020984878247272687, 0.007762924329593579, 0.007762924329593579, 0.007762924329593579, 0.10134300765211901, 0.10134300765211901, 0.10134300765211901, 0.10541568162432535, 0.10541568162432535, 0.10541568162432535, 0.12705942268913295, 0.12705942268913295, 0.12705942268913295, 0.09562844859542385, 0.09562844859542385, 0.09562844859542385, 0.08425749323136245, 0.08425749323136245, 0.08425749323136245, 0.10031973127130223, 0.10031973127130223, 0.10031973127130223, 0.9642196211376733, 0.9642196211376733, 0.9642196211376733, 0.97071969792477, 0.97071969792477, 0.97071969792477, 0.972742016247729, 0.972742016247729, 0.972742016247729, 0.2668115082604051, 0.2668115082604051, 0.2668115082604051, 0.25698491065249995, 0.25698491065249995, 0.25698491065249995, 0.25317461559202736, 0.25317461559202736, 0.25317461559202736, 0.3210667798874164, 0.3210667798874164, 0.3210667798874164, 0.22566554115595172, 0.22566554115595172, 0.22566554115595172, 0.26804675684702484, 0.26804675684702484, 0.26804675684702484, 0.1542266356084503, 0.1542266356084503, 0.1542266356084503, 0.15572081432512008, 0.15572081432512008, 0.15572081432512008, 0.1428192104234307, 0.1428192104234307, 0.1428192104234307, 0.12212012169185105, 0.12212012169185105, 0.12212012169185105, 0.16565529000859658, 0.16565529000859658, 0.16565529000859658, 0.16140151909444633, 0.16140151909444633, 0.16140151909444633, 0.04071620057280867, 0.04071620057280867, 0.04071620057280867, 0.02712711446771665, 0.02712711446771665, 0.02712711446771665, 0.0031896378452201946, 0.0031896378452201946, 0.0031896378452201946, 0.12227766528700945, 0.12227766528700945, 0.12227766528700945, 0.022853835321934413, 0.022853835321934413, 0.022853835321934413, 0.06547705600378617, 0.06547705600378617, 0.06547705600378617, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.095868611199039, 0.095868611199039, 0.095868611199039, 0.08809492772619465, 0.08809492772619465, 0.08809492772619465, 0.04631952567327624, 0.04631952567327624, 0.04631952567327624, 0.37956595403503124, 0.37956595403503124, 0.37956595403503124, 0.3814938865378845, 0.3814938865378845, 0.3814938865378845, 0.38363521246046284, 0.38363521246046284, 0.38363521246046284, 0.08769201235153246, 0.08769201235153246, 0.08769201235153246, 0.11993212229340133, 0.11993212229340133, 0.11993212229340133, 0.08629366438833586, 0.08629366438833586, 0.08629366438833586, 0.23195505129107308, 0.23195505129107308, 0.23195505129107308, 0.17900419814158008, 0.17900419814158008, 0.17900419814158008, 0.15649423274632768, 0.15649423274632768, 0.15649423274632768, 0.2798399610837632, 0.2798399610837632, 0.2798399610837632, 0.29453608475165005, 0.29453608475165005, 0.29453608475165005, 0.247401999722907, 0.247401999722907, 0.247401999722907, 0.20472667526472266, 0.20472667526472266, 0.20472667526472266, 0.21318891120102523, 0.21318891120102523, 0.21318891120102523, 0.16323302630885717, 0.16323302630885717, 0.16323302630885717, 0.2359278437090807, 0.2359278437090807, 0.2359278437090807, 0.21725200772169506, 0.21725200772169506, 0.21725200772169506, 0.2200119653665361, 0.2200119653665361, 0.2200119653665361, 0.19773936340678955, 0.19773936340678955, 0.19773936340678955, 0.1928854371166342, 0.1928854371166342, 0.1928854371166342, 0.18135910608404116, 0.18135910608404116, 0.18135910608404116, 0.6364195067030426, 0.6364195067030426, 0.6364195067030426, 0.15661557119075786, 0.15661557119075786, 0.15661557119075786, 0.17485698612269518, 0.17485698612269518, 0.17485698612269518, 0.1686894082234508, 0.1686894082234508, 0.1686894082234508, 0.2096108630695398, 0.2096108630695398, 0.2096108630695398, 0.15570375960244542, 0.15570375960244542, 0.15570375960244542, 0.19610837926221614, 0.19610837926221614, 0.19610837926221614, 0.1814938344154442, 0.1814938344154442, 0.1814938344154442, 0.18144828121716106, 0.18144828121716106, 0.18144828121716106, 0.0913251945585849, 0.0913251945585849, 0.0913251945585849, 0.08597594683267273, 0.08597594683267273, 0.08597594683267273, 0.07892965699215038, 0.07892965699215038, 0.07892965699215038]}, "mutation_prompt": null}
{"id": "e4e90cf4-0262-4e42-8dc1-5a3996dec218", "solution": "import numpy as np\n\nclass QuantumDifferentialSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.9  # Increased initial inertia\n        self.cognitive = 1.5  # Slightly adjusted cognitive component\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n        self.inertia_damp = 0.99  # Added inertia damping factor\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            self.inertia *= self.inertia_damp  # Apply inertia damping\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumDifferentialSwarmOptimization", "description": "Quantum-Inspired Enhanced Differential Swarm Optimization with adaptive inertia and dynamic mutation control.", "configspace": "", "generation": 58, "fitness": 0.3040340240613232, "feedback": "The algorithm QuantumDifferentialSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7517164730295952, 0.7517164730295952, 0.7517164730295952, 0.7159947241042981, 0.7159947241042981, 0.7159947241042981, 0.7041688669628167, 0.7041688669628167, 0.7041688669628167, 0.02617633026170063, 0.02617633026170063, 0.02617633026170063, 0.12152708737524609, 0.12152708737524609, 0.12152708737524609, 0.3762410151467591, 0.3762410151467591, 0.3762410151467591, 0.16482085898798993, 0.16482085898798993, 0.16482085898798993, 0.10067949539078491, 0.10067949539078491, 0.10067949539078491, 0.10007748135526329, 0.10007748135526329, 0.10007748135526329, 0.09967778510505809, 0.09967778510505809, 0.09967778510505809, 0.09899480468988042, 0.09899480468988042, 0.09899480468988042, 0.08502447914787914, 0.08502447914787914, 0.08502447914787914, 0.961718096615083, 0.961718096615083, 0.961718096615083, 0.9629832487173089, 0.9629832487173089, 0.9629832487173089, 0.9678174515423967, 0.9678174515423967, 0.9678174515423967, 0.4894358454535358, 0.4894358454535358, 0.4894358454535358, 0.4469752768213604, 0.4469752768213604, 0.4469752768213604, 0.5010739467371186, 0.5010739467371186, 0.5010739467371186, 0.7326109384374806, 0.7326109384374806, 0.7326109384374806, 0.6517359891261412, 0.6517359891261412, 0.6517359891261412, 0.6882859063238442, 0.6882859063238442, 0.6882859063238442, 0.40874528495156714, 0.40874528495156714, 0.40874528495156714, 0.3724426055260236, 0.3724426055260236, 0.3724426055260236, 0.2164706129900017, 0.2164706129900017, 0.2164706129900017, 0.40930580679929274, 0.40930580679929274, 0.40930580679929274, 0.3107646711225861, 0.3107646711225861, 0.3107646711225861, 0.30835437988163117, 0.30835437988163117, 0.30835437988163117, 0.09557743238606942, 0.09557743238606942, 0.09557743238606942, 0.16707720609152643, 0.16707720609152643, 0.16707720609152643, 0.0494209674339543, 0.0494209674339543, 0.0494209674339543, 0.21198651832502002, 0.21198651832502002, 0.21198651832502002, 0.1565587063580235, 0.1565587063580235, 0.1565587063580235, 0.15559999635405386, 0.15559999635405386, 0.15559999635405386, 0.03387133884183491, 0.03387133884183491, 0.03387133884183491, 0.09510878155671432, 0.09510878155671432, 0.09510878155671432, 0.06943826790870766, 0.06943826790870766, 0.06943826790870766, 0.2647331281983265, 0.2647331281983265, 0.2647331281983265, 0.2017969068662253, 0.2017969068662253, 0.2017969068662253, 0.24125911889853047, 0.24125911889853047, 0.24125911889853047, 0.5854195152916328, 0.5854195152916328, 0.5854195152916328, 0.5906665614748836, 0.5906665614748836, 0.5906665614748836, 0.5652787795742781, 0.5652787795742781, 0.5652787795742781, 0.12238267874490105, 0.12238267874490105, 0.12238267874490105, 0.11943380211366694, 0.11943380211366694, 0.11943380211366694, 0.13601223195494438, 0.13601223195494438, 0.13601223195494438, 0.18091678158510827, 0.18091678158510827, 0.18091678158510827, 0.1984126356510697, 0.1984126356510697, 0.1984126356510697, 0.26197450558145907, 0.26197450558145907, 0.26197450558145907, 0.2755756079975952, 0.2755756079975952, 0.2755756079975952, 0.3311651442372341, 0.3311651442372341, 0.3311651442372341, 0.4419831427578911, 0.4419831427578911, 0.4419831427578911, 0.2646452750001713, 0.2646452750001713, 0.2646452750001713, 0.2156727409199436, 0.2156727409199436, 0.2156727409199436, 0.23628803958133926, 0.23628803958133926, 0.23628803958133926, 0.22608560013474666, 0.22608560013474666, 0.22608560013474666, 0.23920146732892722, 0.23920146732892722, 0.23920146732892722, 0.22055453361717825, 0.22055453361717825, 0.22055453361717825, 0.18236613943482982, 0.18236613943482982, 0.18236613943482982, 0.1825130578699622, 0.1825130578699622, 0.1825130578699622, 0.20702947737745825, 0.20702947737745825, 0.20702947737745825, 0.8452635008480347, 0.8452635008480347, 0.8452635008480347, 0.20639180746221675, 0.20639180746221675, 0.20639180746221675, 0.16595240253339394, 0.16595240253339394, 0.16595240253339394, 0.1675878103611219, 0.1675878103611219, 0.1675878103611219, 0.20773896432766958, 0.20773896432766958, 0.20773896432766958, 0.1544136557211656, 0.1544136557211656, 0.1544136557211656, 0.19905786318074092, 0.19905786318074092, 0.19905786318074092, 0.18517043458537952, 0.18517043458537952, 0.18517043458537952, 0.19490239979636392, 0.19490239979636392, 0.19490239979636392, 0.08970474225446012, 0.08970474225446012, 0.08970474225446012, 0.0827147802464544, 0.0827147802464544, 0.0827147802464544, 0.09172582104741267, 0.09172582104741267, 0.09172582104741267]}, "mutation_prompt": null}
{"id": "37aa0473-9d7d-466d-990c-ddbc1b0d895e", "solution": "import numpy as np\n\nclass QuantumSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.7\n        self.cognitive = 1.4\n        self.social = 1.9\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumSwarmDifferentialEvolution", "description": "Quantum-Swarm Differential Evolution with adaptive multi-strategy reinforcement for robust global search.", "configspace": "", "generation": 59, "fitness": 0.2860001538033778, "feedback": "The algorithm QuantumSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.65625734411261, 0.65625734411261, 0.65625734411261, 0.6784311400475507, 0.6784311400475507, 0.6784311400475507, 0.672148397059257, 0.672148397059257, 0.672148397059257, 0.24157646222324913, 0.24157646222324913, 0.24157646222324913, 0.19378833272065554, 0.19378833272065554, 0.19378833272065554, 0.16047704311065158, 0.16047704311065158, 0.16047704311065158, 0.10036644188093802, 0.10036644188093802, 0.10036644188093802, 0.11685220132027119, 0.11685220132027119, 0.11685220132027119, 0.11220898489991782, 0.11220898489991782, 0.11220898489991782, 0.13174337905043398, 0.13174337905043398, 0.13174337905043398, 0.10326083730179691, 0.10326083730179691, 0.10326083730179691, 0.12126135852992759, 0.12126135852992759, 0.12126135852992759, 0.9629019804592225, 0.9629019804592225, 0.9629019804592225, 0.9820588745567655, 0.9820588745567655, 0.9820588745567655, 0.9371616455307807, 0.9371616455307807, 0.9371616455307807, 0.47989885361718987, 0.47989885361718987, 0.47989885361718987, 0.4589052598529221, 0.4589052598529221, 0.4589052598529221, 0.45854721104593643, 0.45854721104593643, 0.45854721104593643, 0.5809268994445931, 0.5809268994445931, 0.5809268994445931, 0.2556315374492799, 0.2556315374492799, 0.2556315374492799, 0.19256729471851808, 0.19256729471851808, 0.19256729471851808, 0.3058891228837197, 0.3058891228837197, 0.3058891228837197, 0.18932442016869577, 0.18932442016869577, 0.18932442016869577, 0.21418094588499803, 0.21418094588499803, 0.21418094588499803, 0.2218542527361277, 0.2218542527361277, 0.2218542527361277, 0.22416617470052402, 0.22416617470052402, 0.22416617470052402, 0.22444654248995244, 0.22444654248995244, 0.22444654248995244, 0.09518309066036035, 0.09518309066036035, 0.09518309066036035, 0.07437205600797969, 0.07437205600797969, 0.07437205600797969, 0.11540352906595341, 0.11540352906595341, 0.11540352906595341, 0.22373434124345937, 0.22373434124345937, 0.22373434124345937, 0.09957674069192157, 0.09957674069192157, 0.09957674069192157, 0.25943879650519774, 0.25943879650519774, 0.25943879650519774, 0.03212943588565509, 0.03212943588565509, 0.03212943588565509, 0.17070885823389248, 0.17070885823389248, 0.17070885823389248, 0.08726206305151629, 0.08726206305151629, 0.08726206305151629, 0.1346280384969798, 0.1346280384969798, 0.1346280384969798, 0.11868616837204171, 0.11868616837204171, 0.11868616837204171, 0.2110282578036251, 0.2110282578036251, 0.2110282578036251, 0.5068355681129588, 0.5068355681129588, 0.5068355681129588, 0.564124278430937, 0.564124278430937, 0.564124278430937, 0.5352611658468527, 0.5352611658468527, 0.5352611658468527, 0.1311290850340553, 0.1311290850340553, 0.1311290850340553, 0.1759176909201704, 0.1759176909201704, 0.1759176909201704, 0.12129567691082177, 0.12129567691082177, 0.12129567691082177, 0.3523462191572243, 0.3523462191572243, 0.3523462191572243, 0.2333014374433161, 0.2333014374433161, 0.2333014374433161, 0.24147128197441237, 0.24147128197441237, 0.24147128197441237, 0.3445972495380184, 0.3445972495380184, 0.3445972495380184, 0.3632885751524618, 0.3632885751524618, 0.3632885751524618, 0.30262731733779435, 0.30262731733779435, 0.30262731733779435, 0.21849874168578076, 0.21849874168578076, 0.21849874168578076, 0.25311837577865304, 0.25311837577865304, 0.25311837577865304, 0.2555516191003049, 0.2555516191003049, 0.2555516191003049, 0.23512942295649686, 0.23512942295649686, 0.23512942295649686, 0.21250090728115167, 0.21250090728115167, 0.21250090728115167, 0.23604280083627982, 0.23604280083627982, 0.23604280083627982, 0.21709633090416092, 0.21709633090416092, 0.21709633090416092, 0.186193190824267, 0.186193190824267, 0.186193190824267, 0.21578524795909904, 0.21578524795909904, 0.21578524795909904, 0.8436338267686972, 0.8436338267686972, 0.8436338267686972, 0.15879705625809037, 0.15879705625809037, 0.15879705625809037, 0.16935960839298636, 0.16935960839298636, 0.16935960839298636, 0.15444741056661548, 0.15444741056661548, 0.15444741056661548, 0.21110077180085896, 0.21110077180085896, 0.21110077180085896, 0.6567186740789337, 0.6567186740789337, 0.6567186740789337, 0.1956015828794696, 0.1956015828794696, 0.1956015828794696, 0.18250494920016136, 0.18250494920016136, 0.18250494920016136, 0.19830638980780502, 0.19830638980780502, 0.19830638980780502, 0.0910647219803139, 0.0910647219803139, 0.0910647219803139, 0.13770148543012561, 0.13770148543012561, 0.13770148543012561, 0.09167809967885765, 0.09167809967885765, 0.09167809967885765]}, "mutation_prompt": null}
{"id": "c47be879-40c2-4685-b0fc-6b4e05d4f17a", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Adjusted inertia for better exploration\n        self.cognitive = 1.5  # Slightly increased cognitive component\n        self.social = 1.8  # Slightly decreased social component\n        self.quantum_prob = 0.3  # Adjusted probability for quantum update\n        self.elite_quantum_prob = 0.2  # Adjusted probability for elite quantum update\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9  # Increased mutation factor for exploration\n        self.de_crossover_rate = 0.8  # Slightly decreased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update with stochastic perturbation\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                ) + np.random.normal(0, 0.1, self.dim)  # Added stochastic perturbation\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Quantum-Inspired Differential Swarm Optimization with enhanced adaptive learning and stochastic velocity perturbation.", "configspace": "", "generation": 60, "fitness": 0.2123700845076122, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.4429558550459607, 0.4429558550459607, 0.4429558550459607, 0.4041406205012087, 0.4041406205012087, 0.4041406205012087, 0.38724058797127814, 0.38724058797127814, 0.38724058797127814, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030883790886245155, 0.030883790886245155, 0.030883790886245155, 0.09028758503934076, 0.09028758503934076, 0.09028758503934076, 0.10278951932422586, 0.10278951932422586, 0.10278951932422586, 0.09174674562704932, 0.09174674562704932, 0.09174674562704932, 0.10988161131341168, 0.10988161131341168, 0.10988161131341168, 0.09688980491471888, 0.09688980491471888, 0.09688980491471888, 0.09376663335679747, 0.09376663335679747, 0.09376663335679747, 0.9485816754271785, 0.9485816754271785, 0.9485816754271785, 0.9643769099539791, 0.9643769099539791, 0.9643769099539791, 0.9556803474765916, 0.9556803474765916, 0.9556803474765916, 0.26192382489107013, 0.26192382489107013, 0.26192382489107013, 0.2692427018199869, 0.2692427018199869, 0.2692427018199869, 0.26999714138306186, 0.26999714138306186, 0.26999714138306186, 0.32634960852273276, 0.32634960852273276, 0.32634960852273276, 0.18769823664749208, 0.18769823664749208, 0.18769823664749208, 0.3400421014232008, 0.3400421014232008, 0.3400421014232008, 0.13066108090325357, 0.13066108090325357, 0.13066108090325357, 0.1665832780314993, 0.1665832780314993, 0.1665832780314993, 0.16467280417234575, 0.16467280417234575, 0.16467280417234575, 0.16803010019598696, 0.16803010019598696, 0.16803010019598696, 0.13778464957390446, 0.13778464957390446, 0.13778464957390446, 0.167260201993233, 0.167260201993233, 0.167260201993233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026308513354679985, 0.026308513354679985, 0.026308513354679985, 0.012569500937839595, 0.012569500937839595, 0.012569500937839595, 0.16088548256394697, 0.16088548256394697, 0.16088548256394697, 0.1227033025938854, 0.1227033025938854, 0.1227033025938854, 0.06954194892291199, 0.06954194892291199, 0.06954194892291199, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0935411619739811, 0.0935411619739811, 0.0935411619739811, 0.08539369771858696, 0.08539369771858696, 0.08539369771858696, 0.04616501415024554, 0.04616501415024554, 0.04616501415024554, 0.3743552859009286, 0.3743552859009286, 0.3743552859009286, 0.37286608110976793, 0.37286608110976793, 0.37286608110976793, 0.35732163096852887, 0.35732163096852887, 0.35732163096852887, 0.12424020173140526, 0.12424020173140526, 0.12424020173140526, 0.09591878589704395, 0.09591878589704395, 0.09591878589704395, 0.09904257223372914, 0.09904257223372914, 0.09904257223372914, 0.20925813326626552, 0.20925813326626552, 0.20925813326626552, 0.22994855459828512, 0.22994855459828512, 0.22994855459828512, 0.16349536958430944, 0.16349536958430944, 0.16349536958430944, 0.27637344606205994, 0.27637344606205994, 0.27637344606205994, 0.2716829394394703, 0.2716829394394703, 0.2716829394394703, 0.28918126870606087, 0.28918126870606087, 0.28918126870606087, 0.22342172415827533, 0.22342172415827533, 0.22342172415827533, 0.20346781454689622, 0.20346781454689622, 0.20346781454689622, 0.20849976526866898, 0.20849976526866898, 0.20849976526866898, 0.20027327953122231, 0.20027327953122231, 0.20027327953122231, 0.19636599705637137, 0.19636599705637137, 0.19636599705637137, 0.20785938584668895, 0.20785938584668895, 0.20785938584668895, 0.20087538706698238, 0.20087538706698238, 0.20087538706698238, 0.20066304619699438, 0.20066304619699438, 0.20066304619699438, 0.20384847680843154, 0.20384847680843154, 0.20384847680843154, 0.5836065430354411, 0.5836065430354411, 0.5836065430354411, 0.15668019815567003, 0.15668019815567003, 0.15668019815567003, 0.5309025385898205, 0.5309025385898205, 0.5309025385898205, 0.16829630523124528, 0.16829630523124528, 0.16829630523124528, 0.20814055733714498, 0.20814055733714498, 0.20814055733714498, 0.16522582585509626, 0.16522582585509626, 0.16522582585509626, 0.18818409876052133, 0.18818409876052133, 0.18818409876052133, 0.1728737192693126, 0.1728737192693126, 0.1728737192693126, 0.18527537241028436, 0.18527537241028436, 0.18527537241028436, 0.09938282623460981, 0.09938282623460981, 0.09938282623460981, 0.0967309018664424, 0.0967309018664424, 0.0967309018664424, 0.09921201321227202, 0.09921201321227202, 0.09921201321227202]}, "mutation_prompt": null}
{"id": "f1e4f7a8-2671-4568-9663-009708844c2a", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Adjusted inertia for better exploration\n        self.cognitive = 1.5  # Slight increase for cognitive component\n        self.social = 1.8  # Slight reduction for balanced exploration\n        self.quantum_prob = 0.3  # Adjusted probability for quantum move\n        self.elite_quantum_prob = 0.2  # Adjusted probability for elite quantum\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased max velocity\n        self.de_mutation_factor = 0.9  # Adjusted DE mutation factor\n        self.de_crossover_rate = 0.85  # Adjusted DE crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            adaptive_inertia = (0.4 + 0.3 * (self.budget - eval_count) / self.budget) # Dynamic inertia\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update with adaptive inertia\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    adaptive_inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation with adaptive crossover\n                deferred_crossover = np.random.rand(self.dim) < (self.de_crossover_rate - 0.15 * eval_count / self.budget)\n                if np.any(deferred_crossover):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(deferred_crossover, donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumDifferentialOptimization", "description": "Adaptive Quantum Differential Optimization incorporates adaptive inertia and crossover strategies to enhance convergence in high-dimensional spaces.", "configspace": "", "generation": 61, "fitness": 0.32538971971149866, "feedback": "The algorithm AdaptiveQuantumDifferentialOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7210498386608675, 0.7210498386608675, 0.7210498386608675, 0.7639093639909311, 0.7639093639909311, 0.7639093639909311, 0.7336106857845093, 0.7336106857845093, 0.7336106857845093, 0.08862038862394095, 0.08862038862394095, 0.08862038862394095, 0.407360182498574, 0.407360182498574, 0.407360182498574, 0.3863192020181172, 0.3863192020181172, 0.3863192020181172, 0.1705054715803297, 0.1705054715803297, 0.1705054715803297, 0.10274959879071865, 0.10274959879071865, 0.10274959879071865, 0.12120985412242502, 0.12120985412242502, 0.12120985412242502, 0.1025804764899444, 0.1025804764899444, 0.1025804764899444, 0.10716927113811126, 0.10716927113811126, 0.10716927113811126, 0.11194767411671525, 0.11194767411671525, 0.11194767411671525, 0.9414668898311512, 0.9414668898311512, 0.9414668898311512, 0.9591341016210881, 0.9591341016210881, 0.9591341016210881, 0.9696893005229376, 0.9696893005229376, 0.9696893005229376, 0.4782144234644047, 0.4782144234644047, 0.4782144234644047, 0.45223023981620125, 0.45223023981620125, 0.45223023981620125, 0.5010555015704459, 0.5010555015704459, 0.5010555015704459, 0.20996225715783268, 0.20996225715783268, 0.20996225715783268, 0.7471847317234207, 0.7471847317234207, 0.7471847317234207, 0.2293717572006183, 0.2293717572006183, 0.2293717572006183, 0.12924175865588805, 0.12924175865588805, 0.12924175865588805, 0.12399593537747444, 0.12399593537747444, 0.12399593537747444, 0.2669413338074441, 0.2669413338074441, 0.2669413338074441, 0.33217410731383223, 0.33217410731383223, 0.33217410731383223, 0.319324113010404, 0.319324113010404, 0.319324113010404, 0.2884978758148131, 0.2884978758148131, 0.2884978758148131, 0.055857309260944565, 0.055857309260944565, 0.055857309260944565, 0.08903402742544908, 0.08903402742544908, 0.08903402742544908, 0.09923067979499067, 0.09923067979499067, 0.09923067979499067, 0.22755269990228222, 0.22755269990228222, 0.22755269990228222, 0.33271485230153064, 0.33271485230153064, 0.33271485230153064, 0.1875475472320035, 0.1875475472320035, 0.1875475472320035, 0.07462708412915942, 0.07462708412915942, 0.07462708412915942, 0.06324402793127504, 0.06324402793127504, 0.06324402793127504, 0.22953603327592176, 0.22953603327592176, 0.22953603327592176, 0.16618627176939027, 0.16618627176939027, 0.16618627176939027, 0.18910276630261091, 0.18910276630261091, 0.18910276630261091, 0.251252355028294, 0.251252355028294, 0.251252355028294, 0.5653290736060292, 0.5653290736060292, 0.5653290736060292, 0.5671603946237118, 0.5671603946237118, 0.5671603946237118, 0.5960762066858911, 0.5960762066858911, 0.5960762066858911, 0.10521270073545053, 0.10521270073545053, 0.10521270073545053, 0.10782154718657244, 0.10782154718657244, 0.10782154718657244, 0.13441783595502543, 0.13441783595502543, 0.13441783595502543, 0.25723596476721866, 0.25723596476721866, 0.25723596476721866, 0.1634051956132323, 0.1634051956132323, 0.1634051956132323, 0.3327327163062399, 0.3327327163062399, 0.3327327163062399, 0.3358355416059382, 0.3358355416059382, 0.3358355416059382, 0.2645630304900931, 0.2645630304900931, 0.2645630304900931, 0.3606349871282608, 0.3606349871282608, 0.3606349871282608, 0.30522168328928523, 0.30522168328928523, 0.30522168328928523, 0.31104869209119934, 0.31104869209119934, 0.31104869209119934, 0.3289019995996918, 0.3289019995996918, 0.3289019995996918, 0.2585732389242371, 0.2585732389242371, 0.2585732389242371, 0.24286223387428119, 0.24286223387428119, 0.24286223387428119, 0.20848134080575387, 0.20848134080575387, 0.20848134080575387, 0.2500560058587449, 0.2500560058587449, 0.2500560058587449, 0.46027717482348307, 0.46027717482348307, 0.46027717482348307, 0.2004533198955777, 0.2004533198955777, 0.2004533198955777, 0.8276384856611223, 0.8276384856611223, 0.8276384856611223, 0.14741366198307093, 0.14741366198307093, 0.14741366198307093, 0.17304307140234376, 0.17304307140234376, 0.17304307140234376, 0.7778940719556935, 0.7778940719556935, 0.7778940719556935, 0.7587828226075711, 0.7587828226075711, 0.7587828226075711, 0.7575800384345445, 0.7575800384345445, 0.7575800384345445, 0.20668612073520953, 0.20668612073520953, 0.20668612073520953, 0.20303633560350853, 0.20303633560350853, 0.20303633560350853, 0.21733204166311404, 0.21733204166311404, 0.21733204166311404, 0.09413667085742128, 0.09413667085742128, 0.09413667085742128, 0.08624980165196228, 0.08624980165196228, 0.08624980165196228, 0.09056382374943173, 0.09056382374943173, 0.09056382374943173]}, "mutation_prompt": null}
{"id": "3e74f922-e093-41ae-ba15-6f8b06d5dd9c", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.4\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.2\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(size=self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(size=self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with adaptive strategy\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumInspiredDSO", "description": "Hybrid Quantum-Inspired Differential Swarm Optimization with adaptive exploration-exploitation balance and mutation refinement.", "configspace": "", "generation": 62, "fitness": 0.3279934030977111, "feedback": "The algorithm HybridQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8567097853722353, 0.8567097853722353, 0.8567097853722353, 0.8608708809739632, 0.8608708809739632, 0.8608708809739632, 0.8392793983135545, 0.8392793983135545, 0.8392793983135545, 0.626082862620843, 0.626082862620843, 0.626082862620843, 0.61802252099508, 0.61802252099508, 0.61802252099508, 0.6354072125108255, 0.6354072125108255, 0.6354072125108255, 0.12346464694328696, 0.12346464694328696, 0.12346464694328696, 0.11258401317934363, 0.11258401317934363, 0.11258401317934363, 0.18166214338559505, 0.18166214338559505, 0.18166214338559505, 0.09293455808872308, 0.09293455808872308, 0.09293455808872308, 0.10358974904981588, 0.10358974904981588, 0.10358974904981588, 0.08740561876790598, 0.08740561876790598, 0.08740561876790598, 0.9438642188051093, 0.9438642188051093, 0.9438642188051093, 0.9490367089673335, 0.9490367089673335, 0.9490367089673335, 0.9327230352257467, 0.9327230352257467, 0.9327230352257467, 0.6798257284937383, 0.6798257284937383, 0.6798257284937383, 0.6045911802536383, 0.6045911802536383, 0.6045911802536383, 0.6528703871797649, 0.6528703871797649, 0.6528703871797649, 0.8384185737357426, 0.8384185737357426, 0.8384185737357426, 0.16731181395163697, 0.16731181395163697, 0.16731181395163697, 0.902978318153893, 0.902978318153893, 0.902978318153893, 0.13342322638639237, 0.13342322638639237, 0.13342322638639237, 0.2910227929488831, 0.2910227929488831, 0.2910227929488831, 0.273670460092279, 0.273670460092279, 0.273670460092279, 0.3839827013873254, 0.3839827013873254, 0.3839827013873254, 0.13160133181354472, 0.13160133181354472, 0.13160133181354472, 0.2237155017466519, 0.2237155017466519, 0.2237155017466519, 0.13917100208413635, 0.13917100208413635, 0.13917100208413635, 0.0808129846682728, 0.0808129846682728, 0.0808129846682728, 0.08087635984479835, 0.08087635984479835, 0.08087635984479835, 0.168019702225627, 0.168019702225627, 0.168019702225627, 0.09172677573969035, 0.09172677573969035, 0.09172677573969035, 0.22343946784570234, 0.22343946784570234, 0.22343946784570234, 0.08420782184827458, 0.08420782184827458, 0.08420782184827458, 0.10714722125916742, 0.10714722125916742, 0.10714722125916742, 0.07041289349403146, 0.07041289349403146, 0.07041289349403146, 0.22721975767623426, 0.22721975767623426, 0.22721975767623426, 0.23635355865320595, 0.23635355865320595, 0.23635355865320595, 0.19144430033957083, 0.19144430033957083, 0.19144430033957083, 0.6170468191349676, 0.6170468191349676, 0.6170468191349676, 0.7698185592851693, 0.7698185592851693, 0.7698185592851693, 0.6395538603962546, 0.6395538603962546, 0.6395538603962546, 0.08555270703313378, 0.08555270703313378, 0.08555270703313378, 0.12502855295469129, 0.12502855295469129, 0.12502855295469129, 0.14803722606920944, 0.14803722606920944, 0.14803722606920944, 0.17226531915054544, 0.17226531915054544, 0.17226531915054544, 0.2186244973458713, 0.2186244973458713, 0.2186244973458713, 0.1821441964226781, 0.1821441964226781, 0.1821441964226781, 0.32146755175836683, 0.32146755175836683, 0.32146755175836683, 0.28358521476374443, 0.28358521476374443, 0.28358521476374443, 0.5038595827981294, 0.5038595827981294, 0.5038595827981294, 0.20499482730041785, 0.20499482730041785, 0.20499482730041785, 0.19643092792975103, 0.19643092792975103, 0.19643092792975103, 0.3153683419486195, 0.3153683419486195, 0.3153683419486195, 0.19973548286440468, 0.19973548286440468, 0.19973548286440468, 0.261545709731126, 0.261545709731126, 0.261545709731126, 0.2370563294919642, 0.2370563294919642, 0.2370563294919642, 0.20240417363446095, 0.20240417363446095, 0.20240417363446095, 0.18049237494432202, 0.18049237494432202, 0.18049237494432202, 0.19365274974259783, 0.19365274974259783, 0.19365274974259783, 0.9107671089798464, 0.9107671089798464, 0.9107671089798464, 0.1586426350822896, 0.1586426350822896, 0.1586426350822896, 0.16936047708627544, 0.16936047708627544, 0.16936047708627544, 0.15506043656132062, 0.15506043656132062, 0.15506043656132062, 0.21188135146462894, 0.21188135146462894, 0.21188135146462894, 0.09447177705166376, 0.09447177705166376, 0.09447177705166376, 0.19750512425070232, 0.19750512425070232, 0.19750512425070232, 0.19394019570976162, 0.19394019570976162, 0.19394019570976162, 0.20811370813081442, 0.20811370813081442, 0.20811370813081442, 0.10578486415522326, 0.10578486415522326, 0.10578486415522326, 0.08584351575587812, 0.08584351575587812, 0.08584351575587812, 0.11760760908480294, 0.11760760908480294, 0.11760760908480294]}, "mutation_prompt": null}
{"id": "645f6889-9c0e-4013-b3d1-de41e6025e43", "solution": "import numpy as np\n\nclass StochasticAdaptiveQuantumSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Increased inertia for exploration\n        self.cognitive = 1.5  # Adjusted cognitive component\n        self.social = 1.8  # Adjusted social component\n        self.quantum_prob = 0.2  # Reduced probability to focus more on elite updates\n        self.elite_quantum_prob = 0.2  # Increased elite quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased velocity range\n        self.de_mutation_factor = 0.9  # Higher differential mutation factor for diversity\n        self.de_crossover_rate = 0.85  # Slightly less crossover activity\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update with adaptive variance\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.5, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update with adaptive variance\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 0.3, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update with dynamic inertia\n                dynamic_inertia = 0.5 + 0.5 * (self.budget - eval_count) / self.budget\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    dynamic_inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with adaptive factor\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "StochasticAdaptiveQuantumSwarm", "description": "Stochastic Adaptive Quantum Swarm Optimization incorporating dynamic parameter tuning and elite-guided exploration.", "configspace": "", "generation": 63, "fitness": 0.2456932682962631, "feedback": "The algorithm StochasticAdaptiveQuantumSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.5280257139422, 0.5280257139422, 0.5280257139422, 0.5541963994758257, 0.5541963994758257, 0.5541963994758257, 0.5090830287517877, 0.5090830287517877, 0.5090830287517877, 0.06612772957954316, 0.06612772957954316, 0.06612772957954316, 0.0891913647089978, 0.0891913647089978, 0.0891913647089978, 0.0590912845127497, 0.0590912845127497, 0.0590912845127497, 0.1013477849432265, 0.1013477849432265, 0.1013477849432265, 0.08694458761171775, 0.08694458761171775, 0.08694458761171775, 0.1159130648469947, 0.1159130648469947, 0.1159130648469947, 0.09104502099475653, 0.09104502099475653, 0.09104502099475653, 0.11139468263956898, 0.11139468263956898, 0.11139468263956898, 0.11041878825068685, 0.11041878825068685, 0.11041878825068685, 0.968509007747178, 0.968509007747178, 0.968509007747178, 0.9715346019684187, 0.9715346019684187, 0.9715346019684187, 0.9741646452666037, 0.9741646452666037, 0.9741646452666037, 0.3232190117074214, 0.3232190117074214, 0.3232190117074214, 0.2676629655575866, 0.2676629655575866, 0.2676629655575866, 0.3085035730128354, 0.3085035730128354, 0.3085035730128354, 0.49030568047805534, 0.49030568047805534, 0.49030568047805534, 0.4132769823831365, 0.4132769823831365, 0.4132769823831365, 0.4731417714685584, 0.4731417714685584, 0.4731417714685584, 0.15638311277707195, 0.15638311277707195, 0.15638311277707195, 0.18905410508644616, 0.18905410508644616, 0.18905410508644616, 0.15893910954832902, 0.15893910954832902, 0.15893910954832902, 0.18830857299941584, 0.18830857299941584, 0.18830857299941584, 0.18162395340715054, 0.18162395340715054, 0.18162395340715054, 0.17794946736866002, 0.17794946736866002, 0.17794946736866002, 0.01603306260365056, 0.01603306260365056, 0.01603306260365056, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015816353161323793, 0.015816353161323793, 0.015816353161323793, 0.06399292213943986, 0.06399292213943986, 0.06399292213943986, 0.13676364837211963, 0.13676364837211963, 0.13676364837211963, 0.1025427536140664, 0.1025427536140664, 0.1025427536140664, 0.01945443143258163, 0.01945443143258163, 0.01945443143258163, 0.03553020490658798, 0.03553020490658798, 0.03553020490658798, 0.07401580071421687, 0.07401580071421687, 0.07401580071421687, 0.12044034687047511, 0.12044034687047511, 0.12044034687047511, 0.09894771552811832, 0.09894771552811832, 0.09894771552811832, 0.04820745597709486, 0.04820745597709486, 0.04820745597709486, 0.4717686018728183, 0.4717686018728183, 0.4717686018728183, 0.45994298118473276, 0.45994298118473276, 0.45994298118473276, 0.4284996507919073, 0.4284996507919073, 0.4284996507919073, 0.1285826226788277, 0.1285826226788277, 0.1285826226788277, 0.12272315892700658, 0.12272315892700658, 0.12272315892700658, 0.10659655631399567, 0.10659655631399567, 0.10659655631399567, 0.16563407223716897, 0.16563407223716897, 0.16563407223716897, 0.2414432372825278, 0.2414432372825278, 0.2414432372825278, 0.16972799992109866, 0.16972799992109866, 0.16972799992109866, 0.279752147375518, 0.279752147375518, 0.279752147375518, 0.3002648930844555, 0.3002648930844555, 0.3002648930844555, 0.2866237575251632, 0.2866237575251632, 0.2866237575251632, 0.25468497220673536, 0.25468497220673536, 0.25468497220673536, 0.19474405197242572, 0.19474405197242572, 0.19474405197242572, 0.12914175634960467, 0.12914175634960467, 0.12914175634960467, 0.21006497326079954, 0.21006497326079954, 0.21006497326079954, 0.20403731014960125, 0.20403731014960125, 0.20403731014960125, 0.19097666501753052, 0.19097666501753052, 0.19097666501753052, 0.18975217871494265, 0.18975217871494265, 0.18975217871494265, 0.18768408228293842, 0.18768408228293842, 0.18768408228293842, 0.2069204909095762, 0.2069204909095762, 0.2069204909095762, 0.6995823875680585, 0.6995823875680585, 0.6995823875680585, 0.15697328147529044, 0.15697328147529044, 0.15697328147529044, 0.7214969302817096, 0.7214969302817096, 0.7214969302817096, 0.5822753836338899, 0.5822753836338899, 0.5822753836338899, 0.20914956488256675, 0.20914956488256675, 0.20914956488256675, 0.15421923360174827, 0.15421923360174827, 0.15421923360174827, 0.19201369921112355, 0.19201369921112355, 0.19201369921112355, 0.20912096615032505, 0.20912096615032505, 0.20912096615032505, 0.1781469279683, 0.1781469279683, 0.1781469279683, 0.08922357559369942, 0.08922357559369942, 0.08922357559369942, 0.08097951038593887, 0.08097951038593887, 0.08097951038593887, 0.0899669901643203, 0.0899669901643203, 0.0899669901643203]}, "mutation_prompt": null}
{"id": "02f05112-1feb-4283-8f0e-29fbaad269d8", "solution": "import numpy as np\n\nclass AdaptiveQuantumEnhancedDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 45  # Increased particles\n        self.inertia = 0.6  # Adjusted inertia weight\n        self.cognitive = 1.5  # Adjusted cognitive coefficient\n        self.social = 1.8  # Adjusted social coefficient\n        self.quantum_prob = 0.3  # Adjusted quantum probability\n        self.elite_quantum_prob = 0.2  # Adjusted elite quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced max velocity\n        self.de_mutation_factor = 0.75  # Adjusted DE mutation factor\n        self.de_crossover_rate = 0.85  # Adjusted DE crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumEnhancedDSO", "description": "Adaptive Quantum-Enhanced Differential Swarm Optimization with probabilistic elite strategy and dynamic crossover control.", "configspace": "", "generation": 64, "fitness": 0.32449053652484505, "feedback": "The algorithm AdaptiveQuantumEnhancedDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7936318991901126, 0.7936318991901126, 0.7936318991901126, 0.7634445839625653, 0.7634445839625653, 0.7634445839625653, 0.7801023132148007, 0.7801023132148007, 0.7801023132148007, 0.26296918886248244, 0.26296918886248244, 0.26296918886248244, 0.36444071704389003, 0.36444071704389003, 0.36444071704389003, 0.39362324978484486, 0.39362324978484486, 0.39362324978484486, 0.12147047901170205, 0.12147047901170205, 0.12147047901170205, 0.10521203246877431, 0.10521203246877431, 0.10521203246877431, 0.1471259739369205, 0.1471259739369205, 0.1471259739369205, 0.13149751003445542, 0.13149751003445542, 0.13149751003445542, 0.12333941078512001, 0.12333941078512001, 0.12333941078512001, 0.10456240120473681, 0.10456240120473681, 0.10456240120473681, 0.9254072732276167, 0.9254072732276167, 0.9254072732276167, 0.9382014213113022, 0.9382014213113022, 0.9382014213113022, 0.9453199971500365, 0.9453199971500365, 0.9453199971500365, 0.5693695565267127, 0.5693695565267127, 0.5693695565267127, 0.5608278602752037, 0.5608278602752037, 0.5608278602752037, 0.5225132824373434, 0.5225132824373434, 0.5225132824373434, 0.7202853326183376, 0.7202853326183376, 0.7202853326183376, 0.7724013480981059, 0.7724013480981059, 0.7724013480981059, 0.3801275379587823, 0.3801275379587823, 0.3801275379587823, 0.3091021866949345, 0.3091021866949345, 0.3091021866949345, 0.5225059863790582, 0.5225059863790582, 0.5225059863790582, 0.3308404036074769, 0.3308404036074769, 0.3308404036074769, 0.1319826469628197, 0.1319826469628197, 0.1319826469628197, 0.44267478637010915, 0.44267478637010915, 0.44267478637010915, 0.22958558564444198, 0.22958558564444198, 0.22958558564444198, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06703285808366655, 0.06703285808366655, 0.06703285808366655, 0.125830855049324, 0.125830855049324, 0.125830855049324, 0.18471238952583868, 0.18471238952583868, 0.18471238952583868, 0.2272728214924008, 0.2272728214924008, 0.2272728214924008, 0.03995311487482378, 0.03995311487482378, 0.03995311487482378, 0.1873688053457213, 0.1873688053457213, 0.1873688053457213, 0.24946775387103604, 0.24946775387103604, 0.24946775387103604, 0.24372294133441585, 0.24372294133441585, 0.24372294133441585, 0.2607512425337062, 0.2607512425337062, 0.2607512425337062, 0.24562932817363015, 0.24562932817363015, 0.24562932817363015, 0.6152154260022067, 0.6152154260022067, 0.6152154260022067, 0.6424852950700324, 0.6424852950700324, 0.6424852950700324, 0.6553808004333201, 0.6553808004333201, 0.6553808004333201, 0.14216662812795444, 0.14216662812795444, 0.14216662812795444, 0.14221061254739686, 0.14221061254739686, 0.14221061254739686, 0.14649681211025656, 0.14649681211025656, 0.14649681211025656, 0.4917756171114235, 0.4917756171114235, 0.4917756171114235, 0.3312292727174405, 0.3312292727174405, 0.3312292727174405, 0.3029153077112058, 0.3029153077112058, 0.3029153077112058, 0.3080717171193371, 0.3080717171193371, 0.3080717171193371, 0.37369809615039207, 0.37369809615039207, 0.37369809615039207, 0.26803147395439086, 0.26803147395439086, 0.26803147395439086, 0.22418924323263711, 0.22418924323263711, 0.22418924323263711, 0.21679595074806357, 0.21679595074806357, 0.21679595074806357, 0.2756842686858074, 0.2756842686858074, 0.2756842686858074, 0.22900536283260298, 0.22900536283260298, 0.22900536283260298, 0.21596687758876543, 0.21596687758876543, 0.21596687758876543, 0.2545271395449966, 0.2545271395449966, 0.2545271395449966, 0.20922277900200814, 0.20922277900200814, 0.20922277900200814, 0.21338869394593585, 0.21338869394593585, 0.21338869394593585, 0.1963506909502174, 0.1963506909502174, 0.1963506909502174, 0.8884737272705454, 0.8884737272705454, 0.8884737272705454, 0.15833418319343295, 0.15833418319343295, 0.15833418319343295, 0.16633595158697612, 0.16633595158697612, 0.16633595158697612, 0.1668001153814379, 0.1668001153814379, 0.1668001153814379, 0.2104802555945816, 0.2104802555945816, 0.2104802555945816, 0.15637143561406552, 0.15637143561406552, 0.15637143561406552, 0.19196449439891972, 0.19196449439891972, 0.19196449439891972, 0.22172293826258505, 0.22172293826258505, 0.22172293826258505, 0.22414046694343137, 0.22414046694343137, 0.22414046694343137, 0.08351206891412088, 0.08351206891412088, 0.08351206891412088, 0.1041044249015578, 0.1041044249015578, 0.1041044249015578, 0.11176342709354736, 0.11176342709354736, 0.11176342709354736]}, "mutation_prompt": null}
{"id": "4e3af104-28db-4cb8-9b52-c5a285b89ede", "solution": "import numpy as np\n\nclass AdvancedQuantumDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.2\n        self.elite_quantum_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.standard_normal(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.standard_normal(self.dim) * 0.5\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Enhanced Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdvancedQuantumDSO", "description": "Advanced Quantum Differential Swarm Optimization with adaptive hyperparameters and crossover enhancement for robust search.", "configspace": "", "generation": 65, "fitness": 0.29420753012227674, "feedback": "The algorithm AdvancedQuantumDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7397425352255791, 0.7397425352255791, 0.7397425352255791, 0.7083427942099085, 0.7083427942099085, 0.7083427942099085, 0.75119106779842, 0.75119106779842, 0.75119106779842, 0.15629459630319031, 0.15629459630319031, 0.15629459630319031, 0.26452322591005417, 0.26452322591005417, 0.26452322591005417, 0.28817907709207236, 0.28817907709207236, 0.28817907709207236, 0.12020305690082589, 0.12020305690082589, 0.12020305690082589, 0.13145916761425847, 0.13145916761425847, 0.13145916761425847, 0.13050787590228208, 0.13050787590228208, 0.13050787590228208, 0.09906719378542073, 0.09906719378542073, 0.09906719378542073, 0.11433480053006073, 0.11433480053006073, 0.11433480053006073, 0.12552193484973317, 0.12552193484973317, 0.12552193484973317, 0.9489244858117774, 0.9489244858117774, 0.9489244858117774, 0.9713399710630678, 0.9713399710630678, 0.9713399710630678, 0.9633573437127408, 0.9633573437127408, 0.9633573437127408, 0.44066686653149256, 0.44066686653149256, 0.44066686653149256, 0.5081623124403418, 0.5081623124403418, 0.5081623124403418, 0.5177111116982885, 0.5177111116982885, 0.5177111116982885, 0.2241076522926585, 0.2241076522926585, 0.2241076522926585, 0.8132629428254049, 0.8132629428254049, 0.8132629428254049, 0.7481263343219947, 0.7481263343219947, 0.7481263343219947, 0.26045332236263063, 0.26045332236263063, 0.26045332236263063, 0.19687972536666243, 0.19687972536666243, 0.19687972536666243, 0.1312330448471124, 0.1312330448471124, 0.1312330448471124, 0.2455733633439966, 0.2455733633439966, 0.2455733633439966, 0.3070994819732167, 0.3070994819732167, 0.3070994819732167, 0.42360468848489763, 0.42360468848489763, 0.42360468848489763, 0.04933990353115081, 0.04933990353115081, 0.04933990353115081, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07343938512590686, 0.07343938512590686, 0.07343938512590686, 0.10198954214676048, 0.10198954214676048, 0.10198954214676048, 0.09238936541973797, 0.09238936541973797, 0.09238936541973797, 0.18852727211573483, 0.18852727211573483, 0.18852727211573483, 0.08957567934636901, 0.08957567934636901, 0.08957567934636901, 0.10715394045339854, 0.10715394045339854, 0.10715394045339854, 0.08002168754100603, 0.08002168754100603, 0.08002168754100603, 0.146271976985048, 0.146271976985048, 0.146271976985048, 0.03693228905767976, 0.03693228905767976, 0.03693228905767976, 0.1251478079176903, 0.1251478079176903, 0.1251478079176903, 0.49911682112412836, 0.49911682112412836, 0.49911682112412836, 0.5549316546920959, 0.5549316546920959, 0.5549316546920959, 0.5549359605406163, 0.5549359605406163, 0.5549359605406163, 0.1391508765744085, 0.1391508765744085, 0.1391508765744085, 0.12756325465036222, 0.12756325465036222, 0.12756325465036222, 0.09232864173876298, 0.09232864173876298, 0.09232864173876298, 0.17453279495052942, 0.17453279495052942, 0.17453279495052942, 0.24590185124921382, 0.24590185124921382, 0.24590185124921382, 0.1968784838154105, 0.1968784838154105, 0.1968784838154105, 0.3752219932457972, 0.3752219932457972, 0.3752219932457972, 0.3147568066840961, 0.3147568066840961, 0.3147568066840961, 0.321257220065192, 0.321257220065192, 0.321257220065192, 0.2013654258603046, 0.2013654258603046, 0.2013654258603046, 0.27800011549077697, 0.27800011549077697, 0.27800011549077697, 0.19490791138930974, 0.19490791138930974, 0.19490791138930974, 0.2244348070965576, 0.2244348070965576, 0.2244348070965576, 0.20978890541476325, 0.20978890541476325, 0.20978890541476325, 0.20522491142861865, 0.20522491142861865, 0.20522491142861865, 0.24378724749173775, 0.24378724749173775, 0.24378724749173775, 0.1832156655212086, 0.1832156655212086, 0.1832156655212086, 0.20237663493506763, 0.20237663493506763, 0.20237663493506763, 0.868213641953234, 0.868213641953234, 0.868213641953234, 0.15710098060385513, 0.15710098060385513, 0.15710098060385513, 0.17678023572843482, 0.17678023572843482, 0.17678023572843482, 0.20549059257255387, 0.20549059257255387, 0.20549059257255387, 0.20878032912604838, 0.20878032912604838, 0.20878032912604838, 0.7667452858975154, 0.7667452858975154, 0.7667452858975154, 0.1815389580093827, 0.1815389580093827, 0.1815389580093827, 0.1871770963491578, 0.1871770963491578, 0.1871770963491578, 0.19390384974583152, 0.19390384974583152, 0.19390384974583152, 0.10123731720550344, 0.10123731720550344, 0.10123731720550344, 0.08845782502540256, 0.08845782502540256, 0.08845782502540256, 0.08707924978947645, 0.08707924978947645, 0.08707924978947645]}, "mutation_prompt": null}
{"id": "53f26d7c-c35e-4088-9782-8748b006851f", "solution": "import numpy as np\n\nclass HybridQuantumEnhancedDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.6\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumEnhancedDSO", "description": "Hybrid Quantum-Enhanced Differential Swarm Optimization with adaptive mutation and velocity adjustments.", "configspace": "", "generation": 66, "fitness": 0.3114930532147175, "feedback": "The algorithm HybridQuantumEnhancedDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7595906579149919, 0.7595906579149919, 0.7595906579149919, 0.7352439451236051, 0.7352439451236051, 0.7352439451236051, 0.7558430120351474, 0.7558430120351474, 0.7558430120351474, 0.23638487207728487, 0.23638487207728487, 0.23638487207728487, 0.3830252984747071, 0.3830252984747071, 0.3830252984747071, 0.34232337951162595, 0.34232337951162595, 0.34232337951162595, 0.1094356585847387, 0.1094356585847387, 0.1094356585847387, 0.16199399413286575, 0.16199399413286575, 0.16199399413286575, 0.12259214166179222, 0.12259214166179222, 0.12259214166179222, 0.11847451538459408, 0.11847451538459408, 0.11847451538459408, 0.10913851731494795, 0.10913851731494795, 0.10913851731494795, 0.11519235112519888, 0.11519235112519888, 0.11519235112519888, 0.9544783811505223, 0.9544783811505223, 0.9544783811505223, 0.9550785325438427, 0.9550785325438427, 0.9550785325438427, 0.9553691612196942, 0.9553691612196942, 0.9553691612196942, 0.4988113276254251, 0.4988113276254251, 0.4988113276254251, 0.3862456368237306, 0.3862456368237306, 0.3862456368237306, 0.5067910633738805, 0.5067910633738805, 0.5067910633738805, 0.7623396181465159, 0.7623396181465159, 0.7623396181465159, 0.16084450737135791, 0.16084450737135791, 0.16084450737135791, 0.7623944864275121, 0.7623944864275121, 0.7623944864275121, 0.34156434169218786, 0.34156434169218786, 0.34156434169218786, 0.397020580261485, 0.397020580261485, 0.397020580261485, 0.33542833716531606, 0.33542833716531606, 0.33542833716531606, 0.2353322052152539, 0.2353322052152539, 0.2353322052152539, 0.4181346857788508, 0.4181346857788508, 0.4181346857788508, 0.11747143746782662, 0.11747143746782662, 0.11747143746782662, 0.2364507926994177, 0.2364507926994177, 0.2364507926994177, 0.13233665548879725, 0.13233665548879725, 0.13233665548879725, 0.09848384842717062, 0.09848384842717062, 0.09848384842717062, 0.2503852542775602, 0.2503852542775602, 0.2503852542775602, 0.10554879459440603, 0.10554879459440603, 0.10554879459440603, 0.14819486536265214, 0.14819486536265214, 0.14819486536265214, 0.07327927536671108, 0.07327927536671108, 0.07327927536671108, 0.06482483957306306, 0.06482483957306306, 0.06482483957306306, 0.08388307018554875, 0.08388307018554875, 0.08388307018554875, 0.17264530986575066, 0.17264530986575066, 0.17264530986575066, 0.20069004276174118, 0.20069004276174118, 0.20069004276174118, 0.19413292918569724, 0.19413292918569724, 0.19413292918569724, 0.5825822792557902, 0.5825822792557902, 0.5825822792557902, 0.5942799351029753, 0.5942799351029753, 0.5942799351029753, 0.611150782568316, 0.611150782568316, 0.611150782568316, 0.12739567746781777, 0.12739567746781777, 0.12739567746781777, 0.10224751844095936, 0.10224751844095936, 0.10224751844095936, 0.10199725829769302, 0.10199725829769302, 0.10199725829769302, 0.2035549527930527, 0.2035549527930527, 0.2035549527930527, 0.24413044243645576, 0.24413044243645576, 0.24413044243645576, 0.20529390834567007, 0.20529390834567007, 0.20529390834567007, 0.31094964170180117, 0.31094964170180117, 0.31094964170180117, 0.37558283640288304, 0.37558283640288304, 0.37558283640288304, 0.3037411852774169, 0.3037411852774169, 0.3037411852774169, 0.21070355372353078, 0.21070355372353078, 0.21070355372353078, 0.27266784757785545, 0.27266784757785545, 0.27266784757785545, 0.16621065364076149, 0.16621065364076149, 0.16621065364076149, 0.21811882008594996, 0.21811882008594996, 0.21811882008594996, 0.23084192465157682, 0.23084192465157682, 0.23084192465157682, 0.23921906688254557, 0.23921906688254557, 0.23921906688254557, 0.19699932819128263, 0.19699932819128263, 0.19699932819128263, 0.19219124829643586, 0.19219124829643586, 0.19219124829643586, 0.1837660412173906, 0.1837660412173906, 0.1837660412173906, 0.8819959167291388, 0.8819959167291388, 0.8819959167291388, 0.15735676743864424, 0.15735676743864424, 0.15735676743864424, 0.16951499275191306, 0.16951499275191306, 0.16951499275191306, 0.7908882042768539, 0.7908882042768539, 0.7908882042768539, 0.2101056305391178, 0.2101056305391178, 0.2101056305391178, 0.15461830843322044, 0.15461830843322044, 0.15461830843322044, 0.19605227271155767, 0.19605227271155767, 0.19605227271155767, 0.20057658267543343, 0.20057658267543343, 0.20057658267543343, 0.2170289831399277, 0.2170289831399277, 0.2170289831399277, 0.08703306476050843, 0.08703306476050843, 0.08703306476050843, 0.08793551951257705, 0.08793551951257705, 0.08793551951257705, 0.1033703627391902, 0.1033703627391902, 0.1033703627391902]}, "mutation_prompt": null}
{"id": "aa61fb2a-0c3d-44fc-94e2-b0c55d16f920", "solution": "import numpy as np\n\nclass QuantumAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.base_inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.2\n        self.elite_quantum_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia_weight = self.base_inertia - ((self.base_inertia - 0.4) * eval_count / self.budget)\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia_weight * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation with localized strategy\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumAdaptiveDSO", "description": "Quantum-Inspired Adaptive Differential Swarm Optimization with dynamic inertia and localized mutation for enhanced exploration and exploitation.", "configspace": "", "generation": 67, "fitness": 0.32678666098607495, "feedback": "The algorithm QuantumAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7524804243442443, 0.7524804243442443, 0.7524804243442443, 0.7609034757253058, 0.7609034757253058, 0.7609034757253058, 0.7886430919527002, 0.7886430919527002, 0.7886430919527002, 0.4822286793267969, 0.4822286793267969, 0.4822286793267969, 0.4457215990677713, 0.4457215990677713, 0.4457215990677713, 0.4196838715463098, 0.4196838715463098, 0.4196838715463098, 0.1335260189114108, 0.1335260189114108, 0.1335260189114108, 0.1379104753823831, 0.1379104753823831, 0.1379104753823831, 0.10018498213249694, 0.10018498213249694, 0.10018498213249694, 0.10439543831328213, 0.10439543831328213, 0.10439543831328213, 0.07644064840922316, 0.07644064840922316, 0.07644064840922316, 0.07527287948026173, 0.07527287948026173, 0.07527287948026173, 0.9531359888792557, 0.9531359888792557, 0.9531359888792557, 0.9650145262783614, 0.9650145262783614, 0.9650145262783614, 0.9594865652969272, 0.9594865652969272, 0.9594865652969272, 0.5172922580407563, 0.5172922580407563, 0.5172922580407563, 0.5050786450111286, 0.5050786450111286, 0.5050786450111286, 0.5339553963033706, 0.5339553963033706, 0.5339553963033706, 0.22448272913637624, 0.22448272913637624, 0.22448272913637624, 0.713039530023541, 0.713039530023541, 0.713039530023541, 0.17112347340215472, 0.17112347340215472, 0.17112347340215472, 0.4778815545379753, 0.4778815545379753, 0.4778815545379753, 0.4627134677263979, 0.4627134677263979, 0.4627134677263979, 0.3015745744527447, 0.3015745744527447, 0.3015745744527447, 0.33324525404924554, 0.33324525404924554, 0.33324525404924554, 0.4615269789562757, 0.4615269789562757, 0.4615269789562757, 0.12690239093759015, 0.12690239093759015, 0.12690239093759015, 0.060099980528048214, 0.060099980528048214, 0.060099980528048214, 0.11978021175278153, 0.11978021175278153, 0.11978021175278153, 0.2857093603831913, 0.2857093603831913, 0.2857093603831913, 0.2328645035648621, 0.2328645035648621, 0.2328645035648621, 0.3238950763604872, 0.3238950763604872, 0.3238950763604872, 0.36873684619605607, 0.36873684619605607, 0.36873684619605607, 0.03969907249513294, 0.03969907249513294, 0.03969907249513294, 0.1905131573211476, 0.1905131573211476, 0.1905131573211476, 0.18729684044576156, 0.18729684044576156, 0.18729684044576156, 0.19673476826106284, 0.19673476826106284, 0.19673476826106284, 0.036230942650699816, 0.036230942650699816, 0.036230942650699816, 0.13265299657473772, 0.13265299657473772, 0.13265299657473772, 0.6388006943061653, 0.6388006943061653, 0.6388006943061653, 0.6008540453988191, 0.6008540453988191, 0.6008540453988191, 0.6183911838955127, 0.6183911838955127, 0.6183911838955127, 0.11303936483903931, 0.11303936483903931, 0.11303936483903931, 0.13230689433970733, 0.13230689433970733, 0.13230689433970733, 0.13748914343722696, 0.13748914343722696, 0.13748914343722696, 0.5308100652263722, 0.5308100652263722, 0.5308100652263722, 0.2153627028673194, 0.2153627028673194, 0.2153627028673194, 0.3209060561619195, 0.3209060561619195, 0.3209060561619195, 0.4132615824900535, 0.4132615824900535, 0.4132615824900535, 0.4326186154468451, 0.4326186154468451, 0.4326186154468451, 0.3788122555483957, 0.3788122555483957, 0.3788122555483957, 0.25986182769711375, 0.25986182769711375, 0.25986182769711375, 0.25627461211063185, 0.25627461211063185, 0.25627461211063185, 0.33431561246239794, 0.33431561246239794, 0.33431561246239794, 0.23055912857431926, 0.23055912857431926, 0.23055912857431926, 0.2260037176746309, 0.2260037176746309, 0.2260037176746309, 0.2248062090623575, 0.2248062090623575, 0.2248062090623575, 0.21333065404049034, 0.21333065404049034, 0.21333065404049034, 0.20624109552480363, 0.20624109552480363, 0.20624109552480363, 0.20457995908337157, 0.20457995908337157, 0.20457995908337157, 0.8867771420968835, 0.8867771420968835, 0.8867771420968835, 0.164226203950962, 0.164226203950962, 0.164226203950962, 0.17474297348563084, 0.17474297348563084, 0.17474297348563084, 0.20792910132456166, 0.20792910132456166, 0.20792910132456166, 0.20916578661681662, 0.20916578661681662, 0.20916578661681662, 0.1657521906826087, 0.1657521906826087, 0.1657521906826087, 0.19054320097561928, 0.19054320097561928, 0.19054320097561928, 0.2225464987839033, 0.2225464987839033, 0.2225464987839033, 0.19102353016690832, 0.19102353016690832, 0.19102353016690832, 0.10589807338668067, 0.10589807338668067, 0.10589807338668067, 0.08383556612567755, 0.08383556612567755, 0.08383556612567755, 0.07951522905539454, 0.07951522905539454, 0.07951522905539454]}, "mutation_prompt": null}
{"id": "43dcdc50-ec86-4a7f-adb9-c22ecf7d44ee", "solution": "import numpy as np\n\nclass AdaptiveQuantumDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia_initial = 0.9\n        self.inertia_final = 0.4\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_initial = 0.9\n        self.de_crossover_final = 0.6\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia_weight = (self.inertia_initial - self.inertia_final) * (1 - eval_count / self.budget) + self.inertia_final\n            de_crossover_rate = (self.de_crossover_initial - self.de_crossover_final) * (1 - eval_count / self.budget) + self.de_crossover_final\n\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia_weight * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumDSO", "description": "Adaptive Quantum Differential Swarm Optimization with dynamic inertia and crossover rate for improved exploration and exploitation.", "configspace": "", "generation": 68, "fitness": 0.2627705309109225, "feedback": "The algorithm AdaptiveQuantumDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6417200769569817, 0.6417200769569817, 0.6417200769569817, 0.6317730561691068, 0.6317730561691068, 0.6317730561691068, 0.6298516550057325, 0.6298516550057325, 0.6298516550057325, 0.182316302462043, 0.182316302462043, 0.182316302462043, 0.22047586371266614, 0.22047586371266614, 0.22047586371266614, 0.17559218584834002, 0.17559218584834002, 0.17559218584834002, 0.11891950861909206, 0.11891950861909206, 0.11891950861909206, 0.11452223544468632, 0.11452223544468632, 0.11452223544468632, 0.11825952548635721, 0.11825952548635721, 0.11825952548635721, 0.11377116360321127, 0.11377116360321127, 0.11377116360321127, 0.08627488754133861, 0.08627488754133861, 0.08627488754133861, 0.10008235202021332, 0.10008235202021332, 0.10008235202021332, 0.960831254825613, 0.960831254825613, 0.960831254825613, 0.961572412343447, 0.961572412343447, 0.961572412343447, 0.9591110873092192, 0.9591110873092192, 0.9591110873092192, 0.44639200445827465, 0.44639200445827465, 0.44639200445827465, 0.38934989157609823, 0.38934989157609823, 0.38934989157609823, 0.40815728846777855, 0.40815728846777855, 0.40815728846777855, 0.330784577000638, 0.330784577000638, 0.330784577000638, 0.1766604195218462, 0.1766604195218462, 0.1766604195218462, 0.5589766497734648, 0.5589766497734648, 0.5589766497734648, 0.28622826941344637, 0.28622826941344637, 0.28622826941344637, 0.1213592109884647, 0.1213592109884647, 0.1213592109884647, 0.2929090139582923, 0.2929090139582923, 0.2929090139582923, 0.31442942960057585, 0.31442942960057585, 0.31442942960057585, 0.22880679349361432, 0.22880679349361432, 0.22880679349361432, 0.12258970274164382, 0.12258970274164382, 0.12258970274164382, 0.03699570755353887, 0.03699570755353887, 0.03699570755353887, 0.1101465457371007, 0.1101465457371007, 0.1101465457371007, 0.10675269755969219, 0.10675269755969219, 0.10675269755969219, 0.2013515537264059, 0.2013515537264059, 0.2013515537264059, 0.07111937306917604, 0.07111937306917604, 0.07111937306917604, 0.11576908235169503, 0.11576908235169503, 0.11576908235169503, 0.027560162646541042, 0.027560162646541042, 0.027560162646541042, 0.0892786180396965, 0.0892786180396965, 0.0892786180396965, 0.05386507368940041, 0.05386507368940041, 0.05386507368940041, 0.14740140160102178, 0.14740140160102178, 0.14740140160102178, 0.2011925214411976, 0.2011925214411976, 0.2011925214411976, 0.09883129380049682, 0.09883129380049682, 0.09883129380049682, 0.513760665632933, 0.513760665632933, 0.513760665632933, 0.5406867927617833, 0.5406867927617833, 0.5406867927617833, 0.52337910931725, 0.52337910931725, 0.52337910931725, 0.1300692692835166, 0.1300692692835166, 0.1300692692835166, 0.11394217890379787, 0.11394217890379787, 0.11394217890379787, 0.11551351838181056, 0.11551351838181056, 0.11551351838181056, 0.2834227994175105, 0.2834227994175105, 0.2834227994175105, 0.163526617948638, 0.163526617948638, 0.163526617948638, 0.24828969936871714, 0.24828969936871714, 0.24828969936871714, 0.32754076734921844, 0.32754076734921844, 0.32754076734921844, 0.29694006478840507, 0.29694006478840507, 0.29694006478840507, 0.37442329333364044, 0.37442329333364044, 0.37442329333364044, 0.22646500694337357, 0.22646500694337357, 0.22646500694337357, 0.23791655380464793, 0.23791655380464793, 0.23791655380464793, 0.19236495282527843, 0.19236495282527843, 0.19236495282527843, 0.21127199559038579, 0.21127199559038579, 0.21127199559038579, 0.20916513223733868, 0.20916513223733868, 0.20916513223733868, 0.21459769527102157, 0.21459769527102157, 0.21459769527102157, 0.17369414961824736, 0.17369414961824736, 0.17369414961824736, 0.19271043533368426, 0.19271043533368426, 0.19271043533368426, 0.19293778191600608, 0.19293778191600608, 0.19293778191600608, 0.7953000141395271, 0.7953000141395271, 0.7953000141395271, 0.1582974374068824, 0.1582974374068824, 0.1582974374068824, 0.16203287055883175, 0.16203287055883175, 0.16203287055883175, 0.1667825490133884, 0.1667825490133884, 0.1667825490133884, 0.2076677419050985, 0.2076677419050985, 0.2076677419050985, 0.1546145835413819, 0.1546145835413819, 0.1546145835413819, 0.20857895130935244, 0.20857895130935244, 0.20857895130935244, 0.2067225466396807, 0.2067225466396807, 0.2067225466396807, 0.1829751944419057, 0.1829751944419057, 0.1829751944419057, 0.08618398857204757, 0.08618398857204757, 0.08618398857204757, 0.0767601635770705, 0.0767601635770705, 0.0767601635770705, 0.07896285489590282, 0.07896285489590282, 0.07896285489590282]}, "mutation_prompt": null}
{"id": "801aa344-4dde-4270-86e3-a4de34713b9b", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6  # slightly increased inertia\n        self.cognitive = 1.4  # slightly increased cognitive component\n        self.social = 1.9  # slightly decreased social component\n        self.quantum_prob = 0.2  # slightly decreased quantum probability\n        self.elite_quantum_prob = 0.2  # increased elite quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # increased max velocity\n        self.de_mutation_factor = 0.9  # slightly increased mutation factor\n        self.de_crossover_rate = 0.95  # increased crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.5\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with multi-parent crossover\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 4, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]]) +\n                        self.de_mutation_factor * (positions[idxs[3]] - positions[i])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumInspiredDSO", "description": "Hybrid Quantum-Inspired Differential Swarm Optimization with adaptive velocity control, elite diversification, and multi-parent crossover.", "configspace": "", "generation": 69, "fitness": 0.3029145182158706, "feedback": "The algorithm HybridQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7703733316489754, 0.7703733316489754, 0.7703733316489754, 0.7720838323182702, 0.7720838323182702, 0.7720838323182702, 0.7571335241930461, 0.7571335241930461, 0.7571335241930461, 0.050673726042016476, 0.050673726042016476, 0.050673726042016476, 0.2100054133252761, 0.2100054133252761, 0.2100054133252761, 0.046810129875925144, 0.046810129875925144, 0.046810129875925144, 0.12578860883424792, 0.12578860883424792, 0.12578860883424792, 0.14927475725286332, 0.14927475725286332, 0.14927475725286332, 0.09292065068971622, 0.09292065068971622, 0.09292065068971622, 0.08352550059155817, 0.08352550059155817, 0.08352550059155817, 0.10188994147323083, 0.10188994147323083, 0.10188994147323083, 0.11718309508326297, 0.11718309508326297, 0.11718309508326297, 0.9559518535493908, 0.9559518535493908, 0.9559518535493908, 0.9759907328755589, 0.9759907328755589, 0.9759907328755589, 0.9629487590431087, 0.9629487590431087, 0.9629487590431087, 0.4735584060636746, 0.4735584060636746, 0.4735584060636746, 0.5300260166122908, 0.5300260166122908, 0.5300260166122908, 0.4655458471725926, 0.4655458471725926, 0.4655458471725926, 0.3600028430603075, 0.3600028430603075, 0.3600028430603075, 0.3494648676484704, 0.3494648676484704, 0.3494648676484704, 0.5660573088512486, 0.5660573088512486, 0.5660573088512486, 0.27044060156377003, 0.27044060156377003, 0.27044060156377003, 0.12567749020322205, 0.12567749020322205, 0.12567749020322205, 0.30600733996695084, 0.30600733996695084, 0.30600733996695084, 0.36005344582495913, 0.36005344582495913, 0.36005344582495913, 0.24407594205534688, 0.24407594205534688, 0.24407594205534688, 0.45443045229519463, 0.45443045229519463, 0.45443045229519463, 0.051408394284734316, 0.051408394284734316, 0.051408394284734316, 0.24705339031319273, 0.24705339031319273, 0.24705339031319273, 0.11436681258303893, 0.11436681258303893, 0.11436681258303893, 0.18124753916029657, 0.18124753916029657, 0.18124753916029657, 0.13779052858508134, 0.13779052858508134, 0.13779052858508134, 0.22413752963508282, 0.22413752963508282, 0.22413752963508282, 0.10819527688715536, 0.10819527688715536, 0.10819527688715536, 0.20070860099621435, 0.20070860099621435, 0.20070860099621435, 0.1615111501220503, 0.1615111501220503, 0.1615111501220503, 0.20550353976149116, 0.20550353976149116, 0.20550353976149116, 0.14950036518485577, 0.14950036518485577, 0.14950036518485577, 0.14583583958804136, 0.14583583958804136, 0.14583583958804136, 0.5598634921531673, 0.5598634921531673, 0.5598634921531673, 0.5827565844217018, 0.5827565844217018, 0.5827565844217018, 0.5981367089932002, 0.5981367089932002, 0.5981367089932002, 0.13575054624157057, 0.13575054624157057, 0.13575054624157057, 0.10570482562327799, 0.10570482562327799, 0.10570482562327799, 0.10715444168849753, 0.10715444168849753, 0.10715444168849753, 0.14174765791500576, 0.14174765791500576, 0.14174765791500576, 0.4625446750609704, 0.4625446750609704, 0.4625446750609704, 0.27954191499257186, 0.27954191499257186, 0.27954191499257186, 0.33541110917381, 0.33541110917381, 0.33541110917381, 0.346644552471289, 0.346644552471289, 0.346644552471289, 0.3460798607328548, 0.3460798607328548, 0.3460798607328548, 0.2576780886736204, 0.2576780886736204, 0.2576780886736204, 0.18763920934244793, 0.18763920934244793, 0.18763920934244793, 0.1897629614603683, 0.1897629614603683, 0.1897629614603683, 0.23084202223512906, 0.23084202223512906, 0.23084202223512906, 0.2227230434554861, 0.2227230434554861, 0.2227230434554861, 0.22046940822616212, 0.22046940822616212, 0.22046940822616212, 0.1855450821263711, 0.1855450821263711, 0.1855450821263711, 0.18187951579961914, 0.18187951579961914, 0.18187951579961914, 0.19263952231028558, 0.19263952231028558, 0.19263952231028558, 0.8717071144703077, 0.8717071144703077, 0.8717071144703077, 0.15881572265440613, 0.15881572265440613, 0.15881572265440613, 0.8411916515962189, 0.8411916515962189, 0.8411916515962189, 0.20985837608316338, 0.20985837608316338, 0.20985837608316338, 0.21077132269968457, 0.21077132269968457, 0.21077132269968457, 0.1551582420296792, 0.1551582420296792, 0.1551582420296792, 0.1935920742688474, 0.1935920742688474, 0.1935920742688474, 0.2230339308021948, 0.2230339308021948, 0.2230339308021948, 0.18232600301536905, 0.18232600301536905, 0.18232600301536905, 0.09066641935939201, 0.09066641935939201, 0.09066641935939201, 0.08363769011614353, 0.08363769011614353, 0.08363769011614353, 0.1134181561341604, 0.1134181561341604, 0.1134181561341604]}, "mutation_prompt": null}
{"id": "366256e6-c38a-4b22-844b-c1a5ec270b2a", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = self.halton_sequence(self.num_particles, self.dim)\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    memory_factor = 0.6\n                    quantum_position = self.global_best_position + memory_factor * np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value\n\n    def halton_sequence(self, size, dim):\n        def halton_single_index(index, base):\n            result = 0.0\n            f = 1.0\n            i = index\n            while i > 0:\n                f = f / base\n                result = result + f * (i % base)\n                i = int(i / base)\n            return result\n\n        seq = np.empty((size, dim))\n        primes = self._first_primes(dim)\n        for d in range(dim):\n            for i in range(size):\n                seq[i, d] = halton_single_index(i + 1, primes[d]) * (self.ub - self.lb) + self.lb\n        return seq\n\n    def _first_primes(self, n):\n        primes = []\n        candidate = 2\n        while len(primes) < n:\n            is_prime = True\n            for p in primes:\n                if candidate % p == 0:\n                    is_prime = False\n                    break\n            if is_prime:\n                primes.append(candidate)\n            candidate += 1\n        return primes", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with nonlinear inertia weight, quasi-random initialization, and memory-based elite reinforcement.", "configspace": "", "generation": 70, "fitness": 0.2806151021327058, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6120498423649446, 0.6120498423649446, 0.6120498423649446, 0.617013025265357, 0.617013025265357, 0.617013025265357, 0.6469782942933479, 0.6469782942933479, 0.6469782942933479, 0.14316215284172762, 0.14316215284172762, 0.14316215284172762, 0.13702873412920558, 0.13702873412920558, 0.13702873412920558, 0.1586365536205101, 0.1586365536205101, 0.1586365536205101, 0.11847788423025851, 0.11847788423025851, 0.11847788423025851, 0.10134632622298434, 0.10134632622298434, 0.10134632622298434, 0.12280985765597874, 0.12280985765597874, 0.12280985765597874, 0.10138156185631264, 0.10138156185631264, 0.10138156185631264, 0.09602800967303515, 0.09602800967303515, 0.09602800967303515, 0.10037550427144304, 0.10037550427144304, 0.10037550427144304, 0.9453152599168139, 0.9453152599168139, 0.9453152599168139, 0.9480228772231823, 0.9480228772231823, 0.9480228772231823, 0.9622459549778415, 0.9622459549778415, 0.9622459549778415, 0.38059773927654095, 0.38059773927654095, 0.38059773927654095, 0.3834408111392986, 0.3834408111392986, 0.3834408111392986, 0.3956352512011755, 0.3956352512011755, 0.3956352512011755, 0.21779564412166796, 0.21779564412166796, 0.21779564412166796, 0.2636307288174705, 0.2636307288174705, 0.2636307288174705, 0.6047785688016072, 0.6047785688016072, 0.6047785688016072, 0.2621191719196617, 0.2621191719196617, 0.2621191719196617, 0.2677678196005404, 0.2677678196005404, 0.2677678196005404, 0.29265613325700246, 0.29265613325700246, 0.29265613325700246, 0.24886441676134552, 0.24886441676134552, 0.24886441676134552, 0.2269245734035681, 0.2269245734035681, 0.2269245734035681, 0.21015020421876607, 0.21015020421876607, 0.21015020421876607, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11484844677548223, 0.11484844677548223, 0.11484844677548223, 0.029381411991438622, 0.029381411991438622, 0.029381411991438622, 0.16313789947075097, 0.16313789947075097, 0.16313789947075097, 0.09627782366664017, 0.09627782366664017, 0.09627782366664017, 0.11723927855926031, 0.11723927855926031, 0.11723927855926031, 0.08704121500053263, 0.08704121500053263, 0.08704121500053263, 0.049623180473932216, 0.049623180473932216, 0.049623180473932216, 0.04160665955216136, 0.04160665955216136, 0.04160665955216136, 0.187598561422188, 0.187598561422188, 0.187598561422188, 0.111136885234003, 0.111136885234003, 0.111136885234003, 0.12323348582662896, 0.12323348582662896, 0.12323348582662896, 0.5007151533197474, 0.5007151533197474, 0.5007151533197474, 0.5158912450999045, 0.5158912450999045, 0.5158912450999045, 0.47378484084139016, 0.47378484084139016, 0.47378484084139016, 0.09911787916195369, 0.09911787916195369, 0.09911787916195369, 0.13422864321406902, 0.13422864321406902, 0.13422864321406902, 0.16360408189296083, 0.16360408189296083, 0.16360408189296083, 0.349614435358105, 0.349614435358105, 0.349614435358105, 0.3916493190706388, 0.3916493190706388, 0.3916493190706388, 0.27406631415904126, 0.27406631415904126, 0.27406631415904126, 0.35610230820070765, 0.35610230820070765, 0.35610230820070765, 0.35304017418344136, 0.35304017418344136, 0.35304017418344136, 0.34978760107382256, 0.34978760107382256, 0.34978760107382256, 0.26207599690399397, 0.26207599690399397, 0.26207599690399397, 0.23855599036466058, 0.23855599036466058, 0.23855599036466058, 0.1830782811055447, 0.1830782811055447, 0.1830782811055447, 0.20779465439767375, 0.20779465439767375, 0.20779465439767375, 0.21806318805965297, 0.21806318805965297, 0.21806318805965297, 0.20641166994393412, 0.20641166994393412, 0.20641166994393412, 0.2261212147318884, 0.2261212147318884, 0.2261212147318884, 0.20779367710270313, 0.20779367710270313, 0.20779367710270313, 0.19160595323801122, 0.19160595323801122, 0.19160595323801122, 0.19826262113520854, 0.19826262113520854, 0.19826262113520854, 0.7795276474400815, 0.7795276474400815, 0.7795276474400815, 0.16245396176398585, 0.16245396176398585, 0.16245396176398585, 0.6854129114002314, 0.6854129114002314, 0.6854129114002314, 0.2105948547768106, 0.2105948547768106, 0.2105948547768106, 0.7122958897107663, 0.7122958897107663, 0.7122958897107663, 0.19313863026029532, 0.19313863026029532, 0.19313863026029532, 0.17943042559770295, 0.17943042559770295, 0.17943042559770295, 0.17779190792362365, 0.17779190792362365, 0.17779190792362365, 0.100358749362213, 0.100358749362213, 0.100358749362213, 0.10980197323094276, 0.10980197323094276, 0.10980197323094276, 0.10565741049450206, 0.10565741049450206, 0.10565741049450206]}, "mutation_prompt": null}
{"id": "85a3e94e-1734-4622-b9d4-8eb1f5daecee", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n        self.diversity_control_factor = 0.1\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation with dynamic control\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    donor_vector += np.random.normal(0, self.diversity_control_factor, self.dim)\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with dynamic mutation control and adaptive swarm diversity.", "configspace": "", "generation": 71, "fitness": 0.28312296946453547, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8293600170680353, 0.8293600170680353, 0.8293600170680353, 0.8100107721145224, 0.8100107721145224, 0.8100107721145224, 0.8262730175346031, 0.8262730175346031, 0.8262730175346031, 0.3420040293975696, 0.3420040293975696, 0.3420040293975696, 0.14841623852471364, 0.14841623852471364, 0.14841623852471364, 0.5721717092421025, 0.5721717092421025, 0.5721717092421025, 0.115961272212602, 0.115961272212602, 0.115961272212602, 0.10971456595730511, 0.10971456595730511, 0.10971456595730511, 0.11542243200591984, 0.11542243200591984, 0.11542243200591984, 0.12055608199936485, 0.12055608199936485, 0.12055608199936485, 0.04669960783664262, 0.04669960783664262, 0.04669960783664262, 0.14674022481148274, 0.14674022481148274, 0.14674022481148274, 0.9825318857649832, 0.9825318857649832, 0.9825318857649832, 0.9640598903428392, 0.9640598903428392, 0.9640598903428392, 0.9642409466462062, 0.9642409466462062, 0.9642409466462062, 0.41662386167141663, 0.41662386167141663, 0.41662386167141663, 0.5577070455811219, 0.5577070455811219, 0.5577070455811219, 0.4182972621296761, 0.4182972621296761, 0.4182972621296761, 0.2237184916690491, 0.2237184916690491, 0.2237184916690491, 0.16148648477947336, 0.16148648477947336, 0.16148648477947336, 0.2295538017566351, 0.2295538017566351, 0.2295538017566351, 0.3303450551229029, 0.3303450551229029, 0.3303450551229029, 0.13452691404466421, 0.13452691404466421, 0.13452691404466421, 0.16367165442147857, 0.16367165442147857, 0.16367165442147857, 0.3259124416667377, 0.3259124416667377, 0.3259124416667377, 0.32104008976679854, 0.32104008976679854, 0.32104008976679854, 0.13060333558241688, 0.13060333558241688, 0.13060333558241688, 0.09464898608006167, 0.09464898608006167, 0.09464898608006167, 0.14761243503218424, 0.14761243503218424, 0.14761243503218424, 0.17665699019762393, 0.17665699019762393, 0.17665699019762393, 0.35741292816154113, 0.35741292816154113, 0.35741292816154113, 0.22069579237920767, 0.22069579237920767, 0.22069579237920767, 0.2741143256216304, 0.2741143256216304, 0.2741143256216304, 0.04475035448331144, 0.04475035448331144, 0.04475035448331144, 0.09207258295958565, 0.09207258295958565, 0.09207258295958565, 0.07732130651978153, 0.07732130651978153, 0.07732130651978153, 0.17780326290588544, 0.17780326290588544, 0.17780326290588544, 0.2625563829106975, 0.2625563829106975, 0.2625563829106975, 0.19334235618421525, 0.19334235618421525, 0.19334235618421525, 0.5835390004764042, 0.5835390004764042, 0.5835390004764042, 0.5275225057751312, 0.5275225057751312, 0.5275225057751312, 0.6371282110669418, 0.6371282110669418, 0.6371282110669418, 0.10639415864258861, 0.10639415864258861, 0.10639415864258861, 0.10994343214947289, 0.10994343214947289, 0.10994343214947289, 0.12454328015796834, 0.12454328015796834, 0.12454328015796834, 0.2927504586667036, 0.2927504586667036, 0.2927504586667036, 0.19217249910864953, 0.19217249910864953, 0.19217249910864953, 0.19920243730394382, 0.19920243730394382, 0.19920243730394382, 0.3351654186115248, 0.3351654186115248, 0.3351654186115248, 0.32765259368497346, 0.32765259368497346, 0.32765259368497346, 0.341148124365107, 0.341148124365107, 0.341148124365107, 0.2788258768731052, 0.2788258768731052, 0.2788258768731052, 0.15896169937510352, 0.15896169937510352, 0.15896169937510352, 0.23411867744269377, 0.23411867744269377, 0.23411867744269377, 0.21685845941047543, 0.21685845941047543, 0.21685845941047543, 0.21872912193889937, 0.21872912193889937, 0.21872912193889937, 0.24451195888073185, 0.24451195888073185, 0.24451195888073185, 0.20897682897565206, 0.20897682897565206, 0.20897682897565206, 0.2044628246180108, 0.2044628246180108, 0.2044628246180108, 0.20451947870431042, 0.20451947870431042, 0.20451947870431042, 0.18806108952582934, 0.18806108952582934, 0.18806108952582934, 0.16506714686374868, 0.16506714686374868, 0.16506714686374868, 0.1777748888319387, 0.1777748888319387, 0.1777748888319387, 0.2094100357328793, 0.2094100357328793, 0.2094100357328793, 0.21109867154991746, 0.21109867154991746, 0.21109867154991746, 0.1557890945361261, 0.1557890945361261, 0.1557890945361261, 0.19396291899826934, 0.19396291899826934, 0.19396291899826934, 0.23466252822287104, 0.23466252822287104, 0.23466252822287104, 0.19768107913767374, 0.19768107913767374, 0.19768107913767374, 0.09406657196788837, 0.09406657196788837, 0.09406657196788837, 0.08630160462864278, 0.08630160462864278, 0.08630160462864278, 0.09721429213538635, 0.09721429213538635, 0.09721429213538635]}, "mutation_prompt": null}
{"id": "818e95e2-157e-449f-8713-58b411622ccb", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.2\n        self.social = 1.8\n        self.quantum_prob = 0.2\n        self.elite_quantum_prob = 0.2\n        self.local_attraction_prob = 0.5\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n                \n                # Local attraction update\n                if np.random.rand() < self.local_attraction_prob:\n                    local_best_neighbor_idx = np.argmin(personal_best_values)\n                    local_attraction_position = personal_best_positions[local_best_neighbor_idx] + np.random.randn(self.dim)\n                    local_attraction_position = np.clip(local_attraction_position, self.lb, self.ub)\n                    local_attraction_value = func(local_attraction_position)\n                    eval_count += 1\n                    if local_attraction_value < personal_best_values[i]:\n                        personal_best_positions[i] = local_attraction_position\n                        personal_best_values[i] = local_attraction_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumInspiredDE", "description": "Hybrid Quantum-Inspired Differential Evolution with adaptive velocity control and elite particle reinforcement using local attraction pull.", "configspace": "", "generation": 72, "fitness": 0.2744700813919475, "feedback": "The algorithm HybridQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6972442361765829, 0.6972442361765829, 0.6972442361765829, 0.6592515620062029, 0.6592515620062029, 0.6592515620062029, 0.6719587585569824, 0.6719587585569824, 0.6719587585569824, 0.2405203453765553, 0.2405203453765553, 0.2405203453765553, 0.03250696617855087, 0.03250696617855087, 0.03250696617855087, 0.015975461129764557, 0.015975461129764557, 0.015975461129764557, 0.12231874701714973, 0.12231874701714973, 0.12231874701714973, 0.11371919333331992, 0.11371919333331992, 0.11371919333331992, 0.17063085121906352, 0.17063085121906352, 0.17063085121906352, 0.11180740860169935, 0.11180740860169935, 0.11180740860169935, 0.07635529382904316, 0.07635529382904316, 0.07635529382904316, 0.10025446333364674, 0.10025446333364674, 0.10025446333364674, 0.9535445776562312, 0.9535445776562312, 0.9535445776562312, 0.9646567907115123, 0.9646567907115123, 0.9646567907115123, 0.9613356972977563, 0.9613356972977563, 0.9613356972977563, 0.3633418924424002, 0.3633418924424002, 0.3633418924424002, 0.36885341675226924, 0.36885341675226924, 0.36885341675226924, 0.4466022181926752, 0.4466022181926752, 0.4466022181926752, 0.7476646272680596, 0.7476646272680596, 0.7476646272680596, 0.201845013791071, 0.201845013791071, 0.201845013791071, 0.7311521530502322, 0.7311521530502322, 0.7311521530502322, 0.33094295829502907, 0.33094295829502907, 0.33094295829502907, 0.25356335443877964, 0.25356335443877964, 0.25356335443877964, 0.33175745019403435, 0.33175745019403435, 0.33175745019403435, 0.29591706811169716, 0.29591706811169716, 0.29591706811169716, 0.19457225599070016, 0.19457225599070016, 0.19457225599070016, 0.1287649357056293, 0.1287649357056293, 0.1287649357056293, 0.048833689627615806, 0.048833689627615806, 0.048833689627615806, 0.04504628882971662, 0.04504628882971662, 0.04504628882971662, 0.08081005656423712, 0.08081005656423712, 0.08081005656423712, 0.18021747404185584, 0.18021747404185584, 0.18021747404185584, 0.048292017009397004, 0.048292017009397004, 0.048292017009397004, 0.22743130743685092, 0.22743130743685092, 0.22743130743685092, 0.032353272898670515, 0.032353272898670515, 0.032353272898670515, 0.05884722487219629, 0.05884722487219629, 0.05884722487219629, 0.09173513573232761, 0.09173513573232761, 0.09173513573232761, 0.1532255140516805, 0.1532255140516805, 0.1532255140516805, 0.15059256107083563, 0.15059256107083563, 0.15059256107083563, 0.11853410689951727, 0.11853410689951727, 0.11853410689951727, 0.5215593803134582, 0.5215593803134582, 0.5215593803134582, 0.5247263604063908, 0.5247263604063908, 0.5247263604063908, 0.5480217513141834, 0.5480217513141834, 0.5480217513141834, 0.1386428366354001, 0.1386428366354001, 0.1386428366354001, 0.12664864913584484, 0.12664864913584484, 0.12664864913584484, 0.14170145120779276, 0.14170145120779276, 0.14170145120779276, 0.2519918304952763, 0.2519918304952763, 0.2519918304952763, 0.33030738519990277, 0.33030738519990277, 0.33030738519990277, 0.22895677779442103, 0.22895677779442103, 0.22895677779442103, 0.27438564748499294, 0.27438564748499294, 0.27438564748499294, 0.31121020557960155, 0.31121020557960155, 0.31121020557960155, 0.35877458364318626, 0.35877458364318626, 0.35877458364318626, 0.27234268381044013, 0.27234268381044013, 0.27234268381044013, 0.2145505707782268, 0.2145505707782268, 0.2145505707782268, 0.18242220013054944, 0.18242220013054944, 0.18242220013054944, 0.20873406877028522, 0.20873406877028522, 0.20873406877028522, 0.20439528851287558, 0.20439528851287558, 0.20439528851287558, 0.2181648322379176, 0.2181648322379176, 0.2181648322379176, 0.19106627493354122, 0.19106627493354122, 0.19106627493354122, 0.19790808310850727, 0.19790808310850727, 0.19790808310850727, 0.20863350548290183, 0.20863350548290183, 0.20863350548290183, 0.8307200835284094, 0.8307200835284094, 0.8307200835284094, 0.16566477444943362, 0.16566477444943362, 0.16566477444943362, 0.17732873596474952, 0.17732873596474952, 0.17732873596474952, 0.2092768219843264, 0.2092768219843264, 0.2092768219843264, 0.2085698007870478, 0.2085698007870478, 0.2085698007870478, 0.15508639002149083, 0.15508639002149083, 0.15508639002149083, 0.1880112506978422, 0.1880112506978422, 0.1880112506978422, 0.19289774963016626, 0.19289774963016626, 0.19289774963016626, 0.18570809304140956, 0.18570809304140956, 0.18570809304140956, 0.09616463815084886, 0.09616463815084886, 0.09616463815084886, 0.08216398227951593, 0.08216398227951593, 0.08216398227951593, 0.0921328270177435, 0.0921328270177435, 0.0921328270177435]}, "mutation_prompt": null}
{"id": "eb03e2a9-b197-4898-b378-fb3ac5f488e3", "solution": "import numpy as np\n\nclass QuantumDifferentialSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Adjusted inertia for exploration-exploitation balance\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.standard_normal(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update with adaptive inertia\n                r1, r2 = np.random.rand(), np.random.rand()\n                adaptive_inertia = self.inertia - (0.5 * eval_count / self.budget)\n                velocities[i] = (\n                    adaptive_inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation with fitness diversity reinforcement\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    if np.std(personal_best_values) > 0.1:\n                        donor_vector = (\n                            positions[idxs[0]] +\n                            self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                        )\n                    else:\n                        donor_vector = positions[i]  # Reinforce position in low diversity\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumDifferentialSwarmOptimization", "description": "Quantum Differential Swarm Optimization with adaptive inertia and fitness diversity reinforcement.", "configspace": "", "generation": 73, "fitness": 0.3247081089673995, "feedback": "The algorithm QuantumDifferentialSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7788685037213519, 0.7788685037213519, 0.7788685037213519, 0.7918530780674596, 0.7918530780674596, 0.7918530780674596, 0.8073768346081263, 0.8073768346081263, 0.8073768346081263, 0.03320744521309538, 0.03320744521309538, 0.03320744521309538, 0.4784768064282079, 0.4784768064282079, 0.4784768064282079, 0.5160324511684935, 0.5160324511684935, 0.5160324511684935, 0.1068483480071043, 0.1068483480071043, 0.1068483480071043, 0.12002000497952359, 0.12002000497952359, 0.12002000497952359, 0.1080316462770492, 0.1080316462770492, 0.1080316462770492, 0.09187710476118449, 0.09187710476118449, 0.09187710476118449, 0.06432913269427498, 0.06432913269427498, 0.06432913269427498, 0.09725840630771199, 0.09725840630771199, 0.09725840630771199, 0.9595662222866589, 0.9595662222866589, 0.9595662222866589, 0.9673560791042823, 0.9673560791042823, 0.9673560791042823, 0.9606091377835202, 0.9606091377835202, 0.9606091377835202, 0.44541423741224095, 0.44541423741224095, 0.44541423741224095, 0.6393341801196917, 0.6393341801196917, 0.6393341801196917, 0.3065684551463046, 0.3065684551463046, 0.3065684551463046, 0.22348657664814486, 0.22348657664814486, 0.22348657664814486, 0.18196734298606376, 0.18196734298606376, 0.18196734298606376, 0.8119665515089636, 0.8119665515089636, 0.8119665515089636, 0.20169297701495048, 0.20169297701495048, 0.20169297701495048, 0.2826117470179649, 0.2826117470179649, 0.2826117470179649, 0.22870393915869025, 0.22870393915869025, 0.22870393915869025, 0.13279497546010588, 0.13279497546010588, 0.13279497546010588, 0.4762314499959519, 0.4762314499959519, 0.4762314499959519, 0.29833661517221755, 0.29833661517221755, 0.29833661517221755, 0.0348825306920999, 0.0348825306920999, 0.0348825306920999, 0.12301490003228888, 0.12301490003228888, 0.12301490003228888, 0.119290601056676, 0.119290601056676, 0.119290601056676, 0.26150794936121635, 0.26150794936121635, 0.26150794936121635, 0.23241433465679395, 0.23241433465679395, 0.23241433465679395, 0.18875934620223456, 0.18875934620223456, 0.18875934620223456, 0.06242717770897266, 0.06242717770897266, 0.06242717770897266, 0.09081513414941977, 0.09081513414941977, 0.09081513414941977, 0.10308829500899852, 0.10308829500899852, 0.10308829500899852, 0.3255365776170738, 0.3255365776170738, 0.3255365776170738, 0.27007077988043415, 0.27007077988043415, 0.27007077988043415, 0.04720371990381156, 0.04720371990381156, 0.04720371990381156, 0.5318102203805126, 0.5318102203805126, 0.5318102203805126, 0.6383411109126751, 0.6383411109126751, 0.6383411109126751, 0.5332834013872401, 0.5332834013872401, 0.5332834013872401, 0.101938097711883, 0.101938097711883, 0.101938097711883, 0.10959917257686935, 0.10959917257686935, 0.10959917257686935, 0.11953986352959767, 0.11953986352959767, 0.11953986352959767, 0.24808948199254832, 0.24808948199254832, 0.24808948199254832, 0.29069195632045985, 0.29069195632045985, 0.29069195632045985, 0.18140198568459587, 0.18140198568459587, 0.18140198568459587, 0.32843347823258695, 0.32843347823258695, 0.32843347823258695, 0.31733866994912363, 0.31733866994912363, 0.31733866994912363, 0.33672839746361594, 0.33672839746361594, 0.33672839746361594, 0.28568948126679716, 0.28568948126679716, 0.28568948126679716, 0.2787215549650719, 0.2787215549650719, 0.2787215549650719, 0.25176203617106807, 0.25176203617106807, 0.25176203617106807, 0.2510933614778158, 0.2510933614778158, 0.2510933614778158, 0.21553448560276123, 0.21553448560276123, 0.21553448560276123, 0.20567741735298672, 0.20567741735298672, 0.20567741735298672, 0.20723617850046627, 0.20723617850046627, 0.20723617850046627, 0.22130770806875877, 0.22130770806875877, 0.22130770806875877, 0.23877672452905574, 0.23877672452905574, 0.23877672452905574, 0.8769231340600221, 0.8769231340600221, 0.8769231340600221, 0.6542265789452189, 0.6542265789452189, 0.6542265789452189, 0.8646185726891673, 0.8646185726891673, 0.8646185726891673, 0.16864721964372853, 0.16864721964372853, 0.16864721964372853, 0.21089245001198031, 0.21089245001198031, 0.21089245001198031, 0.8259829126414608, 0.8259829126414608, 0.8259829126414608, 0.21075477723291647, 0.21075477723291647, 0.21075477723291647, 0.23239571572821527, 0.23239571572821527, 0.23239571572821527, 0.19051862686717558, 0.19051862686717558, 0.19051862686717558, 0.08957660571632609, 0.08957660571632609, 0.08957660571632609, 0.09539680660201244, 0.09539680660201244, 0.09539680660201244, 0.09622406611869994, 0.09622406611869994, 0.09622406611869994]}, "mutation_prompt": null}
{"id": "4ae8f60e-d3c2-4875-aa54-93528dd9ee8c", "solution": "import numpy as np\n\nclass QuantumEnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6\n        self.cognitive = 1.4\n        self.social = 1.9\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.1\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.1\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedPSO", "description": "Quantum-Enhanced Particle Swarm Optimization with adaptive mutation and hierarchical learning strategies.", "configspace": "", "generation": 74, "fitness": 0.3354034861119072, "feedback": "The algorithm QuantumEnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7906179252829963, 0.7906179252829963, 0.7906179252829963, 0.7805145091742801, 0.7805145091742801, 0.7805145091742801, 0.8023350000436981, 0.8023350000436981, 0.8023350000436981, 0.06964531623330894, 0.06964531623330894, 0.06964531623330894, 0.4886588939008447, 0.4886588939008447, 0.4886588939008447, 0.4898038611163541, 0.4898038611163541, 0.4898038611163541, 0.1115064159024689, 0.1115064159024689, 0.1115064159024689, 0.11170792750438763, 0.11170792750438763, 0.11170792750438763, 0.11022655137651205, 0.11022655137651205, 0.11022655137651205, 0.05497725619728977, 0.05497725619728977, 0.05497725619728977, 0.07812628388236353, 0.07812628388236353, 0.07812628388236353, 0.06576589719374282, 0.06576589719374282, 0.06576589719374282, 0.946720401259497, 0.946720401259497, 0.946720401259497, 0.9313012620130782, 0.9313012620130782, 0.9313012620130782, 0.9470363595635507, 0.9470363595635507, 0.9470363595635507, 0.5700792923045536, 0.5700792923045536, 0.5700792923045536, 0.5475171386443036, 0.5475171386443036, 0.5475171386443036, 0.6186976294162756, 0.6186976294162756, 0.6186976294162756, 0.19607741519476007, 0.19607741519476007, 0.19607741519476007, 0.19326082223083618, 0.19326082223083618, 0.19326082223083618, 0.8275785852371396, 0.8275785852371396, 0.8275785852371396, 0.13238618504391142, 0.13238618504391142, 0.13238618504391142, 0.3700961467775248, 0.3700961467775248, 0.3700961467775248, 0.4652851273154478, 0.4652851273154478, 0.4652851273154478, 0.22413183031104233, 0.22413183031104233, 0.22413183031104233, 0.5522198209779173, 0.5522198209779173, 0.5522198209779173, 0.41592685794234285, 0.41592685794234285, 0.41592685794234285, 0.1590492064613962, 0.1590492064613962, 0.1590492064613962, 0.1810594424751718, 0.1810594424751718, 0.1810594424751718, 0.056636289077090396, 0.056636289077090396, 0.056636289077090396, 0.3115383659039741, 0.3115383659039741, 0.3115383659039741, 0.27741926334396205, 0.27741926334396205, 0.27741926334396205, 0.11029464336843453, 0.11029464336843453, 0.11029464336843453, 0.05931441939728954, 0.05931441939728954, 0.05931441939728954, 0.08255554363089757, 0.08255554363089757, 0.08255554363089757, 0.14645922199732908, 0.14645922199732908, 0.14645922199732908, 0.13963925432275515, 0.13963925432275515, 0.13963925432275515, 0.25981503096770453, 0.25981503096770453, 0.25981503096770453, 0.30078836483759286, 0.30078836483759286, 0.30078836483759286, 0.6580515322398119, 0.6580515322398119, 0.6580515322398119, 0.6305067546177835, 0.6305067546177835, 0.6305067546177835, 0.7108353891119708, 0.7108353891119708, 0.7108353891119708, 0.11037292758891959, 0.11037292758891959, 0.11037292758891959, 0.11024969695370623, 0.11024969695370623, 0.11024969695370623, 0.10540213361840378, 0.10540213361840378, 0.10540213361840378, 0.14424742513085198, 0.14424742513085198, 0.14424742513085198, 0.32944413293432895, 0.32944413293432895, 0.32944413293432895, 0.2547320834815625, 0.2547320834815625, 0.2547320834815625, 0.37194829222469816, 0.37194829222469816, 0.37194829222469816, 0.3585754059390591, 0.3585754059390591, 0.3585754059390591, 0.3102233342207573, 0.3102233342207573, 0.3102233342207573, 0.20188550599579635, 0.20188550599579635, 0.20188550599579635, 0.26759454822242124, 0.26759454822242124, 0.26759454822242124, 0.22172748020521982, 0.22172748020521982, 0.22172748020521982, 0.2485513505792667, 0.2485513505792667, 0.2485513505792667, 0.2119804410028261, 0.2119804410028261, 0.2119804410028261, 0.2763205255700083, 0.2763205255700083, 0.2763205255700083, 0.20691224605594183, 0.20691224605594183, 0.20691224605594183, 0.19721355044287825, 0.19721355044287825, 0.19721355044287825, 0.18609494576550023, 0.18609494576550023, 0.18609494576550023, 0.8918286291840566, 0.8918286291840566, 0.8918286291840566, 0.15812070879612916, 0.15812070879612916, 0.15812070879612916, 0.8857360665548476, 0.8857360665548476, 0.8857360665548476, 0.16862990952320656, 0.16862990952320656, 0.16862990952320656, 0.2120753935082953, 0.2120753935082953, 0.2120753935082953, 0.8417557647532348, 0.8417557647532348, 0.8417557647532348, 0.17918329193421667, 0.17918329193421667, 0.17918329193421667, 0.2207032195417341, 0.2207032195417341, 0.2207032195417341, 0.2208143803766739, 0.2208143803766739, 0.2208143803766739, 0.08124151697564796, 0.08124151697564796, 0.08124151697564796, 0.10948621527473135, 0.10948621527473135, 0.10948621527473135, 0.08983644390880585, 0.08983644390880585, 0.08983644390880585]}, "mutation_prompt": null}
{"id": "724e6266-e929-4350-992e-988eb0cdefdd", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and elite particle reinforcement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8321186788849009, 0.8321186788849009, 0.8321186788849009, 0.8077373703110324, 0.8077373703110324, 0.8077373703110324, 0.8230672540546263, 0.8230672540546263, 0.8230672540546263, 0.5116669950722281, 0.5116669950722281, 0.5116669950722281, 0.5661560136612218, 0.5661560136612218, 0.5661560136612218, 0.6113058189557582, 0.6113058189557582, 0.6113058189557582, 0.15980213110663188, 0.15980213110663188, 0.15980213110663188, 0.15836379454087035, 0.15836379454087035, 0.15836379454087035, 0.10700891265479351, 0.10700891265479351, 0.10700891265479351, 0.12732956032599918, 0.12732956032599918, 0.12732956032599918, 0.06905195301446476, 0.06905195301446476, 0.06905195301446476, 0.1345013716819694, 0.1345013716819694, 0.1345013716819694, 0.9591111998970985, 0.9591111998970985, 0.9591111998970985, 0.9585593447047763, 0.9585593447047763, 0.9585593447047763, 0.9574263685928593, 0.9574263685928593, 0.9574263685928593, 0.6364651002009667, 0.6364651002009667, 0.6364651002009667, 0.6951144370755298, 0.6951144370755298, 0.6951144370755298, 0.6686499429390589, 0.6686499429390589, 0.6686499429390589, 0.8100450310483559, 0.8100450310483559, 0.8100450310483559, 0.2191433915634472, 0.2191433915634472, 0.2191433915634472, 0.35535998298566196, 0.35535998298566196, 0.35535998298566196, 0.5982796272612709, 0.5982796272612709, 0.5982796272612709, 0.6415045173467162, 0.6415045173467162, 0.6415045173467162, 0.6398000470576843, 0.6398000470576843, 0.6398000470576843, 0.5428928671013161, 0.5428928671013161, 0.5428928671013161, 0.5642790632999215, 0.5642790632999215, 0.5642790632999215, 0.6524933627785994, 0.6524933627785994, 0.6524933627785994, 0.3320409711584029, 0.3320409711584029, 0.3320409711584029, 0.4064992272210587, 0.4064992272210587, 0.4064992272210587, 0.0032715883739258267, 0.0032715883739258267, 0.0032715883739258267, 0.5339891197626435, 0.5339891197626435, 0.5339891197626435, 0.17748082363632034, 0.17748082363632034, 0.17748082363632034, 0.6205554758644007, 0.6205554758644007, 0.6205554758644007, 0.12699739198808058, 0.12699739198808058, 0.12699739198808058, 0.20264865332135862, 0.20264865332135862, 0.20264865332135862, 0.10359900711219672, 0.10359900711219672, 0.10359900711219672, 0.17336943788479298, 0.17336943788479298, 0.17336943788479298, 0.03797532713121943, 0.03797532713121943, 0.03797532713121943, 0.055864185337872185, 0.055864185337872185, 0.055864185337872185, 0.7251167159474545, 0.7251167159474545, 0.7251167159474545, 0.6908898067973139, 0.6908898067973139, 0.6908898067973139, 0.7367565470019714, 0.7367565470019714, 0.7367565470019714, 0.13749820551805536, 0.13749820551805536, 0.13749820551805536, 0.1826801551718401, 0.1826801551718401, 0.1826801551718401, 0.12066259163666926, 0.12066259163666926, 0.12066259163666926, 0.202893140333395, 0.202893140333395, 0.202893140333395, 0.2314563184270485, 0.2314563184270485, 0.2314563184270485, 0.38954346630555825, 0.38954346630555825, 0.38954346630555825, 0.37502158564298227, 0.37502158564298227, 0.37502158564298227, 0.3059459622620033, 0.3059459622620033, 0.3059459622620033, 0.48969630406392073, 0.48969630406392073, 0.48969630406392073, 0.2480830354911986, 0.2480830354911986, 0.2480830354911986, 0.443672575036419, 0.443672575036419, 0.443672575036419, 0.1644781920745234, 0.1644781920745234, 0.1644781920745234, 0.2843285752980297, 0.2843285752980297, 0.2843285752980297, 0.22353751179202908, 0.22353751179202908, 0.22353751179202908, 0.23127309941644802, 0.23127309941644802, 0.23127309941644802, 0.7425618916612338, 0.7425618916612338, 0.7425618916612338, 0.20694529613164991, 0.20694529613164991, 0.20694529613164991, 0.19579955627160162, 0.19579955627160162, 0.19579955627160162, 0.9081391265722403, 0.9081391265722403, 0.9081391265722403, 0.15891442399030364, 0.15891442399030364, 0.15891442399030364, 0.17133278472820113, 0.17133278472820113, 0.17133278472820113, 0.20935471733507016, 0.20935471733507016, 0.20935471733507016, 0.21098447324252212, 0.21098447324252212, 0.21098447324252212, 0.8094593742775736, 0.8094593742775736, 0.8094593742775736, 0.2177271797225232, 0.2177271797225232, 0.2177271797225232, 0.24910938126412285, 0.24910938126412285, 0.24910938126412285, 0.2474734376703408, 0.2474734376703408, 0.2474734376703408, 0.09066702526169679, 0.09066702526169679, 0.09066702526169679, 0.08767401619723092, 0.08767401619723092, 0.08767401619723092, 0.09458529381324443, 0.09458529381324443, 0.09458529381324443]}, "mutation_prompt": null}
{"id": "53438a3d-2e8b-491c-83f5-767b886c11a6", "solution": "import numpy as np\n\nclass QuantumInspiredPSOwithADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # increased number of particles for better exploration\n        self.inertia = 0.6  # slightly higher inertia for improved exploration\n        self.cognitive = 1.5  # increased cognitive attraction to enhance personal learning\n        self.social = 1.8  # reduced social component to balance global exploration\n        self.quantum_prob = 0.2  # slightly decreased to balance exploration-exploitation\n        self.elite_quantum_prob = 0.2  # increased probability for elite particles\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # increased max velocity for faster convergence\n        self.de_mutation_factor = 0.9  # increased mutation factor for better diversity\n        self.de_crossover_rate = 0.8  # slightly reduced crossover rate for conservative changes\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumInspiredPSOwithADE", "description": "Quantum-Inspired Particle Swarm Optimization with Adaptive Differential Evolution for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": 0.3246596954446322, "feedback": "The algorithm QuantumInspiredPSOwithADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7684882727043431, 0.7684882727043431, 0.7684882727043431, 0.7409223872765628, 0.7409223872765628, 0.7409223872765628, 0.7524781573351713, 0.7524781573351713, 0.7524781573351713, 0.3349877747940976, 0.3349877747940976, 0.3349877747940976, 0.3327756238230204, 0.3327756238230204, 0.3327756238230204, 0.39993122666810066, 0.39993122666810066, 0.39993122666810066, 0.13480821757179406, 0.13480821757179406, 0.13480821757179406, 0.10688261649009123, 0.10688261649009123, 0.10688261649009123, 0.11412782283801515, 0.11412782283801515, 0.11412782283801515, 0.08890250346360207, 0.08890250346360207, 0.08890250346360207, 0.1027956627406007, 0.1027956627406007, 0.1027956627406007, 0.06771116040583491, 0.06771116040583491, 0.06771116040583491, 0.9664966604574884, 0.9664966604574884, 0.9664966604574884, 0.9654985425872988, 0.9654985425872988, 0.9654985425872988, 0.9627141303117411, 0.9627141303117411, 0.9627141303117411, 0.4783236105508595, 0.4783236105508595, 0.4783236105508595, 0.4179588409302327, 0.4179588409302327, 0.4179588409302327, 0.5003201834938911, 0.5003201834938911, 0.5003201834938911, 0.7613844422627909, 0.7613844422627909, 0.7613844422627909, 0.7420838841886641, 0.7420838841886641, 0.7420838841886641, 0.815920650456795, 0.815920650456795, 0.815920650456795, 0.4520391954212909, 0.4520391954212909, 0.4520391954212909, 0.3671087831836295, 0.3671087831836295, 0.3671087831836295, 0.25353873830332163, 0.25353873830332163, 0.25353873830332163, 0.3913664688667542, 0.3913664688667542, 0.3913664688667542, 0.30003252946756453, 0.30003252946756453, 0.30003252946756453, 0.12969949714444096, 0.12969949714444096, 0.12969949714444096, 0.22320301346141247, 0.22320301346141247, 0.22320301346141247, 0.1746623519432816, 0.1746623519432816, 0.1746623519432816, 0.2473561134480946, 0.2473561134480946, 0.2473561134480946, 0.34739825061231633, 0.34739825061231633, 0.34739825061231633, 0.13843512020234283, 0.13843512020234283, 0.13843512020234283, 0.14579689939213492, 0.14579689939213492, 0.14579689939213492, 0.06761305054297295, 0.06761305054297295, 0.06761305054297295, 0.09313293295000113, 0.09313293295000113, 0.09313293295000113, 0.11055676191667829, 0.11055676191667829, 0.11055676191667829, 0.1888226080995703, 0.1888226080995703, 0.1888226080995703, 0.035349012102997235, 0.035349012102997235, 0.035349012102997235, 0.2786476205557348, 0.2786476205557348, 0.2786476205557348, 0.6108428978494267, 0.6108428978494267, 0.6108428978494267, 0.5617269760821701, 0.5617269760821701, 0.5617269760821701, 0.5909321095925228, 0.5909321095925228, 0.5909321095925228, 0.10239365054213723, 0.10239365054213723, 0.10239365054213723, 0.10907387710038619, 0.10907387710038619, 0.10907387710038619, 0.10722426389285977, 0.10722426389285977, 0.10722426389285977, 0.2535652709372096, 0.2535652709372096, 0.2535652709372096, 0.23696825587070391, 0.23696825587070391, 0.23696825587070391, 0.3030130492385108, 0.3030130492385108, 0.3030130492385108, 0.32399032720136145, 0.32399032720136145, 0.32399032720136145, 0.38056265741410844, 0.38056265741410844, 0.38056265741410844, 0.32883430473265196, 0.32883430473265196, 0.32883430473265196, 0.14670072533361767, 0.14670072533361767, 0.14670072533361767, 0.22107152660147444, 0.22107152660147444, 0.22107152660147444, 0.12350594749465726, 0.12350594749465726, 0.12350594749465726, 0.22579690219638482, 0.22579690219638482, 0.22579690219638482, 0.2328887570328967, 0.2328887570328967, 0.2328887570328967, 0.22221932001310885, 0.22221932001310885, 0.22221932001310885, 0.19555444736128524, 0.19555444736128524, 0.19555444736128524, 0.18661788486463138, 0.18661788486463138, 0.18661788486463138, 0.21853036551195648, 0.21853036551195648, 0.21853036551195648, 0.874204752015861, 0.874204752015861, 0.874204752015861, 0.15842363126472647, 0.15842363126472647, 0.15842363126472647, 0.16954663041231122, 0.16954663041231122, 0.16954663041231122, 0.7638580666686821, 0.7638580666686821, 0.7638580666686821, 0.21087301516283607, 0.21087301516283607, 0.21087301516283607, 0.15596915888315777, 0.15596915888315777, 0.15596915888315777, 0.17929441850854233, 0.17929441850854233, 0.17929441850854233, 0.19981970216807698, 0.19981970216807698, 0.19981970216807698, 0.1850171050762487, 0.1850171050762487, 0.1850171050762487, 0.09308322857541551, 0.09308322857541551, 0.09308322857541551, 0.08510073457527356, 0.08510073457527356, 0.08510073457527356, 0.1180227928727916, 0.1180227928727916, 0.1180227928727916]}, "mutation_prompt": null}
{"id": "d6b4553a-9cf0-484a-a389-0c84c6a9e851", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.6\n        self.cognitive = 1.4\n        self.social = 1.9\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm and Differential Evolution with adaptive diversity and elite learning strategy.", "configspace": "", "generation": 77, "fitness": 0.3205106885437087, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.722686751087579, 0.722686751087579, 0.722686751087579, 0.7585230374887144, 0.7585230374887144, 0.7585230374887144, 0.7382584498338864, 0.7382584498338864, 0.7382584498338864, 0.2172545180566554, 0.2172545180566554, 0.2172545180566554, 0.3813089354706791, 0.3813089354706791, 0.3813089354706791, 0.33062126895750177, 0.33062126895750177, 0.33062126895750177, 0.10808409731110313, 0.10808409731110313, 0.10808409731110313, 0.14445613208446206, 0.14445613208446206, 0.14445613208446206, 0.11190711891740679, 0.11190711891740679, 0.11190711891740679, 0.10025594115958769, 0.10025594115958769, 0.10025594115958769, 0.0905368653380314, 0.0905368653380314, 0.0905368653380314, 0.1305533716727605, 0.1305533716727605, 0.1305533716727605, 0.9633626965422721, 0.9633626965422721, 0.9633626965422721, 0.9701283210060024, 0.9701283210060024, 0.9701283210060024, 0.9641182975395071, 0.9641182975395071, 0.9641182975395071, 0.4503731421999768, 0.4503731421999768, 0.4503731421999768, 0.47473043294094175, 0.47473043294094175, 0.47473043294094175, 0.45416108286060186, 0.45416108286060186, 0.45416108286060186, 0.740993911719084, 0.740993911719084, 0.740993911719084, 0.21437267095109425, 0.21437267095109425, 0.21437267095109425, 0.7960377469950822, 0.7960377469950822, 0.7960377469950822, 0.36775415526258337, 0.36775415526258337, 0.36775415526258337, 0.3359061630289544, 0.3359061630289544, 0.3359061630289544, 0.32348513990075856, 0.32348513990075856, 0.32348513990075856, 0.47446859000232067, 0.47446859000232067, 0.47446859000232067, 0.3153115565932575, 0.3153115565932575, 0.3153115565932575, 0.27172226475162853, 0.27172226475162853, 0.27172226475162853, 0.0531018489221331, 0.0531018489221331, 0.0531018489221331, 0.18783846867055043, 0.18783846867055043, 0.18783846867055043, 0.33557256774304556, 0.33557256774304556, 0.33557256774304556, 0.3755099438762687, 0.3755099438762687, 0.3755099438762687, 0.2354587555028964, 0.2354587555028964, 0.2354587555028964, 0.32740397237334395, 0.32740397237334395, 0.32740397237334395, 0.09834176315822474, 0.09834176315822474, 0.09834176315822474, 0.14213837994897016, 0.14213837994897016, 0.14213837994897016, 0.19782430933842288, 0.19782430933842288, 0.19782430933842288, 0.11794795693761773, 0.11794795693761773, 0.11794795693761773, 0.14146969521961583, 0.14146969521961583, 0.14146969521961583, 0.24774662119039892, 0.24774662119039892, 0.24774662119039892, 0.6012484788424217, 0.6012484788424217, 0.6012484788424217, 0.5761052649915468, 0.5761052649915468, 0.5761052649915468, 0.5667919566936375, 0.5667919566936375, 0.5667919566936375, 0.1082795851399545, 0.1082795851399545, 0.1082795851399545, 0.11375355766168072, 0.11375355766168072, 0.11375355766168072, 0.1152361552214548, 0.1152361552214548, 0.1152361552214548, 0.2388636281658243, 0.2388636281658243, 0.2388636281658243, 0.22841595003069204, 0.22841595003069204, 0.22841595003069204, 0.37120949742373954, 0.37120949742373954, 0.37120949742373954, 0.3763642470048443, 0.3763642470048443, 0.3763642470048443, 0.4579054687191486, 0.4579054687191486, 0.4579054687191486, 0.3944144296190065, 0.3944144296190065, 0.3944144296190065, 0.2202595758738819, 0.2202595758738819, 0.2202595758738819, 0.2327707188655479, 0.2327707188655479, 0.2327707188655479, 0.13550251629536758, 0.13550251629536758, 0.13550251629536758, 0.19512527970458904, 0.19512527970458904, 0.19512527970458904, 0.2284684993836127, 0.2284684993836127, 0.2284684993836127, 0.20139051822574405, 0.20139051822574405, 0.20139051822574405, 0.22492847351228107, 0.22492847351228107, 0.22492847351228107, 0.2020205312935437, 0.2020205312935437, 0.2020205312935437, 0.18947813585110784, 0.18947813585110784, 0.18947813585110784, 0.8700224128449341, 0.8700224128449341, 0.8700224128449341, 0.15835249341125712, 0.15835249341125712, 0.15835249341125712, 0.16944808164589853, 0.16944808164589853, 0.16944808164589853, 0.20677411205260865, 0.20677411205260865, 0.20677411205260865, 0.21047448335593044, 0.21047448335593044, 0.21047448335593044, 0.15531758065280066, 0.15531758065280066, 0.15531758065280066, 0.18484101479265125, 0.18484101479265125, 0.18484101479265125, 0.1915873691253802, 0.1915873691253802, 0.1915873691253802, 0.22488298796592254, 0.22488298796592254, 0.22488298796592254, 0.10218014007465259, 0.10218014007465259, 0.10218014007465259, 0.0896989677532607, 0.0896989677532607, 0.0896989677532607, 0.12293052039818231, 0.12293052039818231, 0.12293052039818231]}, "mutation_prompt": null}
{"id": "f4f45771-f33a-4725-ba75-8484009e780d", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Slightly increased inertia for enhanced exploration\n        self.cognitive = 1.5  # Enhanced cognitive factor for better personal exploration\n        self.social = 2.1  # Increased social factor for improved global exploration\n        self.quantum_prob = 0.3  # Adjusted probability for quantum update\n        self.elite_quantum_prob = 0.1  # Reduced probability for elite quantum update\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.25  # Increased max velocity for faster exploration\n        self.de_mutation_factor = 0.9  # Enhanced mutation factor for stronger mutation\n        self.de_crossover_rate = 0.95  # Increased crossover rate for more aggressive trial solutions\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveDSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization with dynamic strategy selection for improved convergence.", "configspace": "", "generation": 78, "fitness": 0.2806821253411157, "feedback": "The algorithm QuantumEnhancedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.642809801213462, 0.642809801213462, 0.642809801213462, 0.6396157594759051, 0.6396157594759051, 0.6396157594759051, 0.6559158724906787, 0.6559158724906787, 0.6559158724906787, 0.1607037362346707, 0.1607037362346707, 0.1607037362346707, 0.14149799796910578, 0.14149799796910578, 0.14149799796910578, 0.19845681664653492, 0.19845681664653492, 0.19845681664653492, 0.10761974263512308, 0.10761974263512308, 0.10761974263512308, 0.22236671680746833, 0.22236671680746833, 0.22236671680746833, 0.09816234229494403, 0.09816234229494403, 0.09816234229494403, 0.10191048187390428, 0.10191048187390428, 0.10191048187390428, 0.08169787180601173, 0.08169787180601173, 0.08169787180601173, 0.10038737759832761, 0.10038737759832761, 0.10038737759832761, 0.9529901427703413, 0.9529901427703413, 0.9529901427703413, 0.9843512645356002, 0.9843512645356002, 0.9843512645356002, 0.9524360824154348, 0.9524360824154348, 0.9524360824154348, 0.3887151151444288, 0.3887151151444288, 0.3887151151444288, 0.32513367595881215, 0.32513367595881215, 0.32513367595881215, 0.4004979108474699, 0.4004979108474699, 0.4004979108474699, 0.7166319029032122, 0.7166319029032122, 0.7166319029032122, 0.18812462324598023, 0.18812462324598023, 0.18812462324598023, 0.5939778837135918, 0.5939778837135918, 0.5939778837135918, 0.21345390854528923, 0.21345390854528923, 0.21345390854528923, 0.23099652779433977, 0.23099652779433977, 0.23099652779433977, 0.23797811947505454, 0.23797811947505454, 0.23797811947505454, 0.12660908352864297, 0.12660908352864297, 0.12660908352864297, 0.25442088111770467, 0.25442088111770467, 0.25442088111770467, 0.12286344237792401, 0.12286344237792401, 0.12286344237792401, 0.14528735122353575, 0.14528735122353575, 0.14528735122353575, 0.026900232782126277, 0.026900232782126277, 0.026900232782126277, 0.05501278710111879, 0.05501278710111879, 0.05501278710111879, 0.12895764426326517, 0.12895764426326517, 0.12895764426326517, 0.1419932472890143, 0.1419932472890143, 0.1419932472890143, 0.15945981142267174, 0.15945981142267174, 0.15945981142267174, 0.1271321583389845, 0.1271321583389845, 0.1271321583389845, 0.059604530321430094, 0.059604530321430094, 0.059604530321430094, 0.07560216432807809, 0.07560216432807809, 0.07560216432807809, 0.15854794887125878, 0.15854794887125878, 0.15854794887125878, 0.03512933798964146, 0.03512933798964146, 0.03512933798964146, 0.07261649434180584, 0.07261649434180584, 0.07261649434180584, 0.5372046335326273, 0.5372046335326273, 0.5372046335326273, 0.5237603235167712, 0.5237603235167712, 0.5237603235167712, 0.5224821556277365, 0.5224821556277365, 0.5224821556277365, 0.13278494122881368, 0.13278494122881368, 0.13278494122881368, 0.13085732048939314, 0.13085732048939314, 0.13085732048939314, 0.09922974423585951, 0.09922974423585951, 0.09922974423585951, 0.22413007127636497, 0.22413007127636497, 0.22413007127636497, 0.17785590288545206, 0.17785590288545206, 0.17785590288545206, 0.30287688694560333, 0.30287688694560333, 0.30287688694560333, 0.33053335586539556, 0.33053335586539556, 0.33053335586539556, 0.37448792150156973, 0.37448792150156973, 0.37448792150156973, 0.2618968698104178, 0.2618968698104178, 0.2618968698104178, 0.21407325541970468, 0.21407325541970468, 0.21407325541970468, 0.18243704716984388, 0.18243704716984388, 0.18243704716984388, 0.1700828462152798, 0.1700828462152798, 0.1700828462152798, 0.2102910857795015, 0.2102910857795015, 0.2102910857795015, 0.18842926647019498, 0.18842926647019498, 0.18842926647019498, 0.2113018670617416, 0.2113018670617416, 0.2113018670617416, 0.19450538819989116, 0.19450538819989116, 0.19450538819989116, 0.18739067855191638, 0.18739067855191638, 0.18739067855191638, 0.208967705637652, 0.208967705637652, 0.208967705637652, 0.8510147826728847, 0.8510147826728847, 0.8510147826728847, 0.8008028832742312, 0.8008028832742312, 0.8008028832742312, 0.17440648523143976, 0.17440648523143976, 0.17440648523143976, 0.7952968079504231, 0.7952968079504231, 0.7952968079504231, 0.2096828106895251, 0.2096828106895251, 0.2096828106895251, 0.1550236069455464, 0.1550236069455464, 0.1550236069455464, 0.18270847338610718, 0.18270847338610718, 0.18270847338610718, 0.1707850619142448, 0.1707850619142448, 0.1707850619142448, 0.19861803382542254, 0.19861803382542254, 0.19861803382542254, 0.08378812675211467, 0.08378812675211467, 0.08378812675211467, 0.08285748265708859, 0.08285748265708859, 0.08285748265708859, 0.09198041214667396, 0.09198041214667396, 0.09198041214667396]}, "mutation_prompt": null}
{"id": "0dde69b6-f4ef-482c-abab-d78712c1980f", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 1.8\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 0.2, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumInspiredDSO", "description": "Adaptive Quantum-Inspired Differential Swarm Optimization with dynamic learning rates and local search intensification.", "configspace": "", "generation": 79, "fitness": 0.27198405771690953, "feedback": "The algorithm AdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6957415613996172, 0.6957415613996172, 0.6957415613996172, 0.6641218474338382, 0.6641218474338382, 0.6641218474338382, 0.6588647893817171, 0.6588647893817171, 0.6588647893817171, 0.09524637221149312, 0.09524637221149312, 0.09524637221149312, 0.14170902442506628, 0.14170902442506628, 0.14170902442506628, 0.19289720126728216, 0.19289720126728216, 0.19289720126728216, 0.11112300292814037, 0.11112300292814037, 0.11112300292814037, 0.08648672817624847, 0.08648672817624847, 0.08648672817624847, 0.14123559417460385, 0.14123559417460385, 0.14123559417460385, 0.09907803328811737, 0.09907803328811737, 0.09907803328811737, 0.11354265187353307, 0.11354265187353307, 0.11354265187353307, 0.1079530089344527, 0.1079530089344527, 0.1079530089344527, 0.9685653236262446, 0.9685653236262446, 0.9685653236262446, 0.969688232592483, 0.969688232592483, 0.969688232592483, 0.9695218363436965, 0.9695218363436965, 0.9695218363436965, 0.4137144172209207, 0.4137144172209207, 0.4137144172209207, 0.39163759051160085, 0.39163759051160085, 0.39163759051160085, 0.40723003256822743, 0.40723003256822743, 0.40723003256822743, 0.16880493795383988, 0.16880493795383988, 0.16880493795383988, 0.1605977789719646, 0.1605977789719646, 0.1605977789719646, 0.18183802665282356, 0.18183802665282356, 0.18183802665282356, 0.374022528172242, 0.374022528172242, 0.374022528172242, 0.2396659732974602, 0.2396659732974602, 0.2396659732974602, 0.28098197935577884, 0.28098197935577884, 0.28098197935577884, 0.18258561770756865, 0.18258561770756865, 0.18258561770756865, 0.23786253527045298, 0.23786253527045298, 0.23786253527045298, 0.26934014290185937, 0.26934014290185937, 0.26934014290185937, 0.11296873013893949, 0.11296873013893949, 0.11296873013893949, 0.10957147405154832, 0.10957147405154832, 0.10957147405154832, 0.1132577331434681, 0.1132577331434681, 0.1132577331434681, 0.24756394706972062, 0.24756394706972062, 0.24756394706972062, 0.053751193556397237, 0.053751193556397237, 0.053751193556397237, 0.15272929167700988, 0.15272929167700988, 0.15272929167700988, 0.03390363750819814, 0.03390363750819814, 0.03390363750819814, 0.18627844137582517, 0.18627844137582517, 0.18627844137582517, 0.051637687606313376, 0.051637687606313376, 0.051637687606313376, 0.15607696308989694, 0.15607696308989694, 0.15607696308989694, 0.16807413935934146, 0.16807413935934146, 0.16807413935934146, 0.05448677384875156, 0.05448677384875156, 0.05448677384875156, 0.5246911832201524, 0.5246911832201524, 0.5246911832201524, 0.493042792895681, 0.493042792895681, 0.493042792895681, 0.5231837302329092, 0.5231837302329092, 0.5231837302329092, 0.11531893358466072, 0.11531893358466072, 0.11531893358466072, 0.1088860874880222, 0.1088860874880222, 0.1088860874880222, 0.11215036681139301, 0.11215036681139301, 0.11215036681139301, 0.3507213319057486, 0.3507213319057486, 0.3507213319057486, 0.24926203037017858, 0.24926203037017858, 0.24926203037017858, 0.31838405249489465, 0.31838405249489465, 0.31838405249489465, 0.3469774120736834, 0.3469774120736834, 0.3469774120736834, 0.3006803990435337, 0.3006803990435337, 0.3006803990435337, 0.30928748473717604, 0.30928748473717604, 0.30928748473717604, 0.2078250377642299, 0.2078250377642299, 0.2078250377642299, 0.23628659167424992, 0.23628659167424992, 0.23628659167424992, 0.13783349604156514, 0.13783349604156514, 0.13783349604156514, 0.22180843233906367, 0.22180843233906367, 0.22180843233906367, 0.2178021783093792, 0.2178021783093792, 0.2178021783093792, 0.23677999525620774, 0.23677999525620774, 0.23677999525620774, 0.19562747376897882, 0.19562747376897882, 0.19562747376897882, 0.19624503748382083, 0.19624503748382083, 0.19624503748382083, 0.19874529974142174, 0.19874529974142174, 0.19874529974142174, 0.8401836491314743, 0.8401836491314743, 0.8401836491314743, 0.7742217764599232, 0.7742217764599232, 0.7742217764599232, 0.1680137077746745, 0.1680137077746745, 0.1680137077746745, 0.16524170034967356, 0.16524170034967356, 0.16524170034967356, 0.21142134581787608, 0.21142134581787608, 0.21142134581787608, 0.155324564481643, 0.155324564481643, 0.155324564481643, 0.18633468542521892, 0.18633468542521892, 0.18633468542521892, 0.21517723718294968, 0.21517723718294968, 0.21517723718294968, 0.18311501100437777, 0.18311501100437777, 0.18311501100437777, 0.09207377166867048, 0.09207377166867048, 0.09207377166867048, 0.09650335648543662, 0.09650335648543662, 0.09650335648543662, 0.1293452215319374, 0.1293452215319374, 0.1293452215319374]}, "mutation_prompt": null}
{"id": "4882fafd-7c12-45ba-86ed-e8f61088ef1f", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithAdaptiveInertia:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia_max = 0.9\n        self.inertia_min = 0.4\n        self.cognitive = 1.4\n        self.social = 2.1\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia = self.inertia_max - ((self.inertia_max - self.inertia_min) * (eval_count / self.budget))\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 1, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumInspiredDEWithAdaptiveInertia", "description": "Quantum-Inspired Differential Evolution with Adaptive Inertia and Elite Quantum Swarming for enhanced search efficiency.", "configspace": "", "generation": 80, "fitness": 0.2906633699928666, "feedback": "The algorithm QuantumInspiredDEWithAdaptiveInertia got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6293517403576648, 0.6293517403576648, 0.6293517403576648, 0.6373823482777261, 0.6373823482777261, 0.6373823482777261, 0.6400128020261844, 0.6400128020261844, 0.6400128020261844, 0.22667772121553353, 0.22667772121553353, 0.22667772121553353, 0.2521717294514163, 0.2521717294514163, 0.2521717294514163, 0.1492921492270396, 0.1492921492270396, 0.1492921492270396, 0.12640293631753152, 0.12640293631753152, 0.12640293631753152, 0.12034170864839067, 0.12034170864839067, 0.12034170864839067, 0.11271301158662117, 0.11271301158662117, 0.11271301158662117, 0.09804224158364372, 0.09804224158364372, 0.09804224158364372, 0.09065947656875539, 0.09065947656875539, 0.09065947656875539, 0.10680036959933825, 0.10680036959933825, 0.10680036959933825, 0.9479351827305835, 0.9479351827305835, 0.9479351827305835, 0.9706044429501488, 0.9706044429501488, 0.9706044429501488, 0.9673482444049066, 0.9673482444049066, 0.9673482444049066, 0.3795258190759355, 0.3795258190759355, 0.3795258190759355, 0.3797628599870726, 0.3797628599870726, 0.3797628599870726, 0.41694754239519893, 0.41694754239519893, 0.41694754239519893, 0.5416922700626992, 0.5416922700626992, 0.5416922700626992, 0.18598026422219582, 0.18598026422219582, 0.18598026422219582, 0.6733544422358189, 0.6733544422358189, 0.6733544422358189, 0.34229729251653407, 0.34229729251653407, 0.34229729251653407, 0.17331838841871527, 0.17331838841871527, 0.17331838841871527, 0.28700523805434097, 0.28700523805434097, 0.28700523805434097, 0.19911734886857735, 0.19911734886857735, 0.19911734886857735, 0.3147054028785048, 0.3147054028785048, 0.3147054028785048, 0.3680174005195076, 0.3680174005195076, 0.3680174005195076, 0.05064310577550257, 0.05064310577550257, 0.05064310577550257, 0.08942862296244802, 0.08942862296244802, 0.08942862296244802, 0.048438818196322564, 0.048438818196322564, 0.048438818196322564, 0.1895239331712142, 0.1895239331712142, 0.1895239331712142, 0.07189668035624885, 0.07189668035624885, 0.07189668035624885, 0.09326124828941174, 0.09326124828941174, 0.09326124828941174, 0.02912524143736117, 0.02912524143736117, 0.02912524143736117, 0.07595216639991398, 0.07595216639991398, 0.07595216639991398, 0.061529607532354036, 0.061529607532354036, 0.061529607532354036, 0.1562433425911346, 0.1562433425911346, 0.1562433425911346, 0.03478385597946654, 0.03478385597946654, 0.03478385597946654, 0.0606566298180744, 0.0606566298180744, 0.0606566298180744, 0.47627021116739277, 0.47627021116739277, 0.47627021116739277, 0.5398868259216476, 0.5398868259216476, 0.5398868259216476, 0.5040167818478543, 0.5040167818478543, 0.5040167818478543, 0.13864159508456764, 0.13864159508456764, 0.13864159508456764, 0.14908874437003417, 0.14908874437003417, 0.14908874437003417, 0.10221165742064608, 0.10221165742064608, 0.10221165742064608, 0.2037762830401727, 0.2037762830401727, 0.2037762830401727, 0.2419910461781839, 0.2419910461781839, 0.2419910461781839, 0.2022117011342076, 0.2022117011342076, 0.2022117011342076, 0.31819468138654616, 0.31819468138654616, 0.31819468138654616, 0.3586462424624436, 0.3586462424624436, 0.3586462424624436, 0.28199565913061475, 0.28199565913061475, 0.28199565913061475, 0.22312446127309238, 0.22312446127309238, 0.22312446127309238, 0.2304269682388157, 0.2304269682388157, 0.2304269682388157, 0.21467308714301858, 0.21467308714301858, 0.21467308714301858, 0.21056741143867674, 0.21056741143867674, 0.21056741143867674, 0.19990056817667212, 0.19990056817667212, 0.19990056817667212, 0.22063159793509257, 0.22063159793509257, 0.22063159793509257, 0.45698863369394516, 0.45698863369394516, 0.45698863369394516, 0.48142247651048087, 0.48142247651048087, 0.48142247651048087, 0.20221600985210153, 0.20221600985210153, 0.20221600985210153, 0.8218313159320008, 0.8218313159320008, 0.8218313159320008, 0.8052173206189249, 0.8052173206189249, 0.8052173206189249, 0.19335378362861688, 0.19335378362861688, 0.19335378362861688, 0.6570129167661601, 0.6570129167661601, 0.6570129167661601, 0.2082113948208043, 0.2082113948208043, 0.2082113948208043, 0.1542185344963778, 0.1542185344963778, 0.1542185344963778, 0.17421830295852092, 0.17421830295852092, 0.17421830295852092, 0.20765586557058124, 0.20765586557058124, 0.20765586557058124, 0.19919502678411838, 0.19919502678411838, 0.19919502678411838, 0.08418684775260465, 0.08418684775260465, 0.08418684775260465, 0.07938996845369439, 0.07938996845369439, 0.07938996845369439, 0.08744509160774816, 0.08744509160774816, 0.08744509160774816]}, "mutation_prompt": null}
{"id": "9285b31b-bd53-40ce-bc2c-6cf0e7ae074c", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7  # Increased initial inertia\n        self.inertia_decay = 0.99  # Inertia decay factor\n        self.cognitive = 1.5  # Slightly increased cognitive component\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n        self.dynamic_crossover = True  # Enable dynamic crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update with decaying inertia\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if self.dynamic_crossover:\n                    self.de_crossover_rate = 0.5 + 0.4 * (self.budget - eval_count) / self.budget  # Dynamic crossover\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            self.inertia *= self.inertia_decay  # Decay inertia over time\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveDSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization using dynamic inertia and crossover adjustments for improved convergence.", "configspace": "", "generation": 81, "fitness": 0.33548342748942295, "feedback": "The algorithm QuantumEnhancedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7952674050716956, 0.7952674050716956, 0.7952674050716956, 0.7900301991012122, 0.7900301991012122, 0.7900301991012122, 0.7766867928875416, 0.7766867928875416, 0.7766867928875416, 0.5008521178915307, 0.5008521178915307, 0.5008521178915307, 0.5319704117885244, 0.5319704117885244, 0.5319704117885244, 0.5726635424357207, 0.5726635424357207, 0.5726635424357207, 0.15186826160043854, 0.15186826160043854, 0.15186826160043854, 0.11815293569929597, 0.11815293569929597, 0.11815293569929597, 0.14923545951495276, 0.14923545951495276, 0.14923545951495276, 0.1022904631032101, 0.1022904631032101, 0.1022904631032101, 0.11707277872361466, 0.11707277872361466, 0.11707277872361466, 0.15007971002425202, 0.15007971002425202, 0.15007971002425202, 0.9592638521117907, 0.9592638521117907, 0.9592638521117907, 0.9564509016488372, 0.9564509016488372, 0.9564509016488372, 0.959090729637032, 0.959090729637032, 0.959090729637032, 0.5294412469445637, 0.5294412469445637, 0.5294412469445637, 0.6175844194558857, 0.6175844194558857, 0.6175844194558857, 0.651383239771744, 0.651383239771744, 0.651383239771744, 0.35909645649004407, 0.35909645649004407, 0.35909645649004407, 0.7463277033388883, 0.7463277033388883, 0.7463277033388883, 0.7906647405178127, 0.7906647405178127, 0.7906647405178127, 0.5168060152109124, 0.5168060152109124, 0.5168060152109124, 0.13163838305687636, 0.13163838305687636, 0.13163838305687636, 0.12907859487045648, 0.12907859487045648, 0.12907859487045648, 0.6127284847181855, 0.6127284847181855, 0.6127284847181855, 0.2434304714723079, 0.2434304714723079, 0.2434304714723079, 0.1290432599954946, 0.1290432599954946, 0.1290432599954946, 0.17907925916348943, 0.17907925916348943, 0.17907925916348943, 0.21787229048045353, 0.21787229048045353, 0.21787229048045353, 0.12641773025440417, 0.12641773025440417, 0.12641773025440417, 0.11950750721593117, 0.11950750721593117, 0.11950750721593117, 0.0874593075487039, 0.0874593075487039, 0.0874593075487039, 0.13356671179097734, 0.13356671179097734, 0.13356671179097734, 0.042827562839273914, 0.042827562839273914, 0.042827562839273914, 0.07260770156596175, 0.07260770156596175, 0.07260770156596175, 0.18059756318940856, 0.18059756318940856, 0.18059756318940856, 0.13202243518839984, 0.13202243518839984, 0.13202243518839984, 0.22175499402583487, 0.22175499402583487, 0.22175499402583487, 0.2708599582525829, 0.2708599582525829, 0.2708599582525829, 0.6409557185449578, 0.6409557185449578, 0.6409557185449578, 0.6575092276682359, 0.6575092276682359, 0.6575092276682359, 0.621389860707391, 0.621389860707391, 0.621389860707391, 0.6116675646922094, 0.6116675646922094, 0.6116675646922094, 0.08986928313682474, 0.08986928313682474, 0.08986928313682474, 0.1431575347513464, 0.1431575347513464, 0.1431575347513464, 0.18045144354126186, 0.18045144354126186, 0.18045144354126186, 0.4215169592958895, 0.4215169592958895, 0.4215169592958895, 0.18537086920340173, 0.18537086920340173, 0.18537086920340173, 0.4246042577204139, 0.4246042577204139, 0.4246042577204139, 0.29491316709406323, 0.29491316709406323, 0.29491316709406323, 0.21061072768591615, 0.21061072768591615, 0.21061072768591615, 0.26453891781065275, 0.26453891781065275, 0.26453891781065275, 0.21646740417252786, 0.21646740417252786, 0.21646740417252786, 0.4038293116008669, 0.4038293116008669, 0.4038293116008669, 0.20657990742178056, 0.20657990742178056, 0.20657990742178056, 0.24043995288396713, 0.24043995288396713, 0.24043995288396713, 0.21050799236048046, 0.21050799236048046, 0.21050799236048046, 0.2150853366188169, 0.2150853366188169, 0.2150853366188169, 0.185250249902273, 0.185250249902273, 0.185250249902273, 0.1774911827857415, 0.1774911827857415, 0.1774911827857415, 0.8883109969870567, 0.8883109969870567, 0.8883109969870567, 0.158451857647272, 0.158451857647272, 0.158451857647272, 0.1653453137740546, 0.1653453137740546, 0.1653453137740546, 0.2085924099623323, 0.2085924099623323, 0.2085924099623323, 0.2086321787519636, 0.2086321787519636, 0.2086321787519636, 0.1557212858350172, 0.1557212858350172, 0.1557212858350172, 0.1876456994523792, 0.1876456994523792, 0.1876456994523792, 0.20029337334148645, 0.20029337334148645, 0.20029337334148645, 0.22784750865585246, 0.22784750865585246, 0.22784750865585246, 0.09266965787828663, 0.09266965787828663, 0.09266965787828663, 0.09345619357823876, 0.09345619357823876, 0.09345619357823876, 0.092861835177251, 0.092861835177251, 0.092861835177251]}, "mutation_prompt": null}
{"id": "a77ae82a-e97d-4ac3-a9a8-b704f45544cf", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n        inertia_decrease = (self.inertia - 0.1) / (self.budget / self.num_particles)\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Dynamic inertia update\n                self.inertia = max(0.1, self.inertia - inertia_decrease)\n                \n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation with adaptive crossover\n                if np.random.rand() < self.de_crossover_rate * ((self.budget - eval_count) / self.budget):\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedAdaptiveDSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization incorporating dynamic inertia scaling and elite crossover strategies.", "configspace": "", "generation": 82, "fitness": 0.30637679683440744, "feedback": "The algorithm QuantumEnhancedAdaptiveDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.9022317264146081, 0.9022317264146081, 0.9022317264146081, 0.8908404597093759, 0.8908404597093759, 0.8908404597093759, 0.8691668730656124, 0.8691668730656124, 0.8691668730656124, 0.36203520095100705, 0.36203520095100705, 0.36203520095100705, 0.5933427410933667, 0.5933427410933667, 0.5933427410933667, 0.45312393622991254, 0.45312393622991254, 0.45312393622991254, 0.14459036935569325, 0.14459036935569325, 0.14459036935569325, 0.09225008392082057, 0.09225008392082057, 0.09225008392082057, 0.07693585246021595, 0.07693585246021595, 0.07693585246021595, 0.11047579023733523, 0.11047579023733523, 0.11047579023733523, 0.09275872386155115, 0.09275872386155115, 0.09275872386155115, 0.1027144443745821, 0.1027144443745821, 0.1027144443745821, 0.9460983484439306, 0.9460983484439306, 0.9460983484439306, 0.9536227382877561, 0.9536227382877561, 0.9536227382877561, 0.9525300442207174, 0.9525300442207174, 0.9525300442207174, 0.5948440296219009, 0.5948440296219009, 0.5948440296219009, 0.46504185583529656, 0.46504185583529656, 0.46504185583529656, 0.49553325572327034, 0.49553325572327034, 0.49553325572327034, 0.21353286583515474, 0.21353286583515474, 0.21353286583515474, 0.21293295053444783, 0.21293295053444783, 0.21293295053444783, 0.2333337656967306, 0.2333337656967306, 0.2333337656967306, 0.16135946919446342, 0.16135946919446342, 0.16135946919446342, 0.13484648528603504, 0.13484648528603504, 0.13484648528603504, 0.22376287855609422, 0.22376287855609422, 0.22376287855609422, 0.2954844539378667, 0.2954844539378667, 0.2954844539378667, 0.3048794328229888, 0.3048794328229888, 0.3048794328229888, 0.21155279976991548, 0.21155279976991548, 0.21155279976991548, 0.2886429108820373, 0.2886429108820373, 0.2886429108820373, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07214013047413592, 0.07214013047413592, 0.07214013047413592, 0.22426018177072482, 0.22426018177072482, 0.22426018177072482, 0.1101972117395622, 0.1101972117395622, 0.1101972117395622, 0.16690757090118036, 0.16690757090118036, 0.16690757090118036, 0.05079312412691683, 0.05079312412691683, 0.05079312412691683, 0.18022415997675634, 0.18022415997675634, 0.18022415997675634, 0.21980238697876398, 0.21980238697876398, 0.21980238697876398, 0.14175115446937048, 0.14175115446937048, 0.14175115446937048, 0.13809632004556038, 0.13809632004556038, 0.13809632004556038, 0.17879941057858684, 0.17879941057858684, 0.17879941057858684, 0.6532836471437364, 0.6532836471437364, 0.6532836471437364, 0.547088873255434, 0.547088873255434, 0.547088873255434, 0.570444249442015, 0.570444249442015, 0.570444249442015, 0.15775888141131023, 0.15775888141131023, 0.15775888141131023, 0.12707905323102098, 0.12707905323102098, 0.12707905323102098, 0.14214788753788965, 0.14214788753788965, 0.14214788753788965, 0.19776743755494264, 0.19776743755494264, 0.19776743755494264, 0.19906373779876252, 0.19906373779876252, 0.19906373779876252, 0.248978113965858, 0.248978113965858, 0.248978113965858, 0.35209903235538287, 0.35209903235538287, 0.35209903235538287, 0.36976248129393485, 0.36976248129393485, 0.36976248129393485, 0.39363347016981265, 0.39363347016981265, 0.39363347016981265, 0.31012097530976823, 0.31012097530976823, 0.31012097530976823, 0.3039563294491897, 0.3039563294491897, 0.3039563294491897, 0.1808481944325261, 0.1808481944325261, 0.1808481944325261, 0.18096853878083552, 0.18096853878083552, 0.18096853878083552, 0.1952038088704362, 0.1952038088704362, 0.1952038088704362, 0.2615180732988055, 0.2615180732988055, 0.2615180732988055, 0.20393682803344082, 0.20393682803344082, 0.20393682803344082, 0.1979234191965551, 0.1979234191965551, 0.1979234191965551, 0.1828804356224929, 0.1828804356224929, 0.1828804356224929, 0.9361234084304086, 0.9361234084304086, 0.9361234084304086, 0.15868989520544985, 0.15868989520544985, 0.15868989520544985, 0.1616265032323856, 0.1616265032323856, 0.1616265032323856, 0.21130376459029254, 0.21130376459029254, 0.21130376459029254, 0.21102637255711854, 0.21102637255711854, 0.21102637255711854, 0.6212247184808013, 0.6212247184808013, 0.6212247184808013, 0.20664120093545757, 0.20664120093545757, 0.20664120093545757, 0.20426922063428488, 0.20426922063428488, 0.20426922063428488, 0.23116390790061914, 0.23116390790061914, 0.23116390790061914, 0.09073781904090628, 0.09073781904090628, 0.09073781904090628, 0.09410093102178874, 0.09410093102178874, 0.09410093102178874, 0.0942220245094273, 0.0942220245094273, 0.0942220245094273]}, "mutation_prompt": null}
{"id": "9dfe7f7c-f981-4035-837b-c8a8d07d1e2f", "solution": "import numpy as np\n\nclass HybridAdaptiveQuantumDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Adaptive inertia update\n                self.inertia = 0.4 + 0.5 * (self.budget - eval_count) / self.budget\n\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = np.random.normal(self.global_best_position, 0.5)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.5\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = np.copy(trial_vector)\n                        personal_best_positions[i] = np.copy(trial_vector)\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridAdaptiveQuantumDSO", "description": "Hybrid Adaptive Quantum Differential Swarm Optimization with dynamic inertia and enhanced exploitation-exploration balance.", "configspace": "", "generation": 83, "fitness": 0.27713987238444887, "feedback": "The algorithm HybridAdaptiveQuantumDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6597982811213907, 0.6597982811213907, 0.6597982811213907, 0.6551851747756823, 0.6551851747756823, 0.6551851747756823, 0.6588521284553592, 0.6588521284553592, 0.6588521284553592, 0.028063342345818088, 0.028063342345818088, 0.028063342345818088, 0.2052535752415684, 0.2052535752415684, 0.2052535752415684, 0.17838997915328725, 0.17838997915328725, 0.17838997915328725, 0.12744339402219707, 0.12744339402219707, 0.12744339402219707, 0.10446806309542522, 0.10446806309542522, 0.10446806309542522, 0.11422071126181144, 0.11422071126181144, 0.11422071126181144, 0.10465380549407732, 0.10465380549407732, 0.10465380549407732, 0.09384045244758821, 0.09384045244758821, 0.09384045244758821, 0.12682431965086338, 0.12682431965086338, 0.12682431965086338, 0.9394539199799377, 0.9394539199799377, 0.9394539199799377, 0.9719277902719563, 0.9719277902719563, 0.9719277902719563, 0.9638699580439372, 0.9638699580439372, 0.9638699580439372, 0.4096411910319283, 0.4096411910319283, 0.4096411910319283, 0.4094701957330984, 0.4094701957330984, 0.4094701957330984, 0.40367909760776743, 0.40367909760776743, 0.40367909760776743, 0.6462449080837612, 0.6462449080837612, 0.6462449080837612, 0.3282856621680792, 0.3282856621680792, 0.3282856621680792, 0.5543434051766603, 0.5543434051766603, 0.5543434051766603, 0.2532217601613188, 0.2532217601613188, 0.2532217601613188, 0.2671404310018016, 0.2671404310018016, 0.2671404310018016, 0.24727803827891903, 0.24727803827891903, 0.24727803827891903, 0.1980209016499933, 0.1980209016499933, 0.1980209016499933, 0.37279446304807995, 0.37279446304807995, 0.37279446304807995, 0.28707871330895585, 0.28707871330895585, 0.28707871330895585, 0.10004147461973167, 0.10004147461973167, 0.10004147461973167, 0.056499158731896926, 0.056499158731896926, 0.056499158731896926, 0.08191417669511869, 0.08191417669511869, 0.08191417669511869, 0.12252767899691241, 0.12252767899691241, 0.12252767899691241, 0.14341092155348012, 0.14341092155348012, 0.14341092155348012, 0.10312710386598878, 0.10312710386598878, 0.10312710386598878, 0.033873029306384694, 0.033873029306384694, 0.033873029306384694, 0.0707828514829929, 0.0707828514829929, 0.0707828514829929, 0.0993479876154223, 0.0993479876154223, 0.0993479876154223, 0.16394771870283442, 0.16394771870283442, 0.16394771870283442, 0.11062312310701583, 0.11062312310701583, 0.11062312310701583, 0.06652588746841026, 0.06652588746841026, 0.06652588746841026, 0.538733454204692, 0.538733454204692, 0.538733454204692, 0.5081792522107766, 0.5081792522107766, 0.5081792522107766, 0.5024252820566626, 0.5024252820566626, 0.5024252820566626, 0.10679903363505128, 0.10679903363505128, 0.10679903363505128, 0.10624127807412875, 0.10624127807412875, 0.10624127807412875, 0.10716859960617908, 0.10716859960617908, 0.10716859960617908, 0.24477423396538744, 0.24477423396538744, 0.24477423396538744, 0.4242658443914713, 0.4242658443914713, 0.4242658443914713, 0.36707103492608495, 0.36707103492608495, 0.36707103492608495, 0.3669783129270582, 0.3669783129270582, 0.3669783129270582, 0.3056321285670125, 0.3056321285670125, 0.3056321285670125, 0.2715703592439016, 0.2715703592439016, 0.2715703592439016, 0.26089444856513067, 0.26089444856513067, 0.26089444856513067, 0.20206172379330634, 0.20206172379330634, 0.20206172379330634, 0.19007155803234022, 0.19007155803234022, 0.19007155803234022, 0.2666296399365805, 0.2666296399365805, 0.2666296399365805, 0.20141946132341648, 0.20141946132341648, 0.20141946132341648, 0.20678663508572614, 0.20678663508572614, 0.20678663508572614, 0.42800401695366774, 0.42800401695366774, 0.42800401695366774, 0.18352829353336386, 0.18352829353336386, 0.18352829353336386, 0.24250820163046305, 0.24250820163046305, 0.24250820163046305, 0.772723153553353, 0.772723153553353, 0.772723153553353, 0.1578507858402849, 0.1578507858402849, 0.1578507858402849, 0.1754350093166026, 0.1754350093166026, 0.1754350093166026, 0.15564162019625327, 0.15564162019625327, 0.15564162019625327, 0.20750951541398743, 0.20750951541398743, 0.20750951541398743, 0.1552497208744249, 0.1552497208744249, 0.1552497208744249, 0.18917789106575467, 0.18917789106575467, 0.18917789106575467, 0.1842277618697351, 0.1842277618697351, 0.1842277618697351, 0.1932771339608801, 0.1932771339608801, 0.1932771339608801, 0.08119924991871508, 0.08119924991871508, 0.08119924991871508, 0.09396500586451928, 0.09396500586451928, 0.09396500586451928, 0.09400639638595698, 0.09400639638595698, 0.09400639638595698]}, "mutation_prompt": null}
{"id": "81cc4835-1ad9-407b-a066-35cce6261f4a", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and elite particle reinforcement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8321186788849009, 0.8321186788849009, 0.8321186788849009, 0.8077373703110324, 0.8077373703110324, 0.8077373703110324, 0.8230672540546263, 0.8230672540546263, 0.8230672540546263, 0.5116669950722281, 0.5116669950722281, 0.5116669950722281, 0.5661560136612218, 0.5661560136612218, 0.5661560136612218, 0.6113058189557582, 0.6113058189557582, 0.6113058189557582, 0.15980213110663188, 0.15980213110663188, 0.15980213110663188, 0.15836379454087035, 0.15836379454087035, 0.15836379454087035, 0.10700891265479351, 0.10700891265479351, 0.10700891265479351, 0.12732956032599918, 0.12732956032599918, 0.12732956032599918, 0.06905195301446476, 0.06905195301446476, 0.06905195301446476, 0.1345013716819694, 0.1345013716819694, 0.1345013716819694, 0.9591111998970985, 0.9591111998970985, 0.9591111998970985, 0.9585593447047763, 0.9585593447047763, 0.9585593447047763, 0.9574263685928593, 0.9574263685928593, 0.9574263685928593, 0.6364651002009667, 0.6364651002009667, 0.6364651002009667, 0.6951144370755298, 0.6951144370755298, 0.6951144370755298, 0.6686499429390589, 0.6686499429390589, 0.6686499429390589, 0.8100450310483559, 0.8100450310483559, 0.8100450310483559, 0.2191433915634472, 0.2191433915634472, 0.2191433915634472, 0.35535998298566196, 0.35535998298566196, 0.35535998298566196, 0.5982796272612709, 0.5982796272612709, 0.5982796272612709, 0.6415045173467162, 0.6415045173467162, 0.6415045173467162, 0.6398000470576843, 0.6398000470576843, 0.6398000470576843, 0.5428928671013161, 0.5428928671013161, 0.5428928671013161, 0.5642790632999215, 0.5642790632999215, 0.5642790632999215, 0.6524933627785994, 0.6524933627785994, 0.6524933627785994, 0.3320409711584029, 0.3320409711584029, 0.3320409711584029, 0.4064992272210587, 0.4064992272210587, 0.4064992272210587, 0.0032715883739258267, 0.0032715883739258267, 0.0032715883739258267, 0.5339891197626435, 0.5339891197626435, 0.5339891197626435, 0.17748082363632034, 0.17748082363632034, 0.17748082363632034, 0.6205554758644007, 0.6205554758644007, 0.6205554758644007, 0.12699739198808058, 0.12699739198808058, 0.12699739198808058, 0.20264865332135862, 0.20264865332135862, 0.20264865332135862, 0.10359900711219672, 0.10359900711219672, 0.10359900711219672, 0.17336943788479298, 0.17336943788479298, 0.17336943788479298, 0.03797532713121943, 0.03797532713121943, 0.03797532713121943, 0.055864185337872185, 0.055864185337872185, 0.055864185337872185, 0.7251167159474545, 0.7251167159474545, 0.7251167159474545, 0.6908898067973139, 0.6908898067973139, 0.6908898067973139, 0.7367565470019714, 0.7367565470019714, 0.7367565470019714, 0.13749820551805536, 0.13749820551805536, 0.13749820551805536, 0.1826801551718401, 0.1826801551718401, 0.1826801551718401, 0.12066259163666926, 0.12066259163666926, 0.12066259163666926, 0.202893140333395, 0.202893140333395, 0.202893140333395, 0.2314563184270485, 0.2314563184270485, 0.2314563184270485, 0.38954346630555825, 0.38954346630555825, 0.38954346630555825, 0.37502158564298227, 0.37502158564298227, 0.37502158564298227, 0.3059459622620033, 0.3059459622620033, 0.3059459622620033, 0.48969630406392073, 0.48969630406392073, 0.48969630406392073, 0.2480830354911986, 0.2480830354911986, 0.2480830354911986, 0.443672575036419, 0.443672575036419, 0.443672575036419, 0.1644781920745234, 0.1644781920745234, 0.1644781920745234, 0.2843285752980297, 0.2843285752980297, 0.2843285752980297, 0.22353751179202908, 0.22353751179202908, 0.22353751179202908, 0.23127309941644802, 0.23127309941644802, 0.23127309941644802, 0.7425618916612338, 0.7425618916612338, 0.7425618916612338, 0.20694529613164991, 0.20694529613164991, 0.20694529613164991, 0.19579955627160162, 0.19579955627160162, 0.19579955627160162, 0.9081391265722403, 0.9081391265722403, 0.9081391265722403, 0.15891442399030364, 0.15891442399030364, 0.15891442399030364, 0.17133278472820113, 0.17133278472820113, 0.17133278472820113, 0.20935471733507016, 0.20935471733507016, 0.20935471733507016, 0.21098447324252212, 0.21098447324252212, 0.21098447324252212, 0.8094593742775736, 0.8094593742775736, 0.8094593742775736, 0.2177271797225232, 0.2177271797225232, 0.2177271797225232, 0.24910938126412285, 0.24910938126412285, 0.24910938126412285, 0.2474734376703408, 0.2474734376703408, 0.2474734376703408, 0.09066702526169679, 0.09066702526169679, 0.09066702526169679, 0.08767401619723092, 0.08767401619723092, 0.08767401619723092, 0.09458529381324443, 0.09458529381324443, 0.09458529381324443]}, "mutation_prompt": null}
{"id": "4013505f-cec3-4b5d-abf4-9259b850ecc3", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased for diversity\n        self.inertia = 0.7  # Adjusted for better exploration\n        self.cognitive = 1.5  # Higher cognitive component for individual learning\n        self.social = 1.9  # Slightly reduced to focus on individual improvement\n        self.quantum_prob = 0.35  # Increased for more frequent quantum jumps\n        self.elite_quantum_prob = 0.2  # Adjusted for a balanced elite update\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced max velocity for finer search\n        self.de_mutation_factor = 0.9  # Increased to enhance mutation effect\n        self.de_crossover_rate = 0.85  # Slightly reduced for strategic crossover\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.standard_normal(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.standard_normal(self.dim) * 0.5\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridQuantumInspiredDSO", "description": "Hybrid Quantum-Inspired Differential Swarm Optimization with dynamic group scaling and adaptive elite strategy.", "configspace": "", "generation": 85, "fitness": 0.2716462827655069, "feedback": "The algorithm HybridQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6675277385870633, 0.6675277385870633, 0.6675277385870633, 0.6674760630431461, 0.6674760630431461, 0.6674760630431461, 0.6699516729931432, 0.6699516729931432, 0.6699516729931432, 0.1109794502645356, 0.1109794502645356, 0.1109794502645356, 0.1941153063494605, 0.1941153063494605, 0.1941153063494605, 0.21796334854283472, 0.21796334854283472, 0.21796334854283472, 0.13146281842272833, 0.13146281842272833, 0.13146281842272833, 0.11846119920420184, 0.11846119920420184, 0.11846119920420184, 0.16017276329875307, 0.16017276329875307, 0.16017276329875307, 0.09129874523446802, 0.09129874523446802, 0.09129874523446802, 0.09007472814123996, 0.09007472814123996, 0.09007472814123996, 0.12383983207127736, 0.12383983207127736, 0.12383983207127736, 0.9483076111350034, 0.9483076111350034, 0.9483076111350034, 0.9693442348607049, 0.9693442348607049, 0.9693442348607049, 0.9550067207932625, 0.9550067207932625, 0.9550067207932625, 0.38949385962799044, 0.38949385962799044, 0.38949385962799044, 0.4166389971208968, 0.4166389971208968, 0.4166389971208968, 0.44066745178373623, 0.44066745178373623, 0.44066745178373623, 0.22214857693719636, 0.22214857693719636, 0.22214857693719636, 0.22112886263999576, 0.22112886263999576, 0.22112886263999576, 0.6879366918563026, 0.6879366918563026, 0.6879366918563026, 0.2915111803538275, 0.2915111803538275, 0.2915111803538275, 0.2678619055036382, 0.2678619055036382, 0.2678619055036382, 0.200708806008983, 0.200708806008983, 0.200708806008983, 0.2602366168024315, 0.2602366168024315, 0.2602366168024315, 0.26058097284307147, 0.26058097284307147, 0.26058097284307147, 0.12082282869275718, 0.12082282869275718, 0.12082282869275718, 0.18716475687019607, 0.18716475687019607, 0.18716475687019607, 0.06558954237699521, 0.06558954237699521, 0.06558954237699521, 0.08446518708091222, 0.08446518708091222, 0.08446518708091222, 0.1289225292338162, 0.1289225292338162, 0.1289225292338162, 0.06178602900327601, 0.06178602900327601, 0.06178602900327601, 0.18101557375812805, 0.18101557375812805, 0.18101557375812805, 0.12057982154508518, 0.12057982154508518, 0.12057982154508518, 0.0553071156280488, 0.0553071156280488, 0.0553071156280488, 0.08683579850858636, 0.08683579850858636, 0.08683579850858636, 0.19096946586617047, 0.19096946586617047, 0.19096946586617047, 0.20472564517336822, 0.20472564517336822, 0.20472564517336822, 0.07636355412956242, 0.07636355412956242, 0.07636355412956242, 0.48386927439515304, 0.48386927439515304, 0.48386927439515304, 0.5024624156659323, 0.5024624156659323, 0.5024624156659323, 0.5234068590598546, 0.5234068590598546, 0.5234068590598546, 0.13342586295671133, 0.13342586295671133, 0.13342586295671133, 0.13015864087353057, 0.13015864087353057, 0.13015864087353057, 0.1260813907634103, 0.1260813907634103, 0.1260813907634103, 0.2197753518136749, 0.2197753518136749, 0.2197753518136749, 0.2144464168702862, 0.2144464168702862, 0.2144464168702862, 0.39746260908056597, 0.39746260908056597, 0.39746260908056597, 0.30727471310734866, 0.30727471310734866, 0.30727471310734866, 0.30372237153828363, 0.30372237153828363, 0.30372237153828363, 0.3366839775638034, 0.3366839775638034, 0.3366839775638034, 0.24581083518410674, 0.24581083518410674, 0.24581083518410674, 0.28435788633946435, 0.28435788633946435, 0.28435788633946435, 0.1833601037407646, 0.1833601037407646, 0.1833601037407646, 0.2309539889855916, 0.2309539889855916, 0.2309539889855916, 0.21374257098557892, 0.21374257098557892, 0.21374257098557892, 0.21593454376670007, 0.21593454376670007, 0.21593454376670007, 0.19569314727726628, 0.19569314727726628, 0.19569314727726628, 0.20347138043319635, 0.20347138043319635, 0.20347138043319635, 0.20367580217332126, 0.20367580217332126, 0.20367580217332126, 0.8258551433712236, 0.8258551433712236, 0.8258551433712236, 0.1678080543975946, 0.1678080543975946, 0.1678080543975946, 0.16935800296554449, 0.16935800296554449, 0.16935800296554449, 0.1676898000081366, 0.1676898000081366, 0.1676898000081366, 0.2119325086164191, 0.2119325086164191, 0.2119325086164191, 0.15529826963432425, 0.15529826963432425, 0.15529826963432425, 0.18697168922334206, 0.18697168922334206, 0.18697168922334206, 0.19722224609273398, 0.19722224609273398, 0.19722224609273398, 0.18460494297572172, 0.18460494297572172, 0.18460494297572172, 0.08063201400138842, 0.08063201400138842, 0.08063201400138842, 0.075945039444268, 0.075945039444268, 0.075945039444268, 0.14000050352446214, 0.14000050352446214, 0.14000050352446214]}, "mutation_prompt": null}
{"id": "09eccd73-1919-401c-bb94-5d5e854afac2", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and elite particle reinforcement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8321186788849009, 0.8321186788849009, 0.8321186788849009, 0.8077373703110324, 0.8077373703110324, 0.8077373703110324, 0.8230672540546263, 0.8230672540546263, 0.8230672540546263, 0.5116669950722281, 0.5116669950722281, 0.5116669950722281, 0.5661560136612218, 0.5661560136612218, 0.5661560136612218, 0.6113058189557582, 0.6113058189557582, 0.6113058189557582, 0.15980213110663188, 0.15980213110663188, 0.15980213110663188, 0.15836379454087035, 0.15836379454087035, 0.15836379454087035, 0.10700891265479351, 0.10700891265479351, 0.10700891265479351, 0.12732956032599918, 0.12732956032599918, 0.12732956032599918, 0.06905195301446476, 0.06905195301446476, 0.06905195301446476, 0.1345013716819694, 0.1345013716819694, 0.1345013716819694, 0.9591111998970985, 0.9591111998970985, 0.9591111998970985, 0.9585593447047763, 0.9585593447047763, 0.9585593447047763, 0.9574263685928593, 0.9574263685928593, 0.9574263685928593, 0.6364651002009667, 0.6364651002009667, 0.6364651002009667, 0.6951144370755298, 0.6951144370755298, 0.6951144370755298, 0.6686499429390589, 0.6686499429390589, 0.6686499429390589, 0.8100450310483559, 0.8100450310483559, 0.8100450310483559, 0.2191433915634472, 0.2191433915634472, 0.2191433915634472, 0.35535998298566196, 0.35535998298566196, 0.35535998298566196, 0.5982796272612709, 0.5982796272612709, 0.5982796272612709, 0.6415045173467162, 0.6415045173467162, 0.6415045173467162, 0.6398000470576843, 0.6398000470576843, 0.6398000470576843, 0.5428928671013161, 0.5428928671013161, 0.5428928671013161, 0.5642790632999215, 0.5642790632999215, 0.5642790632999215, 0.6524933627785994, 0.6524933627785994, 0.6524933627785994, 0.3320409711584029, 0.3320409711584029, 0.3320409711584029, 0.4064992272210587, 0.4064992272210587, 0.4064992272210587, 0.0032715883739258267, 0.0032715883739258267, 0.0032715883739258267, 0.5339891197626435, 0.5339891197626435, 0.5339891197626435, 0.17748082363632034, 0.17748082363632034, 0.17748082363632034, 0.6205554758644007, 0.6205554758644007, 0.6205554758644007, 0.12699739198808058, 0.12699739198808058, 0.12699739198808058, 0.20264865332135862, 0.20264865332135862, 0.20264865332135862, 0.10359900711219672, 0.10359900711219672, 0.10359900711219672, 0.17336943788479298, 0.17336943788479298, 0.17336943788479298, 0.03797532713121943, 0.03797532713121943, 0.03797532713121943, 0.055864185337872185, 0.055864185337872185, 0.055864185337872185, 0.7251167159474545, 0.7251167159474545, 0.7251167159474545, 0.6908898067973139, 0.6908898067973139, 0.6908898067973139, 0.7367565470019714, 0.7367565470019714, 0.7367565470019714, 0.13749820551805536, 0.13749820551805536, 0.13749820551805536, 0.1826801551718401, 0.1826801551718401, 0.1826801551718401, 0.12066259163666926, 0.12066259163666926, 0.12066259163666926, 0.202893140333395, 0.202893140333395, 0.202893140333395, 0.2314563184270485, 0.2314563184270485, 0.2314563184270485, 0.38954346630555825, 0.38954346630555825, 0.38954346630555825, 0.37502158564298227, 0.37502158564298227, 0.37502158564298227, 0.3059459622620033, 0.3059459622620033, 0.3059459622620033, 0.48969630406392073, 0.48969630406392073, 0.48969630406392073, 0.2480830354911986, 0.2480830354911986, 0.2480830354911986, 0.443672575036419, 0.443672575036419, 0.443672575036419, 0.1644781920745234, 0.1644781920745234, 0.1644781920745234, 0.2843285752980297, 0.2843285752980297, 0.2843285752980297, 0.22353751179202908, 0.22353751179202908, 0.22353751179202908, 0.23127309941644802, 0.23127309941644802, 0.23127309941644802, 0.7425618916612338, 0.7425618916612338, 0.7425618916612338, 0.20694529613164991, 0.20694529613164991, 0.20694529613164991, 0.19579955627160162, 0.19579955627160162, 0.19579955627160162, 0.9081391265722403, 0.9081391265722403, 0.9081391265722403, 0.15891442399030364, 0.15891442399030364, 0.15891442399030364, 0.17133278472820113, 0.17133278472820113, 0.17133278472820113, 0.20935471733507016, 0.20935471733507016, 0.20935471733507016, 0.21098447324252212, 0.21098447324252212, 0.21098447324252212, 0.8094593742775736, 0.8094593742775736, 0.8094593742775736, 0.2177271797225232, 0.2177271797225232, 0.2177271797225232, 0.24910938126412285, 0.24910938126412285, 0.24910938126412285, 0.2474734376703408, 0.2474734376703408, 0.2474734376703408, 0.09066702526169679, 0.09066702526169679, 0.09066702526169679, 0.08767401619723092, 0.08767401619723092, 0.08767401619723092, 0.09458529381324443, 0.09458529381324443, 0.09458529381324443]}, "mutation_prompt": null}
{"id": "1406b332-ab1b-41d7-95cb-da62f6c774fc", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n        self.adjust_rate = 0.05\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Dynamic parameter tuning\n                self.inertia = max(0.4, self.inertia - self.adjust_rate * (eval_count / self.budget))\n                r1, r2 = np.random.rand(), np.random.rand()\n\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumInspiredDSO", "description": "Adaptive Quantum-Inspired Differential Swarm Optimization with dynamic parameter tuning for enhanced convergence.", "configspace": "", "generation": 87, "fitness": 0.3624362211665973, "feedback": "The algorithm AdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8499315204922981, 0.8499315204922981, 0.8499315204922981, 0.8656031924808683, 0.8656031924808683, 0.8656031924808683, 0.8466963098464817, 0.8466963098464817, 0.8466963098464817, 0.5482878666111343, 0.5482878666111343, 0.5482878666111343, 0.614168499908883, 0.614168499908883, 0.614168499908883, 0.5955119289476617, 0.5955119289476617, 0.5955119289476617, 0.13028164583709656, 0.13028164583709656, 0.13028164583709656, 0.11870859429405844, 0.11870859429405844, 0.11870859429405844, 0.09600040291994538, 0.09600040291994538, 0.09600040291994538, 0.10667306477702876, 0.10667306477702876, 0.10667306477702876, 0.10828191960077915, 0.10828191960077915, 0.10828191960077915, 0.06378907016182334, 0.06378907016182334, 0.06378907016182334, 0.9438415299568638, 0.9438415299568638, 0.9438415299568638, 0.9776487500663538, 0.9776487500663538, 0.9776487500663538, 0.9712743120656006, 0.9712743120656006, 0.9712743120656006, 0.6746366629025913, 0.6746366629025913, 0.6746366629025913, 0.640478471160077, 0.640478471160077, 0.640478471160077, 0.6275178866528184, 0.6275178866528184, 0.6275178866528184, 0.7609841038126391, 0.7609841038126391, 0.7609841038126391, 0.18730166471479714, 0.18730166471479714, 0.18730166471479714, 0.8209226877719773, 0.8209226877719773, 0.8209226877719773, 0.13266218250759898, 0.13266218250759898, 0.13266218250759898, 0.39518594078382685, 0.39518594078382685, 0.39518594078382685, 0.6504431738473454, 0.6504431738473454, 0.6504431738473454, 0.2258107361469538, 0.2258107361469538, 0.2258107361469538, 0.3589111958021812, 0.3589111958021812, 0.3589111958021812, 0.6423323923477714, 0.6423323923477714, 0.6423323923477714, 0.06783803688659296, 0.06783803688659296, 0.06783803688659296, 0.6304552295947616, 0.6304552295947616, 0.6304552295947616, 0.06393087248985807, 0.06393087248985807, 0.06393087248985807, 0.14727720032137892, 0.14727720032137892, 0.14727720032137892, 0.11070985168334191, 0.11070985168334191, 0.11070985168334191, 0.47106718990406393, 0.47106718990406393, 0.47106718990406393, 0.08481039916201139, 0.08481039916201139, 0.08481039916201139, 0.13864001254660108, 0.13864001254660108, 0.13864001254660108, 0.20254667456212538, 0.20254667456212538, 0.20254667456212538, 0.24292901669419853, 0.24292901669419853, 0.24292901669419853, 0.4343873444961509, 0.4343873444961509, 0.4343873444961509, 0.08056853869962721, 0.08056853869962721, 0.08056853869962721, 0.8275134257437403, 0.8275134257437403, 0.8275134257437403, 0.6925143523529125, 0.6925143523529125, 0.6925143523529125, 0.741029155205047, 0.741029155205047, 0.741029155205047, 0.11504970738710818, 0.11504970738710818, 0.11504970738710818, 0.1395118769199185, 0.1395118769199185, 0.1395118769199185, 0.0754120055190548, 0.0754120055190548, 0.0754120055190548, 0.2984113271289133, 0.2984113271289133, 0.2984113271289133, 0.35787830478891314, 0.35787830478891314, 0.35787830478891314, 0.16573620809113965, 0.16573620809113965, 0.16573620809113965, 0.3599519836677092, 0.3599519836677092, 0.3599519836677092, 0.3315497945086848, 0.3315497945086848, 0.3315497945086848, 0.4395842601489255, 0.4395842601489255, 0.4395842601489255, 0.2879026469666385, 0.2879026469666385, 0.2879026469666385, 0.2758187064381389, 0.2758187064381389, 0.2758187064381389, 0.39263703603254607, 0.39263703603254607, 0.39263703603254607, 0.21589367643384827, 0.21589367643384827, 0.21589367643384827, 0.24216453607809085, 0.24216453607809085, 0.24216453607809085, 0.20591872994711535, 0.20591872994711535, 0.20591872994711535, 0.19520428364837805, 0.19520428364837805, 0.19520428364837805, 0.24381353231053182, 0.24381353231053182, 0.24381353231053182, 0.2220795636670979, 0.2220795636670979, 0.2220795636670979, 0.9084945790922038, 0.9084945790922038, 0.9084945790922038, 0.15921992996677747, 0.15921992996677747, 0.15921992996677747, 0.17616287824660504, 0.17616287824660504, 0.17616287824660504, 0.16912766870750418, 0.16912766870750418, 0.16912766870750418, 0.21081263985770937, 0.21081263985770937, 0.21081263985770937, 0.1553122910882555, 0.1553122910882555, 0.1553122910882555, 0.19152456765286452, 0.19152456765286452, 0.19152456765286452, 0.212636735013494, 0.212636735013494, 0.212636735013494, 0.1743197750264177, 0.1743197750264177, 0.1743197750264177, 0.09834362732566948, 0.09834362732566948, 0.09834362732566948, 0.09562712011653163, 0.09562712011653163, 0.09562712011653163, 0.08920492545835623, 0.08920492545835623, 0.08920492545835623]}, "mutation_prompt": null}
{"id": "22f6eaef-bdf6-495a-9cab-3e02c6f3165b", "solution": "# Description: Quantum-Enhanced Adaptive Differential Swarm Optimization with Reinforced Diversity and Dynamic Mutation Strategy\n# Code:\nimport numpy as np\n\nclass QuantumEnhancedADSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.6\n        self.cognitive = 1.5\n        self.social = 1.7\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.20\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update with reinforced diversity\n                if np.random.rand() < self.quantum_prob:\n                    quantum_randomness = np.random.normal(0, 1, self.dim)\n                    quantum_position = self.global_best_position + quantum_randomness\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update with dynamic mutation\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.5\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation with enhanced exploration\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedADSO", "description": "Quantum-Enhanced Adaptive Differential Swarm Optimization with Reinforced Diversity and Dynamic Mutation Strategy", "configspace": "", "generation": 88, "fitness": 0.31803161397639207, "feedback": "The algorithm QuantumEnhancedADSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7707632521603942, 0.7707632521603942, 0.7707632521603942, 0.7514902794856008, 0.7514902794856008, 0.7514902794856008, 0.7842335126000541, 0.7842335126000541, 0.7842335126000541, 0.38349639438968763, 0.38349639438968763, 0.38349639438968763, 0.3926147904857964, 0.3926147904857964, 0.3926147904857964, 0.35659785406396327, 0.35659785406396327, 0.35659785406396327, 0.10895232478399464, 0.10895232478399464, 0.10895232478399464, 0.15772155839602509, 0.15772155839602509, 0.15772155839602509, 0.1066163973568377, 0.1066163973568377, 0.1066163973568377, 0.10048456033629394, 0.10048456033629394, 0.10048456033629394, 0.12217474832202369, 0.12217474832202369, 0.12217474832202369, 0.10458789145175196, 0.10458789145175196, 0.10458789145175196, 0.9650630023056758, 0.9650630023056758, 0.9650630023056758, 0.9820566835862683, 0.9820566835862683, 0.9820566835862683, 0.9328211227233686, 0.9328211227233686, 0.9328211227233686, 0.4844287408489155, 0.4844287408489155, 0.4844287408489155, 0.5660820139294918, 0.5660820139294918, 0.5660820139294918, 0.5463657141738711, 0.5463657141738711, 0.5463657141738711, 0.580232968793444, 0.580232968793444, 0.580232968793444, 0.27625316968900737, 0.27625316968900737, 0.27625316968900737, 0.7777938165584576, 0.7777938165584576, 0.7777938165584576, 0.45218931923823624, 0.45218931923823624, 0.45218931923823624, 0.2137574963236013, 0.2137574963236013, 0.2137574963236013, 0.12809675653378527, 0.12809675653378527, 0.12809675653378527, 0.4287740556456774, 0.4287740556456774, 0.4287740556456774, 0.37609096138531717, 0.37609096138531717, 0.37609096138531717, 0.32405329527386395, 0.32405329527386395, 0.32405329527386395, 0.06712574835585661, 0.06712574835585661, 0.06712574835585661, 0.06092834221476384, 0.06092834221476384, 0.06092834221476384, 0.1417815432249797, 0.1417815432249797, 0.1417815432249797, 0.18304298883972936, 0.18304298883972936, 0.18304298883972936, 0.20939530707289555, 0.20939530707289555, 0.20939530707289555, 0.19755618631688598, 0.19755618631688598, 0.19755618631688598, 0.08969445586556579, 0.08969445586556579, 0.08969445586556579, 0.13047390190795927, 0.13047390190795927, 0.13047390190795927, 0.13381157322694126, 0.13381157322694126, 0.13381157322694126, 0.11710775312095978, 0.11710775312095978, 0.11710775312095978, 0.25442598211943523, 0.25442598211943523, 0.25442598211943523, 0.13820015814362796, 0.13820015814362796, 0.13820015814362796, 0.6066034340728184, 0.6066034340728184, 0.6066034340728184, 0.6015298105695919, 0.6015298105695919, 0.6015298105695919, 0.6221324177650105, 0.6221324177650105, 0.6221324177650105, 0.14523340037552768, 0.14523340037552768, 0.14523340037552768, 0.15911365122633214, 0.15911365122633214, 0.15911365122633214, 0.12373616884147576, 0.12373616884147576, 0.12373616884147576, 0.1830265204510566, 0.1830265204510566, 0.1830265204510566, 0.3205287620599305, 0.3205287620599305, 0.3205287620599305, 0.3826005736335173, 0.3826005736335173, 0.3826005736335173, 0.45248046920347296, 0.45248046920347296, 0.45248046920347296, 0.34067569623209515, 0.34067569623209515, 0.34067569623209515, 0.4183286822121578, 0.4183286822121578, 0.4183286822121578, 0.2571386689681654, 0.2571386689681654, 0.2571386689681654, 0.17439498314007507, 0.17439498314007507, 0.17439498314007507, 0.24701959620506508, 0.24701959620506508, 0.24701959620506508, 0.23594303565299035, 0.23594303565299035, 0.23594303565299035, 0.23700601487261086, 0.23700601487261086, 0.23700601487261086, 0.22544180497799093, 0.22544180497799093, 0.22544180497799093, 0.20729442829204558, 0.20729442829204558, 0.20729442829204558, 0.20459857322806907, 0.20459857322806907, 0.20459857322806907, 0.21956120128632206, 0.21956120128632206, 0.21956120128632206, 0.8723088238420866, 0.8723088238420866, 0.8723088238420866, 0.1578379473894691, 0.1578379473894691, 0.1578379473894691, 0.16956031666265148, 0.16956031666265148, 0.16956031666265148, 0.15407359146217348, 0.15407359146217348, 0.15407359146217348, 0.2110509784054565, 0.2110509784054565, 0.2110509784054565, 0.15547191432147978, 0.15547191432147978, 0.15547191432147978, 0.20181785843139066, 0.20181785843139066, 0.20181785843139066, 0.19603388944186628, 0.19603388944186628, 0.19603388944186628, 0.20103126752904643, 0.20103126752904643, 0.20103126752904643, 0.11958489792049753, 0.11958489792049753, 0.11958489792049753, 0.086928649388606, 0.086928649388606, 0.086928649388606, 0.11085155698818094, 0.11085155698818094, 0.11085155698818094]}, "mutation_prompt": null}
{"id": "3354c628-eeae-445f-b428-2986f56ec720", "solution": "import numpy as np\n\nclass QuantumEnhancedDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.7\n        self.cognitive = 1.5\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                self.inertia = 0.4 + 0.5 * (self.budget - eval_count) / self.budget\n\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 1, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    (self.cognitive + np.random.rand() * 0.5) * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedDSO", "description": "Quantum-Enhanced Differential Swarm Optimization with dynamic inertia, adaptive cognitive components, and elite differential mutation for enhanced convergence.", "configspace": "", "generation": 89, "fitness": 0.27089662839164547, "feedback": "The algorithm QuantumEnhancedDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6205164277950416, 0.6205164277950416, 0.6205164277950416, 0.6166724626668427, 0.6166724626668427, 0.6166724626668427, 0.6461107657513403, 0.6461107657513403, 0.6461107657513403, 0.17520730548030006, 0.17520730548030006, 0.17520730548030006, 0.2624053753679314, 0.2624053753679314, 0.2624053753679314, 0.1632937778505884, 0.1632937778505884, 0.1632937778505884, 0.10699365709900754, 0.10699365709900754, 0.10699365709900754, 0.11324554494060957, 0.11324554494060957, 0.11324554494060957, 0.11507892266035757, 0.11507892266035757, 0.11507892266035757, 0.10202566565485738, 0.10202566565485738, 0.10202566565485738, 0.09844750511107381, 0.09844750511107381, 0.09844750511107381, 0.10203125143568637, 0.10203125143568637, 0.10203125143568637, 0.9456357336458817, 0.9456357336458817, 0.9456357336458817, 0.9641496094526363, 0.9641496094526363, 0.9641496094526363, 0.9635117218128494, 0.9635117218128494, 0.9635117218128494, 0.396514154133354, 0.396514154133354, 0.396514154133354, 0.34809269381055596, 0.34809269381055596, 0.34809269381055596, 0.36489662750166263, 0.36489662750166263, 0.36489662750166263, 0.2140154028371073, 0.2140154028371073, 0.2140154028371073, 0.1584279519499885, 0.1584279519499885, 0.1584279519499885, 0.6153291586379109, 0.6153291586379109, 0.6153291586379109, 0.19700023749086382, 0.19700023749086382, 0.19700023749086382, 0.28627893657326786, 0.28627893657326786, 0.28627893657326786, 0.28313920290366545, 0.28313920290366545, 0.28313920290366545, 0.23789588096938974, 0.23789588096938974, 0.23789588096938974, 0.2297861070942563, 0.2297861070942563, 0.2297861070942563, 0.16803143405816168, 0.16803143405816168, 0.16803143405816168, 0.026258160716653545, 0.026258160716653545, 0.026258160716653545, 0.05461274715278741, 0.05461274715278741, 0.05461274715278741, 0.03692013087126944, 0.03692013087126944, 0.03692013087126944, 0.162044666465762, 0.162044666465762, 0.162044666465762, 0.12808221182242718, 0.12808221182242718, 0.12808221182242718, 0.15196244350278543, 0.15196244350278543, 0.15196244350278543, 0.02618924609176143, 0.02618924609176143, 0.02618924609176143, 0.09339915663651466, 0.09339915663651466, 0.09339915663651466, 0.08129610684032251, 0.08129610684032251, 0.08129610684032251, 0.12237205094769688, 0.12237205094769688, 0.12237205094769688, 0.16330329251084263, 0.16330329251084263, 0.16330329251084263, 0.0690769855009512, 0.0690769855009512, 0.0690769855009512, 0.48172486475497567, 0.48172486475497567, 0.48172486475497567, 0.47226724352348914, 0.47226724352348914, 0.47226724352348914, 0.46441680584799616, 0.46441680584799616, 0.46441680584799616, 0.11915593413137338, 0.11915593413137338, 0.11915593413137338, 0.1515462010247065, 0.1515462010247065, 0.1515462010247065, 0.09373021407810078, 0.09373021407810078, 0.09373021407810078, 0.19593309441927442, 0.19593309441927442, 0.19593309441927442, 0.21902453938384558, 0.21902453938384558, 0.21902453938384558, 0.17406441788712224, 0.17406441788712224, 0.17406441788712224, 0.36076992974766986, 0.36076992974766986, 0.36076992974766986, 0.3766128225241743, 0.3766128225241743, 0.3766128225241743, 0.32432598902383525, 0.32432598902383525, 0.32432598902383525, 0.2329333406271653, 0.2329333406271653, 0.2329333406271653, 0.2920812101010246, 0.2920812101010246, 0.2920812101010246, 0.2009043954809665, 0.2009043954809665, 0.2009043954809665, 0.20285703540377376, 0.20285703540377376, 0.20285703540377376, 0.21523522425879305, 0.21523522425879305, 0.21523522425879305, 0.20381357098510866, 0.20381357098510866, 0.20381357098510866, 0.2206345580267315, 0.2206345580267315, 0.2206345580267315, 0.19248619047127835, 0.19248619047127835, 0.19248619047127835, 0.2224164836337834, 0.2224164836337834, 0.2224164836337834, 0.8084067756056879, 0.8084067756056879, 0.8084067756056879, 0.15588354417921235, 0.15588354417921235, 0.15588354417921235, 0.1742281978290262, 0.1742281978290262, 0.1742281978290262, 0.6500206669156496, 0.6500206669156496, 0.6500206669156496, 0.7050444634982966, 0.7050444634982966, 0.7050444634982966, 0.15497581069943478, 0.15497581069943478, 0.15497581069943478, 0.18617350435748836, 0.18617350435748836, 0.18617350435748836, 0.18054460663334937, 0.18054460663334937, 0.18054460663334937, 0.18721241210426065, 0.18721241210426065, 0.18721241210426065, 0.09640251325573079, 0.09640251325573079, 0.09640251325573079, 0.09149027033488177, 0.09149027033488177, 0.09149027033488177, 0.0869896997053029, 0.0869896997053029, 0.0869896997053029]}, "mutation_prompt": null}
{"id": "ea20c287-2966-434a-87ef-63c24cc6ff5f", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 1.8  # Reduced from 2.0\n        self.quantum_prob = 0.2  # Reduced from 0.25\n        self.elite_quantum_prob = 0.2  # Increased from 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced from 0.2\n        self.de_mutation_factor = 0.9  # Increased from 0.85\n        self.de_crossover_rate = 0.8  # Reduced from 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.3\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumInspiredDSO", "description": "Adaptive Quantum-Inspired Differential Swarm Optimization with dynamic velocity scaling and strategic elite exploration.", "configspace": "", "generation": 90, "fitness": 0.362490671590862, "feedback": "The algorithm AdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8515028008687267, 0.8515028008687267, 0.8515028008687267, 0.8430944654872646, 0.8430944654872646, 0.8430944654872646, 0.8585155631132877, 0.8585155631132877, 0.8585155631132877, 0.5523762457466057, 0.5523762457466057, 0.5523762457466057, 0.579965997711676, 0.579965997711676, 0.579965997711676, 0.5705137584826486, 0.5705137584826486, 0.5705137584826486, 0.12064982191960005, 0.12064982191960005, 0.12064982191960005, 0.10677722597335793, 0.10677722597335793, 0.10677722597335793, 0.14029161992444372, 0.14029161992444372, 0.14029161992444372, 0.09005425288153257, 0.09005425288153257, 0.09005425288153257, 0.06495274869446799, 0.06495274869446799, 0.06495274869446799, 0.1340027688649681, 0.1340027688649681, 0.1340027688649681, 0.9643300080893753, 0.9643300080893753, 0.9643300080893753, 0.9499783370211996, 0.9499783370211996, 0.9499783370211996, 0.9575186819850299, 0.9575186819850299, 0.9575186819850299, 0.6738440302994528, 0.6738440302994528, 0.6738440302994528, 0.5056290422907721, 0.5056290422907721, 0.5056290422907721, 0.66829599414559, 0.66829599414559, 0.66829599414559, 0.22483809766237384, 0.22483809766237384, 0.22483809766237384, 0.21096663021220152, 0.21096663021220152, 0.21096663021220152, 0.8012773905657218, 0.8012773905657218, 0.8012773905657218, 0.6173405239640342, 0.6173405239640342, 0.6173405239640342, 0.39493912882185267, 0.39493912882185267, 0.39493912882185267, 0.6992934981584611, 0.6992934981584611, 0.6992934981584611, 0.37375838697875463, 0.37375838697875463, 0.37375838697875463, 0.5984738540707351, 0.5984738540707351, 0.5984738540707351, 0.1317724513471803, 0.1317724513471803, 0.1317724513471803, 0.0946421234356507, 0.0946421234356507, 0.0946421234356507, 0.09576491138484167, 0.09576491138484167, 0.09576491138484167, 0.27469498637235656, 0.27469498637235656, 0.27469498637235656, 0.23509599673224368, 0.23509599673224368, 0.23509599673224368, 0.24874915318449675, 0.24874915318449675, 0.24874915318449675, 0.6502517449268408, 0.6502517449268408, 0.6502517449268408, 0.3412000045885111, 0.3412000045885111, 0.3412000045885111, 0.07441706378632695, 0.07441706378632695, 0.07441706378632695, 0.2093710833721888, 0.2093710833721888, 0.2093710833721888, 0.2485749438431818, 0.2485749438431818, 0.2485749438431818, 0.198619428641291, 0.198619428641291, 0.198619428641291, 0.48001672435323794, 0.48001672435323794, 0.48001672435323794, 0.7475165919737159, 0.7475165919737159, 0.7475165919737159, 0.6676937878127138, 0.6676937878127138, 0.6676937878127138, 0.6773234862609164, 0.6773234862609164, 0.6773234862609164, 0.15652748745454026, 0.15652748745454026, 0.15652748745454026, 0.14259982494962864, 0.14259982494962864, 0.14259982494962864, 0.08189000262253232, 0.08189000262253232, 0.08189000262253232, 0.27445916820359384, 0.27445916820359384, 0.27445916820359384, 0.26654532091884586, 0.26654532091884586, 0.26654532091884586, 0.22103450981019757, 0.22103450981019757, 0.22103450981019757, 0.4573730328354556, 0.4573730328354556, 0.4573730328354556, 0.25588124238328414, 0.25588124238328414, 0.25588124238328414, 0.4819010095492112, 0.4819010095492112, 0.4819010095492112, 0.27220329195821014, 0.27220329195821014, 0.27220329195821014, 0.2777748980427708, 0.2777748980427708, 0.2777748980427708, 0.29447187197034363, 0.29447187197034363, 0.29447187197034363, 0.2193756499747639, 0.2193756499747639, 0.2193756499747639, 0.2536033934900743, 0.2536033934900743, 0.2536033934900743, 0.20695451038060286, 0.20695451038060286, 0.20695451038060286, 0.2016683704400064, 0.2016683704400064, 0.2016683704400064, 0.17755063393526527, 0.17755063393526527, 0.17755063393526527, 0.19715456196629144, 0.19715456196629144, 0.19715456196629144, 0.9095330812819259, 0.9095330812819259, 0.9095330812819259, 0.15813256437612488, 0.15813256437612488, 0.15813256437612488, 0.17628564740733987, 0.17628564740733987, 0.17628564740733987, 0.16886978798425512, 0.16886978798425512, 0.16886978798425512, 0.2114018873231034, 0.2114018873231034, 0.2114018873231034, 0.15468882730269284, 0.15468882730269284, 0.15468882730269284, 0.22718443010898215, 0.22718443010898215, 0.22718443010898215, 0.2400251541448517, 0.2400251541448517, 0.2400251541448517, 0.21377771326588313, 0.21377771326588313, 0.21377771326588313, 0.09264175438968181, 0.09264175438968181, 0.09264175438968181, 0.09858580770615932, 0.09858580770615932, 0.09858580770615932, 0.08034756241562013, 0.08034756241562013, 0.08034756241562013]}, "mutation_prompt": null}
{"id": "00bad32d-77f8-4eab-8db3-06a1c9bcd0a6", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.4  # Slightly increased for better exploration\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.2  # Increased to emphasize elite particles\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased to allow faster convergence\n        self.de_mutation_factor = 0.9  # Increased for more aggressive differential mutation\n        self.de_crossover_rate = 0.85  # Slightly decreased to focus on the best features\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.max_velocity, self.max_velocity, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia_weight = self.inertia - (eval_count / self.budget) * 0.4  # Dynamic inertia adjustment\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_idxs = np.argsort(personal_best_values)[:3]  # Select top 3 particles\n                    elite_position = personal_best_positions[np.random.choice(elite_idxs)] + np.random.randn(self.dim)\n                    elite_position = np.clip(elite_position, self.lb, self.ub)\n                    elite_value = func(elite_position)\n                    eval_count += 1\n                    if elite_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_position\n                        personal_best_values[i] = elite_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia_weight * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "AdaptiveQuantumInspiredDSO", "description": "Adaptive Quantum-Inspired Differential Swarm Optimization with dynamic parameter tuning and multi-elite particle influence.", "configspace": "", "generation": 91, "fitness": 0.3595184109402723, "feedback": "The algorithm AdaptiveQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8319723472918468, 0.8319723472918468, 0.8319723472918468, 0.8177856882149211, 0.8177856882149211, 0.8177856882149211, 0.8335725066565666, 0.8335725066565666, 0.8335725066565666, 0.6316560764940715, 0.6316560764940715, 0.6316560764940715, 0.6081904738833737, 0.6081904738833737, 0.6081904738833737, 0.571731850802479, 0.571731850802479, 0.571731850802479, 0.11594797876818919, 0.11594797876818919, 0.11594797876818919, 0.14681840460925155, 0.14681840460925155, 0.14681840460925155, 0.09941529761241619, 0.09941529761241619, 0.09941529761241619, 0.1071838951712838, 0.1071838951712838, 0.1071838951712838, 0.10925410888531095, 0.10925410888531095, 0.10925410888531095, 0.09733122790990278, 0.09733122790990278, 0.09733122790990278, 0.9565706828635685, 0.9565706828635685, 0.9565706828635685, 0.9759232212780574, 0.9759232212780574, 0.9759232212780574, 0.9760326859236534, 0.9760326859236534, 0.9760326859236534, 0.6130610893550608, 0.6130610893550608, 0.6130610893550608, 0.5845482185778035, 0.5845482185778035, 0.5845482185778035, 0.656043498188956, 0.656043498188956, 0.656043498188956, 0.21577673128549957, 0.21577673128549957, 0.21577673128549957, 0.8551817309103165, 0.8551817309103165, 0.8551817309103165, 0.8414705161612189, 0.8414705161612189, 0.8414705161612189, 0.14070280708335592, 0.14070280708335592, 0.14070280708335592, 0.6295138300686978, 0.6295138300686978, 0.6295138300686978, 0.43901026960803224, 0.43901026960803224, 0.43901026960803224, 0.15734093761334011, 0.15734093761334011, 0.15734093761334011, 0.30416005629652276, 0.30416005629652276, 0.30416005629652276, 0.3509138836585959, 0.3509138836585959, 0.3509138836585959, 0.45725105741202365, 0.45725105741202365, 0.45725105741202365, 0.019234244976103043, 0.019234244976103043, 0.019234244976103043, 0.0031981006184192973, 0.0031981006184192973, 0.0031981006184192973, 0.2721023105207878, 0.2721023105207878, 0.2721023105207878, 0.23100942887912324, 0.23100942887912324, 0.23100942887912324, 0.031744807422586785, 0.031744807422586785, 0.031744807422586785, 0.04621082750975114, 0.04621082750975114, 0.04621082750975114, 0.07135531210966417, 0.07135531210966417, 0.07135531210966417, 0.13803133683220237, 0.13803133683220237, 0.13803133683220237, 0.2151692981847313, 0.2151692981847313, 0.2151692981847313, 0.32102929486652043, 0.32102929486652043, 0.32102929486652043, 0.08110888469011157, 0.08110888469011157, 0.08110888469011157, 0.7081814346530737, 0.7081814346530737, 0.7081814346530737, 0.6830888746375976, 0.6830888746375976, 0.6830888746375976, 0.6331841233624866, 0.6331841233624866, 0.6331841233624866, 0.1402735520771623, 0.1402735520771623, 0.1402735520771623, 0.10571496175440664, 0.10571496175440664, 0.10571496175440664, 0.13916227391518166, 0.13916227391518166, 0.13916227391518166, 0.31085462559817156, 0.31085462559817156, 0.31085462559817156, 0.2071786235087656, 0.2071786235087656, 0.2071786235087656, 0.2030838939479065, 0.2030838939479065, 0.2030838939479065, 0.3080565518438172, 0.3080565518438172, 0.3080565518438172, 0.370376242349834, 0.370376242349834, 0.370376242349834, 0.3343663923153434, 0.3343663923153434, 0.3343663923153434, 0.2634671100290963, 0.2634671100290963, 0.2634671100290963, 0.3584911259071907, 0.3584911259071907, 0.3584911259071907, 0.20964539191417086, 0.20964539191417086, 0.20964539191417086, 0.22180545979635158, 0.22180545979635158, 0.22180545979635158, 0.21392086559743861, 0.21392086559743861, 0.21392086559743861, 0.21434119799768214, 0.21434119799768214, 0.21434119799768214, 0.19779454561901344, 0.19779454561901344, 0.19779454561901344, 0.22024735306130105, 0.22024735306130105, 0.22024735306130105, 0.1998214399386944, 0.1998214399386944, 0.1998214399386944, 0.8954174942408983, 0.8954174942408983, 0.8954174942408983, 0.8926009043679692, 0.8926009043679692, 0.8926009043679692, 0.17522274561377615, 0.17522274561377615, 0.17522274561377615, 0.1552314364121805, 0.1552314364121805, 0.1552314364121805, 0.8790363072126371, 0.8790363072126371, 0.8790363072126371, 0.15563995796431007, 0.15563995796431007, 0.15563995796431007, 0.22319628087922494, 0.22319628087922494, 0.22319628087922494, 0.21805661241263452, 0.21805661241263452, 0.21805661241263452, 0.21335045227819227, 0.21335045227819227, 0.21335045227819227, 0.09203767669687002, 0.09203767669687002, 0.09203767669687002, 0.09857810552801982, 0.09857810552801982, 0.09857810552801982, 0.08934665507389128, 0.08934665507389128, 0.08934665507389128]}, "mutation_prompt": null}
{"id": "2e8f1dad-fb67-4bf9-aa4a-e3bf2bc8b676", "solution": "import numpy as np\n\nclass QuantumEnhancedDifferentialSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia_init = 0.9\n        self.inertia_final = 0.4\n        self.cognitive = 1.5\n        self.social = 1.5\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.1\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.8\n        self.de_crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia = (self.inertia_init - self.inertia_final) * ((self.budget - eval_count) / self.budget) + self.inertia_final\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedDifferentialSwarm", "description": "Quantum-Enhanced Differential Swarm with Stochastic Elite Reinforcement and Adaptive Inertia.", "configspace": "", "generation": 92, "fitness": 0.28238432679218123, "feedback": "The algorithm QuantumEnhancedDifferentialSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6824622270063012, 0.6824622270063012, 0.6824622270063012, 0.6952249107445048, 0.6952249107445048, 0.6952249107445048, 0.6966724886542404, 0.6966724886542404, 0.6966724886542404, 0.11115340639819404, 0.11115340639819404, 0.11115340639819404, 0.2911218648727967, 0.2911218648727967, 0.2911218648727967, 0.22119491986519701, 0.22119491986519701, 0.22119491986519701, 0.1257713862890132, 0.1257713862890132, 0.1257713862890132, 0.10814363522361314, 0.10814363522361314, 0.10814363522361314, 0.1229472765246572, 0.1229472765246572, 0.1229472765246572, 0.08767863591172353, 0.08767863591172353, 0.08767863591172353, 0.11866929079276911, 0.11866929079276911, 0.11866929079276911, 0.09155794762131941, 0.09155794762131941, 0.09155794762131941, 0.9620984160278724, 0.9620984160278724, 0.9620984160278724, 0.9553098523369279, 0.9553098523369279, 0.9553098523369279, 0.9651450289470513, 0.9651450289470513, 0.9651450289470513, 0.4553990921909412, 0.4553990921909412, 0.4553990921909412, 0.4972179098313486, 0.4972179098313486, 0.4972179098313486, 0.46581526124594874, 0.46581526124594874, 0.46581526124594874, 0.33540444273013403, 0.33540444273013403, 0.33540444273013403, 0.6228830710563394, 0.6228830710563394, 0.6228830710563394, 0.21906283597655718, 0.21906283597655718, 0.21906283597655718, 0.30763408695223493, 0.30763408695223493, 0.30763408695223493, 0.12503741066766816, 0.12503741066766816, 0.12503741066766816, 0.38988617722986374, 0.38988617722986374, 0.38988617722986374, 0.1749893517709672, 0.1749893517709672, 0.1749893517709672, 0.36944842507691533, 0.36944842507691533, 0.36944842507691533, 0.2677812323270229, 0.2677812323270229, 0.2677812323270229, 0.03839322361954434, 0.03839322361954434, 0.03839322361954434, 0.0923483404875256, 0.0923483404875256, 0.0923483404875256, 0.0013912223739888097, 0.0013912223739888097, 0.0013912223739888097, 0.13780856112014428, 0.13780856112014428, 0.13780856112014428, 0.263731306409845, 0.263731306409845, 0.263731306409845, 0.17983598610164975, 0.17983598610164975, 0.17983598610164975, 0.03524114222095631, 0.03524114222095631, 0.03524114222095631, 0.0830268203217096, 0.0830268203217096, 0.0830268203217096, 0.059924416051182594, 0.059924416051182594, 0.059924416051182594, 0.18044164744884106, 0.18044164744884106, 0.18044164744884106, 0.19552849360931346, 0.19552849360931346, 0.19552849360931346, 0.044633955902394384, 0.044633955902394384, 0.044633955902394384, 0.5556341895772988, 0.5556341895772988, 0.5556341895772988, 0.5406575464701808, 0.5406575464701808, 0.5406575464701808, 0.5193531541630863, 0.5193531541630863, 0.5193531541630863, 0.1261822830098538, 0.1261822830098538, 0.1261822830098538, 0.11991665557522369, 0.11991665557522369, 0.11991665557522369, 0.11217089289402815, 0.11217089289402815, 0.11217089289402815, 0.3538105197392747, 0.3538105197392747, 0.3538105197392747, 0.19008554690157187, 0.19008554690157187, 0.19008554690157187, 0.22687992545718405, 0.22687992545718405, 0.22687992545718405, 0.23819788372952466, 0.23819788372952466, 0.23819788372952466, 0.26475523461231565, 0.26475523461231565, 0.26475523461231565, 0.36594163473406627, 0.36594163473406627, 0.36594163473406627, 0.22079787071361912, 0.22079787071361912, 0.22079787071361912, 0.20998573446775393, 0.20998573446775393, 0.20998573446775393, 0.23013365454788803, 0.23013365454788803, 0.23013365454788803, 0.2045522351318766, 0.2045522351318766, 0.2045522351318766, 0.20743137105902265, 0.20743137105902265, 0.20743137105902265, 0.2150761914395254, 0.2150761914395254, 0.2150761914395254, 0.20200227863159892, 0.20200227863159892, 0.20200227863159892, 0.20067115578694794, 0.20067115578694794, 0.20067115578694794, 0.20111320255121423, 0.20111320255121423, 0.20111320255121423, 0.8162618986973977, 0.8162618986973977, 0.8162618986973977, 0.1580481274825124, 0.1580481274825124, 0.1580481274825124, 0.17627499004666247, 0.17627499004666247, 0.17627499004666247, 0.688453278923556, 0.688453278923556, 0.688453278923556, 0.20938686704346543, 0.20938686704346543, 0.20938686704346543, 0.1673706854941982, 0.1673706854941982, 0.1673706854941982, 0.18101741525383186, 0.18101741525383186, 0.18101741525383186, 0.18928029695515536, 0.18928029695515536, 0.18928029695515536, 0.1901560481740896, 0.1901560481740896, 0.1901560481740896, 0.0982932641989901, 0.0982932641989901, 0.0982932641989901, 0.08251225194032397, 0.08251225194032397, 0.08251225194032397, 0.09125154369459265, 0.09125154369459265, 0.09125154369459265]}, "mutation_prompt": null}
{"id": "72e27d78-312d-4d18-a37f-1b41977ba944", "solution": "import numpy as np\n\nclass QuantumEnhancedDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # Increased particle number\n        self.inertia = 0.7  # Adjusted inertia weight\n        self.cognitive = 1.5  # Adjusted cognitive component\n        self.social = 1.5  # Adjusted social component\n        self.quantum_prob = 0.2  # Adjusted quantum probability\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.9  # Adjusted mutation factor\n        self.de_crossover_rate = 0.7  # Adjusted crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumEnhancedDSO", "description": "Quantum-Enhanced Differential Swarm Optimization with adaptive velocity update and population diversity reinforcement.", "configspace": "", "generation": 93, "fitness": 0.30658557962368344, "feedback": "The algorithm QuantumEnhancedDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.78541910440041, 0.78541910440041, 0.78541910440041, 0.7741734533434977, 0.7741734533434977, 0.7741734533434977, 0.7522746804224418, 0.7522746804224418, 0.7522746804224418, 0.280851447636317, 0.280851447636317, 0.280851447636317, 0.33357285765621447, 0.33357285765621447, 0.33357285765621447, 0.37906478110038544, 0.37906478110038544, 0.37906478110038544, 0.1149015471819208, 0.1149015471819208, 0.1149015471819208, 0.1537134869106167, 0.1537134869106167, 0.1537134869106167, 0.1177836063858193, 0.1177836063858193, 0.1177836063858193, 0.12997764963390313, 0.12997764963390313, 0.12997764963390313, 0.09036967472844348, 0.09036967472844348, 0.09036967472844348, 0.1088542850037888, 0.1088542850037888, 0.1088542850037888, 0.9685032308149739, 0.9685032308149739, 0.9685032308149739, 0.9649412404506332, 0.9649412404506332, 0.9649412404506332, 0.9540880300764925, 0.9540880300764925, 0.9540880300764925, 0.4417212476621549, 0.4417212476621549, 0.4417212476621549, 0.439842043323876, 0.439842043323876, 0.439842043323876, 0.46378103964981554, 0.46378103964981554, 0.46378103964981554, 0.828606372178981, 0.828606372178981, 0.828606372178981, 0.21805023176570315, 0.21805023176570315, 0.21805023176570315, 0.2330451351077787, 0.2330451351077787, 0.2330451351077787, 0.12967102655766471, 0.12967102655766471, 0.12967102655766471, 0.2938026655861251, 0.2938026655861251, 0.2938026655861251, 0.41149890743014517, 0.41149890743014517, 0.41149890743014517, 0.35257586605535973, 0.35257586605535973, 0.35257586605535973, 0.3511298169516295, 0.3511298169516295, 0.3511298169516295, 0.13104723323556977, 0.13104723323556977, 0.13104723323556977, 0.07136294654820863, 0.07136294654820863, 0.07136294654820863, 0.14986429509191168, 0.14986429509191168, 0.14986429509191168, 0.10764239236455542, 0.10764239236455542, 0.10764239236455542, 0.27639857588575345, 0.27639857588575345, 0.27639857588575345, 0.1568119322659557, 0.1568119322659557, 0.1568119322659557, 0.22191988572717303, 0.22191988572717303, 0.22191988572717303, 0.07475001814694515, 0.07475001814694515, 0.07475001814694515, 0.07044544555851806, 0.07044544555851806, 0.07044544555851806, 0.09851759856130626, 0.09851759856130626, 0.09851759856130626, 0.14600913271371663, 0.14600913271371663, 0.14600913271371663, 0.03719320227226619, 0.03719320227226619, 0.03719320227226619, 0.05187958402093773, 0.05187958402093773, 0.05187958402093773, 0.5621770179630495, 0.5621770179630495, 0.5621770179630495, 0.5383614396051192, 0.5383614396051192, 0.5383614396051192, 0.5353188422665235, 0.5353188422665235, 0.5353188422665235, 0.09248654659651512, 0.09248654659651512, 0.09248654659651512, 0.13736461717148218, 0.13736461717148218, 0.13736461717148218, 0.12303646374784893, 0.12303646374784893, 0.12303646374784893, 0.3923465109223203, 0.3923465109223203, 0.3923465109223203, 0.29357769893928254, 0.29357769893928254, 0.29357769893928254, 0.37875394644526883, 0.37875394644526883, 0.37875394644526883, 0.24654538170479123, 0.24654538170479123, 0.24654538170479123, 0.43720508681209647, 0.43720508681209647, 0.43720508681209647, 0.4239473311461316, 0.4239473311461316, 0.4239473311461316, 0.22338868499587483, 0.22338868499587483, 0.22338868499587483, 0.3139336579633548, 0.3139336579633548, 0.3139336579633548, 0.15641604203532933, 0.15641604203532933, 0.15641604203532933, 0.2147023129985267, 0.2147023129985267, 0.2147023129985267, 0.24038111809265228, 0.24038111809265228, 0.24038111809265228, 0.20847570989761444, 0.20847570989761444, 0.20847570989761444, 0.2266418953363173, 0.2266418953363173, 0.2266418953363173, 0.19755697212979895, 0.19755697212979895, 0.19755697212979895, 0.21595105032573536, 0.21595105032573536, 0.21595105032573536, 0.8382425285443519, 0.8382425285443519, 0.8382425285443519, 0.15878039895250573, 0.15878039895250573, 0.15878039895250573, 0.16091208993079875, 0.16091208993079875, 0.16091208993079875, 0.7944561301244152, 0.7944561301244152, 0.7944561301244152, 0.21100348524698898, 0.21100348524698898, 0.21100348524698898, 0.15547662037494925, 0.15547662037494925, 0.15547662037494925, 0.18586058877560985, 0.18586058877560985, 0.18586058877560985, 0.2027433991802231, 0.2027433991802231, 0.2027433991802231, 0.23270746956370048, 0.23270746956370048, 0.23270746956370048, 0.09713044052085462, 0.09713044052085462, 0.09713044052085462, 0.0937173973093326, 0.0937173973093326, 0.0937173973093326, 0.1185071868779336, 0.1185071868779336, 0.1185071868779336]}, "mutation_prompt": null}
{"id": "52847c32-55ba-4950-a46c-e2587f63a16c", "solution": "import numpy as np\n\nclass QuantumSwarmEnhancedParticleOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50  # changed to 50 for more exploration\n        self.inertia_max = 0.8   # Maximum inertia weight\n        self.inertia_min = 0.3   # Minimum inertia weight\n        self.cognitive = 1.5     # increased for stronger personal attraction\n        self.social = 1.5        # adjusted for better convergence balance\n        self.quantum_prob = 0.3  # increased probability for quantum jump\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # increased to 0.3\n        self.de_mutation_factor = 0.9  # adjusted for better diversity\n        self.de_crossover_rate = 0.95  # slightly higher for more aggressive DE\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            inertia = self.inertia_max - (self.inertia_max - self.inertia_min) * (eval_count / self.budget)\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumSwarmEnhancedParticleOptimization", "description": "Quantum Swarm-enhanced Particle Optimization (QSPO) with dynamic inertia and adaptive local-global balance for improved convergence.", "configspace": "", "generation": 94, "fitness": 0.2861026233982616, "feedback": "The algorithm QuantumSwarmEnhancedParticleOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.6960266104377235, 0.6960266104377235, 0.6960266104377235, 0.6936231903959094, 0.6936231903959094, 0.6936231903959094, 0.7039043662631346, 0.7039043662631346, 0.7039043662631346, 0.28749450747455596, 0.28749450747455596, 0.28749450747455596, 0.25968790072811376, 0.25968790072811376, 0.25968790072811376, 0.008818388809794131, 0.008818388809794131, 0.008818388809794131, 0.13284300142881256, 0.13284300142881256, 0.13284300142881256, 0.10415794311399673, 0.10415794311399673, 0.10415794311399673, 0.1426128523226422, 0.1426128523226422, 0.1426128523226422, 0.10545773136468761, 0.10545773136468761, 0.10545773136468761, 0.08218971843435197, 0.08218971843435197, 0.08218971843435197, 0.10122716469388615, 0.10122716469388615, 0.10122716469388615, 0.9542007944176449, 0.9542007944176449, 0.9542007944176449, 0.970131386459494, 0.970131386459494, 0.970131386459494, 0.959876408008194, 0.959876408008194, 0.959876408008194, 0.45836263447337655, 0.45836263447337655, 0.45836263447337655, 0.4987336544627541, 0.4987336544627541, 0.4987336544627541, 0.48061843223386536, 0.48061843223386536, 0.48061843223386536, 0.5978807987185949, 0.5978807987185949, 0.5978807987185949, 0.2721972444695564, 0.2721972444695564, 0.2721972444695564, 0.22558306106218673, 0.22558306106218673, 0.22558306106218673, 0.3184219810390062, 0.3184219810390062, 0.3184219810390062, 0.3247925988704061, 0.3247925988704061, 0.3247925988704061, 0.24389590202665956, 0.24389590202665956, 0.24389590202665956, 0.43362478261066795, 0.43362478261066795, 0.43362478261066795, 0.22812691689454423, 0.22812691689454423, 0.22812691689454423, 0.21077211573909516, 0.21077211573909516, 0.21077211573909516, 0.07289376465509179, 0.07289376465509179, 0.07289376465509179, 0.050511425314532565, 0.050511425314532565, 0.050511425314532565, 0.07992468134986319, 0.07992468134986319, 0.07992468134986319, 0.1862807011528852, 0.1862807011528852, 0.1862807011528852, 0.11639645817294053, 0.11639645817294053, 0.11639645817294053, 0.25778072447213074, 0.25778072447213074, 0.25778072447213074, 0.13447487639306477, 0.13447487639306477, 0.13447487639306477, 0.3241467673373245, 0.3241467673373245, 0.3241467673373245, 0.047857163231719846, 0.047857163231719846, 0.047857163231719846, 0.25059193176777717, 0.25059193176777717, 0.25059193176777717, 0.27241606567852594, 0.27241606567852594, 0.27241606567852594, 0.07156912107909252, 0.07156912107909252, 0.07156912107909252, 0.5989477643971843, 0.5989477643971843, 0.5989477643971843, 0.5988479434587236, 0.5988479434587236, 0.5988479434587236, 0.5805278116772321, 0.5805278116772321, 0.5805278116772321, 0.12727318005658894, 0.12727318005658894, 0.12727318005658894, 0.15231272618674863, 0.15231272618674863, 0.15231272618674863, 0.1239436119008882, 0.1239436119008882, 0.1239436119008882, 0.22932652374089058, 0.22932652374089058, 0.22932652374089058, 0.16833865213571664, 0.16833865213571664, 0.16833865213571664, 0.20215011338679578, 0.20215011338679578, 0.20215011338679578, 0.3511937231918869, 0.3511937231918869, 0.3511937231918869, 0.3236280795681604, 0.3236280795681604, 0.3236280795681604, 0.28841306813475953, 0.28841306813475953, 0.28841306813475953, 0.22216447274435946, 0.22216447274435946, 0.22216447274435946, 0.21956591406054116, 0.21956591406054116, 0.21956591406054116, 0.2240770774978793, 0.2240770774978793, 0.2240770774978793, 0.21900155830209456, 0.21900155830209456, 0.21900155830209456, 0.22208022349079182, 0.22208022349079182, 0.22208022349079182, 0.24087362584289873, 0.24087362584289873, 0.24087362584289873, 0.18853068825581554, 0.18853068825581554, 0.18853068825581554, 0.1806332160226144, 0.1806332160226144, 0.1806332160226144, 0.18425565331727278, 0.18425565331727278, 0.18425565331727278, 0.854069751888577, 0.854069751888577, 0.854069751888577, 0.15687702738161857, 0.15687702738161857, 0.15687702738161857, 0.16882975436893177, 0.16882975436893177, 0.16882975436893177, 0.16695403478656645, 0.16695403478656645, 0.16695403478656645, 0.20859823955974066, 0.20859823955974066, 0.20859823955974066, 0.15556586034251962, 0.15556586034251962, 0.15556586034251962, 0.18767273448765365, 0.18767273448765365, 0.18767273448765365, 0.1878158430820499, 0.1878158430820499, 0.1878158430820499, 0.21633127086162562, 0.21633127086162562, 0.21633127086162562, 0.08941500920111412, 0.08941500920111412, 0.08941500920111412, 0.0983367195883944, 0.0983367195883944, 0.0983367195883944, 0.10273124419759638, 0.10273124419759638, 0.10273124419759638]}, "mutation_prompt": null}
{"id": "5f9da9c7-16d9-4927-845e-1c2d7d73dca2", "solution": "import numpy as np\n\nclass QuantumDifferentialPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 50\n        self.inertia = 0.6\n        self.cognitive = 1.5\n        self.social = 1.9\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 0.5, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 0.5, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumDifferentialPSO", "description": "Quantum Differential Particle Swarm Optimization with dynamic swarm adaptation and enhanced quantum mutation.", "configspace": "", "generation": 95, "fitness": 0.315006169034623, "feedback": "The algorithm QuantumDifferentialPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7448771916682412, 0.7448771916682412, 0.7448771916682412, 0.7182258340041348, 0.7182258340041348, 0.7182258340041348, 0.733797636626182, 0.733797636626182, 0.733797636626182, 0.2146267150322091, 0.2146267150322091, 0.2146267150322091, 0.3292709770972845, 0.3292709770972845, 0.3292709770972845, 0.23972124520270266, 0.23972124520270266, 0.23972124520270266, 0.1191137777700425, 0.1191137777700425, 0.1191137777700425, 0.11464282908843959, 0.11464282908843959, 0.11464282908843959, 0.12357898532183986, 0.12357898532183986, 0.12357898532183986, 0.10424075052843251, 0.10424075052843251, 0.10424075052843251, 0.1016743750821375, 0.1016743750821375, 0.1016743750821375, 0.08907223077413529, 0.08907223077413529, 0.08907223077413529, 0.9629686897331708, 0.9629686897331708, 0.9629686897331708, 0.9637483557002317, 0.9637483557002317, 0.9637483557002317, 0.9626967054720107, 0.9626967054720107, 0.9626967054720107, 0.49685219207541165, 0.49685219207541165, 0.49685219207541165, 0.5107326551825755, 0.5107326551825755, 0.5107326551825755, 0.4897416513937588, 0.4897416513937588, 0.4897416513937588, 0.7911085296788887, 0.7911085296788887, 0.7911085296788887, 0.2719372926065463, 0.2719372926065463, 0.2719372926065463, 0.8138604083180218, 0.8138604083180218, 0.8138604083180218, 0.42613345781205303, 0.42613345781205303, 0.42613345781205303, 0.30270135080701666, 0.30270135080701666, 0.30270135080701666, 0.5130586479047798, 0.5130586479047798, 0.5130586479047798, 0.3326411414804826, 0.3326411414804826, 0.3326411414804826, 0.36708558684549364, 0.36708558684549364, 0.36708558684549364, 0.333286886274344, 0.333286886274344, 0.333286886274344, 0.10746518473359634, 0.10746518473359634, 0.10746518473359634, 0.2506248302784345, 0.2506248302784345, 0.2506248302784345, 0.055987875002384335, 0.055987875002384335, 0.055987875002384335, 0.28116275531534785, 0.28116275531534785, 0.28116275531534785, 0.06836609928247894, 0.06836609928247894, 0.06836609928247894, 0.2842268667762152, 0.2842268667762152, 0.2842268667762152, 0.060819275413860674, 0.060819275413860674, 0.060819275413860674, 0.08730597542864194, 0.08730597542864194, 0.08730597542864194, 0.1890698013315809, 0.1890698013315809, 0.1890698013315809, 0.17611535923447774, 0.17611535923447774, 0.17611535923447774, 0.0649294531456408, 0.0649294531456408, 0.0649294531456408, 0.15234556305298685, 0.15234556305298685, 0.15234556305298685, 0.5644146098007521, 0.5644146098007521, 0.5644146098007521, 0.5972017802744913, 0.5972017802744913, 0.5972017802744913, 0.5611377511136171, 0.5611377511136171, 0.5611377511136171, 0.11113469317137481, 0.11113469317137481, 0.11113469317137481, 0.11929015600712733, 0.11929015600712733, 0.11929015600712733, 0.09138937252770407, 0.09138937252770407, 0.09138937252770407, 0.3077844272803595, 0.3077844272803595, 0.3077844272803595, 0.35516169119988894, 0.35516169119988894, 0.35516169119988894, 0.4763721586775145, 0.4763721586775145, 0.4763721586775145, 0.2584887304810626, 0.2584887304810626, 0.2584887304810626, 0.3661333506493427, 0.3661333506493427, 0.3661333506493427, 0.36097279126814896, 0.36097279126814896, 0.36097279126814896, 0.20012395611782685, 0.20012395611782685, 0.20012395611782685, 0.21388769932513896, 0.21388769932513896, 0.21388769932513896, 0.17964374766458657, 0.17964374766458657, 0.17964374766458657, 0.2434292642755871, 0.2434292642755871, 0.2434292642755871, 0.20219884758080464, 0.20219884758080464, 0.20219884758080464, 0.21528354569142427, 0.21528354569142427, 0.21528354569142427, 0.2033923856431622, 0.2033923856431622, 0.2033923856431622, 0.2057839493275343, 0.2057839493275343, 0.2057839493275343, 0.3068926122408232, 0.3068926122408232, 0.3068926122408232, 0.8559155101237081, 0.8559155101237081, 0.8559155101237081, 0.15896808349714464, 0.15896808349714464, 0.15896808349714464, 0.16964543759966633, 0.16964543759966633, 0.16964543759966633, 0.1678137342147571, 0.1678137342147571, 0.1678137342147571, 0.21151882397013422, 0.21151882397013422, 0.21151882397013422, 0.15580822285129892, 0.15580822285129892, 0.15580822285129892, 0.18130460719779817, 0.18130460719779817, 0.18130460719779817, 0.19557355496852558, 0.19557355496852558, 0.19557355496852558, 0.1952613526081013, 0.1952613526081013, 0.1952613526081013, 0.08487918708108777, 0.08487918708108777, 0.08487918708108777, 0.09477248894869139, 0.09477248894869139, 0.09477248894869139, 0.11905050863745181, 0.11905050863745181, 0.11905050863745181]}, "mutation_prompt": null}
{"id": "558d228e-9f89-40d7-98a1-1647ee3178ac", "solution": "import numpy as np\n\nclass QuantumDifferentialSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6\n        self.cognitive = 1.5\n        self.social = 2.2\n        self.quantum_prob = 0.3\n        self.elite_quantum_prob = 0.2\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3\n        self.de_mutation_factor = 0.9\n        self.de_crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.normal(0, 1, self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.normal(0, 1, self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "QuantumDifferentialSwarmOptimization", "description": "Quantum-Inspired Differential Swarm Optimization with adaptive strategies, including quantum jumps, elite reinforcement, and adaptive mutation.", "configspace": "", "generation": 96, "fitness": 0.3086835235620158, "feedback": "The algorithm QuantumDifferentialSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7285249100534724, 0.7285249100534724, 0.7285249100534724, 0.7363936840806737, 0.7363936840806737, 0.7363936840806737, 0.728557723403484, 0.728557723403484, 0.728557723403484, 0.2727170289330946, 0.2727170289330946, 0.2727170289330946, 0.3856026216265428, 0.3856026216265428, 0.3856026216265428, 0.34320963490058476, 0.34320963490058476, 0.34320963490058476, 0.14232512758839877, 0.14232512758839877, 0.14232512758839877, 0.12404568816547357, 0.12404568816547357, 0.12404568816547357, 0.11757135049815037, 0.11757135049815037, 0.11757135049815037, 0.0913584598149022, 0.0913584598149022, 0.0913584598149022, 0.0882269143894635, 0.0882269143894635, 0.0882269143894635, 0.1341596529199902, 0.1341596529199902, 0.1341596529199902, 0.9335947573351031, 0.9335947573351031, 0.9335947573351031, 0.977529581330039, 0.977529581330039, 0.977529581330039, 0.9843876491665415, 0.9843876491665415, 0.9843876491665415, 0.436737010038065, 0.436737010038065, 0.436737010038065, 0.43622985850218265, 0.43622985850218265, 0.43622985850218265, 0.4482106572932356, 0.4482106572932356, 0.4482106572932356, 0.7876856743111202, 0.7876856743111202, 0.7876856743111202, 0.7612833194331724, 0.7612833194331724, 0.7612833194331724, 0.2310502525764797, 0.2310502525764797, 0.2310502525764797, 0.12948876802259968, 0.12948876802259968, 0.12948876802259968, 0.29479101557001064, 0.29479101557001064, 0.29479101557001064, 0.13074340018169206, 0.13074340018169206, 0.13074340018169206, 0.12803273907673884, 0.12803273907673884, 0.12803273907673884, 0.3791092839468131, 0.3791092839468131, 0.3791092839468131, 0.39849303139801906, 0.39849303139801906, 0.39849303139801906, 0.05361045871490877, 0.05361045871490877, 0.05361045871490877, 0.05609648376841647, 0.05609648376841647, 0.05609648376841647, 0.21112394824096736, 0.21112394824096736, 0.21112394824096736, 0.2883446786596081, 0.2883446786596081, 0.2883446786596081, 0.0857764457127399, 0.0857764457127399, 0.0857764457127399, 0.1610428908115058, 0.1610428908115058, 0.1610428908115058, 0.04160574141797846, 0.04160574141797846, 0.04160574141797846, 0.2391119968662948, 0.2391119968662948, 0.2391119968662948, 0.07884165951487154, 0.07884165951487154, 0.07884165951487154, 0.23152487881744466, 0.23152487881744466, 0.23152487881744466, 0.3108077997050803, 0.3108077997050803, 0.3108077997050803, 0.19485533441317782, 0.19485533441317782, 0.19485533441317782, 0.6385732808148643, 0.6385732808148643, 0.6385732808148643, 0.6324835581453714, 0.6324835581453714, 0.6324835581453714, 0.5631099951304886, 0.5631099951304886, 0.5631099951304886, 0.11425044851104338, 0.11425044851104338, 0.11425044851104338, 0.10591878175129787, 0.10591878175129787, 0.10591878175129787, 0.11217030307501685, 0.11217030307501685, 0.11217030307501685, 0.24913047862970883, 0.24913047862970883, 0.24913047862970883, 0.23395791664112042, 0.23395791664112042, 0.23395791664112042, 0.2566106891667408, 0.2566106891667408, 0.2566106891667408, 0.2774064744921404, 0.2774064744921404, 0.2774064744921404, 0.3697462444938425, 0.3697462444938425, 0.3697462444938425, 0.23513032485609597, 0.23513032485609597, 0.23513032485609597, 0.3378361558891173, 0.3378361558891173, 0.3378361558891173, 0.2527822752818547, 0.2527822752818547, 0.2527822752818547, 0.2543994983828848, 0.2543994983828848, 0.2543994983828848, 0.1992312632899108, 0.1992312632899108, 0.1992312632899108, 0.21938239533089687, 0.21938239533089687, 0.21938239533089687, 0.2383727348074114, 0.2383727348074114, 0.2383727348074114, 0.19088643978065023, 0.19088643978065023, 0.19088643978065023, 0.24085870911694507, 0.24085870911694507, 0.24085870911694507, 0.5694808250621067, 0.5694808250621067, 0.5694808250621067, 0.8876875967698725, 0.8876875967698725, 0.8876875967698725, 0.1577622202955219, 0.1577622202955219, 0.1577622202955219, 0.19742273952331157, 0.19742273952331157, 0.19742273952331157, 0.16808640253185037, 0.16808640253185037, 0.16808640253185037, 0.20994416178996644, 0.20994416178996644, 0.20994416178996644, 0.153535714245575, 0.153535714245575, 0.153535714245575, 0.19667826099630215, 0.19667826099630215, 0.19667826099630215, 0.1962016173596327, 0.1962016173596327, 0.1962016173596327, 0.19968370069896346, 0.19968370069896346, 0.19968370069896346, 0.08578244926907186, 0.08578244926907186, 0.08578244926907186, 0.09126315860223333, 0.09126315860223333, 0.09126315860223333, 0.08664477053429143, 0.08664477053429143, 0.08664477053429143]}, "mutation_prompt": null}
{"id": "d9f8a9f6-39fc-488e-ae27-11480d07fe44", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.3\n        self.social = 2.0\n        self.quantum_prob = 0.25\n        self.elite_quantum_prob = 0.15\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.2\n        self.de_mutation_factor = 0.85\n        self.de_crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Enhanced Quantum-Inspired Differential Swarm Optimization with adaptive velocity control and elite particle reinforcement.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8321186788849009, 0.8321186788849009, 0.8321186788849009, 0.8077373703110324, 0.8077373703110324, 0.8077373703110324, 0.8230672540546263, 0.8230672540546263, 0.8230672540546263, 0.5116669950722281, 0.5116669950722281, 0.5116669950722281, 0.5661560136612218, 0.5661560136612218, 0.5661560136612218, 0.6113058189557582, 0.6113058189557582, 0.6113058189557582, 0.15980213110663188, 0.15980213110663188, 0.15980213110663188, 0.15836379454087035, 0.15836379454087035, 0.15836379454087035, 0.10700891265479351, 0.10700891265479351, 0.10700891265479351, 0.12732956032599918, 0.12732956032599918, 0.12732956032599918, 0.06905195301446476, 0.06905195301446476, 0.06905195301446476, 0.1345013716819694, 0.1345013716819694, 0.1345013716819694, 0.9591111998970985, 0.9591111998970985, 0.9591111998970985, 0.9585593447047763, 0.9585593447047763, 0.9585593447047763, 0.9574263685928593, 0.9574263685928593, 0.9574263685928593, 0.6364651002009667, 0.6364651002009667, 0.6364651002009667, 0.6951144370755298, 0.6951144370755298, 0.6951144370755298, 0.6686499429390589, 0.6686499429390589, 0.6686499429390589, 0.8100450310483559, 0.8100450310483559, 0.8100450310483559, 0.2191433915634472, 0.2191433915634472, 0.2191433915634472, 0.35535998298566196, 0.35535998298566196, 0.35535998298566196, 0.5982796272612709, 0.5982796272612709, 0.5982796272612709, 0.6415045173467162, 0.6415045173467162, 0.6415045173467162, 0.6398000470576843, 0.6398000470576843, 0.6398000470576843, 0.5428928671013161, 0.5428928671013161, 0.5428928671013161, 0.5642790632999215, 0.5642790632999215, 0.5642790632999215, 0.6524933627785994, 0.6524933627785994, 0.6524933627785994, 0.3320409711584029, 0.3320409711584029, 0.3320409711584029, 0.4064992272210587, 0.4064992272210587, 0.4064992272210587, 0.0032715883739258267, 0.0032715883739258267, 0.0032715883739258267, 0.5339891197626435, 0.5339891197626435, 0.5339891197626435, 0.17748082363632034, 0.17748082363632034, 0.17748082363632034, 0.6205554758644007, 0.6205554758644007, 0.6205554758644007, 0.12699739198808058, 0.12699739198808058, 0.12699739198808058, 0.20264865332135862, 0.20264865332135862, 0.20264865332135862, 0.10359900711219672, 0.10359900711219672, 0.10359900711219672, 0.17336943788479298, 0.17336943788479298, 0.17336943788479298, 0.03797532713121943, 0.03797532713121943, 0.03797532713121943, 0.055864185337872185, 0.055864185337872185, 0.055864185337872185, 0.7251167159474545, 0.7251167159474545, 0.7251167159474545, 0.6908898067973139, 0.6908898067973139, 0.6908898067973139, 0.7367565470019714, 0.7367565470019714, 0.7367565470019714, 0.13749820551805536, 0.13749820551805536, 0.13749820551805536, 0.1826801551718401, 0.1826801551718401, 0.1826801551718401, 0.12066259163666926, 0.12066259163666926, 0.12066259163666926, 0.202893140333395, 0.202893140333395, 0.202893140333395, 0.2314563184270485, 0.2314563184270485, 0.2314563184270485, 0.38954346630555825, 0.38954346630555825, 0.38954346630555825, 0.37502158564298227, 0.37502158564298227, 0.37502158564298227, 0.3059459622620033, 0.3059459622620033, 0.3059459622620033, 0.48969630406392073, 0.48969630406392073, 0.48969630406392073, 0.2480830354911986, 0.2480830354911986, 0.2480830354911986, 0.443672575036419, 0.443672575036419, 0.443672575036419, 0.1644781920745234, 0.1644781920745234, 0.1644781920745234, 0.2843285752980297, 0.2843285752980297, 0.2843285752980297, 0.22353751179202908, 0.22353751179202908, 0.22353751179202908, 0.23127309941644802, 0.23127309941644802, 0.23127309941644802, 0.7425618916612338, 0.7425618916612338, 0.7425618916612338, 0.20694529613164991, 0.20694529613164991, 0.20694529613164991, 0.19579955627160162, 0.19579955627160162, 0.19579955627160162, 0.9081391265722403, 0.9081391265722403, 0.9081391265722403, 0.15891442399030364, 0.15891442399030364, 0.15891442399030364, 0.17133278472820113, 0.17133278472820113, 0.17133278472820113, 0.20935471733507016, 0.20935471733507016, 0.20935471733507016, 0.21098447324252212, 0.21098447324252212, 0.21098447324252212, 0.8094593742775736, 0.8094593742775736, 0.8094593742775736, 0.2177271797225232, 0.2177271797225232, 0.2177271797225232, 0.24910938126412285, 0.24910938126412285, 0.24910938126412285, 0.2474734376703408, 0.2474734376703408, 0.2474734376703408, 0.09066702526169679, 0.09066702526169679, 0.09066702526169679, 0.08767401619723092, 0.08767401619723092, 0.08767401619723092, 0.09458529381324443, 0.09458529381324443, 0.09458529381324443]}, "mutation_prompt": null}
{"id": "ceb2de4f-e3b4-4443-b1de-5017751223fe", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.5\n        self.cognitive = 1.5  # Adjusted for better exploration\n        self.social = 1.8     # Adjusted for better exploration\n        self.quantum_prob = 0.3  # Increased for more quantum updates\n        self.elite_quantum_prob = 0.2  # Increased for more elite quantum updates\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.3  # Increased velocity limit\n        self.de_mutation_factor = 0.95  # Slightly increased mutation factor\n        self.de_crossover_rate = 0.85  # Adjusted crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim) * 0.5\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n                        \n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim) * 0.5\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n                    \n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n                    \n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "EnhancedQuantumInspiredDSO", "description": "Quantum-Inspired Differential Swarm Optimization with Adaptive Randomization and Two-Stage Elite Search for Enhanced Global Exploration.", "configspace": "", "generation": 98, "fitness": 0.3596592040368311, "feedback": "The algorithm EnhancedQuantumInspiredDSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.8295576450437003, 0.8295576450437003, 0.8295576450437003, 0.8157441192587561, 0.8157441192587561, 0.8157441192587561, 0.8233994330462828, 0.8233994330462828, 0.8233994330462828, 0.49155267706957684, 0.49155267706957684, 0.49155267706957684, 0.49049077617745174, 0.49049077617745174, 0.49049077617745174, 0.45548385155830173, 0.45548385155830173, 0.45548385155830173, 0.11631471703967344, 0.11631471703967344, 0.11631471703967344, 0.11064325103100858, 0.11064325103100858, 0.11064325103100858, 0.105333646667362, 0.105333646667362, 0.105333646667362, 0.09467907138125009, 0.09467907138125009, 0.09467907138125009, 0.07663426543394525, 0.07663426543394525, 0.07663426543394525, 0.10308991322358485, 0.10308991322358485, 0.10308991322358485, 0.9536856213628541, 0.9536856213628541, 0.9536856213628541, 0.962434255769311, 0.962434255769311, 0.962434255769311, 0.9656033385483812, 0.9656033385483812, 0.9656033385483812, 0.6460826934100208, 0.6460826934100208, 0.6460826934100208, 0.5928858411905218, 0.5928858411905218, 0.5928858411905218, 0.5894753574754178, 0.5894753574754178, 0.5894753574754178, 0.36869690912219066, 0.36869690912219066, 0.36869690912219066, 0.20908862738577205, 0.20908862738577205, 0.20908862738577205, 0.8014158618735913, 0.8014158618735913, 0.8014158618735913, 0.5506945309060856, 0.5506945309060856, 0.5506945309060856, 0.2934944340350232, 0.2934944340350232, 0.2934944340350232, 0.5124245382558392, 0.5124245382558392, 0.5124245382558392, 0.13056311634677786, 0.13056311634677786, 0.13056311634677786, 0.5432269135120246, 0.5432269135120246, 0.5432269135120246, 0.43429587597421626, 0.43429587597421626, 0.43429587597421626, 0.06543088988539691, 0.06543088988539691, 0.06543088988539691, 0.5163081674778958, 0.5163081674778958, 0.5163081674778958, 0.013383839200443837, 0.013383839200443837, 0.013383839200443837, 0.14322418993846353, 0.14322418993846353, 0.14322418993846353, 0.24710507179619035, 0.24710507179619035, 0.24710507179619035, 0.2912398343747522, 0.2912398343747522, 0.2912398343747522, 0.08200231063904961, 0.08200231063904961, 0.08200231063904961, 0.112724029314624, 0.112724029314624, 0.112724029314624, 0.1356172061105988, 0.1356172061105988, 0.1356172061105988, 0.2241825341062582, 0.2241825341062582, 0.2241825341062582, 0.2951462907515715, 0.2951462907515715, 0.2951462907515715, 0.08168763983580996, 0.08168763983580996, 0.08168763983580996, 0.723149527881293, 0.723149527881293, 0.723149527881293, 0.6644334833460854, 0.6644334833460854, 0.6644334833460854, 0.7348026740919733, 0.7348026740919733, 0.7348026740919733, 0.11087456928910466, 0.11087456928910466, 0.11087456928910466, 0.1680831937589855, 0.1680831937589855, 0.1680831937589855, 0.11879105460927863, 0.11879105460927863, 0.11879105460927863, 0.19328060216177712, 0.19328060216177712, 0.19328060216177712, 0.23355515114114256, 0.23355515114114256, 0.23355515114114256, 0.3310074699849117, 0.3310074699849117, 0.3310074699849117, 0.3610529275661507, 0.3610529275661507, 0.3610529275661507, 0.3901845629571934, 0.3901845629571934, 0.3901845629571934, 0.4094357933587013, 0.4094357933587013, 0.4094357933587013, 0.2842597822116044, 0.2842597822116044, 0.2842597822116044, 0.22907292173553873, 0.22907292173553873, 0.22907292173553873, 0.18614405797881717, 0.18614405797881717, 0.18614405797881717, 0.19080425020301794, 0.19080425020301794, 0.19080425020301794, 0.25969889604051355, 0.25969889604051355, 0.25969889604051355, 0.2601853606566087, 0.2601853606566087, 0.2601853606566087, 0.2458298114597972, 0.2458298114597972, 0.2458298114597972, 0.18467356823611758, 0.18467356823611758, 0.18467356823611758, 0.22322471074920514, 0.22322471074920514, 0.22322471074920514, 0.9103745465553761, 0.9103745465553761, 0.9103745465553761, 0.15863252336963074, 0.15863252336963074, 0.15863252336963074, 0.177637045799503, 0.177637045799503, 0.177637045799503, 0.8437690752200666, 0.8437690752200666, 0.8437690752200666, 0.2125708146078501, 0.2125708146078501, 0.2125708146078501, 0.857674166911512, 0.857674166911512, 0.857674166911512, 0.19101856636359238, 0.19101856636359238, 0.19101856636359238, 0.20579602820532572, 0.20579602820532572, 0.20579602820532572, 0.2375364994332827, 0.2375364994332827, 0.2375364994332827, 0.1075442967580359, 0.1075442967580359, 0.1075442967580359, 0.11044932508690308, 0.11044932508690308, 0.11044932508690308, 0.10487214739296813, 0.10487214739296813, 0.10487214739296813]}, "mutation_prompt": null}
{"id": "45399e83-5abf-484a-b39a-a3dfcbc1771e", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lb = -5.0\n        self.ub = 5.0\n        self.num_particles = 40\n        self.inertia = 0.6  # Adjusted for dynamic balance\n        self.cognitive = 1.5  # Slightly increased for better personal exploration\n        self.social = 1.8  # Decreased for focused social interaction\n        self.quantum_prob = 0.3  # Increased quantum exploration probability\n        self.elite_quantum_prob = 0.2  # Adjusted elite exploration\n        self.global_best_position = None\n        self.global_best_value = np.inf\n        self.max_velocity = (self.ub - self.lb) * 0.15  # Reduced to stabilize\n        self.de_mutation_factor = 0.9  # Increased for greater diversity\n        self.de_crossover_rate = 0.8  # Balanced crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lb, self.ub, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.full(self.num_particles, np.inf)\n\n        for i in range(self.num_particles):\n            value = func(positions[i])\n            personal_best_values[i] = value\n            if value < self.global_best_value:\n                self.global_best_value = value\n                self.global_best_position = np.copy(positions[i])\n\n        eval_count = self.num_particles\n\n        while eval_count < self.budget:\n            for i in range(self.num_particles):\n                # Quantum-inspired update\n                if np.random.rand() < self.quantum_prob:\n                    quantum_position = self.global_best_position + np.random.randn(self.dim)\n                    quantum_position = np.clip(quantum_position, self.lb, self.ub)\n                    quantum_value = func(quantum_position)\n                    eval_count += 1\n                    if quantum_value < personal_best_values[i]:\n                        personal_best_values[i] = quantum_value\n                        personal_best_positions[i] = quantum_position\n\n                # Elite quantum-inspired update\n                if np.random.rand() < self.elite_quantum_prob:\n                    elite_quantum_position = personal_best_positions[i] + np.random.randn(self.dim)\n                    elite_quantum_position = np.clip(elite_quantum_position, self.lb, self.ub)\n                    elite_quantum_value = func(elite_quantum_position)\n                    eval_count += 1\n                    if elite_quantum_value < personal_best_values[i]:\n                        personal_best_positions[i] = elite_quantum_position\n                        personal_best_values[i] = elite_quantum_value\n\n                # Velocity and position update\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (\n                    self.inertia * velocities[i] +\n                    self.cognitive * r1 * (personal_best_positions[i] - positions[i]) +\n                    self.social * r2 * (self.global_best_position - positions[i])\n                )\n                velocities[i] = np.clip(velocities[i], -self.max_velocity, self.max_velocity)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lb, self.ub)\n\n                # Evaluate new position\n                value = func(positions[i])\n                eval_count += 1\n                if value < personal_best_values[i]:\n                    personal_best_values[i] = value\n                    personal_best_positions[i] = np.copy(positions[i])\n\n                # Differential Mutation\n                if np.random.rand() < self.de_crossover_rate:\n                    idxs = np.random.choice(self.num_particles, 3, replace=False)\n                    donor_vector = (\n                        positions[idxs[0]] +\n                        self.de_mutation_factor * (positions[idxs[1]] - positions[idxs[2]])\n                    )\n                    trial_vector = np.where(np.random.rand(self.dim) < self.de_crossover_rate,\n                                            donor_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lb, self.ub)\n\n                    trial_value = func(trial_vector)\n                    eval_count += 1\n                    if trial_value < personal_best_values[i]:\n                        positions[i] = trial_vector\n                        personal_best_positions[i] = trial_vector\n                        personal_best_values[i] = trial_value\n\n                if eval_count >= self.budget:\n                    break\n\n            if eval_count >= self.budget:\n                break\n\n            # Update global best\n            for i in range(self.num_particles):\n                value = personal_best_values[i]\n                if value < self.global_best_value:\n                    self.global_best_value = value\n                    self.global_best_position = np.copy(personal_best_positions[i])\n\n        return self.global_best_position, self.global_best_value", "name": "HybridAdaptiveSwarmOptimizer", "description": "Hybrid Adaptive Swarm Optimization with Quantum and Differential Evolution enhancements for efficient exploration-exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.35137589077902853, "feedback": "The algorithm HybridAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.26.", "error": "", "parent_id": "f4f27ed2-1e45-4d80-8e42-77b4d4ff9205", "metadata": {"aucs": [0.7770066675168822, 0.7770066675168822, 0.7770066675168822, 0.789734492629227, 0.789734492629227, 0.789734492629227, 0.8080276652683479, 0.8080276652683479, 0.8080276652683479, 0.4159389994850402, 0.4159389994850402, 0.4159389994850402, 0.4768583043328133, 0.4768583043328133, 0.4768583043328133, 0.39978409042270746, 0.39978409042270746, 0.39978409042270746, 0.16530894410995056, 0.16530894410995056, 0.16530894410995056, 0.133073322328653, 0.133073322328653, 0.133073322328653, 0.12580745853953634, 0.12580745853953634, 0.12580745853953634, 0.10255696507826395, 0.10255696507826395, 0.10255696507826395, 0.09977598138849297, 0.09977598138849297, 0.09977598138849297, 0.1096474149134039, 0.1096474149134039, 0.1096474149134039, 0.9400304610974022, 0.9400304610974022, 0.9400304610974022, 0.9649632306715508, 0.9649632306715508, 0.9649632306715508, 0.96746221591997, 0.96746221591997, 0.96746221591997, 0.5630587640101247, 0.5630587640101247, 0.5630587640101247, 0.5936087361903025, 0.5936087361903025, 0.5936087361903025, 0.5581622958491137, 0.5581622958491137, 0.5581622958491137, 0.864319205347128, 0.864319205347128, 0.864319205347128, 0.6350248222306887, 0.6350248222306887, 0.6350248222306887, 0.2234763637424707, 0.2234763637424707, 0.2234763637424707, 0.45385137562476574, 0.45385137562476574, 0.45385137562476574, 0.4319727656761737, 0.4319727656761737, 0.4319727656761737, 0.1297197545280402, 0.1297197545280402, 0.1297197545280402, 0.4110057852271448, 0.4110057852271448, 0.4110057852271448, 0.468943594876019, 0.468943594876019, 0.468943594876019, 0.1286358240189931, 0.1286358240189931, 0.1286358240189931, 0.09917380351595717, 0.09917380351595717, 0.09917380351595717, 0.1710807024617066, 0.1710807024617066, 0.1710807024617066, 0.11692383823726815, 0.11692383823726815, 0.11692383823726815, 0.22673333132950824, 0.22673333132950824, 0.22673333132950824, 0.29039867190215596, 0.29039867190215596, 0.29039867190215596, 0.24349232320836922, 0.24349232320836922, 0.24349232320836922, 0.04553648764035456, 0.04553648764035456, 0.04553648764035456, 0.2528197581581565, 0.2528197581581565, 0.2528197581581565, 0.08582141833168389, 0.08582141833168389, 0.08582141833168389, 0.16790410427357072, 0.16790410427357072, 0.16790410427357072, 0.17792743510480635, 0.17792743510480635, 0.17792743510480635, 0.2162449693394587, 0.2162449693394587, 0.2162449693394587, 0.6718830724624834, 0.6718830724624834, 0.6718830724624834, 0.5361846125024019, 0.5361846125024019, 0.5361846125024019, 0.6333338944210434, 0.6333338944210434, 0.6333338944210434, 0.13819114499942076, 0.13819114499942076, 0.13819114499942076, 0.09528109948216812, 0.09528109948216812, 0.09528109948216812, 0.10730893943882824, 0.10730893943882824, 0.10730893943882824, 0.37717612657700805, 0.37717612657700805, 0.37717612657700805, 0.23935934478502785, 0.23935934478502785, 0.23935934478502785, 0.21304117941192513, 0.21304117941192513, 0.21304117941192513, 0.4089794831854675, 0.4089794831854675, 0.4089794831854675, 0.3807464738870706, 0.3807464738870706, 0.3807464738870706, 0.47453585420870126, 0.47453585420870126, 0.47453585420870126, 0.35168295944752126, 0.35168295944752126, 0.35168295944752126, 0.23246291359507776, 0.23246291359507776, 0.23246291359507776, 0.4046712071018984, 0.4046712071018984, 0.4046712071018984, 0.21365129828987817, 0.21365129828987817, 0.21365129828987817, 0.2541883390659462, 0.2541883390659462, 0.2541883390659462, 0.20683527259454237, 0.20683527259454237, 0.20683527259454237, 0.1960599903574105, 0.1960599903574105, 0.1960599903574105, 0.18054916858686587, 0.18054916858686587, 0.18054916858686587, 0.20247916885380624, 0.20247916885380624, 0.20247916885380624, 0.8778096321719482, 0.8778096321719482, 0.8778096321719482, 0.8682792077862074, 0.8682792077862074, 0.8682792077862074, 0.17532564944063744, 0.17532564944063744, 0.17532564944063744, 0.1644655499358938, 0.1644655499358938, 0.1644655499358938, 0.21008627653188072, 0.21008627653188072, 0.21008627653188072, 0.8285471953809425, 0.8285471953809425, 0.8285471953809425, 0.19856934568294782, 0.19856934568294782, 0.19856934568294782, 0.18365706065633858, 0.18365706065633858, 0.18365706065633858, 0.17645712398523905, 0.17645712398523905, 0.17645712398523905, 0.10314121626479678, 0.10314121626479678, 0.10314121626479678, 0.07890619402901333, 0.07890619402901333, 0.07890619402901333, 0.08340579644351143, 0.08340579644351143, 0.08340579644351143]}, "mutation_prompt": null}
