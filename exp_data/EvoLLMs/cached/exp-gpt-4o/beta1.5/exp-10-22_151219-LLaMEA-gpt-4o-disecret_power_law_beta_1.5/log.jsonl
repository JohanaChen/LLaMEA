{"id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "solution": "import numpy as np\n\nclass AdaptiveDEwithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        local_vector = vector + np.random.normal(0, 0.1, self.dim)\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "AdaptiveDEwithLocalSearch", "description": "Adaptive Differential Evolution with Local Search to balance exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.20285861667991945, "feedback": "The algorithm AdaptiveDEwithLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.40268716854379194, 0.407619395984537, 0.3967947176363028, 0.4054147570487022, 0.4118066426454966, 0.4210165064682948, 0.4347654760508669, 0.4282248205378464, 0.41848140773738496, 0.0405066518036058, 0.037839017383403006, 0.03225518023824936, 0.026815550554173728, 0.03589716796112885, 0.052949860364623236, 0.021789216400198486, 0.029435034952229988, 0.022898703515685903, 0.09352684863848915, 0.08831897178279013, 0.08615026124293768, 0.09363235851891727, 0.0911910096211972, 0.0935694064569792, 0.08248392836270324, 0.08619839090141834, 0.09942642203149166, 0.07577043267230932, 0.08927902150364875, 0.07998433451899722, 0.08418664462115688, 0.08067480654685133, 0.09794911540361917, 0.07332168783851067, 0.08048037242692951, 0.08080219271387645, 0.8973896562553778, 0.8724626684444572, 0.8618814634909644, 0.8731636453402134, 0.9186936325066577, 0.9043775535633587, 0.9197221711109073, 0.8964079442227078, 0.8518053602294208, 0.2333745157567655, 0.21475581430708413, 0.22731181402050382, 0.22978237643338584, 0.2388635428925895, 0.24185355144290566, 0.2322011410285515, 0.2447976450920608, 0.22780888005940292, 0.2787072812257624, 0.28035554542756413, 0.28095619604067756, 0.28720785537713067, 0.30905532514027156, 0.283124157258289, 0.2974501002906538, 0.2783160559483995, 0.2661309594175587, 0.14991756213524732, 0.13349193543028648, 0.15283017375296626, 0.13769501426462571, 0.1335200402310227, 0.14175829611866397, 0.12869891157224445, 0.1399755297504327, 0.14530010345054267, 0.16357997905259325, 0.14841250895186675, 0.1250260092095128, 0.14371232770152387, 0.14438362015844142, 0.13782484695872044, 0.139679533397854, 0.13573384500721153, 0.11678964934858904, 0.0074796563342811595, 0.004650921289012122, 0.007391580115766017, 0.034434408217952295, 0.03666402963583182, 0.0030231913524607634, 0.004355072447187247, 0.017019240817959913, 0.0034960732605603395, 0.079194089096572, 0.09156613020163817, 0.09384314739535005, 0.10807933676349513, 0.10827658259566741, 0.09077615014768048, 0.07767966643559199, 0.08722662188862818, 0.0924407420637412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08513080796548234, 0.09265970239247834, 0.08768808996574429, 0.0852577193913221, 0.09332505234211053, 0.08685363660904444, 0.0874321313212113, 0.09390827821585424, 0.09099551724096633, 0.38805603383909126, 0.3911119582999226, 0.365414009436285, 0.38921860372869843, 0.4014458141905145, 0.38928593982419646, 0.38695375220510264, 0.3762625891571436, 0.3738821359783372, 0.1166546173965568, 0.08476619159898524, 0.08309543327454716, 0.0827548132628535, 0.08292365486502162, 0.08311819052697478, 0.07842988687898855, 0.07874144145157536, 0.08695886692716015, 0.20472688011347817, 0.14377162405489707, 0.16849768521762176, 0.19507417617513234, 0.14461525636030215, 0.16716501902460312, 0.18875560972857586, 0.14868104936103754, 0.13495607538792698, 0.25290821546737685, 0.2528650104285358, 0.2526429497268009, 0.22668480650763312, 0.23668319015942618, 0.23513512041697893, 0.25562171134361966, 0.274923125432439, 0.2623430146602872, 0.19041921873448542, 0.20433827879762245, 0.18268269665370962, 0.19206725135251623, 0.18701386260667707, 0.193339409567148, 0.19760382928433584, 0.19642959787656977, 0.1884776107055972, 0.16619912880332266, 0.16804207573418917, 0.17288769222100597, 0.1890019261426218, 0.17074814598415544, 0.1862747827434681, 0.18630987483848527, 0.19944297053525206, 0.1857292996885953, 0.16562166315625404, 0.1704647948044008, 0.19016998890596337, 0.18596884606232278, 0.17005022876843245, 0.17832682397543953, 0.1781966614569519, 0.17381437034835867, 0.17525315025242105, 0.5832030640071301, 0.5396787449384011, 0.17796646890323942, 0.45090753029174935, 0.17473319837573797, 0.4240028142793455, 0.36757432230763853, 0.3603456265538598, 0.2779614976171124, 0.2994848595141749, 0.26191962301247873, 0.18111386350318925, 0.32838383010587724, 0.33040103831052625, 0.37789213098074814, 0.2102779200497109, 0.20545645517386824, 0.4879998823678755, 0.18996474288067133, 0.18331090386270843, 0.18779954464199222, 0.18671435170729933, 0.1903134949356884, 0.17721477083470472, 0.18038693020063, 0.1781971265737391, 0.18769888010885116, 0.08005097967053876, 0.0729293577532586, 0.07006833835331705, 0.0745433728892253, 0.0953788128649734, 0.07018022926652778, 0.07115840236210191, 0.07826537261968625, 0.07180629268618721]}, "mutation_prompt": null}
{"id": "fccb802e-4650-4c2f-b98b-10f19102ffb7", "solution": "import numpy as np\n\nclass AdaptiveDEwithStochasticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.85  # Adjusted for better exploration\n        self.crossover_rate = 0.85  # Adjusted to explore more\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.stochastic_local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def stochastic_local_search(self, vector):\n        if np.random.rand() < 0.5:  # Introduce stochastic decision\n            local_vector = vector + np.random.normal(0, 0.05, self.dim)  # Tighter local search\n        else:\n            local_vector = vector + np.random.normal(0, 0.2, self.dim)  # Wider search occasionally\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "AdaptiveDEwithStochasticLocalSearch", "description": "Adaptive Differential Evolution with Stochastic Local Search for enhanced convergence through probabilistic improvements.", "configspace": "", "generation": 1, "fitness": 0.19002205742433886, "feedback": "The algorithm AdaptiveDEwithStochasticLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.413687602620916, 0.410040821816807, 0.4072870415149721, 0.4313763923112294, 0.44297683621019246, 0.4276579326712383, 0.4024422576944384, 0.4035781138889559, 0.41548774754322093, 0.037199311160060256, 0.030472505054499055, 0.0233318485905476, 0.03200510292287384, 0.059212916697560236, 0.040821309770253, 0.0537613192438301, 0.03621727106130779, 0.03675540112464348, 0.09487852339348868, 0.08389803288600961, 0.07981686302996382, 0.07800618835777007, 0.08526712848678031, 0.08156578814808313, 0.08029842346705718, 0.09189816563089848, 0.09196942884994519, 0.07511057514848585, 0.07491337061176895, 0.08508016427090004, 0.08827304661742097, 0.07795510352656021, 0.09282562978490572, 0.08221176616029557, 0.08351123675048389, 0.08208764579632644, 0.8999689454250474, 0.9829872902292284, 0.9115500093443093, 0.9126693583226222, 0.9208534437420424, 0.9745712420422619, 0.9181778745285447, 0.8764478536846907, 0.9409836736113305, 0.21005435524294713, 0.20993218550122983, 0.21269397726363237, 0.2128592092740852, 0.1956833833429411, 0.21360985589155324, 0.21056284736090913, 0.225133411720968, 0.2288300842932982, 0.2482527091164114, 0.25780012872500113, 0.24306034176503166, 0.2793014232691665, 0.26861237171628505, 0.28961984853835054, 0.275175765113684, 0.2522944941177898, 0.2586343004209404, 0.13322931719701103, 0.13507845340125968, 0.13272967089175525, 0.12829258059943982, 0.1050756496729246, 0.12948732769867854, 0.12621407576234556, 0.13116236192891773, 0.13334311985732872, 0.11213083616757735, 0.1294377529064299, 0.14303480084270392, 0.14114845410336585, 0.11404002676791902, 0.13041768067024373, 0.09916771758719911, 0.10953369837125615, 0.12535197934626374, 9.999999999998899e-05, 0.006797092999559773, 0.0003106662242901015, 0.0017515002569506999, 9.999999999998899e-05, 0.005373181237053326, 0.02106809155300393, 9.999999999998899e-05, 0.006264431307441587, 0.0829871239737151, 0.08088229584686779, 0.09799666926748285, 0.11389771146776861, 0.11222810007661044, 0.06967126118883737, 0.08863254368697804, 0.08698800925102734, 0.07125722923042699, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005848110468376411, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07542959839708996, 0.0760970874817194, 0.08165886292886737, 0.07882204398124015, 0.08040571151867171, 0.08480173696461057, 0.08360359952285668, 0.08079283561784756, 0.08583213064529605, 0.3636671573428951, 0.3655514693034698, 0.36451934034082323, 0.3904818318919654, 0.3760306746976474, 0.382154371589854, 0.36343211028339395, 0.3712386224480799, 0.3854189722656347, 0.08080039282208962, 0.09244736987918989, 0.08493810660410783, 0.07862935557551887, 0.07121427730189911, 0.09071982997608719, 0.06707496173195615, 0.08092546355599128, 0.08142684916605647, 0.17060557523473385, 0.1524019364989183, 0.1556784463796388, 0.16102513406414432, 0.15661005553919916, 0.1425101282760617, 0.14640051784045116, 0.15125535424299374, 0.13530733649446647, 0.23069610982225153, 0.2297646226830049, 0.25489385869855696, 0.23053972986565052, 0.22889286424420785, 0.22778165725670974, 0.24782952586823204, 0.25142943293023234, 0.2443235672259041, 0.18254293967005764, 0.17308541568553504, 0.17731568854427915, 0.17666228449190058, 0.1782354389100379, 0.17327237830125342, 0.1780275999304819, 0.18775699499992649, 0.19704465508796642, 0.17779498214462963, 0.18158807286387213, 0.1781381818428983, 0.18762599072849295, 0.1968959263539547, 0.16447325010321512, 0.19624897248468864, 0.1741624123163421, 0.17097136050834216, 0.17411331507703087, 0.16962710426416283, 0.17296437642608875, 0.17224516780421706, 0.17410433597862995, 0.17017931178022516, 0.16773259058742118, 0.1784231156121745, 0.1742318140913277, 0.18033987309258992, 0.15092302660076928, 0.16287591965192294, 0.3486650798996792, 0.3818695317786971, 0.2882391702027347, 0.3347292731521586, 0.18107680975260587, 0.39356717752423365, 0.18953523162070474, 0.19559599598123234, 0.2088512634578399, 0.15834158724154845, 0.2703918189653185, 0.22264440032244848, 0.2081590955716417, 0.20437326626571173, 0.1957771019819119, 0.17056081595576433, 0.17454703883574807, 0.18759607844731152, 0.17896426328647408, 0.19059491048127652, 0.1881087473076375, 0.192383987321754, 0.20210932953304783, 0.18167090250686624, 0.07653664262171134, 0.0698068724920411, 0.0673876927622068, 0.05947759129292385, 0.06429810865967134, 0.05816144301325099, 0.06564863734920923, 0.06935387877964583, 0.07394882812953807]}, "mutation_prompt": null}
{"id": "0a7e67d8-011b-4ac5-aba3-eeeb68f0225c", "solution": "import numpy as np\n\nclass HybridDEwithDynamicScaling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.5\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n            self.dynamic_scaling()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        best_vector = vector\n        best_fitness = func(vector)\n        for _ in range(3):\n            local_vector = vector + np.random.normal(0, 0.1, self.dim)\n            local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n            local_fitness = func(local_vector)\n            if local_fitness < best_fitness:\n                best_fitness = local_fitness\n                best_vector = local_vector\n        return best_vector\n\n    def dynamic_scaling(self):\n        self.scale_factor = 0.5 + 0.3 * np.random.rand()", "name": "HybridDEwithDynamicScaling", "description": "Hybrid Differential Evolution with Dynamic Scaling and Adaptive Local Search for improved exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.15378795593203012, "feedback": "The algorithm HybridDEwithDynamicScaling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.15.", "error": "", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.32102328428007176, 0.320497519723564, 0.3161276426564047, 0.3282663301678803, 0.33852236136895275, 0.346994945601916, 0.3090070286494542, 0.3249524851421398, 0.35983923751241254, 0.07957926790719361, 0.0667145219240659, 0.05291117270125889, 0.06220657526920714, 0.06449953295570865, 0.06454938130581322, 0.054832814025994936, 0.05737356612856237, 0.06115091115235516, 0.06859220678052058, 0.09403495409030582, 0.07178294380399697, 0.06527404090768907, 0.07532143779761569, 0.07177058834521, 0.07106790748930147, 0.07416376328207186, 0.0888097474821603, 0.06398284041175595, 0.060246426358422145, 0.0764634768712169, 0.07184088917160047, 0.053351902639824034, 0.06225874381050378, 0.060057070378984334, 0.05248859338618117, 0.06878860358316574, 0.7221981855942778, 0.681868680482651, 0.7692944588711362, 0.6821960802707014, 0.8061621989087928, 0.70553823875611, 0.8282412638430484, 0.7019387681188072, 0.7838650078638493, 0.12323592657854388, 0.10774255941081645, 0.1385427979363043, 0.13218499519946947, 0.11285115911643295, 0.15239500112082915, 0.13991955217741903, 0.12780872295930767, 0.13329829881793998, 0.2127277007188242, 0.1988405129261137, 0.20473454222596643, 0.20927350018641577, 0.20279405092616432, 0.18735351024398494, 0.22471959179857026, 0.19555315990954292, 0.21083052462735719, 0.05980266973677539, 0.062162296691721575, 0.08573142127356315, 0.0803888524501577, 0.08160591898625302, 0.06979425440724552, 0.052711586143226685, 0.05821329985935153, 0.11960883559895175, 0.08238642971772603, 0.07052962733623047, 0.07485140998767748, 0.06547172247536348, 0.06816430264384399, 0.08179645316734063, 0.06905427209072801, 0.053552186620065556, 0.08285177262290855, 0.012107026855071257, 0.00187726974802227, 0.0031606154800163377, 0.010094481622061391, 0.01644239586505225, 0.0027920142257360503, 0.0128848719220519, 0.011625197487872163, 0.011320022562471443, 0.11342935008218014, 0.11167656339538867, 0.13244941302744828, 0.09984575502811621, 0.09777408111080443, 0.09810391255662487, 0.1348219501562451, 0.15460834745244123, 0.09333412623044568, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000722698859354387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05639476699632906, 0.04435454093390767, 0.05403792772285321, 0.037036205784266585, 0.049615050639255975, 0.06439164933709451, 0.06828091119518975, 0.049286709631015446, 0.05533610368331898, 0.3084552437088598, 0.29231543442955277, 0.3206900696289259, 0.31813557139583903, 0.28523369194277925, 0.29645941229136585, 0.29648046693338814, 0.2805377545453379, 0.3059779542712816, 0.085730904781264, 0.0803640077427401, 0.07467961715310611, 0.06997120490969189, 0.06377687977784552, 0.08013821543932431, 0.06782734601054285, 0.07780287955957499, 0.06221035894599736, 0.13711130689698314, 0.12367730316175385, 0.13695619608799137, 0.15764331838049017, 0.12851691010620891, 0.1168735267411426, 0.16183806225467956, 0.132754355344332, 0.12880642275235255, 0.19970150166410272, 0.18869994261501666, 0.2074085468212633, 0.20999973226383606, 0.19138918825007445, 0.18697758537250853, 0.21058922378780975, 0.2485398161688822, 0.1992384518341489, 0.13768500568292585, 0.13299104174728293, 0.14375184870033497, 0.13530604478340535, 0.1377015819565588, 0.1363224421114383, 0.14248761472349958, 0.16510900397918538, 0.14023368296458016, 0.20585042807137943, 0.17212476847410707, 0.1810247926937062, 0.15610530019149904, 0.19870506318127867, 0.1783890799223411, 0.1851945887299129, 0.17192659597790938, 0.18056356751319147, 0.13790296016917214, 0.1603425832534423, 0.160534295414131, 0.17896712995711916, 0.14519204551648712, 0.15141855963635353, 0.16417077326048202, 0.1629217677754281, 0.162346120983615, 0.16453392774632214, 0.15014632307312226, 0.16180460329429258, 0.1199817898955795, 0.15525073179075355, 0.14633248812883504, 0.18559414527526508, 0.16315727115235423, 0.164724217910175, 0.16720473797208668, 0.16798960064983326, 0.13083393750747274, 0.15371626597062826, 0.11806953612179627, 0.1559506372987849, 0.16498517986768024, 0.17816681968467052, 0.12785407446244057, 0.19999450071178138, 0.183448440371634, 0.20260192387447673, 0.1710715718313004, 0.1839638683546394, 0.1834696599095842, 0.1745695123922958, 0.1804652282718977, 0.17825943280838186, 0.07230340663399015, 0.06006505737597012, 0.07646161435838217, 0.08111969863082835, 0.061228932302837324, 0.0650853147159216, 0.06986183472034968, 0.08034893032768375, 0.06607119853007992]}, "mutation_prompt": null}
{"id": "875c9773-48e9-401c-920b-b20ce783593d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDEwithChaoticSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.chaotic_local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def chaotic_local_search(self, vector):\n        # Implementing a chaotic local search strategy\n        beta = 0.5  # chaotic coefficient\n        chaos_vector = vector + beta * (np.random.rand(self.dim) - 0.5) * 2\n        return np.clip(chaos_vector, self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveDEwithChaoticSearch", "description": "Enhanced Adaptive Differential Evolution with Chaotic Local Search for improved adaptability and convergence.", "configspace": "", "generation": 3, "fitness": 0.1773368605538751, "feedback": "The algorithm EnhancedAdaptiveDEwithChaoticSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.33204021218101865, 0.32758521238795846, 0.32668845144250214, 0.3431666324219218, 0.32830052672249, 0.364613979500786, 0.3373563442893508, 0.353568432275877, 0.33698135159208265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030744098899916583, 9.999999999998899e-05, 9.999999999998899e-05, 0.09044988448768565, 0.08381029695089492, 0.06680109804239909, 0.08589141121667432, 0.09053226943604387, 0.08075711420605947, 0.09252763112668583, 0.08614834687158424, 0.07283122802738395, 0.07841165841271447, 0.07956571824282133, 0.06300186258906249, 0.07104516644587422, 0.07402356130752707, 0.06727076610320548, 0.06964601313732077, 0.06829604257648081, 0.067456854241572, 0.8890410778948985, 0.9203630623332271, 0.9213515505266457, 0.9281687370134631, 0.8963021908465596, 0.9072826515239749, 0.9620727043898843, 0.9104330309385917, 0.9032113235120778, 0.19640892974824464, 0.18053177214391636, 0.1936712599407201, 0.19082833778735342, 0.1940828563283229, 0.19652053031622507, 0.1932183938735781, 0.22271396777813723, 0.20190949153661142, 0.24613690486154927, 0.23171983850093525, 0.22024158777359748, 0.22706712672079432, 0.24863962436037623, 0.24936409299623352, 0.22750546085579115, 0.2504747428227362, 0.24550649607533293, 0.12916402626788004, 0.10357603019196959, 0.11089553327460488, 0.10789550934974845, 0.113238084288792, 0.12123089473385185, 0.10420654377733796, 0.10216599752803923, 0.11982112986241844, 0.09062465743887715, 0.09819790817204943, 0.10002681607457309, 0.11685060923085278, 0.10418277124714947, 0.11414709784845123, 0.1071010780476559, 0.09909956166614153, 0.11162463529138256, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010267674416758465, 0.0615156910942507, 0.08577693825469546, 0.06617313544263503, 0.07020016457260914, 0.08052926385459447, 0.10484734874516399, 0.068074267107472, 0.08978430543183291, 0.05876105249746033, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06004110699436771, 0.06068658438785346, 0.048447648700770896, 0.05638027743850327, 0.05846958175561068, 0.05840462298476601, 0.06381733366452502, 0.0532088412440338, 0.05988554957246872, 0.3264359615665102, 0.33812556564273877, 0.34272621369106393, 0.3170656323422578, 0.33059988934849893, 0.3224912806712793, 0.32081803704442546, 0.32380912686534513, 0.31858713537626404, 0.07592078862267115, 0.08490525041936947, 0.08179579832936212, 0.09245895146897365, 0.08683697950400004, 0.07983182454999571, 0.08569893532387052, 0.0915263420369894, 0.09205050004853133, 0.14651319324157064, 0.1272545168990601, 0.19243600915218528, 0.1353982754997618, 0.12414216738179928, 0.12993496299360174, 0.14519034711133882, 0.17811375974055388, 0.14220124765603692, 0.2206056211388745, 0.22829339545785376, 0.23477457701246007, 0.22762398759392022, 0.2235514219506748, 0.23208435997452748, 0.2628168478205759, 0.24037089954922664, 0.23118396792164508, 0.16783709359023324, 0.17079896820346352, 0.17099594507703642, 0.1610152101095078, 0.15756504582681863, 0.15430275017072614, 0.16739798070359413, 0.1847018594043055, 0.18548550367198158, 0.20347477177569973, 0.16543738203592617, 0.2309851146764863, 0.1762558180426529, 0.19293886819162576, 0.1781185332087034, 0.18135994678454437, 0.18010732693203824, 0.1801238749407732, 0.17071117051773999, 0.18305979710846265, 0.17264018182645247, 0.16579213497151501, 0.1678991124547934, 0.1692415416909152, 0.18275129591678896, 0.17384194763495975, 0.1788424824868693, 0.15788644943295405, 0.38441612746576526, 0.1768612156042031, 0.18041807121769382, 0.4025658592380238, 0.2097460244959356, 0.16580304654529276, 0.22526692722648323, 0.3169451541846785, 0.18388017673944124, 0.3114062016744754, 0.176979185779918, 0.17472866729267644, 0.21707175556054925, 0.27099040683565523, 0.20251199058826364, 0.20240025394717653, 0.2993958165186229, 0.1847771676294354, 0.190635930090998, 0.18277775196454726, 0.18145550259970544, 0.19347328906170835, 0.1970353597256178, 0.18252393071275885, 0.19034860390952335, 0.19612598389422042, 0.07704165222874604, 0.07515394746273962, 0.06415315499436725, 0.0749581478132959, 0.077166787230451, 0.06654088005521297, 0.06903531444206346, 0.07056803892660768, 0.07700240363205302]}, "mutation_prompt": null}
{"id": "4a245210-4dfa-4b37-9c5c-c2554617db0b", "solution": "import numpy as np\n\nclass AdaptiveDEwithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        local_vector = vector + np.random.normal(0, 0.1, self.dim)\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "AdaptiveDEwithLocalSearch", "description": "Adaptive Differential Evolution with Local Search to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.40268716854379194, 0.407619395984537, 0.3967947176363028, 0.4054147570487022, 0.4118066426454966, 0.4210165064682948, 0.4347654760508669, 0.4282248205378464, 0.41848140773738496, 0.0405066518036058, 0.037839017383403006, 0.03225518023824936, 0.026815550554173728, 0.03589716796112885, 0.052949860364623236, 0.021789216400198486, 0.029435034952229988, 0.022898703515685903, 0.09352684863848915, 0.08831897178279013, 0.08615026124293768, 0.09363235851891727, 0.0911910096211972, 0.0935694064569792, 0.08248392836270324, 0.08619839090141834, 0.09942642203149166, 0.07577043267230932, 0.08927902150364875, 0.07998433451899722, 0.08418664462115688, 0.08067480654685133, 0.09794911540361917, 0.07332168783851067, 0.08048037242692951, 0.08080219271387645, 0.8973896562553778, 0.8724626684444572, 0.8618814634909644, 0.8731636453402134, 0.9186936325066577, 0.9043775535633587, 0.9197221711109073, 0.8964079442227078, 0.8518053602294208, 0.2333745157567655, 0.21475581430708413, 0.22731181402050382, 0.22978237643338584, 0.2388635428925895, 0.24185355144290566, 0.2322011410285515, 0.2447976450920608, 0.22780888005940292, 0.2787072812257624, 0.28035554542756413, 0.28095619604067756, 0.28720785537713067, 0.30905532514027156, 0.283124157258289, 0.2974501002906538, 0.2783160559483995, 0.2661309594175587, 0.14991756213524732, 0.13349193543028648, 0.15283017375296626, 0.13769501426462571, 0.1335200402310227, 0.14175829611866397, 0.12869891157224445, 0.1399755297504327, 0.14530010345054267, 0.16357997905259325, 0.14841250895186675, 0.1250260092095128, 0.14371232770152387, 0.14438362015844142, 0.13782484695872044, 0.139679533397854, 0.13573384500721153, 0.11678964934858904, 0.0074796563342811595, 0.004650921289012122, 0.007391580115766017, 0.034434408217952295, 0.03666402963583182, 0.0030231913524607634, 0.004355072447187247, 0.017019240817959913, 0.0034960732605603395, 0.079194089096572, 0.09156613020163817, 0.09384314739535005, 0.10807933676349513, 0.10827658259566741, 0.09077615014768048, 0.07767966643559199, 0.08722662188862818, 0.0924407420637412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08513080796548234, 0.09265970239247834, 0.08768808996574429, 0.0852577193913221, 0.09332505234211053, 0.08685363660904444, 0.0874321313212113, 0.09390827821585424, 0.09099551724096633, 0.38805603383909126, 0.3911119582999226, 0.365414009436285, 0.38921860372869843, 0.4014458141905145, 0.38928593982419646, 0.38695375220510264, 0.3762625891571436, 0.3738821359783372, 0.1166546173965568, 0.08476619159898524, 0.08309543327454716, 0.0827548132628535, 0.08292365486502162, 0.08311819052697478, 0.07842988687898855, 0.07874144145157536, 0.08695886692716015, 0.20472688011347817, 0.14377162405489707, 0.16849768521762176, 0.19507417617513234, 0.14461525636030215, 0.16716501902460312, 0.18875560972857586, 0.14868104936103754, 0.13495607538792698, 0.25290821546737685, 0.2528650104285358, 0.2526429497268009, 0.22668480650763312, 0.23668319015942618, 0.23513512041697893, 0.25562171134361966, 0.274923125432439, 0.2623430146602872, 0.19041921873448542, 0.20433827879762245, 0.18268269665370962, 0.19206725135251623, 0.18701386260667707, 0.193339409567148, 0.19760382928433584, 0.19642959787656977, 0.1884776107055972, 0.16619912880332266, 0.16804207573418917, 0.17288769222100597, 0.1890019261426218, 0.17074814598415544, 0.1862747827434681, 0.18630987483848527, 0.19944297053525206, 0.1857292996885953, 0.16562166315625404, 0.1704647948044008, 0.19016998890596337, 0.18596884606232278, 0.17005022876843245, 0.17832682397543953, 0.1781966614569519, 0.17381437034835867, 0.17525315025242105, 0.5832030640071301, 0.5396787449384011, 0.17796646890323942, 0.45090753029174935, 0.17473319837573797, 0.4240028142793455, 0.36757432230763853, 0.3603456265538598, 0.2779614976171124, 0.2994848595141749, 0.26191962301247873, 0.18111386350318925, 0.32838383010587724, 0.33040103831052625, 0.37789213098074814, 0.2102779200497109, 0.20545645517386824, 0.4879998823678755, 0.18996474288067133, 0.18331090386270843, 0.18779954464199222, 0.18671435170729933, 0.1903134949356884, 0.17721477083470472, 0.18038693020063, 0.1781971265737391, 0.18769888010885116, 0.08005097967053876, 0.0729293577532586, 0.07006833835331705, 0.0745433728892253, 0.0953788128649734, 0.07018022926652778, 0.07115840236210191, 0.07826537261968625, 0.07180629268618721]}, "mutation_prompt": null}
{"id": "f193d115-a285-465f-90c1-4464ba128c23", "solution": "import numpy as np\n\nclass AdaptiveDEwithLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        local_vector = vector + np.random.normal(0, 0.1, self.dim)\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "AdaptiveDEwithLocalSearch", "description": "Adaptive Differential Evolution with Local Search to balance exploration and exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.40268716854379194, 0.407619395984537, 0.3967947176363028, 0.4054147570487022, 0.4118066426454966, 0.4210165064682948, 0.4347654760508669, 0.4282248205378464, 0.41848140773738496, 0.0405066518036058, 0.037839017383403006, 0.03225518023824936, 0.026815550554173728, 0.03589716796112885, 0.052949860364623236, 0.021789216400198486, 0.029435034952229988, 0.022898703515685903, 0.09352684863848915, 0.08831897178279013, 0.08615026124293768, 0.09363235851891727, 0.0911910096211972, 0.0935694064569792, 0.08248392836270324, 0.08619839090141834, 0.09942642203149166, 0.07577043267230932, 0.08927902150364875, 0.07998433451899722, 0.08418664462115688, 0.08067480654685133, 0.09794911540361917, 0.07332168783851067, 0.08048037242692951, 0.08080219271387645, 0.8973896562553778, 0.8724626684444572, 0.8618814634909644, 0.8731636453402134, 0.9186936325066577, 0.9043775535633587, 0.9197221711109073, 0.8964079442227078, 0.8518053602294208, 0.2333745157567655, 0.21475581430708413, 0.22731181402050382, 0.22978237643338584, 0.2388635428925895, 0.24185355144290566, 0.2322011410285515, 0.2447976450920608, 0.22780888005940292, 0.2787072812257624, 0.28035554542756413, 0.28095619604067756, 0.28720785537713067, 0.30905532514027156, 0.283124157258289, 0.2974501002906538, 0.2783160559483995, 0.2661309594175587, 0.14991756213524732, 0.13349193543028648, 0.15283017375296626, 0.13769501426462571, 0.1335200402310227, 0.14175829611866397, 0.12869891157224445, 0.1399755297504327, 0.14530010345054267, 0.16357997905259325, 0.14841250895186675, 0.1250260092095128, 0.14371232770152387, 0.14438362015844142, 0.13782484695872044, 0.139679533397854, 0.13573384500721153, 0.11678964934858904, 0.0074796563342811595, 0.004650921289012122, 0.007391580115766017, 0.034434408217952295, 0.03666402963583182, 0.0030231913524607634, 0.004355072447187247, 0.017019240817959913, 0.0034960732605603395, 0.079194089096572, 0.09156613020163817, 0.09384314739535005, 0.10807933676349513, 0.10827658259566741, 0.09077615014768048, 0.07767966643559199, 0.08722662188862818, 0.0924407420637412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08513080796548234, 0.09265970239247834, 0.08768808996574429, 0.0852577193913221, 0.09332505234211053, 0.08685363660904444, 0.0874321313212113, 0.09390827821585424, 0.09099551724096633, 0.38805603383909126, 0.3911119582999226, 0.365414009436285, 0.38921860372869843, 0.4014458141905145, 0.38928593982419646, 0.38695375220510264, 0.3762625891571436, 0.3738821359783372, 0.1166546173965568, 0.08476619159898524, 0.08309543327454716, 0.0827548132628535, 0.08292365486502162, 0.08311819052697478, 0.07842988687898855, 0.07874144145157536, 0.08695886692716015, 0.20472688011347817, 0.14377162405489707, 0.16849768521762176, 0.19507417617513234, 0.14461525636030215, 0.16716501902460312, 0.18875560972857586, 0.14868104936103754, 0.13495607538792698, 0.25290821546737685, 0.2528650104285358, 0.2526429497268009, 0.22668480650763312, 0.23668319015942618, 0.23513512041697893, 0.25562171134361966, 0.274923125432439, 0.2623430146602872, 0.19041921873448542, 0.20433827879762245, 0.18268269665370962, 0.19206725135251623, 0.18701386260667707, 0.193339409567148, 0.19760382928433584, 0.19642959787656977, 0.1884776107055972, 0.16619912880332266, 0.16804207573418917, 0.17288769222100597, 0.1890019261426218, 0.17074814598415544, 0.1862747827434681, 0.18630987483848527, 0.19944297053525206, 0.1857292996885953, 0.16562166315625404, 0.1704647948044008, 0.19016998890596337, 0.18596884606232278, 0.17005022876843245, 0.17832682397543953, 0.1781966614569519, 0.17381437034835867, 0.17525315025242105, 0.5832030640071301, 0.5396787449384011, 0.17796646890323942, 0.45090753029174935, 0.17473319837573797, 0.4240028142793455, 0.36757432230763853, 0.3603456265538598, 0.2779614976171124, 0.2994848595141749, 0.26191962301247873, 0.18111386350318925, 0.32838383010587724, 0.33040103831052625, 0.37789213098074814, 0.2102779200497109, 0.20545645517386824, 0.4879998823678755, 0.18996474288067133, 0.18331090386270843, 0.18779954464199222, 0.18671435170729933, 0.1903134949356884, 0.17721477083470472, 0.18038693020063, 0.1781971265737391, 0.18769888010885116, 0.08005097967053876, 0.0729293577532586, 0.07006833835331705, 0.0745433728892253, 0.0953788128649734, 0.07018022926652778, 0.07115840236210191, 0.07826537261968625, 0.07180629268618721]}, "mutation_prompt": null}
{"id": "d064c19e-5a16-40c8-8412-235c79ae7e07", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.dynamic_mutate(i)\n                trial_vector = self.adaptive_crossover(trial_vector, self.population[i])\n                trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def dynamic_mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        scale_factor_var = self.scale_factor * (1 + np.random.uniform(-0.1, 0.1))\n        mutant_vector = self.population[a] + scale_factor_var * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adaptive_crossover(self, mutant_vector, target_vector):\n        crossover_rate_var = self.crossover_rate * (1 + np.random.uniform(-0.05, 0.05))\n        crossover = np.random.rand(self.dim) < crossover_rate_var\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        local_vector = vector + np.random.normal(0, 0.1, self.dim)\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution leveraging dynamic mutation strategies and adaptive crossover to improve performance.", "configspace": "", "generation": 6, "fitness": 0.20147640386374982, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.39840830113598735, 0.4035237775231507, 0.43342435471635965, 0.4014807735562894, 0.4051987777505286, 0.40842984063459764, 0.4094940157535395, 0.398994719388604, 0.41284698494763994, 0.028735250275889523, 0.021382491274150706, 0.03811416110423127, 0.03987399388193824, 0.022294417569190927, 0.0221413445719314, 0.04264953553283435, 0.023972045485728954, 0.024284462984732635, 0.0915401137515599, 0.1018508571995701, 0.09120092523484291, 0.08839305287204335, 0.08119375716320176, 0.08359562680365851, 0.10454472688140837, 0.1078710682163051, 0.09137790764390752, 0.09941289550844756, 0.07475778868948257, 0.08497410744819822, 0.08140890121391298, 0.08764432365440389, 0.09401529342184844, 0.07315370595043225, 0.08295903180677178, 0.07635328127397445, 0.8705356500698656, 0.8660907514987544, 0.9126269442048237, 0.8887018588281924, 0.9131737401689466, 0.886775299767741, 0.9309243096774344, 0.8221626143011854, 0.893518843274025, 0.23246988747743735, 0.22630986159741218, 0.24022766340688317, 0.23392570541967384, 0.23227130529452988, 0.24153348008954845, 0.2294185980719844, 0.2292297475921269, 0.23354508756821202, 0.295029681041052, 0.28523675856903286, 0.27936729623518464, 0.28562816692516846, 0.36104333445484604, 0.3031444866168377, 0.28785281474354996, 0.2852241905800216, 0.2740142100372217, 0.15046291382923027, 0.12528810611780883, 0.15904581819967312, 0.14907111349189184, 0.1494658806226058, 0.13415562470541442, 0.14659334225042564, 0.13633260952302095, 0.13522719835054198, 0.10616644942055697, 0.13985863877445115, 0.1353386817854444, 0.13636823872238124, 0.12176128823612054, 0.13158125170071344, 0.13420444403245202, 0.1296482524295428, 0.1452032303826265, 0.01462933075498063, 0.0007095681975720636, 0.012014532948606549, 0.0005432529992919211, 0.02306451172958912, 0.012446030801910646, 0.016536922420056777, 0.010625264310966998, 0.008385325964612056, 0.0931504382257422, 0.09885278716010037, 0.067403929774831, 0.12455521347094223, 0.07918435754944186, 0.08408009118009163, 0.10163623138543298, 0.08712571578210482, 0.07315672577761057, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0801369465543077, 0.09222084335298164, 0.07418724349443473, 0.0805584192325598, 0.08473575864125593, 0.0882123709360696, 0.08508830378674725, 0.09918948420046036, 0.08960757100725059, 0.3785704568455214, 0.3726987378075278, 0.3742035993936269, 0.3674873548990788, 0.38270566724731137, 0.3731641939414816, 0.3709164695146857, 0.36252185515400903, 0.3713187464360168, 0.0851708210797455, 0.08449396294495504, 0.0991193596566523, 0.08259676345536904, 0.08353190643567798, 0.09293763000487765, 0.07894260738969006, 0.09740525165342495, 0.07750165957574029, 0.1555624658326018, 0.224202972437603, 0.1817461948946213, 0.16796723113023093, 0.14379119777253013, 0.16230528209259587, 0.13902897883479182, 0.13778130305795766, 0.1553088996626728, 0.24261810291068076, 0.24862887379381593, 0.24611908553099815, 0.24912906368777854, 0.23961805718707951, 0.24471473966053914, 0.25330862454226777, 0.2631514437005692, 0.2658720531738312, 0.18826330084366638, 0.19278766822323146, 0.18696271062980663, 0.1934467086479693, 0.17540027813493975, 0.18563169058104956, 0.19390399956591786, 0.19759918896075024, 0.1991231987151385, 0.19910217695429855, 0.1704837895124529, 0.18930185395966626, 0.21233073906388256, 0.18625696999164854, 0.20666434660056132, 0.17562538197150201, 0.16878488329953212, 0.19557383493609937, 0.16927686524304097, 0.1794086135705053, 0.17651346106907817, 0.17619147902401544, 0.17367119446160273, 0.17615543464732508, 0.1756516367256219, 0.17644537825151396, 0.1730973226556498, 0.14866353651303166, 0.49997749085496956, 0.5011369875967358, 0.47659606217172334, 0.40658572882542665, 0.4300896103031945, 0.4340021335053069, 0.4444772391166165, 0.3887102554442009, 0.19540760204010876, 0.375922057773762, 0.37155865014865963, 0.18935594755632879, 0.2753845937020061, 0.17313547168321997, 0.2061291322001293, 0.20857156704547775, 0.20627163402547466, 0.18578363756750527, 0.18486903829724688, 0.1968006099896239, 0.19213020560201954, 0.18126768466933885, 0.19161093268295848, 0.17586100744667565, 0.1794025346082544, 0.2034266784618154, 0.0649930261911209, 0.06491042526888902, 0.0706276110053885, 0.08219734587538607, 0.06990874888650556, 0.07733387123091273, 0.06326705561517343, 0.0693616339650085, 0.0631906125729087]}, "mutation_prompt": null}
{"id": "b2b3345b-f0af-4876-872e-1652b1b7d0aa", "solution": "import numpy as np\n\nclass HybridPSOandDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.velocities = np.zeros((self.population_size, dim))\n        self.personal_best = np.copy(self.population)\n        self.best_fitness = np.full(self.population_size, np.inf)\n        self.global_best = None\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                self.update_velocity(i)\n                self.update_position(i)\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n                    self.personal_best[i] = trial_vector\n                    self.best_fitness[i] = trial_fitness\n                if self.global_best is None or trial_fitness < func(self.global_best):\n                    self.global_best = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.best_fitness[i] = self.fitness[i]\n                self.personal_best[i] = self.population[i]\n                self.evaluations += 1\n\n    def update_velocity(self, idx):\n        inertia_weight = 0.5\n        cognitive_coeff = 2.0\n        social_coeff = 2.0\n        self.velocities[idx] = (inertia_weight * self.velocities[idx] +\n                                cognitive_coeff * np.random.rand(self.dim) * (self.personal_best[idx] - self.population[idx]) +\n                                social_coeff * np.random.rand(self.dim) * (self.global_best - self.population[idx]))\n\n    def update_position(self, idx):\n        self.population[idx] = np.clip(self.population[idx] + self.velocities[idx], self.lower_bound, self.upper_bound)\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        local_vector = vector + np.random.normal(0, 0.1, self.dim)\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "HybridPSOandDE", "description": "Hybrid Particle Swarm and Differential Evolution with Adaptive Dimensional Mutation for Balanced Exploration and Exploitation.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {}, "mutation_prompt": null}
{"id": "eeffd0a4-8e80-4ef3-9d53-8994a982d25a", "solution": "import numpy as np\n\nclass MultiStrategyDEwithProbabilisticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.7  # Slightly reduced scale factor\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.1  # Probability of local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Reduced step size for local search\n        local_vector = vector + step_size\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "MultiStrategyDEwithProbabilisticLocalSearch", "description": "Multi-Strategy Differential Evolution with Probabilistic Local Search for enhanced global and local exploration.", "configspace": "", "generation": 8, "fitness": 0.27426349624941854, "feedback": "The algorithm MultiStrategyDEwithProbabilisticLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "af62cc83-623a-4fbd-a0f0-5f1c37bdba18", "metadata": {"aucs": [0.6976055902708318, 0.6842239323564053, 0.6983985794521024, 0.723309706283758, 0.726306259854796, 0.7147384240546697, 0.7194905969105228, 0.722236368232072, 0.7145625131988589, 0.4912833657503064, 0.4666327104221144, 0.48019992314158555, 0.4458868813345326, 0.44924059875398625, 0.4520901060182676, 0.46222388930887315, 0.46148594605014115, 0.47656027145875546, 0.1038046887720322, 0.11626575606456535, 0.1288114282224686, 0.10575467089508472, 0.10865328659484619, 0.11124037700642275, 0.12323828193945552, 0.11483729632212147, 0.11562690032337741, 0.09954553295106394, 0.09872805637171311, 0.08723572971992166, 0.11153237438718533, 0.09364380779100323, 0.09243494697243981, 0.09298178716313144, 0.0976554651466045, 0.1201320409283817, 0.9388134650952592, 0.9230504603076867, 0.9738103260279127, 0.9659524570795663, 0.9610151272247964, 0.9706610336321845, 0.9260379545554593, 0.957004109404875, 0.938570148719758, 0.31111095016744517, 0.2992219607014278, 0.29125702643172036, 0.3023201881101196, 0.30622708459397796, 0.2999958488804585, 0.31439981703637876, 0.32827575052785885, 0.3192889665492087, 0.47248148768011555, 0.44826688363595224, 0.5409574765414505, 0.5982154707311136, 0.5499899178624962, 0.5287003418765096, 0.5272078053050686, 0.47167296220445176, 0.5377009153037366, 0.20452673035187796, 0.2010931760199094, 0.19444773571363883, 0.20272694819588455, 0.20829876822322846, 0.2005657877512571, 0.1882141749132621, 0.1816310111921, 0.1910094707362625, 0.22365015320241077, 0.11912288864385268, 0.1494330208261756, 0.21694667429920933, 0.20737175386097328, 0.1857580567184297, 0.17743573602614193, 0.19842107342564952, 0.18781023095810556, 0.07726215102424416, 0.07420346045663695, 0.07014071971912983, 0.0804368699557566, 0.05524504163978583, 0.06631491967648784, 0.09842062287297126, 0.054371442068553044, 0.09806658330289608, 0.16364678083070916, 0.191165045391957, 0.19042637857494804, 0.20169163941513657, 0.20262142969155938, 0.14872665175351596, 0.2279788664190473, 0.22126634247176924, 0.214515857488353, 0.03774841920434646, 0.02027123229280492, 0.014685212317105623, 0.03554218601301384, 0.029244377129720278, 0.017576387351286527, 0.007844304730553864, 0.025070728946605003, 0.026420972621459482, 0.15028799464693599, 0.12813411301823652, 0.13644601222460273, 0.16089678380333572, 0.1479278339087452, 0.13594368478790075, 0.13555445029846303, 0.14744686187308997, 0.15070639926151708, 0.48798379092618327, 0.49182978057073135, 0.5003608101983215, 0.48390796040526274, 0.4881819435640943, 0.47877400095364697, 0.4864191406712576, 0.49822452480303503, 0.4794423218744278, 0.09609956945553855, 0.08780954819987874, 0.1046489911675168, 0.10675298345173401, 0.08528837801216482, 0.09834123286407592, 0.08898279311426738, 0.09865565903190576, 0.09392549052783183, 0.13960177090979942, 0.1441490592202863, 0.1335116749974561, 0.17411146682607648, 0.1637126145769766, 0.13944256728771454, 0.14423681043784187, 0.14909869226253591, 0.15414945515388245, 0.28176326447313826, 0.2855666438847756, 0.2961135516778378, 0.28970929324709527, 0.2778612811603396, 0.2776186376723374, 0.30047098508103665, 0.32962141054464267, 0.32766853249837646, 0.21901133499972492, 0.22382085804382168, 0.2112214198843666, 0.19070122989283622, 0.203661194791251, 0.20158212956051613, 0.2144008492685332, 0.20361984426419222, 0.23049066800331197, 0.17658300219869782, 0.16645622184935638, 0.18549836525771823, 0.18145032016745677, 0.18181978708356228, 0.19811470156699174, 0.18777117299344548, 0.18709291734617395, 0.18063916473198716, 0.1837160384372608, 0.17689922054706309, 0.18598848626248787, 0.18771935704150955, 0.18326227638749792, 0.18967667864640603, 0.19253940435277073, 0.21076973058847837, 0.17229828159203675, 0.4624072814423702, 0.1929059994144714, 0.30618459713448487, 0.501904639276588, 0.1842968363332651, 0.553518675988576, 0.38171465430921836, 0.27410130425937396, 0.41295640648554377, 0.3514044431606336, 0.350390287056092, 0.2719433365787868, 0.29744833153087624, 0.19361305576184318, 0.45480133281523527, 0.481934035974671, 0.20296643633827105, 0.6293482143321468, 0.18714552898389225, 0.192419154327944, 0.17682725330299542, 0.2047680052362001, 0.1831869756388136, 0.185722836265388, 0.19354264202814364, 0.17510885495299722, 0.20603058140888675, 0.08183276643570192, 0.0686882505497366, 0.06509254232145045, 0.07697440860886018, 0.0746083435359296, 0.06788362089148214, 0.06810800197845834, 0.0748623942966209, 0.06991569860203561]}, "mutation_prompt": null}
{"id": "b4aeb55f-0e06-4129-b4f7-d52685e412fd", "solution": "import numpy as np\n\nclass MultiStrategyDEwithProbabilisticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.7  # Slightly reduced scale factor\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.1  # Probability of local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Reduced step size for local search\n        local_vector = vector + step_size\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "MultiStrategyDEwithProbabilisticLocalSearch", "description": "Multi-Strategy Differential Evolution with Probabilistic Local Search for enhanced global and local exploration.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eeffd0a4-8e80-4ef3-9d53-8994a982d25a", "metadata": {"aucs": [0.6976055902708318, 0.6842239323564053, 0.6983985794521024, 0.723309706283758, 0.726306259854796, 0.7147384240546697, 0.7194905969105228, 0.722236368232072, 0.7145625131988589, 0.4912833657503064, 0.4666327104221144, 0.48019992314158555, 0.4458868813345326, 0.44924059875398625, 0.4520901060182676, 0.46222388930887315, 0.46148594605014115, 0.47656027145875546, 0.1038046887720322, 0.11626575606456535, 0.1288114282224686, 0.10575467089508472, 0.10865328659484619, 0.11124037700642275, 0.12323828193945552, 0.11483729632212147, 0.11562690032337741, 0.09954553295106394, 0.09872805637171311, 0.08723572971992166, 0.11153237438718533, 0.09364380779100323, 0.09243494697243981, 0.09298178716313144, 0.0976554651466045, 0.1201320409283817, 0.9388134650952592, 0.9230504603076867, 0.9738103260279127, 0.9659524570795663, 0.9610151272247964, 0.9706610336321845, 0.9260379545554593, 0.957004109404875, 0.938570148719758, 0.31111095016744517, 0.2992219607014278, 0.29125702643172036, 0.3023201881101196, 0.30622708459397796, 0.2999958488804585, 0.31439981703637876, 0.32827575052785885, 0.3192889665492087, 0.47248148768011555, 0.44826688363595224, 0.5409574765414505, 0.5982154707311136, 0.5499899178624962, 0.5287003418765096, 0.5272078053050686, 0.47167296220445176, 0.5377009153037366, 0.20452673035187796, 0.2010931760199094, 0.19444773571363883, 0.20272694819588455, 0.20829876822322846, 0.2005657877512571, 0.1882141749132621, 0.1816310111921, 0.1910094707362625, 0.22365015320241077, 0.11912288864385268, 0.1494330208261756, 0.21694667429920933, 0.20737175386097328, 0.1857580567184297, 0.17743573602614193, 0.19842107342564952, 0.18781023095810556, 0.07726215102424416, 0.07420346045663695, 0.07014071971912983, 0.0804368699557566, 0.05524504163978583, 0.06631491967648784, 0.09842062287297126, 0.054371442068553044, 0.09806658330289608, 0.16364678083070916, 0.191165045391957, 0.19042637857494804, 0.20169163941513657, 0.20262142969155938, 0.14872665175351596, 0.2279788664190473, 0.22126634247176924, 0.214515857488353, 0.03774841920434646, 0.02027123229280492, 0.014685212317105623, 0.03554218601301384, 0.029244377129720278, 0.017576387351286527, 0.007844304730553864, 0.025070728946605003, 0.026420972621459482, 0.15028799464693599, 0.12813411301823652, 0.13644601222460273, 0.16089678380333572, 0.1479278339087452, 0.13594368478790075, 0.13555445029846303, 0.14744686187308997, 0.15070639926151708, 0.48798379092618327, 0.49182978057073135, 0.5003608101983215, 0.48390796040526274, 0.4881819435640943, 0.47877400095364697, 0.4864191406712576, 0.49822452480303503, 0.4794423218744278, 0.09609956945553855, 0.08780954819987874, 0.1046489911675168, 0.10675298345173401, 0.08528837801216482, 0.09834123286407592, 0.08898279311426738, 0.09865565903190576, 0.09392549052783183, 0.13960177090979942, 0.1441490592202863, 0.1335116749974561, 0.17411146682607648, 0.1637126145769766, 0.13944256728771454, 0.14423681043784187, 0.14909869226253591, 0.15414945515388245, 0.28176326447313826, 0.2855666438847756, 0.2961135516778378, 0.28970929324709527, 0.2778612811603396, 0.2776186376723374, 0.30047098508103665, 0.32962141054464267, 0.32766853249837646, 0.21901133499972492, 0.22382085804382168, 0.2112214198843666, 0.19070122989283622, 0.203661194791251, 0.20158212956051613, 0.2144008492685332, 0.20361984426419222, 0.23049066800331197, 0.17658300219869782, 0.16645622184935638, 0.18549836525771823, 0.18145032016745677, 0.18181978708356228, 0.19811470156699174, 0.18777117299344548, 0.18709291734617395, 0.18063916473198716, 0.1837160384372608, 0.17689922054706309, 0.18598848626248787, 0.18771935704150955, 0.18326227638749792, 0.18967667864640603, 0.19253940435277073, 0.21076973058847837, 0.17229828159203675, 0.4624072814423702, 0.1929059994144714, 0.30618459713448487, 0.501904639276588, 0.1842968363332651, 0.553518675988576, 0.38171465430921836, 0.27410130425937396, 0.41295640648554377, 0.3514044431606336, 0.350390287056092, 0.2719433365787868, 0.29744833153087624, 0.19361305576184318, 0.45480133281523527, 0.481934035974671, 0.20296643633827105, 0.6293482143321468, 0.18714552898389225, 0.192419154327944, 0.17682725330299542, 0.2047680052362001, 0.1831869756388136, 0.185722836265388, 0.19354264202814364, 0.17510885495299722, 0.20603058140888675, 0.08183276643570192, 0.0686882505497366, 0.06509254232145045, 0.07697440860886018, 0.0746083435359296, 0.06788362089148214, 0.06810800197845834, 0.0748623942966209, 0.06991569860203561]}, "mutation_prompt": null}
{"id": "280987fc-114b-4af1-ab51-daf859584e48", "solution": "import numpy as np\n\nclass MultiStrategyDEwithProbabilisticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.7  # Slightly reduced scale factor\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.1  # Probability of local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Reduced step size for local search\n        local_vector = vector + step_size\n        return np.clip(local_vector, self.lower_bound, self.upper_bound)", "name": "MultiStrategyDEwithProbabilisticLocalSearch", "description": "Multi-Strategy Differential Evolution with Probabilistic Local Search for enhanced global and local exploration.", "configspace": "", "generation": 9, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eeffd0a4-8e80-4ef3-9d53-8994a982d25a", "metadata": {"aucs": [0.6976055902708318, 0.6842239323564053, 0.6983985794521024, 0.723309706283758, 0.726306259854796, 0.7147384240546697, 0.7194905969105228, 0.722236368232072, 0.7145625131988589, 0.4912833657503064, 0.4666327104221144, 0.48019992314158555, 0.4458868813345326, 0.44924059875398625, 0.4520901060182676, 0.46222388930887315, 0.46148594605014115, 0.47656027145875546, 0.1038046887720322, 0.11626575606456535, 0.1288114282224686, 0.10575467089508472, 0.10865328659484619, 0.11124037700642275, 0.12323828193945552, 0.11483729632212147, 0.11562690032337741, 0.09954553295106394, 0.09872805637171311, 0.08723572971992166, 0.11153237438718533, 0.09364380779100323, 0.09243494697243981, 0.09298178716313144, 0.0976554651466045, 0.1201320409283817, 0.9388134650952592, 0.9230504603076867, 0.9738103260279127, 0.9659524570795663, 0.9610151272247964, 0.9706610336321845, 0.9260379545554593, 0.957004109404875, 0.938570148719758, 0.31111095016744517, 0.2992219607014278, 0.29125702643172036, 0.3023201881101196, 0.30622708459397796, 0.2999958488804585, 0.31439981703637876, 0.32827575052785885, 0.3192889665492087, 0.47248148768011555, 0.44826688363595224, 0.5409574765414505, 0.5982154707311136, 0.5499899178624962, 0.5287003418765096, 0.5272078053050686, 0.47167296220445176, 0.5377009153037366, 0.20452673035187796, 0.2010931760199094, 0.19444773571363883, 0.20272694819588455, 0.20829876822322846, 0.2005657877512571, 0.1882141749132621, 0.1816310111921, 0.1910094707362625, 0.22365015320241077, 0.11912288864385268, 0.1494330208261756, 0.21694667429920933, 0.20737175386097328, 0.1857580567184297, 0.17743573602614193, 0.19842107342564952, 0.18781023095810556, 0.07726215102424416, 0.07420346045663695, 0.07014071971912983, 0.0804368699557566, 0.05524504163978583, 0.06631491967648784, 0.09842062287297126, 0.054371442068553044, 0.09806658330289608, 0.16364678083070916, 0.191165045391957, 0.19042637857494804, 0.20169163941513657, 0.20262142969155938, 0.14872665175351596, 0.2279788664190473, 0.22126634247176924, 0.214515857488353, 0.03774841920434646, 0.02027123229280492, 0.014685212317105623, 0.03554218601301384, 0.029244377129720278, 0.017576387351286527, 0.007844304730553864, 0.025070728946605003, 0.026420972621459482, 0.15028799464693599, 0.12813411301823652, 0.13644601222460273, 0.16089678380333572, 0.1479278339087452, 0.13594368478790075, 0.13555445029846303, 0.14744686187308997, 0.15070639926151708, 0.48798379092618327, 0.49182978057073135, 0.5003608101983215, 0.48390796040526274, 0.4881819435640943, 0.47877400095364697, 0.4864191406712576, 0.49822452480303503, 0.4794423218744278, 0.09609956945553855, 0.08780954819987874, 0.1046489911675168, 0.10675298345173401, 0.08528837801216482, 0.09834123286407592, 0.08898279311426738, 0.09865565903190576, 0.09392549052783183, 0.13960177090979942, 0.1441490592202863, 0.1335116749974561, 0.17411146682607648, 0.1637126145769766, 0.13944256728771454, 0.14423681043784187, 0.14909869226253591, 0.15414945515388245, 0.28176326447313826, 0.2855666438847756, 0.2961135516778378, 0.28970929324709527, 0.2778612811603396, 0.2776186376723374, 0.30047098508103665, 0.32962141054464267, 0.32766853249837646, 0.21901133499972492, 0.22382085804382168, 0.2112214198843666, 0.19070122989283622, 0.203661194791251, 0.20158212956051613, 0.2144008492685332, 0.20361984426419222, 0.23049066800331197, 0.17658300219869782, 0.16645622184935638, 0.18549836525771823, 0.18145032016745677, 0.18181978708356228, 0.19811470156699174, 0.18777117299344548, 0.18709291734617395, 0.18063916473198716, 0.1837160384372608, 0.17689922054706309, 0.18598848626248787, 0.18771935704150955, 0.18326227638749792, 0.18967667864640603, 0.19253940435277073, 0.21076973058847837, 0.17229828159203675, 0.4624072814423702, 0.1929059994144714, 0.30618459713448487, 0.501904639276588, 0.1842968363332651, 0.553518675988576, 0.38171465430921836, 0.27410130425937396, 0.41295640648554377, 0.3514044431606336, 0.350390287056092, 0.2719433365787868, 0.29744833153087624, 0.19361305576184318, 0.45480133281523527, 0.481934035974671, 0.20296643633827105, 0.6293482143321468, 0.18714552898389225, 0.192419154327944, 0.17682725330299542, 0.2047680052362001, 0.1831869756388136, 0.185722836265388, 0.19354264202814364, 0.17510885495299722, 0.20603058140888675, 0.08183276643570192, 0.0686882505497366, 0.06509254232145045, 0.07697440860886018, 0.0746083435359296, 0.06788362089148214, 0.06810800197845834, 0.0748623942966209, 0.06991569860203561]}, "mutation_prompt": null}
{"id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "solution": "import numpy as np\n\nclass MultiStrategyDEwithProbabilisticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.6  # Adjusted scale factor for better exploration\n        self.crossover_rate = 0.85  # Adjusted crossover rate for better exploration\n        self.evaluations = 0\n        self.local_search_rate = 0.15  # Increased probability of local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Slightly increased step size for more aggressive local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Dynamic adjustment based on improvement\n            vector = local_vector\n        return vector", "name": "MultiStrategyDEwithProbabilisticLocalSearch", "description": "Adaptive Differential Evolution with Dynamic Local Search Enhancements for Improved Convergence.", "configspace": "", "generation": 11, "fitness": 0.283781958797198, "feedback": "The algorithm MultiStrategyDEwithProbabilisticLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "eeffd0a4-8e80-4ef3-9d53-8994a982d25a", "metadata": {"aucs": [0.6933572421097514, 0.6997944131216527, 0.7104159809580151, 0.6878017980410378, 0.6894606264326236, 0.721434044720586, 0.7267299836000061, 0.7051253262951769, 0.7204054587915399, 0.44415102411928, 0.43935591688963116, 0.5100779786260661, 0.4667888989863048, 0.48874491430058975, 0.4977384506241821, 0.5170217528432632, 0.4862109333919896, 0.47824422213133233, 0.11807784100760998, 0.10598846823706387, 0.13149035977636436, 0.10262848825572912, 0.09612569071912425, 0.12813824370408, 0.11639201252267506, 0.10648395210302519, 0.09414916677771412, 0.09707438431477655, 0.09540387266963213, 0.0970692831553579, 0.09652663770037584, 0.08820734906930794, 0.09706194198648177, 0.09508810435284853, 0.08849091237737938, 0.08573121302154485, 0.9395541197533384, 0.8941772210207174, 0.8999744203378741, 0.9077079968236319, 0.9412399317168759, 0.83181478708879, 0.8661579705382003, 0.9414402666964277, 0.8900811132564814, 0.32119139570256805, 0.33596406293255765, 0.31791167898963124, 0.3060217414852028, 0.3156894068827639, 0.3460860381205484, 0.32258431580344105, 0.3339964845226483, 0.3143696498275427, 0.5691313767246171, 0.5994228232044024, 0.54447618365065, 0.6033290027337244, 0.6511539547855214, 0.62357472011295, 0.563917378208483, 0.5891609913318456, 0.6336769886088744, 0.200829458604746, 0.185862193282756, 0.2125503440387505, 0.18286905329979486, 0.18840974449984427, 0.1924687276123087, 0.19626231081295054, 0.26293473641521603, 0.22082885269424257, 0.19493736861136124, 0.1546583234015887, 0.13024275234615434, 0.17292985641930025, 0.18193657325930823, 0.18214807190894822, 0.21778900221820485, 0.18828756577950212, 0.18856774813898913, 0.12119645381152022, 0.15428998284068185, 0.14043888723869713, 0.12830967623336142, 0.14228379279379955, 0.12811716808312013, 0.14257760945996067, 0.13843791542573436, 0.1734109248928195, 0.24203696195045565, 0.26181782440975865, 0.26443288329577996, 0.28383294497338096, 0.2551688570000711, 0.24047384182578946, 0.28205340844098836, 0.3009593016266595, 0.28747460537723357, 0.034064323900421134, 0.03741078821539345, 0.04613671612025716, 0.06125823549507736, 0.05012136268659306, 0.09891616250295865, 0.04416303880729178, 0.04827913243159254, 0.041318933359736354, 0.17114963312671894, 0.15518597120196032, 0.17006131117109158, 0.18195652176899912, 0.17358941322348165, 0.18483589135136202, 0.1831913370386805, 0.18035007265747882, 0.16494595180289928, 0.5074236082354611, 0.5537071361624155, 0.5645169787415119, 0.5254009931931887, 0.51745433127391, 0.5327314862263179, 0.5358520787632051, 0.5126323403846167, 0.5197183132975973, 0.08944263287456, 0.08061758534391117, 0.08565947458360335, 0.0984046016361717, 0.08768883177385545, 0.07525668069966451, 0.0948340079145008, 0.08737504334122059, 0.08021040230740473, 0.14499202633239916, 0.15220816407658744, 0.13355279226633998, 0.12561939126389665, 0.14071891483405996, 0.12718852103675948, 0.13128266544685063, 0.14559955582956996, 0.1241013884473321, 0.30038288446391925, 0.3196799818357017, 0.3085891271207595, 0.323954154361216, 0.3090628281106419, 0.3035617868854018, 0.3158633866944872, 0.3372393115050901, 0.3510952964589935, 0.22863757940319396, 0.22858029536215463, 0.23882054797551022, 0.19894395289381828, 0.2021114272956458, 0.2180939105895161, 0.2143736741495873, 0.2459658274312555, 0.25645246884769757, 0.18408971485213899, 0.16805037027627168, 0.18826274982701507, 0.20907362476489433, 0.2278271478621149, 0.18101000998155126, 0.17699165609694778, 0.17571019145724553, 0.1936023195243548, 0.1877668963062603, 0.1832054134191501, 0.1839366681629957, 0.19126216829591913, 0.17642092870210513, 0.17710572480491404, 0.1982246338848811, 0.1794941040416439, 0.18647747028241357, 0.17389364033857435, 0.5137130064868931, 0.18473855194113398, 0.3639008219100156, 0.5791204839016371, 0.48059375214078015, 0.1714804551700101, 0.19856293830889815, 0.5196100185665607, 0.32063345484974826, 0.1971091055205909, 0.5387468094744532, 0.16980153412189958, 0.18810320718767604, 0.29811920673951653, 0.5108042887284356, 0.2061415179111149, 0.19816238752568116, 0.18436187110315105, 0.18317448359454813, 0.18954775887462316, 0.1759324615972746, 0.19237394650014916, 0.19050510058701453, 0.20106599994059693, 0.1865161907183498, 0.19016696157335922, 0.07434844595325507, 0.07957920816480546, 0.07726016260773849, 0.06857800183325524, 0.07285279011190726, 0.06786240202915483, 0.0734772428108994, 0.07088682036972782, 0.0655144623068139]}, "mutation_prompt": null}
{"id": "fcdb9150-b21c-4b7e-bd4a-513c44b0d5ec", "solution": "import numpy as np\n\nclass HybridAdaptiveDEwithEnhancedLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.7  # Adjusted scale factor for balanced exploration-exploitation\n        self.crossover_rate = 0.9  # Increased crossover rate for better information sharing\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Higher local search probability for intensified exploitation\n        self.mutation_strategy = 'rand/1/bin'  # Mutation strategy for parameter diversity\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        if self.mutation_strategy == 'rand/1/bin':\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        else:\n            # Fallback mutation\n            a, b, c = np.random.choice(indices, 3, replace=False)\n            mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.15, self.dim)  # Larger step size for more aggressive local refinement\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "HybridAdaptiveDEwithEnhancedLocalSearch", "description": "Hybridized Adaptive Differential Evolution with Enhanced Local Search and Dynamic Strategy Adaptation.", "configspace": "", "generation": 12, "fitness": 0.2297399443829814, "feedback": "The algorithm HybridAdaptiveDEwithEnhancedLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.5334882207417222, 0.528085502167478, 0.5396190925442084, 0.538346784438282, 0.5687881469009239, 0.5643510728989771, 0.5427572558664563, 0.5059680025160305, 0.5092511724964953, 0.2922079926252743, 0.2943359286106987, 0.274782290485419, 0.2712789849872108, 0.26494923170281925, 0.2553015816248565, 0.2627502808190839, 0.24753250168212293, 0.2794751222492796, 0.09591301428893562, 0.08784203767607801, 0.09146554669987272, 0.07977563485824246, 0.09949895994466862, 0.09015904863527813, 0.09641647448344026, 0.09007244971818729, 0.09142666013316192, 0.08120439014989311, 0.0862838913864662, 0.0773570817574899, 0.08384878880642321, 0.0781845222659977, 0.07817683004873455, 0.07548075626809225, 0.08174412995809877, 0.08193802748073453, 0.9448087317510964, 0.8891562963982425, 0.9530349636401001, 0.9109490494176512, 0.9358896926088259, 0.9617066862774895, 0.8943099517801419, 0.8320730413784496, 0.9531464598948207, 0.2457920960868587, 0.2150344519990649, 0.21147577969896925, 0.22125436120343334, 0.2498953737066878, 0.22383071439905844, 0.23689898590574254, 0.24621527918108788, 0.24999562369484452, 0.42471640107928277, 0.3864787510479999, 0.4493288962778207, 0.4455857460367102, 0.4913136637664959, 0.4382860338308737, 0.4200128420642065, 0.3906257556219752, 0.4350954628001267, 0.17092468833648877, 0.14904533833356493, 0.13946918467131675, 0.14585850022123592, 0.17155825750003695, 0.14994101361229673, 0.17660127564462835, 0.13639241444112127, 0.14768572925299106, 0.19713102305299612, 0.135698201299442, 0.11475139355621178, 0.14528298572106269, 0.13005462707416393, 0.155281028441431, 0.15232042442458338, 0.13758121465721784, 0.12623431591906265, 0.08226622003648609, 0.07198642266724742, 0.0716296478732753, 0.08270156689438468, 0.08460046619098627, 0.08975276386831976, 0.07372113266158853, 0.07006294967509841, 0.11087363296379227, 0.20611174308926317, 0.23779777096371213, 0.21940295972708468, 0.18202429050920066, 0.19940589889173188, 0.1866466471723709, 0.24646910305029468, 0.2126573631312797, 0.23487056304844478, 0.012041726039581424, 0.002467194385666338, 0.019885464598232594, 0.019817906807135133, 0.0153310921018186, 0.012661279813053206, 0.006689008751393888, 0.02217242382343576, 0.024104484784930325, 0.11031745024456396, 0.11378595882284703, 0.12487824572097506, 0.11769599557070543, 0.11815211205316378, 0.13365948367459746, 0.11513017355253907, 0.12204473129521087, 0.111942529372271, 0.419806786232488, 0.42311012062994247, 0.41473798602646417, 0.429920414092696, 0.4130370410991665, 0.4227885436290244, 0.43028672290738, 0.41377855115105133, 0.4739706975509437, 0.08608181052903985, 0.09988717894848231, 0.08219367688996904, 0.0868500447016628, 0.07799731867110726, 0.08956516167031836, 0.0847410044309217, 0.07923693487096606, 0.09007735270486483, 0.1666156665109827, 0.12761807668634462, 0.13347103700117646, 0.13832746360217696, 0.16035162651382673, 0.13671590782571763, 0.14966649505228302, 0.1358254368534807, 0.1380017585037593, 0.2422457911151683, 0.2528564709981659, 0.25066279239209954, 0.24878601513219567, 0.2495672282869036, 0.251525848770781, 0.26907338634635003, 0.268784007712477, 0.26198163902819027, 0.19982412550632478, 0.18832066125964764, 0.2063974946626307, 0.18487092640179048, 0.1914745126396864, 0.18935977129381087, 0.19125737642310148, 0.19646815393889439, 0.176492672103439, 0.17820058943344863, 0.18798111443478227, 0.16555326564515016, 0.18758271412569072, 0.17438506679215948, 0.1837971008818392, 0.17287040749974147, 0.17747826289036073, 0.1826846093542459, 0.183219573672754, 0.17154388714246294, 0.16786698846905967, 0.1798374615448216, 0.1748255469091049, 0.18502073779842565, 0.1704683183860627, 0.17256120650469908, 0.17104822320887236, 0.3869589995746642, 0.17784831291907977, 0.4253547302016023, 0.22776261957322352, 0.15783741484551306, 0.20442904443222865, 0.3404478389695207, 0.34660992216781683, 0.5434167396804338, 0.1856719494271475, 0.20861553974434865, 0.14881422596805438, 0.18794937190381966, 0.2388702934250374, 0.2153801737937593, 0.19938202211558143, 0.20441399849238173, 0.20134884512089857, 0.1844151650917384, 0.17852292915124035, 0.1886290013296107, 0.1748952425847381, 0.20859685968009167, 0.1812579072592726, 0.17941281471576753, 0.18103197549914873, 0.18472204275210347, 0.0782575341755577, 0.0761047725765599, 0.07121698904668994, 0.05923682591718171, 0.07406356251812107, 0.06654186782247873, 0.06098923381899857, 0.06776049623532776, 0.07098743875094116]}, "mutation_prompt": null}
{"id": "06267900-40d9-4eb5-89f2-01e80c142088", "solution": "import numpy as np\n\nclass MultiStrategyDEwithProbabilisticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.6  # Adjusted scale factor for better exploration\n        self.crossover_rate = 0.85  # Adjusted crossover rate for better exploration\n        self.evaluations = 0\n        self.local_search_rate = 0.15  # Increased probability of local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Slightly increased step size for more aggressive local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Dynamic adjustment based on improvement\n            vector = local_vector\n        return vector", "name": "MultiStrategyDEwithProbabilisticLocalSearch", "description": "Adaptive Differential Evolution with Dynamic Local Search Enhancements for Improved Convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.6933572421097514, 0.6997944131216527, 0.7104159809580151, 0.6878017980410378, 0.6894606264326236, 0.721434044720586, 0.7267299836000061, 0.7051253262951769, 0.7204054587915399, 0.44415102411928, 0.43935591688963116, 0.5100779786260661, 0.4667888989863048, 0.48874491430058975, 0.4977384506241821, 0.5170217528432632, 0.4862109333919896, 0.47824422213133233, 0.11807784100760998, 0.10598846823706387, 0.13149035977636436, 0.10262848825572912, 0.09612569071912425, 0.12813824370408, 0.11639201252267506, 0.10648395210302519, 0.09414916677771412, 0.09707438431477655, 0.09540387266963213, 0.0970692831553579, 0.09652663770037584, 0.08820734906930794, 0.09706194198648177, 0.09508810435284853, 0.08849091237737938, 0.08573121302154485, 0.9395541197533384, 0.8941772210207174, 0.8999744203378741, 0.9077079968236319, 0.9412399317168759, 0.83181478708879, 0.8661579705382003, 0.9414402666964277, 0.8900811132564814, 0.32119139570256805, 0.33596406293255765, 0.31791167898963124, 0.3060217414852028, 0.3156894068827639, 0.3460860381205484, 0.32258431580344105, 0.3339964845226483, 0.3143696498275427, 0.5691313767246171, 0.5994228232044024, 0.54447618365065, 0.6033290027337244, 0.6511539547855214, 0.62357472011295, 0.563917378208483, 0.5891609913318456, 0.6336769886088744, 0.200829458604746, 0.185862193282756, 0.2125503440387505, 0.18286905329979486, 0.18840974449984427, 0.1924687276123087, 0.19626231081295054, 0.26293473641521603, 0.22082885269424257, 0.19493736861136124, 0.1546583234015887, 0.13024275234615434, 0.17292985641930025, 0.18193657325930823, 0.18214807190894822, 0.21778900221820485, 0.18828756577950212, 0.18856774813898913, 0.12119645381152022, 0.15428998284068185, 0.14043888723869713, 0.12830967623336142, 0.14228379279379955, 0.12811716808312013, 0.14257760945996067, 0.13843791542573436, 0.1734109248928195, 0.24203696195045565, 0.26181782440975865, 0.26443288329577996, 0.28383294497338096, 0.2551688570000711, 0.24047384182578946, 0.28205340844098836, 0.3009593016266595, 0.28747460537723357, 0.034064323900421134, 0.03741078821539345, 0.04613671612025716, 0.06125823549507736, 0.05012136268659306, 0.09891616250295865, 0.04416303880729178, 0.04827913243159254, 0.041318933359736354, 0.17114963312671894, 0.15518597120196032, 0.17006131117109158, 0.18195652176899912, 0.17358941322348165, 0.18483589135136202, 0.1831913370386805, 0.18035007265747882, 0.16494595180289928, 0.5074236082354611, 0.5537071361624155, 0.5645169787415119, 0.5254009931931887, 0.51745433127391, 0.5327314862263179, 0.5358520787632051, 0.5126323403846167, 0.5197183132975973, 0.08944263287456, 0.08061758534391117, 0.08565947458360335, 0.0984046016361717, 0.08768883177385545, 0.07525668069966451, 0.0948340079145008, 0.08737504334122059, 0.08021040230740473, 0.14499202633239916, 0.15220816407658744, 0.13355279226633998, 0.12561939126389665, 0.14071891483405996, 0.12718852103675948, 0.13128266544685063, 0.14559955582956996, 0.1241013884473321, 0.30038288446391925, 0.3196799818357017, 0.3085891271207595, 0.323954154361216, 0.3090628281106419, 0.3035617868854018, 0.3158633866944872, 0.3372393115050901, 0.3510952964589935, 0.22863757940319396, 0.22858029536215463, 0.23882054797551022, 0.19894395289381828, 0.2021114272956458, 0.2180939105895161, 0.2143736741495873, 0.2459658274312555, 0.25645246884769757, 0.18408971485213899, 0.16805037027627168, 0.18826274982701507, 0.20907362476489433, 0.2278271478621149, 0.18101000998155126, 0.17699165609694778, 0.17571019145724553, 0.1936023195243548, 0.1877668963062603, 0.1832054134191501, 0.1839366681629957, 0.19126216829591913, 0.17642092870210513, 0.17710572480491404, 0.1982246338848811, 0.1794941040416439, 0.18647747028241357, 0.17389364033857435, 0.5137130064868931, 0.18473855194113398, 0.3639008219100156, 0.5791204839016371, 0.48059375214078015, 0.1714804551700101, 0.19856293830889815, 0.5196100185665607, 0.32063345484974826, 0.1971091055205909, 0.5387468094744532, 0.16980153412189958, 0.18810320718767604, 0.29811920673951653, 0.5108042887284356, 0.2061415179111149, 0.19816238752568116, 0.18436187110315105, 0.18317448359454813, 0.18954775887462316, 0.1759324615972746, 0.19237394650014916, 0.19050510058701453, 0.20106599994059693, 0.1865161907183498, 0.19016696157335922, 0.07434844595325507, 0.07957920816480546, 0.07726016260773849, 0.06857800183325524, 0.07285279011190726, 0.06786240202915483, 0.0734772428108994, 0.07088682036972782, 0.0655144623068139]}, "mutation_prompt": null}
{"id": "e9bd743d-fc8a-4055-9ed5-53cbd152db8a", "solution": "import numpy as np\n\nclass EnhancedDEwithStochasticElementalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size for improved diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.7  # Modified scale factor for balanced exploration-exploitation\n        self.crossover_rate = 0.9  # Higher crossover rate for better recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability of local search for finer improvements\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.stochastic_elemental_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def stochastic_elemental_search(self, vector, func):\n        step_size = np.random.normal(0, 0.2, self.dim)  # Introduced stochastic variations for flexibility\n        for _ in range(5):  # Iterated elemental steps for potential multiple refinements\n            local_vector = vector + step_size\n            local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n            if func(local_vector) < func(vector):\n                vector = local_vector\n        return vector", "name": "EnhancedDEwithStochasticElementalSearch", "description": "Enhanced Differential Evolution with Stochastic Elemental Search for Versatile Optimization Performance.", "configspace": "", "generation": 14, "fitness": 0.15854439599146022, "feedback": "The algorithm EnhancedDEwithStochasticElementalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.3327083536360147, 0.33263932205776614, 0.31522080072063907, 0.3539092605223506, 0.3730320527770248, 0.3658824273414608, 0.3264515124385432, 0.30151032131680544, 0.33650669458977955, 0.06620952940107361, 0.07242158666335541, 0.08143603528882193, 0.07462522915322911, 0.06343715473852896, 0.09012054626529065, 0.07453054292970973, 0.06421866926577713, 0.07538056464561382, 0.07269014453302147, 0.07257970045660789, 0.08234586889983386, 0.07605937997440271, 0.06578865078816765, 0.07740077083548835, 0.08661282669069459, 0.07807480275024392, 0.06933046818301569, 0.05486623354252296, 0.06332498287930943, 0.06421941349521365, 0.06440719416509377, 0.0576355598622833, 0.06803110878536123, 0.06182091614614782, 0.06948109659135537, 0.06425534084603368, 0.8625371409100347, 0.8461362433452092, 0.8905243696285974, 0.9145073086292617, 0.849427246703991, 0.9250312395327218, 0.7078836489995196, 0.7828114059034892, 0.7747059055573802, 0.14049639818132564, 0.12405152801172137, 0.12851405596339904, 0.1441946684589639, 0.14031967377986743, 0.1486936806352973, 0.14879479445082833, 0.15033846921087657, 0.13529621734798858, 0.21105118956968805, 0.20481172835932138, 0.19863319212287744, 0.20179139620967013, 0.23421881490022445, 0.20185522549178625, 0.20448085963035623, 0.19327116747079287, 0.2600624421948975, 0.07543317685853967, 0.07918272679511684, 0.1049129865663685, 0.07569901720994998, 0.08458626419835069, 0.06672081664467155, 0.10970715971607292, 0.06603733101693965, 0.07157467577148269, 0.06857535440670492, 0.058510649277690785, 0.07252332721772603, 0.08601517708698014, 0.0685955732836182, 0.08548221028036274, 0.07387019768882419, 0.06897643179710233, 0.07733593883010381, 0.007209428098548631, 0.002222750427890552, 0.003917793882418308, 0.0041101230805168365, 0.0020289737778793615, 0.0042076187986574975, 0.0019411735755587856, 0.008003094688910695, 0.004313432140076512, 0.08995467393771994, 0.09422527472046549, 0.11593876658403679, 0.1029764693452706, 0.11285809064277763, 0.06761872262263624, 0.14656348512629336, 0.10114687950464918, 0.13117494151496545, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04282799192318376, 0.044130985387946575, 0.04811700370848271, 0.06945588262029379, 0.049484065232359375, 0.06969616516171229, 0.05272831392445443, 0.05528993942265692, 0.047353820091455834, 0.2917271017062192, 0.3057999026593283, 0.294166105695971, 0.31744980874387174, 0.3131123462225178, 0.29005126748134613, 0.31097056387441846, 0.2903297262147928, 0.30211232798364185, 0.05678559611227596, 0.06926982756817357, 0.0746333946906994, 0.07273152605703859, 0.06686501775823783, 0.06311937639450138, 0.063654515672537, 0.06453153668038336, 0.06488275106708352, 0.12353950986661533, 0.12490700904998486, 0.12254280546592544, 0.1404371652519234, 0.13666931112961578, 0.12434298075466355, 0.15262168584606495, 0.11896590707681587, 0.13574728010583204, 0.19717555408996756, 0.18966002320095543, 0.21491712117673856, 0.18897260913896863, 0.19463862062248205, 0.18288235355715676, 0.1921718688307329, 0.21678543767769465, 0.20584915811525584, 0.14293024733919024, 0.12515258558631326, 0.14914358739037303, 0.13300535313342043, 0.1284630422314874, 0.13105836798067794, 0.14355077434680297, 0.14403785264457625, 0.13285449318550369, 0.17736333866275023, 0.1852722609469608, 0.1637189057999191, 0.16359391351625419, 0.17385083789432232, 0.18971546333557432, 0.15924987761346965, 0.18112028717601847, 0.17978565786492895, 0.15682302947184235, 0.15651044092416488, 0.16385746110875865, 0.15431025485995054, 0.15997372411645172, 0.16687138166743098, 0.1646519075106747, 0.15722324087065298, 0.15792835642939662, 0.14099458226329498, 0.14115300878758918, 0.14911672774457307, 0.18993899455442753, 0.15494784691283037, 0.15254452818453956, 0.15096846920363738, 0.16752429188086426, 0.16139937592894382, 0.2190826727094355, 0.2051872389833872, 0.1493019103301516, 0.16144342969046688, 0.1823457235164836, 0.10772842416195438, 0.18855639413650338, 0.1914739233948941, 0.19515307683748695, 0.18799117493433215, 0.18265630483538886, 0.18815296638320256, 0.182659839483721, 0.17646871793936592, 0.17534755872948915, 0.1704031302606689, 0.19072537730987837, 0.1677980556978298, 0.06119283060290759, 0.05412286720389037, 0.06305289495099664, 0.057303268682405206, 0.0731111570280526, 0.06300124789563666, 0.05636938077241993, 0.058585550569734135, 0.06301090554063082]}, "mutation_prompt": null}
{"id": "a466b427-ccc6-44f5-8fcb-ff3ee6050ef3", "solution": "import numpy as np\n\nclass EnhancedParetoOptimalDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.7  # Enhanced scale factor for better exploitation\n        self.crossover_rate = 0.9  # Enhanced crossover rate for diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Adaptive local search probability\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n                    self.local_search_rate = min(1.0, self.local_search_rate + 0.01)\n                else:\n                    self.local_search_rate = max(0.1, self.local_search_rate - 0.01)\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Reduced step size for precise local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Dynamic adjustment based on improvement\n            vector = local_vector\n        return vector", "name": "EnhancedParetoOptimalDE", "description": "Enhanced Pareto-Optimal Differential Evolution with Adaptive Local Search for Balanced Exploration and Exploitation.", "configspace": "", "generation": 15, "fitness": 0.273299373327828, "feedback": "The algorithm EnhancedParetoOptimalDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.6507191301506057, 0.6412537223901589, 0.6262917002304755, 0.6731740077819879, 0.669582076047772, 0.6559857996854628, 0.6565760834331409, 0.6483558794321069, 0.6648430313000351, 0.409557434997591, 0.41247601047919213, 0.3948586094179686, 0.34693543920858205, 0.4203537208808227, 0.3870122042805495, 0.3883833571128592, 0.4042523608715958, 0.40359519411474953, 0.09423055598234709, 0.11024425046738784, 0.10163838248287282, 0.09993372047344162, 0.0951309450589719, 0.09323136132783316, 0.10822984966495952, 0.08593310448795732, 0.10196694747826096, 0.08367703413097993, 0.09068981399077525, 0.09655580611272307, 0.08563077701923516, 0.08496267472414643, 0.09783205180544285, 0.09841839971470712, 0.08923812635964823, 0.08431232781030618, 0.9857314981648907, 0.9449860830666099, 0.8955168111658148, 0.8980429616507621, 0.9109707570942215, 0.8099803496426914, 0.9224077595344107, 0.9410756056188143, 0.9201081059717005, 0.297493088733371, 0.2920127552590449, 0.2831701963905975, 0.2955740444307857, 0.29740857895399375, 0.29585032125768196, 0.29532789968879614, 0.31674620463401526, 0.30967577090727905, 0.581351192230448, 0.5388748362573754, 0.5455159586357454, 0.6423496589570721, 0.5724410724925398, 0.41557424393753195, 0.521045383449362, 0.6066103265079203, 0.5677479454500765, 0.2516042667931886, 0.22104119767723363, 0.22175392865924048, 0.18457828111698604, 0.23288525833787677, 0.22265863420486354, 0.21550021747014314, 0.21391518448684477, 0.171876038049113, 0.1115787742636205, 0.2239015175607697, 0.15291953596609398, 0.22562858229198168, 0.18768264456496742, 0.19593937802558092, 0.15725067575869656, 0.17176198385651442, 0.16150845116608192, 0.15746612520777348, 0.156878217362869, 0.1495898266494331, 0.14519551612981918, 0.1504263944230001, 0.14509874815221213, 0.15776887966313935, 0.18694891343046938, 0.1728086950027593, 0.2739755594162945, 0.28378953742617063, 0.29875753846080366, 0.2547849525594904, 0.2825947003688958, 0.26833162272401967, 0.2993703235120797, 0.33945186897525415, 0.3033453926388697, 0.015127257496167612, 0.04025068182178548, 0.055236939786892036, 0.0612853821506838, 0.07479546643736379, 0.0486359053126153, 0.05911555233722299, 0.06541033547765651, 0.03495454223059136, 0.17932120482183767, 0.1784083077039933, 0.17105768977669555, 0.16964035360543694, 0.1876092300773874, 0.18696379729519497, 0.16462924182741667, 0.17940579892176323, 0.17094643943502574, 0.4945996580507319, 0.4976808952295818, 0.5226300221260896, 0.49457891406943333, 0.5058181330622603, 0.5164535744267253, 0.5126344412277781, 0.5038068580351596, 0.4912447835506478, 0.0804624067863089, 0.08278709998031442, 0.08610378914273753, 0.0958498321290272, 0.0903089182612804, 0.0931315103554412, 0.09410566113781693, 0.07871368611521579, 0.08904640365651373, 0.1606644871973666, 0.2182846483813986, 0.16247187275688957, 0.16716664303800588, 0.15250188371974893, 0.14059160697330264, 0.14219475726400665, 0.151929553600343, 0.14380583931659474, 0.2891372690981656, 0.30123065781066494, 0.28087603139304096, 0.2907737188664008, 0.2924926525954229, 0.3017825746866766, 0.3113430353741842, 0.3113743260105899, 0.3062804230243835, 0.21585236873035463, 0.226748522140787, 0.21961180540692837, 0.20506133182814068, 0.19547414156644194, 0.21069953512721984, 0.22773793273706144, 0.22136969701910714, 0.21875295680814055, 0.17198653293901212, 0.1964361764991298, 0.18704432388297354, 0.1846345314011023, 0.16987120367503394, 0.17472164096402576, 0.20655816511324887, 0.17937423534904173, 0.19283281557514442, 0.17487019757228284, 0.1714761127345269, 0.17444414814864562, 0.17301194977502032, 0.17331798239329277, 0.17373180664242194, 0.16917640258542366, 0.17673357157819192, 0.1789057793080554, 0.1675861042736695, 0.1651452536348561, 0.16416480952132784, 0.3726306962095679, 0.16532144301349094, 0.5752755719965877, 0.1768183864054157, 0.2520857143819536, 0.4071823735868254, 0.5292015876340744, 0.19575809954367374, 0.5079032184654435, 0.1902069349495611, 0.3214755989011686, 0.19570409180701331, 0.1990806635549931, 0.6025337443085519, 0.2059003535208923, 0.21553803910866887, 0.17518792611038458, 0.17089804811247666, 0.1796027607827977, 0.19457872919495467, 0.1917229494478777, 0.18247902141699934, 0.17918459950203758, 0.19082040290061708, 0.07151908672229146, 0.06868555886248051, 0.09004506331373618, 0.0712570406677685, 0.07191006015492807, 0.07583541225997814, 0.06928403066157585, 0.08506677863477996, 0.07676725943632878]}, "mutation_prompt": null}
{"id": "cb1e101d-455b-4ee0-8b5b-f86e47cfbeba", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = np.random.uniform(0.5, 0.9)  # Stochastic scale factor for varied exploration\n        self.crossover_rate = np.random.uniform(0.8, 0.9)  # Stochastic crossover rate for varied exploration\n        self.evaluations = 0\n        self.local_search_rate = 0.20  # Increased probability of local search for better refinement\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.15, self.dim)  # Adjusted step size for local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Retain if local improvement\n            vector = local_vector\n        return vector", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Stochastic Component Integration and Adaptive Local Search for Superior Optimization Performance.", "configspace": "", "generation": 16, "fitness": 0.21719927145239573, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.3980531722509151, 0.40966954892853036, 0.6871824619131501, 0.4257567719297254, 0.44226098120338697, 0.7012243755901807, 0.43977969621741464, 0.4490775287709353, 0.6951887062462687, 0.1666948622926151, 0.16871545455683556, 0.4590372172526783, 0.1437071179526681, 0.19350571919843873, 0.412387955055867, 0.15708617446111606, 0.17759721403699458, 0.44874743153357943, 0.08708611927479104, 0.08972938018235932, 0.11265418998947785, 0.08469558103021824, 0.09474868143546722, 0.10679888308518748, 0.09412140298181171, 0.07907972644168426, 0.10433128017458426, 0.07349028527031065, 0.07668697696002857, 0.09139018286187062, 0.07959183365664435, 0.07244088696928097, 0.10013304779774113, 0.09365565684734956, 0.06936098680775393, 0.09191270685353303, 0.9437435199479286, 0.8983526038412698, 0.9076871248521495, 0.9630593279733567, 0.9137629212527453, 0.8692159677336067, 0.9064953480218048, 0.9579101610462019, 0.9275663978579345, 0.17923026501845707, 0.18046456947527456, 0.31591458148434304, 0.1767726420765453, 0.19335394078910362, 0.32298436427351274, 0.19163163264289285, 0.19851185703746388, 0.31695216228941914, 0.2382369075134012, 0.2272275944544182, 0.4972387816863505, 0.2605355066800443, 0.24201908542930262, 0.65598258826259, 0.24407428558522626, 0.2436163264491018, 0.6014670259483661, 0.09556660966584118, 0.12355037563612403, 0.16465519389292127, 0.0943288607583036, 0.1404951573557417, 0.18916126646640108, 0.1318814193468394, 0.13265280745914154, 0.18582643968780288, 0.11804611281545097, 0.17714775537238725, 0.1398515176036168, 0.08514537075153361, 0.10922374970482485, 0.16193590725433482, 0.11178649443920041, 0.10577994104517097, 0.1917080914836652, 0.018660477633570705, 0.032545308121256, 0.07980211113697655, 0.011644115293443447, 0.02715040385353329, 0.07630403804044905, 0.011678888585786584, 0.023675595341513533, 0.0797682757775634, 0.1153394810227143, 0.10703377178063478, 0.2217489055727362, 0.12191654892869397, 0.14471186974267525, 0.24569836002052792, 0.1397958617712275, 0.17930834762158743, 0.23308723991848124, 9.999999999998899e-05, 9.999999999998899e-05, 0.023174620702107185, 9.999999999998899e-05, 9.999999999998899e-05, 0.039496917684915256, 9.999999999998899e-05, 0.006835294314708529, 0.04000798093798208, 0.06701534042413038, 0.07641868562450671, 0.15345228239148778, 0.0854463749276767, 0.09062430355469153, 0.15872836389873557, 0.07492982807853243, 0.08789251031176792, 0.14032597496960675, 0.337566696641149, 0.3783975556800985, 0.5155998917023867, 0.3592938936387958, 0.366615457697142, 0.4972800849011302, 0.3513710095726963, 0.3897615722926948, 0.5113057118739572, 0.08154829492594085, 0.08417483790682145, 0.09079486411665971, 0.07658445080693532, 0.07748420274057788, 0.1072690223393793, 0.07998355386117839, 0.07009843175296171, 0.10849189696133876, 0.22879991040670522, 0.1857727747524497, 0.15281691251845098, 0.14422890202384664, 0.12560651345094775, 0.11862030674139568, 0.12793133681196434, 0.12449378482540574, 0.14688424334935246, 0.2158783740568032, 0.22585010621960988, 0.3275933402855542, 0.20588129872076966, 0.19956572615446755, 0.3425132635232283, 0.23710470519993587, 0.2734390295563127, 0.3371330704703913, 0.16925063592328093, 0.154954871483183, 0.2515533506655151, 0.15363900814067433, 0.15282921780270753, 0.22551759373108415, 0.1635099886564194, 0.15727893008775495, 0.22465520315032816, 0.16884957485061436, 0.16039188857711995, 0.20714273291241136, 0.1674325385263783, 0.1647711392402773, 0.1806201799780467, 0.18206142102081913, 0.16655475218061566, 0.19619300739612267, 0.16332775449692039, 0.16286150260623888, 0.1831067637934528, 0.16976335849955615, 0.17067025078840492, 0.1883277222541937, 0.16863143680355475, 0.17083722401222878, 0.18712847611461436, 0.1561642180088444, 0.18462757574199562, 0.16695749724167996, 0.17113018563609872, 0.24151332550272064, 0.32934952273015006, 0.15762042913703922, 0.1929850130822479, 0.26043181883385136, 0.23934118775622515, 0.18308991287987364, 0.4730319955685185, 0.15749322846739855, 0.18445151326971, 0.33630551854780355, 0.2062657671807232, 0.19621167156825747, 0.19742736270906847, 0.18149074275169585, 0.1886856544877331, 0.18688550395846926, 0.17612754654181884, 0.1958697588732844, 0.2097874736301707, 0.19046773551937457, 0.19569840265756977, 0.18726192566692257, 0.06591025277029527, 0.06345960828027164, 0.09010771105120696, 0.06507935643370599, 0.06690905466700403, 0.07174534208150163, 0.06261284594069605, 0.06652831521037261, 0.07537327080350242]}, "mutation_prompt": null}
{"id": "9b308451-c1df-46ed-8406-b123f1ee14fb", "solution": "import numpy as np\n\nclass EnhancedHybridDEwithAdaptiveLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.6\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Intensified local search probability\n        self.adaptive_learning_rate = 0.05  # New adaptive learning rate for dynamic adjustments\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.2, self.dim) * self.adaptive_learning_rate\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            self.adaptive_learning_rate = min(self.adaptive_learning_rate * 1.05, 0.1)  # Increase if improved\n            vector = local_vector\n        else:\n            self.adaptive_learning_rate = max(self.adaptive_learning_rate * 0.95, 0.01)  # Decrease if not improved\n        return vector", "name": "EnhancedHybridDEwithAdaptiveLearning", "description": "Enhanced Hybrid Differential Evolution with Adaptive Learning Rate and Intensified Local Search for Superior Convergence.", "configspace": "", "generation": 17, "fitness": 0.276941011782589, "feedback": "The algorithm EnhancedHybridDEwithAdaptiveLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.6880923235943129, 0.6664691927840052, 0.720203077306773, 0.6828053670733898, 0.6735771063416898, 0.7082798332552048, 0.6818544851834214, 0.6896538319775789, 0.6989719558166347, 0.4545386621324413, 0.4296251768761945, 0.4645877818867783, 0.4561500084699547, 0.4661899009447432, 0.4502049402800924, 0.42097953119357334, 0.45867913601792354, 0.43762532247357777, 0.09999920738999934, 0.10440201835171248, 0.11486967862511888, 0.09541487126115222, 0.09614339747169287, 0.10999403740168634, 0.09840150827610272, 0.09370166446553574, 0.09724299539084436, 0.08518684473025673, 0.10423615300838462, 0.09289715724371306, 0.09029020438047042, 0.09569982389443832, 0.09556811483279948, 0.09742879447441755, 0.09097009795674782, 0.08579455876523501, 0.8930918375910717, 0.9085800855989117, 0.9145066284833985, 0.9108913017920424, 0.9138781189333685, 0.901975235430873, 0.9323346653477865, 0.8853432567498175, 0.9002960416827362, 0.29137990148453863, 0.314931766734572, 0.2973014094115324, 0.2995589515494538, 0.29100522492948566, 0.3039816607693633, 0.2765255557965971, 0.2987869766438175, 0.3426710771137572, 0.5360630047837718, 0.5998289999229349, 0.6408958974525252, 0.6288639213475636, 0.607479653456896, 0.5898674803967301, 0.5776541806151105, 0.5388952792537591, 0.6023457779291417, 0.15348112872443975, 0.17590677305932023, 0.18256092026400628, 0.2178991288480825, 0.19047520788538985, 0.19439541834767893, 0.18510472482197948, 0.16801719591803776, 0.15500492897482876, 0.16845592802041265, 0.1652176240006773, 0.1770357972742298, 0.19572229473304148, 0.20105214662367032, 0.1634569421074764, 0.1867886432443291, 0.16888504333361465, 0.18895402491526836, 0.1279949982799713, 0.1092211225843921, 0.08374344329171723, 0.11983918875254329, 0.10740837840831596, 0.1279684608165097, 0.12589196175492146, 0.1266024600169856, 0.09093965449432617, 0.2642632133908187, 0.24651276587519566, 0.2743260821285497, 0.24721440667927685, 0.25123061050762197, 0.26992846253742786, 0.26484838038923875, 0.2722286859816281, 0.3175768601497627, 0.03532298730744188, 0.051958606416921294, 0.04118802572955227, 0.030238611247715763, 0.03168919200256837, 0.04586453320410544, 0.054204757550607274, 0.03206910489568071, 0.026503000154676215, 0.15182843100901444, 0.14804334791508333, 0.16300487252648055, 0.17695111413636588, 0.17271415920026778, 0.1748603341058812, 0.15718029988000637, 0.1699013556963317, 0.15911668946863178, 0.4908254485244997, 0.5216132545290413, 0.5230483058792672, 0.5188756724838506, 0.5388804610177873, 0.5265895793052651, 0.5233659313805619, 0.4930128267005772, 0.5366502436669647, 0.09225349263430016, 0.08582438171136386, 0.10469276500477687, 0.08855084272705771, 0.10749932330619616, 0.0905141385765399, 0.1042826842873279, 0.09478876570149064, 0.08995130693192988, 0.13711767253736884, 0.13610513126379464, 0.12602751518773292, 0.14866589978452072, 0.1623203750383504, 0.1370270610518175, 0.1439156815967737, 0.1257654831223577, 0.15065189919804944, 0.3008661630171663, 0.2963891254681197, 0.30348380805481956, 0.2927653202076036, 0.27881234980138836, 0.2780695424521109, 0.3193253745405362, 0.3600456059229825, 0.30639696372508485, 0.21511697972946464, 0.22258207405161434, 0.22158457566253187, 0.22486504436390586, 0.2224057444786578, 0.20203992110593905, 0.22176777382574397, 0.24455371051183306, 0.21981373084488065, 0.19652237202640122, 0.18907870483795908, 0.1869245420330109, 0.17274772895008972, 0.20382460729894014, 0.18771380470671128, 0.2117388246783336, 0.1786162320908926, 0.19523629404634824, 0.17591350992476495, 0.19166015472508768, 0.18450938296872244, 0.18076417721690796, 0.19321924018269632, 0.18023874094905168, 0.17639789319558075, 0.1783942314610567, 0.18076995282086794, 0.16264293455386958, 0.16031352649551533, 0.627388737702065, 0.4471874986577977, 0.3264189188968871, 0.5921672331140135, 0.30170238794694326, 0.4641867012459695, 0.5288277368204042, 0.45300704170502226, 0.20146228073789163, 0.22714102130581293, 0.18221251238720104, 0.17960499090128434, 0.4082660752659095, 0.19926498236535417, 0.20130597048159837, 0.187886601461298, 0.1831380961071376, 0.19401249358433548, 0.19395622620147612, 0.1830102068494439, 0.2026006431024523, 0.17081613512320637, 0.19659138892400763, 0.19459482295180364, 0.1930109392340622, 0.08498865962613966, 0.06886111021443575, 0.07289278167527591, 0.07920339395736187, 0.07829906554504307, 0.06686115422380823, 0.07704073670601175, 0.07339357499932453, 0.07657453662851654]}, "mutation_prompt": null}
{"id": "dfdd240c-c2db-444e-9dbb-c9fda39d37b4", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size for exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.55  # Slightly reduced scale factor for balance\n        self.crossover_rate = 0.9  # Increased crossover rate for diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.17  # Adjusted probability for local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.15, self.dim)  # Further increased step size for more exploration\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Dynamic adjustment based on improvement\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Local Search for Enhanced Convergence.", "configspace": "", "generation": 18, "fitness": 0.28531168873188606, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "fce32ed8-fcb3-464f-848c-23c1050c6ba3", "metadata": {"aucs": [0.6742169992724276, 0.660182350036697, 0.6521046052603897, 0.680181549437562, 0.7013287780985386, 0.671274664994511, 0.674811674618568, 0.6641180133886986, 0.7037517214893119, 0.4031697112272732, 0.42070971754103537, 0.44015199183499465, 0.40813692377816424, 0.45753993836601126, 0.4021307749574685, 0.4660750232052585, 0.4346764370922579, 0.42949092427268853, 0.10858287752503915, 0.1086112921100093, 0.09462236570843141, 0.10427007468674965, 0.11476255045931194, 0.10575545633585515, 0.09939737030516194, 0.12058012439309918, 0.10760631072962201, 0.09423210519405334, 0.09500226208739226, 0.08969181288109851, 0.09086669518082457, 0.08653498921904534, 0.08890116392539382, 0.09457304495363006, 0.08769419679775148, 0.10324920374754587, 0.882898718788303, 0.8167257549560175, 0.8647290248230652, 0.8848308966762636, 0.9216049823773225, 0.9280875710255888, 0.8701763291200869, 0.9722160761816853, 0.9384869628583126, 0.2890674192598044, 0.3098917085049979, 0.2919447858320753, 0.32272368862954137, 0.31048270060965855, 0.3492697950751702, 0.3459758714351888, 0.3456618436386908, 0.3030872196660084, 0.6338206757247796, 0.6348980286502954, 0.5585035105644314, 0.6609558365609635, 0.5757768143100535, 0.6204895495661773, 0.5885622338086077, 0.5803173703480763, 0.6434088024527277, 0.22104266316629906, 0.23923507961328616, 0.1738189127107853, 0.18396890612812045, 0.21017465787806355, 0.1948970776359611, 0.19185073608328607, 0.1666394250382187, 0.20628256591347094, 0.11825370471920438, 0.1630599455533569, 0.20031969261555072, 0.1688663454502246, 0.18988259212839598, 0.1798893305238478, 0.15896915878571305, 0.20709559912647735, 0.21307985829843423, 0.22979176622421082, 0.1937791658029675, 0.15421417183645425, 0.19058790749924315, 0.20270606999265162, 0.1700001378404702, 0.1705070490655658, 0.1576926287093411, 0.19539061905872723, 0.32218060361638734, 0.30527819130290124, 0.3175757739388496, 0.3401128112868915, 0.2809644020507329, 0.3011396094587764, 0.35202195339316056, 0.3500960970105057, 0.2916255881602975, 0.07390663636089134, 0.08200707548250286, 0.07088922245138385, 0.09212123615643408, 0.07382308931567494, 0.08538976715073787, 0.08575926213048646, 0.09456082985247072, 0.06987698496905892, 0.17740540585434306, 0.19527560734053762, 0.18601196819810117, 0.17720075523414858, 0.20051986967218938, 0.1962514281582638, 0.1823641107026177, 0.19770098474846443, 0.18796766613874893, 0.521860433721814, 0.5483772948971417, 0.5489621389932277, 0.5439448082356472, 0.5304675128712966, 0.5439497574950053, 0.5270912461115671, 0.5109375404757922, 0.5301872909772858, 0.10233960025143529, 0.10573317845608632, 0.09583742722186106, 0.09841458276583037, 0.1054721283506167, 0.09559096025205505, 0.08826381488483548, 0.0905217358866397, 0.09883080150487733, 0.13221455040396013, 0.13595104191033225, 0.23276842333473247, 0.14160662586663753, 0.1398564385105303, 0.13808233356036104, 0.15841447951122645, 0.13640213698024395, 0.1446669046470963, 0.2948095177942188, 0.3039586580255417, 0.33214761704340234, 0.29696840952057013, 0.2913721185598731, 0.2978787348755262, 0.3147293010784481, 0.3254789885613154, 0.34129203372375916, 0.23259839118217407, 0.2288320434391521, 0.2242952730756056, 0.20929401636450173, 0.2323069334786958, 0.2165935784150732, 0.2521600260826079, 0.242151523324174, 0.2368876980365653, 0.19109535464494976, 0.17127266483756654, 0.182256058134464, 0.18998503309233772, 0.211207333273717, 0.18004682107917347, 0.1918119252881102, 0.18710228628098047, 0.18273435560511098, 0.19485709823276154, 0.18495230450891398, 0.19006561029730462, 0.17587390370039158, 0.17804584877057328, 0.1814470192539659, 0.17978231041616333, 0.18298791897682098, 0.1762648251875255, 0.28499329530844464, 0.30207685241578686, 0.5078468830476244, 0.181333231185013, 0.18662401796340256, 0.5922225336187952, 0.2262406484376509, 0.28888947716817126, 0.5024901010342905, 0.5176272240736236, 0.19336282005634564, 0.19548414872140296, 0.18895924024903488, 0.5223766593596083, 0.2290218714973622, 0.19808911205709612, 0.20954227236108902, 0.20607803971923155, 0.18326548083738825, 0.18539229653031142, 0.18246129942202782, 0.18240186364967748, 0.1831052312585253, 0.1825873330675487, 0.1833382182661829, 0.16915445757439407, 0.17756642826124913, 0.08240873625754153, 0.07263128238406258, 0.07584740144848179, 0.07106268981258268, 0.07421642606180645, 0.0755005128864139, 0.08210599587363576, 0.06946283670555076, 0.08366656118620663]}, "mutation_prompt": null}
{"id": "499f579f-75d4-4b24-aabd-81b7420e71e6", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly reduced population size for efficiency\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor = 0.6  # Adjusted scale factor for more dynamic adaptation\n        self.crossover_rate = 0.85  # Balanced crossover rate for exploration\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability for local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutant_vector = self.population[a] + self.scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.2, self.dim)  # Adjusted step size for fine-tuning\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Dynamic adjustment based on improvement\n            vector = local_vector\n        return vector", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Self-Adjusting Parameters for Robust Global Optimization. ", "configspace": "", "generation": 19, "fitness": 0.2754161617181459, "feedback": "The algorithm AdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "dfdd240c-c2db-444e-9dbb-c9fda39d37b4", "metadata": {"aucs": [0.6816249213604479, 0.6808997832090963, 0.6879784723774829, 0.7100461336134964, 0.6932479590722029, 0.7008995367238766, 0.68610077392303, 0.7071374633359631, 0.6672409286722691, 0.41951947002574763, 0.4460456421616339, 0.5054874944600761, 0.4389057297538034, 0.4291885786180415, 0.4419774511681459, 0.4714407499920027, 0.47709002377234455, 0.42574324076475734, 0.10381191169135673, 0.0993650849490445, 0.0905072171142981, 0.10859566458357128, 0.10340663685259455, 0.09946955232083587, 0.121310813863729, 0.10670511015379003, 0.09613152401805403, 0.08965180601184797, 0.09452404733081676, 0.09442086533712701, 0.10281939612621105, 0.09115837978069352, 0.0942546498634429, 0.09275522674880121, 0.09609149150083918, 0.09408871315513245, 0.9166230335430822, 0.9199839054160798, 0.9043191413286695, 0.9066529872890443, 0.9298924541172972, 0.8809109817106363, 0.9193712584502953, 0.8916515395546525, 0.8641837032545217, 0.32168846352464875, 0.320448122271604, 0.2862880411727926, 0.3037926569369346, 0.30832490832266735, 0.29499375732019084, 0.3111334248947393, 0.31783641621342096, 0.3204406636150626, 0.5628230375739408, 0.5198357560741925, 0.575894840633682, 0.5721774472402263, 0.6115920040814116, 0.5443127119776574, 0.5413225841742307, 0.5795827766980977, 0.6166489089128515, 0.15562255304528294, 0.16129700416976134, 0.1949095694735291, 0.1711618763795767, 0.15715626308807218, 0.20352957067589184, 0.18242397102571428, 0.18921630975863846, 0.1907982539031583, 0.16883873596286225, 0.15786388141062502, 0.19196467593551925, 0.206013503943969, 0.15789828245887916, 0.18057243538394918, 0.16808205983595204, 0.1768535076523038, 0.19869452926490894, 0.11416725502357328, 0.10544603237583472, 0.1341377691731943, 0.09788694963949385, 0.12540349095215098, 0.11589112465252271, 0.10693813351607984, 0.14671047428765327, 0.1241108694937253, 0.2447249524962074, 0.2585191906404193, 0.27612973489518544, 0.24828475902421154, 0.24621361428823296, 0.24253858361656955, 0.25637126149936496, 0.2574891772317843, 0.27092007384328276, 0.024828426415662186, 0.03395337168500223, 0.0293201893783549, 0.041340412717720376, 0.03749016714289688, 0.06004458072183805, 0.030035806837046986, 0.05591178081335235, 0.03184150392414742, 0.16615232987681827, 0.1628414812440938, 0.1491672285210197, 0.15402904865139722, 0.1639478559714278, 0.17105157691356365, 0.14803838152725424, 0.16203683784145761, 0.1590575624097713, 0.5049693109801257, 0.492404527423428, 0.5277765730277688, 0.506822247928381, 0.5215210327562334, 0.5219364847431758, 0.49666671968131126, 0.5108723964748014, 0.5008604571587725, 0.0825955081387294, 0.08830816153820564, 0.08587285060372374, 0.08808814893775307, 0.09732083545013315, 0.10299454492824556, 0.09270182071277377, 0.09373159362485417, 0.09747825206427718, 0.14327364339840132, 0.14664571225995915, 0.1304333920520807, 0.14012197155990203, 0.15497719548854205, 0.12249368300728747, 0.1552301360244206, 0.15022427332528754, 0.13402179965994332, 0.2813039711986912, 0.288255947351603, 0.30294395834099286, 0.30950085513475256, 0.2968423375496123, 0.3306601487651264, 0.3355289795296299, 0.3227298491941277, 0.3115712393496528, 0.20968821929723624, 0.23051218158568576, 0.227508035260242, 0.2157376088970131, 0.19604979014013868, 0.21533265069016638, 0.23357864600850975, 0.24755852493864727, 0.22995889622639665, 0.1849353361151812, 0.18506004859268865, 0.19764114042929248, 0.19285423685494862, 0.18793272983106757, 0.19017065669560163, 0.2051218063901975, 0.20077457505878338, 0.18386530107407706, 0.18500508389305426, 0.18242273871200776, 0.19100567794771972, 0.19787394222166377, 0.17526511807757128, 0.1855144809206165, 0.17948409396797582, 0.17494692036545878, 0.20391491190757483, 0.1624671767075584, 0.3796507670722723, 0.5251190866738173, 0.49760958901038677, 0.1732344683953042, 0.17561427190777124, 0.1743873321024314, 0.1627873769218532, 0.512821390771446, 0.40973461271932, 0.6146420773117903, 0.5719833929608757, 0.1896860825584773, 0.19711019500115456, 0.4721879561555202, 0.19513265558586557, 0.19773008567639405, 0.1938216327433201, 0.17975620295238137, 0.18409189401482529, 0.1853286818671369, 0.1752752829173423, 0.17149455414593906, 0.17178690896102833, 0.2011739474288463, 0.19618595597454824, 0.20170592134878462, 0.06833361218681289, 0.07316462870690521, 0.0755317736637049, 0.06381843686929811, 0.07778834895840936, 0.08097721065392671, 0.09228024346265196, 0.07775140656141577, 0.070094915387652]}, "mutation_prompt": null}
{"id": "02fb1b6c-9455-44e0-8638-2ba6d72a27b3", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size for exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4  # New lower bound for adaptive scale factor\n        self.scale_factor_high = 0.6  # New upper bound for adaptive scale factor\n        self.crossover_rate = 0.9  # Increased crossover rate for diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.17  # Adjusted probability for local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.15, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):  # Dynamic adjustment based on improvement\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Scale and Dynamic Local Search for Robust Convergence.", "configspace": "", "generation": 20, "fitness": 0.3066956651529765, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "dfdd240c-c2db-444e-9dbb-c9fda39d37b4", "metadata": {"aucs": [0.7071801754907534, 0.6911556821695122, 0.6992746723962509, 0.7150878951458195, 0.722605200262098, 0.72132531661939, 0.7262568460120645, 0.7177297264283773, 0.7084873190409314, 0.47098322386117075, 0.46255998724866654, 0.4941240947522362, 0.49677634023448913, 0.487478563226597, 0.4827243971917754, 0.47136087949714345, 0.46112795371860515, 0.49694893741898694, 0.10171870071151257, 0.10524407081817677, 0.10520244240165721, 0.10755369231381662, 0.11767743103835493, 0.11398417554088958, 0.10780268926130321, 0.09341610323366445, 0.09621473912827683, 0.09599500807501227, 0.0864693811001156, 0.09352030636009423, 0.0992615051615452, 0.10975175761845202, 0.08919359695652207, 0.10941388125954365, 0.09767029348961875, 0.0891790044892723, 0.8203451767584203, 0.9310014200766245, 0.8391979682477185, 0.8882594979693628, 0.907693568438361, 0.848214021566681, 0.8946660670072019, 0.9087696614196155, 0.8549646334548269, 0.3395670169681627, 0.29837542474660894, 0.36148041625448946, 0.3313840779641093, 0.33874060073696033, 0.34303286317060444, 0.367875600238299, 0.33600605745295153, 0.3469859067898937, 0.645315967448323, 0.66222451582408, 0.6667156103873964, 0.710635036198874, 0.7259198175006072, 0.6508752575690305, 0.659723615674664, 0.6719949236129609, 0.7488324405861353, 0.18116565729880207, 0.1793932827066288, 0.2029410952237517, 0.17809065152258408, 0.1869984572460548, 0.22413050868892703, 0.23906695024402191, 0.16899971554328308, 0.2039872838580271, 0.20472281496163847, 0.16282973353201013, 0.20958589614964052, 0.18197909651051214, 0.18994214146575883, 0.21468645535404873, 0.16188676121454648, 0.20219656045220813, 0.16901235552272176, 0.22192986049855956, 0.20297044158375144, 0.22285685130884514, 0.2514155886345699, 0.2035173317437431, 0.22659376951944177, 0.2360222866895315, 0.20205449002424158, 0.2608021499077746, 0.3605457430236595, 0.3871872819606157, 0.33417846405660934, 0.33376189599045325, 0.33713183210594533, 0.335719343572489, 0.3556047259424955, 0.3909721251428093, 0.3605130374954141, 0.08467424300584103, 0.07745181940895929, 0.11489990154200436, 0.13730832042487195, 0.1160191019502701, 0.08903025702955347, 0.06693839140825153, 0.05283518933086795, 0.0922039495724466, 0.20686354330890366, 0.2097431825587881, 0.23949783158714977, 0.22349044587260958, 0.23130147612141105, 0.21416613636274417, 0.18170981621165405, 0.20910932770072188, 0.21310205618047162, 0.5626636546412129, 0.5691342797947947, 0.638928664542097, 0.5747117022486781, 0.5621863774887572, 0.5396511536428923, 0.5711187289639121, 0.5317867626930125, 0.5615691699268384, 0.09957629440871008, 0.10814299431943386, 0.0984092204946806, 0.10786519304250142, 0.08640481810399547, 0.09377666557486519, 0.08085257924261258, 0.08675842184041471, 0.1150113811128256, 0.1386275338585139, 0.13801034640602716, 0.13515983918158037, 0.13766266535167793, 0.14730964532268442, 0.15056512934574162, 0.15101566453109605, 0.13787369124630455, 0.1688525876832464, 0.33721835471396777, 0.35671679698431047, 0.3426894501590122, 0.33014101199635926, 0.33308802788539227, 0.33208707473899923, 0.34255882766546164, 0.3617634378650457, 0.332124108444122, 0.253308226161564, 0.23754421562828087, 0.2470244906106982, 0.2445505595243881, 0.2561781971040553, 0.25401141957339535, 0.28111679496204856, 0.27387025387900743, 0.26897426366294697, 0.2000028062770729, 0.20115112436794536, 0.18707700672314842, 0.18865527456750064, 0.19070549328571051, 0.1817876822374277, 0.17981529369647942, 0.19594412500684144, 0.1927188566097805, 0.18716791877650152, 0.17503954403420963, 0.17919019978901396, 0.2026196741354921, 0.18953612433636446, 0.1826561175915029, 0.18156862498397874, 0.17744764620446263, 0.1972793716327027, 0.5946732256944889, 0.6756192375642278, 0.1713651112768101, 0.6766646525501345, 0.18000674312730136, 0.544237065244475, 0.47896011494643564, 0.21002857003626063, 0.4713415632814163, 0.5458173452930652, 0.5189218586467408, 0.19669198487095696, 0.4849077542264296, 0.18690434216870067, 0.19167944408496984, 0.20780136741929878, 0.20170645120677178, 0.20418456667740748, 0.1800567904630852, 0.1818538077038152, 0.1913526691380284, 0.17650933384958611, 0.18984679464651633, 0.19958093902047425, 0.17513026894666395, 0.17130519092015617, 0.17842280739261418, 0.07495295682124581, 0.07583292843416489, 0.07772505787553441, 0.07863870211175505, 0.09035902467830526, 0.07885841938053195, 0.07415280466821383, 0.07387431624118235, 0.07035512160156543]}, "mutation_prompt": null}
{"id": "1ba43019-3dfb-466b-ba5d-8d50c3ba77f8", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Adjusted lower bound for adaptive scale factor\n        self.scale_factor_high = 0.7  # Adjusted upper bound for adaptive scale factor\n        self.crossover_rate = 0.85  # Slightly decreased crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.18  # Increased probability for local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Learning Rate and Stochastic Local Search for Enhanced Convergence.", "configspace": "", "generation": 21, "fitness": 0.3083020296289667, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "02fb1b6c-9455-44e0-8638-2ba6d72a27b3", "metadata": {"aucs": [0.7408008444228051, 0.7333920804787848, 0.7133225158949359, 0.7270482244526779, 0.7454162709219001, 0.7542482463072755, 0.7281371173296521, 0.7262059671263916, 0.7357738153126967, 0.5499532866187627, 0.5558756101423182, 0.571260026084028, 0.5490869410397992, 0.523379871583797, 0.5150326638334901, 0.5240695967425293, 0.5449844313608073, 0.551928432962905, 0.11603504864721348, 0.11731480959527252, 0.11759665758732774, 0.11452222010436075, 0.11616710077109582, 0.12811480563829047, 0.10772041546425137, 0.1194879358988803, 0.11629592984345094, 0.1096501282892246, 0.09258117429774426, 0.1049687382887079, 0.1040295474480315, 0.10889354429656428, 0.09380819537974272, 0.10522761260821079, 0.09152769582397813, 0.09829020120346887, 0.9568979920883329, 0.893750196467987, 0.9246952331687195, 0.8291250685827743, 0.9080492352468723, 0.907168237342078, 0.8969186939731861, 0.8462470959643883, 0.8687208029458858, 0.3192057661602755, 0.3389466580035113, 0.30542004068629336, 0.36156756015711156, 0.31428276444662173, 0.3328271199678672, 0.3597828710023546, 0.3653106381786222, 0.3544671110841714, 0.6996727134262358, 0.6600245821300601, 0.6737147260706424, 0.6751617278381595, 0.6804422536308974, 0.6589581809645344, 0.6737854896873569, 0.6876015204066968, 0.6513134494621269, 0.18076868768918175, 0.19777863137193763, 0.21223709068685226, 0.21780273595898592, 0.20188814540003985, 0.16525291200813785, 0.20855573623031542, 0.2248007791110631, 0.2601179356929316, 0.18595743194073044, 0.2231437846511476, 0.18270377467004562, 0.1907167680515719, 0.2023813487947227, 0.1825145767700327, 0.21797365237378274, 0.19295059551807603, 0.20327431293544274, 0.15027734207933374, 0.18597738138839925, 0.15727507166509547, 0.16530578103676086, 0.1931620764878088, 0.15452746254902994, 0.1958611329996628, 0.19506537208630093, 0.20351756724729908, 0.33370504005684376, 0.33529741570052995, 0.3064309036902011, 0.3333682821422036, 0.2764351387137045, 0.3235539657661497, 0.32105466650182457, 0.36525625143294094, 0.3357970616476599, 0.0949644267825539, 0.07516517633522768, 0.051444984763451274, 0.12450450547537584, 0.11101870758340249, 0.0908339206375216, 0.08974677223695504, 0.07040644768014148, 0.07973283664266251, 0.1938473351463984, 0.19926722012388587, 0.20954993090020324, 0.18946912029621377, 0.21592903652051942, 0.2095722889056506, 0.18298793157283355, 0.21526856673696348, 0.20956831984798951, 0.5591471959861086, 0.6142725315844715, 0.5902737022699178, 0.5554191281218752, 0.572256243761994, 0.5907346333780457, 0.5678977411927508, 0.5500486855755227, 0.5961932899584101, 0.09286185070598463, 0.09146053083568073, 0.09847667558477735, 0.09499185747746397, 0.08985189031276586, 0.08822937781706897, 0.09540321700471344, 0.09114531222459266, 0.09874417963653381, 0.1386969244865941, 0.13474829908102526, 0.20252652297890494, 0.1501681952482662, 0.1727876390912434, 0.1430778876301927, 0.1413664231372881, 0.13333390157620795, 0.13283765199426056, 0.33984000152337357, 0.36317257656276924, 0.35167037105607746, 0.3462948106077195, 0.32855527479254343, 0.3553877497497926, 0.3632048046601849, 0.4115782262949882, 0.34673872448121745, 0.2468198777581322, 0.26382766190579787, 0.2516217270066493, 0.26270747659123617, 0.2334730393022485, 0.2379980986623862, 0.2959012507588884, 0.2520790510544404, 0.261593985226071, 0.22754064408766006, 0.20545312439276564, 0.18825843451822444, 0.1912344102728717, 0.21052044345267573, 0.18097496834680127, 0.18714505946366589, 0.2085601216871481, 0.20523245436784732, 0.17859715930246223, 0.19545518832776387, 0.21703086057063103, 0.19412348148369485, 0.1936303216429296, 0.1946961434886615, 0.1769729218508579, 0.19477542814796678, 0.1827975258291341, 0.6202770071153456, 0.1774257353507741, 0.6737901408925282, 0.6549091863204947, 0.5924065305391696, 0.1909584717369477, 0.29447685376455257, 0.40979545156930286, 0.45542046856707286, 0.19744258752419985, 0.584522403458215, 0.19744438261077712, 0.2044199127628351, 0.20506141937562916, 0.31313888579291693, 0.20101961931929102, 0.20382122187375284, 0.1964991664096386, 0.1957044334560929, 0.17877961517392937, 0.18360599250481602, 0.1844596675569985, 0.18582563640978433, 0.18660883931793382, 0.18752437191439852, 0.18235150896398344, 0.20245730166312714, 0.0784531250464704, 0.0818616677076861, 0.073735740383303, 0.08851157853197056, 0.07874520416277209, 0.07775275067021026, 0.0709718896599757, 0.08411047767102942, 0.07436449207810747]}, "mutation_prompt": null}
{"id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Adjusted lower bound for adaptive scale factor to increase exploration\n        self.scale_factor_high = 0.8  # Adjusted upper bound for adaptive scale factor for better adaptability\n        self.crossover_rate = 0.9  # Increased crossover rate for improved recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability for local search to refine solutions\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Diversity Control for Improved Global Search.", "configspace": "", "generation": 22, "fitness": 0.3084063091555159, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "1ba43019-3dfb-466b-ba5d-8d50c3ba77f8", "metadata": {"aucs": [0.6918714543838931, 0.6910977430055845, 0.7019190229217198, 0.7131466181419528, 0.708599945218332, 0.6843834705926312, 0.7178513142291807, 0.6724333687724252, 0.7058649964403547, 0.44465220834293917, 0.44166984048569347, 0.43981318108289846, 0.46063790262821336, 0.4563945015580806, 0.46833690342701406, 0.4454624941770239, 0.4688834694491132, 0.49100025304138195, 0.14198897644351294, 0.10415872257514314, 0.10623613874014082, 0.1214797471209782, 0.12867867527854437, 0.09665753454437986, 0.11739608230507748, 0.10199734905164282, 0.10358673613935643, 0.094231072501193, 0.09437093000384389, 0.09869767805564389, 0.10999438222356239, 0.0979665343386581, 0.09511626256860506, 0.09333602294702592, 0.1142526797912442, 0.09116677117802396, 0.8450273639062319, 0.9000687828673452, 0.9202945050087624, 0.9678956688073918, 0.974026374802772, 0.903834989636071, 0.9320001510852864, 0.920714123493345, 0.836837373142159, 0.3277807173554995, 0.3388929804044276, 0.2910863829330791, 0.28475453768731107, 0.2911693397057198, 0.35945623047851805, 0.3242509836690678, 0.3361548987660219, 0.36882775458562866, 0.6627259857344732, 0.6238440074019638, 0.6675140423303428, 0.7033395209704383, 0.6968724537492412, 0.6815489082809143, 0.6875189486397073, 0.6977000293845128, 0.6103753700601255, 0.18905782923525194, 0.19389481201949144, 0.17416803885076537, 0.1596627345944911, 0.1950429168320018, 0.19228335498289195, 0.20347874582328462, 0.17014094297286408, 0.17204315888565447, 0.17459293162214584, 0.16909264808399416, 0.276641642413606, 0.21181950988226195, 0.21616951484870017, 0.17596860088193111, 0.20172609290931032, 0.2650929408554884, 0.1400031180709137, 0.22557441893991914, 0.19826407038054983, 0.2535543305235103, 0.21468013451706303, 0.2401923186356103, 0.23446238128219576, 0.19571418238091987, 0.22853783260995897, 0.19765411270048705, 0.3492247992448493, 0.3661354935048017, 0.35649453199368586, 0.37038808140728774, 0.3216375852674641, 0.3498249008692268, 0.3244856401806804, 0.3894099466802361, 0.37823820259432483, 0.07731985720543977, 0.0852097220194179, 0.11008063684510327, 0.12252464472461722, 0.1306684492139697, 0.09385976779649208, 0.1150726540118705, 0.11425198370002765, 0.07802959571654478, 0.19306975700351892, 0.21109202111891323, 0.21095617587182836, 0.22204332121311254, 0.20545279321821797, 0.2368122984810188, 0.22554818128245846, 0.2033427246596179, 0.21167663575633366, 0.5492279674434093, 0.5789667044674054, 0.5913537899642323, 0.5545341155513159, 0.5669161320740956, 0.5651342983140633, 0.5556411038002859, 0.5646272647833525, 0.5639214912921623, 0.10119697042493847, 0.09516290590147014, 0.09400501093319835, 0.09668671028236442, 0.09095292866772142, 0.09628815587798578, 0.0856392901660119, 0.0939513063014702, 0.09614050443507671, 0.1550450438890837, 0.17295184134702213, 0.1330905405212447, 0.14980213543380383, 0.17905988339477952, 0.1358624039030334, 0.16392664736725493, 0.15115289783414831, 0.16122112565878144, 0.3340301095267507, 0.33634249574132935, 0.3497743108633796, 0.33375256792377317, 0.32863109680634284, 0.3289652493476697, 0.3650778549441407, 0.3675135088040581, 0.35382160379661265, 0.2465659159025566, 0.27347387439623994, 0.2553337641268145, 0.26326469779281403, 0.24587561354738208, 0.27106619851673275, 0.2874846145170341, 0.24998632942620214, 0.2567994429400131, 0.18842470163113334, 0.1855807107010008, 0.22362917335470334, 0.18812628331365544, 0.1910291139027852, 0.18898681083318902, 0.18172323501890864, 0.22049098336541628, 0.19143735291567898, 0.1730936062572469, 0.19424710182370386, 0.18832293256842447, 0.17610210366200896, 0.19150149347104573, 0.18223685978550697, 0.18794814465069343, 0.19114329553063092, 0.1858711350539194, 0.5252427617357969, 0.685102395699583, 0.5545045670714239, 0.18085650822706678, 0.18175054484590347, 0.5199309023343669, 0.16879589378208015, 0.4728382522698569, 0.58705569601029, 0.4282432488467497, 0.3975274514454984, 0.19932082520652605, 0.3926657931994182, 0.48761582886947863, 0.3851905752068613, 0.2004085935189417, 0.4712853852846106, 0.19789613592154187, 0.1976020606683352, 0.1871152637196739, 0.1774417303725957, 0.18142438995370935, 0.19230509981745725, 0.19565167642395764, 0.18283563560365257, 0.17716928029129708, 0.19209119295491095, 0.08003533707255306, 0.0732148501306068, 0.0716525413707042, 0.07190948906800076, 0.0797885303628747, 0.08059741662535669, 0.07092818999563655, 0.08447246685168797, 0.07097568413553768]}, "mutation_prompt": null}
{"id": "8116296e-5c51-4935-b6e1-e1be466fdace", "solution": "import numpy as np\n\nclass QuantumHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 15 * dim  # Slightly increased population size for greater exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1  # Lower scale factor for finer exploration\n        self.scale_factor_high = 0.9  # Increased upper scale factor for broader adaptability\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for balance\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search to improve exploitation\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Increased acceptance probability\n            vector = local_vector\n        return vector", "name": "QuantumHybridDE", "description": "Hybrid Quantum-Inspired Differential Evolution with Stochastic Hill Climbing for Enhanced Global and Local Search.", "configspace": "", "generation": 23, "fitness": 0.26620862007635654, "feedback": "The algorithm QuantumHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6653792806821984, 0.6507000979036421, 0.6158222129733384, 0.6599232747906935, 0.642104632632063, 0.6442103992550563, 0.6525428759278844, 0.6724357018168624, 0.6440310250598436, 0.38716343630953753, 0.3591032963085432, 0.338338150074902, 0.31077188448970705, 0.3968677668002676, 0.3464075403982221, 0.42212766479513086, 0.3788037377230482, 0.37101782408295436, 0.11345080436874377, 0.11049861096996261, 0.11600654528802201, 0.10138269384662313, 0.11685380806641266, 0.10986494603899133, 0.11975611891464433, 0.10803058843627478, 0.11106623191871023, 0.0949566734771734, 0.09719292458982964, 0.10408404371815072, 0.09024763283953507, 0.08881449286297283, 0.0934599802727536, 0.11339040236613751, 0.10488732303572801, 0.10714362429330615, 0.8550232269511862, 0.8556080190957773, 0.8468626640697735, 0.8933987770412196, 0.9027794673911487, 0.8614857710690061, 0.9441949803462316, 0.8950259181494553, 0.8860321200611613, 0.2989949738457599, 0.25094328594242865, 0.3153441959154374, 0.25809355925409994, 0.24355755051299066, 0.2908698385474474, 0.2838005758150993, 0.25814224090426086, 0.34036195422192117, 0.5797011761994342, 0.5637748628037805, 0.4639431961734577, 0.5599736873163358, 0.6265268587796331, 0.6084442954441865, 0.5773145706660385, 0.5613964541344048, 0.5919200501617892, 0.1609298904697658, 0.16579663755490437, 0.15138081094982714, 0.16319686816384527, 0.17563147620400454, 0.1462878184705061, 0.19042778475153943, 0.1509386973146506, 0.16810836369911053, 0.1484882104419687, 0.21883883062927312, 0.10214381072909595, 0.19090488222070157, 0.17223381518521497, 0.13509663085122026, 0.18295372544726718, 0.1457534438689121, 0.1591473805532414, 0.12638065530613563, 0.06072739875621114, 0.10188824100220029, 0.1565790619328602, 0.0948921481856172, 0.09881005110099672, 0.08170775130486219, 0.09436755260208685, 0.09694417255612175, 0.27808796450274353, 0.2238664539807632, 0.2382879072432258, 0.25460827837486033, 0.23244142512764243, 0.26867680281735484, 0.26968336005571614, 0.2744034730798649, 0.2611582435436458, 0.02318363659782119, 0.025777050484632524, 0.025444316391592836, 0.029202800295987097, 0.05239306147336742, 0.03451365573923881, 0.05853502227694285, 0.054893120897451464, 0.048910070149777995, 0.14636982957951072, 0.14461377026229671, 0.15719196018640014, 0.16919871723414692, 0.1755770863702275, 0.15143038163013534, 0.1546062836919393, 0.15918431434905211, 0.13918813401332752, 0.49674270623082684, 0.4626771198764037, 0.5120077152256216, 0.4884495584329033, 0.5189613777526085, 0.4824599380724086, 0.48665919588274464, 0.4751981765657265, 0.4823031245085041, 0.09332084599505541, 0.08921359873218648, 0.08802045567276529, 0.11583429748561924, 0.08997371903046536, 0.08806493741779375, 0.09413774984489331, 0.09573894097057523, 0.0921694046180912, 0.14795841904475615, 0.15162993190419927, 0.13081542647716815, 0.21361165755749922, 0.12782014378971762, 0.12826746104218778, 0.1435724878811656, 0.15177823401645385, 0.1558648389847691, 0.3020583811882541, 0.3092558760871993, 0.30286115859083107, 0.32791912741381235, 0.3016092565158712, 0.31403308203971825, 0.32861606160797596, 0.3167141167398997, 0.3146035580843909, 0.21692781352840995, 0.23756070994816247, 0.23541285664979916, 0.23494646912345907, 0.251378703652663, 0.2342369172097909, 0.25562558328710994, 0.24001516346929963, 0.23280455404562095, 0.18905228355206238, 0.19775458187481132, 0.21580892194568857, 0.21795905843703234, 0.1898279751318812, 0.1771530469367545, 0.18656237180817792, 0.18278947312714078, 0.1850132335660879, 0.18705156130923295, 0.19496585583017245, 0.19678652101899674, 0.18775099697280528, 0.18751607658157132, 0.20581836895252792, 0.1824042253267567, 0.18827063637269414, 0.18924774028668356, 0.3102800022164135, 0.19740217725263987, 0.17464091471730392, 0.612792704327155, 0.2840960758548361, 0.5435370404279671, 0.15855204894373287, 0.3377497574302577, 0.42214573433831937, 0.42984686568034824, 0.27481642250118976, 0.2720774149080497, 0.16316212239709837, 0.2478319136328655, 0.28866859112831567, 0.20203581088866363, 0.43439969869736983, 0.18451427195846404, 0.1763354750999191, 0.18795025476633975, 0.18526883804081418, 0.1872479688697306, 0.19051252205114477, 0.17838085983809937, 0.19345489911126457, 0.1840908104508504, 0.19325208053247, 0.07910869636570372, 0.08211242553336962, 0.08069808817495139, 0.06993865049236792, 0.08235189961013911, 0.08521238107464724, 0.06954406631366872, 0.0741668421162871, 0.07698608078065827]}, "mutation_prompt": null}
{"id": "aca0474a-0479-4deb-9eb2-69940acaa890", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Maintain population size for sufficient diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Slightly increased for improved exploration\n        self.scale_factor_high = 0.85  # Slightly increased for better adaptability and exploration\n        self.crossover_rate = 0.9  # High crossover rate for robust recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increase the probability for local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.intelligent_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def intelligent_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.2, self.dim)  # Wider step size distribution for increased exploration\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Higher acceptance probability\n            vector = local_vector\n        return vector", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Mutation and Intelligent Local Search for Enhanced Global Optimization.", "configspace": "", "generation": 24, "fitness": 0.26761675079054337, "feedback": "The algorithm AdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.20.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6039667411091474, 0.6088036751013285, 0.6270492751196954, 0.6452180146230285, 0.6274567642156237, 0.6560765959502343, 0.6360501756812662, 0.5977781738850725, 0.6492547977178196, 0.3616193346672514, 0.32679491343097433, 0.33070215570333794, 0.3498541359998252, 0.3475288621163558, 0.35845369432837926, 0.3610283725635499, 0.3383993870480053, 0.3619567180009424, 0.10867200782314157, 0.10425935585286716, 0.1090937865934033, 0.0977784065453805, 0.09638654159422078, 0.09814192624429707, 0.09459584914973962, 0.09459556819811243, 0.1036398733324424, 0.10781179277815667, 0.08292199928962474, 0.09451441704119645, 0.0866545799614914, 0.0891817778085724, 0.0924479800432455, 0.10293251150292104, 0.09298328882426032, 0.09792354684334914, 0.8756616500403028, 0.9044331507690989, 0.9454496546272456, 0.9347959894336314, 0.897472709486659, 0.8176657500074669, 0.8574471054617763, 0.8724518621745223, 0.9059615184208161, 0.2705969079500613, 0.27831772742380023, 0.27876360429908065, 0.2853609999703881, 0.2587755737159374, 0.25155088558791916, 0.2819363129566709, 0.2745117522152848, 0.29174293151372266, 0.579565362815126, 0.5803593993205575, 0.5854256271111835, 0.5833178302115319, 0.5438752618769964, 0.6176098999733121, 0.5346732030303999, 0.6346772413992752, 0.6009798367806773, 0.1452681664173413, 0.13501665432752363, 0.19139600084111386, 0.24681829861637372, 0.15909321009433386, 0.17677777218306978, 0.17175413709647125, 0.16917887119880615, 0.1817212314563651, 0.11112986375818223, 0.15393849048467512, 0.17288237252772432, 0.2045425816510057, 0.16365221639684968, 0.15783949645579176, 0.17046990586161792, 0.16476208907335999, 0.16344890598298167, 0.18249067736529856, 0.14156355125251796, 0.12676136837632712, 0.13940907128357505, 0.14451239623708334, 0.13344914332009794, 0.18800630503025517, 0.12693301134323498, 0.1480377700344918, 0.2891074095254884, 0.25943102725191924, 0.28804965189114395, 0.26938324379428225, 0.27721249286662064, 0.2912441310326501, 0.2955250158225511, 0.29870558129914226, 0.2950590173493035, 0.025167845380683174, 0.047306059023588753, 0.05903888153315329, 0.06555201360860807, 0.058328424052051964, 0.07453507252990499, 0.039043790595246874, 0.05668893742923209, 0.08906233083256065, 0.16533133761816077, 0.18008545760939088, 0.15366891105421432, 0.17539909255035913, 0.17259123083903594, 0.17932922324168465, 0.16741521223646738, 0.1578264144693614, 0.15637988896209754, 0.48782628256272176, 0.5056711391725996, 0.5257097629360429, 0.48472572847685647, 0.4712572214319908, 0.49918329608057654, 0.5301357323261238, 0.4678047535652514, 0.48866169399025794, 0.098273729433202, 0.08501278969393111, 0.09314568715860827, 0.08408022653726444, 0.09436773169000312, 0.1015475986415042, 0.08252168295477136, 0.08668083043790342, 0.08842106921423276, 0.12404185893157404, 0.143137212042582, 0.13315253360079515, 0.14280469224773984, 0.1545546848856446, 0.1589589962526965, 0.12779468681254125, 0.15406460607348949, 0.14140286229617738, 0.3098396656267398, 0.2846336031308788, 0.28842901135679544, 0.29973923048902995, 0.277643474358262, 0.29419604137621713, 0.3123446807812965, 0.31964215340379454, 0.3075812038536596, 0.21978476860505958, 0.215972538049771, 0.24417997175793593, 0.20925862856884692, 0.21937573169338875, 0.21921685929174461, 0.2425984207268661, 0.2307779388972424, 0.21534419093247426, 0.1831630808403093, 0.18924560175876393, 0.19131831642156505, 0.19996074938079178, 0.1887867294527108, 0.19866568776940574, 0.18450201821984502, 0.19848936158533892, 0.1893365691552079, 0.1748161933571275, 0.18131735001042315, 0.17806151590363373, 0.17507158470372364, 0.17776063804696018, 0.17407117657054894, 0.17820115333196174, 0.16992915637695083, 0.19804203492531824, 0.44841130440351484, 0.19048558605592458, 0.291890333285978, 0.26723783347232555, 0.192321029943597, 0.5491894283062305, 0.19399561188575476, 0.16068492710985371, 0.4442571196119579, 0.28606007466370476, 0.3370800857883014, 0.3247623177092671, 0.23542845366614717, 0.22435956634364007, 0.2726714315389809, 0.5588592577640061, 0.42964895333098707, 0.2055874703456737, 0.1963510928919665, 0.19009393447017797, 0.17659493635113688, 0.1917707095383242, 0.1904471521604716, 0.182273552854883, 0.1952542934182515, 0.17785534268859216, 0.189382915796089, 0.07530533726024691, 0.0824709613799538, 0.07748883405422802, 0.06789114720664235, 0.07607885449611673, 0.06943448286129605, 0.06556744038016227, 0.08218246960963427, 0.06637980962859569]}, "mutation_prompt": null}
{"id": "adbf3f79-082d-4a4b-9e0a-241b3331b70e", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size for balanced exploration and exploitation\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Adjusted lower bound for adaptive scale factor for controlled exploration\n        self.scale_factor_high = 0.9  # Adjusted upper bound for adaptive scale factor for improved adaptability\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for more selective recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search for better refinement\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Population Dynamics for Robust Global Search.", "configspace": "", "generation": 25, "fitness": 0.27411524062323256, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6727847697342109, 0.6843562811097723, 0.6834092717398248, 0.6999322659889995, 0.6806127115627385, 0.6867979655103417, 0.6788389414663378, 0.6869874278478402, 0.6681488856983578, 0.4094446800646375, 0.4357032336233494, 0.43836470065215516, 0.42107822071383083, 0.4041328483391229, 0.405962055153933, 0.4161418297994026, 0.4094017290768248, 0.4320080003261002, 0.09129356874198546, 0.10468451452210759, 0.10355280407822431, 0.11486774691540436, 0.0990117367364497, 0.11199832380143127, 0.09877968272502946, 0.09796012461889891, 0.09899547312001233, 0.08792821831071873, 0.10052842534673823, 0.09595995528664647, 0.10554898782791411, 0.09496012987433167, 0.09406687015924475, 0.09319411698863955, 0.08504613967669261, 0.0959082280137592, 0.9143668884616625, 0.8886853491705543, 0.9596893680649058, 0.9581788713723532, 0.9476888379794639, 0.9115286078143454, 0.9458579323454895, 0.9663615471944629, 0.9175581068623784, 0.3019917165236313, 0.2814554313574228, 0.3063307014674117, 0.28835496140773986, 0.2741903025216448, 0.2965186118771076, 0.30831408578150177, 0.3024671333713037, 0.3226571212908279, 0.5606361794562943, 0.576434853307391, 0.5241098451430087, 0.5962676405706683, 0.6722301392378028, 0.5810161250895904, 0.5371166777746318, 0.5754788686171517, 0.6033305360216821, 0.2057805964886693, 0.12610362992339108, 0.18804494093015278, 0.18653459621794954, 0.2364351808409132, 0.22189159379042345, 0.21720032613152485, 0.16769188518867395, 0.19275773188346135, 0.15147310975595485, 0.19436821391169712, 0.14968936223134643, 0.16993725539400673, 0.17985389667528884, 0.18686069166501618, 0.19772570086293717, 0.16824027231320815, 0.15512007856814702, 0.12438538625022211, 0.10958137725701544, 0.10343907927913265, 0.14015471656678036, 0.10197121593912029, 0.12822723640205658, 0.12108477835965337, 0.11741988496796163, 0.10613487096695795, 0.22631833850701544, 0.24852903348227906, 0.21959904755464965, 0.2498465052947605, 0.23311296250424118, 0.232005617966624, 0.26405642914495575, 0.28656571807069253, 0.29833350509048373, 0.038676318819796274, 0.02175926185032928, 0.049567402591344956, 0.025577245939264692, 0.03680075133324012, 0.04494878027708926, 0.050398370248143864, 0.04703350985570631, 0.04710734825531182, 0.1532543241706391, 0.17578691885013742, 0.16468785163924038, 0.17300587126507327, 0.19170230993444826, 0.16895609098487407, 0.16928275566082085, 0.1585716027880879, 0.16481359587082622, 0.5259132158536477, 0.5176200736300993, 0.5263363411452848, 0.4759664196010738, 0.5057303281552439, 0.5197722821577502, 0.4965631307383135, 0.5164151973088504, 0.47935049399732155, 0.08702376631989772, 0.08963682390306427, 0.0952656897227474, 0.08743299601189902, 0.09318907537295873, 0.08408164210676528, 0.09058890012550436, 0.08903604706237966, 0.08536628976127036, 0.17509879102450865, 0.15591319955245597, 0.14156174559525447, 0.13766266535167793, 0.12435247565961871, 0.1478437820878611, 0.158132003918533, 0.12941923986468973, 0.14999260890053923, 0.3043854929275033, 0.30852238193397874, 0.307838196220249, 0.2976874118637518, 0.2950826854395472, 0.2974105240604066, 0.3217863135356901, 0.33296915850363007, 0.31959487446222534, 0.23223862951918162, 0.22958481034179645, 0.2417239339216164, 0.23308291750824206, 0.20828529512237692, 0.21494453803034652, 0.22660466046719052, 0.25068854063235835, 0.22027143374154823, 0.22306368220153483, 0.20027432169475234, 0.1915027169531922, 0.1971695539017656, 0.18664709511005895, 0.1921590997963163, 0.17437771497763532, 0.202795303976119, 0.18606379064699385, 0.18314376340952, 0.1726534884247467, 0.19393036359374005, 0.18066652478033307, 0.18486867781771954, 0.18152613745437085, 0.19117297295553548, 0.17679901068842496, 0.19841787111904496, 0.3845674875803492, 0.6550015790436333, 0.34088470731018883, 0.4032015527133227, 0.18271895163027874, 0.28162168240838303, 0.22697704294857513, 0.2784223388304019, 0.32540139439345317, 0.19210936665058542, 0.19478776186075097, 0.4614902869911085, 0.4175984572096595, 0.17270259351048245, 0.17576977790406745, 0.34775598232424354, 0.20509587695637177, 0.2020626905761832, 0.17999116092799106, 0.1844169325775883, 0.19292518633957, 0.19005607889341392, 0.17989042181594395, 0.17667153951542236, 0.18125005132262562, 0.17254513771569346, 0.17833611426077223, 0.06885388918302415, 0.07630104641127078, 0.08209456578988772, 0.07297606022162395, 0.07924788630594681, 0.0824626923504278, 0.07020949563328793, 0.07385155797769549, 0.07783113192518254]}, "mutation_prompt": null}
{"id": "80c60bbb-f4ad-4844-a560-863cf4de4c43", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Adjusted lower bound for adaptive scale factor to increase exploration\n        self.scale_factor_high = 0.8  # Adjusted upper bound for adaptive scale factor for better adaptability\n        self.crossover_rate = 0.9  # Increased crossover rate for improved recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability for local search to refine solutions\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Diversity Control for Improved Global Search.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6918714543838931, 0.6910977430055845, 0.7019190229217198, 0.7131466181419528, 0.708599945218332, 0.6843834705926312, 0.7178513142291807, 0.6724333687724252, 0.7058649964403547, 0.44465220834293917, 0.44166984048569347, 0.43981318108289846, 0.46063790262821336, 0.4563945015580806, 0.46833690342701406, 0.4454624941770239, 0.4688834694491132, 0.49100025304138195, 0.14198897644351294, 0.10415872257514314, 0.10623613874014082, 0.1214797471209782, 0.12867867527854437, 0.09665753454437986, 0.11739608230507748, 0.10199734905164282, 0.10358673613935643, 0.094231072501193, 0.09437093000384389, 0.09869767805564389, 0.10999438222356239, 0.0979665343386581, 0.09511626256860506, 0.09333602294702592, 0.1142526797912442, 0.09116677117802396, 0.8450273639062319, 0.9000687828673452, 0.9202945050087624, 0.9678956688073918, 0.974026374802772, 0.903834989636071, 0.9320001510852864, 0.920714123493345, 0.836837373142159, 0.3277807173554995, 0.3388929804044276, 0.2910863829330791, 0.28475453768731107, 0.2911693397057198, 0.35945623047851805, 0.3242509836690678, 0.3361548987660219, 0.36882775458562866, 0.6627259857344732, 0.6238440074019638, 0.6675140423303428, 0.7033395209704383, 0.6968724537492412, 0.6815489082809143, 0.6875189486397073, 0.6977000293845128, 0.6103753700601255, 0.18905782923525194, 0.19389481201949144, 0.17416803885076537, 0.1596627345944911, 0.1950429168320018, 0.19228335498289195, 0.20347874582328462, 0.17014094297286408, 0.17204315888565447, 0.17459293162214584, 0.16909264808399416, 0.276641642413606, 0.21181950988226195, 0.21616951484870017, 0.17596860088193111, 0.20172609290931032, 0.2650929408554884, 0.1400031180709137, 0.22557441893991914, 0.19826407038054983, 0.2535543305235103, 0.21468013451706303, 0.2401923186356103, 0.23446238128219576, 0.19571418238091987, 0.22853783260995897, 0.19765411270048705, 0.3492247992448493, 0.3661354935048017, 0.35649453199368586, 0.37038808140728774, 0.3216375852674641, 0.3498249008692268, 0.3244856401806804, 0.3894099466802361, 0.37823820259432483, 0.07731985720543977, 0.0852097220194179, 0.11008063684510327, 0.12252464472461722, 0.1306684492139697, 0.09385976779649208, 0.1150726540118705, 0.11425198370002765, 0.07802959571654478, 0.19306975700351892, 0.21109202111891323, 0.21095617587182836, 0.22204332121311254, 0.20545279321821797, 0.2368122984810188, 0.22554818128245846, 0.2033427246596179, 0.21167663575633366, 0.5492279674434093, 0.5789667044674054, 0.5913537899642323, 0.5545341155513159, 0.5669161320740956, 0.5651342983140633, 0.5556411038002859, 0.5646272647833525, 0.5639214912921623, 0.10119697042493847, 0.09516290590147014, 0.09400501093319835, 0.09668671028236442, 0.09095292866772142, 0.09628815587798578, 0.0856392901660119, 0.0939513063014702, 0.09614050443507671, 0.1550450438890837, 0.17295184134702213, 0.1330905405212447, 0.14980213543380383, 0.17905988339477952, 0.1358624039030334, 0.16392664736725493, 0.15115289783414831, 0.16122112565878144, 0.3340301095267507, 0.33634249574132935, 0.3497743108633796, 0.33375256792377317, 0.32863109680634284, 0.3289652493476697, 0.3650778549441407, 0.3675135088040581, 0.35382160379661265, 0.2465659159025566, 0.27347387439623994, 0.2553337641268145, 0.26326469779281403, 0.24587561354738208, 0.27106619851673275, 0.2874846145170341, 0.24998632942620214, 0.2567994429400131, 0.18842470163113334, 0.1855807107010008, 0.22362917335470334, 0.18812628331365544, 0.1910291139027852, 0.18898681083318902, 0.18172323501890864, 0.22049098336541628, 0.19143735291567898, 0.1730936062572469, 0.19424710182370386, 0.18832293256842447, 0.17610210366200896, 0.19150149347104573, 0.18223685978550697, 0.18794814465069343, 0.19114329553063092, 0.1858711350539194, 0.5252427617357969, 0.685102395699583, 0.5545045670714239, 0.18085650822706678, 0.18175054484590347, 0.5199309023343669, 0.16879589378208015, 0.4728382522698569, 0.58705569601029, 0.4282432488467497, 0.3975274514454984, 0.19932082520652605, 0.3926657931994182, 0.48761582886947863, 0.3851905752068613, 0.2004085935189417, 0.4712853852846106, 0.19789613592154187, 0.1976020606683352, 0.1871152637196739, 0.1774417303725957, 0.18142438995370935, 0.19230509981745725, 0.19565167642395764, 0.18283563560365257, 0.17716928029129708, 0.19209119295491095, 0.08003533707255306, 0.0732148501306068, 0.0716525413707042, 0.07190948906800076, 0.0797885303628747, 0.08059741662535669, 0.07092818999563655, 0.08447246685168797, 0.07097568413553768]}, "mutation_prompt": null}
{"id": "8d990bf6-01d4-4a9d-9e67-abfb34c78b3d", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 13 * dim  # Slightly reduced population size to increase convergence speed\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Modified lower bound for adaptive scale factor to balance exploration\n        self.scale_factor_high = 0.7  # Adjusted upper bound for adaptive scale factor for better exploitation\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for controlled recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search to refine solutions further\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.08, self.dim)  # Narrower step size distribution for refined local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Increased stochastic acceptance chance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Dynamic Memetic Search for Enhanced Convergence and Solution Refinement.", "configspace": "", "generation": 27, "fitness": 0.2843148985751804, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.7091641795163977, 0.6897770699580934, 0.6965206693516919, 0.7217921115902806, 0.6764136894096239, 0.6884639413505969, 0.7056803050587581, 0.7085843277243407, 0.6676068784071443, 0.4772494586652166, 0.4308655864258151, 0.4649756477800271, 0.38964822132186605, 0.47029853193052806, 0.43505021208874584, 0.4325289957591306, 0.4852544475691726, 0.4518851147862699, 0.11574428275694626, 0.10656937700476887, 0.12016491118866801, 0.10273467890237642, 0.1006919915438158, 0.10579818416068343, 0.10048054350655167, 0.10545918441798419, 0.094582885178767, 0.09873257479036912, 0.08436167460758892, 0.09292638424813537, 0.1098034343743115, 0.09750260274891409, 0.08921309047367232, 0.09682350769448256, 0.09149101544740246, 0.09301185337238349, 0.8617777355383517, 0.8853165815159605, 0.8940468027301263, 0.8948789136408907, 0.8766024030616621, 0.7993093503300228, 0.9412305954616677, 0.9251155392271767, 0.8763875024193002, 0.32193020910223913, 0.32588745284338305, 0.29286350362827984, 0.315068190204841, 0.3339246249021013, 0.29615920084020986, 0.30746417171799945, 0.32191809580028985, 0.32389216815240973, 0.6013612268265969, 0.5917226410906656, 0.6336676022593455, 0.6933898745015665, 0.6480335354808469, 0.668044628439001, 0.5656696451177139, 0.6055981472993742, 0.6508241634685357, 0.18017012111126185, 0.1622901266951483, 0.17171373322732342, 0.21560443704727117, 0.164244486371649, 0.1706863749189279, 0.18042310021657593, 0.18539499258377545, 0.19835906952841909, 0.1658872573861203, 0.23040458996277868, 0.18223040589239836, 0.20514834041731211, 0.16737958714804468, 0.18590050745667386, 0.18935076560107977, 0.15023305252082264, 0.15963403223428574, 0.12202146793213686, 0.14754679485465472, 0.1133785634448723, 0.12938474363389707, 0.13980671232511555, 0.13143981221720746, 0.13940119599928513, 0.1377592189031448, 0.13682603394578052, 0.23605803940328607, 0.2545430897899964, 0.29534333953425174, 0.2622839523774826, 0.2566570100222807, 0.22845773949676473, 0.28299009317926516, 0.31200314760762327, 0.2850530364018766, 0.05697232350538051, 0.03594981070792658, 0.08515669817189153, 0.0455958474634508, 0.06738140919213942, 0.10815092227620049, 0.058961025068710815, 0.07083833218720681, 0.06134383583649339, 0.167546783337024, 0.1878320818665168, 0.15771739981610022, 0.16708001090996805, 0.1774335386182444, 0.1835164806752022, 0.1569049458470526, 0.1609346654537983, 0.14933285124739581, 0.5149691704037743, 0.5360516581960961, 0.5204690791115221, 0.5297557388831835, 0.5169400674966576, 0.5062896655239115, 0.5207094214575367, 0.5285845289640816, 0.516591534019031, 0.08965089118214087, 0.08444162336458616, 0.09341865287335627, 0.09438806745185502, 0.07582014892967759, 0.09901699485596016, 0.09575090414050569, 0.09077408535812248, 0.10328667562041993, 0.1431118784165366, 0.17215679192085953, 0.13563721492638559, 0.16472627443040566, 0.14081998736072454, 0.12820948976167512, 0.12819745405844019, 0.12521497909842472, 0.15563352824631005, 0.32148984053500984, 0.31096958964613863, 0.3196721406624583, 0.30039545111525423, 0.3056265228409667, 0.3108503136453834, 0.3372203147513463, 0.3499645635908427, 0.34920269638141666, 0.23177241934519588, 0.2301610747700702, 0.24539388941175366, 0.23472238007341362, 0.2514362263297034, 0.2420971554078848, 0.23388118066075536, 0.2663053503071876, 0.24636602345720338, 0.20716487243514525, 0.22189425264349405, 0.19153866848179735, 0.2182021018418755, 0.19142741341694003, 0.19709985989634238, 0.2093954572742256, 0.18692952535108476, 0.19938770425176922, 0.17020139577457316, 0.18615907820005828, 0.2031972523689033, 0.18355593516402546, 0.19590040972559442, 0.182056391963614, 0.18515144999049749, 0.17442255192726297, 0.20224865248495782, 0.16716932093616976, 0.5759395416283464, 0.5441895057333296, 0.5857636842407119, 0.26085463121948327, 0.6250696723566598, 0.22884391795474124, 0.1646479337328265, 0.17338322475085055, 0.37143806677570057, 0.20005635738752137, 0.18698756823549334, 0.1908244516081551, 0.20546005236678622, 0.47203344378989, 0.1889721427982105, 0.5007395471941023, 0.48619066280464873, 0.20174793504567856, 0.18480217138409227, 0.1822283258679227, 0.18042101983022152, 0.17564641207898768, 0.18963661107295016, 0.1820156086087017, 0.17356789393921557, 0.18143140507334388, 0.07439423713464077, 0.06871432207404227, 0.07834946040730595, 0.08639370732650098, 0.07700332347131611, 0.07335056573942234, 0.07900339825287916, 0.07886712969648269, 0.0772102232637415]}, "mutation_prompt": null}
{"id": "4182b589-6667-4dee-88de-69ff0b55192d", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_min = 0.1  # Lower scale factor for finer exploration\n        self.scale_factor_max = 0.9  # Higher scale factor for more diversity\n        self.crossover_rate_min = 0.6  # More diverse crossover rate\n        self.crossover_rate_max = 1.0  # More diverse crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased local search involvement\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_min, self.scale_factor_max)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover_rate = np.random.uniform(self.crossover_rate_min, self.crossover_rate_max)\n        crossover = np.random.rand(self.dim) < crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.7 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation and Crossover for Improved Convergence.", "configspace": "", "generation": 28, "fitness": 0.28964243916522653, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.7126613908005139, 0.7060582628163481, 0.7206424382932195, 0.7145338184682031, 0.6865963947635577, 0.7099864908473775, 0.7093772107737466, 0.6883919865675664, 0.6934597087114052, 0.4826687124338074, 0.44953478361508337, 0.5048421310202967, 0.44956489711360503, 0.4446299573144825, 0.4820510437375849, 0.46981440602234237, 0.4755917837265039, 0.5231584755580041, 0.13595968616380327, 0.11578933941285763, 0.12676053925556752, 0.1318257845540689, 0.12475524687050532, 0.11311531842752953, 0.11633075185551356, 0.11895585971707023, 0.1201960887490412, 0.11078561196521963, 0.12293682461489552, 0.11734815535421916, 0.11602214504400876, 0.1320831955735472, 0.11522710161368, 0.12163048367424723, 0.1139874987955729, 0.1125793263928172, 0.8946654493352469, 0.9265306180008138, 0.9488279144139712, 0.8165632864203718, 0.8733740844310632, 0.8467152815166634, 0.8981871099574315, 0.8452394025976204, 0.9146812171756326, 0.3003378966994087, 0.302006937324211, 0.2997889592652958, 0.31717081053041085, 0.32330034484524617, 0.3269178286542155, 0.33327755551095717, 0.2912559611127863, 0.3203134064852293, 0.608964462955305, 0.5998679314250581, 0.5837309162126142, 0.6571382450229244, 0.6690538599832727, 0.650139255893063, 0.5502122591289504, 0.6093919061957522, 0.6587372512281133, 0.15674256781920393, 0.1338639687953319, 0.17629921606433618, 0.2052563433538237, 0.18822229324852935, 0.11942305152763733, 0.19957243583959772, 0.21031477822534694, 0.169675701296781, 0.19192043465467046, 0.19862767224685263, 0.15373373675810564, 0.18434962524767973, 0.24588466032608924, 0.18311939184758297, 0.1936427501364456, 0.16090398777100656, 0.16565978401266235, 0.10256355560615871, 0.10270258304010327, 0.11281607960805817, 0.12274249398846537, 0.11733822829062424, 0.1478773336910053, 0.10631593826075292, 0.13119652233006185, 0.14166447653815617, 0.26220637201468766, 0.2706341439454628, 0.24865363096732207, 0.22849030370052692, 0.19091120928149097, 0.20572689436332625, 0.264673471572625, 0.24928437779085877, 0.2914406313331459, 0.06839041099229104, 0.03869843663108563, 0.04592859062109256, 0.04123594430495081, 0.048823916733363504, 0.06119597378008601, 0.06195952480776801, 0.042951144934807006, 0.08534247644041859, 0.16598952223868058, 0.16241647218737076, 0.16577764408400886, 0.20626023878837396, 0.17597203746623769, 0.17335485704202824, 0.1712874564790804, 0.1707173383068894, 0.1667804644110793, 0.529094239143989, 0.5069496688452448, 0.5197712297928829, 0.5294806413342961, 0.528934531004158, 0.5248587628559842, 0.5482997203009503, 0.5213623294539327, 0.5127578016524541, 0.0961813870022874, 0.11569075741817036, 0.09415485698330706, 0.09764632102190351, 0.09031440785764189, 0.10446442824042823, 0.09831707676835577, 0.08945369069865339, 0.09871319470199702, 0.14790100630552538, 0.152221155094455, 0.1289153418852298, 0.14262765734991356, 0.14076868819212918, 0.14520836741038978, 0.15085638146944236, 0.170380424803677, 0.17158362770875724, 0.3386125406341671, 0.3360988447762253, 0.3247266608932219, 0.3430971059022415, 0.3102255695180067, 0.3349784336985472, 0.3508908904282182, 0.3574573616706226, 0.3373669796055958, 0.2436358646208201, 0.25505198383128824, 0.2646463098997124, 0.2258233017840514, 0.23050002569574612, 0.2583276432787872, 0.25640575888082906, 0.2979397761303004, 0.2760438610126206, 0.2124370379517745, 0.19248520754557563, 0.22242246457706083, 0.19059650828227415, 0.22408688727013082, 0.18638906437208413, 0.19259130548388959, 0.20636884269742217, 0.19663993878795716, 0.1980103678139422, 0.18050779958793084, 0.18399703259344635, 0.1947775731180591, 0.23946648001507587, 0.19163935075981575, 0.19117713789674218, 0.20531815275100662, 0.211832893809777, 0.16410590449379636, 0.18343574703238452, 0.47755193914212934, 0.61195199423279, 0.5041652466443152, 0.3626363687151305, 0.18564162379718896, 0.6634605558805704, 0.584409455091321, 0.31799064726680615, 0.4110962067424234, 0.2001319206736608, 0.3680915537959266, 0.3039256865784311, 0.25783439051448453, 0.20252954239047283, 0.1992395071841564, 0.5461724058205895, 0.1804921114121686, 0.1852143831281452, 0.1866006454469663, 0.18555179968647284, 0.1732239383547194, 0.1951231043838101, 0.1927085048716679, 0.19745598653585916, 0.18279290111986768, 0.07606483823885879, 0.07703018441255283, 0.07466882249651186, 0.06899361320842257, 0.07654998802295832, 0.07746453817813148, 0.07758005283364089, 0.0722872760654849, 0.0753367237414182]}, "mutation_prompt": null}
{"id": "2f16e88c-8fbd-4889-80b0-679e44250050", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Adjusted lower bound for adaptive scale factor to increase exploration\n        self.scale_factor_high = 0.8  # Adjusted upper bound for adaptive scale factor for better adaptability\n        self.crossover_rate = 0.9  # Increased crossover rate for improved recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability for local search to refine solutions\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Diversity Control for Improved Global Search.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6918714543838931, 0.6910977430055845, 0.7019190229217198, 0.7131466181419528, 0.708599945218332, 0.6843834705926312, 0.7178513142291807, 0.6724333687724252, 0.7058649964403547, 0.44465220834293917, 0.44166984048569347, 0.43981318108289846, 0.46063790262821336, 0.4563945015580806, 0.46833690342701406, 0.4454624941770239, 0.4688834694491132, 0.49100025304138195, 0.14198897644351294, 0.10415872257514314, 0.10623613874014082, 0.1214797471209782, 0.12867867527854437, 0.09665753454437986, 0.11739608230507748, 0.10199734905164282, 0.10358673613935643, 0.094231072501193, 0.09437093000384389, 0.09869767805564389, 0.10999438222356239, 0.0979665343386581, 0.09511626256860506, 0.09333602294702592, 0.1142526797912442, 0.09116677117802396, 0.8450273639062319, 0.9000687828673452, 0.9202945050087624, 0.9678956688073918, 0.974026374802772, 0.903834989636071, 0.9320001510852864, 0.920714123493345, 0.836837373142159, 0.3277807173554995, 0.3388929804044276, 0.2910863829330791, 0.28475453768731107, 0.2911693397057198, 0.35945623047851805, 0.3242509836690678, 0.3361548987660219, 0.36882775458562866, 0.6627259857344732, 0.6238440074019638, 0.6675140423303428, 0.7033395209704383, 0.6968724537492412, 0.6815489082809143, 0.6875189486397073, 0.6977000293845128, 0.6103753700601255, 0.18905782923525194, 0.19389481201949144, 0.17416803885076537, 0.1596627345944911, 0.1950429168320018, 0.19228335498289195, 0.20347874582328462, 0.17014094297286408, 0.17204315888565447, 0.17459293162214584, 0.16909264808399416, 0.276641642413606, 0.21181950988226195, 0.21616951484870017, 0.17596860088193111, 0.20172609290931032, 0.2650929408554884, 0.1400031180709137, 0.22557441893991914, 0.19826407038054983, 0.2535543305235103, 0.21468013451706303, 0.2401923186356103, 0.23446238128219576, 0.19571418238091987, 0.22853783260995897, 0.19765411270048705, 0.3492247992448493, 0.3661354935048017, 0.35649453199368586, 0.37038808140728774, 0.3216375852674641, 0.3498249008692268, 0.3244856401806804, 0.3894099466802361, 0.37823820259432483, 0.07731985720543977, 0.0852097220194179, 0.11008063684510327, 0.12252464472461722, 0.1306684492139697, 0.09385976779649208, 0.1150726540118705, 0.11425198370002765, 0.07802959571654478, 0.19306975700351892, 0.21109202111891323, 0.21095617587182836, 0.22204332121311254, 0.20545279321821797, 0.2368122984810188, 0.22554818128245846, 0.2033427246596179, 0.21167663575633366, 0.5492279674434093, 0.5789667044674054, 0.5913537899642323, 0.5545341155513159, 0.5669161320740956, 0.5651342983140633, 0.5556411038002859, 0.5646272647833525, 0.5639214912921623, 0.10119697042493847, 0.09516290590147014, 0.09400501093319835, 0.09668671028236442, 0.09095292866772142, 0.09628815587798578, 0.0856392901660119, 0.0939513063014702, 0.09614050443507671, 0.1550450438890837, 0.17295184134702213, 0.1330905405212447, 0.14980213543380383, 0.17905988339477952, 0.1358624039030334, 0.16392664736725493, 0.15115289783414831, 0.16122112565878144, 0.3340301095267507, 0.33634249574132935, 0.3497743108633796, 0.33375256792377317, 0.32863109680634284, 0.3289652493476697, 0.3650778549441407, 0.3675135088040581, 0.35382160379661265, 0.2465659159025566, 0.27347387439623994, 0.2553337641268145, 0.26326469779281403, 0.24587561354738208, 0.27106619851673275, 0.2874846145170341, 0.24998632942620214, 0.2567994429400131, 0.18842470163113334, 0.1855807107010008, 0.22362917335470334, 0.18812628331365544, 0.1910291139027852, 0.18898681083318902, 0.18172323501890864, 0.22049098336541628, 0.19143735291567898, 0.1730936062572469, 0.19424710182370386, 0.18832293256842447, 0.17610210366200896, 0.19150149347104573, 0.18223685978550697, 0.18794814465069343, 0.19114329553063092, 0.1858711350539194, 0.5252427617357969, 0.685102395699583, 0.5545045670714239, 0.18085650822706678, 0.18175054484590347, 0.5199309023343669, 0.16879589378208015, 0.4728382522698569, 0.58705569601029, 0.4282432488467497, 0.3975274514454984, 0.19932082520652605, 0.3926657931994182, 0.48761582886947863, 0.3851905752068613, 0.2004085935189417, 0.4712853852846106, 0.19789613592154187, 0.1976020606683352, 0.1871152637196739, 0.1774417303725957, 0.18142438995370935, 0.19230509981745725, 0.19565167642395764, 0.18283563560365257, 0.17716928029129708, 0.19209119295491095, 0.08003533707255306, 0.0732148501306068, 0.0716525413707042, 0.07190948906800076, 0.0797885303628747, 0.08059741662535669, 0.07092818999563655, 0.08447246685168797, 0.07097568413553768]}, "mutation_prompt": null}
{"id": "d9f52dcd-e2d3-44c0-b826-3e3ca594495c", "solution": "# Description: Enhanced Quantum-Inspired Differential Evolution with Adaptive Learning Rate for Efficient Global and Local Search.\n# Code:\nimport numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Slightly increased for improved initial exploration\n        self.scale_factor_high = 0.9  # Increased adaptability\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.2\n        self.learning_rate = 0.1  # New adaptive learning rate for better convergence\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.adaptive_local_search(trial_vector, func)  # Enhanced local search\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, self.learning_rate, self.dim)  # Adaptive step size based on learning rate\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Learning Rate for Efficient Global and Local Search.", "configspace": "", "generation": 30, "fitness": 0.16713522580857998, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.15.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.36505192344855597, 0.32443150206053384, 0.36564244775083177, 0.37900180103362735, 0.39358031920291003, 0.387649638752263, 0.338202036334603, 0.38523440274668597, 0.3947085765357964, 0.09149252878757164, 0.09634328688591143, 0.10767443198105497, 0.08632013216228351, 0.08339757928500746, 0.09561559487490356, 0.07476339808748711, 0.10980021272526597, 0.08538311349254868, 0.09653394732218656, 0.08658269082928782, 0.07566465130934719, 0.06822506239433701, 0.08053020428058133, 0.0817916417067529, 0.08402486109865881, 0.08144788215213361, 0.08469575403612761, 0.07308623579623341, 0.05910089288932141, 0.06284012815692153, 0.06778361995413906, 0.06119399923937907, 0.05433453824146728, 0.0655059198969491, 0.06291383806702744, 0.05820175822503493, 0.7591504837034422, 0.6652015910573207, 0.8798487635162475, 0.7644309464468082, 0.6562057693518577, 0.7389337478889769, 0.7162526099947513, 0.6815751329308108, 0.7619296314247112, 0.13616392327200955, 0.15554153756732847, 0.13613995754788355, 0.15731808119631296, 0.14053446489206167, 0.1393901064293912, 0.15310733801122023, 0.15226029976357036, 0.13929998974382873, 0.24792908139956493, 0.24513202445487692, 0.2057862218572324, 0.23942316464912528, 0.2760172562213561, 0.23017481230128378, 0.23729784051389002, 0.24111705371147407, 0.24263728595007528, 0.083883554448273, 0.09786900351464245, 0.09976706147794101, 0.09666625257485362, 0.09426201943462953, 0.06725194148415248, 0.08818745180743881, 0.10341594681058086, 0.09947315060045891, 0.06886551554027809, 0.09575780739410589, 0.07597879761416226, 0.08609661472839358, 0.1115572542886617, 0.11726062086802636, 0.09045851127999283, 0.0914515734867346, 0.09575415638622653, 0.01924648746764801, 0.03026061960000348, 0.025446357167521416, 0.0144467367625426, 0.023188797063045552, 0.019714638422121955, 0.016776302967171475, 0.013607502632008273, 0.008283084598286972, 0.12420202249885204, 0.11466063742966748, 0.12947334645494668, 0.0967772751173176, 0.13224159893768594, 0.11627757687341511, 0.14602789189794052, 0.14817050407961085, 0.14403285925169418, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003645195011904079, 9.999999999998899e-05, 0.00013584297371904697, 9.999999999998899e-05, 9.999999999998899e-05, 0.06404646940499947, 0.06356237017596833, 0.0708220377382549, 0.08188534545721249, 0.06432712433245502, 0.059870985953702105, 0.060453582325666555, 0.062143520961333576, 0.0654700701809372, 0.3261288190165613, 0.32826909233570967, 0.34159480636664075, 0.32544668947092636, 0.33369945485301167, 0.32496546551339145, 0.3305281573959099, 0.31273051818249287, 0.33985676707188195, 0.09338548596909657, 0.08319661936542855, 0.07728656010149992, 0.07309679195973406, 0.09058423072643329, 0.07921491320094842, 0.07955761818155005, 0.08591697621905914, 0.08970232291665092, 0.11812127656612448, 0.14903706949143347, 0.1255994008559277, 0.13943042674196093, 0.13599000020263718, 0.14051050023785794, 0.1394900474383003, 0.1207208407281345, 0.12323029439274014, 0.2206732181309039, 0.2151870742276677, 0.22809371752376761, 0.21253995537601833, 0.2185835563984907, 0.19594616524250408, 0.21548238109345808, 0.2285903494735657, 0.21037744401003444, 0.14253793180707253, 0.16384069524099232, 0.15735516614119005, 0.15357903890442726, 0.16976486213788544, 0.14636416959103937, 0.16342656205136574, 0.17449205315806615, 0.14907749519751246, 0.18062161222484352, 0.1977407564871816, 0.1783012615555195, 0.16446847656512997, 0.17563856261420985, 0.18046583171362784, 0.21282904070354658, 0.18370415496732884, 0.18140527931909445, 0.1612504841308281, 0.16330915795797807, 0.17015522360330615, 0.16829166849881472, 0.17464246430365093, 0.16561413046378692, 0.15082554054815667, 0.15445583416620134, 0.1518438457809962, 0.17201568628833486, 0.16513601159471014, 0.14517552808408085, 0.1494684079001507, 0.1982014597042746, 0.1650874799406432, 0.17249190225551847, 0.15218701453651062, 0.17250719132570613, 0.20489957727396613, 0.23651799365157344, 0.25566148533615773, 0.2237052679242182, 0.13823497196129342, 0.20321239288344095, 0.1884955215512646, 0.18405448637538768, 0.18801891670800364, 0.18567116816713325, 0.17996314727621265, 0.18290017413492643, 0.17375582575324933, 0.19197973378290922, 0.1844353046577374, 0.18002228091597994, 0.1793172517800864, 0.18248553756348862, 0.060596584126591524, 0.06378279962302036, 0.07407973573548221, 0.06986165652448306, 0.068516211404539, 0.06926225261804775, 0.06883997307054268, 0.06616402478840222, 0.06433382560467671]}, "mutation_prompt": null}
{"id": "6848951a-15d8-4972-b0c6-e4ccfd067e13", "solution": "import numpy as np\n\nclass BioInspiredES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.9  # Adjusted upper bound for increased adaptability\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Enhanced local search probability\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.15, self.dim)  # Adjusted step size for broader exploration\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Increased stochastic acceptance\n            vector = local_vector\n        return vector", "name": "BioInspiredES", "description": "Bio-Inspired Evolutionary Strategy with Dynamic Adaptation and Stochastic Convergence Control.", "configspace": "", "generation": 31, "fitness": 0.278321229276201, "feedback": "The algorithm BioInspiredES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6810136824222282, 0.6586681065690511, 0.6031814575797745, 0.6650552099833456, 0.6483689266059198, 0.6618516947134534, 0.6704124777905265, 0.6468096402439073, 0.6357052669384188, 0.44407206115379916, 0.39408684347024137, 0.38051456897054725, 0.39709958563357084, 0.36868700126923926, 0.4260951095070382, 0.39673644806037445, 0.3516112588159195, 0.373559004166359, 0.10014000113296828, 0.10277749975925521, 0.09581203819289152, 0.08458327457238723, 0.11152354239078488, 0.10258594945190103, 0.10901151053940716, 0.11325037681079297, 0.08937736904835092, 0.10630842722577272, 0.09539098073308838, 0.08395254352216819, 0.10135748812101297, 0.10415739449152639, 0.0902437973013317, 0.09912233365880929, 0.10122422359337213, 0.0934943123972587, 0.8384675451701276, 0.977562975990832, 0.9040889600771872, 0.8509749685119963, 0.9056407493707727, 0.8381004960345603, 0.9347253442436934, 0.7976567880980574, 0.9332395308373013, 0.2787074598669399, 0.2998471121376258, 0.2685853008646676, 0.2827421721892923, 0.2942904700725115, 0.25296517473688795, 0.3012574900829853, 0.30666772280331256, 0.30103625963890845, 0.5825667036051104, 0.5597519731576645, 0.561064861541472, 0.6647647820934204, 0.584618973047528, 0.6292131931521567, 0.6036597214721235, 0.6541598522228904, 0.5830660866234525, 0.1780360339863275, 0.19332921583838125, 0.20342531242086537, 0.21966739831450866, 0.17035663513931865, 0.16108738986463467, 0.16321948389537833, 0.21094180670294826, 0.22585645077189154, 0.1356770468801668, 0.18296036830359663, 0.16928630409468193, 0.1788631838989606, 0.13957036113380727, 0.22377418412706007, 0.19328795680772393, 0.14204436431803547, 0.18400416572058698, 0.1636895528197303, 0.15648581511973148, 0.15269169584622722, 0.19347703941220495, 0.14251308133471552, 0.19704198604798417, 0.14920826693831402, 0.16068067975935663, 0.14752360726971891, 0.3196973199907269, 0.2929052305351896, 0.29901434973069896, 0.2557956612901686, 0.24140945799550062, 0.30157471564471205, 0.3423071058397067, 0.29842903032171875, 0.3294269042079895, 0.07492687441918644, 0.051848258160314575, 0.08969420129565009, 0.09007864420063838, 0.06611075441024972, 0.05602196451324304, 0.0822698916420248, 0.05316218348990842, 0.09227329268804318, 0.18656648507806528, 0.15641187410856472, 0.1954259295286599, 0.1820014685175939, 0.1587538615026266, 0.21041832718497844, 0.17891127426118492, 0.17519420543044362, 0.17154646704560905, 0.5142496061212356, 0.53510381170225, 0.5658941664541404, 0.5023078695407619, 0.5079142788134721, 0.5120734647275902, 0.5103130020126933, 0.5262332052178456, 0.4999252770414062, 0.08971032372833143, 0.09034699846034377, 0.10434564222831144, 0.09388441227002509, 0.08911331014323465, 0.09368615866630825, 0.07759604997840708, 0.09975501680697485, 0.09112434820164472, 0.1243809711642847, 0.12316685434974695, 0.14678085250819495, 0.14568249871032435, 0.13892965126626144, 0.13911935180964485, 0.1517495740745558, 0.18195537835133113, 0.13308425886177733, 0.32317350849124216, 0.3062836008842722, 0.3120090481483999, 0.30414833430176036, 0.31812564226362694, 0.29688327662944225, 0.3119974154502606, 0.3121923799768943, 0.3172644235491643, 0.22803221343491464, 0.2594899397529363, 0.2516480035351668, 0.24081115407499143, 0.24632699334075958, 0.24061932205509795, 0.23637631401281833, 0.25719084552033444, 0.2675257941369743, 0.19390085614567565, 0.17476099485272412, 0.19691746629406615, 0.19333266229694768, 0.18760652415683998, 0.19987752713797358, 0.18550072933598816, 0.20311966079575983, 0.21552740788647407, 0.1872292716193099, 0.1840990078838275, 0.17838859963755693, 0.1799799146735429, 0.17649935773667325, 0.19398830866223715, 0.1804989796318781, 0.19185735669582604, 0.1775097004271633, 0.5951545921066805, 0.37314012538538255, 0.5757548970605767, 0.5345612399994037, 0.1731222181425741, 0.4654718473699059, 0.44600019245113864, 0.15726640127953395, 0.19663254491359272, 0.35834941269870024, 0.1675444286022728, 0.5020497700227635, 0.1840794217554922, 0.18098663783961566, 0.18070293444682206, 0.1756841160541177, 0.19915198573017445, 0.20553761687333216, 0.17930118988343724, 0.19133399631648107, 0.1804423562251839, 0.17873924614013337, 0.175914254022267, 0.19060143980333855, 0.18317447992360525, 0.18530347389504764, 0.18617534327872787, 0.0834415188665445, 0.08707414603708907, 0.07133157756838704, 0.07460133748720998, 0.08190767785594799, 0.07020496273542398, 0.09484397336243056, 0.07150061784168027, 0.07304548676326483]}, "mutation_prompt": null}
{"id": "aafaaa0d-cd19-4577-ba62-49f46e1024a7", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.2\n        self.feedback_scale = 0.001  # New feedback-driven parameter for adaptive scaling\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n                self.update_parameters(trial_fitness)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector\n\n    def update_parameters(self, trial_fitness):\n        improvement = np.min(self.fitness) - trial_fitness\n        self.scale_factor_low = max(0.1, self.scale_factor_low + self.feedback_scale * improvement)\n        self.scale_factor_high = min(1.0, self.scale_factor_high + self.feedback_scale * improvement)", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Feedback-Driven Parameter Adaptation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 32, "fitness": 0.10337909568819502, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.19.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.1502831462247448, 0.12744049463313245, 0.15684995183594963, 0.14160623166485098, 0.1486303517807801, 0.15724424757279154, 0.1295838952797278, 0.14427781077556678, 0.18784467489942047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02140361892314291, 0.015169340368183293, 0.006083000405862182, 0.020251562460310235, 0.021575749777110076, 0.03321404987374532, 0.029610237579255072, 0.025943405784824014, 0.022077359924378648, 9.999999999998899e-05, 9.999999999998899e-05, 0.009718422179799235, 0.01959972157639278, 0.005069732269801119, 0.0035779950083888457, 0.014763392921912755, 9.999999999998899e-05, 0.0051780975214653635, 0.9837357856993343, 0.9703775610363191, 0.9840867436809182, 0.9692151356107667, 0.9484231372402728, 0.9490255383360001, 0.9797776933263487, 0.9677987571514279, 0.9785078191705998, 0.06438618777686622, 0.04623863972789166, 9.999999999998899e-05, 0.018751037549519456, 0.04449304475319915, 0.013228726117895717, 0.019769433932551483, 0.028521852443523343, 0.025558757549239974, 0.10108177772306959, 0.09452173404935016, 0.06041805824912849, 0.08691274534972004, 0.0823478049381603, 0.09387782505332676, 0.10277453526633273, 0.09242250193107882, 0.10248717104342286, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012529217703833861, 9.999999999998899e-05, 9.999999999998899e-05, 0.0298421148478325, 0.008829583483405123, 0.01887532515496293, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004134009366921432, 0.009716573529646277, 0.007126305577510483, 0.015665322253441638, 0.009674883810009693, 0.004396129867934584, 0.004357942567510875, 0.003086999969042159, 0.002818399025964591, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025505691794242003, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14203297392109981, 0.15919698024406148, 0.15486081096815107, 0.14265967302541216, 0.13486916207629962, 0.16084860125348954, 0.19704338560224244, 0.1463960678322206, 0.1503586812769041, 0.0374865764374992, 0.02723674531000253, 0.028910224262321593, 0.03420998535183939, 0.011234877191888537, 0.032253112323885946, 0.011072595813474972, 0.028053476013844225, 0.0267656688986897, 0.13529156389371366, 0.13989968290345445, 0.13889062904213878, 0.1779761667408467, 0.13319902763208014, 0.12419456474640522, 0.1420881740079616, 0.14651724880815253, 0.15063523380730426, 0.13800967638671613, 0.12474007267728215, 0.17430619645035716, 0.13814796456448164, 0.14329816240646565, 0.13594186744140657, 0.17531976645615266, 0.17377774300845283, 0.13081815461319324, 0.062155405286435594, 0.06138331567437949, 0.11486432430522986, 0.11370523509404229, 0.09115755311578144, 0.10819557570388738, 0.0837317855149382, 0.11526286591505963, 0.07756132059238974, 0.12713539798133422, 0.13272246486382067, 0.15694092631270418, 0.13765311497592425, 0.11935177592441937, 0.12816330597865433, 0.12245976138762271, 0.13385875002862957, 0.1261963614278906, 0.12162017617900167, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12680551929410044, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12331715568213808, 0.11102852968063348, 0.1323636729786033, 0.16924854220809082, 0.1361899993363217, 0.1067626125559833, 0.11519835821033375, 0.12650094864350903, 0.13305767559430004, 0.15096786227078407, 0.10267165755511809, 0.10235837639384116, 0.07621907935941086, 0.09710199203946779, 0.07509553381912593, 0.15786158881576962, 0.20244246327164095, 0.15652894678780338, 0.1811862626649895, 0.1690243810927855, 0.181516141760398, 0.23562229241919164, 0.19027699822479804, 0.17633244109128177, 0.17968684336752472, 0.18330806493049334, 0.20382723790008372, 0.027445993390559864, 0.033473964911230336, 0.052956155853112086, 0.02756654299911787, 0.03469991363794578, 0.0388165651178235, 0.03739962850391876, 0.03803354422653826, 0.020266696057528177]}, "mutation_prompt": null}
{"id": "f9eaa20b-d6bd-4a56-a5e6-733eaf379b13", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Altered lower bound for adaptive scale factor to increase exploration\n        self.scale_factor_high = 0.9  # Altered upper bound for adaptive scale factor for better adaptability\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for improved solution retention\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search to refine solutions more aggressively\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c, d = np.random.choice(indices, 4, replace=False)  # Using four indices for enhanced mutation diversity\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c] + self.population[d] - self.population[idx])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Narrower step size distribution for finer local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Stochastic acceptance with higher probability\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Multi-Phase Diversity Control for Enhanced Global and Local Search Dynamics.", "configspace": "", "generation": 33, "fitness": 0.18126559848925836, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.4213634902009943, 0.3890277592750545, 0.4262567674939701, 0.41163130394173, 0.4244351297222939, 0.44153759189343156, 0.44074578137157183, 0.4155062110312585, 0.40749837253079235, 0.15825220039407728, 0.14386853210017558, 0.16878519018928562, 0.15262602438175055, 0.15496333496161674, 0.15091915365797182, 0.1573238966646171, 0.15965870210101352, 0.16798415819695878, 0.08180422729114356, 0.08262879709134308, 0.0822463922601544, 0.0779659043362193, 0.09172078953365981, 0.09253638208890547, 0.09262764483188402, 0.08993944632996576, 0.09915916920522216, 0.08073554254897886, 0.09193287408770812, 0.07873893933509679, 0.0796399779389354, 0.07788626955036759, 0.06796735534491105, 0.07859931740870651, 0.0784090248316599, 0.06966997910152062, 0.9602665980352135, 0.955834147402083, 0.9763536607988401, 0.8767185636425937, 0.9441501584317654, 0.9393141373560565, 0.9782434199417362, 0.9568714346805826, 0.9511864978965753, 0.16217668098559357, 0.138688704249181, 0.1516795319511497, 0.16319485828320635, 0.14902864147351247, 0.165049006035905, 0.16697269665889858, 0.16460360130205243, 0.16240952987320556, 0.22630283271971785, 0.2135831948884772, 0.23387278106062304, 0.21935654283336814, 0.232652329388779, 0.22603047774676366, 0.25440562466971395, 0.24453144865183374, 0.23476861071793698, 0.08766268430766866, 0.08247699701788136, 0.08498611560128899, 0.09879977195936407, 0.09873116277197314, 0.11342182890497532, 0.08822117998870393, 0.09111216168500746, 0.0983973650897253, 0.07952953722932454, 0.10396020636760572, 0.10828339971741208, 0.08451113105483854, 0.07563147214074195, 0.09079865203502158, 0.09672575712481957, 0.0933773453740907, 0.07968266718161288, 0.029624719610184536, 0.009431169129651251, 0.002164106562892454, 0.007635445758800374, 0.0306184601309456, 0.022847735268711422, 0.010143357347284332, 0.017882166859927162, 0.008592895214642127, 0.11084824767408497, 0.10823445371321472, 0.10570442561378568, 0.10735933729157876, 0.11815615065196294, 0.09168939010612354, 0.10866285599928449, 0.13867992754035263, 0.11490730929609161, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07441229809851191, 0.07481050134027845, 0.07636734355016928, 0.07178215847154734, 0.07378421639509447, 0.0770473764405919, 0.0831112153525777, 0.07371950893244483, 0.0774343769427902, 0.34151507381086765, 0.33945846744503083, 0.34943635142176765, 0.35816162032467025, 0.37070432846351065, 0.3504556908832892, 0.36473020833464576, 0.3427353929655512, 0.3340111388576186, 0.08984492123607268, 0.07178995994222936, 0.07072376716610429, 0.07293972983518437, 0.07678040961713073, 0.07720259993612799, 0.07109818933393797, 0.0715028712997986, 0.08118129318511569, 0.15666596856931247, 0.1122352879009435, 0.14398290057387153, 0.17732876668765352, 0.16634651248732046, 0.1387713404675851, 0.13610564452881513, 0.1288116115870409, 0.14095227745861705, 0.22618695551546375, 0.20564418775932602, 0.22393194547899464, 0.2029575705353025, 0.19828113250110913, 0.21034835605136137, 0.22720790050077277, 0.23931078702504283, 0.2220416393761384, 0.16163045735719117, 0.15451153760473813, 0.14320113223684094, 0.14761428535136378, 0.14547500750266862, 0.14108074417980987, 0.15808824309811842, 0.1599565769578175, 0.15951972555522986, 0.1861720562486422, 0.17195149489716188, 0.1665997710221584, 0.17820151791219774, 0.18310482258013372, 0.16544583381643374, 0.17825628055729303, 0.1778948055663323, 0.18297737743556086, 0.19295450387525648, 0.16373568427628615, 0.17305497116467394, 0.18534072150943515, 0.1704915425590503, 0.17288471893884838, 0.16947259114171231, 0.1662762562816319, 0.1612012038368037, 0.14601395379802562, 0.14830494748328726, 0.14574974049104672, 0.15497333069825414, 0.14838743416488798, 0.14603653738477873, 0.1497178783130899, 0.1480324902869834, 0.15501541513935935, 0.14358191154774336, 0.2036764936682368, 0.1642097665553378, 0.21216711766761331, 0.17630462017151693, 0.19610364950298875, 0.19858673277431282, 0.19785921646256832, 0.2021740870552311, 0.18441545257959568, 0.20015270202604196, 0.19119877855352418, 0.19993451365293846, 0.19397999926083864, 0.2039756509251962, 0.18571505969723945, 0.17755569047820385, 0.1884858627731132, 0.07178310888643169, 0.05708325928927538, 0.054884143824690534, 0.06286707234272149, 0.062414321920344795, 0.07125475562806438, 0.06139275722386062, 0.06009786801849437, 0.0631083611613652]}, "mutation_prompt": null}
{"id": "28b3068a-79b6-4895-8bb8-3c50b0b40723", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Adjusted lower bound for adaptive scale factor to increase exploration\n        self.scale_factor_high = 0.8  # Adjusted upper bound for adaptive scale factor for better adaptability\n        self.crossover_rate = 0.9  # Increased crossover rate for improved recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability for local search to refine solutions\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Diversity Control for Improved Global Search.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6918714543838931, 0.6910977430055845, 0.7019190229217198, 0.7131466181419528, 0.708599945218332, 0.6843834705926312, 0.7178513142291807, 0.6724333687724252, 0.7058649964403547, 0.44465220834293917, 0.44166984048569347, 0.43981318108289846, 0.46063790262821336, 0.4563945015580806, 0.46833690342701406, 0.4454624941770239, 0.4688834694491132, 0.49100025304138195, 0.14198897644351294, 0.10415872257514314, 0.10623613874014082, 0.1214797471209782, 0.12867867527854437, 0.09665753454437986, 0.11739608230507748, 0.10199734905164282, 0.10358673613935643, 0.094231072501193, 0.09437093000384389, 0.09869767805564389, 0.10999438222356239, 0.0979665343386581, 0.09511626256860506, 0.09333602294702592, 0.1142526797912442, 0.09116677117802396, 0.8450273639062319, 0.9000687828673452, 0.9202945050087624, 0.9678956688073918, 0.974026374802772, 0.903834989636071, 0.9320001510852864, 0.920714123493345, 0.836837373142159, 0.3277807173554995, 0.3388929804044276, 0.2910863829330791, 0.28475453768731107, 0.2911693397057198, 0.35945623047851805, 0.3242509836690678, 0.3361548987660219, 0.36882775458562866, 0.6627259857344732, 0.6238440074019638, 0.6675140423303428, 0.7033395209704383, 0.6968724537492412, 0.6815489082809143, 0.6875189486397073, 0.6977000293845128, 0.6103753700601255, 0.18905782923525194, 0.19389481201949144, 0.17416803885076537, 0.1596627345944911, 0.1950429168320018, 0.19228335498289195, 0.20347874582328462, 0.17014094297286408, 0.17204315888565447, 0.17459293162214584, 0.16909264808399416, 0.276641642413606, 0.21181950988226195, 0.21616951484870017, 0.17596860088193111, 0.20172609290931032, 0.2650929408554884, 0.1400031180709137, 0.22557441893991914, 0.19826407038054983, 0.2535543305235103, 0.21468013451706303, 0.2401923186356103, 0.23446238128219576, 0.19571418238091987, 0.22853783260995897, 0.19765411270048705, 0.3492247992448493, 0.3661354935048017, 0.35649453199368586, 0.37038808140728774, 0.3216375852674641, 0.3498249008692268, 0.3244856401806804, 0.3894099466802361, 0.37823820259432483, 0.07731985720543977, 0.0852097220194179, 0.11008063684510327, 0.12252464472461722, 0.1306684492139697, 0.09385976779649208, 0.1150726540118705, 0.11425198370002765, 0.07802959571654478, 0.19306975700351892, 0.21109202111891323, 0.21095617587182836, 0.22204332121311254, 0.20545279321821797, 0.2368122984810188, 0.22554818128245846, 0.2033427246596179, 0.21167663575633366, 0.5492279674434093, 0.5789667044674054, 0.5913537899642323, 0.5545341155513159, 0.5669161320740956, 0.5651342983140633, 0.5556411038002859, 0.5646272647833525, 0.5639214912921623, 0.10119697042493847, 0.09516290590147014, 0.09400501093319835, 0.09668671028236442, 0.09095292866772142, 0.09628815587798578, 0.0856392901660119, 0.0939513063014702, 0.09614050443507671, 0.1550450438890837, 0.17295184134702213, 0.1330905405212447, 0.14980213543380383, 0.17905988339477952, 0.1358624039030334, 0.16392664736725493, 0.15115289783414831, 0.16122112565878144, 0.3340301095267507, 0.33634249574132935, 0.3497743108633796, 0.33375256792377317, 0.32863109680634284, 0.3289652493476697, 0.3650778549441407, 0.3675135088040581, 0.35382160379661265, 0.2465659159025566, 0.27347387439623994, 0.2553337641268145, 0.26326469779281403, 0.24587561354738208, 0.27106619851673275, 0.2874846145170341, 0.24998632942620214, 0.2567994429400131, 0.18842470163113334, 0.1855807107010008, 0.22362917335470334, 0.18812628331365544, 0.1910291139027852, 0.18898681083318902, 0.18172323501890864, 0.22049098336541628, 0.19143735291567898, 0.1730936062572469, 0.19424710182370386, 0.18832293256842447, 0.17610210366200896, 0.19150149347104573, 0.18223685978550697, 0.18794814465069343, 0.19114329553063092, 0.1858711350539194, 0.5252427617357969, 0.685102395699583, 0.5545045670714239, 0.18085650822706678, 0.18175054484590347, 0.5199309023343669, 0.16879589378208015, 0.4728382522698569, 0.58705569601029, 0.4282432488467497, 0.3975274514454984, 0.19932082520652605, 0.3926657931994182, 0.48761582886947863, 0.3851905752068613, 0.2004085935189417, 0.4712853852846106, 0.19789613592154187, 0.1976020606683352, 0.1871152637196739, 0.1774417303725957, 0.18142438995370935, 0.19230509981745725, 0.19565167642395764, 0.18283563560365257, 0.17716928029129708, 0.19209119295491095, 0.08003533707255306, 0.0732148501306068, 0.0716525413707042, 0.07190948906800076, 0.0797885303628747, 0.08059741662535669, 0.07092818999563655, 0.08447246685168797, 0.07097568413553768]}, "mutation_prompt": null}
{"id": "0475b0d4-5d85-41df-8d45-cd517ee0ef78", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly reduced for faster convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1  # Further lowered for increased exploration at the start\n        self.scale_factor_high = 0.9  # Increased to allow more aggressive mutation at times\n        self.crossover_rate = 0.85  # Slightly reduced to maintain diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased for more frequent local search\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Finer step size distribution for precise search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.7 and func(local_vector) < func(vector):  # More deterministic acceptance\n            vector = local_vector\n        return vector", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Strategic Diversity and Local Intensification.", "configspace": "", "generation": 35, "fitness": 0.29778138869976956, "feedback": "The algorithm AdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.7143653664052514, 0.682090085219873, 0.7046027742731591, 0.6905181109264473, 0.7216457829415586, 0.7222771107568905, 0.7116503822633007, 0.7120300213930568, 0.6915944509062089, 0.4819462809115094, 0.4798923267558687, 0.4766820208022615, 0.4799667470843013, 0.45882698098672314, 0.4626969032515402, 0.47375286415193973, 0.5030650445936796, 0.47350249326515204, 0.12470876757117944, 0.11111593220428806, 0.10520204198126426, 0.11330183311768782, 0.1116770730057749, 0.10542568868151925, 0.11464397851508312, 0.10203210699777043, 0.1303539141875868, 0.10105996736796574, 0.10133287475813124, 0.11482781707615197, 0.0952515962301097, 0.11012909871367937, 0.09246742909084749, 0.10878940783574675, 0.11059979343708382, 0.1101390575305442, 0.9037343456924445, 0.8256018090368338, 0.9171744319048255, 0.8833487388651862, 0.9541473822328906, 0.880752377601435, 0.9085257626116491, 0.841373688517746, 0.8446706516956011, 0.31001287586506265, 0.3179864906896037, 0.29484064385819375, 0.29809286051823525, 0.3183019584112753, 0.31022896393968735, 0.33158076645567747, 0.34030105917189646, 0.3331492224813316, 0.6013943840927987, 0.6446218316742544, 0.5614483918495349, 0.6400376157898987, 0.6351785776359423, 0.6628421841117595, 0.6681539248032666, 0.6170288286876824, 0.6265428088968414, 0.28962288333118213, 0.1641362718139302, 0.17240502442900885, 0.19563059401571403, 0.2393508035959908, 0.1484554573323561, 0.23407230391316047, 0.2844264990833524, 0.16768527959855528, 0.14644600652131945, 0.14000211209568403, 0.19155366826894693, 0.18465777557828822, 0.17729552270586557, 0.19842090373220267, 0.19082898020614236, 0.20169406944513957, 0.19578442547278996, 0.15265559387646044, 0.1498959015178467, 0.13992277160286992, 0.12877779984692328, 0.17867865060401167, 0.11506879521658375, 0.15832619745268384, 0.0766214059740028, 0.1473579510782398, 0.21411829414377936, 0.28970644985597405, 0.288642971048074, 0.23850705958374496, 0.2861828422853261, 0.31397229422892337, 0.360191920803298, 0.27477983404784245, 0.33956724535493477, 0.051693234529564314, 0.03858389113722094, 0.06692322681559648, 0.05838583056873836, 0.08365666128168048, 0.05104588682456379, 0.08289884402202752, 0.11865188179375197, 0.07476585128602198, 0.17056299154475052, 0.1849564634633828, 0.16372288121213263, 0.1809239948175434, 0.20114549478796695, 0.1663984246054191, 0.16774419160556642, 0.18317198347553731, 0.18586525659399322, 0.5006277417820607, 0.5439006101082311, 0.5403860309192015, 0.5256914815809215, 0.5553470027554229, 0.5083402575525748, 0.5245086655579835, 0.5606891538440418, 0.5300783278030734, 0.08632887147981705, 0.08513458240931904, 0.099515437733114, 0.10068076814576121, 0.09305048230097945, 0.09476258294198903, 0.09412814777205458, 0.09858182717228503, 0.08865880119109715, 0.1435292674760421, 0.13489489026539647, 0.12971010456838106, 0.16266712335872857, 0.14736937378233794, 0.16159824556476055, 0.15014719523095632, 0.14781636548874377, 0.14630095669329735, 0.3483509291015372, 0.3239200695417468, 0.3531446343392992, 0.3218890752600936, 0.33264764937249613, 0.3395027570944096, 0.35344098941815705, 0.3620983122285305, 0.3343925735565767, 0.23318573914535234, 0.2585669997367742, 0.2564326726542854, 0.24264044809201424, 0.2660996421023448, 0.24748976897836017, 0.2550374226654436, 0.2822072341694183, 0.2767088476697369, 0.22050342162161818, 0.2162300427946634, 0.20753151473120524, 0.19324165861604814, 0.18685814478631046, 0.19695126831901222, 0.20948759139305206, 0.1978313127049358, 0.19407905179532614, 0.18712817439913965, 0.22040351242121614, 0.19755054319010357, 0.1868322739098126, 0.1963787706857517, 0.19507556774591217, 0.19258710131712076, 0.3022883703996918, 0.19393088348914478, 0.17822037389127832, 0.5137454387537663, 0.625435901215888, 0.6386379766748221, 0.5327000591554822, 0.5831428651352727, 0.1557178521075928, 0.35037853677677144, 0.17654385953581875, 0.20073466408459084, 0.4608697312991391, 0.44910381311452496, 0.45790107542107295, 0.3783842968756438, 0.5409565855358354, 0.20426694245929122, 0.20476391918179893, 0.5819701071410219, 0.1832914354250369, 0.18223574747959959, 0.1698639386443478, 0.18714020945462373, 0.17273759208074757, 0.17514603641354043, 0.18900257676196786, 0.19472162885213506, 0.19008834223619697, 0.08685126611894722, 0.07512100501872354, 0.09012701674707113, 0.08128627311874514, 0.07460184106023349, 0.08085397659732785, 0.07769657353173576, 0.07972224826081331, 0.07795273575431005]}, "mutation_prompt": null}
{"id": "6a16f250-9002-4647-b38a-6618c8504293", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Slightly increased lower bound for adaptive scale factor to boost exploration\n        self.scale_factor_high = 0.7  # Slightly reduced upper bound for adaptive scale factor for finer adaptation\n        self.crossover_rate = 0.85  # Adjusted crossover rate for improved recombination balance\n        self.evaluations = 0\n        self.local_search_rate = 0.3  # Increased probability for local search to refine solutions further\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, np.random.uniform(0.05, 0.15), self.dim)  # Multi-scale step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Multi-Scale Perturbation for Enhanced Global and Local Search Balance.", "configspace": "", "generation": 36, "fitness": 0.2745703950847771, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6684822207273118, 0.6877224986849471, 0.6601779314119698, 0.6777139236381093, 0.6898908740870882, 0.6748790086793959, 0.6674680557114461, 0.662730625690958, 0.6757972284971248, 0.3788225628921522, 0.40218844120922903, 0.4406003083993255, 0.40478761663575813, 0.44950956292145594, 0.41360187165080464, 0.44469055625397325, 0.4118243652310195, 0.41591017558567045, 0.09934102064634864, 0.11830693403850623, 0.11120528253900919, 0.12563616191436866, 0.10007462416002688, 0.09771480687057388, 0.10500408412003359, 0.10515913136776744, 0.1045458644804057, 0.10324438858829776, 0.08750076173700838, 0.09180595525060176, 0.11175716830185434, 0.09762727747294686, 0.10031285391248235, 0.10273901049110046, 0.0942042054602582, 0.09487705082404518, 0.8999632426303941, 0.9216880302663103, 0.8524065216219262, 0.8621815805422272, 0.9342088771689023, 0.9339655571672599, 0.9169277897830463, 0.9239566502088381, 0.8315305407589048, 0.30328215078465526, 0.3011101736333489, 0.292866370324778, 0.2621095172257587, 0.28306987709955134, 0.273087585612082, 0.3145936916495923, 0.29733017401252126, 0.328827005029503, 0.5652902145444336, 0.5192753287614023, 0.547079356277907, 0.6269080660860317, 0.5723811667163192, 0.5767119784113659, 0.5418122192814178, 0.6161024690394044, 0.6395283216847272, 0.1489131301070893, 0.15847680808647113, 0.17020552334447203, 0.18867126264471135, 0.18228096871744193, 0.14643488685899775, 0.17701345228146237, 0.21357439907778175, 0.16306287984862322, 0.12309079444549642, 0.17165170770471527, 0.184137889748745, 0.14559258555792876, 0.16981123445446977, 0.17987286936321323, 0.19073302553330895, 0.19713288288886432, 0.17324118577010905, 0.1699064782889429, 0.10415087223884367, 0.11782082048507203, 0.09877512031611602, 0.11785685856920047, 0.11843165044252457, 0.1106898450728806, 0.1341966959961426, 0.12078080923117518, 0.25626687069008736, 0.2593209509087201, 0.26776124207641283, 0.20808681739407786, 0.24415739747174103, 0.24944032826406948, 0.2541304110844671, 0.2683300441245545, 0.2740560527291377, 0.03223651069781375, 0.024982719992215574, 0.07068323125661935, 0.05304870839322173, 0.05186945861025016, 0.04411039297520858, 0.05060095517761909, 0.06501189777953009, 0.06542104849588337, 0.146067733548226, 0.17063671852513507, 0.16805798828256013, 0.16526470116506375, 0.16512271279801827, 0.18218735698828947, 0.15972145387172643, 0.1646255972146351, 0.16367707273273013, 0.5068632018993815, 0.5002306612407847, 0.50327480230527, 0.5009546124697815, 0.4935688376016587, 0.49435489031467916, 0.4956856437138668, 0.5127177052164297, 0.5155032924738037, 0.09522206103200914, 0.09105427288820811, 0.09708584473308479, 0.09376080234300821, 0.10178346608035538, 0.09521380016409708, 0.09466898894249265, 0.1076549335615502, 0.08008877173125761, 0.1304106684696379, 0.13870331982007933, 0.1406525639725229, 0.1505252442297358, 0.1428102056045395, 0.1366032951202515, 0.14083747164172833, 0.15072361291181335, 0.14272870129647341, 0.30060605749247216, 0.294739048676125, 0.30221127308860074, 0.3288398943032609, 0.28031691178911655, 0.3140567933874149, 0.3396453782157739, 0.34301707991252584, 0.3233525078733952, 0.23383628503870146, 0.24303450995293419, 0.2198982761037621, 0.21908614490019662, 0.22234492846163156, 0.2271123101778263, 0.2436889820291146, 0.2285011219097558, 0.23988110481870517, 0.20380014954100756, 0.19874128584099438, 0.19086253777908657, 0.19331934675003237, 0.20372377148916654, 0.18252885670751717, 0.199078564347429, 0.1981076435273642, 0.19227987844171734, 0.18128228642047328, 0.17451104750145952, 0.194236890599632, 0.20428504690890703, 0.17903599950661642, 0.18715463892330797, 0.18904483008352369, 0.18416285777297858, 0.18333191211323285, 0.537247649440667, 0.1721773889372331, 0.416648725119407, 0.5364122882912923, 0.4876944862300615, 0.5850247302343823, 0.1728452099985549, 0.15779380279100041, 0.3675736176570168, 0.336994098619983, 0.19406398488649024, 0.1887661854437621, 0.21776355182314466, 0.2589612667154405, 0.17971017417233326, 0.20044242758879882, 0.4200006009517909, 0.5138944861801822, 0.1814709472382683, 0.19201107382521032, 0.18333871569346472, 0.1874357560074319, 0.18637046748772368, 0.1832336027100473, 0.18441243961728881, 0.17404614961800657, 0.19300110409832416, 0.0716280309334486, 0.07599517416831603, 0.07410172366105161, 0.0752851361834953, 0.07977333073473014, 0.06975457858410483, 0.08445927426887667, 0.07751259742802652, 0.07459086007944205]}, "mutation_prompt": null}
{"id": "94d45495-db39-41a4-8c18-c0e1b75899b6", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly reduced population size for computational efficiency\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Adjusted to enhance exploration capabilities\n        self.scale_factor_high = 0.9  # Adjusted to maximize exploration potential\n        self.crossover_rate = 0.85  # Slightly reduced to allow less disruptive recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased to emphasize solution refinement\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.15, self.dim)  # Modified to cover a broader neighborhood\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Increased probability of acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Dynamic Population Scaling and Strategic Local Perturbations.", "configspace": "", "generation": 37, "fitness": 0.2629690359073761, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.666937464285946, 0.660515334221895, 0.6831264179458998, 0.6694694866803671, 0.6566606379278912, 0.6739832253339229, 0.6581323362326896, 0.6826105746842419, 0.6405836273172975, 0.3801837328831852, 0.4093201024560702, 0.43121123782257453, 0.4175831884077359, 0.3857263209543996, 0.3935572064464561, 0.43511724967236065, 0.37843135912000503, 0.39827323932359227, 0.11126070063813254, 0.09701746526433674, 0.0965784084700112, 0.09634667606998482, 0.11477070439794224, 0.11602606759118661, 0.11937876038419215, 0.09870276499688702, 0.10290620410930773, 0.08957829293144437, 0.10288906403694764, 0.11922896972132002, 0.09292581369667896, 0.10190489838308714, 0.09263260716733346, 0.09744639277515255, 0.09294081831710155, 0.09917871278283852, 0.931151932654128, 0.8742435574017898, 0.9577382353869246, 0.9561897428726077, 0.9445690833064415, 0.87522484408606, 0.9366933563484163, 0.9643832847627819, 0.8936120658334717, 0.28641993524259446, 0.24848210717978958, 0.3192304489228812, 0.2675241281677173, 0.2921185504910706, 0.30830014510662596, 0.29338950402311315, 0.3079470713774407, 0.3120557682857601, 0.515061538307935, 0.4977695668163835, 0.5374643572359274, 0.536078977779813, 0.5271137915293829, 0.546948659291397, 0.5421599380010531, 0.5549739364713253, 0.5474094130867082, 0.1601665265081923, 0.17622221524326265, 0.16381830815338727, 0.1925008082682832, 0.20808627705176497, 0.16122214156419756, 0.1728220245830966, 0.1874848019295421, 0.16157454405542326, 0.1309820437547864, 0.16154127701135168, 0.14978332783969273, 0.1678427553146148, 0.16037037419444855, 0.19410062505247905, 0.1665686002398883, 0.19048330030154814, 0.18091037579226033, 0.11746931255011495, 0.10493553694797741, 0.12522653611963064, 0.13106287842361675, 0.08740801183815727, 0.11678869573318185, 0.0993750792591287, 0.1206770454656505, 0.10592337592487733, 0.21404430394883533, 0.2597969865585653, 0.1899227105393272, 0.1795469218550445, 0.2072846452619993, 0.21801223105484147, 0.2433619716851949, 0.2280102103207673, 0.2475277694683472, 0.05955104641112796, 0.028994662567982776, 0.05287235665294632, 0.054874685687739455, 0.027626972575775066, 0.029337397434908596, 0.03203183437218127, 0.0734959724100116, 0.03084267353108594, 0.139052566135634, 0.1882004170018683, 0.13921355968688764, 0.1472333272788664, 0.15555103523698177, 0.13764433484461336, 0.14421621284727548, 0.13167141167546992, 0.1491768900123549, 0.49474005682369604, 0.4809241145695017, 0.4954923142103834, 0.4879294635689677, 0.49276435615733594, 0.49593130483061576, 0.4877067481718277, 0.49769295664682944, 0.49306306427021396, 0.09361522896470087, 0.095422161020706, 0.07703161747188692, 0.08298245448204866, 0.08349980165799986, 0.08530625102956091, 0.11366035832832388, 0.08698705504297355, 0.08113476968109568, 0.13512675510335448, 0.15402191655181974, 0.13841133645452464, 0.1680636704175451, 0.12442502503811759, 0.13539490899081297, 0.15999513468891313, 0.1891276132867501, 0.13572709104868952, 0.30234036983201784, 0.2891002976771919, 0.28047639108993416, 0.28768631558852054, 0.29029629237206545, 0.29263645395592197, 0.30114996213345113, 0.33328531025836683, 0.3350009624517952, 0.21854637110289665, 0.21256684458008201, 0.21635491691306685, 0.2040041048042217, 0.20069701735091072, 0.21028955026793406, 0.22226465005792684, 0.26052837990570876, 0.2504494169257826, 0.19820549474785887, 0.17311273652161685, 0.17960537351720574, 0.19757680071518136, 0.18837940282411958, 0.1967449327363784, 0.1821980654570019, 0.20348639218354525, 0.1892712966996406, 0.18331847700554582, 0.17991871093295253, 0.1977272027673701, 0.18417592405553995, 0.20946388818427664, 0.18474581936921064, 0.19272097449975922, 0.17247375491544936, 0.18342242135630982, 0.4279594319412915, 0.5397237727660926, 0.2244976607383159, 0.384572895811389, 0.1815060359941807, 0.2511629089360009, 0.1770584713318445, 0.20315064561306073, 0.20823971897227633, 0.18859096182009893, 0.24857094709877714, 0.2188817144589439, 0.45459673289514935, 0.292969724412388, 0.15587042589757005, 0.17696736147856096, 0.20394613481307966, 0.2023827035214374, 0.1755910579694424, 0.1899404305788156, 0.17909458651952104, 0.17830979345964082, 0.1807509477185566, 0.19910744399705027, 0.18528938028848185, 0.20785974664407914, 0.19768089262226285, 0.06816329628236639, 0.07537064833264462, 0.06861526472064217, 0.07367224448116705, 0.07608827262915907, 0.07250063366878945, 0.07182969328162236, 0.07324443783318313, 0.07532402260225368]}, "mutation_prompt": null}
{"id": "d76f99b3-5122-4451-92b9-26719f150cd3", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Slightly increased lower bound for scale factor for better diversity\n        self.scale_factor_high = 0.7  # Slightly decreased upper bound for control over mutation explosiveness\n        self.crossover_rate = 0.85  # Slightly decreased crossover rate for stability in recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Tweaked probability for local search to balance exploration and exploitation\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation and Local Search Balance for Enhanced Global Optimization.", "configspace": "", "generation": 38, "fitness": 0.27580390262101007, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6844653658027071, 0.6668100616582979, 0.70487979360351, 0.7096478339192375, 0.6881481962482542, 0.7051783966038833, 0.706600508504368, 0.6836577038241595, 0.6778479787445424, 0.4876622210070264, 0.4505442575789993, 0.433008009231173, 0.4376042499367153, 0.3929742271302973, 0.4796861886696525, 0.43531446346762337, 0.4455958949397367, 0.4226597909636126, 0.11512159588204263, 0.11271739473027631, 0.12271260302075648, 0.10947478014846079, 0.10690622099448721, 0.10428270151355501, 0.11203967227411193, 0.13092180316399915, 0.10701248509749695, 0.0983958438533098, 0.11060812343180604, 0.0919191617760754, 0.09409284603986212, 0.09268346332710609, 0.10487187602667836, 0.09869698814498351, 0.09148838990159569, 0.09369275213614403, 0.9021189505032513, 0.9206770285249235, 0.8537843778685179, 0.8583431584751128, 0.8672073697170246, 0.9445356599704721, 0.8930387844622549, 0.854765588058696, 0.838600048799475, 0.29482454718423723, 0.3074451915555755, 0.2994919503969655, 0.2862742072433986, 0.30561183020020466, 0.3046865910280723, 0.28601615433782024, 0.30933209517216154, 0.29250253353566036, 0.5573215532759889, 0.5251004902854081, 0.5664556390573389, 0.5911534434157489, 0.6257450279632153, 0.6598121225977349, 0.5311544804580212, 0.6350653873073433, 0.7406948798625548, 0.14663625496263843, 0.15495083182187153, 0.1704346480997999, 0.14577736612516978, 0.16701927344591772, 0.2228903156150338, 0.2231618163588489, 0.1793418127749481, 0.16299607321180265, 0.14026254394889126, 0.14383736870650987, 0.16445669473468683, 0.18654677995607638, 0.13109979313589848, 0.17627651867666572, 0.1939033718684262, 0.2039494891232786, 0.21290934015223384, 0.14738978529246993, 0.12492152466675088, 0.16342208622253473, 0.11225217000362064, 0.12278866881605022, 0.12011074940898248, 0.16834603516685498, 0.12010202005618953, 0.1439225086618393, 0.263638406953309, 0.21597601538650857, 0.2625484995064007, 0.2283397049302196, 0.23465747512466362, 0.23624151764416634, 0.2778412137654406, 0.22624589704401743, 0.2612247382073767, 0.07455920054008236, 0.038819174151068725, 0.03158327789929538, 0.04172223881241677, 0.0263136627725169, 0.03085214536292047, 0.02962582693510596, 0.020962972394675816, 0.05764357763426631, 0.17503667923717459, 0.16287272527713015, 0.16236441012277536, 0.15217105210971094, 0.16237673754857185, 0.1766831484645105, 0.17037513864838094, 0.14480244300800182, 0.15505360545252955, 0.5016959191757612, 0.5045186191328461, 0.5155976529686568, 0.49103356928044806, 0.5030680357640813, 0.4956859962649701, 0.5476012406996373, 0.4986831412653775, 0.514019784773305, 0.09996942084248184, 0.09143727671057245, 0.09610367301750122, 0.09467862822848805, 0.09002664793517834, 0.08906858854441635, 0.09564415813909088, 0.08010241634196413, 0.09155165676668897, 0.1389029918155178, 0.14422364593279546, 0.15379239579352177, 0.14340998101218105, 0.1366074855175613, 0.12932850690331565, 0.14924963735979435, 0.13518636676112816, 0.13415663649148613, 0.3009872643847984, 0.29768821680480717, 0.32571233194491556, 0.3118008902903352, 0.3138512338556493, 0.31410382262119696, 0.3435033883302959, 0.3288571220718456, 0.3165459987370588, 0.23294662910585184, 0.22381084597691592, 0.25160912775801436, 0.22961703414137113, 0.22519298518568698, 0.23125058201534132, 0.26841359671253207, 0.24698122506202358, 0.23819426673291666, 0.197462462880166, 0.20811944596707144, 0.2284940694873987, 0.19515105373856567, 0.1863671575707736, 0.1845343943384491, 0.1978863974813586, 0.19923430656945018, 0.19587845828318462, 0.1905763384209732, 0.18540409232429678, 0.19035775082794193, 0.18961287091895884, 0.17987223549542308, 0.18261642969909742, 0.2016232669248479, 0.17850718472706484, 0.16645306255913617, 0.5115779620493011, 0.18895875407785556, 0.19048756864312388, 0.392412534788965, 0.3628814455419831, 0.5784711556689981, 0.3879159140353816, 0.18443975173791516, 0.16817005374760197, 0.18451719995043858, 0.33532664596697015, 0.24240414002761412, 0.2966307219561014, 0.1812463767476301, 0.3467388829247954, 0.18954185375731347, 0.5709378728520962, 0.19592586170415582, 0.1813424852258818, 0.17671196772923925, 0.20464737786490372, 0.1867465049388729, 0.2026672889873159, 0.17864001361877724, 0.19429693218921318, 0.19049151869076042, 0.19669663123962677, 0.07889313812560672, 0.07396125160805145, 0.07809055529318265, 0.08160502301981254, 0.08041981431354683, 0.07425348181839653, 0.08102969916789715, 0.07922522578547175, 0.06885748645794298]}, "mutation_prompt": null}
{"id": "790d972a-88a5-4e86-afc6-6b5ef88b27ae", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 16 * dim  # Adjusted population size for improved diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1  # Reduced lower bound for scale factor to enhance exploration\n        self.scale_factor_high = 0.9  # Increased upper bound for scale factor for better adaptability\n        self.crossover_rate = 0.85  # Adjusted crossover rate for balanced recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search for better refinement\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        # Adaptive local search with dynamic step size based on current evaluations\n        step_size_scale = np.interp(self.evaluations, [0, self.budget], [0.2, 0.05])\n        step_size = np.random.normal(0, step_size_scale, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Local Search for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 39, "fitness": 0.2630072875806974, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6282953723822284, 0.6103104742594334, 0.6401144831735758, 0.6451799259940793, 0.6379357948031461, 0.622828537041195, 0.6294477970278061, 0.6623667065329035, 0.6494750243492766, 0.35676053491673, 0.353629547452439, 0.3521069200200775, 0.3921895047090592, 0.3532619160129644, 0.3781767051868191, 0.3589506405132944, 0.3857150671268562, 0.3822897926642177, 0.10417526858297899, 0.1204996306480085, 0.10378222950514204, 0.0998515508485609, 0.11752910662191007, 0.10896618935614022, 0.11841166323818075, 0.11572027999224321, 0.10677427503633607, 0.10020570910457549, 0.10232651848103724, 0.09484632224669987, 0.09318224424287691, 0.09800247200767176, 0.09831429444634354, 0.09148108609535444, 0.10105573834213388, 0.09482681617709754, 0.9204256534424037, 0.8959926951021226, 0.8474764096705676, 0.9250342848327252, 0.8933622424485536, 0.8856437024687933, 0.9345599870237833, 0.8673937738309776, 0.818532235809614, 0.2435164216779554, 0.2733755722071063, 0.2552908414718159, 0.284862910375278, 0.27467231150072824, 0.2695664502923326, 0.2725883220319504, 0.3083811762406351, 0.28492377196176844, 0.5793621776934681, 0.531975033873665, 0.5076494965674969, 0.5905784212140466, 0.6013800045124202, 0.6376979254088421, 0.6184441907046889, 0.5488107091158234, 0.5700615502277426, 0.14910895801976698, 0.14187059894520393, 0.1446316340125371, 0.18790992595797884, 0.16382855415612996, 0.24015200135206283, 0.17183478440262767, 0.19622571578875692, 0.16288630158283213, 0.1195168960648767, 0.19784156949263, 0.14419994359820087, 0.21444012072283047, 0.19528969257628237, 0.14677406410781602, 0.17579725895122578, 0.14842117446629688, 0.1366422736447226, 0.10368043094209822, 0.1049909894711698, 0.1106222009164054, 0.10197803456701982, 0.08011295432249532, 0.07596352521329297, 0.09527365313223457, 0.11815626715528904, 0.07886423787804142, 0.2112960938238797, 0.2238415809891353, 0.20772814704332954, 0.20981164227935878, 0.21586897933877003, 0.22019572479687943, 0.24636094603180259, 0.2584228300398045, 0.20451176978693875, 0.016026461106038004, 0.026847406124860362, 0.022255313765568108, 0.05406244241409053, 0.036519854755809655, 0.0412093666303508, 0.030851942691111578, 0.033242486736218546, 0.05066090051722916, 0.14046970815224924, 0.1554033340388341, 0.1405079223645338, 0.1580731560683808, 0.16335000694874158, 0.16798537125867097, 0.14055515863423695, 0.15729823378551522, 0.1425931481130741, 0.48280555226273514, 0.49935149663913303, 0.48844555172752246, 0.4780336582167152, 0.44452318899428134, 0.46545145495027906, 0.4964790818096466, 0.4856629257848458, 0.48409517703135274, 0.10301068595958118, 0.09638659389616078, 0.0977870137105945, 0.09373096714243911, 0.09011651676254862, 0.0974476541870507, 0.09468462334427008, 0.0823185231003728, 0.09600751856520184, 0.1422789033042956, 0.1506385382400386, 0.1406120405046658, 0.1498357395437825, 0.16730120243115, 0.14858031422733187, 0.14123416928874355, 0.15039025912290438, 0.16139251239529973, 0.3085208034259306, 0.31006329796321774, 0.31558930976932265, 0.29220779807648656, 0.31356255037456493, 0.32614669535126184, 0.31732956765162856, 0.3244246454577975, 0.3330349371869262, 0.2232445946097722, 0.23659635545538482, 0.22339988035732972, 0.22974651596704165, 0.2346765808988558, 0.2252362163199897, 0.24698488057886947, 0.257084150059098, 0.22631936561831123, 0.1892807278570131, 0.20345805946139062, 0.18645687815461864, 0.18399972458761327, 0.19534316372181015, 0.19129318949833285, 0.2178723882715521, 0.20057921518341326, 0.20272555826503957, 0.20099100561235306, 0.18723676421587077, 0.19696588324117337, 0.18464452592549063, 0.18788545314957428, 0.18233310558779647, 0.18861285206444234, 0.19210415301307937, 0.17346783016481837, 0.1654895105435893, 0.29481098036950004, 0.46706214632974696, 0.41968982565071833, 0.3280014285593882, 0.4993028217977561, 0.264338457681666, 0.162791248579785, 0.4991771836097576, 0.5285361977006569, 0.18357345575198314, 0.24572987395861223, 0.18220663264363823, 0.2413468901044996, 0.19999454324597998, 0.2004561611218867, 0.2983293820775411, 0.19801186994743225, 0.17858699264473343, 0.19559682305345827, 0.202486908441723, 0.17541580937617363, 0.1837302944574526, 0.1969441873364507, 0.1835737970835899, 0.18704450527812533, 0.17966337827769474, 0.07254757223276831, 0.07357429637732871, 0.07591001206540782, 0.0712877896669124, 0.07405393370778823, 0.07064695528794018, 0.069984194846754, 0.09373794486739517, 0.07441152599175094]}, "mutation_prompt": null}
{"id": "9e1a723f-b8a8-463f-a1fd-2c8eca1093f0", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.9  # Slightly increased upper bound of scale factor for more aggressive exploration\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.2\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.2, self.dim)  # Adjusted the variance for broader exploration\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Self-Adaptive Parameters for Enhanced Global Navigation.", "configspace": "", "generation": 40, "fitness": 0.29202021729935645, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6607061882676117, 0.684465226322077, 0.6527668284269095, 0.684799483170552, 0.6731839279156782, 0.6625573701896557, 0.6886270951221749, 0.6577520269910433, 0.6926000527389613, 0.4495262308951603, 0.41636601553222596, 0.41694745590165627, 0.44776005928390006, 0.3968315660971957, 0.4337603039897633, 0.38868004009930657, 0.44820849522221706, 0.4263737883088745, 0.09910750822914416, 0.1052010293200607, 0.09772838775986781, 0.11459125358865663, 0.10129093773285536, 0.1049591197927966, 0.1049553823890157, 0.10695956431534415, 0.10092680870426796, 0.08971420621142367, 0.0920580795165622, 0.08804262650172656, 0.09951490668508978, 0.10348090744972105, 0.09452116928311194, 0.09078259004023825, 0.09807094249105175, 0.0875078514861618, 0.9347874271368054, 0.9382307042899909, 0.98566953698569, 0.8834348860706168, 0.8409085889534526, 0.914885530643292, 0.9202926683037819, 0.7869808237470847, 0.8798016077281092, 0.3303463211223888, 0.2768134181124998, 0.2915344121522415, 0.3344887047002916, 0.31241299418092516, 0.2866112870047042, 0.3003992567746987, 0.335925216855817, 0.3139203404822628, 0.6500396857805484, 0.58646988783199, 0.6549977129047841, 0.6376078272356773, 0.5967622060356084, 0.6657881920688962, 0.6010022326812903, 0.6337076155901749, 0.6359813488555432, 0.20975971644175428, 0.19658159369392703, 0.3224377059578132, 0.2236960357603336, 0.1917971120114531, 0.15023376644597175, 0.1592370146315859, 0.209308050834776, 0.17047614387725185, 0.25055010440789705, 0.14693218994382007, 0.10820913834627932, 0.2592888861673962, 0.2485252147704794, 0.20172191659000394, 0.17607209106862376, 0.2167250274768293, 0.27051993241089967, 0.20675916951309659, 0.1982651114254168, 0.18160262962262008, 0.21844395411935058, 0.19270650374327936, 0.16218107435249673, 0.1812068130291602, 0.18484588376281708, 0.20705079578135777, 0.3241093979782701, 0.327488651680516, 0.31681984434420907, 0.315554834339718, 0.31185032803530144, 0.29835985115843655, 0.34464305226458114, 0.32402353676499374, 0.3496262969561845, 0.049783707928801046, 0.10180501277889686, 0.08084620926653319, 0.08587547824874109, 0.06292935617644158, 0.0884081968795124, 0.043555366061184264, 0.11818716141703622, 0.08516245042399528, 0.1906551127526077, 0.2022720878597376, 0.18169758792519963, 0.19371027870557833, 0.20499339931657745, 0.1859242827135541, 0.18050603338274418, 0.18870415533198437, 0.17927470378822896, 0.5191441200762721, 0.5452842246078657, 0.5571085037231165, 0.5396552298876123, 0.5442522155134648, 0.5560471296969411, 0.5525922220768211, 0.5360453104748073, 0.5123379339946382, 0.09932526068629899, 0.10086890227931178, 0.08007745445634573, 0.0991089708591737, 0.09057868158481885, 0.08961454348344378, 0.09479447299221333, 0.08895660413662332, 0.08727332825308642, 0.1366821519686402, 0.15553205892579558, 0.14097259708683307, 0.1651793660265699, 0.1530125609690185, 0.13677969848526317, 0.1483330868082936, 0.14992220509388376, 0.1267896953965294, 0.30401110763023875, 0.32040104031373773, 0.308229842307703, 0.3205760337673086, 0.3081599745982099, 0.2984980744377811, 0.3512995239005279, 0.32712634506966687, 0.3396842569154547, 0.24796064727773914, 0.25384702139649773, 0.25828552097823587, 0.22427865740432418, 0.24057041896851827, 0.2342489105126908, 0.25571324504151227, 0.2793484500859582, 0.2393849132604713, 0.18720951369944983, 0.202401881130169, 0.19720028717681848, 0.19936872866703104, 0.19265916652322967, 0.1915313877028081, 0.19652845092699012, 0.2084401213903846, 0.19610604636387896, 0.18117136702367287, 0.17664663202973607, 0.19811290052404584, 0.1943361988439417, 0.19622570527107797, 0.18642640981563996, 0.17882496485115118, 0.18989415433923174, 0.1808006857299146, 0.6328681814822792, 0.1939751967233525, 0.17904327523341212, 0.18042884184675534, 0.45543159817057055, 0.5162863601423263, 0.4977085761938669, 0.15327228179071228, 0.3059312292969655, 0.16216726242982926, 0.4055343929227191, 0.3204126733513709, 0.41047287200140303, 0.1891113274557169, 0.4576354824887351, 0.20610240632052623, 0.5474307670118268, 0.3492961035779818, 0.18234073840376275, 0.192409127794824, 0.1920710580482653, 0.17842925577048463, 0.17462374380244272, 0.17226088370324966, 0.18357850258684294, 0.177694109641775, 0.21570556758983106, 0.07914642853932896, 0.08234306135175806, 0.08392975317967843, 0.0788142966788471, 0.07712670599482974, 0.07460814829489248, 0.07004008517518001, 0.08157097005736325, 0.07176274532036986]}, "mutation_prompt": null}
{"id": "cfb434a0-a962-42ee-b945-ccaf19c6957b", "solution": "import numpy as np\n\nclass AdaptiveMemeticQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1  # Further reduced lower bound for adaptive scale factor for increased exploration\n        self.scale_factor_high = 0.9  # Expanded upper bound for adaptive scale factor to enhance adaptability\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for better balance between exploration and exploitation\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search to refine solutions further\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Further narrowed step size distribution for finer tuning\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.6 and func(local_vector) < func(vector):  # Increased stochastic acceptance probability\n            vector = local_vector\n        return vector", "name": "AdaptiveMemeticQIDE", "description": "Adaptive Memetic Quantum-Inspired Differential Evolution with Enhanced Scale Factor Adjustments and Local Search Refinement.", "configspace": "", "generation": 41, "fitness": 0.2789479698298368, "feedback": "The algorithm AdaptiveMemeticQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6716740539388713, 0.6750826752487409, 0.6886251197163612, 0.701626657158938, 0.673897140070818, 0.6522312040769632, 0.671485810944771, 0.6477942217529669, 0.6974674426284411, 0.43565861923473015, 0.3933450308719585, 0.41050006019497887, 0.407716833969587, 0.42420972000079193, 0.4417582316506896, 0.44688261347345437, 0.40298445717607123, 0.4050047294038691, 0.10799869512014759, 0.09739133280205081, 0.10370133180572372, 0.10363710458388709, 0.10105185882904133, 0.1255925117286737, 0.10836422770069531, 0.11520677369277477, 0.10783220519685144, 0.10405878035281546, 0.10113483500382447, 0.10321154584303516, 0.10964221402296337, 0.10005389407563581, 0.09339959920979546, 0.10663279270011605, 0.09886512375756029, 0.10496519645563274, 0.8893255449845919, 0.9366930795846635, 0.9422542315877597, 0.9133424198944795, 0.8641185742205468, 0.7909528659168215, 0.9668082122371097, 0.8738090425620013, 0.8726984951737624, 0.2709923331137385, 0.28285367580489806, 0.26629302760564066, 0.29172192634890937, 0.24967228523014318, 0.28055681455896253, 0.31005742443213424, 0.28307588735377776, 0.3065662171882283, 0.6170776247298171, 0.5600944978303266, 0.6034262790805756, 0.5920288429796885, 0.6153790909635946, 0.6157087838946382, 0.6708427256996068, 0.5608138554688928, 0.5396171600508315, 0.12854725034110037, 0.1824452245615803, 0.17627406581606686, 0.16287638832619833, 0.20948530671623034, 0.14912924783721715, 0.19484134932260477, 0.17179163658096763, 0.20699595044903196, 0.17422936185896998, 0.13557875990737156, 0.1697863314378446, 0.19673025514675413, 0.14809973288466172, 0.16811135261966847, 0.1734600150579252, 0.17705562072781356, 0.17298520606683598, 0.12597168595700803, 0.11436872942360332, 0.13152904910102514, 0.13524980117225682, 0.10270901627718831, 0.17767054505425117, 0.15022331202865702, 0.13420040649444398, 0.12186252764562056, 0.25195190203522544, 0.2452566023846956, 0.26148481000104506, 0.24960695120596388, 0.23302756598577068, 0.21613160441763613, 0.3112592046122129, 0.2718101986260637, 0.2523725655992688, 0.046024305677352495, 0.04647789190142049, 0.07127416371134554, 0.08182891744077969, 0.014733959904736582, 0.07579269535886946, 0.058456388070580956, 0.06231752962949544, 0.057665984011133875, 0.17109416181327852, 0.15937489540604421, 0.15788629179039415, 0.18439751262440895, 0.16536532573276075, 0.17288450103147557, 0.15664528200677996, 0.16440298653003416, 0.15249503844455736, 0.4892744289294493, 0.49654483230841984, 0.5024970874902333, 0.4938439955132399, 0.5350033937098118, 0.5235865566508109, 0.5457562183505935, 0.516233325757681, 0.49614033406197977, 0.08588804416518492, 0.09087145494243154, 0.10308070734719454, 0.11840061293711823, 0.0900319306655023, 0.10005341891685715, 0.08444319398193312, 0.08745178834652856, 0.0972524517621488, 0.14468347199633858, 0.12734517251820654, 0.14349592951942736, 0.21185200924410152, 0.1566853060896145, 0.14172273829706405, 0.15683717633834182, 0.14142395694416177, 0.15201987827497154, 0.338549716361469, 0.28627206773585556, 0.31878293379295797, 0.3117460579831651, 0.29646120311113144, 0.31534935609136816, 0.33504135355003006, 0.35059285846028165, 0.34981117267669337, 0.24518233952692736, 0.22699169988953039, 0.23580299879919753, 0.25243846654321567, 0.23811734669095008, 0.23263263636026754, 0.2582635267889083, 0.26932160240324243, 0.25808883859402354, 0.18750602463931232, 0.20804858780664293, 0.19387102849178162, 0.22113966209856528, 0.2147799111071984, 0.19346446073675327, 0.192365697675959, 0.19860269981742984, 0.21088888791962368, 0.2032566936511826, 0.18497343102283903, 0.20059232225156742, 0.18881162956147668, 0.18810592132903348, 0.19325179260460834, 0.19993957637557425, 0.20714767562785108, 0.1876715748041442, 0.18055221656571574, 0.610693785752295, 0.5747638565583668, 0.3804475126327823, 0.476476999519735, 0.1723700154740242, 0.4911503111390366, 0.38433972978925734, 0.5088152846593548, 0.1948281479982764, 0.18680564280580125, 0.19708400254899794, 0.3701619434537726, 0.19301383615447354, 0.1550968360858067, 0.5704271628693737, 0.19427026075110865, 0.20001141159955327, 0.1812004289529463, 0.18069405716819043, 0.18668950893910718, 0.20459452535095946, 0.2182538719102799, 0.1869184674602138, 0.1964567046141794, 0.1746825697453125, 0.1833596735282671, 0.06862656263993194, 0.07423585349489259, 0.07549166488620063, 0.07937765750750003, 0.07363009539369636, 0.07846541979904431, 0.08811810360148231, 0.07140865855881562, 0.07127260773929533]}, "mutation_prompt": null}
{"id": "cbb59179-3a95-424e-b2cd-c5b0d68c4fac", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim  # Adjusted population size for greater diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Adjusted lower bound for adaptive scale factor to increase exploration\n        self.scale_factor_high = 0.8  # Adjusted upper bound for adaptive scale factor for better adaptability\n        self.crossover_rate = 0.9  # Increased crossover rate for improved recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Increased probability for local search to refine solutions\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):  # Stochastic acceptance\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Diversity Control for Improved Global Search.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.6918714543838931, 0.6910977430055845, 0.7019190229217198, 0.7131466181419528, 0.708599945218332, 0.6843834705926312, 0.7178513142291807, 0.6724333687724252, 0.7058649964403547, 0.44465220834293917, 0.44166984048569347, 0.43981318108289846, 0.46063790262821336, 0.4563945015580806, 0.46833690342701406, 0.4454624941770239, 0.4688834694491132, 0.49100025304138195, 0.14198897644351294, 0.10415872257514314, 0.10623613874014082, 0.1214797471209782, 0.12867867527854437, 0.09665753454437986, 0.11739608230507748, 0.10199734905164282, 0.10358673613935643, 0.094231072501193, 0.09437093000384389, 0.09869767805564389, 0.10999438222356239, 0.0979665343386581, 0.09511626256860506, 0.09333602294702592, 0.1142526797912442, 0.09116677117802396, 0.8450273639062319, 0.9000687828673452, 0.9202945050087624, 0.9678956688073918, 0.974026374802772, 0.903834989636071, 0.9320001510852864, 0.920714123493345, 0.836837373142159, 0.3277807173554995, 0.3388929804044276, 0.2910863829330791, 0.28475453768731107, 0.2911693397057198, 0.35945623047851805, 0.3242509836690678, 0.3361548987660219, 0.36882775458562866, 0.6627259857344732, 0.6238440074019638, 0.6675140423303428, 0.7033395209704383, 0.6968724537492412, 0.6815489082809143, 0.6875189486397073, 0.6977000293845128, 0.6103753700601255, 0.18905782923525194, 0.19389481201949144, 0.17416803885076537, 0.1596627345944911, 0.1950429168320018, 0.19228335498289195, 0.20347874582328462, 0.17014094297286408, 0.17204315888565447, 0.17459293162214584, 0.16909264808399416, 0.276641642413606, 0.21181950988226195, 0.21616951484870017, 0.17596860088193111, 0.20172609290931032, 0.2650929408554884, 0.1400031180709137, 0.22557441893991914, 0.19826407038054983, 0.2535543305235103, 0.21468013451706303, 0.2401923186356103, 0.23446238128219576, 0.19571418238091987, 0.22853783260995897, 0.19765411270048705, 0.3492247992448493, 0.3661354935048017, 0.35649453199368586, 0.37038808140728774, 0.3216375852674641, 0.3498249008692268, 0.3244856401806804, 0.3894099466802361, 0.37823820259432483, 0.07731985720543977, 0.0852097220194179, 0.11008063684510327, 0.12252464472461722, 0.1306684492139697, 0.09385976779649208, 0.1150726540118705, 0.11425198370002765, 0.07802959571654478, 0.19306975700351892, 0.21109202111891323, 0.21095617587182836, 0.22204332121311254, 0.20545279321821797, 0.2368122984810188, 0.22554818128245846, 0.2033427246596179, 0.21167663575633366, 0.5492279674434093, 0.5789667044674054, 0.5913537899642323, 0.5545341155513159, 0.5669161320740956, 0.5651342983140633, 0.5556411038002859, 0.5646272647833525, 0.5639214912921623, 0.10119697042493847, 0.09516290590147014, 0.09400501093319835, 0.09668671028236442, 0.09095292866772142, 0.09628815587798578, 0.0856392901660119, 0.0939513063014702, 0.09614050443507671, 0.1550450438890837, 0.17295184134702213, 0.1330905405212447, 0.14980213543380383, 0.17905988339477952, 0.1358624039030334, 0.16392664736725493, 0.15115289783414831, 0.16122112565878144, 0.3340301095267507, 0.33634249574132935, 0.3497743108633796, 0.33375256792377317, 0.32863109680634284, 0.3289652493476697, 0.3650778549441407, 0.3675135088040581, 0.35382160379661265, 0.2465659159025566, 0.27347387439623994, 0.2553337641268145, 0.26326469779281403, 0.24587561354738208, 0.27106619851673275, 0.2874846145170341, 0.24998632942620214, 0.2567994429400131, 0.18842470163113334, 0.1855807107010008, 0.22362917335470334, 0.18812628331365544, 0.1910291139027852, 0.18898681083318902, 0.18172323501890864, 0.22049098336541628, 0.19143735291567898, 0.1730936062572469, 0.19424710182370386, 0.18832293256842447, 0.17610210366200896, 0.19150149347104573, 0.18223685978550697, 0.18794814465069343, 0.19114329553063092, 0.1858711350539194, 0.5252427617357969, 0.685102395699583, 0.5545045670714239, 0.18085650822706678, 0.18175054484590347, 0.5199309023343669, 0.16879589378208015, 0.4728382522698569, 0.58705569601029, 0.4282432488467497, 0.3975274514454984, 0.19932082520652605, 0.3926657931994182, 0.48761582886947863, 0.3851905752068613, 0.2004085935189417, 0.4712853852846106, 0.19789613592154187, 0.1976020606683352, 0.1871152637196739, 0.1774417303725957, 0.18142438995370935, 0.19230509981745725, 0.19565167642395764, 0.18283563560365257, 0.17716928029129708, 0.19209119295491095, 0.08003533707255306, 0.0732148501306068, 0.0716525413707042, 0.07190948906800076, 0.0797885303628747, 0.08059741662535669, 0.07092818999563655, 0.08447246685168797, 0.07097568413553768]}, "mutation_prompt": null}
{"id": "24455886-79be-479a-8f4e-e321921bdec9", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1  # Slightly reduced for finer exploration\n        self.scale_factor_high = 0.9  # Slightly increased for broader adaptability\n        self.crossover_rate = 0.85  # Slightly adjusted for balance\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased probability for local search refinement\n        self.dynamic_factor = 0.5  # New factor for dynamic adaptation\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n                self.dynamic_adaptation()\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < (self.dynamic_factor * self.crossover_rate)\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector\n\n    def dynamic_adaptation(self):\n        # Adjust the dynamic factor based on performance metrics (e.g., diversity, convergence)\n        if np.random.rand() < 0.1:\n            self.dynamic_factor *= 1.05  # Slightly increase factor\n        else:\n            self.dynamic_factor *= 0.95  # Slightly decrease factor\n        self.dynamic_factor = np.clip(self.dynamic_factor, 0.1, 1.0)", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Dynamic Adaptive Mechanisms for Enhanced Performance and Convergence.", "configspace": "", "generation": 43, "fitness": 0.2067639910507707, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.64065795518034, 0.6347459900971206, 0.613788371882202, 0.6119375882190232, 0.6082054628703679, 0.6267184699813058, 0.6133282175856415, 0.601091446150877, 0.6152621348446838, 0.3158301502788481, 0.3200662885538855, 0.30807252471600455, 0.3029776483811114, 0.2732768370300346, 0.28282232860264844, 0.29322492115286547, 0.3062081855280582, 0.30961138919715514, 0.2309413812866259, 0.2550736179989116, 0.27987174013880844, 0.25872631305859595, 0.2626831352442105, 0.2274267611758124, 0.252589715599258, 0.26470671378664656, 0.2362277352615122, 0.21110359026878023, 0.20323841150110178, 0.2057065489644766, 0.19358725009636546, 0.20914958884471302, 0.1702405620705436, 0.2161830813661877, 0.1737815751108368, 0.18938467554155025, 0.8886844302806219, 0.8990454565768901, 0.8853055614820922, 0.9062227866884431, 0.8778200887881678, 0.8676394253206086, 0.9070367808109323, 0.8780718825011219, 0.865469689904637, 0.1376868285563282, 0.13076064444900548, 0.11772852495150399, 0.12428738086096258, 0.11706005120002227, 0.13314692804037076, 0.1315752445302356, 0.1478496594984755, 0.11708758766639837, 0.15727459189547588, 0.17338164863269845, 0.13984722406450767, 0.2434645520659514, 0.19592741745392428, 0.19462900855726917, 0.16883053487920463, 0.17016529558393811, 0.16501995922682167, 0.12982343647346883, 0.12729306724053424, 0.11233533702577547, 0.12731128285120707, 0.10262010235982977, 0.1396057731870255, 0.13193320520097807, 0.14919245588427998, 0.12153552185504635, 0.09849168050772572, 0.12631307329556463, 0.09790352879259068, 0.1080634049532524, 0.10261398991060744, 0.1154294770627855, 0.08605983834163566, 0.10440903190107798, 0.10618466894239753, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012810209184664245, 9.999999999998899e-05, 9.999999999998899e-05, 0.054093698588830175, 0.047028586894179214, 0.056086377080682204, 0.10415417741268795, 0.05325351667701683, 0.05211713708189125, 0.05867719574517527, 0.08801536083070327, 0.07422822994415579, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05431697784059619, 0.03821956228465029, 0.05775128554762632, 0.05997087782812327, 0.06952479577316772, 0.060364436635398144, 0.0554690546375769, 0.05795392265279664, 0.060083597840987935, 0.3592273336018682, 0.3604715639560776, 0.37715310879438935, 0.35468707068557415, 0.3628040227052778, 0.35500745335573736, 0.36741133136477666, 0.3553353134838534, 0.3643989141244146, 0.0779642221398471, 0.1112252330348914, 0.08874702370766718, 0.08419102219917318, 0.07972399744296166, 0.0832376914061953, 0.085316676417873, 0.08361113333156045, 0.08298864194341526, 0.19359509366942718, 0.13536584275497876, 0.14581355544833763, 0.15756628912182968, 0.14209022092858647, 0.14088598743937364, 0.16917836366095595, 0.13829679509771087, 0.1478649075811963, 0.19481505234491037, 0.1941998143368534, 0.20369060605642886, 0.22680568992492023, 0.22217400334703208, 0.2066804876387689, 0.21522052024290783, 0.21108894890268592, 0.20970929180224473, 0.15895988941774264, 0.14512675518201668, 0.14420627192312696, 0.1575701726634452, 0.1429222033837696, 0.1440800512307454, 0.14952275805707071, 0.1659937896536794, 0.13114413291695093, 0.18781169723582725, 0.17727024702712701, 0.1951785845212286, 0.18929288437306502, 0.18593403706187817, 0.17567832671111316, 0.18566371189960007, 0.20444927102943644, 0.1877375403812449, 0.20748399340414858, 0.1960472908864591, 0.20360361834750773, 0.18935592318440875, 0.1948122946010572, 0.22812870189963108, 0.19708364638486742, 0.19929248349304685, 0.19521300623506133, 0.2078353001575941, 0.18155457416806908, 0.2567824541203162, 0.2820679807417763, 0.23422933821703484, 0.19694028530489083, 0.24493150401264452, 0.3174566279692004, 0.19774890051442595, 0.23964130470840483, 0.22822546675841682, 0.17847766741596138, 0.17626636729435508, 0.18567327373346232, 0.23288923877956613, 0.18373941932896798, 0.20351556927817993, 0.22438876986269984, 0.18083292278439822, 0.17660130687856013, 0.1816878393168586, 0.17793327282832538, 0.18409412032723105, 0.19372933846432394, 0.19371605530586933, 0.17627768186995962, 0.18465211858732944, 0.06915689368311762, 0.07903669863017238, 0.069201236654582, 0.07462933906809854, 0.0681558403752528, 0.07498362866521346, 0.06893490691994175, 0.07961677892317676, 0.06490616991772802]}, "mutation_prompt": null}
{"id": "b293ae17-4eee-4c55-9dc8-770cac16e59d", "solution": "import numpy as np\n\nclass HybridAPSO_QIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly smaller population for focused search\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Modified for more effective exploitation\n        self.scale_factor_high = 0.7  # Narrowed range for better control\n        self.crossover_rate = 0.85  # Slightly reduced to balance recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased for better local refinement\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, dim))  # Added velocity for PSO dynamics\n        self.inertia_weight = 0.5  # Inertia weight for PSO\n        self.cognitive_coeff = 1.5  # Cognitive coefficient for PSO\n        self.social_coeff = 1.5  # Social coefficient for PSO\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                    \n                # PSO Update\n                personal_best = self.population[i].copy()\n                global_best = self.population[np.argmin(self.fitness)]\n                self.velocity[i] = (self.inertia_weight * self.velocity[i] +\n                                    self.cognitive_coeff * np.random.rand() * (personal_best - self.population[i]) +\n                                    self.social_coeff * np.random.rand() * (global_best - self.population[i]))\n                self.population[i] = np.clip(self.population[i] + self.velocity[i], self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Finer step size for precise local search\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "HybridAPSO_QIDE", "description": "Hybrid Adaptive Particle Swarm Optimization with Quantum-Inspired Differential Evolution for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 44, "fitness": 0.16621687374770724, "feedback": "The algorithm HybridAPSO_QIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.21.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.15778055203965646, 0.18259195377784254, 0.4697808335181728, 0.17207881780013123, 0.7655216202985917, 0.5643955405221097, 0.2921678672050221, 0.3374717007801815, 0.2987298181358543, 0.1713776829526067, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03312684230343743, 9.999999999998899e-05, 9.999999999998899e-05, 0.04845017646227767, 0.047125508043340036, 0.06787946797249622, 0.04092982905079934, 0.0589552081295569, 0.06057866013828239, 0.04814050691749272, 0.0478296264281709, 0.050455862449776956, 0.03856167353002948, 0.10650639712790921, 0.03977094082567345, 0.04959407343457278, 0.045612674006854315, 0.022652979394489514, 0.07705997186532254, 0.17224852465237694, 0.04157282695251674, 0.9615059075455611, 0.9618616785827723, 0.9572630626544705, 0.9639168842360005, 0.9644078458545193, 0.9711686696317106, 0.9753624195545372, 0.9731454400679861, 0.9657974584425215, 0.23015986403525668, 0.32528960849696376, 0.20763310419588232, 0.1048755724802195, 0.14803379518913828, 0.09818259682530739, 0.08774856123902774, 0.08662447133086193, 0.22915504967637168, 0.220878754873583, 0.22386830393778434, 0.20817548938391528, 0.15802138223821016, 0.17269116006239216, 0.15318340359249183, 0.14922956204167004, 0.13318713389546466, 0.14105417794358632, 0.07689512915552243, 0.12186818235046026, 0.027625408962189013, 0.11730434321116023, 0.10548115490238197, 0.3139529960006947, 0.13749288131715187, 0.0011071016715613613, 0.1234145419963596, 9.999999999998899e-05, 9.999999999998899e-05, 0.4658699632910718, 0.46596192606629794, 0.11583591371619262, 9.999999999998899e-05, 0.12099602956439781, 0.1763915599765884, 0.04157940563672602, 9.999999999998899e-05, 9.999999999998899e-05, 0.05939511363198202, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024405895068578154, 0.022660251951454713, 0.02411282372177448, 0.016860933656095534, 0.03047904918967137, 0.01708195635680987, 0.009294462973095885, 0.008884797928746746, 0.02511357003472059, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08060034867714949, 9.999999999998899e-05, 0.15119593335772152, 9.999999999998899e-05, 9.999999999998899e-05, 0.12971028541650687, 0.04589101648944072, 0.0011000057473115055, 0.0013680075705886363, 0.06453612110232532, 0.031286646999804324, 0.21695244535980107, 0.4993047647974984, 0.38333738477786483, 0.2483980733802409, 0.26662880769701613, 0.2535108483355232, 0.4320185626062104, 0.17168408634405552, 0.35147947803602797, 0.07141112760133961, 0.05143495898710937, 0.09066590218324944, 0.04804918281119985, 0.043614067102553, 0.05055997311251781, 0.0676884729578967, 0.06633619535866908, 0.053177811448152146, 0.14134254309572536, 0.11029400662840705, 0.11842175776965747, 0.3550305918859873, 0.21676076831607938, 0.10798713552628325, 0.11627447457892592, 0.09091108223903943, 0.1139140981571023, 0.25242096958663673, 0.13898305488136609, 0.21502638726540568, 0.2520571948875455, 0.259530663069067, 0.17022751933808355, 0.18935991856719625, 0.177190275985182, 0.27580429471107226, 0.16286428384419394, 0.15843026089920764, 0.17098131900404057, 0.13371412050337494, 0.10977673599264615, 0.19860136568740316, 0.14231674321197574, 0.10139059099976688, 0.11406098447690383, 0.20302858143316382, 0.137646806346168, 0.17635498828234408, 0.15483530259181022, 0.1655101374538568, 0.1653181769980231, 0.1735842784143692, 0.13412922460906118, 0.17356723178574862, 0.16509909203261286, 0.162951139531461, 0.1585500121096608, 0.17647214258410748, 0.1583966602013428, 0.1949188072053728, 0.17826995909243504, 0.1337801599521774, 0.14612606862739863, 0.11233635004706699, 0.1833028452429878, 0.16166212560035054, 0.22107225852074075, 0.19624754060198846, 0.17129571156737888, 0.17707701833247103, 0.15816873874840054, 0.1403063808080769, 0.850069026191497, 0.1711004109318467, 0.07292673668157856, 0.10462104255577509, 0.11964998339699995, 0.10300605887162761, 0.20825710371093675, 0.10983700304123722, 0.08971852329747931, 0.17544139541793424, 0.1933683236015057, 0.1902320065962525, 0.15604450033961437, 0.16907414135852505, 0.18365234778869421, 0.20025102230474456, 0.1778254010441631, 0.18801610172508354, 0.06956698954208174, 0.04745382656780639, 0.054787715901274736, 0.07898580890857831, 0.047098927292859694, 0.08004028759047, 0.07669253444153978, 0.04564312249014779, 0.059628112772452946]}, "mutation_prompt": null}
{"id": "167a794e-2fe5-4de2-a090-1f2a6a4637f7", "solution": "import numpy as np\n\nclass QuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1  # Lower scale factor for finer exploration\n        self.scale_factor_high = 0.9  # Higher scale factor for broader search space exploration\n        self.crossover_rate = 0.95  # Enhanced crossover rate for thorough recombination\n        self.evaluations = 0\n        self.local_search_rate = 0.15  # Reduced local search probability to balance exploration\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)  # Narrower step size distribution\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "QuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Mutation Range and Enhanced Crossover for Robust Global Optimization.", "configspace": "", "generation": 45, "fitness": 0.3453344501056834, "feedback": "The algorithm QuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.22.", "error": "", "parent_id": "1e060c46-5846-4d06-b6c9-1fb48dd74b7a", "metadata": {"aucs": [0.713950667284043, 0.719473352429832, 0.691572916333858, 0.7412445648637623, 0.7234176564350218, 0.7216553364324736, 0.6975359609546219, 0.7113785468369483, 0.6684797103622493, 0.5172072329570604, 0.46050766031127954, 0.5016206705198304, 0.5074390859649447, 0.512276829976974, 0.5228178453472769, 0.4689549025159284, 0.5262509982643344, 0.5315048650861443, 0.10212333145531505, 0.10240646181818935, 0.10546004760523231, 0.10900649455345623, 0.11413685379724137, 0.096827359785427, 0.11337791781173023, 0.1266827849914256, 0.1119221471348939, 0.09642843381404254, 0.1116172775463028, 0.09869938771548337, 0.1021754947984237, 0.09616812777630379, 0.09413036145372389, 0.10996344339035735, 0.10514295690358266, 0.09832664822155768, 0.7946424168126771, 0.8080542708528144, 0.8293631557073791, 0.8410280064248373, 0.9216322155424902, 0.7333321363536065, 0.8273785188438258, 0.9090789722580059, 0.8082519694609249, 0.33913100620574677, 0.3313826171886687, 0.34967790297174517, 0.3745812158818814, 0.3207201563834824, 0.3846884061773924, 0.3836214117863287, 0.3938678773903139, 0.3474558208094848, 0.6221495798939102, 0.76022138620615, 0.7354551309983461, 0.7223358026824019, 0.7531948263575704, 0.7646230561468779, 0.7443612290932412, 0.7375755891751457, 0.764920774465745, 0.26262333959600115, 0.15819075935284777, 0.24536024737362405, 0.21678234952617015, 0.30262260094327065, 0.1358472248725302, 0.2330382679788996, 0.33991926969541797, 0.18247248328180798, 0.26045185537155635, 0.17431113159877454, 0.18168571139294354, 0.29128627632174486, 0.29152425848858443, 0.21281306349631157, 0.29149954692239055, 0.32535515315855323, 0.2690135832210976, 0.37064218739523447, 0.33658052878103484, 0.33611408474383775, 0.3976512345891, 0.31461839592379104, 0.3055061246187978, 0.2985970525400161, 0.3676405176740589, 0.2767782682434258, 0.43205589936260624, 0.4705500777077607, 0.5086430828985319, 0.416768656548139, 0.4950404840739471, 0.4121820919582935, 0.5096242573885894, 0.5159834233362965, 0.4779536214014767, 0.10538214485276365, 0.11724355149029142, 0.12144870214775605, 0.23641516077485714, 0.09517465825296645, 0.22918084476768652, 0.11546200817545227, 0.18754619490404134, 0.13833004470952004, 0.24977522359636328, 0.25941559959076, 0.2613042675027347, 0.26559033172557855, 0.279122403748968, 0.264505394016331, 0.27036749405265237, 0.2737665345302799, 0.24882629803978062, 0.6332917455250737, 0.6694201587571988, 0.6218746617323514, 0.6076834484016733, 0.6143282041916716, 0.6511526379388767, 0.6034595596495799, 0.6449131230540327, 0.6520289851132284, 0.09687164873992693, 0.09859867556488755, 0.09577567359978534, 0.09829998228690895, 0.11643582225695315, 0.1208914819066782, 0.1098693422509952, 0.1068489449531882, 0.11098265878794245, 0.14456245857369743, 0.1460287045203601, 0.1625082581144992, 0.14056505368520045, 0.15388042227662824, 0.16441849333428205, 0.1408852448599508, 0.12231189528634911, 0.17859838394691974, 0.38136207160437474, 0.35979965973736894, 0.3559826741164668, 0.3689194726587067, 0.40170449922554385, 0.36670264705275846, 0.3734990493864987, 0.39219701364792103, 0.38627993450575215, 0.315465909710699, 0.3139980713938575, 0.30534638025832395, 0.29053145506127076, 0.29384677599702125, 0.28587769677135844, 0.33961559940475927, 0.3206136583928715, 0.29394367944175526, 0.1815201982879182, 0.2010123983020623, 0.201338986044715, 0.21033701095900437, 0.20499287450320913, 0.19513644560356502, 0.1999430725783945, 0.20493157117143068, 0.20024358109415408, 0.17991750499736825, 0.269380788468188, 0.2082519352610278, 0.20944458446095127, 0.20284235331799805, 0.2199805607962546, 0.22469559479578782, 0.18321640787975157, 0.22163363446665085, 0.19578720586596443, 0.616227262556984, 0.6681965358252128, 0.17955657283418425, 0.18425313231916884, 0.18681689546385982, 0.4271174305545119, 0.5257449895378092, 0.5747829306980052, 0.6162337500072971, 0.7113682468598678, 0.6867871674992924, 0.6859462818506004, 0.5719507730355088, 0.5714314148952511, 0.20459715338364826, 0.6951202718725661, 0.5492393243268646, 0.20620707091239332, 0.17505368030378954, 0.1832921923188534, 0.22073162925688583, 0.18384399231373094, 0.1828908240405117, 0.17955547783078096, 0.20019975289074177, 0.1725786500944616, 0.07865481488623993, 0.0723353207515185, 0.07224749652392015, 0.07771207848636863, 0.07421347352135721, 0.08725016445834355, 0.07532406207935927, 0.08781229846333882, 0.06899572946733423]}, "mutation_prompt": null}
{"id": "cdde0d5d-311d-409c-8952-fab11aab8e8d", "solution": "import numpy as np\n\nclass AdaptiveQuantumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.95\n        self.evaluations = 0\n        self.local_search_rate = 0.15\n        self.global_mutation_prob = 0.2  # Probability of using global mutation\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        if np.random.rand() < self.global_mutation_prob:\n            return self.global_mutation(idx)\n        else:\n            return self.adaptive_mutation(idx)\n\n    def adaptive_mutation(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def global_mutation(self, idx):\n        random_idx = np.random.choice([i for i in range(self.population_size) if i != idx])\n        noise = np.random.normal(0, 0.1, self.dim)  # Larger noise for global mutation\n        mutant_vector = self.population[random_idx] + noise\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "AdaptiveQuantumEvolution", "description": "Adaptive Quantum Evolution with Dual Mutation Strategies for Enhanced Exploration and Convergence Control.", "configspace": "", "generation": 46, "fitness": 0.3243639259432223, "feedback": "The algorithm AdaptiveQuantumEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "167a794e-2fe5-4de2-a090-1f2a6a4637f7", "metadata": {"aucs": [0.6989961437928405, 0.6829067836774694, 0.6965012344516329, 0.6847027941256687, 0.711064409338588, 0.6834103599557537, 0.7152960754581641, 0.6865866940612262, 0.7042297074321147, 0.43991200318383794, 0.3411384448014104, 0.35185459735126023, 0.3965668463956463, 0.41462790062243926, 0.3872434296525453, 0.4315565643167174, 0.37731920474023595, 0.4012564412668158, 0.11708241993655577, 0.1516155845955942, 0.12955275792300947, 0.14734274401846326, 0.11847708308687255, 0.21342216464882868, 0.13648100077375058, 0.14299939624823488, 0.11998843741257892, 0.10347031160220099, 0.10099999087192613, 0.12216002399317627, 0.11764963599910772, 0.1237091655262248, 0.10768733159809851, 0.11584892204980712, 0.12128627200452591, 0.1160106265048384, 0.8575516991531715, 0.8794704020648352, 0.933598150080463, 0.8381981404589932, 0.7720834251368587, 0.7769383604100785, 0.934071001419624, 0.9433507721951123, 0.8436277515699162, 0.33527732590026615, 0.3317946488685911, 0.34912733656575934, 0.32391633169136425, 0.33700723036345503, 0.3533929450554415, 0.3366479610458586, 0.3790897543495412, 0.364795539477368, 0.7022651126323309, 0.705268626023045, 0.7408540607582397, 0.7040437734998533, 0.7201215532749734, 0.6995485733823494, 0.7518764231273263, 0.7364583839066166, 0.7412623150596869, 0.19977582923445625, 0.27132767889242504, 0.15511927267679826, 0.18134264593140548, 0.18249111111205918, 0.1941240064070836, 0.20066175809406273, 0.2666766345055236, 0.2009246445347238, 0.1486771726745335, 0.11670133921740566, 0.30529451812017605, 0.21095842838105905, 0.22377311520058252, 0.1770350080577784, 0.18133704798110062, 0.19295040701584465, 0.1900054908360831, 0.275644788703161, 0.28347881801519226, 0.2865284104035921, 0.3006512330702362, 0.2909228998898923, 0.22636877245132847, 0.34870395788410513, 0.27174838964853965, 0.31186004584648286, 0.370152008428553, 0.3569923085363924, 0.4236993923108271, 0.3913106602421743, 0.44091925257967557, 0.37365173226735415, 0.3938317494332825, 0.4265751815648098, 0.3919033555967676, 0.11979778918263784, 0.12079405077796579, 0.13827968980485872, 0.19263016588231585, 0.12658521638644304, 0.17727332334072765, 0.13174422048521306, 0.12005172187031954, 0.09034323902300367, 0.243240602320293, 0.22263883976879695, 0.22037145655280455, 0.23358088436901825, 0.22601482042630316, 0.23028313512894105, 0.21326216924747132, 0.22400431714115898, 0.2460521321826844, 0.5991848691377161, 0.5877592823258837, 0.5995159939495182, 0.5912083242989152, 0.5728487055046193, 0.5922531967050889, 0.6792025863598341, 0.6135180516159371, 0.6386695258735475, 0.11103271084046884, 0.11277971561983757, 0.11282431568465112, 0.12551028650868756, 0.10097706847240917, 0.11650210016990203, 0.1565513656901517, 0.13641746620106443, 0.11074347709636312, 0.19654702157170034, 0.2717678114700459, 0.2308264136967646, 0.3923909221058308, 0.35526087173768106, 0.28549922597015664, 0.3290869627244728, 0.21354356943334774, 0.3943315823398702, 0.359163970371672, 0.32806781916072136, 0.35181666005101986, 0.36942197681736555, 0.3652068157091223, 0.36970094297941203, 0.38128267794616566, 0.3780869336757676, 0.3466856770107547, 0.29215099208761086, 0.27354620990038603, 0.2915088302395278, 0.28123423028441696, 0.2951988471951559, 0.3279268830564399, 0.3171665912748748, 0.3031246570364209, 0.27739070912392094, 0.1987570946062065, 0.1963341372225058, 0.20713803676922138, 0.2147512862005274, 0.21392407648266043, 0.20183382150455287, 0.23973295915967197, 0.1978340087662559, 0.210506363997932, 0.2100115784472406, 0.2415257587371128, 0.208389847321527, 0.3020577138738654, 0.20243764059882807, 0.21966768385177315, 0.21540000933028314, 0.2032607468652341, 0.1888295906389098, 0.6666475129734076, 0.625026701770332, 0.7151591404042545, 0.7888760725724506, 0.1914287525372793, 0.17142057976403502, 0.18674327633255505, 0.1686831262513977, 0.1760268603468096, 0.7753110238293172, 0.206433416256546, 0.20396408397736832, 0.19730164324456168, 0.19573228402127874, 0.19786385273302953, 0.20197438595574946, 0.1948125393369241, 0.20484995461028688, 0.2054462582026445, 0.18548291924465055, 0.1866637600906208, 0.17857525663578366, 0.18452264853228995, 0.19310749379874437, 0.18237723238955672, 0.17499010901885426, 0.22006071351217082, 0.08987032643765613, 0.0760397312152189, 0.07984024051859018, 0.07644483700136573, 0.07565275180802167, 0.07871776937546615, 0.09133419391772479, 0.08436331489180715, 0.07937809830203657]}, "mutation_prompt": null}
{"id": "3144cc4d-1346-48ce-90c9-9a9583b613fd", "solution": "import numpy as np\n\nclass AdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Slightly higher for more diverse search\n        self.scale_factor_high = 0.8  # Adjusted for balance\n        self.crossover_rate = 0.9  # Optimized crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.1  # Further reduced for balance\n        self.self_adaptive_factor = 0.5  # New parameter for self-adaptation\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        self_adaptive_part = self.self_adaptive_factor * (self.population[a] - self.population[c])\n        mutant_vector += self_adaptive_part\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        dynamic_crossover_rate = self.crossover_rate * (1.0 - (self.evaluations / self.budget))\n        crossover = np.random.rand(self.dim) < dynamic_crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector", "name": "AdaptiveQuantumDE", "description": "Adaptive Quantum-Inspired Differential Evolution with Self-Adaptive Scaling and Dynamic Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 47, "fitness": 0.16580046588178193, "feedback": "The algorithm AdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "167a794e-2fe5-4de2-a090-1f2a6a4637f7", "metadata": {"aucs": [0.3980419166266018, 0.37165396742540246, 0.35468243291518353, 0.4020357568785552, 0.4060519765581645, 0.41171939862170936, 0.37630158949608883, 0.3648913867410901, 0.36819485938042285, 0.15183016559041151, 0.14207863239175966, 0.1402619019117154, 0.13723867669992817, 0.1239309007818239, 0.17661876883366234, 0.16463515212896496, 0.15369293319376864, 0.14326457599580933, 0.08638131650255654, 0.1031958704955801, 0.08835784908164801, 0.10032807752593997, 0.09787376456624419, 0.09762315135959365, 0.08483850142467331, 0.093848702165509, 0.11420710967695957, 0.07101094556215981, 0.0812195534185356, 0.07846402580946055, 0.0810485351176452, 0.08390408471830524, 0.09871916164039574, 0.07725197167422426, 0.08553537754581453, 0.09873085912719526, 0.9448598736748277, 0.97024040430777, 0.9651416843014652, 0.9552501108817697, 0.9770059138169767, 0.9583577222299219, 0.9772250967212329, 0.9813533559763264, 0.9484196269389343, 0.14649998042349033, 0.17011431328593085, 0.14356157599433494, 0.14241746656497922, 0.13142147423138972, 0.12715686340294763, 0.12831021572552492, 0.12846608143581384, 0.12978346941153318, 0.16908927329983525, 0.17828011039160974, 0.1546347374988405, 0.17398949534422736, 0.16749795887631158, 0.19738301268985037, 0.20585530234011762, 0.17852020525390067, 0.15824875813403927, 0.06602677242441823, 0.07557122738843769, 0.07319928693552646, 0.09854486487207503, 0.07304476386548664, 0.08737970685558172, 0.07848989503446391, 0.10118352211254, 0.10292819034175027, 0.09551580544923743, 0.08197771818738642, 0.07964615626875315, 0.07046019494967892, 0.06678219391021756, 0.08867710090464476, 0.02330409295437985, 0.04423236669993491, 0.03387104281125142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030716136978149233, 0.033744216928792814, 0.03999812796225066, 0.05867631445075017, 0.04181684489952586, 0.027215051295379822, 0.044828117867165784, 0.04405828605318729, 0.10108401901057007, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04088782119205592, 0.022412871294086645, 0.029957259290383065, 0.03872258115068039, 0.031832177452535526, 0.03277033438132526, 0.04479152945833631, 0.04261450793631105, 0.04256515517524784, 0.2968857520367796, 0.2922399991798248, 0.2899848910580921, 0.3132967784117928, 0.3188041286533667, 0.31082957740019634, 0.293249565845875, 0.3161688516594283, 0.3069409781787543, 0.08784343507335557, 0.09310900338098926, 0.08201465179087264, 0.061768493305691896, 0.06589425220828671, 0.07013487261745865, 0.06810597453052836, 0.06496288240161174, 0.076261176851537, 0.14211444529924389, 0.18281790672185672, 0.14662964517201238, 0.1646001790463013, 0.15976270519623725, 0.15318915402839306, 0.15022394979021902, 0.13623800121148377, 0.14371135485828523, 0.18411235071485055, 0.1958308659024337, 0.20156278347751944, 0.19486050983147174, 0.1715553243144743, 0.17296654017047441, 0.21235160735248848, 0.21823987539737855, 0.19879403435999377, 0.12494546536291751, 0.11388322028987519, 0.13657203978287524, 0.12687988358372237, 0.1081867988673364, 0.12057850024718786, 0.14379176521675685, 0.14382345312013045, 0.13356101151140543, 0.16641239372398886, 0.15707114058826688, 0.18681670843594134, 0.16884303506870368, 0.15922585404756906, 0.16289170925364327, 0.1671373262117899, 0.1731209900899845, 0.1701451968182046, 0.16319993544076206, 0.1552770383026456, 0.16207950461288434, 0.1632674420953466, 0.17601753156401578, 0.15464125860375044, 0.15393088717083936, 0.16827944443961096, 0.15061394336525846, 0.15333907316043638, 0.1533915818289424, 0.1476811601190302, 0.1677169987976016, 0.1596321208197472, 0.1298285530545763, 0.17352143568098854, 0.15876194603936622, 0.1432853906112952, 0.16650714213037077, 0.16802801083522678, 0.161256532225163, 0.13767533224992234, 0.18147813747909658, 0.13561625097506314, 0.24721107014533528, 0.185581666802763, 0.20218308126925044, 0.17739075642951307, 0.17819031680888997, 0.18715950124641667, 0.1985536693860347, 0.18776266281419018, 0.17815664044056068, 0.17373828807412706, 0.18300092964087544, 0.18880665396021146, 0.05678010786176768, 0.06120113874323796, 0.05828611897910063, 0.059421703558730776, 0.057717468174750874, 0.06337794660320817, 0.06326968595177895, 0.052275390728128146, 0.05579200411432372]}, "mutation_prompt": null}
{"id": "d31f5100-575c-4d36-be3e-ac67aa153511", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.95\n        self.evaluations = 0\n        self.local_search_rate = 0.15\n        self.dynamic_population_resizing = True  # New strategy for resizing population\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector\n\n    def update_population_size(self):\n        # Dynamically resize the population based on evaluations\n        reduction_ratio = 0.9\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(4 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired DE with Dynamic Population Resizing and Enhanced Exploration for Robust Optimization.", "configspace": "", "generation": 48, "fitness": 0.3516049558632304, "feedback": "The algorithm AdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.22.", "error": "", "parent_id": "167a794e-2fe5-4de2-a090-1f2a6a4637f7", "metadata": {"aucs": [0.7151015621268029, 0.7210874895174224, 0.6913122434243576, 0.7415327166994619, 0.7248645088365234, 0.7220470381438276, 0.6983586802901098, 0.7113351302026379, 0.6733185267594363, 0.546813801271713, 0.49955583957565874, 0.5307690288388387, 0.5237017240316366, 0.5310356109734298, 0.5387472225281607, 0.5007668874209347, 0.5506402521507638, 0.5516820834303662, 0.19684944375977342, 0.15200370714504952, 0.11350876899053419, 0.25578766624425175, 0.10384492105917564, 0.16967185441946275, 0.11606964071393666, 0.17875596784046788, 0.1205675094282016, 0.1068016785262158, 0.12496717181173078, 0.1065722545149127, 0.11714645843682359, 0.10825550890032498, 0.10082512547639222, 0.10422286686680693, 0.11372482700238418, 0.10221790478813453, 0.7946424168126771, 0.8080542708528144, 0.8293631557073791, 0.8410280064248373, 0.9216322155424902, 0.7333321363536065, 0.8273785188438258, 0.9090789722580059, 0.8082519694609249, 0.38920482402155676, 0.3425330282532586, 0.37661974579986357, 0.3457465231583523, 0.362837174429649, 0.444583629455681, 0.37612562597540145, 0.3746045363193068, 0.32076481676360813, 0.6221495798939102, 0.76022138620615, 0.7354551309983461, 0.7223358026824019, 0.7531948263575704, 0.7646230561468779, 0.7443612290932412, 0.7375755891751457, 0.764920774465745, 0.20854862440595678, 0.1543961478951027, 0.2347665278569938, 0.19835072443698532, 0.2633337854350649, 0.13243090474003916, 0.20762973159201892, 0.2882767134991765, 0.17137357678680853, 0.20508115198239596, 0.15870561358472046, 0.17208002329974714, 0.26870191396032816, 0.26676721755399757, 0.20098024798800007, 0.2405411945567888, 0.3162272892635001, 0.23293216082158752, 0.42585555148306575, 0.3433119726708245, 0.356189273768615, 0.35921105293082123, 0.32219199978958235, 0.3843276693541573, 0.26511875939440366, 0.3833701006465208, 0.26162823608616304, 0.39720718926112275, 0.452479021941143, 0.4846829812470145, 0.40080400444558006, 0.47921364456868176, 0.36504009195996967, 0.5422603921213773, 0.47649758365899575, 0.437004714198613, 0.09829085025894457, 0.10712613036843321, 0.11820566396019805, 0.22149096575714455, 0.10103386570239514, 0.2658077363115007, 0.11035334802307839, 0.20748131027562133, 0.1533852890315811, 0.24127681581036464, 0.26868427319866006, 0.2713368784210711, 0.28429191812970234, 0.2657610727672711, 0.27738289606937294, 0.2857143585124121, 0.3365111794737793, 0.30986779898994077, 0.6488182237688216, 0.6825385403745631, 0.6066882020323254, 0.5835852117124184, 0.6211670349385208, 0.6106988355878669, 0.6318047817479879, 0.6239383191892888, 0.651293559295177, 0.10598402148931618, 0.10599973129928786, 0.10763654277456225, 0.11218484987908528, 0.1160602077160886, 0.11362533999795355, 0.15246596636069132, 0.11428557390420979, 0.11098265878794245, 0.14075059851588978, 0.18081310262342254, 0.23894063668345467, 0.14711318405411822, 0.23171306476514186, 0.16722367506773828, 0.14252937707280366, 0.14858401402010657, 0.19300073012934638, 0.37944983719352743, 0.3793483106477472, 0.383316316454676, 0.4068559648704664, 0.4233235659628386, 0.39799107004163137, 0.40268557806050176, 0.44159702567646, 0.3896177289859758, 0.30702268857828097, 0.3307119314796235, 0.31920758690608986, 0.3019253235288919, 0.34284526778715174, 0.2910562627295862, 0.35298624338559015, 0.3521674875998152, 0.3579279332058387, 0.17939674838914166, 0.20150596548504762, 0.201338986044715, 0.21033701095900437, 0.20423914636025298, 0.19888200503462317, 0.1987142744035546, 0.20546770353523247, 0.20024358109415408, 0.18059120305300003, 0.3581616225306544, 0.2141145985317996, 0.2027287315234474, 0.19767053276065993, 0.2615199701426282, 0.22475475945162904, 0.18279625774587416, 0.20509798507518284, 0.19578720670464955, 0.6188832352525461, 0.6684985133908872, 0.17955657418486426, 0.1842528825076183, 0.18681689209464858, 0.46428752058034317, 0.5425059868635257, 0.5758622882675731, 0.6168070511181075, 0.7113682468598678, 0.6866918585362771, 0.6858997354785235, 0.5711285335906475, 0.5703537165962456, 0.2045971534183828, 0.6951202718725661, 0.5563232878512794, 0.20390347345890292, 0.1769404168513251, 0.18116427417752934, 0.22073162925688583, 0.18386593514125704, 0.18638668130659453, 0.17955547783078096, 0.20019975289074177, 0.16891085223866953, 0.0804112906765524, 0.07462013598921335, 0.07206488693593693, 0.07771207848636863, 0.07493970870800204, 0.08318616745146279, 0.07634771673396368, 0.08781229846333882, 0.06855084184164772]}, "mutation_prompt": null}
{"id": "4bee8a17-bfab-4957-9d10-4b8c161982df", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.95\n        self.evaluations = 0\n        self.local_search_rate = 0.15\n        self.dynamic_population_resizing = True  # New strategy for resizing population\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if np.random.rand() < 0.5 and func(local_vector) < func(vector):\n            vector = local_vector\n        return vector\n\n    def update_population_size(self):\n        # Dynamically resize the population based on evaluations\n        reduction_ratio = 0.9\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(4 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired DE with Dynamic Population Resizing and Enhanced Exploration for Robust Optimization.", "configspace": "", "generation": 49, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d31f5100-575c-4d36-be3e-ac67aa153511", "metadata": {"aucs": [0.7151015621268029, 0.7210874895174224, 0.6913122434243576, 0.7415327166994619, 0.7248645088365234, 0.7220470381438276, 0.6983586802901098, 0.7113351302026379, 0.6733185267594363, 0.546813801271713, 0.49955583957565874, 0.5307690288388387, 0.5237017240316366, 0.5310356109734298, 0.5387472225281607, 0.5007668874209347, 0.5506402521507638, 0.5516820834303662, 0.19684944375977342, 0.15200370714504952, 0.11350876899053419, 0.25578766624425175, 0.10384492105917564, 0.16967185441946275, 0.11606964071393666, 0.17875596784046788, 0.1205675094282016, 0.1068016785262158, 0.12496717181173078, 0.1065722545149127, 0.11714645843682359, 0.10825550890032498, 0.10082512547639222, 0.10422286686680693, 0.11372482700238418, 0.10221790478813453, 0.7946424168126771, 0.8080542708528144, 0.8293631557073791, 0.8410280064248373, 0.9216322155424902, 0.7333321363536065, 0.8273785188438258, 0.9090789722580059, 0.8082519694609249, 0.38920482402155676, 0.3425330282532586, 0.37661974579986357, 0.3457465231583523, 0.362837174429649, 0.444583629455681, 0.37612562597540145, 0.3746045363193068, 0.32076481676360813, 0.6221495798939102, 0.76022138620615, 0.7354551309983461, 0.7223358026824019, 0.7531948263575704, 0.7646230561468779, 0.7443612290932412, 0.7375755891751457, 0.764920774465745, 0.20854862440595678, 0.1543961478951027, 0.2347665278569938, 0.19835072443698532, 0.2633337854350649, 0.13243090474003916, 0.20762973159201892, 0.2882767134991765, 0.17137357678680853, 0.20508115198239596, 0.15870561358472046, 0.17208002329974714, 0.26870191396032816, 0.26676721755399757, 0.20098024798800007, 0.2405411945567888, 0.3162272892635001, 0.23293216082158752, 0.42585555148306575, 0.3433119726708245, 0.356189273768615, 0.35921105293082123, 0.32219199978958235, 0.3843276693541573, 0.26511875939440366, 0.3833701006465208, 0.26162823608616304, 0.39720718926112275, 0.452479021941143, 0.4846829812470145, 0.40080400444558006, 0.47921364456868176, 0.36504009195996967, 0.5422603921213773, 0.47649758365899575, 0.437004714198613, 0.09829085025894457, 0.10712613036843321, 0.11820566396019805, 0.22149096575714455, 0.10103386570239514, 0.2658077363115007, 0.11035334802307839, 0.20748131027562133, 0.1533852890315811, 0.24127681581036464, 0.26868427319866006, 0.2713368784210711, 0.28429191812970234, 0.2657610727672711, 0.27738289606937294, 0.2857143585124121, 0.3365111794737793, 0.30986779898994077, 0.6488182237688216, 0.6825385403745631, 0.6066882020323254, 0.5835852117124184, 0.6211670349385208, 0.6106988355878669, 0.6318047817479879, 0.6239383191892888, 0.651293559295177, 0.10598402148931618, 0.10599973129928786, 0.10763654277456225, 0.11218484987908528, 0.1160602077160886, 0.11362533999795355, 0.15246596636069132, 0.11428557390420979, 0.11098265878794245, 0.14075059851588978, 0.18081310262342254, 0.23894063668345467, 0.14711318405411822, 0.23171306476514186, 0.16722367506773828, 0.14252937707280366, 0.14858401402010657, 0.19300073012934638, 0.37944983719352743, 0.3793483106477472, 0.383316316454676, 0.4068559648704664, 0.4233235659628386, 0.39799107004163137, 0.40268557806050176, 0.44159702567646, 0.3896177289859758, 0.30702268857828097, 0.3307119314796235, 0.31920758690608986, 0.3019253235288919, 0.34284526778715174, 0.2910562627295862, 0.35298624338559015, 0.3521674875998152, 0.3579279332058387, 0.17939674838914166, 0.20150596548504762, 0.201338986044715, 0.21033701095900437, 0.20423914636025298, 0.19888200503462317, 0.1987142744035546, 0.20546770353523247, 0.20024358109415408, 0.18059120305300003, 0.3581616225306544, 0.2141145985317996, 0.2027287315234474, 0.19767053276065993, 0.2615199701426282, 0.22475475945162904, 0.18279625774587416, 0.20509798507518284, 0.19578720670464955, 0.6188832352525461, 0.6684985133908872, 0.17955657418486426, 0.1842528825076183, 0.18681689209464858, 0.46428752058034317, 0.5425059868635257, 0.5758622882675731, 0.6168070511181075, 0.7113682468598678, 0.6866918585362771, 0.6858997354785235, 0.5711285335906475, 0.5703537165962456, 0.2045971534183828, 0.6951202718725661, 0.5563232878512794, 0.20390347345890292, 0.1769404168513251, 0.18116427417752934, 0.22073162925688583, 0.18386593514125704, 0.18638668130659453, 0.17955547783078096, 0.20019975289074177, 0.16891085223866953, 0.0804112906765524, 0.07462013598921335, 0.07206488693593693, 0.07771207848636863, 0.07493970870800204, 0.08318616745146279, 0.07634771673396368, 0.08781229846333882, 0.06855084184164772]}, "mutation_prompt": null}
{"id": "939d3081-4fb5-497f-92bb-a4a4780d3b1c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.95\n        self.evaluations = 0\n        self.local_search_rate = 0.15\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='Nelder-Mead', tol=1e-3)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.9\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(4 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "HybridQuantumDE", "description": "Hybrid Quantum-Inspired DE with Adaptive Nelder-Mead Local Search for Enhanced Convergence and Robust Optimization.", "configspace": "", "generation": 50, "fitness": 0.3997015836547923, "feedback": "The algorithm HybridQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.30.", "error": "", "parent_id": "d31f5100-575c-4d36-be3e-ac67aa153511", "metadata": {"aucs": [0.8475288389272971, 0.8566545920457505, 0.844054095916013, 0.8511459640188698, 0.8544843593972935, 0.8690462092978796, 0.8517861700552755, 0.8574371669547898, 0.8359519098791306, 0.567769213839356, 0.7283128547751274, 0.5104884173187524, 0.7371144417028118, 0.7544641371440937, 0.5589180720237452, 0.6016088915952965, 0.6587249959025637, 0.6968001144902487, 0.08124808524139604, 0.08390811694390654, 0.10246844694293611, 0.06039224839194268, 0.06339858811609078, 0.0779395209124657, 0.05663694966754507, 0.06890724382924052, 0.056368121515153136, 0.061005642334562626, 0.04088616200603279, 0.01799013810540906, 0.03471711722124804, 0.03468035846780515, 0.04138335960422013, 0.04794539450332558, 0.05467828771762384, 0.04462181567208667, 0.9844318245837316, 0.9869962784297227, 0.9774697737289088, 0.978779135009405, 0.9852262216095482, 0.9885407601660493, 0.9860493779509175, 0.9840186361485932, 0.9870982495746314, 0.2406882154392731, 0.36400075094709305, 0.15363703929206318, 0.22148523861308644, 0.32034496802582013, 0.30592132162511987, 0.13068038502991808, 0.36533271090813857, 0.2103366528533268, 0.37729612861121176, 0.34256643448910906, 0.40988675515113104, 0.3427520173787215, 0.24512072555027253, 0.26465803448449265, 0.48792187342767446, 0.34274980604692495, 0.4196224664850643, 0.7208972542551502, 0.8533299842044964, 0.8196679701770073, 0.7884091331348325, 0.8008660846781461, 0.8245826150498019, 0.7780943340175943, 0.8131462250824808, 0.7706322768830259, 0.8392429075811678, 0.6531325715693144, 0.7701702392689975, 0.7731011530674379, 0.8499961662137181, 0.8455975405686932, 0.8245552597654676, 0.7837562004080036, 0.8365616703113278, 0.6088871992912812, 0.7716078838192764, 0.17077909528209367, 0.322091668787571, 0.5961447176989954, 0.47128562806886387, 0.5317112244048159, 0.6903695869465812, 0.6502038075702151, 0.20249008625955434, 0.26819061287463397, 0.21365406774290363, 0.23799186057364252, 0.14293581464091332, 0.19924848165389708, 0.30041998705546247, 0.22549303381996266, 0.2678366251403529, 0.2632702393617087, 0.2282003634030707, 0.298768817238071, 0.3240724015319202, 0.306251951855417, 0.6710750134350603, 0.23023640270599854, 0.22960544407770633, 0.19077360983510894, 0.36326988846188213, 0.3801197991952102, 0.4426806150596352, 0.3966661045077745, 0.39346907323616165, 0.4999793300489094, 0.4121426378583076, 0.47687526474841857, 0.5440068389650861, 0.8532906898973674, 0.8452095511157944, 0.8520183211056305, 0.8223461464847135, 0.8541349848978425, 0.8382439820730572, 0.9085194998655793, 0.8155943438533282, 0.7821620133195484, 0.17355752098912547, 0.09067982996691748, 0.0624502643660364, 0.07783950974059639, 0.05777041244444592, 0.07055090846258061, 0.06726036188826678, 0.0627371990359632, 0.05240321857625785, 0.14228951721478245, 0.1397338204334807, 0.20842940477178606, 0.2166690638775276, 0.15448608830306187, 0.12629786113318586, 0.14168657500732684, 0.14882002021811624, 0.13884397111132007, 0.1481598317724454, 0.15082597920495522, 0.18365230363112683, 0.1520569585077557, 0.14372834456008055, 0.1464677848589636, 0.18052334113480795, 0.18252173505688873, 0.1723888904053088, 0.08989422446647932, 0.09861446825509301, 0.12775636914236366, 0.10919376147183268, 0.08627620718135853, 0.10772929030532341, 0.11173075416231881, 0.12563315020333377, 0.10941977936579839, 0.17068388959727832, 0.23414747609160924, 0.19474626306301912, 0.23644053773609464, 0.22531783669476146, 0.24232723449391802, 0.2046832389241764, 0.18488788368924602, 0.2316720381317776, 0.21506485004335152, 0.20552843754319305, 0.1997186956784477, 0.21689820795348502, 0.5136638970229901, 0.20824624784089396, 0.18950373579380075, 0.2240315027210419, 0.2171091853179684, 0.19317726050985107, 0.4457018342685469, 0.1844302077154999, 0.8595066165433056, 0.18918693741172377, 0.7932679555397792, 0.5436168444402041, 0.1694321690114452, 0.5230282567327222, 0.8982381650511566, 0.666439989489847, 0.9662426697916805, 0.8299832441507206, 0.38227745757163745, 0.9676574220446972, 0.7665094964972475, 0.6294944024613225, 0.1753345205943817, 0.25656054358108227, 0.24292829798036697, 0.2448094816071792, 0.27258666027545564, 0.28246909699656575, 0.25490420239457157, 0.30342152676347456, 0.3266388691033718, 0.2870856993325157, 0.0676117778392954, 0.08717653092672772, 0.08343974688917732, 0.06075748125521263, 0.06215326977898239, 0.08198158303947167, 0.05032748253264652, 0.08863361055551433, 0.06963875915046625]}, "mutation_prompt": null}
{"id": "1b57f51b-3faa-4e4b-9d5a-72647ef43392", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.2\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.075, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='Nelder-Mead', tol=1e-4)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedDE", "description": "Quantum-Inspired Differential Evolution enhanced with Dynamic Scaling and Adaptive Local Search for improved black box function optimization.", "configspace": "", "generation": 51, "fitness": 0.4248052200111809, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.34.", "error": "", "parent_id": "939d3081-4fb5-497f-92bb-a4a4780d3b1c", "metadata": {"aucs": [0.9495394783163501, 0.972740972222281, 0.973041331144078, 0.9408091122341855, 0.974542312438862, 0.9740310527741208, 0.967077233350422, 0.9748304953981263, 0.9443928766359586, 0.9018955706824294, 0.8900361238731729, 0.7806394938066485, 0.7694311621467331, 0.9201297098826332, 0.8793103103891137, 0.6578571825980755, 0.6199954910213361, 0.7947681494838579, 0.06291921000229173, 0.041404452022004046, 0.06115580535559606, 0.05575767643259821, 0.051422347261594226, 0.09559458346562366, 0.07275652338545935, 0.09005640886701172, 0.03999558307277806, 0.033016001836010944, 0.045848504309485505, 0.05187332662511546, 0.0449706924169071, 0.052985567358679875, 0.02061603527591238, 0.026990804070250674, 0.0484349441252836, 0.06129765791078623, 0.9860894286369389, 0.9869962009538424, 0.9753084617497142, 0.9805609899914453, 0.9804357436709498, 0.9891027785844412, 0.9859728209006444, 0.9800294335675213, 0.9865033296372864, 0.1601595447357793, 0.39988243989319394, 0.15518907529459391, 0.30504667471530056, 0.35502096315123577, 0.314183365585041, 0.2626569174609361, 0.2533126680587042, 0.3454000931149388, 0.18630632468996255, 0.19550691710576096, 0.18834078984683467, 0.18893921557962567, 0.25172306037825576, 0.18820481631203834, 0.19494318917581532, 0.24599035957595128, 0.17643805924782718, 0.8676867972452538, 0.8939175029367584, 0.9064308188318861, 0.8679348540908681, 0.9444782681267428, 0.7400989548315425, 0.9192583130829526, 0.9267640149575738, 0.940695491924597, 0.9143096392247256, 0.8730587045350984, 0.8067338619414092, 0.8525564014752995, 0.9317375794847594, 0.79101271462849, 0.8921339545752568, 0.8898836923725502, 0.9262711313793308, 0.6203984645795783, 0.6616173322000474, 0.4702049224927429, 0.8076975739671213, 0.7498994569783679, 0.3047329120260335, 0.866739997787294, 0.370954078362439, 0.33934230133593957, 0.1643676215905825, 0.24574531517810339, 0.2789269027401118, 0.1906168802029906, 0.562234904080875, 0.5186056566616934, 0.31455081706391597, 0.3017391919815856, 0.2972963897686435, 0.37988874058307, 0.3792873953351874, 0.33349077107212777, 0.8042916608075821, 0.6453774459354571, 0.8393628881736719, 0.13041114961403255, 0.34489251367773854, 0.1749590106193062, 0.7090182337499908, 0.3186143193657216, 0.49903055882152203, 0.6928367658751653, 0.48873637310609486, 0.7242278925583183, 0.3221716317712465, 0.47660568667863856, 0.7002883928229763, 0.9424072156411032, 0.950596987283154, 0.9626470644148571, 0.8787094816723595, 0.9422697619017605, 0.9454417856479287, 0.9477618517407478, 0.9520093221195722, 0.9407388343869224, 0.07474041374265294, 0.049991807526528986, 0.07341835917362494, 0.058555087086373026, 0.03900587169868941, 0.12873700656149412, 0.033573314682801225, 0.047425260577365735, 0.027341228168280773, 0.2837292965418282, 0.11255040781935699, 0.21537518655618793, 0.15170818412953013, 0.14482350563068935, 0.11785660907166384, 0.1611945810277995, 0.12299220216767714, 0.15173649592220484, 0.15460586286101496, 0.1470361520176806, 0.16439886124774894, 0.17366276165440975, 0.15742364245190743, 0.13199676955383277, 0.146897681540472, 0.17494455350509708, 0.13123313460778485, 0.08432463079471286, 0.1106776568203377, 0.10535241121915129, 0.08403397101301002, 0.09894704225464446, 0.08903147404292855, 0.10612630771807685, 0.10475225955490075, 0.08940442334990095, 0.2082401071785125, 0.17528280882625624, 0.1603158979606073, 0.1732490974218759, 0.16640806079551929, 0.19281332905480697, 0.16773222302619872, 0.14554841482402903, 0.20709664336769162, 0.21504125128154405, 0.20249299307813473, 0.20362554862065652, 0.20541090331215328, 0.19906894541606435, 0.20461126876285785, 0.2122923716122883, 0.18976844332697573, 0.22000015035866916, 0.17855192840944145, 0.173786347275118, 0.6063329064799892, 0.9132111671376731, 0.19431758354966455, 0.41009054708076986, 0.16490506309260655, 0.7576577116198672, 0.4727681978837437, 0.9102439759417209, 0.8009553558448858, 0.9666354483677011, 0.8062263670489822, 0.20698507342612527, 0.971128208683925, 0.3052486797643009, 0.15213619040639115, 0.4442293750854662, 0.2715973795207598, 0.23562821080579155, 0.27083672247412827, 0.2815103148264667, 0.31029528586610444, 0.3190535086326409, 0.2873138181544681, 0.330620954896939, 0.2919472633640905, 0.059448543393974096, 0.08590391092119176, 0.051210803609107236, 0.05890598177375872, 0.07085766061740428, 0.05823638766438888, 0.061465401469997794, 0.05882567147935658, 0.0831417095031648]}, "mutation_prompt": null}
{"id": "aa1608be-86c2-4eaf-bb96-0769333b5e51", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Adjusted local search rate\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.075, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='Nelder-Mead', tol=1e-5)  # Adjusted tolerance for optimization\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.80  # Adjusted reduction ratio\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedDE", "description": "Quantum-Enhanced Differential Evolution with Adaptive Population Strategy and Enhanced Local Search for robust optimization.", "configspace": "", "generation": 52, "fitness": 0.41979411916115006, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.36.", "error": "", "parent_id": "1b57f51b-3faa-4e4b-9d5a-72647ef43392", "metadata": {"aucs": [0.9622133756414873, 0.972740972222281, 0.973041331144078, 0.961592785286644, 0.974542312438862, 0.9740310527741208, 0.967077233350422, 0.9748304953981263, 0.9627488534839738, 0.9313546363340587, 0.8994511306496863, 0.5734470837904049, 0.5435473010590842, 0.9264021183829507, 0.6049294712159394, 0.2908341007784956, 0.6813711313523836, 0.6526955699023262, 0.0426675085861965, 0.04563621325343925, 0.05646797208762677, 0.046859137288131736, 0.04085545334915641, 0.037720000843720514, 0.04844107436945233, 0.09027875455839063, 0.024538106985468988, 0.021766447487349794, 0.028103041703937515, 0.012479529385065358, 0.02432137650388444, 0.025374333426372297, 0.018950775239994777, 0.0281020857438512, 0.013936774754567005, 0.03033397759145373, 0.9860894286369389, 0.9869962009538424, 0.9753084617497142, 0.9805609899914453, 0.9804357436709498, 0.9891027785844412, 0.9859728209006444, 0.9800294335675213, 0.9865033296372864, 0.22740325900215097, 0.3422287502446065, 0.3050748003422047, 0.3037637478217551, 0.21957826091632882, 0.6258667197566701, 0.28962639446395355, 0.10847894704568639, 0.7549277976172138, 0.149567285124513, 0.1525122585807558, 0.1786399747683276, 0.16893164702661811, 0.1694084394827845, 0.15780644125537457, 0.14850718581114686, 0.18657363294374885, 0.1511768865309021, 0.9123435653682732, 0.8939175029367584, 0.9552949671951122, 0.8679348540908681, 0.9444782681267428, 0.9255772515589629, 0.9192583130829526, 0.9267640149575738, 0.9027916858188046, 0.8396387883354475, 0.8679879582081117, 0.8557686077103488, 0.9327846741801584, 0.9324715216939369, 0.7670185513526185, 0.9203294035877734, 0.8898836923725502, 0.9425008686609119, 0.5748553271584689, 0.6047604014997507, 0.5099438644997588, 0.701728723573634, 0.8207534547315312, 0.7573263203236752, 0.5448612745741162, 0.35512751585464997, 0.3493427803867136, 0.19063368419762905, 0.24574531707211966, 0.1966718827363001, 0.144310046834485, 0.48240935158080056, 0.108800451039198, 0.20190344690532136, 0.16991105234853332, 0.11252428789782976, 0.3188095398464724, 0.19231301647170918, 0.330429078541832, 0.6537509852271016, 0.864439903518692, 0.8883926972716315, 0.18993762563930616, 0.6693322897027152, 0.34175763691446004, 0.5261781199099582, 0.5170873795619408, 0.37532917760031437, 0.6114436328071824, 0.42470445230606924, 0.8897236378628349, 0.576713894325517, 0.842385998314204, 0.7208847809903751, 0.9436814687886793, 0.950596987283154, 0.9626470644148571, 0.959709788409792, 0.9422697619017605, 0.9454417856479287, 0.9415932643558366, 0.9591608033268847, 0.9547636733781634, 0.047497238476655546, 0.046515104896242554, 0.051530673639383684, 0.04589661751162877, 0.08142339747720884, 0.06242332751123536, 0.03194414044368987, 0.05122614112245305, 0.039440821050849784, 0.16281123845849566, 0.12198368649862146, 0.12691575636038088, 0.13766266535167793, 0.15394468620118917, 0.1202386156838362, 0.1271876798935908, 0.1723822529332294, 0.15960284729766172, 0.1307920806476457, 0.13783640448814372, 0.1613932299901244, 0.14707037797302214, 0.14126208204541113, 0.13969670017204228, 0.1580657310214756, 0.17377774300845283, 0.13787877551445527, 0.08818960572092716, 0.09110185601007181, 0.08398582550377798, 0.1137086711876173, 0.09837087699891978, 0.07553443709260377, 0.09302375484548342, 0.10804516206711745, 0.0916025032422021, 0.19202136211506338, 0.1562058517631384, 0.1735236683992325, 0.21177969882951808, 0.15748908444478527, 0.14980183211435671, 0.17109306751050712, 0.13225697113605261, 0.1759263691163402, 0.21287889643496105, 0.20783849940521248, 0.18809982684329063, 0.2214419521499128, 0.2079194752291179, 0.21782371062642958, 0.20718166247322367, 0.21074605652929157, 0.1935775714347867, 0.17082165791966508, 0.192952474108261, 0.15791921476102067, 0.17211375254654815, 0.20613539394852942, 0.8403377615875692, 0.8968495583131414, 0.8474887367432482, 0.5821703631365551, 0.9016527495019958, 0.7788012765351398, 0.8332620741778326, 0.2068782431045011, 0.20620291518814893, 0.971128208683925, 0.9442060124637084, 0.7013092281352655, 0.1606922018340483, 0.2370468873650462, 0.31200979910213467, 0.24489172689782712, 0.2691258369726709, 0.2436729811922279, 0.2579723045109621, 0.2655644660576615, 0.29355226861065353, 0.23263675196629197, 0.04917917316335185, 0.03794487042242323, 0.048972977989001576, 0.057902783255239454, 0.08615106670431139, 0.03900087353244586, 0.06722931371368235, 0.06832426879744147, 0.077274049410477]}, "mutation_prompt": null}
{"id": "b4e55aaa-0bfb-47f7-8c63-948b5f8206e7", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.9  # Adjusted high scale factor for better exploration\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Increased local search rate for better exploitation\n        self.dynamic_population_resizing = True\n        self.chaotic_sequence = self.init_chaotic_sequence()  # Introduced chaotic sequence\n\n    def init_chaotic_sequence(self):\n        # Create a logistic map chaotic sequence\n        chaos = np.zeros(self.budget)\n        x = 0.7\n        for i in range(self.budget):\n            x = 4.0 * x * (1.0 - x)\n            chaos[i] = x\n        return chaos\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = self.scale_factor_high * self.chaotic_sequence[self.evaluations % self.budget]\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.075, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='Nelder-Mead', tol=1e-4)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Exploration through Chaos Theory and Adaptive Parameter Control for robust black box optimization.", "configspace": "", "generation": 53, "fitness": 0.4197366983302353, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.35.", "error": "", "parent_id": "1b57f51b-3faa-4e4b-9d5a-72647ef43392", "metadata": {"aucs": [0.9618296632516661, 0.9684017926251769, 0.9563161842574598, 0.9436958976395352, 0.9706140724452467, 0.9718784190543626, 0.9498925735194452, 0.9625466270845457, 0.9619084257325453, 0.4761937460018474, 0.6290027714685615, 0.7298830807604784, 0.8168101982078161, 0.5940829918438173, 0.6776906211161173, 0.8012472832203803, 0.25723332803472854, 0.7087242827401867, 0.06084474313280319, 0.04400610602548494, 0.03259089000913895, 0.05072338672164223, 0.047069062574462084, 0.051680535377482406, 0.038017942649932635, 0.050305723350407616, 0.048544773944126374, 0.018658868963484898, 0.046241183214824955, 0.0343037488415221, 0.07998945147280778, 0.0274854063193829, 0.01763592944867365, 0.0730241667123992, 0.08486293395685751, 0.024236575498969293, 0.9851658583341661, 0.9825561335266607, 0.9740256808102042, 0.9843449244185715, 0.9432825820879842, 0.9864964587736516, 0.9618190766419314, 0.9197494061370127, 0.9830722758043942, 0.3363690546661444, 0.2848792742165368, 0.22515255390786892, 0.5022896009848454, 0.45850582768337145, 0.15460981531970852, 0.3201746312216993, 0.2582072674947531, 0.345368429046772, 0.18822200257983246, 0.170846984501406, 0.13540598418383776, 0.1515392291930957, 0.19104519295453237, 0.16986426826717815, 0.16597240902950328, 0.17089796734953067, 0.17012465101009744, 0.9376913959273101, 0.9285214458973418, 0.9238003334348407, 0.9306280164874665, 0.8772691657536101, 0.9265311369667797, 0.930845764258086, 0.926472875158729, 0.8129454967707459, 0.9320695718963383, 0.9386503522814952, 0.7102953440916975, 0.8401499199138487, 0.8657915993211488, 0.9147418225657611, 0.8399894768760792, 0.8512147778227243, 0.8892257757112203, 0.7666231650051147, 0.6018953582750401, 0.8738683655842995, 0.3997723385659272, 0.5106914714521578, 0.3093748811358128, 0.715054041254579, 0.7414114906486073, 0.7804378118052744, 0.20081809463371214, 0.3486401767587175, 0.24342681046663683, 0.10875692014958094, 0.09860226114021531, 0.2340393624251904, 0.2920193913654532, 0.13867448820954964, 0.19216683055230566, 0.39247439329653067, 0.22310470751832412, 0.2964084223092629, 0.6805389364601924, 0.8162302573124053, 0.5150925756969784, 0.19609164910251442, 0.1886964065837312, 0.21080529662505743, 0.4012784618246378, 0.7749879757706934, 0.646355206755791, 0.5752787457734712, 0.7005677847787348, 0.600782748375233, 0.5322904736716741, 0.40785761206757665, 0.7331521179127014, 0.8911547916486465, 0.9487174058614469, 0.9556848453969539, 0.9341585467265486, 0.9426795501567373, 0.9435780380190348, 0.9549516365497419, 0.9335206438884268, 0.9357126467232288, 0.03666723699155938, 0.048532321446396076, 0.05751245934916882, 0.06845306401510642, 0.058648227613576465, 0.07770357962566299, 0.04762058068334463, 0.05266729714037521, 0.06358553814764889, 0.13093665538453825, 0.14198506737739136, 0.14169796618876385, 0.15009210948397012, 0.16773117082460975, 0.15003259310332084, 0.1513252617435914, 0.1548162651000461, 0.1259554140109045, 0.1380124056083929, 0.12788848806694808, 0.1656209889719903, 0.1428568705335943, 0.13524773422790382, 0.13530542810420032, 0.1493588957325317, 0.17969800973780403, 0.15434727957564354, 0.07626136548343332, 0.07463476681802694, 0.08496749653838254, 0.10109210352343012, 0.08312943606486423, 0.08994667782205035, 0.11672037486887332, 0.10000776941021117, 0.08482544462025887, 0.1711261123755976, 0.16355338648425277, 0.20972978719553304, 0.17369749704829596, 0.14122615457975718, 0.1958657735941709, 0.1523808176653496, 0.15411578842507134, 0.24667800574002463, 0.21445837362399156, 0.19219914901491542, 0.21048062832515524, 0.20450272350378185, 0.20063864696795908, 0.20327579469380785, 0.1961160412260634, 0.19282284439659625, 0.19847759582469415, 0.21355881010133004, 0.1702810788525254, 0.18581800465210319, 0.948332287287465, 0.9564904793869563, 0.6690316250940616, 0.1708754626805108, 0.15788805730391164, 0.4924147486107989, 0.9442729632134005, 0.9390938388703663, 0.9064887037087882, 0.9462234764211911, 0.9534336593488171, 0.9239526369442763, 0.1833679808748837, 0.483180447103399, 0.8608138279137967, 0.22498133080548122, 0.25121214458141483, 0.2517960455012035, 0.3437671288641344, 0.2826597684629826, 0.28653247259943015, 0.2524173492151194, 0.2914337824196559, 0.2813484036943861, 0.06795874392098145, 0.060644070327783406, 0.0561633405798555, 0.06036585873778899, 0.06504154713389909, 0.05867421500986458, 0.04726432907525413, 0.06518070238597429, 0.0695177182902118]}, "mutation_prompt": null}
{"id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "AdaptiveMemeticQuantumDE", "description": "Adaptive Memetic Quantum DE combining Quantum-Inspired DE with Adaptive Learning Memes for enhanced exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.5350933185036681, "feedback": "The algorithm AdaptiveMemeticQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.37.", "error": "", "parent_id": "1b57f51b-3faa-4e4b-9d5a-72647ef43392", "metadata": {"aucs": [0.9924670422390527, 0.9915408782662392, 0.992452591997489, 0.992382036906779, 0.9901573909424434, 0.9924124619680466, 0.9923103538515763, 0.987857679233041, 0.9922949230229235, 0.9705042938951913, 0.9794031764515592, 0.9674087610443713, 0.979203185450062, 0.9783932638440251, 0.9777238171595642, 0.9517336008474909, 0.9781286253373136, 0.976687645313368, 0.0548983631915988, 0.11638628817580032, 0.05927908991276287, 0.05806523572463318, 0.056841899386782635, 0.046598031988475896, 0.07086382006817471, 0.05842282201910276, 0.04337670435027574, 0.05869391356978615, 0.03318092192251132, 0.03351324203265593, 0.03217429631455637, 0.050679790247966205, 0.059267364629036146, 0.03248177774814798, 0.0442598257811635, 0.06731436048759354, 0.9902206376455807, 0.9901601100628397, 0.9890534743121823, 0.9885387726093946, 0.9897501560265013, 0.9863029879769701, 0.9880544121868204, 0.9897189779923079, 0.9909668921224063, 0.8320156622589263, 0.8985474641847394, 0.8120382224404042, 0.7024486542893135, 0.919210311735522, 0.7841409989570889, 0.7824008956048456, 0.8231360320930736, 0.790201769993434, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.9152171608503382, 0.954753008377771, 0.8814625306595233, 0.9519356084159577, 0.9461489013513299, 0.9477498029651522, 0.944980808916221, 0.8995067505582149, 0.9684448344323958, 0.961151971406983, 0.9541024127626765, 0.9331115809206902, 0.9628124382417353, 0.9389265910146264, 0.9556271927981393, 0.9675300764200093, 0.9547854068832504, 0.9550489307325515, 0.8088778185214008, 0.7650525538386473, 0.903338676216281, 0.8262641829018775, 0.822911165157705, 0.7981679156551558, 0.7585863167258964, 0.7844928444312685, 0.8801867752298695, 0.7159516486033592, 0.8105831419227991, 0.7421679505298693, 0.8056827567255608, 0.7858780860211418, 0.7342526709945958, 0.8045206568550833, 0.8201744110133983, 0.8200476351492714, 0.7372486412505779, 0.8629753830376348, 0.7912471077888036, 0.7234395994340095, 0.7319910375683505, 0.8091279756042709, 0.5474639542021817, 0.7272920006301427, 0.5897602846660941, 0.5221962775343001, 0.5290628900350594, 0.501407039135128, 0.5442094361273901, 0.54873826743215, 0.5966813535595021, 0.6595011257749013, 0.6448991818202043, 0.6665524321573657, 0.8045191045482666, 0.80890447346724, 0.865915454478525, 0.8071539292211016, 0.7593415285196478, 0.854177078409461, 0.8339398225203464, 0.8040828795163534, 0.83105990602326, 0.09551239279046952, 0.06291346760303362, 0.06856871362184469, 0.050246750020063846, 0.06072250489711495, 0.08857902072343005, 0.05962070090669891, 0.049123442014367136, 0.06441195581762726, 0.09042177290678532, 0.09206000817259863, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10676391538461272, 0.12390635109438808, 0.15870336382753591, 0.14895822825701255, 0.1676473416316694, 0.16759651544860388, 0.15124549708500568, 0.19001291616893068, 0.18298477708973915, 0.18381414793216555, 0.1732930986214014, 0.07512446329586187, 0.06385716305502576, 0.09851590353290773, 0.0853711217825992, 0.08599191181922416, 0.10669186410163434, 0.10344340969851351, 0.10524503704596677, 0.09524283671068556, 0.18625144806273985, 0.14425346195952005, 0.17246198286137182, 0.26724366798813837, 0.16129054987826763, 0.1848001237676724, 0.1672407481970648, 0.1745269941610269, 0.2049960056766169, 0.21941417003172625, 0.21296879153416126, 0.2257605108478079, 0.22792274363614073, 0.2453798803534133, 0.22816230242583502, 0.20408771393039393, 0.9692799791896981, 0.2265709025986734, 0.7964094260525704, 0.9073557378175009, 0.9821218170480415, 0.9616324994512985, 0.9634796540901283, 0.8916953834755309, 0.9467016778459812, 0.8033558432680256, 0.8512643604698018, 0.9498378972515099, 0.841958429484871, 0.8466493015344532, 0.8231105115564934, 0.8937738115673081, 0.9100092355203836, 0.3504282340657978, 0.8171566292233908, 0.8468163691417774, 0.16355557610037774, 0.16383073639321355, 0.16409177618796034, 0.16827988847869113, 0.1772513192612456, 0.18056258921994717, 0.150639854419077, 0.16672125459066833, 0.1591067270831802, 0.07220832775248032, 0.0748063688967282, 0.05524457693118834, 0.07991122017258989, 0.07594805563031604, 0.07760387768544474, 0.053741832098799236, 0.0702787778017786, 0.0620010760286277]}, "mutation_prompt": null}
{"id": "87e2f065-f49c-44cc-a798-0e476b556738", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "AdaptiveMemeticQuantumDE", "description": "Adaptive Memetic Quantum DE combining Quantum-Inspired DE with Adaptive Learning Memes for enhanced exploration and exploitation balance.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924670422390527, 0.9915408782662392, 0.992452591997489, 0.992382036906779, 0.9901573909424434, 0.9924124619680466, 0.9923103538515763, 0.987857679233041, 0.9922949230229235, 0.9705042938951913, 0.9794031764515592, 0.9674087610443713, 0.979203185450062, 0.9783932638440251, 0.9777238171595642, 0.9517336008474909, 0.9781286253373136, 0.976687645313368, 0.0548983631915988, 0.11638628817580032, 0.05927908991276287, 0.05806523572463318, 0.056841899386782635, 0.046598031988475896, 0.07086382006817471, 0.05842282201910276, 0.04337670435027574, 0.05869391356978615, 0.03318092192251132, 0.03351324203265593, 0.03217429631455637, 0.050679790247966205, 0.059267364629036146, 0.03248177774814798, 0.0442598257811635, 0.06731436048759354, 0.9902206376455807, 0.9901601100628397, 0.9890534743121823, 0.9885387726093946, 0.9897501560265013, 0.9863029879769701, 0.9880544121868204, 0.9897189779923079, 0.9909668921224063, 0.8320156622589263, 0.8985474641847394, 0.8120382224404042, 0.7024486542893135, 0.919210311735522, 0.7841409989570889, 0.7824008956048456, 0.8231360320930736, 0.790201769993434, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.9152171608503382, 0.954753008377771, 0.8814625306595233, 0.9519356084159577, 0.9461489013513299, 0.9477498029651522, 0.944980808916221, 0.8995067505582149, 0.9684448344323958, 0.961151971406983, 0.9541024127626765, 0.9331115809206902, 0.9628124382417353, 0.9389265910146264, 0.9556271927981393, 0.9675300764200093, 0.9547854068832504, 0.9550489307325515, 0.8088778185214008, 0.7650525538386473, 0.903338676216281, 0.8262641829018775, 0.822911165157705, 0.7981679156551558, 0.7585863167258964, 0.7844928444312685, 0.8801867752298695, 0.7159516486033592, 0.8105831419227991, 0.7421679505298693, 0.8056827567255608, 0.7858780860211418, 0.7342526709945958, 0.8045206568550833, 0.8201744110133983, 0.8200476351492714, 0.7372486412505779, 0.8629753830376348, 0.7912471077888036, 0.7234395994340095, 0.7319910375683505, 0.8091279756042709, 0.5474639542021817, 0.7272920006301427, 0.5897602846660941, 0.5221962775343001, 0.5290628900350594, 0.501407039135128, 0.5442094361273901, 0.54873826743215, 0.5966813535595021, 0.6595011257749013, 0.6448991818202043, 0.6665524321573657, 0.8045191045482666, 0.80890447346724, 0.865915454478525, 0.8071539292211016, 0.7593415285196478, 0.854177078409461, 0.8339398225203464, 0.8040828795163534, 0.83105990602326, 0.09551239279046952, 0.06291346760303362, 0.06856871362184469, 0.050246750020063846, 0.06072250489711495, 0.08857902072343005, 0.05962070090669891, 0.049123442014367136, 0.06441195581762726, 0.09042177290678532, 0.09206000817259863, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10676391538461272, 0.12390635109438808, 0.15870336382753591, 0.14895822825701255, 0.1676473416316694, 0.16759651544860388, 0.15124549708500568, 0.19001291616893068, 0.18298477708973915, 0.18381414793216555, 0.1732930986214014, 0.07512446329586187, 0.06385716305502576, 0.09851590353290773, 0.0853711217825992, 0.08599191181922416, 0.10669186410163434, 0.10344340969851351, 0.10524503704596677, 0.09524283671068556, 0.18625144806273985, 0.14425346195952005, 0.17246198286137182, 0.26724366798813837, 0.16129054987826763, 0.1848001237676724, 0.1672407481970648, 0.1745269941610269, 0.2049960056766169, 0.21941417003172625, 0.21296879153416126, 0.2257605108478079, 0.22792274363614073, 0.2453798803534133, 0.22816230242583502, 0.20408771393039393, 0.9692799791896981, 0.2265709025986734, 0.7964094260525704, 0.9073557378175009, 0.9821218170480415, 0.9616324994512985, 0.9634796540901283, 0.8916953834755309, 0.9467016778459812, 0.8033558432680256, 0.8512643604698018, 0.9498378972515099, 0.841958429484871, 0.8466493015344532, 0.8231105115564934, 0.8937738115673081, 0.9100092355203836, 0.3504282340657978, 0.8171566292233908, 0.8468163691417774, 0.16355557610037774, 0.16383073639321355, 0.16409177618796034, 0.16827988847869113, 0.1772513192612456, 0.18056258921994717, 0.150639854419077, 0.16672125459066833, 0.1591067270831802, 0.07220832775248032, 0.0748063688967282, 0.05524457693118834, 0.07991122017258989, 0.07594805563031604, 0.07760387768544474, 0.053741832098799236, 0.0702787778017786, 0.0620010760286277]}, "mutation_prompt": null}
{"id": "9266a695-f932-4c7e-a164-448f30d2df5a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedQuantumSelfAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.65:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "EnhancedQuantumSelfAdaptiveDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Self-Adaptive Mechanisms for Robust Global Optimization.", "configspace": "", "generation": 56, "fitness": 0.526687117833216, "feedback": "The algorithm EnhancedQuantumSelfAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922941142439609, 0.9922213325101477, 0.9924524714468377, 0.9926426286203045, 0.9922883137837315, 0.9924124619680466, 0.9925803880410802, 0.9922437407580005, 0.9922612612615166, 0.9771879885486553, 0.9677163547189506, 0.9761542814328104, 0.9700117970673633, 0.9607583013078455, 0.9806648673714912, 0.9468135997714994, 0.9710338940175304, 0.9643246235310645, 0.05605891462441892, 0.06230101028334778, 0.06502556914834767, 0.05660146990479875, 0.035283305723489145, 0.03776008620571081, 0.03403112454339441, 0.04822918104035778, 0.05905627103558453, 0.046876751457068155, 0.013158442572137163, 0.03673415984276396, 0.061790234860936266, 0.018820598305210434, 0.04996009797376211, 0.028609531853848402, 0.028239659694434538, 0.025909621276751893, 0.991755238774952, 0.9908936988523132, 0.9890286855982657, 0.9912870831022323, 0.9909400608494169, 0.9888223284275202, 0.9903075906631815, 0.9904760163536129, 0.9909666202810333, 0.8616792968623308, 0.8113552348925188, 0.8285713219918113, 0.8405348179051473, 0.9128075443952193, 0.92629648220406, 0.8219399543379116, 0.7794000847448741, 0.8875076675327855, 0.4386723477097616, 0.5112524063514414, 0.3523963011109411, 0.5777531490422598, 0.4889827696268989, 0.5105047259595434, 0.38237809371451414, 0.43046923778305235, 0.42750826491400096, 0.9457967213557497, 0.9047569550862403, 0.9184420874063706, 0.943974471288629, 0.9665611268360683, 0.9490858015945298, 0.9605102955859893, 0.8319388354086048, 0.9703582125602274, 0.9626584470090025, 0.9602027244760113, 0.9427880464377519, 0.9465693537324813, 0.9418918258444862, 0.9538835185252209, 0.9626358057756954, 0.9429822889278869, 0.9596423204973734, 0.817761841200924, 0.8197377606461949, 0.8497887679564721, 0.8461353399220403, 0.8842191690964365, 0.9366345490853738, 0.871315983977235, 0.8240497530281734, 0.8792687408583317, 0.8192930312000272, 0.797338022954508, 0.8386455375159099, 0.8054204015225702, 0.8549116805634854, 0.7673345906244362, 0.750310619322818, 0.7690769687091329, 0.7819229301591325, 0.8453192978480759, 0.8921697289459322, 0.7861642169111706, 0.7342958978735263, 0.8566456855680515, 0.8222884052637511, 0.5215961540703205, 0.5284301999244971, 0.6329819408962012, 0.5144431307700397, 0.49049787847428683, 0.5016565890659448, 0.6027299968141757, 0.547112619360292, 0.5526276900680045, 0.7048077537294817, 0.7136537902004505, 0.6690471898452724, 0.8769650156882128, 0.8241700303817605, 0.8130249384390318, 0.7964193446825294, 0.8065253885393846, 0.7940575120802634, 0.8327814781302176, 0.8163911053576365, 0.8240495037632413, 0.03598888132009548, 0.035033078033524734, 0.059545383719986744, 0.06333428195347501, 0.045288153298207234, 0.05396770858472644, 0.049254050039418296, 0.05591645644436416, 0.07216956374363803, 0.10360217193875465, 0.09093393637771663, 0.12273773163118673, 0.13766266535167793, 0.1115181701561403, 0.12679906972400368, 0.09703210599819412, 0.10463729166974267, 0.09494711318846005, 0.1567946827621276, 0.1447040400921269, 0.17346655123179167, 0.17214168720628786, 0.15303870640732697, 0.16841676816796824, 0.16151304542116618, 0.17401158669989714, 0.17196705561183934, 0.09481410101194143, 0.07759909430469358, 0.0945216298055882, 0.07116219889767383, 0.08922152168483044, 0.08194610030997496, 0.09909677886704049, 0.10579960878206418, 0.08779788235108843, 0.15017064699504756, 0.17346734112603535, 0.19872401430484476, 0.16264323176948525, 0.16890303658367833, 0.15308643912559405, 0.1829902007032399, 0.121258711876437, 0.18543091794898958, 0.19752463984491442, 0.22022201458168533, 0.18774768214608817, 0.3969177539283606, 0.22996885879102402, 0.20386883274855472, 0.7512611708792145, 0.2961771534236659, 0.2271375671688436, 0.32488774795067876, 0.9620428262190411, 0.9210050690440038, 0.5717711551878348, 0.6817521629999604, 0.8458548264944021, 0.7305191149382106, 0.7563084931778367, 0.8120957182336476, 0.7403488562385587, 0.8532526379374957, 0.8339833545743188, 0.5563142506240437, 0.9741819238115684, 0.4811055713423137, 0.6579945509818146, 0.7435676255235601, 0.9011019298913641, 0.17802613078837715, 0.15049144574503792, 0.18614910101403181, 0.18543845241376722, 0.1708427443360384, 0.15094546702145561, 0.1802893815604384, 0.19645770427276477, 0.1899057126308824, 0.059349427720908565, 0.06602803297412607, 0.078851332749307, 0.0729397917993223, 0.06327567591348293, 0.07714767263218036, 0.05278423876950333, 0.05976175571339848, 0.05807201790248162]}, "mutation_prompt": null}
{"id": "b96d494f-07b4-43de-b3bf-ca8aef96def0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.03, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.3:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveMemeticDE", "description": "Quantum-Inspired Adaptive Memetic DE with Dynamic Strategies blending exploration and exploitation using adaptive scaling, crossover, and local search.", "configspace": "", "generation": 57, "fitness": 0.5234023721917699, "feedback": "The algorithm QuantumAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.992313226983031, 0.9936251988811584, 0.9925929520517058, 0.9920206017372296, 0.9935687649990106, 0.992705608534654, 0.9902594907283726, 0.9932820067302975, 0.9636327659033004, 0.9644185678404442, 0.9744152366223686, 0.9699907475215374, 0.9732035517271391, 0.9697715964515631, 0.9703686224597355, 0.969006833706584, 0.9812340525870028, 0.06074863182180956, 0.06992952780237516, 0.05289309800719233, 0.07435685293297667, 0.061550311841836125, 0.09071381516576438, 0.03705418956632023, 0.06083329284131256, 0.04214523126709069, 0.05556002191419995, 0.03859188858511642, 0.04510699253781458, 0.036829305683757196, 0.05920211849171697, 0.047270416043278196, 0.04929509105498586, 0.020960577163751437, 0.04214871792655517, 0.9907002671056918, 0.9918664406621405, 0.9922554739588627, 0.9908000219937653, 0.9929664640243825, 0.992179235079582, 0.9924539206923481, 0.9914059649168903, 0.9921777582550252, 0.8801697509118199, 0.773832692420947, 0.8158737107924318, 0.8706039353509983, 0.8967150977931164, 0.8597167738233085, 0.812844681625342, 0.7957650569570711, 0.7516299891311407, 0.4760831743672077, 0.4529769572891498, 0.5650724709138496, 0.521849957975446, 0.6086426482861436, 0.5004319155277872, 0.4818499918144056, 0.5212081263075792, 0.5269376609709446, 0.9574034121943445, 0.9578698746741017, 0.8721604858329988, 0.9584022446914304, 0.9387549792555127, 0.9472635495520828, 0.9491648995950188, 0.9360925075186706, 0.9669602985619802, 0.9564350758971577, 0.9570101583434765, 0.9705876469710678, 0.9126230067468477, 0.9117290752801497, 0.956460775678282, 0.953363096073527, 0.9015636389315516, 0.9591493759012135, 0.8147728640714124, 0.7744280322244285, 0.7512064323406615, 0.8074743538332815, 0.7487638263901909, 0.8545821399481743, 0.794703971029879, 0.8080381575554572, 0.7341258463799286, 0.7765534808535574, 0.7645558493462885, 0.7276615478221462, 0.7032839568110452, 0.7866333714777668, 0.7992821514248183, 0.7703421016560135, 0.831197517739422, 0.8718774850401412, 0.8656864225478638, 0.8911677422911127, 0.8771633036516373, 0.8536010983049573, 0.7521547005648687, 0.7754238965912602, 0.7915878578802273, 0.7450920468672636, 0.6757642918548648, 0.5067001308247545, 0.5065130075322591, 0.501620801746766, 0.5437353257012979, 0.5550336313740782, 0.5519751906341408, 0.7103182854175014, 0.669401184537155, 0.6228819939444334, 0.8059058852656878, 0.8934821017569718, 0.848976320959222, 0.8399017082960203, 0.8241932243980017, 0.7940259235805681, 0.8237917516449198, 0.842583581949994, 0.8390076377713546, 0.06722334216651615, 0.061643535483869916, 0.08039677132834855, 0.066237996756625, 0.03779397864518508, 0.07013779058570613, 0.061288369619015626, 0.06148895825713385, 0.050299561183691055, 0.09736132814422216, 0.09314803147746009, 0.11842175776965747, 0.10776825379799648, 0.10852972522114013, 0.10798713552628325, 0.11961243902446639, 0.1338533643073031, 0.09355219682204274, 0.14521217942463338, 0.14904248627234395, 0.16968162049380076, 0.14590874553691324, 0.1570847699649186, 0.15933979026204048, 0.16273790587795534, 0.18188123561298164, 0.15222375593490034, 0.08274515143466266, 0.10196936526149769, 0.09434339357866484, 0.08731480300879613, 0.0864588873636376, 0.0798629665866174, 0.0989706239164374, 0.0997711199450243, 0.09251031078131833, 0.22089215738170187, 0.18147549150950737, 0.16112176789230703, 0.25412732165395313, 0.15457223265150655, 0.1395167487577662, 0.21816488429127678, 0.15076932741225524, 0.15947991326043343, 0.2472052083059204, 0.21129002560936905, 0.6549364356002852, 0.2212206640934109, 0.2199020169076754, 0.5842565903678816, 0.21117376764076057, 0.21584707962552385, 0.20575761349456712, 0.7644078140468747, 0.7097554531089034, 0.19548585783755312, 0.9278999761892859, 0.5986164594666481, 0.9360417344037802, 0.7305050137898994, 0.8511347878540992, 0.9052261441371648, 0.9135546719052935, 0.8202286239445227, 0.7623088605602862, 0.8596725580542812, 0.49972056349707106, 0.1979737068144215, 0.4503802096658487, 0.8312351989739061, 0.20959467298397483, 0.16107264821044265, 0.1756949216597744, 0.16059919194296612, 0.1657970942845577, 0.14639152168725433, 0.19029863296858862, 0.1619617424920523, 0.16529616726225815, 0.1861829183567162, 0.062386308928203627, 0.0522075645964476, 0.0592733080452823, 0.05172916551298623, 0.07778796322950454, 0.06127608553167052, 0.07288225506844848, 0.05577541916841888, 0.04503411809457125]}, "mutation_prompt": null}
{"id": "ff89dd6a-172e-49f4-b465-e1a25fce10b5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridQuantumMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly reduced initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2  # Slightly lower scale factor range\n        self.scale_factor_high = 0.8  # Slightly higher scale factor range\n        self.crossover_rate = 0.9  # Slightly higher crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.3  # Slightly increased local search rate\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing and self.evaluations > self.budget * 0.3:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.7  # Slightly different reduction ratio\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "HybridQuantumMemeticDE", "description": "Hybrid Quantum-Inspired Memetic DE leveraging adaptive crossover and dynamic local search for improved optimization efficiency.", "configspace": "", "generation": 58, "fitness": 0.5313063948484439, "feedback": "The algorithm HybridQuantumMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.992313226983031, 0.9936209853613711, 0.9925973820312957, 0.9920206017372296, 0.9935687649990106, 0.9928074083029274, 0.9898698209749234, 0.9931049785368491, 0.9725228771758454, 0.9703398504853166, 0.9742712611490869, 0.978412077733274, 0.9483870311698119, 0.9818738909451553, 0.9722810697673174, 0.9486916544123241, 0.9721191452895914, 0.08712699116235578, 0.0737011263519074, 0.11329436273644566, 0.07585977550646383, 0.10357575324740287, 0.045165839774807814, 0.08333378054125529, 0.046407162520880174, 0.049282627096891685, 0.03351720709136918, 0.014025954950737995, 0.06524707197028401, 0.06435928897611942, 0.07551513728481296, 0.02047501712925004, 0.041615902289443896, 0.02801241502200469, 0.03116871964456147, 0.9907124308901897, 0.9923566124558406, 0.9922418440314246, 0.9908296666343819, 0.992962134488001, 0.9921837478096766, 0.9924581734137127, 0.9914026683815915, 0.9921772096394792, 0.8956061289565576, 0.9171095400535174, 0.8669062714477297, 0.936029665501528, 0.8625749417066605, 0.8925646048782312, 0.8056810933793088, 0.7405192986817446, 0.8453147095126142, 0.5638488646417854, 0.5749156651522225, 0.6919177855103729, 0.6017141334103683, 0.5806771065016271, 0.5743555764876684, 0.5981286811726743, 0.5761755841867582, 0.5704904873795975, 0.9640189383295803, 0.9557521839607137, 0.8555206877582758, 0.9526984933168773, 0.9365576286644492, 0.9503559314763236, 0.9446034349012228, 0.9314837113509143, 0.9665878669968221, 0.9545550264589734, 0.9495047998390236, 0.9637939599137114, 0.9119237356776133, 0.9250320238219067, 0.9520042862454248, 0.9384646251566389, 0.9108756003148297, 0.950536960356446, 0.8029546834956663, 0.8566477067497156, 0.7346779595796692, 0.8737358763907795, 0.9046315012770103, 0.8326612326433869, 0.7778613499427454, 0.8642192758545463, 0.8724792974759707, 0.7253719128534029, 0.8027188418182643, 0.8062127274147504, 0.7334676023242219, 0.7768845738839072, 0.7133551082201693, 0.7902379512293258, 0.8591999127202377, 0.7651880964388085, 0.8742061301533082, 0.6859788254490957, 0.8272661227729385, 0.8326408583237401, 0.7926092815175275, 0.7337780024555751, 0.8123020147698577, 0.7697003340880058, 0.7281710301614195, 0.510428232321761, 0.5047337668046126, 0.5145321737459913, 0.5455241652232454, 0.522576974085817, 0.5563410308694459, 0.6320903285093811, 0.6567300788316307, 0.6073747630244712, 0.8070349235546759, 0.8489459162739733, 0.7858591163938706, 0.8561608826380291, 0.7965691208833412, 0.8043435551784469, 0.8381020701062923, 0.8552777597379607, 0.8248120117233572, 0.057737067052794244, 0.02835427932191792, 0.04781027118088155, 0.08061486844537535, 0.09932064237415472, 0.10083185870248978, 0.05578309442943319, 0.08612371444351596, 0.05770466993683754, 0.08843840630088218, 0.09601110011549974, 0.11842175776965747, 0.10183706931423508, 0.11390915673850754, 0.10798713552628325, 0.08808199726801991, 0.10486638177200724, 0.09055186481662747, 0.15183782089189535, 0.14232070406632846, 0.1623953804129311, 0.18461893986960864, 0.17891374570031204, 0.15756791360740807, 0.17915786386265808, 0.1850359707367798, 0.17143390638399247, 0.08700257444415671, 0.11476858078718943, 0.09139059609016953, 0.08504081754086168, 0.09048073036096571, 0.11026749792113, 0.0913636660468865, 0.1045404308317811, 0.09513012161990975, 0.22740383796398977, 0.15646473811808814, 0.14003079708504707, 0.20190786574107156, 0.1669396519087919, 0.1785497468454028, 0.19059923427276937, 0.19288126466115318, 0.2283720831177415, 0.20103147818849243, 0.1869270506326517, 0.22423632458280085, 0.9150807889565356, 0.3460563654016874, 0.24742983241861238, 0.20973108916496452, 0.7078433748315438, 0.19094521784890683, 0.7935152506784072, 0.960839468911086, 0.6971665011020228, 0.9320833909296934, 0.835016389536945, 0.6684645481803921, 0.45194369233835185, 0.2093827350298313, 0.8429217910612737, 0.707987778459948, 0.8377467320952297, 0.7677354724853543, 0.8458461115113103, 0.7084977838558544, 0.20789682249713104, 0.8585692694400817, 0.6602057563694799, 0.19118593561625308, 0.16441074969083824, 0.18847661264876547, 0.1831812346611399, 0.20241643607046655, 0.18493976880387897, 0.1833789744792833, 0.15348221699436726, 0.1548519828876902, 0.1608878812998693, 0.07053860937676659, 0.04591326484734548, 0.06258440149089639, 0.046950230388441594, 0.05626655640434619, 0.058571837037957986, 0.05338993288406069, 0.07996661390960269, 0.05844556903361209]}, "mutation_prompt": null}
{"id": "9659b6df-aa56-4424-83ce-331686bf50ef", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEAdaptivePerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        mutant_vector += perturbation\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEAdaptivePerturbation", "description": "Quantum-Inspired Memetic DE enhanced with Adaptive Gaussian Perturbation for improved convergence.", "configspace": "", "generation": 59, "fitness": 0.5198310573834382, "feedback": "The algorithm QuantumMemeticDEAdaptivePerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9916476635843997, 0.9922213325101477, 0.9891699457858174, 0.9916002617662022, 0.9914640667233334, 0.9896447931981578, 0.9909962367288686, 0.9917106228127391, 0.9888313377398128, 0.9775039039723888, 0.9748528662587757, 0.9719810998844468, 0.941239467264999, 0.9757468411167864, 0.975963172542041, 0.9724007977560276, 0.9722575687706765, 0.9625087145537389, 0.08316220034465693, 0.0858650416705643, 0.052706336173916846, 0.06785683852692803, 0.05231624086908582, 0.06399401076187916, 0.05433004876052272, 0.06390283562170584, 0.06163477313866628, 0.029037145045530455, 0.08282151396373938, 0.10505725416989464, 0.04109962780405729, 0.031345944112782465, 0.09000219413012178, 0.04783483116376175, 0.04418177284571689, 0.03626823525274525, 0.9883919102698127, 0.9890094306870064, 0.9881645448324003, 0.9889493102480764, 0.9882780925067749, 0.9875194400423145, 0.9901617790988815, 0.989267375758435, 0.9876464895363, 0.8135991719955313, 0.8406485709700654, 0.9129471395221593, 0.8030607009547697, 0.8284680685196171, 0.8550218161755132, 0.8164147585644221, 0.7913642990317289, 0.7540583331346609, 0.2628645824198558, 0.2752091135285205, 0.2903673278121178, 0.33044887209714735, 0.28477018699589207, 0.27131618015727244, 0.26043760565910223, 0.2772278225252196, 0.28622153695105734, 0.9446636692084983, 0.9198922130102127, 0.9546299021606873, 0.9469966443854484, 0.9539184104764135, 0.9722546696652367, 0.9457875295229186, 0.9488852923853163, 0.9461340537235742, 0.9585739311068997, 0.9541729164419335, 0.9522957669996238, 0.9033640727661403, 0.9556614593826008, 0.92035503484807, 0.9282579708396941, 0.9245083649247916, 0.9459316002723297, 0.7503919916151136, 0.7569628473927186, 0.7847428998383992, 0.8365807798092741, 0.9608929366471214, 0.8542441493664973, 0.7707287079834929, 0.8352000406057173, 0.845989086850149, 0.8405413900119774, 0.799066083241962, 0.9230611599375013, 0.7533870643293721, 0.7930559604219568, 0.7052364379712257, 0.7756658180778215, 0.7091592984878778, 0.818412365236542, 0.8196904420393746, 0.7333013120339802, 0.7890336314000339, 0.7614486834071523, 0.7557945798440358, 0.8534610088014349, 0.5910895039894702, 0.6492270731367182, 0.5519382990573352, 0.525384648294512, 0.522273914576419, 0.5112817456483095, 0.5689139479183869, 0.5427342675042803, 0.5602096815039626, 0.6784560201448431, 0.6740486302787538, 0.6145837370275264, 0.8877623327873706, 0.837118550022617, 0.8225995255506967, 0.8120869650505234, 0.7752838554486391, 0.7768650195931885, 0.850562933469962, 0.8252710022205456, 0.8259416601140093, 0.062135559134123275, 0.05626285566160172, 0.06810703617224356, 0.1072836424039646, 0.08128680350143025, 0.07734669823378593, 0.06715660329027273, 0.11143135755525069, 0.07611297556361063, 0.09625174027436734, 0.1162378742131861, 0.12247025679368562, 0.13766266535167793, 0.11355473789204629, 0.13893129895081147, 0.09882653131735386, 0.0866245411531954, 0.09758556448650901, 0.17802575837834356, 0.17558820420781007, 0.1747097151841115, 0.16340431043756598, 0.16540270759961384, 0.176876252804556, 0.17126698910192517, 0.1739686289115231, 0.1611538527098776, 0.08985911533839719, 0.08873894414005135, 0.10392271908459771, 0.10844145814623374, 0.0880021562688813, 0.11892822014537763, 0.0991539466431064, 0.10780237960422123, 0.10472855415266802, 0.18148269329112943, 0.21036578773785464, 0.21569853781258663, 0.1738616004524396, 0.1643070826812233, 0.14789375620284395, 0.14424255173228318, 0.21135176880894824, 0.2143529024823554, 0.23899254905755019, 0.2157191660441483, 0.4836511683643505, 0.2054573959882191, 0.876235985852651, 0.1987303691539034, 0.23100801229542378, 0.22037838238819063, 0.24280438127985804, 0.8295639531138146, 0.49909751740983843, 0.6387832041089145, 0.8229730637324796, 0.8765404360385323, 0.8996540250010312, 0.6430194226627779, 0.7050345506660285, 0.9217904992355814, 0.8854969386586221, 0.8618563101021277, 0.7664408807063134, 0.7581606271545411, 0.20599637080842936, 0.401982076218833, 0.8364951866749324, 0.7839138673031735, 0.9012953518037194, 0.17144300538957613, 0.1662231921717453, 0.17224341568081525, 0.17214178885321685, 0.15857595642748978, 0.1757162874621454, 0.1672036509026269, 0.15272224834582526, 0.15857252912765885, 0.07040741927787297, 0.062614237997903, 0.07451598773892132, 0.09445898631173366, 0.05179750559868712, 0.06529045806605227, 0.05512797300770966, 0.05422977383674876, 0.0873954626627843]}, "mutation_prompt": null}
{"id": "347cd5ca-5089-4bcd-ba42-93de9ea99c78", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumDifferentialEvolutionHybrid:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='L-BFGS-B', bounds=[(self.lower_bound, self.upper_bound)]*self.dim, tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumDifferentialEvolutionHybrid", "description": "Quantum-Inspired Differential Evolution with Hybrid Adaptive Strategies for Global and Local Search Synergy.", "configspace": "", "generation": 60, "fitness": 0.38682871496840576, "feedback": "The algorithm QuantumDifferentialEvolutionHybrid got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.9920827774097912, 0.9926368773735478, 0.9931638120473556, 0.9906820415047202, 0.9929461402900299, 0.993120456420088, 0.9885972986372749, 0.9928201317180967, 0.4205000756072539, 0.3889732608447325, 0.46771248938391896, 0.5953616317502741, 0.48802849388075065, 0.5298738149020397, 0.4931051311778216, 0.5819988162504548, 0.37208499388453453, 0.07344168510464733, 0.10050590522034253, 0.11872280558694892, 0.07629929980394479, 0.0714463509911939, 0.09862455621675559, 0.07118208003463189, 0.07611129522557403, 0.10100524008782708, 0.0782888506638697, 0.08319543960362807, 0.06420843419548816, 0.0626504170260318, 0.06274053827631176, 0.06454853490952484, 0.04715971025201726, 0.04491175755400889, 0.0512428879882173, 0.9928800581925632, 0.9917898267523223, 0.990608415956229, 0.9928744010712605, 0.9903320735486674, 0.9899202374783115, 0.9918376299982693, 0.9918321810086347, 0.9925903446630027, 0.3772480587296786, 0.37079117475670076, 0.4222885403766319, 0.39782315675316215, 0.34404205515811437, 0.4742004828667614, 0.36557495749137847, 0.37142735838512286, 0.39284525123274205, 0.5331771198206636, 0.5801656843717111, 0.4967837495355205, 0.5418350708355211, 0.5537712578612817, 0.6235338879404979, 0.48726431331666387, 0.5330637313978619, 0.6604744533003031, 0.5766120868141433, 0.613258765073282, 0.6162476392268806, 0.4450808260213198, 0.4223310516864365, 0.46792259919198553, 0.6659613075033787, 0.6323774286660782, 0.6081119622784599, 0.6136015232156731, 0.5985922531642569, 0.6532472747243399, 0.6756678175832729, 0.7280771785644318, 0.6857152188343166, 0.6623011895569354, 0.656756587373351, 0.7172169159864783, 0.39057085586849294, 0.5340004507681974, 0.5110953854842226, 0.5936851154283347, 0.535174828209968, 0.5741585128576048, 0.3386055771679969, 0.3570313015392732, 0.4043982207559229, 0.32117398071717396, 0.30775987491469625, 0.22894881963021774, 0.4403505982471967, 0.4484368891123739, 0.38478387538331604, 0.29602590710814447, 0.49178028726970036, 0.3373262994827376, 0.38965568606922674, 0.4366087404921073, 0.46916076639927784, 0.6834988857465836, 0.6706020465878989, 0.7258684704708306, 0.5472870235809932, 0.4777159245870928, 0.4474395768971686, 0.5322346639247684, 0.45284775522998133, 0.41527799074175376, 0.45105314938061714, 0.35665678306469417, 0.35730884138532115, 0.29931210233868455, 0.3724545866670108, 0.34560464269029534, 0.5812129453386201, 0.6302000250163349, 0.6016129664148535, 0.5764011205981525, 0.587690402997451, 0.5456450795932033, 0.6271219477983789, 0.5852420653706438, 0.5829008436167946, 0.10205051637635154, 0.08658975412607761, 0.11584604683530142, 0.09496580199202742, 0.08398883990541739, 0.08733584447544585, 0.08148070037800403, 0.09960937287051053, 0.11531640627354445, 0.0910523808760767, 0.10072459118360932, 0.11842175776965747, 0.13766266535167793, 0.12134618270202224, 0.10874400837020892, 0.12214756776198288, 0.10538429590584397, 0.10131370729188038, 0.1747782829320409, 0.16681904850697704, 0.1925048870693591, 0.18583671726814244, 0.17646503816592374, 0.17735082523554124, 0.17165925119304015, 0.19979444010366876, 0.18703284470306603, 0.14482910294017326, 0.11782266752792458, 0.1145801242211999, 0.10100320587965539, 0.1110308634002728, 0.1044670104596056, 0.14062654201606606, 0.14104195511238526, 0.1271128294210192, 0.16905367112714997, 0.18440203170849623, 0.19635260676533373, 0.1936718430983556, 0.196840428546728, 0.1728230966379739, 0.17790176496944643, 0.20881206146165643, 0.251997567163765, 0.20475070893601277, 0.20867987372825036, 0.22969447892814865, 0.1998104656096501, 0.21696587543135248, 0.19777507591742272, 0.1969525858144099, 0.19929799306699225, 0.20497189379699599, 0.3331343621082472, 0.5243633134616454, 0.6059853526661058, 0.7679863469545709, 0.6351731856702106, 0.7010527272808137, 0.32289604313189, 0.4028156813141004, 0.5757141906508616, 0.36938361953500864, 0.37279928926011485, 0.4347110342977534, 0.4833916318871173, 0.43890534902067235, 0.2094123249964518, 0.27881438738753084, 0.5599655796301338, 0.5605380609936055, 0.19558280806411743, 0.16999108665053986, 0.18269893139329985, 0.20075581384113106, 0.16815981515245437, 0.18408687839249238, 0.1942387586187314, 0.17063759912584187, 0.19507798832420342, 0.08589734059620424, 0.07910061939640567, 0.0865530150923225, 0.07652183432011228, 0.11226609554421085, 0.08446383750652908, 0.07530143820462798, 0.08637146722676148, 0.06357969841157651]}, "mutation_prompt": null}
{"id": "a895630e-810e-41c6-a61b-f27de90ac5ed", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridAdaptiveQuantumFirefly:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.8\n        self.evaluations = 0\n        self.attraction_coefficient = 1.0\n        self.absorption_coefficient = 0.5\n        self.dynamic_population_resizing = False\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.firefly_attraction(trial_vector, i)\n                if np.random.rand() < 0.3:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def firefly_attraction(self, trial_vector, idx):\n        for j in range(self.population_size):\n            if self.fitness[j] < self.fitness[idx]:\n                distance = np.linalg.norm(self.population[j] - trial_vector)\n                beta = self.attraction_coefficient * np.exp(-self.absorption_coefficient * distance ** 2)\n                trial_vector += beta * (self.population[j] - trial_vector)\n        return np.clip(trial_vector, self.lower_bound, self.upper_bound)\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector", "name": "HybridAdaptiveQuantumFirefly", "description": "Hybrid Adaptive Quantum Firefly Optimization integrating quantum-inspired evolution with adaptive firefly attraction for enhanced global and local search balance.", "configspace": "", "generation": 61, "fitness": 0.4954246974251025, "feedback": "The algorithm HybridAdaptiveQuantumFirefly got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9901064947625859, 0.9904648545002589, 0.9909206280310664, 0.9900367114850488, 0.9907712788535542, 0.9899219631321239, 0.9904123573615157, 0.9900765374457425, 0.9911023724428243, 0.9646980111319601, 0.9794969116805938, 0.9756937116653472, 0.9761723988671424, 0.9775447874162727, 0.977821380199236, 0.9737735532443311, 0.971676735364817, 0.9739677328437039, 0.052798007339294184, 0.0565526578959481, 0.050254724579740784, 0.05378326345714124, 0.08966921555013574, 0.05952451788697721, 0.05344584484079007, 0.0635228163001409, 0.044072651258343254, 0.013562956333850296, 0.03698376234602585, 0.03105306637492633, 0.036399560819943666, 0.08796842257391568, 0.06687746619286261, 0.0331859860016992, 0.02944615982893828, 0.018733684738740375, 0.9876276722479882, 0.9853240460570609, 0.9893741323690765, 0.9878772435038272, 0.9893537116607758, 0.9880593400021118, 0.9877804280276435, 0.989356628081323, 0.9869874761480546, 0.8836597495669867, 0.8730898825474371, 0.7946799705153801, 0.8163449144172841, 0.760080592891539, 0.7850000880171158, 0.7818064097688018, 0.8316804654430747, 0.8311632510802555, 0.3894199370715996, 0.2160027922511456, 0.16475567457397833, 0.14827395515559616, 0.15557907760719536, 0.1744889593354002, 0.20812211597871444, 0.1540456288214337, 0.22398519309386822, 0.949908995446042, 0.9471786998786335, 0.9460021376981944, 0.9121721363742197, 0.9040950693465494, 0.9648103816898994, 0.9688246308439961, 0.9502573494561563, 0.9725617179232654, 0.9466818777762551, 0.9506314086445418, 0.8800238570119985, 0.9164881042392039, 0.9577351560240337, 0.9501894227356451, 0.954937692327589, 0.9150061068524901, 0.9156532755785654, 0.8220002221631586, 0.7903349122734598, 0.7918878357454926, 0.8391891061736516, 0.8092065525251457, 0.9189529089163426, 0.7786213582191321, 0.7901748858072242, 0.8120051565869469, 0.7648007588059996, 0.7799045898250228, 0.8665642937127604, 0.792547452860311, 0.770953941154717, 0.7548216780581289, 0.8023957113326158, 0.6789642983708939, 0.7162955784116629, 0.7834857933123797, 0.9107291346120432, 0.9154009385458084, 0.9059533700646536, 0.7172612606053457, 0.7386279095049305, 0.5531088997709408, 0.5233972913282259, 0.7197842273982695, 0.5102738962062356, 0.5104982230405045, 0.4990322011618624, 0.5487011987910593, 0.5412508201502979, 0.5392419716807775, 0.7032483384950193, 0.6440540294214183, 0.6142982458129518, 0.8333871197474383, 0.8483551747890766, 0.7963448956262642, 0.7992072662870932, 0.8352522399833443, 0.7757100503485628, 0.8400597250381479, 0.8230391332883236, 0.8116189564737999, 0.06362923151227862, 0.08696703210720824, 0.028685584809156173, 0.09856108728401958, 0.05613330789087778, 0.057211839518942376, 0.0589046779550898, 0.07974226509791349, 0.08747425177091228, 0.08847540051144953, 0.08609370886951495, 0.11917918466453625, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.1064898905221826, 0.09628275961029686, 0.08588332852035385, 0.172620269704712, 0.1512023324593894, 0.18618650769623868, 0.15279920721377915, 0.16539039251831744, 0.15211085796676327, 0.15886942379730662, 0.17377774300845283, 0.15371849608931532, 0.07912351604569445, 0.0947546059708706, 0.11804237778481785, 0.10052777034909799, 0.08600603312107102, 0.07304560355426126, 0.09219037344861702, 0.1019590637338964, 0.11295039453167688, 0.14134406791944842, 0.14268492179010062, 0.13345086981233123, 0.12998131988323003, 0.17629300369231804, 0.18092445481875596, 0.18016483374545422, 0.14591567202834466, 0.1342062398000411, 0.19693013547908245, 0.24786519240026617, 0.21467167698489242, 0.21720602593602778, 0.22145452457044956, 0.2207333300589166, 0.21582771537840606, 0.23048812757742132, 0.24398290690592916, 0.9106511286722877, 0.6230369038503376, 0.5837580553897393, 0.36845413416260286, 0.48014224301589326, 0.18548513794166221, 0.8513877496542065, 0.3057533965581273, 0.6167468471850253, 0.7560174301749898, 0.9122040821504717, 0.7093698495638561, 0.8957714057663568, 0.21016539270721613, 0.8856406618808054, 0.20328787736298615, 0.18375266429385295, 0.9208205177573722, 0.18347531064651557, 0.17307160187472004, 0.17974888338741712, 0.19429867515494537, 0.17163677930525623, 0.16677384024824626, 0.19530541875502527, 0.16241600620715746, 0.1677952202945382, 0.05413643047939354, 0.03915028858887126, 0.06516735095486781, 0.05244758700966701, 0.057277548552532975, 0.057120309344382836, 0.061868469104442325, 0.05504370092538191, 0.04874858712453223]}, "mutation_prompt": null}
{"id": "5cf0dad7-ead4-4fc1-b28c-db8a79d20937", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumCooperativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.cooperative_swarm_factor = 0.1\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            global_best = self.population[np.argmin(self.fitness)]\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                trial_vector = self.cooperative_swarm_update(trial_vector, global_best)\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def cooperative_swarm_update(self, vector, global_best):\n        attraction = np.random.uniform(0, self.cooperative_swarm_factor, self.dim)\n        updated_vector = vector + attraction * (global_best - vector)\n        return np.clip(updated_vector, self.lower_bound, self.upper_bound)\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumCooperativeDE", "description": "Quantum-Cooperative DE, integrating Quantum-inspired differential evolution with cooperative swarm strategies for robust optimization.", "configspace": "", "generation": 62, "fitness": 0.5187597150568318, "feedback": "The algorithm QuantumCooperativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924609722980442, 0.9917618601457309, 0.9916432798417374, 0.9905708218062983, 0.9918844114131888, 0.9910782661630879, 0.9909601829040569, 0.991361729119193, 0.9909655738587372, 0.9801887849464919, 0.955141449046668, 0.9638657573226819, 0.9767075327398423, 0.9786488850622538, 0.9763862249343905, 0.9814589890916104, 0.9745772146394683, 0.9697503295010612, 0.08497678741352466, 0.10021598712699886, 0.05304694046530278, 0.08824959183334635, 0.05948416089361985, 0.07058196789340931, 0.08750160052069478, 0.07287612129437093, 0.0847393903346847, 0.03807220153059465, 0.09519840285006198, 0.05084978094496129, 0.05139244077850835, 0.012564151052573802, 0.03510558785451445, 0.05957693616718529, 0.020240659327566246, 0.037394430885025254, 0.9885461725479866, 0.9905119098111528, 0.9906422439618332, 0.9891087404050802, 0.9901127760110212, 0.9911504710997336, 0.9892168725374261, 0.99047014434639, 0.9896165414444539, 0.7708918962005503, 0.7875350871915953, 0.8961439654299852, 0.854186683312576, 0.8528923111208218, 0.8780817903492973, 0.9470525616535548, 0.7868416639086151, 0.8954361093400686, 0.43552876306226307, 0.47677927023894884, 0.4550781219116745, 0.4631330258353058, 0.4197977723501638, 0.4805147508932869, 0.3945450511013078, 0.49738903112571464, 0.37992337037225443, 0.9633866342209939, 0.9404737308722015, 0.9751231580461895, 0.9484844750370867, 0.9649347656794012, 0.9482266644975612, 0.8452213709470116, 0.9320112128615755, 0.950913099234133, 0.9527487440980914, 0.9642680652926056, 0.9727463281092574, 0.957313915110207, 0.9585763605599793, 0.9600232637053526, 0.9646099308978784, 0.9550091830607923, 0.9574666825314523, 0.8163905634122897, 0.7738729907160735, 0.7602678461709341, 0.8302380992214772, 0.9148542589443406, 0.9101738298719444, 0.802187583624116, 0.7966214948703387, 0.8072140114027317, 0.7290743034153899, 0.7952796370311078, 0.7771922404578286, 0.7583870556698968, 0.7608914203833502, 0.7535117962801513, 0.7669985208523489, 0.7558867862353643, 0.733902830727396, 0.8447470989093849, 0.7608810063256664, 0.7474280921376707, 0.8742172575533732, 0.8537548400275982, 0.80811706314096, 0.8096674278049958, 0.5289640953772065, 0.6337326661739315, 0.4953819730504704, 0.508927296611343, 0.5066160036140323, 0.5752146974288066, 0.5532046115723483, 0.5817766228514085, 0.6753752736829286, 0.6252881768464917, 0.671674725611492, 0.8091818761043615, 0.8618668355494183, 0.811184625409281, 0.7956041977869861, 0.7898734986503413, 0.7737002381650939, 0.8284298185837544, 0.819653338691708, 0.8722796961920578, 0.053859621773190924, 0.07543808325558532, 0.037318250793326624, 0.12932024174129275, 0.06268099615766132, 0.07165543309761158, 0.06649814900241413, 0.06118839197727699, 0.072110972134525, 0.08506654286853155, 0.14624777797084987, 0.12089882770581772, 0.13766266535167793, 0.11639692454563488, 0.10798713552628325, 0.0963441985350828, 0.09849141806680728, 0.07886047878433933, 0.17280633750118646, 0.14355331766246204, 0.16444263445043383, 0.17006599236742692, 0.16346037422009307, 0.16423380547635147, 0.16408015054401315, 0.18240272716895156, 0.1719768183092898, 0.14203473268378586, 0.07904178570579001, 0.12933664172283021, 0.09007896131963111, 0.09208894163734838, 0.09653837946374366, 0.10856107757880928, 0.11274987690275395, 0.09903243735041489, 0.1790344333912055, 0.16007975380085337, 0.180482514066572, 0.16980548834532128, 0.13880828735046213, 0.16097210985927135, 0.1973764009466107, 0.1308968330675545, 0.14925958633478276, 0.21816288292298613, 0.2209154267835446, 0.8563970002370986, 0.1915159517336278, 0.22301815886219067, 0.2466066586047001, 0.24196870681555194, 0.3975345169628428, 0.3322060258633637, 0.6659595247004675, 0.259839275037961, 0.8312847506465338, 0.8067170721679269, 0.8078103485085179, 0.8229679684318174, 0.6628058894268286, 0.6043307643966687, 0.8347709158280638, 0.9195432448212021, 0.504380793599903, 0.8932866909101012, 0.7802629342715919, 0.4999304741909226, 0.20163731456460965, 0.6990301081777732, 0.3469698393810948, 0.2019459820175794, 0.19984204876716927, 0.17070163163960916, 0.1768511815948326, 0.1495197502591491, 0.16572593489048792, 0.1744260626899381, 0.17709726380761437, 0.17043836399893297, 0.15273836499068771, 0.07344936365394916, 0.06863735375682356, 0.051994592603861745, 0.08256534139079941, 0.07161879768129165, 0.05504433803682063, 0.05580481046289065, 0.059852694214148294, 0.05893241998884424]}, "mutation_prompt": null}
{"id": "fa316bcf-ceac-4ba4-b5cd-63d99742fd72", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass AdaptiveMemeticQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "AdaptiveMemeticQuantumDE", "description": "Adaptive Memetic Quantum DE combining Quantum-Inspired DE with Adaptive Learning Memes for enhanced exploration and exploitation balance.", "configspace": "", "generation": 55, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924670422390527, 0.9915408782662392, 0.992452591997489, 0.992382036906779, 0.9901573909424434, 0.9924124619680466, 0.9923103538515763, 0.987857679233041, 0.9922949230229235, 0.9705042938951913, 0.9794031764515592, 0.9674087610443713, 0.979203185450062, 0.9783932638440251, 0.9777238171595642, 0.9517336008474909, 0.9781286253373136, 0.976687645313368, 0.0548983631915988, 0.11638628817580032, 0.05927908991276287, 0.05806523572463318, 0.056841899386782635, 0.046598031988475896, 0.07086382006817471, 0.05842282201910276, 0.04337670435027574, 0.05869391356978615, 0.03318092192251132, 0.03351324203265593, 0.03217429631455637, 0.050679790247966205, 0.059267364629036146, 0.03248177774814798, 0.0442598257811635, 0.06731436048759354, 0.9902206376455807, 0.9901601100628397, 0.9890534743121823, 0.9885387726093946, 0.9897501560265013, 0.9863029879769701, 0.9880544121868204, 0.9897189779923079, 0.9909668921224063, 0.8320156622589263, 0.8985474641847394, 0.8120382224404042, 0.7024486542893135, 0.919210311735522, 0.7841409989570889, 0.7824008956048456, 0.8231360320930736, 0.790201769993434, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.9152171608503382, 0.954753008377771, 0.8814625306595233, 0.9519356084159577, 0.9461489013513299, 0.9477498029651522, 0.944980808916221, 0.8995067505582149, 0.9684448344323958, 0.961151971406983, 0.9541024127626765, 0.9331115809206902, 0.9628124382417353, 0.9389265910146264, 0.9556271927981393, 0.9675300764200093, 0.9547854068832504, 0.9550489307325515, 0.8088778185214008, 0.7650525538386473, 0.903338676216281, 0.8262641829018775, 0.822911165157705, 0.7981679156551558, 0.7585863167258964, 0.7844928444312685, 0.8801867752298695, 0.7159516486033592, 0.8105831419227991, 0.7421679505298693, 0.8056827567255608, 0.7858780860211418, 0.7342526709945958, 0.8045206568550833, 0.8201744110133983, 0.8200476351492714, 0.7372486412505779, 0.8629753830376348, 0.7912471077888036, 0.7234395994340095, 0.7319910375683505, 0.8091279756042709, 0.5474639542021817, 0.7272920006301427, 0.5897602846660941, 0.5221962775343001, 0.5290628900350594, 0.501407039135128, 0.5442094361273901, 0.54873826743215, 0.5966813535595021, 0.6595011257749013, 0.6448991818202043, 0.6665524321573657, 0.8045191045482666, 0.80890447346724, 0.865915454478525, 0.8071539292211016, 0.7593415285196478, 0.854177078409461, 0.8339398225203464, 0.8040828795163534, 0.83105990602326, 0.09551239279046952, 0.06291346760303362, 0.06856871362184469, 0.050246750020063846, 0.06072250489711495, 0.08857902072343005, 0.05962070090669891, 0.049123442014367136, 0.06441195581762726, 0.09042177290678532, 0.09206000817259863, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10676391538461272, 0.12390635109438808, 0.15870336382753591, 0.14895822825701255, 0.1676473416316694, 0.16759651544860388, 0.15124549708500568, 0.19001291616893068, 0.18298477708973915, 0.18381414793216555, 0.1732930986214014, 0.07512446329586187, 0.06385716305502576, 0.09851590353290773, 0.0853711217825992, 0.08599191181922416, 0.10669186410163434, 0.10344340969851351, 0.10524503704596677, 0.09524283671068556, 0.18625144806273985, 0.14425346195952005, 0.17246198286137182, 0.26724366798813837, 0.16129054987826763, 0.1848001237676724, 0.1672407481970648, 0.1745269941610269, 0.2049960056766169, 0.21941417003172625, 0.21296879153416126, 0.2257605108478079, 0.22792274363614073, 0.2453798803534133, 0.22816230242583502, 0.20408771393039393, 0.9692799791896981, 0.2265709025986734, 0.7964094260525704, 0.9073557378175009, 0.9821218170480415, 0.9616324994512985, 0.9634796540901283, 0.8916953834755309, 0.9467016778459812, 0.8033558432680256, 0.8512643604698018, 0.9498378972515099, 0.841958429484871, 0.8466493015344532, 0.8231105115564934, 0.8937738115673081, 0.9100092355203836, 0.3504282340657978, 0.8171566292233908, 0.8468163691417774, 0.16355557610037774, 0.16383073639321355, 0.16409177618796034, 0.16827988847869113, 0.1772513192612456, 0.18056258921994717, 0.150639854419077, 0.16672125459066833, 0.1591067270831802, 0.07220832775248032, 0.0748063688967282, 0.05524457693118834, 0.07991122017258989, 0.07594805563031604, 0.07760387768544474, 0.053741832098799236, 0.0702787778017786, 0.0620010760286277]}, "mutation_prompt": null}
{"id": "96b9de98-1423-4e1b-b177-5e163cf6f053", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass ExtendedAdaptiveQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.orthogonal_crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high) * (1 - self.evaluations / self.budget)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def orthogonal_crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        orthogonal_vector = mutant_vector + np.random.normal(0, 0.01, self.dim) * (mutant_vector - target_vector)\n        return np.where(np.random.rand(self.dim) < 0.5, trial_vector, orthogonal_vector)\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "ExtendedAdaptiveQuantumDE", "description": "Extended Adaptive Quantum DE enhancing diversity through orthogonal crossover and dynamic mutation scaling.", "configspace": "", "generation": 64, "fitness": 0.5284021847659316, "feedback": "The algorithm ExtendedAdaptiveQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9927932677413883, 0.9921062683893842, 0.9872186441823336, 0.9881257055858612, 0.9926452631790673, 0.9851313749192298, 0.9926703994375815, 0.9925727529350319, 0.9875137242199967, 0.9738701545869407, 0.9706154359410467, 0.9748467054180839, 0.9716073091686661, 0.9748936755492303, 0.9679962842534886, 0.975417436396775, 0.9793395426035637, 0.9610521515445976, 0.058282530385954434, 0.06153259566403779, 0.07625421354865392, 0.07691739567264444, 0.0715008032131873, 0.083537337978417, 0.08634075811036124, 0.059879718603398246, 0.10219855803700861, 0.060628182571149436, 0.0564835582012434, 0.08063619028309765, 0.041406087471433595, 0.047627338774338335, 0.026037232604743665, 0.0315342245916459, 0.06521301141893632, 0.031077184661610358, 0.9912737173459285, 0.9908083918449495, 0.9870656180157747, 0.9858583686166236, 0.9908329312485675, 0.9859232362380189, 0.9859077242652425, 0.9913390763244789, 0.9849705193597625, 0.84337923337511, 0.8640955339753771, 0.7655453530050461, 0.7874472340407846, 0.8172379363913111, 0.9358898114780765, 0.7388771314365437, 0.7879396300425701, 0.809608807742062, 0.6055550210868743, 0.5569053619528206, 0.5544407846475019, 0.5402770251275879, 0.5480291476898596, 0.5355281459462469, 0.6089263936435596, 0.5722160117992288, 0.6304262026440102, 0.8996911130442878, 0.8848314523234042, 0.8460852228219553, 0.9360333119127414, 0.9710874137969943, 0.7752515222638344, 0.9353153010509547, 0.8312948938489951, 0.9332416229987308, 0.9562665297430902, 0.9489254617574284, 0.954672202070788, 0.9488651867297382, 0.9508656497771016, 0.9434348313175847, 0.9073700606849138, 0.949813617198062, 0.8704084322917827, 0.7332516955127637, 0.7875553216011544, 0.793039275979727, 0.8934653349974868, 0.8710445635727967, 0.8123099882769556, 0.8541914756252734, 0.9013394812640194, 0.8038019347983946, 0.7760672721356218, 0.8410949467418788, 0.9273595988362762, 0.8538476355374047, 0.768362270786255, 0.79852958066243, 0.8010050056172281, 0.761928780104868, 0.7370096887187048, 0.847139377046502, 0.7900372177435561, 0.8844806036943258, 0.7946353810856819, 0.7098828493271576, 0.8118555784454348, 0.8093090534353287, 0.6075269772268725, 0.5604629853521269, 0.5052029927710282, 0.5015878039233882, 0.4957131248151426, 0.5730996598050073, 0.551324438555153, 0.5525719338440579, 0.6779414900126272, 0.6462894049544394, 0.663577196995955, 0.8183884206887868, 0.8786497039476947, 0.8093570477458608, 0.7973451279816589, 0.8711945539579575, 0.8077591468456229, 0.8350303064771978, 0.8760303468904795, 0.8020833054876484, 0.041795053774446256, 0.07592662930255445, 0.056193390228962525, 0.06020458464636835, 0.07743615922944758, 0.08861678186943533, 0.04531783696845981, 0.062162073624793424, 0.06982952837664269, 0.08494000004272673, 0.11957946954640919, 0.11842175776965747, 0.13766266535167793, 0.1134502932013356, 0.10798713552628325, 0.08913656660404434, 0.09227792941523527, 0.0832840764916074, 0.15868231233970587, 0.1447943572543865, 0.197252390022018, 0.17541338245199145, 0.1576198428435056, 0.16428975778491606, 0.18112376849132972, 0.18808263667966918, 0.17411968448873016, 0.0803107187917722, 0.08052967763281937, 0.08856621501937167, 0.10531520387178428, 0.0835984435102779, 0.1088109136118246, 0.09738343473877598, 0.11011268665656793, 0.09442240013066272, 0.16515874892144, 0.13807917426482796, 0.1572645303782576, 0.24740009241014482, 0.15341790450487935, 0.1404196302732098, 0.14391487651865353, 0.31822872848447725, 0.17983871632736825, 0.22182877059865613, 0.2018708611359582, 0.7817433124353469, 0.19719951484303144, 0.23063971844241782, 0.5748123906258376, 0.211425373084843, 0.21767941704195404, 0.8933982420892641, 0.88212556667756, 0.1866113297637204, 0.5253090216708394, 0.6093031151438986, 0.9139776570135063, 0.5590356713255534, 0.9098723179259889, 0.835899428544703, 0.7644373828688413, 0.9775756915940537, 0.8233084226710942, 0.8127458047743944, 0.8129455102711838, 0.20388759755229735, 0.1960836232035792, 0.7297505532271893, 0.8540601820465277, 0.5477310225148853, 0.16092344537041103, 0.19758594998206336, 0.16754444011244263, 0.16439747386626347, 0.17571053271096282, 0.18077833724046855, 0.17973577862801993, 0.1861348080838543, 0.1821717591438894, 0.04807930383093029, 0.05401793501503105, 0.0654723073975092, 0.06324771061952017, 0.04561689345580211, 0.054523777187180156, 0.06959491077998936, 0.05499691812431429, 0.03976889584563692]}, "mutation_prompt": null}
{"id": "d7be5856-c07a-45f1-b3a2-1b9b303874de", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9  # Adjusted to enhance exploration\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.3  # Slightly increased to enhance local search\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.stochastic_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def stochastic_local_search(self, vector, func):\n        for _ in range(5):  # Adding stochasticity by repeating local search trials\n            step_size = np.random.normal(0, 0.05, self.dim)\n            local_vector = vector + step_size\n            local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n            if func(local_vector) < func(vector):\n                vector = local_vector\n                if np.random.rand() < 0.6:\n                    result = minimize(func, vector, method='BFGS', tol=1e-5)\n                    if result.success and func(result.x) < func(vector):\n                        vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumStochasticDE", "description": "Quantum-Inspired Differential Evolution with Dynamic Population and Stochastic Adaptive Local Search for diverse exploration and exploitation.", "configspace": "", "generation": 65, "fitness": 0.5021144288932828, "feedback": "The algorithm QuantumStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.38.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922923263829813, 0.9896482872694137, 0.9924523510191149, 0.9926426286203045, 0.9919313643883957, 0.9924124619680466, 0.9925803880410802, 0.991872220604747, 0.9923034021417089, 0.9748273604319421, 0.9742756305790448, 0.9801331974630931, 0.9793933333477607, 0.9749997992589898, 0.9770852441848764, 0.9594899567257537, 0.9719522266767395, 0.9663152148719745, 0.05033014754072518, 0.0795673248506038, 0.055289978306684695, 0.042812324974607296, 0.027984483717355957, 0.05221903361071889, 0.04117865541089627, 0.07251578290053184, 0.039837644004467654, 0.018415083951957456, 0.037235464116663564, 0.030273973739141202, 0.026689189030101645, 0.018968797953761385, 0.02661992392328938, 0.02836132511904632, 0.017532489899291015, 0.012669612407781972, 0.991753409638755, 0.988569723827663, 0.990396770435065, 0.9913298771501236, 0.9879369590369338, 0.9903146782702199, 0.9902942485776457, 0.9886503839646615, 0.9909663499576744, 0.7947411711719196, 0.8019714017719658, 0.9248666303028856, 0.7538785566976731, 0.845417981658491, 0.9471794431488497, 0.8804131227926378, 0.8399493439663765, 0.7687489096150677, 0.1604986736714742, 0.18332996276312696, 0.15276866522508337, 0.16501338032772694, 0.19059654304997398, 0.17037342214097573, 0.16855625065019286, 0.18712868956847628, 0.16752720353134753, 0.9715989836394081, 0.9061523895628714, 0.9603100660642362, 0.972961450710139, 0.9667362706216541, 0.9499165848060714, 0.9572738554312886, 0.9623295695660119, 0.9501322995701994, 0.8949753183063174, 0.9569741454884536, 0.8873261053504986, 0.9426325593279744, 0.9447158235743138, 0.953859157817632, 0.964325032535313, 0.945620548154708, 0.9558669143913313, 0.7545003402975355, 0.8037789825408551, 0.8254787408656802, 0.847872427545025, 0.8098214310282359, 0.8218840131873149, 0.7662319408533793, 0.8720256577651433, 0.8511219018795059, 0.8045034410888489, 0.7251526592923399, 0.7797853160915613, 0.8141254772352735, 0.8406172448764384, 0.7676043139858589, 0.7270041342581197, 0.8490484065007983, 0.8032955265709645, 0.8088161235806737, 0.9141764694831344, 0.7978103050891395, 0.7056020493975026, 0.8455644418860124, 0.7676390394884762, 0.5397602703267561, 0.5186205851777606, 0.7342262998583484, 0.5306098455478461, 0.5140438341389705, 0.5018161984977797, 0.548220407462946, 0.5554500499588547, 0.5616742259851751, 0.6053400655460803, 0.6512791419807188, 0.6553498214352712, 0.8437131996413781, 0.8303085257313362, 0.8406657115794121, 0.8332323984770943, 0.8076727872385533, 0.7615300909602457, 0.8648077623671234, 0.8638491634354091, 0.8338622918643157, 0.024907986232581614, 0.023517589163094654, 0.03441982129040355, 0.033143845122175275, 0.05702655995011974, 0.06580427886155571, 0.040177082116882645, 0.0527706226525666, 0.047622604004974534, 0.099300504925809, 0.09003607136010561, 0.12445984659256815, 0.13766266535167793, 0.10852972522114013, 0.10803649930025438, 0.09170166942137237, 0.08412979499036488, 0.10496936192326012, 0.15324711586441575, 0.14885707837051, 0.17841216721011333, 0.13811928908835036, 0.14487573328669912, 0.141579598299154, 0.1371740566998073, 0.17582617781914045, 0.19408416835554143, 0.07595237401091781, 0.08746037813764018, 0.08398582550377798, 0.07281596828179504, 0.08001813370804989, 0.08454717650168564, 0.08477525683791809, 0.1135222705479989, 0.07951359220720855, 0.1354527163006931, 0.1500414778291953, 0.19853934864312828, 0.14427677785433513, 0.13702405800431583, 0.16716424745325298, 0.13186024328047574, 0.2567039907418829, 0.13581982576455398, 0.22047165288164072, 0.24753194816652724, 0.22001940741990733, 0.22817044914467488, 0.1968436786242863, 0.22047055539478166, 0.22818816608764425, 0.22550336756467582, 0.20485820597140314, 0.5766446982795588, 0.643511740430994, 0.9175855153330301, 0.5285320384615086, 0.7418245252321154, 0.8337274478180496, 0.8477147051560037, 0.9491297230429804, 0.9270643792167398, 0.7621317194684868, 0.9177461140191508, 0.6709252949842928, 0.8101959664234795, 0.20085988240486463, 0.16986073249145406, 0.8352954181261455, 0.2559873861001256, 0.8648951832701831, 0.1874387416114115, 0.1679882182873722, 0.18038124216746798, 0.15853927172464588, 0.14733896385217926, 0.1562911715220776, 0.17398624224451775, 0.16754408047259584, 0.16605362119907496, 0.04323271715362775, 0.04581861816162547, 0.05525978868806414, 0.038777285004060635, 0.04857850278655462, 0.05657759765432313, 0.0502401396740364, 0.04696890836045897, 0.038665534522634326]}, "mutation_prompt": null}
{"id": "6bebe70b-5706-4458-b214-c6f0328e980a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9  # Slightly expanded range for better exploration\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedAdaptiveMemeticDE", "description": "Quantum-Enhanced Adaptive Memetic DE utilizing Quantum-Inspired Differential Evolution with enhanced adaptive strategies for improved convergence.", "configspace": "", "generation": 66, "fitness": 0.52609776476545, "feedback": "The algorithm QuantumEnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924727364548812, 0.9915427060792326, 0.9924523510191149, 0.992382036906779, 0.990147848788635, 0.9924124619680466, 0.9923103538515763, 0.9878906845643023, 0.9923034021417089, 0.9732375513204504, 0.9755635809183126, 0.9801331974630931, 0.9657793045041754, 0.9751961047388477, 0.9770852441848764, 0.9668515293495978, 0.9775251932561361, 0.9663152148719745, 0.06795943731465648, 0.08374035071126185, 0.06395826991380815, 0.07515583140538362, 0.06140755442137413, 0.06679173565590013, 0.07035155564312334, 0.0841487823779653, 0.0562079109766388, 0.01959050924558925, 0.03562825546056725, 0.02814495799400396, 0.05512874588159378, 0.024802783931932026, 0.05021154691390184, 0.07020412557183686, 0.08758386080718139, 0.03289050853744779, 0.990219604149017, 0.9901512849389034, 0.9890140234181459, 0.9885522023991465, 0.9897067490622106, 0.9862862726316057, 0.9880544266929236, 0.9897394236583523, 0.9909663499576744, 0.7269708763951515, 0.880256343686145, 0.8509034049874624, 0.8430870056211641, 0.849311221025479, 0.9471794431488497, 0.782814752141885, 0.7411053631494504, 0.7817780632378724, 0.47282464957536685, 0.4208043147284698, 0.33682122331205544, 0.37639083426917264, 0.5039152933217872, 0.36246616243775065, 0.36060105897174377, 0.4175046567542202, 0.41160605868293676, 0.888964055202685, 0.9511229718578585, 0.9603100660642362, 0.951525286718771, 0.9439507600335573, 0.9499165848060714, 0.9388252784692456, 0.9451746812254522, 0.9736878921042696, 0.9658149268567511, 0.9569647767649851, 0.8993987988366708, 0.9640384864431171, 0.9258599604678607, 0.953859157817632, 0.9684767716603045, 0.9302933493799539, 0.9558669143913313, 0.9185155680942382, 0.7113993288841635, 0.71174209085034, 0.8514003981557381, 0.8152656217153511, 0.9542824431239004, 0.9267306115785998, 0.8679911330969781, 0.8145081096864031, 0.7725627032424038, 0.7232922712227254, 0.8524503646056047, 0.8407360512388806, 0.7983778754654702, 0.7495022223777499, 0.7659583066909702, 0.7298381281748534, 0.8345497814141939, 0.8091002791366833, 0.9055326567751789, 0.774515060905195, 0.7474933330909155, 0.7821847670880228, 0.826335549366548, 0.553957344742763, 0.5747603484501439, 0.7344230108537675, 0.5134724810865067, 0.5074435934758088, 0.538182167231481, 0.5593711611488217, 0.5583843457322, 0.5547424721843879, 0.5999470162680923, 0.6939255672580928, 0.6291329530619438, 0.8735320052186816, 0.7989290794406381, 0.8111209376285566, 0.8029420841626017, 0.7667204616267309, 0.82428532003124, 0.8406541735995109, 0.8371439873896384, 0.8647194636627209, 0.05016823329825015, 0.06985189947013082, 0.09373559003313481, 0.08327550393579297, 0.07153699533404811, 0.08043088171522705, 0.05047173128117988, 0.07314227610925739, 0.0948922552731929, 0.10757618682934966, 0.10201389132154237, 0.11842175776965747, 0.13766266535167793, 0.12841231473425796, 0.10798713552628325, 0.09947643839462328, 0.10265413575491311, 0.12777813707405583, 0.14281206975469363, 0.14780120283514064, 0.1618065537805995, 0.1770662053683456, 0.1490984586251003, 0.16424801060892746, 0.1553666291971042, 0.17424525262585344, 0.17794638221352943, 0.10138003113835459, 0.07713218572345071, 0.100896424658385, 0.10065306288706566, 0.08579670378030335, 0.10418671473243835, 0.09458156061004086, 0.10376917428086452, 0.08459304791946565, 0.1519380492383381, 0.13566998776181594, 0.15762904371689312, 0.12974843144094417, 0.1228367782148776, 0.14134194291393143, 0.17339954610856, 0.19576225072954234, 0.19308561013165093, 0.7506775203954683, 0.2534627493012578, 0.2141684541062534, 0.2420608586627535, 0.20579139295426863, 0.21450287250166433, 0.22478777600102418, 0.20960400841951254, 0.22313541136077308, 0.8941383557416265, 0.9819512489827095, 0.9175563074437174, 0.9175833603124948, 0.8675202075353354, 0.8728572729466979, 0.9234318676223996, 0.7045491114621099, 0.3780939799394434, 0.9284381432207335, 0.7389092469046059, 0.8428579738892805, 0.20812209166869933, 0.8665302684139614, 0.6227150085891636, 0.5168353734263875, 0.8506665176339289, 0.924790050501399, 0.17992159802368568, 0.17475483386737356, 0.17197484289653908, 0.1617837424380386, 0.1668772691595516, 0.19380672948978417, 0.18776759062599402, 0.14938303094596272, 0.1539634765160739, 0.038272871365095495, 0.09352357216890561, 0.05067953850826312, 0.05142107284218023, 0.06225385984887721, 0.07653386491450997, 0.06618479936035915, 0.08256513989504388, 0.04478794949343046]}, "mutation_prompt": null}
{"id": "58069794-0418-41fe-9a50-659f2aa79e64", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveMemeticDE", "description": "Quantum-Inspired DE with Adaptive Memetic Strategy using Dynamic Mutation and Local Search Refinement for efficient search space exploration.", "configspace": "", "generation": 67, "fitness": 0.5291554047676877, "feedback": "The algorithm QuantumAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922932420529966, 0.9915495041106551, 0.9924619586043977, 0.9926426286203045, 0.9901687127046099, 0.9924124619680466, 0.9925803880410802, 0.9880425840840994, 0.9922648456357844, 0.978050439557775, 0.9768339720894301, 0.9763060957865993, 0.9770071893783131, 0.9751281542055492, 0.9808317421376244, 0.9661646273776416, 0.9717943823869073, 0.9645090730565771, 0.10375371099680764, 0.08832698100120873, 0.04614689915865233, 0.08889265006382918, 0.0907242966676669, 0.07082438529155366, 0.045684772283062, 0.07052341671097839, 0.08286351113083124, 0.016670491874333115, 0.02695845894386495, 0.032811162913619185, 0.02891015723401158, 0.049507778923018275, 0.06780055049678957, 0.059413547210071416, 0.04489749010069277, 0.03081246204203003, 0.9917556709645767, 0.9901616159472393, 0.9890302156944767, 0.9912822903355504, 0.9897678814273542, 0.9888248573198212, 0.9903115108956823, 0.9897161271771745, 0.990993833258196, 0.8580020764677669, 0.8278735126625705, 0.7118423588265657, 0.8476743903530559, 0.7888633969239728, 0.8169860441009291, 0.84093472955902, 0.7608879191380976, 0.856741112679877, 0.5331771198206636, 0.5801656843717111, 0.4967837495355205, 0.5418350708355211, 0.5537712578612817, 0.6235338879404979, 0.48726431331666387, 0.5330637313978619, 0.6604744533003031, 0.824540141590954, 0.9533941021511615, 0.9544209753758219, 0.9505323992688489, 0.9516539026604921, 0.9473338915159061, 0.9598755031232852, 0.8657073809812919, 0.9692530596510193, 0.9655891613950982, 0.9579376822785539, 0.9409673523777204, 0.9457833988905017, 0.9420625868404385, 0.9555655044388552, 0.9304057929475132, 0.9676225459924579, 0.9623541024670679, 0.9035637970315171, 0.8365617053214414, 0.8058483356825537, 0.8138457092845242, 0.86360505067992, 0.8278094187877978, 0.85212131234778, 0.8367278753709394, 0.8104225939802469, 0.845471693172699, 0.7901006632402767, 0.7614952706792952, 0.7335642326865384, 0.7666463749785739, 0.7936955524679188, 0.766380190040199, 0.8188462570400222, 0.793728931921669, 0.7753589114640145, 0.8314146297197178, 0.771089852995726, 0.7205997085254177, 0.7416807086992061, 0.8151239809797615, 0.5229768563779338, 0.706261961591137, 0.7699350515340503, 0.5210544256494604, 0.5201922521430358, 0.52092541927861, 0.5640806328274443, 0.5458108713428154, 0.5566339685132756, 0.6856911788338023, 0.6368256126804573, 0.6132117146724647, 0.8004351667430072, 0.8095562429815675, 0.8444605077367644, 0.8370345056557997, 0.7972641641385704, 0.8086184236442002, 0.8862669311883011, 0.8420460737607003, 0.8599238984438485, 0.03957929298557605, 0.05778108670800919, 0.05962213607491307, 0.06766575903457728, 0.052524404307784045, 0.07245615189773036, 0.07662851340570176, 0.09892313908122674, 0.059163111885446096, 0.08716119481183049, 0.09277532421247958, 0.11842175776965747, 0.13766266535167793, 0.1204257412563795, 0.10798713552628325, 0.09818992182175423, 0.08562267012655433, 0.10661326649399472, 0.15738791737233992, 0.13907574355079633, 0.1733852195124398, 0.17225062682120718, 0.1464192621599696, 0.16319351521040748, 0.15561238825847268, 0.18718569903268, 0.16839551294125954, 0.09543480996599596, 0.0887980753131895, 0.11215125549386518, 0.08540322587729765, 0.085191232319908, 0.1034640047285742, 0.10597707660679012, 0.13141250037735497, 0.09435786507553001, 0.1553569588388164, 0.14894668669670685, 0.1937859908451246, 0.17378559878928213, 0.18585944568400392, 0.21362202384865792, 0.15190658835338888, 0.16149796301546449, 0.15408826696012967, 0.64513580595229, 0.6644152093928304, 0.20526173857960894, 0.20261220096701504, 0.20139813055654154, 0.22317093609218974, 0.2319216586864813, 0.9731197396063049, 0.43115683565095564, 0.2609952186223944, 0.8468551515310532, 0.9760491260954364, 0.32067309162472, 0.18939827523964614, 0.8068226213966257, 0.8409234133738701, 0.9033518678230591, 0.8962761551424242, 0.9145944399943722, 0.8037193154176513, 0.7325030979073517, 0.6162972728548849, 0.8490873085112037, 0.49384771895596036, 0.3610346934257638, 0.9064876127988851, 0.25918091522942344, 0.18259696714997742, 0.16031705352749448, 0.17550342881728498, 0.17322997324111633, 0.15076160842630293, 0.1859360655211144, 0.16567719012078974, 0.17933432570689656, 0.20444848458385, 0.039947953421006765, 0.07301438136057825, 0.06393833176823227, 0.08635209887398465, 0.11293149991708729, 0.10964064805722118, 0.06772618770661432, 0.07853993499886347, 0.05004138105661282]}, "mutation_prompt": null}
{"id": "3f5a9c7d-9edc-44ce-a102-19902316182a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEvolutionaryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.2\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_probability = 0.3\n        self.adaptive_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.adaptive_population_resizing:\n                self.adjust_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_probability:\n                    trial_vector = self.stochastic_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def stochastic_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='L-BFGS-B', tol=1e-6)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def adjust_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEvolutionaryDE", "description": "Quantum-Evolutionary DE with Stochastic Local Search integrates stochastic exploration with evolutionary strategies for enhanced adaptability.", "configspace": "", "generation": 68, "fitness": 0.4431181514935806, "feedback": "The algorithm QuantumEvolutionaryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.9924970159287978, 0.9941660106155206, 0.9936220780294459, 0.9920206017372296, 0.9935687649990106, 0.9936605247990957, 0.9908351265431459, 0.9940310177073535, 0.6289155878727473, 0.6148246008516827, 0.6296469866491337, 0.6717650169239311, 0.7177964153106354, 0.6128588925404508, 0.6630334579306577, 0.6574509923292918, 0.6651910331162842, 0.08298761210664285, 0.08220493638051685, 0.10321231961539545, 0.10218889977529544, 0.09993371038808996, 0.05744261450299637, 0.11908128227060166, 0.10370117176487748, 0.11892985976291015, 0.06606911526533765, 0.058871075909493475, 0.06550958582516997, 0.055208380519791156, 0.050950274810504737, 0.056294674032868586, 0.06825209380880237, 0.05307948371040072, 0.07313087823710651, 0.9912703194363102, 0.9918231666216948, 0.9922755121630046, 0.9913103461245053, 0.9924634112860822, 0.9922187935343206, 0.9924440854241647, 0.9913637674134014, 0.9921959623698142, 0.5097793277674441, 0.4552869327007848, 0.5366268300035828, 0.4655587768703443, 0.47808373220566036, 0.5378500724517918, 0.5122725516950131, 0.434819505500059, 0.3663487949152876, 0.5839020943849909, 0.6376245039985253, 0.61260335730288, 0.6463393039782565, 0.656096571259219, 0.5880146449630338, 0.6857105569516482, 0.6852493860678024, 0.7000703650324057, 0.7762201292973542, 0.7594974942322541, 0.7962114602230439, 0.6203512558476312, 0.6680105316555636, 0.6421707907163826, 0.8719905086999833, 0.7903584629522026, 0.8502414142434278, 0.873843077896589, 0.8528050091958166, 0.7707235682018087, 0.9190883825656145, 0.9133211057777794, 0.8130623200217951, 0.9077286700066814, 0.8454419890413107, 0.8721483271497312, 0.7017332412972903, 0.6263994285670464, 0.6944289925443156, 0.6634591560244038, 0.6624295938373147, 0.633334219755751, 0.571918889729222, 0.5934948745339357, 0.6102162445486745, 0.6351259804017595, 0.539133781725154, 0.582299762411055, 0.4780714163337283, 0.5308581574789462, 0.5639270015780622, 0.57934895515077, 0.5287911911850363, 0.561087840811233, 0.39520363660282887, 0.40343165071521836, 0.4802761598521349, 0.8766267002283827, 0.7015277500762918, 0.7881848790255526, 0.5246409700668089, 0.49789583057926257, 0.4973679074112589, 0.20634142118892007, 0.3330203738224954, 0.3540505460134593, 0.5588644022385848, 0.5922454270105297, 0.5085652901244437, 0.45374413983067774, 0.39753424542293936, 0.4656450265730303, 0.7043737233324884, 0.7009004432171433, 0.7112010543897564, 0.7296861802956067, 0.7106422941205168, 0.7035637073604234, 0.6939011429276518, 0.6685044729869907, 0.6982311365251659, 0.09201413172357165, 0.0696328383052256, 0.08575795074442738, 0.10792278547953715, 0.07893767995357082, 0.10948353913687514, 0.08648244837699526, 0.0801551387568441, 0.08616749281237368, 0.10354918704168725, 0.11891644976807947, 0.1269411566327775, 0.13194623601465738, 0.1274912328299881, 0.12560515517807913, 0.12500289661539388, 0.11334623788744136, 0.11188219649210862, 0.16156694924105197, 0.14644543840550983, 0.19130082131307113, 0.16784981808611132, 0.18151133881239134, 0.1766280783474754, 0.16625696184320826, 0.19318099501529107, 0.19972285729212158, 0.10996277405910337, 0.11338552950293401, 0.09502508229564466, 0.13704117208409006, 0.1121597474238688, 0.1058203295470832, 0.10997944848785357, 0.14298544928448942, 0.12760527605807837, 0.2182814257991489, 0.16772013438895195, 0.17294066828354682, 0.20868502433677416, 0.18935127853688272, 0.2125491779514176, 0.18359540209004277, 0.23833232748875388, 0.21782789961985316, 0.2112438908270321, 0.21107503359492286, 0.2040449050148221, 0.22307847939380776, 0.21021084114468158, 0.20899187677792574, 0.2544582075891778, 0.2004006619380101, 0.2169319263167503, 0.18642259848618492, 0.6842581335988838, 0.8404926504428507, 0.8682348698497542, 0.7329591233568287, 0.614980251070521, 0.4850651459788109, 0.46574622126250975, 0.4718300574309131, 0.5405864467210992, 0.5397944855217905, 0.4923347540248856, 0.43607346166023164, 0.21161284425896354, 0.21201279575073928, 0.5573816270032921, 0.6175152033022651, 0.16643904942326793, 0.17471655164119182, 0.18400816046473056, 0.1921856483348785, 0.1834835942941727, 0.23698566315977254, 0.17262090327936963, 0.18173342449586571, 0.22772180305194323, 0.2001108981287245, 0.06932039227987585, 0.06049683541210471, 0.063815206098491, 0.0920545068984695, 0.08263664793870407, 0.07033495152112645, 0.08814588448476901, 0.0743895541497741, 0.07442600859882553]}, "mutation_prompt": null}
{"id": "c6a9aced-0828-4fca-b054-72f79b8caaf3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedAdaptiveMemeticQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n        self.dynamic_crossover_rate = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.enhanced_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        if self.dynamic_crossover_rate:\n            self.crossover_rate = 0.6 + 0.4 * np.random.rand()\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def enhanced_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.7:\n                result = minimize(func, vector, method='BFGS', tol=1e-6)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.3:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "EnhancedAdaptiveMemeticQuantumDE", "description": "Enhanced Adaptive Memetic Quantum DE using dynamic crossover and improved local search for robust exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.5107918860357442, "feedback": "The algorithm EnhancedAdaptiveMemeticQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9903258126340282, 0.992037543564381, 0.9913671596440711, 0.9889926310641705, 0.9918421270395616, 0.9916141310189669, 0.9892499663705321, 0.9920180383818564, 0.98934035257132, 0.9820858321344909, 0.9665459667902933, 0.9754927291002121, 0.9663935558628118, 0.9737225535980721, 0.97771289824878, 0.9510205871199369, 0.9505506508962736, 0.9703003910294277, 0.05719292260762998, 0.0755804160091067, 0.05262528389003729, 0.11024880197049947, 0.08000167523632395, 0.05210874548509348, 0.05568700449273023, 0.04119484503459314, 0.04846833040791665, 0.0314180859438975, 0.0160051869934017, 0.029640327574634417, 0.02496920461322094, 0.013840027461276772, 0.05348764209214918, 0.018332759412292732, 0.03372694821760902, 0.08677752122078386, 0.9886600392052723, 0.9901656638868902, 0.9893231533669532, 0.9904386566053506, 0.9901933609340428, 0.9901497847325708, 0.989438157595652, 0.9912790350438968, 0.9893247776700244, 0.8671368924587205, 0.8963143180359481, 0.8544022116854812, 0.8661344925662591, 0.7579483541322035, 0.8462397969560685, 0.870223216008744, 0.9423702303681334, 0.8685724261611073, 0.24238659709958332, 0.21858754410758496, 0.3452797271687451, 0.33386645726549746, 0.33221818856756036, 0.3693928000594595, 0.34844555474388117, 0.22361723712674908, 0.34324584962582083, 0.9514368482807333, 0.957548491711454, 0.950160558515066, 0.9248881236323488, 0.8817645544289325, 0.9498633962014262, 0.9647157308958421, 0.8967735160235987, 0.9366275738360024, 0.9473730324107629, 0.9535915845994545, 0.9548370608328478, 0.9469762199609587, 0.9579148368613238, 0.9721823688628759, 0.9424454763366006, 0.9112570154733575, 0.8919243624946556, 0.7467240536933359, 0.7076898951719293, 0.7487524875853795, 0.9059324589336184, 0.859616707672733, 0.8632105067267907, 0.8003045562031332, 0.7672645803927602, 0.8020877681373244, 0.7233726343737814, 0.7849536323402208, 0.8604669957367573, 0.7518537431712475, 0.7421516749858621, 0.7571595185807519, 0.8671784035915213, 0.7204360660780401, 0.8416553808500244, 0.8039151248942956, 0.7935798447764726, 0.8759189056855061, 0.733659500373943, 0.7575261964820597, 0.7417359131201863, 0.5993318044901657, 0.5267742210824867, 0.7386197395669363, 0.5319400713161575, 0.4930697091813515, 0.5013766537506918, 0.5469047628067459, 0.547989567259503, 0.5375805210988955, 0.595375637670361, 0.5928113830084236, 0.6079799265593848, 0.8287719819478542, 0.8404868210128925, 0.8047628327902966, 0.8041508235386983, 0.7909172557494728, 0.8339927339153784, 0.849209913795164, 0.8143479863276778, 0.8139519846226072, 0.06314266101643029, 0.049717352413665705, 0.04236359012597479, 0.07271862089984116, 0.04714134137526349, 0.09019067745563625, 0.0542886344487955, 0.053822162951876584, 0.039675086700055595, 0.10213832177574822, 0.09028146036139073, 0.14181389062103278, 0.13766266535167793, 0.10852972522114013, 0.11951795210876914, 0.09981930236234515, 0.08312228961194124, 0.08832987674053272, 0.13806394819498635, 0.13552475913715611, 0.18200445682149158, 0.1743777012453056, 0.1497091156013186, 0.14432886807193823, 0.1478187029272704, 0.17377774300845283, 0.15451001318270918, 0.07550389881943942, 0.0715049637740518, 0.08475056502932199, 0.10064637839882673, 0.09377449335253296, 0.08606351957957481, 0.10145947827179658, 0.10182428757051531, 0.10047069732007152, 0.17115596718617598, 0.13001820231690076, 0.1454794634694061, 0.14377722464879916, 0.1620055527185923, 0.16975413379469195, 0.16842634690886593, 0.1314481700114355, 0.16963144869844415, 0.216856751196134, 0.2535416453171807, 0.20532979250435124, 0.4458419873173567, 0.7079361523154547, 0.23797208641233114, 0.9750746122235096, 0.22935618355837362, 0.6699503227889969, 0.23110077539293472, 0.8235691571251651, 0.870341026534759, 0.959004221153499, 0.20766562690998058, 0.6772923916294129, 0.18531586664130895, 0.6964418723897028, 0.9012254734872808, 0.4802078189550836, 0.3370469804362818, 0.836276725296149, 0.9170524684992912, 0.6889568489515928, 0.18646485452839856, 0.9302360165897419, 0.7797525717328613, 0.5101656824787104, 0.19425957916460568, 0.16770875256169382, 0.20700380206116442, 0.16752840899924504, 0.1942658273664517, 0.1641774220049842, 0.1928906350350661, 0.1644813554251512, 0.15152604359517519, 0.05123932296560474, 0.05375253210974229, 0.044677890730382974, 0.05819505607454589, 0.055206664853035936, 0.04864161334603234, 0.0475897800757884, 0.07780308666427105, 0.0409911754021427]}, "mutation_prompt": null}
{"id": "5bd02ce2-4380-4324-b5cf-855e10e408d6", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticTabuDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n        self.tabu_list = []\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                if not self.is_tabu(trial_vector):\n                    trial_fitness = func(trial_vector)\n                    self.evaluations += 1\n                    if trial_fitness < self.fitness[i]:\n                        self.fitness[i] = trial_fitness\n                        self.population[i] = trial_vector\n                        self.tabu_list.append(trial_vector)\n            self.tabu_list = self.tabu_list[-self.population_size:]  # Keep tabu list size manageable\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size\n\n    def is_tabu(self, vector):\n        return any(np.allclose(vector, tabu, atol=1e-3) for tabu in self.tabu_list)", "name": "QuantumMemeticTabuDE", "description": "Quantum-Inspired Memetic DE with Adaptive Tabu Search for enhanced convergence by excluding recently visited regions.", "configspace": "", "generation": 70, "fitness": 0.5345327761945551, "feedback": "The algorithm QuantumMemeticTabuDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924670422390527, 0.9915408782662392, 0.992452591997489, 0.992382036906779, 0.9901573909424434, 0.9924124619680466, 0.9923103538515763, 0.987857679233041, 0.9922949230229235, 0.9705042938951913, 0.9794031764515592, 0.9674087610443713, 0.979203185450062, 0.9783932638440251, 0.9777238171595642, 0.9517336008474909, 0.9781286253373136, 0.976687645313368, 0.0548983631915988, 0.11638628817580032, 0.05927908991276287, 0.05806523572463318, 0.056841899386782635, 0.046598031988475896, 0.07086382006817471, 0.05842282201910276, 0.04337670435027574, 0.05869391356978615, 0.03318092192251132, 0.03351324203265593, 0.03217429631455637, 0.050679790247966205, 0.059267364629036146, 0.03248177774814798, 0.0442598257811635, 0.06731436048759354, 0.9902206376455807, 0.9901601100628397, 0.9890534743121823, 0.9885387726093946, 0.9897501560265013, 0.9863029879769701, 0.9880544121868204, 0.9897189779923079, 0.9909668921224063, 0.8320156622589263, 0.8985474641847394, 0.8120382224404042, 0.7024486542893135, 0.919210311735522, 0.7841409989570889, 0.7824008956048456, 0.8231360320930736, 0.790201769993434, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.9152171608503382, 0.954753008377771, 0.8814625306595233, 0.9519356084159577, 0.9461489013513299, 0.9477498029651522, 0.944980808916221, 0.8995067505582149, 0.9684448344323958, 0.961151971406983, 0.9541024127626765, 0.9331115809206902, 0.9628124382417353, 0.9389265910146264, 0.9556271927981393, 0.9675300764200093, 0.9547854068832504, 0.9550489307325515, 0.8088778185214008, 0.7650525538386473, 0.903338676216281, 0.8262641829018775, 0.822911165157705, 0.7981679156551558, 0.7585863167258964, 0.7844928444312685, 0.8801867752298695, 0.7159516486033592, 0.8105831419227991, 0.7421679505298693, 0.8056827567255608, 0.7858780860211418, 0.7342526709945958, 0.8045206568550833, 0.8201744110133983, 0.8200476351492714, 0.7372486412505779, 0.8629753830376348, 0.7912471077888036, 0.7234395994340095, 0.7319910375683505, 0.8091279756042709, 0.5474639542021817, 0.7272920006301427, 0.5897602846660941, 0.5221962775343001, 0.5290628900350594, 0.501407039135128, 0.5442094361273901, 0.54873826743215, 0.5966813535595021, 0.6595011257749013, 0.6448991818202043, 0.6665524321573657, 0.8045191045482666, 0.80890447346724, 0.865915454478525, 0.8071539292211016, 0.7593415285196478, 0.854177078409461, 0.8339398225203464, 0.8040828795163534, 0.83105990602326, 0.09551239279046952, 0.06291346760303362, 0.06856871362184469, 0.050246750020063846, 0.06072250489711495, 0.08857902072343005, 0.05962070090669891, 0.049123442014367136, 0.06441195581762726, 0.09042177290678532, 0.09206000817259863, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10676391538461272, 0.12390635109438808, 0.15870336382753591, 0.14895822825701255, 0.1676473416316694, 0.16759651544860388, 0.15124549708500568, 0.19001291616893068, 0.18298477708973915, 0.18381414793216555, 0.1732930986214014, 0.07512446329586187, 0.06385716305502576, 0.09851590353290773, 0.0853711217825992, 0.08599191181922416, 0.10669186410163434, 0.10344340969851351, 0.10524503704596677, 0.09524283671068556, 0.18625144806273985, 0.14425346195952005, 0.17246198286137182, 0.26724366798813837, 0.16129054987826763, 0.1848001237676724, 0.1672407481970648, 0.1745269941610269, 0.2049960056766169, 0.21968986864249918, 0.21296879153416126, 0.22576344223167955, 0.22792274363614073, 0.2453798803534133, 0.22816230242583502, 0.20408771393039393, 0.9692799791896981, 0.2265709025986734, 0.6258819953769471, 0.9476646084495414, 0.9829421226105001, 0.9616324994512985, 0.9637648348159868, 0.8665198287025921, 0.9467016778459812, 0.8034071893061002, 0.8957194956762872, 0.9123680758234115, 0.8319281705976311, 0.8311799088567222, 0.8260989115486275, 0.8937738115673081, 0.9067246983223624, 0.45155478473370303, 0.8173825844066722, 0.7971558520101192, 0.16355557610037774, 0.16383073639321355, 0.16409177618796034, 0.16827988847869113, 0.1772513192612456, 0.18056258921994717, 0.150639854419077, 0.16672125459066833, 0.1591067270831802, 0.07220832775248032, 0.0748063688967282, 0.05524457693118834, 0.07991122017258989, 0.07594805563031604, 0.07760387768544474, 0.053741832098799236, 0.0702787778017786, 0.0620010760286277]}, "mutation_prompt": null}
{"id": "87bc984b-76ad-4922-b3ed-d182e2e75f13", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveEvolution", "description": "Quantum-inspired Evolutionary Algorithm with Dynamic Adaptive Strategies optimizing exploration and exploitation.", "configspace": "", "generation": 71, "fitness": 0.5350933185036681, "feedback": "The algorithm QuantumAdaptiveEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924670422390527, 0.9915408782662392, 0.992452591997489, 0.992382036906779, 0.9901573909424434, 0.9924124619680466, 0.9923103538515763, 0.987857679233041, 0.9922949230229235, 0.9705042938951913, 0.9794031764515592, 0.9674087610443713, 0.979203185450062, 0.9783932638440251, 0.9777238171595642, 0.9517336008474909, 0.9781286253373136, 0.976687645313368, 0.0548983631915988, 0.11638628817580032, 0.05927908991276287, 0.05806523572463318, 0.056841899386782635, 0.046598031988475896, 0.07086382006817471, 0.05842282201910276, 0.04337670435027574, 0.05869391356978615, 0.03318092192251132, 0.03351324203265593, 0.03217429631455637, 0.050679790247966205, 0.059267364629036146, 0.03248177774814798, 0.0442598257811635, 0.06731436048759354, 0.9902206376455807, 0.9901601100628397, 0.9890534743121823, 0.9885387726093946, 0.9897501560265013, 0.9863029879769701, 0.9880544121868204, 0.9897189779923079, 0.9909668921224063, 0.8320156622589263, 0.8985474641847394, 0.8120382224404042, 0.7024486542893135, 0.919210311735522, 0.7841409989570889, 0.7824008956048456, 0.8231360320930736, 0.790201769993434, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.9152171608503382, 0.954753008377771, 0.8814625306595233, 0.9519356084159577, 0.9461489013513299, 0.9477498029651522, 0.944980808916221, 0.8995067505582149, 0.9684448344323958, 0.961151971406983, 0.9541024127626765, 0.9331115809206902, 0.9628124382417353, 0.9389265910146264, 0.9556271927981393, 0.9675300764200093, 0.9547854068832504, 0.9550489307325515, 0.8088778185214008, 0.7650525538386473, 0.903338676216281, 0.8262641829018775, 0.822911165157705, 0.7981679156551558, 0.7585863167258964, 0.7844928444312685, 0.8801867752298695, 0.7159516486033592, 0.8105831419227991, 0.7421679505298693, 0.8056827567255608, 0.7858780860211418, 0.7342526709945958, 0.8045206568550833, 0.8201744110133983, 0.8200476351492714, 0.7372486412505779, 0.8629753830376348, 0.7912471077888036, 0.7234395994340095, 0.7319910375683505, 0.8091279756042709, 0.5474639542021817, 0.7272920006301427, 0.5897602846660941, 0.5221962775343001, 0.5290628900350594, 0.501407039135128, 0.5442094361273901, 0.54873826743215, 0.5966813535595021, 0.6595011257749013, 0.6448991818202043, 0.6665524321573657, 0.8045191045482666, 0.80890447346724, 0.865915454478525, 0.8071539292211016, 0.7593415285196478, 0.854177078409461, 0.8339398225203464, 0.8040828795163534, 0.83105990602326, 0.09551239279046952, 0.06291346760303362, 0.06856871362184469, 0.050246750020063846, 0.06072250489711495, 0.08857902072343005, 0.05962070090669891, 0.049123442014367136, 0.06441195581762726, 0.09042177290678532, 0.09206000817259863, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10676391538461272, 0.12390635109438808, 0.15870336382753591, 0.14895822825701255, 0.1676473416316694, 0.16759651544860388, 0.15124549708500568, 0.19001291616893068, 0.18298477708973915, 0.18381414793216555, 0.1732930986214014, 0.07512446329586187, 0.06385716305502576, 0.09851590353290773, 0.0853711217825992, 0.08599191181922416, 0.10669186410163434, 0.10344340969851351, 0.10524503704596677, 0.09524283671068556, 0.18625144806273985, 0.14425346195952005, 0.17246198286137182, 0.26724366798813837, 0.16129054987826763, 0.1848001237676724, 0.1672407481970648, 0.1745269941610269, 0.2049960056766169, 0.21941417003172625, 0.21296879153416126, 0.2257605108478079, 0.22792274363614073, 0.2453798803534133, 0.22816230242583502, 0.20408771393039393, 0.9692799791896981, 0.2265709025986734, 0.7964094260525704, 0.9073557378175009, 0.9821218170480415, 0.9616324994512985, 0.9634796540901283, 0.8916953834755309, 0.9467016778459812, 0.8033558432680256, 0.8512643604698018, 0.9498378972515099, 0.841958429484871, 0.8466493015344532, 0.8231105115564934, 0.8937738115673081, 0.9100092355203836, 0.3504282340657978, 0.8171566292233908, 0.8468163691417774, 0.16355557610037774, 0.16383073639321355, 0.16409177618796034, 0.16827988847869113, 0.1772513192612456, 0.18056258921994717, 0.150639854419077, 0.16672125459066833, 0.1591067270831802, 0.07220832775248032, 0.0748063688967282, 0.05524457693118834, 0.07991122017258989, 0.07594805563031604, 0.07760387768544474, 0.053741832098799236, 0.0702787778017786, 0.0620010760286277]}, "mutation_prompt": null}
{"id": "00b74f0b-8dba-416a-9e1e-66a64fde6b57", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.gradient_assisted_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def gradient_assisted_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='L-BFGS-B', bounds=[(self.lower_bound, self.upper_bound)]*self.dim, tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "EnhancedQuantumDE", "description": "Enhanced Quantum-Inspired DE with Dynamic Population Control and Gradient-Assisted Local Search for robust optimization.", "configspace": "", "generation": 72, "fitness": 0.38964991271715627, "feedback": "The algorithm EnhancedQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9926113171963605, 0.9920766160923512, 0.9929851225648635, 0.99290322033383, 0.9906820415047202, 0.9929461402900299, 0.9928504222305841, 0.9884123937862164, 0.9928446129991199, 0.3939987840421322, 0.48047040333783086, 0.5053650984695571, 0.49506356542736374, 0.5950636060823367, 0.549731747780611, 0.5539631674972039, 0.6109048567554678, 0.4880439758290389, 0.10633827848345134, 0.10129087732190489, 0.12571467652907486, 0.08328268922151205, 0.10180554482180726, 0.0707506062658656, 0.1074087688835258, 0.09336880713205842, 0.10311079147929836, 0.05533342796205709, 0.043826014183867334, 0.05975377025236217, 0.055952606629534385, 0.05287825298696047, 0.05682876708982354, 0.06056538288187363, 0.05293863126160503, 0.07281985802029445, 0.9918790141680317, 0.9917895758123261, 0.9906086257812844, 0.9896258884466044, 0.9918069885931314, 0.9868575977739522, 0.9886664775775601, 0.9918323889660968, 0.9925881576486907, 0.40293718091217656, 0.43375117269195473, 0.41556290500385407, 0.4331934008742643, 0.40194329236309945, 0.39476235643790347, 0.35957912540900683, 0.4019893866653349, 0.3038950033135204, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.5621925586133305, 0.6361034340610052, 0.5863669598712207, 0.43409604895557685, 0.45507080681379275, 0.4272644329577123, 0.6208222131377719, 0.6344264985428744, 0.6305421724109148, 0.6137049847314733, 0.618758089057279, 0.6138296500532081, 0.6977608288951509, 0.6908201717053435, 0.6765873969774048, 0.6521630712607492, 0.6952105652939367, 0.6297148911845094, 0.5772091851152688, 0.4747812670556413, 0.5407697176970969, 0.5648879618293227, 0.5028043062803923, 0.5420592288832489, 0.3450841711822368, 0.37112397917413853, 0.38596494887301347, 0.30206737664872196, 0.29076215869749045, 0.26506755411922134, 0.39681467878645704, 0.40104763627158413, 0.4231656682659273, 0.3682638373741717, 0.4572740302786956, 0.4460016512842544, 0.44920243681748073, 0.40919977129151397, 0.48420804995771316, 0.715737964847325, 0.6798410752911503, 0.7465068972113948, 0.48155742968521176, 0.4261927873336504, 0.4793510973742051, 0.44000178875200235, 0.27887233745374507, 0.41572415581611855, 0.46932675315514805, 0.38192886584670205, 0.48650954276386826, 0.36468896963955166, 0.3916509796939731, 0.3416317296441753, 0.6076197579386253, 0.6028740847698605, 0.6025969429376128, 0.5537136845084671, 0.555069098539466, 0.5786583918643905, 0.5837622358876331, 0.5855015968006791, 0.5833703110664512, 0.12139540715954078, 0.10180622574051135, 0.07829472906817425, 0.09930835381244285, 0.0597838258236808, 0.09624596683891995, 0.070601082086297, 0.1105736467727122, 0.0757279272986574, 0.10680219520312606, 0.1405066003553338, 0.12260961686681227, 0.13766266535167793, 0.10852972522114013, 0.11392541981343363, 0.10225686662332523, 0.13170455030492523, 0.12835801412625658, 0.17561856958205024, 0.1530230395848654, 0.18023463563903386, 0.18266456087639327, 0.15956933591150768, 0.21358900010490567, 0.17976684390237463, 0.19240159062418183, 0.19588386035089755, 0.11082640305193692, 0.09570371063710503, 0.13358899988177564, 0.12989731289952866, 0.11646231811833319, 0.11379291447472206, 0.10989074367570595, 0.1201095995225494, 0.11121874426002576, 0.24401318742361833, 0.17882530455109058, 0.22650853232210555, 0.23646745187880902, 0.21006485830727706, 0.18004980737560872, 0.18458364753622403, 0.19948709912401974, 0.24577066774075962, 0.21027376092566996, 0.23216328513365125, 0.21314915179809257, 0.1954649908943048, 0.19562983449444582, 0.18579815817669365, 0.2092125973497866, 0.2030448411291328, 0.21401010616888116, 0.4402817659814411, 0.6633424965308727, 0.6669981355858531, 0.7706698447805037, 0.7337794099875703, 0.5916884827285241, 0.43905571427303036, 0.5287240250708556, 0.5472663351746486, 0.45542788359187814, 0.21922535147680755, 0.5280808590559866, 0.3699328972615117, 0.308347127741198, 0.46494974054338245, 0.28230796745520303, 0.7968337647270285, 0.4543907478730733, 0.18225437758265672, 0.22048781128200845, 0.19914200916015712, 0.1709144863313421, 0.19372025517953861, 0.21833596440234482, 0.1938980830588417, 0.18651442541538377, 0.18312533953849608, 0.08426797164254618, 0.09474360786235536, 0.0849173888844118, 0.09672487814486508, 0.09138241092514132, 0.08373713039434183, 0.07206845613602841, 0.07548372484747656, 0.08132873566622079]}, "mutation_prompt": null}
{"id": "98ee27e2-b5f7-46c3-87b9-1319d2dda6ac", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.dynamic_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def dynamic_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive DE with Dynamic Local Search and Population Adjustment for Versatile Black Box Optimization.", "configspace": "", "generation": 73, "fitness": 0.530463383999299, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924699290637403, 0.9915497001247942, 0.9924524714468377, 0.992382036906779, 0.9901523996461441, 0.9924124619680466, 0.9923103538515763, 0.9878726026396354, 0.9922992999439953, 0.9792546057594815, 0.9696890667277996, 0.9761542814328104, 0.9796251764897833, 0.9771203722551143, 0.9806648673714912, 0.9722594392660261, 0.9717208093178036, 0.9643246235310645, 0.0747980047531337, 0.08217931522846722, 0.07416568564193027, 0.0821867328755872, 0.09166196316564312, 0.0404788641496292, 0.07527100422786703, 0.06395767969420973, 0.06925755514350806, 0.06504512640835547, 0.03420246124974291, 0.04123599054584082, 0.04077727750306115, 0.02771254931929301, 0.025477348743088934, 0.04227186202485278, 0.02789554083156942, 0.04068710728488589, 0.9902201182278778, 0.9901555141957964, 0.9890286855982657, 0.9885387847909041, 0.9897231195382739, 0.986279970513026, 0.9880544194442494, 0.9897281479051285, 0.9909666202810333, 0.8013009616467792, 0.8458248976981699, 0.8285713219918113, 0.8337787673419669, 0.9369538932347607, 0.92629648220406, 0.8208431005988142, 0.7902260929580069, 0.8872745704858362, 0.3970268584264386, 0.33419769782472963, 0.39303347435102143, 0.5587678061120123, 0.4763391408100601, 0.43023606964677896, 0.37280886598553087, 0.4190652852540353, 0.5150888774240253, 0.901300813020462, 0.9544980161306869, 0.9184420874063706, 0.9528572400261083, 0.9482227610891052, 0.9490858015945298, 0.9427501780824729, 0.8578542386072728, 0.9703582125602274, 0.9629638960734004, 0.9566523689748289, 0.9427880464377519, 0.9632069526604485, 0.8796895127615425, 0.9538835185252209, 0.969886973486498, 0.9207091173596771, 0.9596423204973734, 0.9307010952305147, 0.8543840962983646, 0.7632748340214798, 0.8955871928572938, 0.8567745956989654, 0.7961664894229958, 0.9304379290544194, 0.8400355477889623, 0.7764788587400691, 0.8597239072565482, 0.865590194777445, 0.8386455375159099, 0.7702148180164827, 0.7659623444875951, 0.6952674544592916, 0.6524220406875312, 0.813589786293208, 0.7400807621777983, 0.7859986823465335, 0.836865169838471, 0.8042534018362133, 0.7865321643708292, 0.7976084671920924, 0.8208016302719561, 0.547356090854016, 0.5813807026938975, 0.6329830118128715, 0.525349505945919, 0.5247173118558889, 0.5301817587771758, 0.5637094056102001, 0.5461386086201854, 0.5445052360343379, 0.6995117889573373, 0.615418289948508, 0.598566322688018, 0.8194252319526563, 0.8217588534593033, 0.8344315352999773, 0.798908634167764, 0.8101008567306416, 0.8184077705979824, 0.8537180569861156, 0.8304105757068969, 0.8476665556182347, 0.04994803095451095, 0.06890902770481078, 0.07238188937400314, 0.05824135574295741, 0.05767031006872725, 0.07765836009978122, 0.05625182059942291, 0.08263712035813964, 0.1099365621348779, 0.1014843670091472, 0.09155593057298206, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.11229538289601482, 0.10585914874270563, 0.09249228823108824, 0.15641177323397837, 0.15895326727910886, 0.1725909020330808, 0.17186248879269717, 0.15089458879454576, 0.16178524556866392, 0.1728403010693348, 0.17544311253594258, 0.1475757630307748, 0.09209551348208533, 0.06556257071548532, 0.08574405319429845, 0.10261551116103074, 0.08476786375787726, 0.12114220183432967, 0.09437570833268638, 0.09978943901648873, 0.09169064812915895, 0.1657489810003594, 0.24144066034145584, 0.20267042863330087, 0.1543748984927108, 0.16894783701617522, 0.20865966403863667, 0.1492353317756624, 0.12916960994491278, 0.20706367848055474, 0.21273424321431667, 0.3986493557097872, 0.2028017275376085, 0.24461487611117494, 0.21450218803160914, 0.21624508978316015, 0.7052134696029684, 0.2200921657765038, 0.2249095619368242, 0.7107079628808655, 0.9766911007260904, 0.9205024900007704, 0.9657196785999586, 0.9120525721629295, 0.9104281920449111, 0.5818406353609461, 0.9009433341702509, 0.8652822178921529, 0.9027702948864027, 0.8411272603710567, 0.8616583243897952, 0.4693822323176341, 0.9741819238115684, 0.791505912875273, 0.4075491148528383, 0.5596267302502718, 0.7902003938640642, 0.18828104282579927, 0.1645097111694619, 0.18614910101403181, 0.17355206117163546, 0.16332288527466265, 0.14935607783284144, 0.1604655493318512, 0.18734078606520166, 0.18613106457372586, 0.06684420594480067, 0.07048966331936424, 0.06913123196810944, 0.06419975585176596, 0.052150414670537826, 0.07952398869144706, 0.049218498816919976, 0.06860087704456197, 0.08437478780101904]}, "mutation_prompt": null}
{"id": "acb6ebf8-d72c-4c44-ab41-1e0ac55c02a0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n        self.meme_pool = []\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptMemeticDE", "description": "Quantum-inspired DE with Adaptive Memetic Learning and Dynamic Exploration for enhanced optimization.", "configspace": "", "generation": 74, "fitness": 0.5350933185036681, "feedback": "The algorithm QuantumAdaptMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924670422390527, 0.9915408782662392, 0.992452591997489, 0.992382036906779, 0.9901573909424434, 0.9924124619680466, 0.9923103538515763, 0.987857679233041, 0.9922949230229235, 0.9705042938951913, 0.9794031764515592, 0.9674087610443713, 0.979203185450062, 0.9783932638440251, 0.9777238171595642, 0.9517336008474909, 0.9781286253373136, 0.976687645313368, 0.0548983631915988, 0.11638628817580032, 0.05927908991276287, 0.05806523572463318, 0.056841899386782635, 0.046598031988475896, 0.07086382006817471, 0.05842282201910276, 0.04337670435027574, 0.05869391356978615, 0.03318092192251132, 0.03351324203265593, 0.03217429631455637, 0.050679790247966205, 0.059267364629036146, 0.03248177774814798, 0.0442598257811635, 0.06731436048759354, 0.9902206376455807, 0.9901601100628397, 0.9890534743121823, 0.9885387726093946, 0.9897501560265013, 0.9863029879769701, 0.9880544121868204, 0.9897189779923079, 0.9909668921224063, 0.8320156622589263, 0.8985474641847394, 0.8120382224404042, 0.7024486542893135, 0.919210311735522, 0.7841409989570889, 0.7824008956048456, 0.8231360320930736, 0.790201769993434, 0.4110616133922975, 0.40321385996626125, 0.44838901457301283, 0.5062579820700366, 0.4918076538719649, 0.5217027127764773, 0.5407067639688741, 0.519606108498498, 0.5083972963062271, 0.9152171608503382, 0.954753008377771, 0.8814625306595233, 0.9519356084159577, 0.9461489013513299, 0.9477498029651522, 0.944980808916221, 0.8995067505582149, 0.9684448344323958, 0.961151971406983, 0.9541024127626765, 0.9331115809206902, 0.9628124382417353, 0.9389265910146264, 0.9556271927981393, 0.9675300764200093, 0.9547854068832504, 0.9550489307325515, 0.8088778185214008, 0.7650525538386473, 0.903338676216281, 0.8262641829018775, 0.822911165157705, 0.7981679156551558, 0.7585863167258964, 0.7844928444312685, 0.8801867752298695, 0.7159516486033592, 0.8105831419227991, 0.7421679505298693, 0.8056827567255608, 0.7858780860211418, 0.7342526709945958, 0.8045206568550833, 0.8201744110133983, 0.8200476351492714, 0.7372486412505779, 0.8629753830376348, 0.7912471077888036, 0.7234395994340095, 0.7319910375683505, 0.8091279756042709, 0.5474639542021817, 0.7272920006301427, 0.5897602846660941, 0.5221962775343001, 0.5290628900350594, 0.501407039135128, 0.5442094361273901, 0.54873826743215, 0.5966813535595021, 0.6595011257749013, 0.6448991818202043, 0.6665524321573657, 0.8045191045482666, 0.80890447346724, 0.865915454478525, 0.8071539292211016, 0.7593415285196478, 0.854177078409461, 0.8339398225203464, 0.8040828795163534, 0.83105990602326, 0.09551239279046952, 0.06291346760303362, 0.06856871362184469, 0.050246750020063846, 0.06072250489711495, 0.08857902072343005, 0.05962070090669891, 0.049123442014367136, 0.06441195581762726, 0.09042177290678532, 0.09206000817259863, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.10676391538461272, 0.12390635109438808, 0.15870336382753591, 0.14895822825701255, 0.1676473416316694, 0.16759651544860388, 0.15124549708500568, 0.19001291616893068, 0.18298477708973915, 0.18381414793216555, 0.1732930986214014, 0.07512446329586187, 0.06385716305502576, 0.09851590353290773, 0.0853711217825992, 0.08599191181922416, 0.10669186410163434, 0.10344340969851351, 0.10524503704596677, 0.09524283671068556, 0.18625144806273985, 0.14425346195952005, 0.17246198286137182, 0.26724366798813837, 0.16129054987826763, 0.1848001237676724, 0.1672407481970648, 0.1745269941610269, 0.2049960056766169, 0.21941417003172625, 0.21296879153416126, 0.2257605108478079, 0.22792274363614073, 0.2453798803534133, 0.22816230242583502, 0.20408771393039393, 0.9692799791896981, 0.2265709025986734, 0.7964094260525704, 0.9073557378175009, 0.9821218170480415, 0.9616324994512985, 0.9634796540901283, 0.8916953834755309, 0.9467016778459812, 0.8033558432680256, 0.8512643604698018, 0.9498378972515099, 0.841958429484871, 0.8466493015344532, 0.8231105115564934, 0.8937738115673081, 0.9100092355203836, 0.3504282340657978, 0.8171566292233908, 0.8468163691417774, 0.16355557610037774, 0.16383073639321355, 0.16409177618796034, 0.16827988847869113, 0.1772513192612456, 0.18056258921994717, 0.150639854419077, 0.16672125459066833, 0.1591067270831802, 0.07220832775248032, 0.0748063688967282, 0.05524457693118834, 0.07991122017258989, 0.07594805563031604, 0.07760387768544474, 0.053741832098799236, 0.0702787778017786, 0.0620010760286277]}, "mutation_prompt": null}
{"id": "8b89400d-37e5-4046-aa9b-54f950f750e8", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.7:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveMemeticDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Memetic Learning and Dynamic Evolution Strategy for optimized exploration-exploitation.", "configspace": "", "generation": 75, "fitness": 0.512597566506134, "feedback": "The algorithm QuantumAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.38.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922907088602627, 0.9922213325101477, 0.9924435599795397, 0.9926426286203045, 0.9922883137837315, 0.9924124619680466, 0.9925803880410802, 0.9922407915060072, 0.9923073389300886, 0.9762121615779639, 0.9600736105736823, 0.9813121813500296, 0.9796799855109155, 0.9588478797570282, 0.9747695338036979, 0.968407331854438, 0.9799781671520037, 0.9622215979243911, 0.05717084698134278, 0.04896343710987838, 0.0377186541003981, 0.09466583275455853, 0.04418514422571951, 0.08155077818961087, 0.03214946794771334, 0.050648579947792816, 0.05140084647100196, 0.020028634469270057, 0.019556906950415343, 0.026469527401826953, 0.04369397754267268, 0.04153723413055577, 0.03128138517753465, 0.041595139809457726, 0.007065937742333661, 0.03204738043647737, 0.9917530130939292, 0.9909020443323476, 0.9890130054862218, 0.9913779408060296, 0.990948406376617, 0.9898131060321387, 0.9902918399584688, 0.9904669938262873, 0.9904920871808519, 0.8464362283121979, 0.9272768399299474, 0.721885574069426, 0.7954602430758287, 0.9330477432326519, 0.8685878081223519, 0.7857568648491522, 0.8449549919262049, 0.8970730539274628, 0.25833234344804734, 0.2571909558972282, 0.22223683526624605, 0.3041838411090252, 0.3336121437000025, 0.2614708304038964, 0.25806871021988387, 0.3232944747731119, 0.2615554789283686, 0.9666413631280163, 0.9224118493827524, 0.9579917371597432, 0.9669395195643683, 0.9680675346716104, 0.9404990298170604, 0.9564978729235336, 0.9438137438467726, 0.949178182734293, 0.9471960837280017, 0.956551074021072, 0.8441982115372996, 0.9450317744882111, 0.9473684952916976, 0.9515589213184655, 0.9695676861230661, 0.9575448636613768, 0.9391776204306898, 0.8505664915158079, 0.9199979881241257, 0.7316233503246653, 0.9031740507100581, 0.869188964511214, 0.8934074944476653, 0.8573434145086651, 0.8248647590262748, 0.7708078308325514, 0.7468275036052456, 0.8334199207196723, 0.8019953153621082, 0.7443913936768254, 0.7829993373322118, 0.7339014157912569, 0.7323910902609375, 0.7560167369790138, 0.7546820318245083, 0.7832053662122664, 0.8810372911961769, 0.7858846393143111, 0.7316496959921401, 0.8519954352625776, 0.7691215672872831, 0.5073292119857683, 0.5483500254618896, 0.6333056403343611, 0.5180189298650609, 0.5008270876952393, 0.5049181765748759, 0.5475872409159308, 0.5365135131582823, 0.5541569769532723, 0.729907286763323, 0.686222907991497, 0.6759028792392328, 0.8227909081657663, 0.8527655425949718, 0.8706062940148758, 0.8094008163770131, 0.7960331445605973, 0.7797305929889842, 0.8264656384612795, 0.8804243888714418, 0.8043120647604545, 0.055205394141383146, 0.030689185324930257, 0.03723725442073955, 0.05681853825037453, 0.05069438294459627, 0.05587775532883821, 0.08504969131141338, 0.08365942743288979, 0.06146167130061986, 0.12277764785406575, 0.10587032990703171, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.11085155307032113, 0.08862308111351047, 0.08332529408661371, 0.08433089128614013, 0.16892280948679395, 0.15291845399523185, 0.1613932299901244, 0.15985718463581433, 0.15838394954775326, 0.13798565740256852, 0.17859675234355077, 0.17403182400721906, 0.15833610268225695, 0.07130486222042431, 0.06531648198158324, 0.08398582550377798, 0.08086809595821909, 0.09267824650241896, 0.10599000827684213, 0.09889919025564053, 0.09986561969269914, 0.10668880672520842, 0.15217530650594968, 0.16366981679073922, 0.1843788746458882, 0.18046053090775493, 0.15879764382241934, 0.14842743878619624, 0.15876887460803613, 0.13991540388021273, 0.18439453167864672, 0.2124263599521088, 0.21631507440777575, 0.19649159711934794, 0.6604823066734258, 0.22761195824441427, 0.6151356424037862, 0.2076857413618206, 0.24020043588955142, 0.22745620479050754, 0.18647612560871552, 0.9535472008784301, 0.975398953496868, 0.8062408709087345, 0.8952903879129541, 0.8365980349761398, 0.8831615717699655, 0.24350741688154376, 0.6255429299242528, 0.747648536822288, 0.7798614717170365, 0.8642596842221062, 0.3251954449889688, 0.860296472273303, 0.3053403331855159, 0.7517162141092799, 0.7044316706798838, 0.6373854813605102, 0.18339212204639366, 0.18058487586712568, 0.16211881512021176, 0.18678493350259584, 0.1716099558282954, 0.1733983173439474, 0.17968137602450496, 0.24103895632598038, 0.169844575390522, 0.05113599641098099, 0.051034466958536306, 0.05587748632840772, 0.05509880592519645, 0.04628795408811548, 0.07155321031836392, 0.051459419750525925, 0.06813615889349023, 0.055794047937033575]}, "mutation_prompt": null}
{"id": "9d073ef9-7a92-4e7b-8e3c-80b9ac21295a", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9  # slightly increased to enhance exploration\n        self.crossover_rate = 0.9  # slightly increased for higher diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.3  # increased rate for local search\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveMemeticDE", "description": "Quantum-Inspired Adaptive Memetic DE with Dynamic Population Resizing and Adaptive Learning for Balanced Exploration and Exploitation.", "configspace": "", "generation": 76, "fitness": 0.5230900312177731, "feedback": "The algorithm QuantumAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922923263829813, 0.9915427060792326, 0.9924523510191149, 0.9926426286203045, 0.990147848788635, 0.9924124619680466, 0.9925803880410802, 0.9880425840840994, 0.9922612612615166, 0.9748273604319421, 0.9755635809183126, 0.9801331974630931, 0.9793933333477607, 0.9751961047388477, 0.9770852441848764, 0.9594899567257537, 0.9775251932561361, 0.9663152148719745, 0.0600124602529577, 0.08314504639398002, 0.0797171193245525, 0.048372485571244406, 0.061999354445527066, 0.06231313677045458, 0.035474483491626074, 0.0631197425590233, 0.049777103178137105, 0.02374281224121444, 0.026394704739527874, 0.05095867119404751, 0.04584004825153154, 0.05192774159081803, 0.042978107482521066, 0.04808644608204937, 0.022161504268118137, 0.04355421589524744, 0.991753409638755, 0.9901512849389034, 0.9890140234181459, 0.9913298771501236, 0.9897067490622106, 0.9888205820206841, 0.9902942485776457, 0.9897394236583523, 0.9909663499576744, 0.7935324914842685, 0.880256343686145, 0.8509034049874624, 0.7830383389683961, 0.9318355627731634, 0.9471794431488497, 0.9090545521387479, 0.748357644335827, 0.7746120353184522, 0.3192915946519468, 0.4590396968313548, 0.25940135477473014, 0.3293329641586471, 0.41155212818393516, 0.40241658643703393, 0.3520209626620786, 0.4713351235209621, 0.40420591724827337, 0.9715989836394081, 0.9511229718578585, 0.9603100660642362, 0.972961450710139, 0.9439507600335573, 0.9499165848060714, 0.9572738554312886, 0.9451746812254522, 0.9736878921042696, 0.903495238673995, 0.9569647767649851, 0.8160153640699208, 0.9426325593279744, 0.9393451226994344, 0.953859157817632, 0.964325032535313, 0.9302933493799539, 0.9558669143913313, 0.8554785398370528, 0.8130679368368203, 0.7950363915246546, 0.8520143462635602, 0.759266504672632, 0.8123673447861621, 0.831384755267451, 0.7645956641851714, 0.9271795516118633, 0.7685898170105323, 0.7350597473359229, 0.8160288957448067, 0.77853084241742, 0.680326263134636, 0.7597186179285265, 0.8369989866770975, 0.7149503510791142, 0.7799769724436411, 0.8088161235806737, 0.8233327213629316, 0.7793627359502961, 0.691442255657946, 0.791212589263808, 0.7854764814390991, 0.5078639244475196, 0.6189581849627219, 0.7342262998583484, 0.506794155706096, 0.4950747309639747, 0.5053185264634168, 0.5655688200388609, 0.5873712434967848, 0.5401050513679798, 0.6186837586608671, 0.7243863713954366, 0.6798384058556703, 0.8371992245389133, 0.7946149083099345, 0.8329051786450312, 0.7797412813392834, 0.7890781542631797, 0.7797856755795542, 0.8562619458521434, 0.8259025575957384, 0.8244325235024221, 0.056283425418186206, 0.055451314882749236, 0.043261896423223645, 0.06583871835655641, 0.0626272116688198, 0.05157010574783705, 0.061810269950818286, 0.04576276781455968, 0.062237577729590154, 0.12133863996716188, 0.09464965854743546, 0.13038914938427826, 0.13766266535167793, 0.10852972522114013, 0.14936560406574462, 0.10305145754540712, 0.08223370237875094, 0.10310629222708101, 0.17587368207474652, 0.13529825802205264, 0.16143896085887677, 0.14471605191899273, 0.16487769128277907, 0.1781946632890996, 0.1398097388221624, 0.18150765395894763, 0.17487625667118067, 0.07857736527460524, 0.08021191204312617, 0.11688691289725972, 0.09843648265258997, 0.09848870631302975, 0.08920514783581424, 0.10000228070606731, 0.10217276448539869, 0.09631778700312299, 0.14383750584891108, 0.2071828833678091, 0.19656450550894355, 0.1353466348585336, 0.14917318929260748, 0.1431560940652271, 0.12842009120795006, 0.14723153254750398, 0.1996588567335068, 0.20912196722665943, 0.24181387312380398, 0.19669020761326084, 0.22835406930757085, 0.7399484853610856, 0.22073596607030932, 0.7974225129725026, 0.22707060343383012, 0.23337332692943047, 0.8644277532635058, 0.9775835410810076, 0.9639579982672859, 0.6940585213735742, 0.5911125570944445, 0.8230835319384695, 0.2113312059592728, 0.7902021870844353, 0.855294916323361, 0.6153264865075502, 0.8429567129564528, 0.8865353936820293, 0.8566955998157992, 0.893175101063589, 0.7560718377889732, 0.7351842372542251, 0.3938078705924235, 0.9003538817257318, 0.15921904798235686, 0.15979738342151706, 0.16049246239693316, 0.166914754178893, 0.1774188171321217, 0.1762031558778162, 0.17818042104578924, 0.18367923342557968, 0.16599498697674786, 0.045187358655607524, 0.06792021765101597, 0.05372650092415443, 0.045028621159190374, 0.0443739056274286, 0.07565525978366716, 0.06827830421061698, 0.06725823255332375, 0.062052801966217874]}, "mutation_prompt": null}
{"id": "9b68f5d8-a431-4a3d-aabe-49873c37a7c5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveMemetic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.bfgs_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def bfgs_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            result = minimize(func, vector, method='BFGS', tol=1e-5)\n            if result.success and func(result.x) < func(vector):\n                vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveMemetic", "description": "Quantum-Inspired Adaptive Memetic Algorithm utilizing adaptive trial vector generation, BFGS local search, and dynamic population resizing for robust optimization across diverse landscapes.", "configspace": "", "generation": 77, "fitness": 0.5346510874266615, "feedback": "The algorithm QuantumAdaptiveMemetic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9924670422390527, 0.9922213325101477, 0.992452591997489, 0.992382036906779, 0.9922883137837315, 0.9924124619680466, 0.9923103538515763, 0.9922459821692861, 0.9922949230229235, 0.9705042938951913, 0.972266584085603, 0.9674087610443713, 0.979203185450062, 0.975232119438083, 0.9777238171595642, 0.9517336008474909, 0.9789842970144343, 0.976687645313368, 0.05498401587007573, 0.033658369947082045, 0.059015261817159104, 0.07704624209482336, 0.07512977446801672, 0.05482571325644625, 0.05502216255205328, 0.06613370183939715, 0.06187267469386659, 0.04050642953296668, 0.0719009167568262, 0.05350493275716195, 0.027786985901167793, 0.02297970145406636, 0.0441846611761626, 0.041508977237928235, 0.01747708382018731, 0.05837606762207581, 0.9902206376455807, 0.9908880711153166, 0.9912490337350407, 0.9905551847880188, 0.9909221191657159, 0.9897964254207272, 0.9906544759540734, 0.9904993553127464, 0.9909668921224063, 0.8417859319663595, 0.7471545887154192, 0.8215801323785029, 0.7024486542893135, 0.8688573249455982, 0.7757856026086459, 0.7824008956048456, 0.8247461571235212, 0.7995658917247209, 0.39962886418496324, 0.38213622663066094, 0.4087106840274801, 0.47155383251492833, 0.40322172896302044, 0.43857725673964976, 0.402743538625589, 0.49745132776241585, 0.4763745401967979, 0.9152171608503382, 0.8964867047659517, 0.8810037138016283, 0.9519356084159577, 0.9655828340031187, 0.9477498029651522, 0.944980808916221, 0.8701582414778605, 0.970604674534697, 0.961151971406983, 0.9588959271022404, 0.9331115809206902, 0.9628124382417353, 0.9436559212183597, 0.9556271927981393, 0.9675300764200093, 0.9716883053698647, 0.9550489307325515, 0.8032957640911265, 0.7640835164550386, 0.776496753925889, 0.8471501993828863, 0.8714786056182828, 0.8755579333219147, 0.78921890418302, 0.7973008761702863, 0.7680163627722052, 0.7843688252284962, 0.8013682199529931, 0.7683593009075063, 0.7860580142232906, 0.8120375209126627, 0.889750066864051, 0.8004437687370238, 0.7701146559490779, 0.922823138533604, 0.7792758559146625, 0.8719372171208256, 0.8512748880976209, 0.7096660023476058, 0.8038267048835835, 0.7327154410417753, 0.5474996555191152, 0.5520083465817822, 0.5893468880921189, 0.5050835148815493, 0.5164917086371772, 0.5028305744422312, 0.5399412559811734, 0.5457685457090178, 0.5937080082820604, 0.6328905835380079, 0.7532399967548005, 0.7819586855924477, 0.8222252264278275, 0.8744590233746168, 0.9000398971951299, 0.8533476729991688, 0.7900193296558429, 0.7900978298303842, 0.8723498100476202, 0.8417857260669571, 0.8336702577721871, 0.06321344649283256, 0.05695269631748889, 0.09481138732000582, 0.08562993707071676, 0.04664050001743203, 0.06058275725869733, 0.04615806185706406, 0.06256124625705084, 0.07012827103127606, 0.09785339928035486, 0.10502161154747391, 0.11842175776965747, 0.13766266535167793, 0.11104712725802879, 0.10798713552628325, 0.08973492558035634, 0.12170025820459573, 0.11747545486294131, 0.149954169855104, 0.14300129834114217, 0.16763790875517715, 0.16235231725284083, 0.14752328246641955, 0.17026926420129018, 0.15283883421958833, 0.17437027199445, 0.15600306692525956, 0.09171741704576686, 0.09359569103550969, 0.10948213712579513, 0.12456826668858834, 0.09292877189017001, 0.09592751009496236, 0.09021968157027604, 0.10213231147893764, 0.10198863792022006, 0.18778162774567986, 0.15658170714269548, 0.20212032601206043, 0.15182817507315993, 0.14172590665055318, 0.17770693750729227, 0.12850204923706166, 0.152803639883902, 0.18635230424620908, 0.2093277451569796, 0.19974510514773025, 0.22071711017425988, 0.2355604717467975, 0.7557180327384878, 0.21197097593369985, 0.22406412662711295, 0.9482269931884659, 0.2090895149608173, 0.7755230081069892, 0.9218356504941745, 0.9821218170480415, 0.9651172187274304, 0.9229268360695018, 0.7050159591006645, 0.8096569444541887, 0.6987281157344973, 0.8941152762673105, 0.9461624128398509, 0.563283116540803, 0.9289124645096895, 0.8685000776366802, 0.8993067274585943, 0.7116486554687285, 0.752153105214883, 0.9136258921490389, 0.9032449435346415, 0.1707513381199358, 0.19062185101244933, 0.18570891336208062, 0.1713421445121026, 0.17705914608333517, 0.17427202077541748, 0.16216070419005368, 0.2177589557789219, 0.18774067350350887, 0.05484487804999749, 0.06748009155197054, 0.04299082891187578, 0.07108825355168624, 0.06138667410642207, 0.07129169460931117, 0.049325958807341475, 0.07201386281068611, 0.04917108831281547]}, "mutation_prompt": null}
{"id": "d66c3074-36fe-44d1-a55d-606d7a3b0441", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.1\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.35\n        self.dynamic_population_resizing = True\n    \n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.7:\n                result = minimize(func, vector, method='BFGS', tol=1e-6)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedMemeticDE", "description": "Quantum-Enhanced Adaptive Memetic DE with Dynamic Learning Rates and Diversity Maintenance for Robust Global Search.", "configspace": "", "generation": 78, "fitness": 0.5170214032172511, "feedback": "The algorithm QuantumEnhancedMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922942709305868, 0.9922213325101477, 0.9918121964295614, 0.9926426286203045, 0.9922883137837315, 0.9917554897876633, 0.9925803880410802, 0.9922419742921553, 0.9920749711093232, 0.976633398236293, 0.9706962731933751, 0.9555452675431536, 0.9657758672425732, 0.9777903713248741, 0.9816443406452698, 0.9709719685573734, 0.9756664204805116, 0.9748477579867507, 0.06461389629936198, 0.047865210413962855, 0.04558043427602465, 0.04069328837945818, 0.055593771233430234, 0.08038307449536863, 0.04969055458125882, 0.0500072176843509, 0.04632149809138553, 0.015216248134408472, 0.032100220420239745, 0.03785944671947039, 0.029556016461834256, 0.019612897344107094, 0.02343364371901302, 0.03532466488271546, 0.012887585999772466, 0.04312316959886697, 0.9917542212388728, 0.9908987149980142, 0.9907791245663597, 0.9913030914782797, 0.9909450770680859, 0.9908786162504888, 0.9902996472685132, 0.9904700505547966, 0.9903271126683336, 0.7244437231580076, 0.7351700698057325, 0.840384553416932, 0.794485481612304, 0.9400622544007156, 0.8772775710517818, 0.7959355090376474, 0.8135337982874384, 0.7842980536866563, 0.511645697313333, 0.4876560673852518, 0.5448674655960097, 0.6093125523187626, 0.4852608937780081, 0.4767822976630015, 0.47219963381662466, 0.5509102002273496, 0.4890155928313449, 0.9703836356390468, 0.9560577916331151, 0.9596330158584784, 0.9632509797662864, 0.9678569717314297, 0.968072697305361, 0.9596133039045079, 0.9607554843787162, 0.9664258557881158, 0.9677367428400054, 0.9565842230851103, 0.9187936204149294, 0.9433770732880076, 0.9424149070030402, 0.9319531890487325, 0.9629220751135402, 0.9656972937403284, 0.9511992380885088, 0.7665157654635333, 0.8397684000177206, 0.779749588261042, 0.7847477303762351, 0.8538772611582566, 0.8815914841703347, 0.8993011623051402, 0.8251288802982772, 0.7798408073057859, 0.8482346464769729, 0.8264613626289868, 0.8588811292580552, 0.741100535711408, 0.8549028331439307, 0.7835880984988078, 0.7391432828930727, 0.886798862492467, 0.802098210105823, 0.8268972963295863, 0.8609752703644906, 0.810946923260932, 0.7434252223062408, 0.8422633351802351, 0.7938531234779512, 0.5141480621196313, 0.564783626748156, 0.4821304741941752, 0.5027373523988232, 0.5243512207322261, 0.5394108670288802, 0.5616470691214527, 0.5491848499268024, 0.5654190273701692, 0.5914223387501419, 0.6448467674706813, 0.6159521973294333, 0.8405826384403156, 0.8255844263973449, 0.8452847844879405, 0.766113658931187, 0.7720884478498538, 0.85186819550223, 0.8704493746215513, 0.8269719056969767, 0.8465009351956754, 0.042539912576813554, 0.03418761806883175, 0.04753822600430957, 0.061193835456257006, 0.04428774359078502, 0.053860777385369096, 0.0772022431889644, 0.07702982991837393, 0.08066305370146343, 0.09141691131152108, 0.10950928623682266, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08595042386215168, 0.09492659830079142, 0.16048768926118973, 0.15683948787127644, 0.17129947298551984, 0.15740127769002954, 0.15691789758866725, 0.15829073443088815, 0.14205333515668894, 0.17377774300845283, 0.15839466453137097, 0.09214209444636579, 0.08449118331197891, 0.09407226887448394, 0.09225166541017038, 0.09782005987351128, 0.08640695610673377, 0.09669437333466158, 0.10289364820920421, 0.10623357588338167, 0.15196409570579128, 0.19989627520458852, 0.1748121471297872, 0.15984866282204935, 0.12505407881192532, 0.1918762200608347, 0.1648310266596189, 0.16527202669009988, 0.1623230650618157, 0.2044591226052238, 0.20665371966361457, 0.19280310009707646, 0.21464245393737025, 0.19955500349751976, 0.25232796228101684, 0.9303401794301943, 0.880773003090628, 0.21673078198960927, 0.2956816226133886, 0.625115313457931, 0.7718037243428078, 0.7449424997771952, 0.4042184129320131, 0.1876584264340576, 0.20961577450249913, 0.4431673630334443, 0.5867397515305692, 0.8344136353928967, 0.7040054378537399, 0.9408479580745904, 0.20947629025674874, 0.7136405194315127, 0.5376465079990842, 0.8413464403665528, 0.9465640420056896, 0.8464259159677059, 0.16370282012333448, 0.1539633794373909, 0.1656122353926498, 0.19124770953217562, 0.14898338626919705, 0.22482043964411846, 0.1662287509393262, 0.1689023465476388, 0.1730222814177934, 0.04404246318651206, 0.0538324380877937, 0.058666079990418396, 0.04776167500160666, 0.06851388870302688, 0.08437494982069693, 0.05760605267717833, 0.05349782312183193, 0.060373274253944675]}, "mutation_prompt": null}
{"id": "888acc95-69ae-4a60-9e8a-931358c72118", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.7:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.4:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedAdaptiveMemeticDE", "description": "Quantum-Enhanced Adaptive Memetic DE leverages Quantum-Inspired DE with adaptive mutation and dynamic local search for robust optimization across diverse landscapes.", "configspace": "", "generation": 79, "fitness": 0.512597566506134, "feedback": "The algorithm QuantumEnhancedAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.38.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922907088602627, 0.9922213325101477, 0.9924435599795397, 0.9926426286203045, 0.9922883137837315, 0.9924124619680466, 0.9925803880410802, 0.9922407915060072, 0.9923073389300886, 0.9762121615779639, 0.9600736105736823, 0.9813121813500296, 0.9796799855109155, 0.9588478797570282, 0.9747695338036979, 0.968407331854438, 0.9799781671520037, 0.9622215979243911, 0.05717084698134278, 0.04896343710987838, 0.0377186541003981, 0.09466583275455853, 0.04418514422571951, 0.08155077818961087, 0.03214946794771334, 0.050648579947792816, 0.05140084647100196, 0.020028634469270057, 0.019556906950415343, 0.026469527401826953, 0.04369397754267268, 0.04153723413055577, 0.03128138517753465, 0.041595139809457726, 0.007065937742333661, 0.03204738043647737, 0.9917530130939292, 0.9909020443323476, 0.9890130054862218, 0.9913779408060296, 0.990948406376617, 0.9898131060321387, 0.9902918399584688, 0.9904669938262873, 0.9904920871808519, 0.8464362283121979, 0.9272768399299474, 0.721885574069426, 0.7954602430758287, 0.9330477432326519, 0.8685878081223519, 0.7857568648491522, 0.8449549919262049, 0.8970730539274628, 0.25833234344804734, 0.2571909558972282, 0.22223683526624605, 0.3041838411090252, 0.3336121437000025, 0.2614708304038964, 0.25806871021988387, 0.3232944747731119, 0.2615554789283686, 0.9666413631280163, 0.9224118493827524, 0.9579917371597432, 0.9669395195643683, 0.9680675346716104, 0.9404990298170604, 0.9564978729235336, 0.9438137438467726, 0.949178182734293, 0.9471960837280017, 0.956551074021072, 0.8441982115372996, 0.9450317744882111, 0.9473684952916976, 0.9515589213184655, 0.9695676861230661, 0.9575448636613768, 0.9391776204306898, 0.8505664915158079, 0.9199979881241257, 0.7316233503246653, 0.9031740507100581, 0.869188964511214, 0.8934074944476653, 0.8573434145086651, 0.8248647590262748, 0.7708078308325514, 0.7468275036052456, 0.8334199207196723, 0.8019953153621082, 0.7443913936768254, 0.7829993373322118, 0.7339014157912569, 0.7323910902609375, 0.7560167369790138, 0.7546820318245083, 0.7832053662122664, 0.8810372911961769, 0.7858846393143111, 0.7316496959921401, 0.8519954352625776, 0.7691215672872831, 0.5073292119857683, 0.5483500254618896, 0.6333056403343611, 0.5180189298650609, 0.5008270876952393, 0.5049181765748759, 0.5475872409159308, 0.5365135131582823, 0.5541569769532723, 0.729907286763323, 0.686222907991497, 0.6759028792392328, 0.8227909081657663, 0.8527655425949718, 0.8706062940148758, 0.8094008163770131, 0.7960331445605973, 0.7797305929889842, 0.8264656384612795, 0.8804243888714418, 0.8043120647604545, 0.055205394141383146, 0.030689185324930257, 0.03723725442073955, 0.05681853825037453, 0.05069438294459627, 0.05587775532883821, 0.08504969131141338, 0.08365942743288979, 0.06146167130061986, 0.12277764785406575, 0.10587032990703171, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.11085155307032113, 0.08862308111351047, 0.08332529408661371, 0.08433089128614013, 0.16892280948679395, 0.15291845399523185, 0.1613932299901244, 0.15985718463581433, 0.15838394954775326, 0.13798565740256852, 0.17859675234355077, 0.17403182400721906, 0.15833610268225695, 0.07130486222042431, 0.06531648198158324, 0.08398582550377798, 0.08086809595821909, 0.09267824650241896, 0.10599000827684213, 0.09889919025564053, 0.09986561969269914, 0.10668880672520842, 0.15217530650594968, 0.16366981679073922, 0.1843788746458882, 0.18046053090775493, 0.15879764382241934, 0.14842743878619624, 0.15876887460803613, 0.13991540388021273, 0.18439453167864672, 0.2124263599521088, 0.21631507440777575, 0.19649159711934794, 0.6604823066734258, 0.22761195824441427, 0.6151356424037862, 0.2076857413618206, 0.24020043588955142, 0.22745620479050754, 0.18647612560871552, 0.9535472008784301, 0.975398953496868, 0.8062408709087345, 0.8952903879129541, 0.8365980349761398, 0.8831615717699655, 0.24350741688154376, 0.6255429299242528, 0.747648536822288, 0.7798614717170365, 0.8642596842221062, 0.3251954449889688, 0.860296472273303, 0.3053403331855159, 0.7517162141092799, 0.7044316706798838, 0.6373854813605102, 0.18339212204639366, 0.18058487586712568, 0.16211881512021176, 0.18678493350259584, 0.1716099558282954, 0.1733983173439474, 0.17968137602450496, 0.24103895632598038, 0.169844575390522, 0.05113599641098099, 0.051034466958536306, 0.05587748632840772, 0.05509880592519645, 0.04628795408811548, 0.07155321031836392, 0.051459419750525925, 0.06813615889349023, 0.055794047937033575]}, "mutation_prompt": null}
{"id": "3aa6e0b8-0f7f-4ea8-b584-458d021175f5", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridPSOwithAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocity = np.random.uniform(-1.0, 1.0, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.personal_best = self.population.copy()\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_fitness = np.inf\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n    \n    def __call__(self, func):\n        self.evaluate_population(func)\n        self.update_personal_best()\n        self.update_global_best()\n        \n        while self.evaluations < self.budget:\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                self.update_velocity(i)\n                self.update_position(i)\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n                    self.update_personal_best(i)\n            self.update_global_best()\n        return self.global_best\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def update_personal_best(self, i=None):\n        if i is None:\n            for idx in range(self.population_size):\n                if self.fitness[idx] < self.personal_best_fitness[idx]:\n                    self.personal_best_fitness[idx] = self.fitness[idx]\n                    self.personal_best[idx] = self.population[idx]\n        else:\n            if self.fitness[i] < self.personal_best_fitness[i]:\n                self.personal_best_fitness[i] = self.fitness[i]\n                self.personal_best[i] = self.population[i]\n\n    def update_global_best(self):\n        min_idx = np.argmin(self.personal_best_fitness)\n        if self.personal_best_fitness[min_idx] < self.global_best_fitness:\n            self.global_best_fitness = self.personal_best_fitness[min_idx]\n            self.global_best = self.personal_best[min_idx]\n\n    def update_velocity(self, i):\n        inertia_weight = 0.5\n        cognitive_const = 2.0\n        social_const = 2.0\n        r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n        cognitive_velocity = cognitive_const * r1 * (self.personal_best[i] - self.population[i])\n        social_velocity = social_const * r2 * (self.global_best - self.population[i])\n        self.velocity[i] = inertia_weight * self.velocity[i] + cognitive_velocity + social_velocity\n\n    def update_position(self, i):\n        self.population[i] = np.clip(self.population[i] + self.velocity[i], self.lower_bound, self.upper_bound)\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector", "name": "HybridPSOwithAdaptiveDE", "description": "Hybrid Particle Swarm Optimization with Adaptive Differential Evolution and Local Search to balance exploration and exploitation dynamically.", "configspace": "", "generation": 80, "fitness": 0.5057438030973379, "feedback": "The algorithm HybridPSOwithAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.38.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9928677564542999, 0.9928320605787783, 0.9932645051914896, 0.9931692533760323, 0.9933591619697391, 0.9929127888985928, 0.9933674776893944, 0.9933100338484522, 0.9931357811950297, 0.9783993813695082, 0.9782606430803591, 0.9746062586740473, 0.9686687983483577, 0.9768110107830775, 0.9667739082934017, 0.9776530799402089, 0.9713416065251562, 0.9776369935065071, 0.05586974068300243, 0.05402734508421725, 0.07328709810100842, 0.08077995881873234, 0.058617030812039395, 0.061257763631181295, 0.07605970169131893, 0.05738640779236903, 0.057443465256923676, 0.04357906141080625, 0.05306401393677007, 0.04842847311460796, 0.03474914966139153, 0.01458520781500372, 0.05257077116207931, 0.0437395329061776, 0.023377643003603787, 0.029257731053636826, 0.9850513469796971, 0.9899063839924497, 0.9913130819235262, 0.9913355654827807, 0.9900428562892926, 0.9909350392681134, 0.9913554723639416, 0.9899676722378112, 0.9914323722815507, 0.8352539544573958, 0.7828480409372982, 0.7778056854551229, 0.7953962634675673, 0.7823552340054812, 0.9635649293000832, 0.8420369973704931, 0.9446884184789073, 0.9128601671782502, 0.16634831165444375, 0.1860341648199988, 0.18715361887612847, 0.19524823004395875, 0.19875736979366498, 0.17469459816729194, 0.1965138880980356, 0.18772361498435708, 0.15694008515863622, 0.9702324629812973, 0.9598187367575934, 0.9589033589061546, 0.9541816104446524, 0.943165691503091, 0.9493973032766557, 0.9625057270326436, 0.9460375898983273, 0.9549918700944136, 0.9538786027307341, 0.9370657077605892, 0.9085316738227873, 0.9676533319338849, 0.9345120493066158, 0.9270384095927201, 0.9164400606176956, 0.9487005515828608, 0.9476350437944927, 0.7792507278783272, 0.7777575078739607, 0.8354967020129371, 0.8338940075882335, 0.8183638061869423, 0.8252059282377798, 0.7716864815028197, 0.905524039480357, 0.8890961217536327, 0.8296078871719408, 0.7300338778268749, 0.8781905904522929, 0.8322944610371233, 0.8653155206938782, 0.9143587995413098, 0.7451754409870622, 0.77178715473042, 0.946686840510759, 0.8500834470763947, 0.7745115353408714, 0.8337551761129425, 0.7938088411362669, 0.6944916811578482, 0.7108065769280538, 0.5084931243075181, 0.6141545969007467, 0.7920586388833617, 0.5294112632616483, 0.5323844277987931, 0.5129494620830563, 0.6201590689553851, 0.5521343339275326, 0.5660521912551549, 0.6589039033979186, 0.6583961094848572, 0.6273198611280608, 0.8043727760839802, 0.8095764107152653, 0.8273509124452703, 0.8131309921867993, 0.8155996442548007, 0.7816024109841145, 0.8335108543488893, 0.8285320669109536, 0.8327162488882021, 0.11437781060433372, 0.09112281347558382, 0.11016634885034526, 0.04788129556765075, 0.06649541048399699, 0.05746777738852993, 0.08047825336674852, 0.07493602215174544, 0.058039811587668355, 0.10169066839526553, 0.11362862027209553, 0.11842175776965747, 0.09969474379741683, 0.11061231434655783, 0.11069255007449152, 0.09886726333154527, 0.14056875856762585, 0.07972200083751746, 0.14417388183262825, 0.17037887872711888, 0.16413499547107835, 0.18766167850521775, 0.14311376298696632, 0.1455804338489024, 0.1713417560997348, 0.18374249461485948, 0.18081203558294678, 0.12176324738289057, 0.09671691341900024, 0.0991811646931936, 0.08218545271568034, 0.10072705884163846, 0.10056798758585006, 0.1117180606101581, 0.10782654033620509, 0.09548695219205183, 0.14856732089953462, 0.15512192390314716, 0.17001288327947262, 0.18320460458826182, 0.1404903430653225, 0.16032945896280903, 0.19590899228524294, 0.1423268109318262, 0.1876243672470982, 0.21394857146123836, 0.4140410910571385, 0.24777099348332965, 0.7489132438974643, 0.4279378548153143, 0.22551517561374312, 0.3376880242820426, 0.2589175743924398, 0.4671973617281404, 0.958116290615093, 0.20605102375300766, 0.7995900125542275, 0.6992154237657671, 0.19615601457308807, 0.8742307119955244, 0.9335132809154388, 0.18441928446945943, 0.9058251711620998, 0.9527033677753894, 0.20802432409888838, 0.6705409338633743, 0.21230453518564207, 0.8380265589984737, 0.69319642977165, 0.5924861786575548, 0.14728090024557183, 0.20969659021847387, 0.16751846409840399, 0.1609951154238577, 0.17750712500729482, 0.18076661883767464, 0.19574191891081383, 0.1607502649697613, 0.1586769294772239, 0.19337918243502983, 0.16340292521975897, 0.05208161494201646, 0.044774609373640306, 0.040820216709665735, 0.08751253062789077, 0.07047330897198423, 0.06373843767364473, 0.046754482499648864, 0.05152664291906495, 0.04467374391828294]}, "mutation_prompt": null}
{"id": "a6021cdd-cfa6-4f8e-828c-024eb6aa28f0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedQuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.65:\n                result = minimize(func, vector, method='L-BFGS-B', tol=1e-6)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "EnhancedQuantumAdaptiveDE", "description": "Quantum-inspired DE with Adaptive Learning Memes and Improved Local Search for enhanced exploration-exploitation balance.", "configspace": "", "generation": 81, "fitness": 0.4314923872073906, "feedback": "The algorithm EnhancedQuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.31.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.9939673274949316, 0.9941660106155206, 0.9936220780294459, 0.9939838234115768, 0.9935687649990106, 0.9936605247990957, 0.9913807626430428, 0.9940310177073535, 0.6242410080978151, 0.6467816051262669, 0.607721023175348, 0.6464352397744066, 0.6657971897459616, 0.6310614525768261, 0.6989932523802993, 0.6588956806670895, 0.7626903291719782, 0.08201852758365624, 0.0715051806077035, 0.09002694522671739, 0.128462327753319, 0.08780197817626956, 0.1048476748167042, 0.06048162252004241, 0.1021734145826596, 0.07611353683902777, 0.04533603337168457, 0.035205041109448, 0.05198434029117871, 0.05933392236200885, 0.06305266438166235, 0.05480751659318972, 0.061647568952899245, 0.05777797120116124, 0.052267823580499084, 0.9912705109588958, 0.9918086270426492, 0.9922736381767839, 0.9913099726788779, 0.9929654502898537, 0.9922121753667155, 0.992438104109244, 0.9913807613521415, 0.992197803937749, 0.5522691611406799, 0.4840985828904196, 0.48022021773137524, 0.5078937170839228, 0.5011964708250076, 0.5246676181172079, 0.3842980891842198, 0.39617096281134523, 0.3880215969779498, 0.5420529257089558, 0.5049032396657434, 0.45301429667017434, 0.509925671691914, 0.4666802650873144, 0.5733033906704613, 0.49630312604059623, 0.4187118549177241, 0.41570307784041016, 0.8082560614201568, 0.7895569719572862, 0.7904559128727113, 0.7197881834639419, 0.6314758918818271, 0.6012183518063046, 0.8235118816028592, 0.7878158614886488, 0.8500210356730058, 0.8115029916574207, 0.8253307932851854, 0.7848745207477799, 0.9537914174577344, 0.849041583877847, 0.9425523183318227, 0.9336202060772874, 0.8488726592007132, 0.8760302911488919, 0.6851194983220747, 0.6053311335816352, 0.6871716622450014, 0.6973369571146555, 0.6888869806514245, 0.6688813763406471, 0.5531394204691195, 0.6295237628803911, 0.631109496882315, 0.42078069052095646, 0.5281350432929013, 0.5073559304258833, 0.6505865538488034, 0.5306088362979275, 0.5462358147404692, 0.5499089531026256, 0.6529830787544215, 0.6221399666217624, 0.4411082749276054, 0.37802255971892995, 0.42010817507796094, 0.8941678474232402, 0.7842718268302761, 0.7499639484667507, 0.524853512154394, 0.5330974202613863, 0.5294137687535702, 0.3417697716108582, 0.3206907601426253, 0.36293418185728366, 0.5246739232302764, 0.5443354719158503, 0.47923384727507135, 0.473170430349269, 0.16802107226081953, 0.5019719646525863, 0.647675599179736, 0.6552896979879723, 0.7213729254168662, 0.6236301264277366, 0.6430632994722265, 0.6354064416365931, 0.6582238559265643, 0.7715730545760654, 0.6520342337486953, 0.06527854720312665, 0.08855279981300301, 0.10100268011128322, 0.07543150318815439, 0.09121463569812327, 0.08978160183602979, 0.06897460793676824, 0.0663552540676623, 0.0832597871236499, 0.11364227463032317, 0.09130784930790015, 0.11842175776965747, 0.11537691207366574, 0.1092131951933718, 0.12151272569856753, 0.13307851676309368, 0.09707482110261267, 0.10190212740625304, 0.16354806578179526, 0.15030570624202377, 0.16331362143619188, 0.2021703310891514, 0.16249382674689206, 0.1712220987618963, 0.15414975092118455, 0.17846990669684493, 0.1714082995440176, 0.08661954044332854, 0.08950422064290853, 0.09606550409155046, 0.13932126196692662, 0.10621375216828366, 0.09805237547092494, 0.10500807917072397, 0.12993066996706004, 0.1466692058311575, 0.15826017991337882, 0.20074255111708894, 0.22382904840159157, 0.16648641442604206, 0.16815168230670208, 0.19575786002169504, 0.19695852790688706, 0.16200648597722322, 0.21838282739729376, 0.196235836425661, 0.21873962632624877, 0.20441793659875984, 0.21716061882393545, 0.254631070648097, 0.2091616849851704, 0.21738727097328114, 0.23137957107868312, 0.2051866367622298, 0.570385803563233, 0.1997363549551282, 0.19668369886931736, 0.8908823445978187, 0.20155524199228725, 0.7036713184393322, 0.608632751194145, 0.5626195913762437, 0.5821476717541991, 0.6745903972670484, 0.6083459814530796, 0.49664575092586105, 0.4360054281156097, 0.21163751904119998, 0.23954563937562723, 0.7770765720113678, 0.54976188303274, 0.2114184875558247, 0.20333125227774107, 0.1887500738350576, 0.17583949441348978, 0.1969044556689169, 0.17885085115093446, 0.1996865691875993, 0.19019845986753559, 0.22446268516866463, 0.2058421942599309, 0.05487960122050628, 0.07351326791505053, 0.07644620143941028, 0.06504900137821856, 0.0685383833813843, 0.08736761630592105, 0.1082984761549346, 0.06953931562400051, 0.06339520265629894]}, "mutation_prompt": null}
{"id": "1bc39840-24e4-469b-88a6-7f5ba8b700b2", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedQuantumMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.adaptive_crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.enhanced_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def adaptive_crossover(self, mutant_vector, target_vector):\n        crossover_probability = np.random.uniform(0.1, self.crossover_rate)\n        crossover = np.random.rand(self.dim) < crossover_probability\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def enhanced_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.65:\n                result = minimize(func, vector, method='L-BFGS-B', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "EnhancedQuantumMemeticDE", "description": "Enhanced Quantum DE with Hierarchical Memetic Techniques utilizing dynamic crossover strategies and adaptive local search enhancements.", "configspace": "", "generation": 82, "fitness": 0.37312676176932585, "feedback": "The algorithm EnhancedQuantumMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9921764039645483, 0.992037543564381, 0.9918950720565646, 0.9932506759518641, 0.9918421270395616, 0.9918787836460631, 0.9926703994375815, 0.9920180383818564, 0.9917023908049365, 0.5754672807802446, 0.5323913270259983, 0.29760934006336237, 0.5146933159027112, 0.5456975005343588, 0.5205857112462599, 0.5415186041203953, 0.5341008398752443, 0.5014808594594904, 0.05357963785314679, 0.1085665232577181, 0.0757445195188593, 0.0723037025276162, 0.12142844040132128, 0.07651098313465632, 0.07190893014789257, 0.08128309792213839, 0.07190193512702359, 0.07506436116273363, 0.0432966113024964, 0.10241670135975944, 0.05174412165823328, 0.06815061461589045, 0.061917986028393934, 0.04537411480181586, 0.04732294578203966, 0.05437049863166499, 0.9913619928472382, 0.9906678254769434, 0.9910980486302498, 0.9893399806934727, 0.9902247168765461, 0.9910452285721206, 0.9913759818289614, 0.9912787427165258, 0.990577288874321, 0.5272464848823704, 0.5127902954953101, 0.4670390282267902, 0.473916584994182, 0.4613947287222002, 0.43875412188372065, 0.22864198207881736, 0.2806506574207269, 0.3314247458931977, 0.1838415618374566, 0.19393037458692253, 0.1759404375645548, 0.22733609629226825, 0.2254180956162185, 0.22632446961567465, 0.19893461956343395, 0.20503937883944878, 0.18821667268857578, 0.5891132628730071, 0.5904217230825718, 0.6376744274018952, 0.4727771050085776, 0.4193772419380135, 0.41322202450205237, 0.608555084835616, 0.5974140456503649, 0.6367657876421169, 0.6388800019996476, 0.5817418768561434, 0.6383624257948091, 0.7116368594887434, 0.7114752787291749, 0.6668750701770549, 0.7437478785521812, 0.6753906336926427, 0.7008113335608634, 0.4615884862138473, 0.6117659052083873, 0.4967737801772001, 0.5132087422803739, 0.5193073148795471, 0.5703306710641787, 0.49459291802347083, 0.43745902980412876, 0.38430862742811556, 0.22387945218948235, 0.5556979965734192, 0.2753765938839017, 0.5332479318109393, 0.4610818672727983, 0.38846042054617536, 0.4464795375209495, 0.2510932725049545, 0.44110570326039555, 0.4439166424990364, 0.5065655613439557, 0.41147287003688193, 0.6711259206184279, 0.7381036469610289, 0.6953480687958367, 0.511871079723135, 0.4337051916352964, 0.5404479219264878, 0.39194644434673465, 0.28023199401355214, 0.41390931816954046, 0.4084977118584433, 0.42428791805683996, 0.45473799013804106, 0.3505492404558922, 0.2846923233022467, 0.3876299545675219, 0.5732678933958602, 0.5636875071886125, 0.5560576521441287, 0.5104071017702148, 0.5269167585576648, 0.531872733477443, 0.574436039086865, 0.5584821584908486, 0.5318952782366486, 0.07241401357439425, 0.057767957707895556, 0.0616117196848851, 0.06941409123729714, 0.05847585436610847, 0.12569622114070467, 0.07467480166676632, 0.04642675672275942, 0.06389071258955514, 0.10679346173149096, 0.10330319775295305, 0.11842175776965747, 0.13766266535167793, 0.12449660297725418, 0.10798713552628325, 0.11998901902912151, 0.09561751418766706, 0.11005035111276029, 0.21588349301069565, 0.1475695720366108, 0.17364871877777133, 0.15625551632980694, 0.1543110775715706, 0.17784779708374832, 0.1675895440567602, 0.17437027477128486, 0.15299859706914887, 0.08958220291899832, 0.09729222634495305, 0.12199131034115929, 0.11401704197595541, 0.09277933567567054, 0.12165659126293737, 0.1117284124092317, 0.10450867600175584, 0.11238039890194174, 0.1938241199982722, 0.17207679984482493, 0.19396917888001608, 0.21355561693596747, 0.1857214670288928, 0.1999398917398284, 0.19440102937567294, 0.2535773034273632, 0.1941348404096196, 0.20827635241874776, 0.25869429780060405, 0.21015277230409968, 0.22985038817747339, 0.211367136999846, 0.20266158350392927, 0.22338933809515793, 0.21433720810583823, 0.22043033486693775, 0.4603158036690742, 0.5762332329558627, 0.19775008057593757, 0.5620289243522566, 0.7471967073465458, 0.7784487252321172, 0.22794756793270032, 0.5061182481181735, 0.3953418757636554, 0.43297590536082375, 0.39249690741097043, 0.46624831650645193, 0.3722871937875806, 0.310187402488605, 0.5158187101354486, 0.6885863501134115, 0.5850625805424797, 0.44992809688591306, 0.1766135837438776, 0.18450798353334352, 0.1810633105635926, 0.1810050540541468, 0.19129087811640744, 0.17205478020066878, 0.2116929384231374, 0.22211743256303784, 0.1806332252248316, 0.07197914270077233, 0.11316594507939959, 0.07304001268224769, 0.07267874428929777, 0.07144175503421635, 0.07358762686592146, 0.08004126058084016, 0.06985642631614153, 0.06639821741018315]}, "mutation_prompt": null}
{"id": "852321c2-b94e-437e-b1da-5c53a8eda54d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridQuantumDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.7:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "HybridQuantumDE", "description": "Hybrid Quantum-Inspired DE utilizing Adaptive Population and Memetic Strategies for efficient optimization.", "configspace": "", "generation": 83, "fitness": 0.5231308769774956, "feedback": "The algorithm HybridQuantumDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.9934294651942313, 0.9936230330933614, 0.9925973364001389, 0.9934550506184824, 0.9935687649990106, 0.9928027206173271, 0.9904196528291066, 0.993165230578697, 0.9650176214537372, 0.9785474749240173, 0.9746184631887795, 0.9792621722039044, 0.9686503477680748, 0.9747606916001403, 0.9690818840338092, 0.9812183579168893, 0.978212961690327, 0.06205431869436362, 0.056761721875163706, 0.070592815713577, 0.06045882361188415, 0.043195603139935534, 0.05474496381266325, 0.05739929500737939, 0.07152207895515983, 0.04070585552452355, 0.03213993936921011, 0.03645060497004127, 0.056710678313348084, 0.050231734805404216, 0.020033040157484194, 0.04734242512720499, 0.06383872883772512, 0.04076983051882366, 0.04265104240346229, 0.9907121772324056, 0.9918729031278696, 0.9922472423746135, 0.990828836069874, 0.9929658437232555, 0.9921817633260632, 0.9924581734137127, 0.9914051399668967, 0.9921775874064694, 0.8811365017223209, 0.7398972672470137, 0.8234926786330842, 0.9614215574048973, 0.8365365005542406, 0.862314618841699, 0.7724164055617952, 0.778943532691339, 0.7678577676275795, 0.5366127605944833, 0.49715231240176316, 0.44641654204753234, 0.5025752444646535, 0.45751650314922265, 0.5630644771019317, 0.4870075103537862, 0.4098894571407382, 0.4081582162024241, 0.9619352934128622, 0.9164848551356228, 0.870847725951065, 0.9510230392051221, 0.9384573080688597, 0.9489539337159829, 0.9446632163115656, 0.8703501241396665, 0.9654757048615954, 0.9548196927373103, 0.960822774738596, 0.9652962200042198, 0.9124853582435108, 0.954628589161155, 0.9571049804836478, 0.9400068557417992, 0.8582810725593277, 0.9583255724483607, 0.7794594293505188, 0.7190638098858927, 0.7747538189405383, 0.8710380911925819, 0.915415175628655, 0.8916177033686589, 0.9501622100154595, 0.8086071241648816, 0.7772880418454943, 0.7130385812515614, 0.7483090468839004, 0.9003978590290606, 0.7890672435128788, 0.7774243067159963, 0.7401467056504628, 0.7366571108612288, 0.7999047679975044, 0.7760508066845044, 0.933618276823196, 0.63034347439752, 0.8442809036542818, 0.816267521432568, 0.7922224247140645, 0.7269450931265231, 0.7697873939656907, 0.7392089492749094, 0.6851744422912138, 0.5392907756004175, 0.5063718910786624, 0.535622187404577, 0.5450899892826246, 0.5411133644513397, 0.5715612376487771, 0.6427171039262642, 0.683666236204681, 0.669622853158321, 0.8110107503281236, 0.8301541510059298, 0.8442984982008566, 0.8009607196851328, 0.8177727885267736, 0.9025341043258304, 0.8528361569207203, 0.8670088966340559, 0.8204120073465702, 0.03951037358284626, 0.03233434702087212, 0.03871545557511835, 0.056448472669610394, 0.06581739926774222, 0.055398833789630064, 0.09565144424977079, 0.03895631436141245, 0.0654327690651949, 0.11335146307154209, 0.08609370886951495, 0.11842175776965747, 0.1084662210346311, 0.10907335582268773, 0.10798713552628325, 0.09405666521410017, 0.08809959271638002, 0.0884792193061954, 0.14214104460670607, 0.13583581613807905, 0.16949836181420652, 0.15629115782185599, 0.15373524405815953, 0.16346725932296757, 0.13895543486587358, 0.1840770856566839, 0.16137577947968906, 0.08928843606461001, 0.09807048359763415, 0.09209083921632266, 0.11550620781633536, 0.09075926725395489, 0.08444705061853586, 0.0934634408614805, 0.09995068346233515, 0.11241162582498343, 0.14799798584856472, 0.13260844706487973, 0.1648822401790354, 0.1427243679770307, 0.19537678611827158, 0.19666096987347714, 0.2209437300356517, 0.1389975054204775, 0.15625501590895707, 0.22484304806152955, 0.6608339478117828, 0.22601748907910146, 0.22514593799159321, 0.22772790606924664, 0.3783857106093146, 0.21873628465176242, 0.7186734357570791, 0.2240089019355479, 0.3904937684162131, 0.7775716888963362, 0.49642072788042624, 0.936333098864686, 0.799363412080053, 0.98405923006083, 0.7498407004196724, 0.8522287982358954, 0.9354734201327555, 0.8339008745614123, 0.9051590715777283, 0.8246002356337349, 0.8907435707995343, 0.41059267009247713, 0.19907575860008542, 0.9353754043726012, 0.20080042351785665, 0.26264277597962815, 0.1722414127600096, 0.15011490330746524, 0.16271069277445493, 0.17168496660291332, 0.15697520517662011, 0.16349230409041737, 0.17766329930411173, 0.17795742244668455, 0.16442432883756553, 0.03876329136728329, 0.07230553667208728, 0.0591525799576762, 0.0666241474285878, 0.052271101713715185, 0.06030619799293668, 0.07479708088335923, 0.05307109137311106, 0.061774300177659835]}, "mutation_prompt": null}
{"id": "1e1c4501-bb8f-4645-b9e1-603c8b8c1023", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumAdaptiveMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4  # Slightly increased for enhanced exploration\n        self.scale_factor_high = 0.8 # Slightly increased for enhanced exploration\n        self.crossover_rate = 0.9    # Increased for better information exchange\n        self.evaluations = 0\n        self.local_search_rate = 0.3 # Increased local search probability\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.85  # Adjusted ratio for more gradual population resizing\n        if self.evaluations > self.budget * 0.5:  # Start resizing later\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumAdaptiveMemeticDE", "description": "Quantum-Inspired DE with Adaptive Memetic Learning and Dynamic Scaling for efficient exploration and exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.524268865238078, "feedback": "The algorithm QuantumAdaptiveMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9922945188293151, 0.9915497135289184, 0.9924436706008603, 0.9926426286203045, 0.9901466174117165, 0.9924124619680466, 0.9925803880410802, 0.9880434805296252, 0.9922612612615166, 0.9761602783159132, 0.969386116175076, 0.9783085198098611, 0.9720754223285933, 0.9654403164678481, 0.9769969168344382, 0.9529145369058774, 0.9737290344305071, 0.981582966299209, 0.04646947874549445, 0.05678065026690016, 0.08284480588226384, 0.040743423718558325, 0.056062232195565276, 0.0425036249278643, 0.03706853723386938, 0.07309020349271655, 0.043293754633199066, 0.04462598419819408, 0.030000586536348628, 0.01952253411123639, 0.027714033802955784, 0.022976903295637174, 0.023855144557555663, 0.07433939737711537, 0.03711797885751511, 0.017048066378695825, 0.9917548136336751, 0.9901500737295158, 0.9890272159063634, 0.9912927268532221, 0.9897021424325522, 0.9888206851064436, 0.9903040806890484, 0.9897440969541899, 0.9904927541596984, 0.8779627036758039, 0.7327920551160869, 0.757747332109471, 0.9065641461089716, 0.8811693225911589, 0.8351641063033071, 0.8191904045760645, 0.8506308665918096, 0.9054147671555016, 0.37169485069001473, 0.30957229057516933, 0.4017591445970714, 0.4714686138170594, 0.48572978066720474, 0.35216031705345896, 0.4030856537651094, 0.3055205382277095, 0.37573241389593437, 0.9486566920928097, 0.9518209046193405, 0.9542537882038212, 0.9447680379944086, 0.926272219159905, 0.9425113778841545, 0.9589919709894977, 0.8337053952016332, 0.9445468880033779, 0.9648628922610912, 0.9564372621584127, 0.8159672598857359, 0.9462079079960264, 0.9383193435079374, 0.9495569780940095, 0.969421578502526, 0.933726465383453, 0.9356014041664654, 0.7814945979272334, 0.8393799332003046, 0.7999377360559909, 0.8732525583593662, 0.8182013056624131, 0.8635979125783945, 0.7990946113577313, 0.7946724039113886, 0.7726140017476879, 0.958548696489956, 0.7365932379253453, 0.7709886587967064, 0.8251466956247326, 0.8812652748392671, 0.8364150271325352, 0.7773536724103816, 0.7982725613222905, 0.714870754202481, 0.8630351044374963, 0.8030021941837605, 0.8064805638969346, 0.7083421849266096, 0.7849492411610512, 0.8454361974151643, 0.5126867512203218, 0.6462547067922446, 0.6001285692122651, 0.5191176032619196, 0.5130743908710464, 0.5125313756757701, 0.5675396211151345, 0.5633841963212476, 0.5471845160157246, 0.6786013268973055, 0.655457307113907, 0.6464647860629726, 0.8175128041989351, 0.7873106522315985, 0.8419173121100689, 0.813951071817614, 0.7808274427905212, 0.8214877770567589, 0.8496403847208764, 0.8545321572071255, 0.8184461475032397, 0.06826963079865966, 0.06859371091461541, 0.06960039989207312, 0.0641980678046602, 0.05362283660686351, 0.0684593760588601, 0.03705444569990013, 0.05685152352855494, 0.0715681746149639, 0.09636452243549154, 0.13736102902865222, 0.11842175776965747, 0.13766266535167793, 0.10852972522114013, 0.14796060423672952, 0.10885400935198031, 0.09092206073829368, 0.10224740907786656, 0.1514808289701527, 0.16099798824513434, 0.17248299222055252, 0.16471175899775714, 0.1479779320230067, 0.1418798981488284, 0.15586234295327683, 0.1867690351955168, 0.15917853295077455, 0.08619019299165775, 0.07679951789567663, 0.08695374261432098, 0.08030635681998666, 0.09246031190533244, 0.10388842711731283, 0.09773171001847436, 0.11158469356037326, 0.09485489862471275, 0.16041974696657957, 0.13590124676985083, 0.15955625810308371, 0.1373035778933479, 0.19812736560417143, 0.1635363662575734, 0.2148233496709948, 0.17463119512768155, 0.20776381426712986, 0.21186321763180116, 0.7701606889634489, 0.19188243300395869, 0.5925097254167434, 0.22647172999397813, 0.2179379586737228, 0.24507632399455603, 0.21033081850305335, 0.22745490759436626, 0.6895348515077626, 0.9583746861358696, 0.9762446416583413, 0.7114064470261792, 0.6563489310326427, 0.774544226417634, 0.7492068438279995, 0.7270714990570002, 0.44759493240289105, 0.7318484414063109, 0.9215977008882964, 0.8219531955304309, 0.7765715323764179, 0.8213551215418815, 0.6051324213586924, 0.7588653507430202, 0.7833296008647812, 0.8212389636293983, 0.15562618610871437, 0.17982834402382397, 0.16675899333286193, 0.16273902037899424, 0.16024318075227462, 0.19411098839455498, 0.18668674548833664, 0.17768669843367202, 0.16433892806114525, 0.06821338231417395, 0.06745233453171495, 0.05306141866125946, 0.07681049478793778, 0.07374445385230866, 0.08511210486516652, 0.06147445535154672, 0.05957133937996373, 0.07369412306287582]}, "mutation_prompt": null}
{"id": "890c519f-b214-4902-82e1-a5eab21b1f72", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.6\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive Population Resizing and Enhanced Crossover Strategies.", "configspace": "", "generation": 85, "fitness": 0.5353128149072368, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.37.", "error": "", "parent_id": "8f1a0af6-19d1-4e5c-9bba-34d7f45afab2", "metadata": {"aucs": [0.9932338847248454, 0.9919456490914976, 0.9936209853613711, 0.9925978160975526, 0.9920206017372296, 0.9935687649990106, 0.993120456420088, 0.9899431600664471, 0.9930700858899028, 0.9721460734725079, 0.9583593052485322, 0.971506221892456, 0.9799723491359801, 0.9808647433746424, 0.9807606755258661, 0.9758877942279423, 0.9802349048207267, 0.9745634516702667, 0.07896105925456265, 0.07264123718670545, 0.08796840251661087, 0.11480602821779007, 0.05707420842232547, 0.08461266821296864, 0.10410161219351699, 0.07105813549306095, 0.04654350051425149, 0.03700110490388253, 0.04932055954378178, 0.05913372186905852, 0.03161250678932537, 0.03195770552342614, 0.025426552778656908, 0.03094277761281261, 0.06432927510718633, 0.04105205029368064, 0.9907439331505291, 0.9918927295075746, 0.9922379605624153, 0.9913000543688775, 0.9929649330543696, 0.992185810983401, 0.9924581732716244, 0.9914045478060918, 0.9921768703243018, 0.8626348355438025, 0.8121548348671254, 0.7092503116601895, 0.7911353550918729, 0.884436164198451, 0.8645401357344565, 0.8997622510556413, 0.8486310919556904, 0.7726348802387798, 0.6423808186141278, 0.5476786171871275, 0.6722030798702898, 0.6539066309954246, 0.5828031683221744, 0.593544528092286, 0.5897872572475169, 0.5419489013071455, 0.6561874777243062, 0.9614898561090172, 0.9600156341957182, 0.9582625182721823, 0.9579502082001659, 0.9434536039873448, 0.9524968449630993, 0.9498794115455501, 0.8768776694494226, 0.9670770525921277, 0.9422691430226152, 0.9434901914564519, 0.9643997106814811, 0.9555501813901855, 0.9624411540716225, 0.955220931672171, 0.9390652821018421, 0.9187338853895184, 0.9477457809475576, 0.9710868064712358, 0.8409740914849049, 0.7237058235520266, 0.8668507565441566, 0.873087812721702, 0.7968548411345859, 0.8471938230081776, 0.7995246055131403, 0.8068602876125113, 0.7802146016020681, 0.8398118662279581, 0.7754691577091667, 0.7513509451642946, 0.7034253568735482, 0.7671318238511387, 0.8172236363282981, 0.7914126414225748, 0.8025971446942655, 0.8347655849274824, 0.7785617090428997, 0.8595774874494149, 0.8772462265182807, 0.7922775610124162, 0.7420630387541032, 0.5967393110416357, 0.7173990420328034, 0.5610007214969538, 0.5071860430702826, 0.49792558453662883, 0.5058427368836751, 0.5391015583375114, 0.5564988966051962, 0.557476782626638, 0.6777427173641799, 0.5997652938712288, 0.696522763650989, 0.8206299739499059, 0.91171424007576, 0.8434274752155878, 0.9003364460471204, 0.7760340577673511, 0.8202819406261472, 0.8107328262063822, 0.8416223301823144, 0.8287603467002775, 0.09046123895553315, 0.043162582868201516, 0.07173173476564587, 0.07239750011429857, 0.05264368324756219, 0.0735211463550337, 0.11731291575385572, 0.0900951425142581, 0.05087837722067379, 0.09304919824113644, 0.09505273385180057, 0.11997977701132712, 0.10295044131490028, 0.1132617252674214, 0.10798713552628325, 0.11960590562092688, 0.10469869000409415, 0.11098675513854572, 0.16556972456796215, 0.1844621523724962, 0.1667663782743084, 0.16893979207505871, 0.17496161360729767, 0.15453420102327842, 0.17613789913264077, 0.19988532659000602, 0.16526283851096157, 0.10780818854658414, 0.08396672494674473, 0.08985753499112104, 0.10352146887526925, 0.08216991259063511, 0.08909457622263306, 0.09980916992145061, 0.10895645541746213, 0.10137578251221879, 0.20241923766957626, 0.13617665233690968, 0.17239177987258003, 0.19608075758546606, 0.18269146246478507, 0.13150313167102545, 0.21759552388064052, 0.1366707216240195, 0.18952133960080453, 0.20567532366774532, 0.756654715442563, 0.22339888602215474, 0.25558449136591876, 0.2119617827968011, 0.20149601040828458, 0.7433249120013701, 0.7793546124595901, 0.19672989540544983, 0.8527699611716377, 0.9277360504358243, 0.7559306172369816, 0.8938827194076362, 0.8360818176028475, 0.8580885968341478, 0.7545731003323489, 0.653088127538561, 0.9659301238971044, 0.8548732197929481, 0.3134767949690931, 0.6487020013719492, 0.8186620690930936, 0.5910966448822761, 0.20726371021091095, 0.7078482787680818, 0.19795299393535648, 0.6951811976212268, 0.16564878449910214, 0.17819554944819171, 0.1789478414052128, 0.1802817024176795, 0.1729000768239397, 0.16441966319972767, 0.1586297242261142, 0.17774463958648412, 0.18738434453867936, 0.0731034359185635, 0.07474104876419918, 0.07176821793289911, 0.061541461556825605, 0.07532141913996349, 0.08743324927361695, 0.06811849527991765, 0.0602844279204533, 0.054505091821189344]}, "mutation_prompt": null}
{"id": "d88eb0d0-c82d-4866-bed6-afaa0af3cc6d", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.8  # Adjusted upper bound for scale factor to intensify exploration\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.35  # Increased local search rate for intensification\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-6)  # Adjusted tolerance for precision\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Enhanced Adaptive Strategies and Local Search Intensification.", "configspace": "", "generation": 86, "fitness": 0.5287134929536266, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.38.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9914563024448988, 0.9936230330933614, 0.9925973364001389, 0.9920206017372296, 0.9935687649990106, 0.9928027206173271, 0.9902690236303603, 0.993165230578697, 0.9650176214537372, 0.9771504510538246, 0.9746184631887795, 0.9792621722039044, 0.953713246388853, 0.9747606916001403, 0.9690818840338092, 0.9812183579168893, 0.978212961690327, 0.054381657156932106, 0.05469573524726368, 0.07539066085142243, 0.05196777418061416, 0.06780808397427174, 0.04277035096661386, 0.05554817407703361, 0.06982473260448097, 0.04033561864052715, 0.03419088561308725, 0.023507355428754262, 0.04073703161731268, 0.03119587895269582, 0.016184147777147828, 0.006600802708295439, 0.035344742578606425, 0.026369771057681124, 0.02783209244532625, 0.9907121772324056, 0.9918729031278696, 0.9922472423746135, 0.990828836069874, 0.9929658437232555, 0.9921817633260632, 0.9924581734137127, 0.9914051399668967, 0.9921775874064694, 0.8811365017223209, 0.8087454793245668, 0.8234926786330842, 0.9614215574048973, 0.9105184163562519, 0.8494889155819296, 0.7724164055617952, 0.9063397579459204, 0.769130613628906, 0.4605952180522529, 0.4838143807109979, 0.35661239756862273, 0.5796953540788383, 0.47677584402507356, 0.4849529248999668, 0.45839391897691284, 0.4191865498864149, 0.4927430844353847, 0.9619352934128622, 0.9564716516152207, 0.888962533905144, 0.9510230392051221, 0.9423943168904942, 0.9489539337159829, 0.9446632163115656, 0.9499946332992262, 0.9654757048615954, 0.9548196927373103, 0.9568272412925125, 0.9652962200042198, 0.9119696891252566, 0.9439867429820641, 0.9571049804836478, 0.9400068557417992, 0.9553325806687448, 0.9583255724483607, 0.8186003367606187, 0.7527055858299482, 0.7747538189405383, 0.8770812950642328, 0.8091556745953936, 0.8782343533128085, 0.7600243535597329, 0.7758713149871678, 0.813619123325795, 0.8051577827186246, 0.8124546226079405, 0.9003978590290606, 0.7579351926532115, 0.8075076118188943, 0.7448555316344261, 0.7389691233123705, 0.7610043386725109, 0.7632395380227721, 0.933618276823196, 0.6307680930487076, 0.8703990268840165, 0.8148533273271206, 0.7840335941369493, 0.745976515977306, 0.7697873939656907, 0.7392089492749094, 0.594821103466775, 0.520430872432128, 0.5264131140118877, 0.5025712149548818, 0.5467116982165887, 0.5589961840417828, 0.5569487345248691, 0.6338400730653765, 0.6381768079045599, 0.6819497616421198, 0.8078925014351719, 0.8210744008941426, 0.8178369656468056, 0.8419254542145048, 0.7767995803026672, 0.9086187407076628, 0.8329870236885151, 0.8596280436471968, 0.8235075518385012, 0.05158457680075701, 0.04089007494313923, 0.08216847327344201, 0.12220645078673764, 0.051997749924200254, 0.050497520525909945, 0.050877563289614014, 0.04134288391238372, 0.05368450644715739, 0.08675528194674698, 0.09279856286879007, 0.11842175776965747, 0.11723348821558321, 0.11920520038816051, 0.10798713552628325, 0.09551601984504199, 0.09929879320382173, 0.0911419117040505, 0.13691665385652563, 0.13405131687048433, 0.1613932299901244, 0.16125924717608653, 0.1849159767959604, 0.16284667736110092, 0.15394026735126476, 0.1743552375456553, 0.16114361504011632, 0.06692890309558153, 0.06450438771264766, 0.09209083921632266, 0.09973531781148837, 0.09046790385977332, 0.0868457854395781, 0.0837317855149382, 0.10215989890835842, 0.0910833604969612, 0.15427066917835186, 0.16267298489778348, 0.18082040555957046, 0.16212884110753345, 0.13316098308827318, 0.2010301776149871, 0.13150057472159793, 0.17413724839914035, 0.20344572350189993, 0.2266110572149559, 0.2145841266886328, 0.21642944347991466, 0.23660801206836835, 0.9165119556682207, 0.20202910120285122, 0.20387535081209796, 0.2166473390757252, 0.661842650227876, 0.8087432351605803, 0.1941649457588952, 0.9195234453401153, 0.9620723441320019, 0.9167751706863773, 0.98405923006083, 0.804397226091132, 0.8078269776097771, 0.6366798918820478, 0.7833930718623171, 0.8591641688370576, 0.8630534396474114, 0.8915709461474577, 0.6719327982392418, 0.20442566138802154, 0.672322178649116, 0.7376527462335899, 0.8806599562762156, 0.15139122813589534, 0.1975008929762061, 0.17434459426601456, 0.17766405160940923, 0.17634315093808095, 0.1635490259459229, 0.17946368419547798, 0.16250215894844, 0.16356993999700065, 0.05829065856373672, 0.06577712607809627, 0.052416868077542644, 0.07602232823726696, 0.05545542583015972, 0.07585242640102352, 0.06038408354073377, 0.05148444840678601, 0.07374568322043962]}, "mutation_prompt": null}
{"id": "dcb9f325-d840-46ca-bf2b-57f41e1ebfcb", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass HybridQuantumMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.5\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.4\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:\n                result = minimize(func, vector, method='BFGS', tol=1e-6)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.7\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "HybridQuantumMemeticDE", "description": "Hybrid Quantum-Inspired Memetic DE with Adaptive Strategy and Stochastic Local Search for Enhanced Solution Quality.", "configspace": "", "generation": 87, "fitness": 0.5239659537420436, "feedback": "The algorithm HybridQuantumMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.99145697684985, 0.9936222799038953, 0.9926018519896029, 0.9920206017372296, 0.9935687649990106, 0.993120456420088, 0.9928471563284867, 0.9931607946303639, 0.9799406942439587, 0.9795442446164617, 0.9763978638216297, 0.9770248720360528, 0.9787215944756663, 0.9729542586649224, 0.9767353964924513, 0.9781105195817059, 0.9756876042825042, 0.07963069009538759, 0.06078712802494901, 0.049263314114171175, 0.0482712350759662, 0.04124363599671721, 0.047301613326001135, 0.05508600895621818, 0.05154834168385314, 0.03502064526227133, 0.006277361745243293, 0.04854308552259068, 0.050706304991280926, 0.04388606756090563, 0.023045012863050163, 0.016406684612219724, 0.06847025100349036, 0.037040755896375455, 0.045889179322229356, 0.9907256821282221, 0.9918506467419829, 0.9922434437365049, 0.9912922295269375, 0.9929670258585499, 0.992184442913717, 0.9924734311186258, 0.9914037459530097, 0.9921779980624764, 0.8469363716404972, 0.7863063096305647, 0.8145613184929861, 0.9190842963034174, 0.9287225565070453, 0.8504664307895531, 0.7699933482434179, 0.7510535300398358, 0.8845606955034419, 0.3935539734084351, 0.537154905780656, 0.5105907944385778, 0.4565973533562935, 0.4469041497208126, 0.5525635211407198, 0.47640405537438113, 0.37215854790005076, 0.4588218403106563, 0.9625312604601824, 0.9593847662917404, 0.9606614357448874, 0.957965806946873, 0.9427889586081003, 0.8788795866983766, 0.9492713215890598, 0.9488129541413173, 0.9689328681176708, 0.9443884589383476, 0.9587859504577526, 0.9660053130208202, 0.8768119824363703, 0.9401696986622243, 0.957361276027532, 0.9356936048627447, 0.9611562558337593, 0.8535446475681265, 0.8190251944992447, 0.7535726063998478, 0.7379919731725495, 0.8584886192470775, 0.8564528452858342, 0.8065441696451072, 0.7424652904890758, 0.8849072419062233, 0.8376150681174959, 0.8178011124095783, 0.8202901771047693, 0.9834688146336221, 0.8325058165411972, 0.7177424233047031, 0.7389789021390751, 0.7356791885876435, 0.732914845278603, 0.8384478565346795, 0.9307752219123671, 0.6313232075913356, 0.9055167401010797, 0.7220097477071694, 0.8131109610309919, 0.744297663806107, 0.7375145711234312, 0.7988088633703043, 0.5948864434253334, 0.5237320947699555, 0.5319025620548407, 0.5150530604292919, 0.543818860173925, 0.5683329479265584, 0.5558989816457016, 0.7092020324328531, 0.6581754157183135, 0.6353210370306214, 0.8023660485791966, 0.8153894193468019, 0.8583510444557125, 0.8781756667026549, 0.8018140745668717, 0.8300561807852969, 0.8326005701354875, 0.8367172377822492, 0.8423296337693076, 0.062174349358823044, 0.044194251734265166, 0.0675380650026105, 0.05264222569648247, 0.07679930838245341, 0.09017925321291165, 0.03291893069035545, 0.03433159233712069, 0.05738485770354795, 0.09254739916738053, 0.09515229779597012, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.10522221094732254, 0.11141518456443533, 0.08715129441981151, 0.16263994786661984, 0.12769917553365084, 0.1613932299901244, 0.1461122382093505, 0.15215187533811803, 0.14679909513848433, 0.16667923066533696, 0.19058966991556203, 0.1457699739030408, 0.10108356156896281, 0.06306350173893716, 0.09436422824154911, 0.07369492250231602, 0.0888726941830561, 0.08318240679340283, 0.10422885084725186, 0.0997711199450243, 0.08771479487490452, 0.1457925302912919, 0.16362860864584672, 0.19073386029298378, 0.1897703811401532, 0.1293349571871666, 0.153253042540358, 0.1380616168014258, 0.15416412394057621, 0.18478103310843097, 0.21258582345637334, 0.19721633992606413, 0.2361132218361176, 0.23035409688250363, 0.498152214083904, 0.22280217051888318, 0.21892897684686252, 0.25933439347772713, 0.21619552003213816, 0.6139215073409058, 0.4811960074563504, 0.875413782510198, 0.9680038870757027, 0.8983740393635182, 0.4906586247418875, 0.8889565454755644, 0.8793639555585614, 0.6840253722055625, 0.87813237145201, 0.7437045004607394, 0.8381064194591007, 0.8918432950503099, 0.20318240125431308, 0.8646442972761493, 0.6007950703357394, 0.8863413647274208, 0.7947450849017244, 0.18737028083098506, 0.16102629222668363, 0.15454309984317627, 0.1586342103724282, 0.20326051850787397, 0.17263532718048813, 0.1653386925187409, 0.16988188938387716, 0.17026135963985545, 0.06255557369158682, 0.05735354674058801, 0.051294041216857655, 0.05586773654539612, 0.06272605525914621, 0.04801620158471487, 0.04762045563660011, 0.0433614037000869, 0.06489612120901511]}, "mutation_prompt": null}
{"id": "9584cbf9-7eff-449c-912f-a6e31845ff7e", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.5\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n        self.adaptive_factor = 0.5\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.02, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.6:\n            new_size = max(4 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumEnhancedDE", "description": "Quantum-Enhanced Dynamic Differential Evolution with Stochastic Local Search and Adaptive Parameters.", "configspace": "", "generation": 88, "fitness": 0.5218249517933601, "feedback": "The algorithm QuantumEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9919456490914976, 0.9926265084448136, 0.9925968054930298, 0.9920206017372296, 0.9931240330640244, 0.993120456420088, 0.9906503945450734, 0.9924475514137099, 0.955843801205159, 0.9753775234509015, 0.9808965184215958, 0.9773158103177599, 0.981353596817784, 0.9684480297552915, 0.9779064014516314, 0.9708596195870853, 0.9766079295693807, 0.036272398940707884, 0.12067944529249108, 0.06973074185536754, 0.059413489976523626, 0.06258307081987646, 0.05500846830235551, 0.07487493967479608, 0.07947386147779034, 0.11660735294944347, 0.0254568567618626, 0.05153779211222842, 0.03878896160745904, 0.050642049839383474, 0.027241650225395597, 0.052122502972470786, 0.036025054226982545, 0.03121991171363825, 0.05682757832225449, 0.9907265492651455, 0.9863449796295878, 0.9876508563221605, 0.9912915964679612, 0.9898461723897067, 0.987041578675935, 0.9924520291281592, 0.9888243638434095, 0.9916856316720775, 0.787119815689653, 0.8619744680643775, 0.6718035869674661, 0.9258452020619631, 0.9095117970803273, 0.8503028680637249, 0.8455900434072978, 0.7373261890071868, 0.9002952855634299, 0.5417521443418889, 0.41351231264123123, 0.5428496980192139, 0.5348039275523874, 0.5564182371919046, 0.548271810806687, 0.5275706019764776, 0.4534809335453106, 0.5717801989949957, 0.956531780235158, 0.9550675981158939, 0.9478677785452854, 0.9549582803872283, 0.9030009325918132, 0.9420902406668334, 0.9456820302146882, 0.9549505902759382, 0.9404186419386384, 0.9545724010344664, 0.9415604807329011, 0.882881699847348, 0.9522479232811232, 0.9541991499648427, 0.9522660326856967, 0.9381853283156565, 0.961219392969218, 0.9490570599974375, 0.8532843206860977, 0.822234161833773, 0.7728773484551497, 0.825063793832582, 0.9455436732569255, 0.9236650578800242, 0.7409076919140782, 0.8106554442482323, 0.9349629439820284, 0.8027593889602889, 0.8696217514179956, 0.8063531700408978, 0.7477560020678371, 0.8159638628433874, 0.8098563228540457, 0.813742259686813, 0.8246676825179232, 0.7881330517563239, 0.8528737147686188, 0.8854564119416382, 0.8335620899863277, 0.8191270037558442, 0.8423196271492608, 0.7090826047446868, 0.7505314984444709, 0.5862626062475074, 0.5230697945829745, 0.49917887994157584, 0.5294272064534975, 0.5256788478035377, 0.5953902387124229, 0.5623016226561445, 0.5422724673110237, 0.6851191521069396, 0.7462682445526967, 0.6519684160973538, 0.8107691853977597, 0.8419544618458381, 0.7931307861779807, 0.78635617016408, 0.7889810153570083, 0.7875690129415156, 0.8568023371156827, 0.8127254160714196, 0.8671779924276894, 0.06652875678900727, 0.0559689809244992, 0.0673343210798244, 0.06404953237470512, 0.04770877473765922, 0.05932371713963114, 0.13661339056473043, 0.03714590246730587, 0.08798980949919788, 0.10587374835843089, 0.10183294159197465, 0.11842175776965747, 0.1194011066602263, 0.10852972522114013, 0.10798713552628325, 0.09554808861652986, 0.10156928469471527, 0.09721687822801928, 0.1571045776130583, 0.14735144796054556, 0.16989782686003385, 0.16750498075798426, 0.15470210434741383, 0.14372955367221452, 0.15335684737888133, 0.1924604990651495, 0.16699219267723253, 0.09273016308600213, 0.09369717638264607, 0.09193225964874618, 0.10015275713148897, 0.08956365555776447, 0.09337092079547982, 0.10173315265315286, 0.10994217183836807, 0.11284922556478538, 0.17204446732890155, 0.2189033346834336, 0.14343941146722938, 0.1467749099338993, 0.17196888649911746, 0.1796847972964466, 0.20491479359241316, 0.19028834521307292, 0.2320696711983693, 0.20566184567876966, 0.20238996792233088, 0.2026202750967805, 0.20865612027704672, 0.21004810444409205, 0.22897307129432398, 0.24272095423972562, 0.2367079185624087, 0.22706542179452105, 0.840921270151924, 0.2134288853310562, 0.8570287332825979, 0.684031917269425, 0.7927380595644784, 0.21138075394604972, 0.19767247910973407, 0.646818811392764, 0.8921273916257395, 0.8979627466998884, 0.8317579516128061, 0.7255977904075612, 0.8315673022803035, 0.7545879994413928, 0.47924867922476144, 0.7954638880707405, 0.20646047646808352, 0.8818055551395121, 0.164397977116571, 0.19973870091067247, 0.15244888982431404, 0.17970574496669034, 0.17029245547208538, 0.17976735635920904, 0.2274203083125893, 0.16958613608580675, 0.16584951530046455, 0.07837659542125763, 0.06117764575656115, 0.0851310821220701, 0.06381962962713916, 0.06971734695525211, 0.082426609298344, 0.06997042123983466, 0.054811206807182655, 0.0487874172718995]}, "mutation_prompt": null}
{"id": "395335e8-9880-42ff-b592-8fbc094aeaf3", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted initial population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Tweaked scale factors for exploration\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85  # Slightly lowered crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.35  # Increased local search application\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.enhanced_local_search(trial_vector, func)  # Enhanced local search\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def enhanced_local_search(self, vector, func):  # New local search function\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            result = minimize(func, vector, method='L-BFGS-B', bounds=[(self.lower_bound, self.upper_bound)] * self.dim, tol=1e-5)  # Switched to L-BFGS-B\n            if result.success and func(result.x) < func(vector):\n                vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.7  # Altered reduction ratio\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))  # Adjusted minimum size\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive Scalability and Enhanced Local Search Techniques.", "configspace": "", "generation": 89, "fitness": 0.3783192236749188, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9927726993474478, 0.992803447480147, 0.9931638120473556, 0.9928237378767353, 0.9927682475160354, 0.993120456420088, 0.9927706172679253, 0.9926338415659033, 0.49946253928560846, 0.4211099103064465, 0.4353030219900198, 0.5095570165770757, 0.5506140473748831, 0.4726524779148573, 0.5839341938480691, 0.5284109634755549, 0.46328137571154826, 0.07074701086074198, 0.0781928683672839, 0.0831958992449856, 0.07515810989979088, 0.0632947169960627, 0.08552712742337332, 0.08043999910298238, 0.06846071242072971, 0.056778653498299136, 0.039596843298456585, 0.04468278355796973, 0.04440493680575042, 0.04702130970295715, 0.09312373874875635, 0.059350971685647735, 0.04688721110283445, 0.05262627834331268, 0.027494708972256365, 0.9919289615759671, 0.9910338301046979, 0.992425416051578, 0.9928735533351503, 0.9925583660976965, 0.9928728776028021, 0.991836920813064, 0.9925837165766488, 0.9928777792447637, 0.4089394221701851, 0.4389618113519399, 0.3911759148468892, 0.5281196967079824, 0.3718039568295539, 0.3672867689152882, 0.3174096077159375, 0.2538118938998899, 0.34301792221409855, 0.3814980453485597, 0.4380978394192495, 0.2540231364089447, 0.35306925429287794, 0.30690703666003905, 0.24406325145682062, 0.2404518616088288, 0.2943935981234216, 0.35183795183692457, 0.6275408526387412, 0.6159226808091021, 0.5831560341764594, 0.4449955202593281, 0.460903471244259, 0.4173957992774333, 0.6780557055160672, 0.6099275331523768, 0.6490653878300426, 0.6176256752210119, 0.6045425930116204, 0.5718656200671266, 0.703980597779152, 0.705951427699359, 0.7036313613391361, 0.6917714601705357, 0.6666125054209473, 0.6925414293441121, 0.5333469330280197, 0.5058421186836637, 0.5181119617716542, 0.567466336635436, 0.48850608146772645, 0.5437464459167796, 0.34531746862054635, 0.39061659425665884, 0.2374928629439047, 0.2674733333092072, 0.3662605441243314, 0.3543486847028521, 0.3479719516322404, 0.46895144872368333, 0.43732543801841206, 0.4333635730127203, 0.34522715409001825, 0.30234835511059666, 0.46778621661579967, 0.48846086602326466, 0.4706902623851892, 0.7171713489242912, 0.6268832474030255, 0.6459384767400227, 0.43788489019643506, 0.3926441190137234, 0.4775017716321569, 0.5196041243403998, 0.46971003152787083, 0.4099336208161931, 0.42098145028448364, 0.45165284137367223, 0.43671749054623465, 0.3418845875428923, 0.38136781513534634, 0.29211716076474004, 0.6091842450199891, 0.5704921084764906, 0.5813493431917354, 0.5615281650970942, 0.5461611669789297, 0.5304580582710059, 0.5720257792845753, 0.5465263082096096, 0.5540810010855106, 0.08456791674065933, 0.06105618967575244, 0.07035390045330936, 0.08587928774123921, 0.07479276531886736, 0.12761683959056536, 0.09826163570945123, 0.07021492119088435, 0.08273187187737763, 0.10104500839291453, 0.10285158776822134, 0.1440135004862323, 0.13766266535167793, 0.11919107114649286, 0.13140774729708204, 0.14012913998322674, 0.11966053560371115, 0.09615553863018378, 0.16374672401752033, 0.15264218611541602, 0.18276379266405895, 0.17003981009403668, 0.18489061866404222, 0.17285145535414048, 0.16264622270868767, 0.18703762124508339, 0.17517366699134784, 0.1270375664201321, 0.10618068441093942, 0.14006867682238422, 0.12014368571401013, 0.10389476661225927, 0.09840939821720585, 0.11330488963511853, 0.11127965930284844, 0.09541765678575087, 0.2032830649481412, 0.25243238298824944, 0.20027163099102585, 0.16153351393469018, 0.27807423384935004, 0.1848394648724958, 0.2063464733517989, 0.27929235314601963, 0.20487383157389372, 0.2119707337166934, 0.20097298651449824, 0.20461940496601427, 0.219687370962929, 0.19557518690998632, 0.20968906376519758, 0.20621901547472343, 0.1983697187455733, 0.1984522778001273, 0.8096932760593905, 0.6852283665486183, 0.7316466538494298, 0.9040197366624692, 0.7045686931774452, 0.7009154635137225, 0.48573885622698376, 0.44337156842874814, 0.38178383327985255, 0.28575168094838066, 0.49390329316667236, 0.3953763541102454, 0.35178840141105105, 0.28167105144631344, 0.31535350975199916, 0.40948767875364034, 0.612078718189101, 0.3246123468634803, 0.20684102505483193, 0.18785617350429906, 0.21031411556237156, 0.18196421248619477, 0.179110613058848, 0.20411713796605513, 0.1776933722477677, 0.18288258694132586, 0.2154969729390077, 0.0805121207099101, 0.08359590582302079, 0.06131852781432212, 0.062156968672275936, 0.08267811127188074, 0.1022522705282829, 0.06896625766705622, 0.06727557213106106, 0.06010697391368536]}, "mutation_prompt": null}
{"id": "22cfd800-cde6-40a4-b311-33b71cc83e1f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithEnhancedDynamicCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.4\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='L-BFGS-B', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.7\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithEnhancedDynamicCrossover", "description": "Quantum-Inspired Memetic DE with Enhanced Dynamic Local Search and Stochastic Mutation Strategies.", "configspace": "", "generation": 90, "fitness": 0.3786314044305271, "feedback": "The algorithm QuantumMemeticDEWithEnhancedDynamicCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9908429154168973, 0.9941660106155206, 0.9936220780294459, 0.9920206017372296, 0.9935687649990106, 0.9936605247990957, 0.9921065522965419, 0.9940310177073535, 0.6209680217567587, 0.2488133752174453, 0.33098703091043513, 0.6570949055933253, 0.5163058407001517, 0.4882647879202079, 0.6714767160804169, 0.5569203563546602, 0.5355391519799112, 0.06945551887913914, 0.10109602010695018, 0.08830788193837558, 0.07844606963050427, 0.07808793123495361, 0.07416380831024239, 0.07467797348727234, 0.05810298749011744, 0.0735784614862599, 0.05386712795891124, 0.036614986525829174, 0.050229940732779865, 0.04903260598566417, 0.06494615762470968, 0.05910285507357127, 0.0464683263858926, 0.08118410276981358, 0.05792363299114189, 0.9912536527167515, 0.9918135156899501, 0.992274567993648, 0.9912996751340934, 0.9924919073172821, 0.9922100030517539, 0.99243810235866, 0.9913694128351442, 0.9921985572659251, 0.42764435693808067, 0.4834578297253025, 0.5181868086044541, 0.43562402094105257, 0.4671033065365504, 0.4460525577467963, 0.2257872088595826, 0.28203810865862877, 0.35201378818477047, 0.3338409734240865, 0.3354647077325589, 0.3562318269609349, 0.43476936723648374, 0.36878255926853876, 0.43262145087072235, 0.40552385160850435, 0.42416826129120944, 0.3910342608772218, 0.6018836597702997, 0.5695401521305479, 0.6154502478832304, 0.4524502040104277, 0.42387101660649085, 0.539982742948736, 0.5931813770131411, 0.6997718145497978, 0.6816652950158966, 0.600063765448268, 0.6150732241960908, 0.6143313338102246, 0.6998794316411694, 0.7094503107018131, 0.737342332473456, 0.6646930680312425, 0.6760999761498911, 0.7140182732580334, 0.5166707070349867, 0.5560090808888598, 0.5249717127092569, 0.5076792968154553, 0.5627480420064463, 0.6471884756012052, 0.2844271784944231, 0.21298474203485562, 0.3893099658903483, 0.2405598181019304, 0.3879643498691424, 0.3056731738095406, 0.4382490262520685, 0.4469147813375073, 0.4880599735927038, 0.423729557728859, 0.5179896067222722, 0.31000673120681466, 0.4287243179354093, 0.48350303599545863, 0.4719188920173024, 0.7671888073505913, 0.7209990690095032, 0.6542526212610438, 0.5224212689202286, 0.4445965144848295, 0.5257795003794113, 0.29467565905746695, 0.2954454051986397, 0.40090943292020786, 0.476059177418544, 0.49216943499950816, 0.32904136916850824, 0.3766938377664184, 0.30537380855425655, 0.35810908082073256, 0.5692619763220256, 0.5914722719950425, 0.6035723741444807, 0.5337838121656608, 0.5615275535955173, 0.5628616944418732, 0.5621939744552662, 0.6047901663889683, 0.5662768518752654, 0.0631778466131836, 0.08382966087167587, 0.07313626760012415, 0.0818420253841301, 0.09284977652325233, 0.08799441091233151, 0.07267730109634252, 0.08497950905348484, 0.08563098732657015, 0.11312329133014531, 0.16806209063434108, 0.13082238701358329, 0.10500127606508158, 0.12299435448396256, 0.138130451232911, 0.09371914676842374, 0.09215583370923286, 0.11549533399215506, 0.1466394875407594, 0.1682819933743751, 0.18979366774227335, 0.18645070602526914, 0.15862145454976984, 0.16028024809440122, 0.20111570738392315, 0.18754270196761313, 0.16734780702095375, 0.09738915090396372, 0.09252427190180501, 0.1386078847387111, 0.11344198020574292, 0.09873534924391703, 0.10497084149654279, 0.10682430188952163, 0.11692705034902373, 0.11700694839912162, 0.18403313273211575, 0.22607316106399034, 0.1896987697989434, 0.21602403023058614, 0.17689860802344115, 0.21996956727757844, 0.23467749842939212, 0.17623604716486074, 0.21693789940539787, 0.20119109077192698, 0.20508953476289293, 0.227740096969968, 0.21664767520447525, 0.22555695333959713, 0.3031040989145114, 0.20888738817927588, 0.24004395301242676, 0.2193702283996064, 0.20057668188021038, 0.2735837466222626, 0.23125927431951, 0.6973873069814717, 0.7090742819051234, 0.4906889010149159, 0.5114849552170393, 0.39023471770026497, 0.5216846493065708, 0.4505626611230955, 0.35808207834483297, 0.4866181095491262, 0.44938521257395103, 0.3614439053121733, 0.4260414827740354, 0.47957636392193004, 0.33341497102629514, 0.5115076495738928, 0.21252043366594886, 0.19893273907028775, 0.20906443163887922, 0.1969126497660355, 0.19935266496052384, 0.1896265840299124, 0.1942216891891152, 0.1721225764443297, 0.21210404756289603, 0.05388145211789852, 0.09056809066227234, 0.060497285070480356, 0.06824195302616642, 0.05699082341421979, 0.06954282700786607, 0.06409199157297718, 0.06071932576220329, 0.06599168610788042]}, "mutation_prompt": null}
{"id": "cf290759-3141-47c4-b8d6-a664fd8c806b", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithDynamicMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.local_search_rate = 0.25\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.multi_stage_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def multi_stage_local_search(self, vector, func):\n        step_sizes = [0.05, 0.02, 0.01]\n        for step_size in step_sizes:\n            step = np.random.normal(0, step_size, self.dim)\n            local_vector = vector + step\n            local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n            if func(local_vector) < func(vector):\n                vector = local_vector\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithDynamicMutation", "description": "Quantum-Inspired Memetic DE with Dynamic Mutation and Multi-Stage Local Search Strategies.", "configspace": "", "generation": 91, "fitness": 0.5079121469524837, "feedback": "The algorithm QuantumMemeticDEWithDynamicMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.38.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9934418925844872, 0.9929851225648635, 0.9934409481680805, 0.9934501182977112, 0.9931240330640244, 0.9935018678736215, 0.9932174583444591, 0.9928201317180967, 0.9705832358064156, 0.9815807452890155, 0.9623776195502143, 0.969234391700017, 0.978621621802404, 0.9633044791712796, 0.9798540449404867, 0.9652444901580095, 0.9764359599498685, 0.04357523740699454, 0.11666730836570083, 0.08116676820895596, 0.06487841121069793, 0.05031220627780297, 0.08601018667493132, 0.10572005849148314, 0.028355157217071825, 0.03980163966950245, 0.012106459688402516, 0.00764520275453795, 0.028570174363989453, 0.028798754329253495, 0.039878826369259324, 0.041589493046255144, 0.049494744034782934, 0.022564426734921983, 0.03313671244377803, 0.9916441951799968, 0.9912009213050609, 0.9903201178937278, 0.9917930659641426, 0.9912953058170292, 0.991473726401485, 0.9933000300726628, 0.9907371993616965, 0.9916879785143852, 0.7957430838521227, 0.8563671622853328, 0.7658752622730889, 0.8778049473858968, 0.8735177092094852, 0.903607815200945, 0.8054914958872301, 0.8353522477851818, 0.8107407485759643, 0.33605370831629555, 0.2939659828620592, 0.25307659567089114, 0.24331752680331542, 0.2656423604820588, 0.2671190203784024, 0.2209432849354791, 0.23090295476080291, 0.2528911622970279, 0.9579090854938146, 0.8384750085565786, 0.8061902340429783, 0.8877886653791476, 0.9420791599084256, 0.9561270012605444, 0.9565074027566404, 0.9380123543763729, 0.8985911265541451, 0.9569379115401901, 0.9559641487259072, 0.9623321645966425, 0.9662575438147478, 0.9572482676740469, 0.9665154909899409, 0.9423028912370809, 0.9495939200010609, 0.9562144601971045, 0.7777006789449783, 0.7718260989348444, 0.7700827736106036, 0.8429446471455835, 0.8607757261024381, 0.7651263057900387, 0.818317569913516, 0.8401860739740267, 0.8849213498514694, 0.9533195570257825, 0.7560456037285838, 0.7870856148323604, 0.7423326169403764, 0.7501807689187623, 0.7593980588487426, 0.7777827676588461, 0.7919087643994609, 0.7529471717314871, 0.7867471075081889, 0.7359271269904093, 0.8323153860157013, 0.7639705487023513, 0.789144668211448, 0.8756028003556198, 0.7621010391259115, 0.6446848686769328, 0.5069808553686526, 0.5279639175832983, 0.5164400399819922, 0.5111797459632617, 0.5496695259507326, 0.5470290517292982, 0.5443462297276602, 0.6415280951138557, 0.7402494007314733, 0.6449595285296158, 0.7860880789099837, 0.7956203230228245, 0.8465748896163626, 0.7634348878786371, 0.7684535185455525, 0.8194473427045271, 0.8566850469364703, 0.8361583738424794, 0.8226402411430418, 0.01755417640082868, 0.04464753829528911, 0.04039724779928311, 0.09947408335646246, 0.05566588008272866, 0.05335592680357837, 0.05699740902955741, 0.05714928486839943, 0.054506738185755466, 0.08494000004272673, 0.08609370886951495, 0.12670928840092255, 0.09855305120349966, 0.10852972522114013, 0.1087191312039496, 0.08955476405314533, 0.09554459970473594, 0.09238258479334405, 0.13913606397253442, 0.1246146934800958, 0.16367364858048017, 0.159783044526282, 0.1544389767767882, 0.15598276599030536, 0.15292955208293169, 0.17377774300845283, 0.16329041832552071, 0.06360962641891965, 0.05275217466971627, 0.08398582550377798, 0.07239203147064566, 0.09290692276535739, 0.10450518653352225, 0.08598098853780489, 0.11930836193369998, 0.1407041665634472, 0.1655778305501142, 0.22499006014027423, 0.15105345766923894, 0.1848886204821233, 0.14969087716647866, 0.143175300969552, 0.14332629043199008, 0.16803228857127228, 0.1480133596172073, 0.3258077144224839, 0.24841414885718727, 0.21036349198707804, 0.6689249335813376, 0.2080107564186049, 0.25638480144184395, 0.21122243066360857, 0.20620939645752856, 0.22053707801019462, 0.8091280638375097, 0.19886378668642168, 0.21226131141920346, 0.7383552813431316, 0.9489797656342944, 0.8808365307224196, 0.8650523648098994, 0.7063818427546698, 0.9276455724117529, 0.6845213341888354, 0.9707055245383311, 0.7485778546094355, 0.8605233922570764, 0.49725393747690483, 0.20623340210032015, 0.8744084503919234, 0.21217778917228214, 0.8816911817683126, 0.169445366446345, 0.18626329738778669, 0.166836467988687, 0.14613594343484315, 0.21797874011412277, 0.17068555352939352, 0.1882991410331296, 0.1762093415032857, 0.18601460115772905, 0.052797286420895984, 0.035496857626929335, 0.069651276656437, 0.053634893490465574, 0.05557702000502229, 0.05672708852366193, 0.05731529849793204, 0.05379073330472017, 0.040936234807552374]}, "mutation_prompt": null}
{"id": "54c382a8-aaf1-4c06-b9da-6661e5473a0f", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Slightly increased initial population size for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Adjusted to allow wider range of variations\n        self.scale_factor_high = 0.7  # Adjusted to allow wider range of variations\n        self.crossover_rate = 0.85  # Slightly reduced to promote diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.35  # Increased to encourage more intensive local exploration\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Slightly increased for broader exploration\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-6)  # Improved precision in local minimization\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.7  # Adjusted for more aggressive population downsizing\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(6 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Enhanced Exploration and Dynamic Strategy Adaptation for Black Box Optimization.", "configspace": "", "generation": 92, "fitness": 0.5215372942485725, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.992306417762767, 0.9922024714896286, 0.9910775341753405, 0.9926426286203045, 0.9913959402953919, 0.9903532665768617, 0.9925803880410802, 0.9889333837969961, 0.9892540999747904, 0.9787686361233587, 0.957310116094132, 0.9781148515115555, 0.9792535282645556, 0.9629828265264949, 0.9788132515007648, 0.978219513113833, 0.9696143838968145, 0.9604502232314285, 0.0722360374444464, 0.07802176567220231, 0.07512430024519723, 0.06728025391023418, 0.07109776532952161, 0.06136706249018076, 0.04581604229732672, 0.1448216530107882, 0.05580851185969404, 0.02661887266453067, 0.031033907469476985, 0.025779699319337435, 0.028233374623195973, 0.02943545509314205, 0.029059096979420773, 0.028231564536825293, 0.018889237392290315, 0.0600080090273406, 0.9917575150487711, 0.9897700290695034, 0.9880415876400137, 0.9912690836878664, 0.989826754799375, 0.9884226666831168, 0.9903306988851156, 0.9903623667908065, 0.9884500802933142, 0.8048761721379472, 0.8127051032987824, 0.8860109048998273, 0.8851839561174146, 0.8529828500513876, 0.8417627965006588, 0.8487526540523872, 0.6979086284243528, 0.8005639524525952, 0.4177353431122448, 0.3942869968428706, 0.3838503913456599, 0.4606484546256041, 0.403296633017151, 0.45315243963408425, 0.3691996907256968, 0.47980021362297, 0.5027805368076841, 0.9674553710051712, 0.9691772581836604, 0.9592137282905832, 0.9525963881991163, 0.9521128905859022, 0.9673065168358468, 0.9585180002266254, 0.9632147107195618, 0.9474886884889688, 0.9645333431346412, 0.9619357897397477, 0.9539754326334579, 0.9514783215267076, 0.9714908687983815, 0.9400867613475806, 0.9498424406022452, 0.9526842632748769, 0.9519185955022482, 0.836792633609842, 0.8174474509507765, 0.8663064982030875, 0.9226933027310578, 0.7899135643933655, 0.81138333627713, 0.816377009236791, 0.7578889518349354, 0.7841947011419367, 0.8750332094017096, 0.7938392514503078, 0.7893931819847374, 0.7409115823386716, 0.7561635642062349, 0.9371166353709153, 0.6831226581114633, 0.8162594045012962, 0.7336988701398188, 0.8383049507303689, 0.8215790423009184, 0.767590102442071, 0.7665315287627157, 0.7653853128719712, 0.7885067322139189, 0.5292380046908234, 0.5704183492686032, 0.4911434554890207, 0.5145787001833053, 0.5082716785087045, 0.5035658436934405, 0.5556578744374608, 0.5455071626748142, 0.5421723891741583, 0.6884544749200103, 0.6780852685606165, 0.6495955668045463, 0.8432134613239209, 0.8185072134775403, 0.8267595278318318, 0.8986137759382293, 0.7740392315819651, 0.8011543575005786, 0.8376414004368194, 0.8616348931468073, 0.8275724463132683, 0.06302859640317637, 0.05774775333934634, 0.052004208589927825, 0.061150340543362436, 0.055720109554385666, 0.06414688883724406, 0.05666983551707894, 0.04201952371232931, 0.06481806454022188, 0.10411270313890875, 0.10023808123967393, 0.11842175776965747, 0.13766266535167793, 0.1261361845590483, 0.1137848219904497, 0.09764160508075748, 0.09451671205125256, 0.11360307524497659, 0.12971899911515739, 0.14249711633952522, 0.1829764603633517, 0.15491949314103948, 0.15404111223843087, 0.16158400135865159, 0.15874967086640068, 0.18610404871508057, 0.15229512503714993, 0.07458861778682091, 0.08287674481887075, 0.10990353293563804, 0.0795017852269968, 0.08811988080367117, 0.08855898012300567, 0.11418225491282574, 0.11298762714370292, 0.08678868641583026, 0.23444499288973297, 0.18475856756885478, 0.17663343528485398, 0.20779741531088547, 0.19675558617476563, 0.17961937599675515, 0.17031345002231735, 0.2260169452677372, 0.1588806683979197, 0.21598690396394027, 0.7386024766728533, 0.2129136826917305, 0.600001870356693, 0.20408283886244394, 0.2548209656599951, 0.43678345905362104, 0.2441726201193566, 0.23983823395104675, 0.8335860034373421, 0.7986430117887351, 0.32398689073907017, 0.7396110650684207, 0.19800608461271818, 0.9333423712585466, 0.6026997497466601, 0.19030747040049445, 0.18999510386433838, 0.7973649457524282, 0.9735606946288722, 0.789830421393573, 0.8962740119921826, 0.5559439073141776, 0.6816738428315532, 0.8311499992380078, 0.9773701521646797, 0.8140259639952946, 0.18650352540587678, 0.17886179398532132, 0.18709745954484092, 0.18017737787074606, 0.202312045527004, 0.17215679736481526, 0.15833112337062938, 0.17198425515973959, 0.22211397870926508, 0.048734451746526464, 0.05944024741254039, 0.0647377512886449, 0.1009647884009417, 0.07318294971919492, 0.06950222111782245, 0.04251367088066471, 0.08157828022035551, 0.06409810550222539]}, "mutation_prompt": null}
{"id": "3582fac1-628f-4d05-90bd-e7df5fed36e1", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.6\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n        self.diversity_boost_rate = 0.1\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n                elif np.random.rand() < self.diversity_boost_rate:  # Introduce diversity boost\n                    self.population[i] = self.diversity_boost(self.population[i])\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size\n\n    def diversity_boost(self, vector):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_vector = vector + perturbation\n        return np.clip(new_vector, self.lower_bound, self.upper_bound)", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive Crossover and Diversity-Boosting Mechanism for Enhanced Global Search.", "configspace": "", "generation": 93, "fitness": 0.5260344033703777, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.36.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9928861078498142, 0.9886374480676967, 0.9936209853613711, 0.9925978160975526, 0.9916636523418938, 0.9935687649990106, 0.993120456420088, 0.991273372760604, 0.9930700858899028, 0.9721460734725079, 0.9688624055613123, 0.9630575315456279, 0.9799723491359801, 0.9752455844502884, 0.9807606755258661, 0.9768367982733014, 0.9802349048207267, 0.9745634516702667, 0.1085890480022379, 0.0652344302176231, 0.057363866958394794, 0.11933549250207998, 0.08515239929193774, 0.13524064585647433, 0.09435324330535877, 0.08576950037900644, 0.07028443567957188, 0.03523849536889556, 0.03618554387775075, 0.039255037731944165, 0.05230008709508782, 0.033047576685295676, 0.0751587188255678, 0.05354188553489658, 0.052046964069267454, 0.04758879615475142, 0.991264657273231, 0.9918927295075746, 0.9922379605624153, 0.9912624058277162, 0.9929649330543696, 0.992185810983401, 0.9913099397005324, 0.9914045478060918, 0.9921768703243018, 0.7446930480025413, 0.9144722867170155, 0.7065662026231873, 0.8079966782181103, 0.7922568388392914, 0.8621827029182113, 0.9074991686173421, 0.6023765405011084, 0.8950425252998482, 0.5588714498007405, 0.30865217802721134, 0.5693779148059538, 0.5802168288177586, 0.560802257702285, 0.5430986519184358, 0.42148848753538604, 0.6106138622560309, 0.556884595859253, 0.9578782741985272, 0.9470994207622947, 0.9582625182721823, 0.9579502082001659, 0.9346292903322753, 0.9524968449630993, 0.9498794115455501, 0.9649349257727117, 0.9670770525921277, 0.9509248992004783, 0.9085024838724745, 0.9643997106814811, 0.9469330416424994, 0.9784754783434607, 0.955220931672171, 0.9473421770945255, 0.9492696685122042, 0.9477457809475576, 0.9614704099811047, 0.7660897845474097, 0.7146296834185033, 0.8747443015899723, 0.7890431350839543, 0.8351752199031193, 0.7435122949357147, 0.8764820099751514, 0.770486745886916, 0.7551453403321619, 0.7512393715146678, 0.7396797114850591, 0.741409804039614, 0.7562818589183702, 0.7667269913897494, 0.7653865097211071, 0.8162881097837412, 0.8778709950147164, 0.8849334919165529, 0.8905096650557063, 0.853507250266846, 0.7958591358093088, 0.792080737926455, 0.7354557170214333, 0.7566883185621429, 0.6255933873491817, 0.5619726914102411, 0.5143602578526758, 0.5018503813008134, 0.5187907107719161, 0.5619889619436604, 0.5708867932272614, 0.5681827672803106, 0.675374832030584, 0.5901517786156819, 0.6164545098176272, 0.8173572621465933, 0.8442523597460092, 0.8134031411533702, 0.8078544713871313, 0.8018304537562075, 0.8551255546709009, 0.8614670614770914, 0.8330552234106465, 0.8626906974684081, 0.0810919262205978, 0.09634431890797801, 0.09717834497418532, 0.07354588820090135, 0.051408150794530094, 0.10048230742564324, 0.07557324745227723, 0.06406778261844515, 0.048348268705923125, 0.09272904403801918, 0.09696574666649815, 0.11842175776965747, 0.09855305120349966, 0.11980259777856939, 0.10798713552628325, 0.08952535179097487, 0.11078729825382505, 0.1168476032388942, 0.1687777421020692, 0.15941154893731257, 0.18427716641228242, 0.16577402046851186, 0.17082741021471215, 0.18431935306340252, 0.16073737430033308, 0.19132850418066827, 0.16283153815621043, 0.0884392960235898, 0.07725149762221428, 0.13788871825001592, 0.09823459279840119, 0.09107384533750029, 0.09706515121245707, 0.11155717016348299, 0.11560919021758276, 0.09574474061137006, 0.1786019777773421, 0.17396713902373373, 0.21180342530744756, 0.17178584733818247, 0.164305998496165, 0.16571139576735572, 0.16905176912806696, 0.1616962041451192, 0.2188369676672821, 0.2155804739107574, 0.6309564388727358, 0.21267594572594017, 0.2187790064628835, 0.2559856010560938, 0.21251510738246593, 0.2056862763978634, 0.20807815089042625, 0.21024443561085748, 0.18669779400418152, 0.5336175421582521, 0.7203576307465456, 0.8023988068896799, 0.5607057938757867, 0.7826967026385014, 0.7414594265865775, 0.5453517405277876, 0.8180966879777473, 0.9555064467547931, 0.8231037957255817, 0.8567552748912225, 0.7608912879838035, 0.5773579904124333, 0.566521418225458, 0.9331889484685792, 0.8009718195230477, 0.5230783806270864, 0.2010725668354182, 0.1750046464412528, 0.16667862224490781, 0.1943326423661823, 0.1621880552102295, 0.18933124378780275, 0.18720274794048863, 0.15816037099222557, 0.18748225702698296, 0.07114585467223589, 0.06393357090642293, 0.07639539501801118, 0.06059601337136877, 0.0725772582962938, 0.08052979274032446, 0.05012732465863046, 0.09826190568433324, 0.0826238144109821]}, "mutation_prompt": null}
{"id": "fe80a153-0e2c-44c7-8120-5350f99e0d57", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.9  # Increased scale factor range for more exploration\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate for diversity\n        self.evaluations = 0\n        self.local_search_rate = 0.2  # Adjusted local search rate for more exploration\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            diversity = np.std(self.population, axis=0).mean()  # Measure population diversity\n            if self.dynamic_population_resizing:\n                self.update_population_size(diversity)\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i, diversity)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx, diversity):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high * min(1, diversity))\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self, diversity):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size and diversity > 0.1:  # Avoid reducing when diversity is low\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive Crossover and Dynamic Mutation Based on Diversity Measures.", "configspace": "", "generation": 94, "fitness": 0.5307895625343336, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9907653578846681, 0.9926318669298189, 0.992594038843173, 0.9907712788535542, 0.9931240330640244, 0.992710393853964, 0.9901519168959935, 0.9924475514137099, 0.970412284812027, 0.9784346458591758, 0.9727756445884588, 0.9705233535411394, 0.9728746415381859, 0.9682685891575739, 0.9786035386108893, 0.9784777778174502, 0.9769149356759583, 0.07549204129072096, 0.1108306759844121, 0.07216951258785753, 0.07213390743666515, 0.09044959046210332, 0.09878541127797469, 0.09702057202664416, 0.09378428511753023, 0.08061140367649855, 0.025183219639219323, 0.05081705104827594, 0.05378435718526775, 0.037494288144847454, 0.026688733717157298, 0.03504069759053163, 0.03928917501046503, 0.03747594826304412, 0.028766845528110152, 0.9907001249054177, 0.9832344271547486, 0.9877256638710559, 0.990799907371481, 0.9898430972187579, 0.9870505288017949, 0.9924581730189537, 0.988831342984599, 0.9916868909075081, 0.7110351330328771, 0.7738595126127301, 0.7919628785736557, 0.923984207381612, 0.8217328562932725, 0.878824953580817, 0.8425990349989556, 0.8776547692423927, 0.9552136673534096, 0.3313758921279103, 0.4770278330007348, 0.5387713965896593, 0.526400987748962, 0.5688522871290967, 0.5667807574539607, 0.5632162827619044, 0.6213247306684219, 0.6348005784624969, 0.9563529654012928, 0.9677472275852608, 0.9484009547746081, 0.9527300490934292, 0.9021967177227954, 0.9420426367080692, 0.9448417065102244, 0.9452873366252514, 0.9424022979284662, 0.954689047757726, 0.9554181403855998, 0.9553507097980959, 0.9164254952623121, 0.9571917530202186, 0.9499525995096323, 0.9377092089721714, 0.9526527294755042, 0.9560453150036804, 0.7750431015105809, 0.7727020420792601, 0.892621364990467, 0.9327031494409134, 0.9229589835252746, 0.8332085931657514, 0.8102672492202672, 0.8075612942828312, 0.8690197334527063, 0.7294693213713563, 0.781643793211362, 0.8487433132137112, 0.7583244387864552, 0.7486609425863073, 0.7650074989527199, 0.7520411037542789, 0.7698475889879464, 0.7283440063380469, 0.8949588368309523, 0.7784501750131031, 0.8071236230451144, 0.7573742539914735, 0.7688154986174014, 0.7608856871496542, 0.9029480512994612, 0.6985574236593444, 0.5131718832072361, 0.4848629124901793, 0.5057071225354939, 0.5129999009578148, 0.5468012456010629, 0.5531931282777879, 0.5490461786936172, 0.6530375307499112, 0.6903598385599311, 0.6754698550755273, 0.8289041810906916, 0.7929471756340778, 0.8598972106572452, 0.7910370980897375, 0.8400178472639234, 0.7807389820524993, 0.8447423121119987, 0.8478583903739012, 0.8166270879186189, 0.07728834816745533, 0.05251998103120337, 0.10308435421594053, 0.08630090970071436, 0.06930279741230294, 0.08909769135907097, 0.08490530779538863, 0.07142383084883297, 0.11055402414616966, 0.1353687838111709, 0.08675778540399026, 0.11842175776965747, 0.10781088041985676, 0.11409862366002088, 0.10798713552628325, 0.09332893689702237, 0.10899659271108741, 0.10635024764805234, 0.1527646627118402, 0.1718592067004716, 0.1745145642614332, 0.15894300358163804, 0.16541590382925364, 0.17794301848876692, 0.15399975636615415, 0.18221463401997184, 0.19812228651515018, 0.10445233665650522, 0.10576952632646786, 0.11072984136318587, 0.10265731392534927, 0.0925352870751096, 0.10259528335110224, 0.1055413323282719, 0.11683883253296012, 0.11438561439267847, 0.14450335017416494, 0.16374132754730253, 0.17133879713972167, 0.15884080941916168, 0.18275997410818856, 0.15957433080364658, 0.21271579604063884, 0.16370614536470496, 0.1777742602655903, 0.24590525640070582, 0.2042676114200831, 0.24346780716737437, 0.24736445908084137, 0.22184170556560767, 0.23409965907840158, 0.22590588507754739, 0.22183398940686516, 0.22867611575098967, 0.5240638000688547, 0.6469640755941863, 0.6776089262551975, 0.23291210934294182, 0.9256574464039262, 0.9131505380126411, 0.7395707678193004, 0.838645061623355, 0.9080226211500463, 0.7684867757922516, 0.9367719200799668, 0.8757009377081864, 0.6151461698731893, 0.6893491882450067, 0.6853249297682498, 0.942196594195647, 0.831484594875758, 0.7574973602286232, 0.16629739076088534, 0.18894429112058708, 0.17227526991569375, 0.17858715489907684, 0.1637522785589659, 0.18356831342330504, 0.1918488339857538, 0.18125782786519107, 0.16701034820384775, 0.0620975469918591, 0.07560937360691755, 0.05207669054965103, 0.06978211453236705, 0.06144639484749115, 0.07842908207074395, 0.08893272391596152, 0.05387686321618712, 0.061582312500715886]}, "mutation_prompt": null}
{"id": "5fff36e6-8773-4851-b748-4bb0b12794e0", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.6\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive Population Resizing and Enhanced Crossover Strategies.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9919456490914976, 0.9936209853613711, 0.9925978160975526, 0.9920206017372296, 0.9935687649990106, 0.993120456420088, 0.9899431600664471, 0.9930700858899028, 0.9721460734725079, 0.9583593052485322, 0.971506221892456, 0.9799723491359801, 0.9808647433746424, 0.9807606755258661, 0.9758877942279423, 0.9802349048207267, 0.9745634516702667, 0.07896105925456265, 0.07264123718670545, 0.08796840251661087, 0.11480602821779007, 0.05707420842232547, 0.08461266821296864, 0.10410161219351699, 0.07105813549306095, 0.04654350051425149, 0.03700110490388253, 0.04932055954378178, 0.05913372186905852, 0.03161250678932537, 0.03195770552342614, 0.025426552778656908, 0.03094277761281261, 0.06432927510718633, 0.04105205029368064, 0.9907439331505291, 0.9918927295075746, 0.9922379605624153, 0.9913000543688775, 0.9929649330543696, 0.992185810983401, 0.9924581732716244, 0.9914045478060918, 0.9921768703243018, 0.8626348355438025, 0.8121548348671254, 0.7092503116601895, 0.7911353550918729, 0.884436164198451, 0.8645401357344565, 0.8997622510556413, 0.8486310919556904, 0.7726348802387798, 0.6423808186141278, 0.5476786171871275, 0.6722030798702898, 0.6539066309954246, 0.5828031683221744, 0.593544528092286, 0.5897872572475169, 0.5419489013071455, 0.6561874777243062, 0.9614898561090172, 0.9600156341957182, 0.9582625182721823, 0.9579502082001659, 0.9434536039873448, 0.9524968449630993, 0.9498794115455501, 0.8768776694494226, 0.9670770525921277, 0.9422691430226152, 0.9434901914564519, 0.9643997106814811, 0.9555501813901855, 0.9624411540716225, 0.955220931672171, 0.9390652821018421, 0.9187338853895184, 0.9477457809475576, 0.9710868064712358, 0.8409740914849049, 0.7237058235520266, 0.8668507565441566, 0.873087812721702, 0.7968548411345859, 0.8471938230081776, 0.7995246055131403, 0.8068602876125113, 0.7802146016020681, 0.8398118662279581, 0.7754691577091667, 0.7513509451642946, 0.7034253568735482, 0.7671318238511387, 0.8172236363282981, 0.7914126414225748, 0.8025971446942655, 0.8347655849274824, 0.7785617090428997, 0.8595774874494149, 0.8772462265182807, 0.7922775610124162, 0.7420630387541032, 0.5967393110416357, 0.7173990420328034, 0.5610007214969538, 0.5071860430702826, 0.49792558453662883, 0.5058427368836751, 0.5391015583375114, 0.5564988966051962, 0.557476782626638, 0.6777427173641799, 0.5997652938712288, 0.696522763650989, 0.8206299739499059, 0.91171424007576, 0.8434274752155878, 0.9003364460471204, 0.7760340577673511, 0.8202819406261472, 0.8107328262063822, 0.8416223301823144, 0.8287603467002775, 0.09046123895553315, 0.043162582868201516, 0.07173173476564587, 0.07239750011429857, 0.05264368324756219, 0.0735211463550337, 0.11731291575385572, 0.0900951425142581, 0.05087837722067379, 0.09304919824113644, 0.09505273385180057, 0.11997977701132712, 0.10295044131490028, 0.1132617252674214, 0.10798713552628325, 0.11960590562092688, 0.10469869000409415, 0.11098675513854572, 0.16556972456796215, 0.1844621523724962, 0.1667663782743084, 0.16893979207505871, 0.17496161360729767, 0.15453420102327842, 0.17613789913264077, 0.19988532659000602, 0.16526283851096157, 0.10780818854658414, 0.08396672494674473, 0.08985753499112104, 0.10352146887526925, 0.08216991259063511, 0.08909457622263306, 0.09980916992145061, 0.10895645541746213, 0.10137578251221879, 0.20241923766957626, 0.13617665233690968, 0.17239177987258003, 0.19608075758546606, 0.18269146246478507, 0.13150313167102545, 0.21759552388064052, 0.1366707216240195, 0.18952133960080453, 0.20567532366774532, 0.756654715442563, 0.22339888602215474, 0.25558449136591876, 0.2119617827968011, 0.20149601040828458, 0.7433249120013701, 0.7793546124595901, 0.19672989540544983, 0.8527699611716377, 0.9277360504358243, 0.7559306172369816, 0.8938827194076362, 0.8360818176028475, 0.8580885968341478, 0.7545731003323489, 0.653088127538561, 0.9659301238971044, 0.8548732197929481, 0.3134767949690931, 0.6487020013719492, 0.8186620690930936, 0.5910966448822761, 0.20726371021091095, 0.7078482787680818, 0.19795299393535648, 0.6951811976212268, 0.16564878449910214, 0.17819554944819171, 0.1789478414052128, 0.1802817024176795, 0.1729000768239397, 0.16441966319972767, 0.1586297242261142, 0.17774463958648412, 0.18738434453867936, 0.0731034359185635, 0.07474104876419918, 0.07176821793289911, 0.061541461556825605, 0.07532141913996349, 0.08743324927361695, 0.06811849527991765, 0.0602844279204533, 0.054505091821189344]}, "mutation_prompt": null}
{"id": "df8c80c3-2307-404f-9696-a91d384b9624", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3\n        self.scale_factor_high = 0.7\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        mutation_scale = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + mutation_scale * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveMutation", "description": "Quantum-Inspired Memetic DE with Adaptive Mutation Strategy and Dynamic Population Management.", "configspace": "", "generation": 96, "fitness": 0.5320196527239239, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.37.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9919456490914976, 0.9936209853613711, 0.9925986561817614, 0.9920206017372296, 0.9935687649990106, 0.993120456420088, 0.9898980776337734, 0.9930858366228595, 0.9692251558013495, 0.9684747504593525, 0.9757646263285754, 0.9803297609640588, 0.9717051324622782, 0.9789172142984813, 0.9669028615292647, 0.9688165424762143, 0.9571969784339781, 0.07670281235650911, 0.07612819050753039, 0.055973565356354116, 0.1108849542829703, 0.07079655399002771, 0.08624049470371298, 0.09832122030950974, 0.13804926604943724, 0.05101049612904607, 0.02398481213460668, 0.049857979582546785, 0.0483877275623088, 0.05786637353998181, 0.06094685206925954, 0.04191911287559391, 0.028764815474755068, 0.041138001661199075, 0.02940751448625545, 0.9907265246468426, 0.9923545284488487, 0.9922398607015819, 0.9912919791484474, 0.9929634962151218, 0.9921847689117166, 0.9924581734137127, 0.991403594132008, 0.9921770352226533, 0.7437077947555567, 0.731062291131628, 0.8182842339801563, 0.8633113510025066, 0.8535288054066934, 0.8599241800911135, 0.895253233118204, 0.8271564623399487, 0.8047977024073588, 0.7233834176652363, 0.5382990220970216, 0.6266919395735979, 0.6383297761068276, 0.6315268146781099, 0.608421507342503, 0.5846159924221819, 0.5521131198883757, 0.5806508142046005, 0.9580170624502109, 0.9582366019847797, 0.823597002866258, 0.9541632568753136, 0.9525942698343192, 0.9519207640889984, 0.9505929792596711, 0.9392928340642517, 0.9666042753511879, 0.9524097697632106, 0.9467011083806799, 0.9660520658897406, 0.9140356765176805, 0.970556263147606, 0.9545556377233989, 0.9363346827506459, 0.9163149859804066, 0.957540221223871, 0.7995359215572765, 0.7353759815646215, 0.8203643926505089, 0.9340945248201465, 0.8136579819141495, 0.8290132449782729, 0.8553456582273182, 0.9136507569405903, 0.8365149401382804, 0.7603345721937669, 0.9176175908985549, 0.7559111415763053, 0.7766606029199103, 0.775907283903883, 0.9291247073067741, 0.8359801364410671, 0.8329936540588289, 0.7934579982556734, 0.8532446133069741, 0.7717830581907961, 0.8227259923475063, 0.8553486364674296, 0.806605339662286, 0.7805399455059712, 0.7547857326549993, 0.7654269746201083, 0.5777794088677611, 0.5134635294845287, 0.5265251783258633, 0.508103284990332, 0.5681264166068829, 0.5457217534846408, 0.5651668990542393, 0.6519460183095899, 0.6825969943315441, 0.6686346187769608, 0.8009564551047272, 0.7981875879199443, 0.8743339123778755, 0.8231548287874066, 0.7771219065453661, 0.778300176125388, 0.8761744434287152, 0.8333278586409939, 0.8448460706303067, 0.05935298564195424, 0.1096533098855127, 0.08262160757043968, 0.09158133998279117, 0.08011235069049383, 0.07436579914083863, 0.07254607503177501, 0.07750149942097617, 0.10737977497603368, 0.09469900013452315, 0.09035476669961895, 0.12306888687397222, 0.11303340967457298, 0.12254824238685946, 0.10798713552628325, 0.0882311254700644, 0.11476767925111964, 0.07814030695297314, 0.16542681393360525, 0.1515956670664469, 0.1990571838214703, 0.1615767924226713, 0.1650088716142012, 0.16070027759897965, 0.1804581082275667, 0.18798092724947546, 0.1542689783314014, 0.07696261371843083, 0.0840740705415326, 0.10240422249546044, 0.113682109559049, 0.08057151350544611, 0.114259125170729, 0.10936060427730587, 0.11003296275986463, 0.11344709777845907, 0.25009851246243675, 0.16043155260423514, 0.20134720575892018, 0.16771092982948665, 0.1551991152537192, 0.2183073349515604, 0.17971792019184563, 0.13754315298129483, 0.20366485599391604, 0.21232413596929456, 0.7100054117349655, 0.2215942205571958, 0.9476593832001147, 0.6500274919688095, 0.2219264394174284, 0.8261393897506764, 0.21430037357490828, 0.3009057895292693, 0.21254253216670793, 0.17923033114783282, 0.8061680913726875, 0.5020130841934507, 0.829877072934849, 0.6526445411565919, 0.3450010893289984, 0.29160955035176483, 0.9107269391476542, 0.913838116586801, 0.8339854246565779, 0.6718543294258217, 0.9394014420369086, 0.5731354206066501, 0.2110970904139291, 0.6692705816854088, 0.3276354698579794, 0.7276618471446379, 0.1581749295913334, 0.17664496270409125, 0.15853678652309322, 0.16958822005327, 0.1803248220357616, 0.16494253116697366, 0.16747806241201757, 0.17601047101338174, 0.16379614119038233, 0.0679809560574004, 0.061141497952610036, 0.057101626579162845, 0.05716350544042603, 0.08243227096550054, 0.06538322883917003, 0.055150790104073755, 0.069794455602595, 0.053537044110640974]}, "mutation_prompt": null}
{"id": "3845c919-0561-4698-acfb-19bfcf60cc59", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.6\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.3\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.05, self.dim)\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.5:\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.75\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive Population Resizing and Enhanced Crossover Strategies.", "configspace": "", "generation": 86, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9932338847248454, 0.9919456490914976, 0.9936209853613711, 0.9925978160975526, 0.9920206017372296, 0.9935687649990106, 0.993120456420088, 0.9899431600664471, 0.9930700858899028, 0.9721460734725079, 0.9583593052485322, 0.971506221892456, 0.9799723491359801, 0.9808647433746424, 0.9807606755258661, 0.9758877942279423, 0.9802349048207267, 0.9745634516702667, 0.07896105925456265, 0.07264123718670545, 0.08796840251661087, 0.11480602821779007, 0.05707420842232547, 0.08461266821296864, 0.10410161219351699, 0.07105813549306095, 0.04654350051425149, 0.03700110490388253, 0.04932055954378178, 0.05913372186905852, 0.03161250678932537, 0.03195770552342614, 0.025426552778656908, 0.03094277761281261, 0.06432927510718633, 0.04105205029368064, 0.9907439331505291, 0.9918927295075746, 0.9922379605624153, 0.9913000543688775, 0.9929649330543696, 0.992185810983401, 0.9924581732716244, 0.9914045478060918, 0.9921768703243018, 0.8626348355438025, 0.8121548348671254, 0.7092503116601895, 0.7911353550918729, 0.884436164198451, 0.8645401357344565, 0.8997622510556413, 0.8486310919556904, 0.7726348802387798, 0.6423808186141278, 0.5476786171871275, 0.6722030798702898, 0.6539066309954246, 0.5828031683221744, 0.593544528092286, 0.5897872572475169, 0.5419489013071455, 0.6561874777243062, 0.9614898561090172, 0.9600156341957182, 0.9582625182721823, 0.9579502082001659, 0.9434536039873448, 0.9524968449630993, 0.9498794115455501, 0.8768776694494226, 0.9670770525921277, 0.9422691430226152, 0.9434901914564519, 0.9643997106814811, 0.9555501813901855, 0.9624411540716225, 0.955220931672171, 0.9390652821018421, 0.9187338853895184, 0.9477457809475576, 0.9710868064712358, 0.8409740914849049, 0.7237058235520266, 0.8668507565441566, 0.873087812721702, 0.7968548411345859, 0.8471938230081776, 0.7995246055131403, 0.8068602876125113, 0.7802146016020681, 0.8398118662279581, 0.7754691577091667, 0.7513509451642946, 0.7034253568735482, 0.7671318238511387, 0.8172236363282981, 0.7914126414225748, 0.8025971446942655, 0.8347655849274824, 0.7785617090428997, 0.8595774874494149, 0.8772462265182807, 0.7922775610124162, 0.7420630387541032, 0.5967393110416357, 0.7173990420328034, 0.5610007214969538, 0.5071860430702826, 0.49792558453662883, 0.5058427368836751, 0.5391015583375114, 0.5564988966051962, 0.557476782626638, 0.6777427173641799, 0.5997652938712288, 0.696522763650989, 0.8206299739499059, 0.91171424007576, 0.8434274752155878, 0.9003364460471204, 0.7760340577673511, 0.8202819406261472, 0.8107328262063822, 0.8416223301823144, 0.8287603467002775, 0.09046123895553315, 0.043162582868201516, 0.07173173476564587, 0.07239750011429857, 0.05264368324756219, 0.0735211463550337, 0.11731291575385572, 0.0900951425142581, 0.05087837722067379, 0.09304919824113644, 0.09505273385180057, 0.11997977701132712, 0.10295044131490028, 0.1132617252674214, 0.10798713552628325, 0.11960590562092688, 0.10469869000409415, 0.11098675513854572, 0.16556972456796215, 0.1844621523724962, 0.1667663782743084, 0.16893979207505871, 0.17496161360729767, 0.15453420102327842, 0.17613789913264077, 0.19988532659000602, 0.16526283851096157, 0.10780818854658414, 0.08396672494674473, 0.08985753499112104, 0.10352146887526925, 0.08216991259063511, 0.08909457622263306, 0.09980916992145061, 0.10895645541746213, 0.10137578251221879, 0.20241923766957626, 0.13617665233690968, 0.17239177987258003, 0.19608075758546606, 0.18269146246478507, 0.13150313167102545, 0.21759552388064052, 0.1366707216240195, 0.18952133960080453, 0.20567532366774532, 0.756654715442563, 0.22339888602215474, 0.25558449136591876, 0.2119617827968011, 0.20149601040828458, 0.7433249120013701, 0.7793546124595901, 0.19672989540544983, 0.8527699611716377, 0.9277360504358243, 0.7559306172369816, 0.8938827194076362, 0.8360818176028475, 0.8580885968341478, 0.7545731003323489, 0.653088127538561, 0.9659301238971044, 0.8548732197929481, 0.3134767949690931, 0.6487020013719492, 0.8186620690930936, 0.5910966448822761, 0.20726371021091095, 0.7078482787680818, 0.19795299393535648, 0.6951811976212268, 0.16564878449910214, 0.17819554944819171, 0.1789478414052128, 0.1802817024176795, 0.1729000768239397, 0.16441966319972767, 0.1586297242261142, 0.17774463958648412, 0.18738434453867936, 0.0731034359185635, 0.07474104876419918, 0.07176821793289911, 0.061541461556825605, 0.07532141913996349, 0.08743324927361695, 0.06811849527991765, 0.0602844279204533, 0.054505091821189344]}, "mutation_prompt": null}
{"id": "438d40b7-4b22-4b20-83c7-9dc51a70793c", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass EnhancedQuantumMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Adjusted initial population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.3  # Adjusted lower scale factor\n        self.scale_factor_high = 0.7  # Adjusted upper scale factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.local_search_rate = 0.35  # Adjusted local search rate\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.adaptive_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def adaptive_local_search(self, vector, func):\n        step_size = np.random.normal(0, 0.1, self.dim)  # Adjusted step size\n        local_vector = vector + step_size\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.6:  # Adjusted probability for minimization\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.8  # Adjusted reduction ratio\n        if self.evaluations > self.budget * 0.6:  # Adjusted evaluation threshold\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "EnhancedQuantumMemeticDE", "description": "Enhanced Quantum Memetic DE with Adaptive Strategy Refinement Incorporating Stochastic Search Dynamics.", "configspace": "", "generation": 98, "fitness": 0.5203855549446589, "feedback": "The algorithm EnhancedQuantumMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.37.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.992306417762767, 0.9922024714896286, 0.9918148232744936, 0.9926426286203045, 0.9913959402953919, 0.9917513408905693, 0.9925803880410802, 0.9889333837969961, 0.9920749711093232, 0.9787686361233587, 0.957310116094132, 0.9701727580129074, 0.9792535282645556, 0.9629828265264949, 0.9828730623160539, 0.978219513113833, 0.9696143838968145, 0.9775003808015366, 0.04297909333524641, 0.06133315083938218, 0.06546903566265061, 0.08951787151761526, 0.04958133269593745, 0.07322003093423723, 0.057606865936156826, 0.06984679201130495, 0.04614172008376205, 0.025717657371132963, 0.018835009112136647, 0.033043961619404816, 0.03354992379314281, 0.023602316574004134, 0.03549673950245158, 0.03946192859927666, 0.02484369718280488, 0.06256640582841955, 0.9917575150487711, 0.9897700290695034, 0.9907785011614831, 0.9912690836878664, 0.989826754799375, 0.9909012216280079, 0.9903306988851156, 0.9903623667908065, 0.990315020259202, 0.8048761721379472, 0.8127051032987824, 0.8720215730711542, 0.8851839561174146, 0.8529828500513876, 0.7829132763016388, 0.8487526540523872, 0.6979086284243528, 0.8005639524525952, 0.3878806354926635, 0.36864391239492555, 0.3620992383776457, 0.43980342960850394, 0.37574681658323683, 0.43328496386901116, 0.3440697566296004, 0.45260746107877725, 0.48958713865160675, 0.9674553710051712, 0.9691772581836604, 0.9622219862660102, 0.9525963881991163, 0.9521128905859022, 0.9686872434221461, 0.9585180002266254, 0.9632147107195618, 0.9474886884889688, 0.9645333431346412, 0.9619357897397477, 0.9340166771338503, 0.9514783215267076, 0.9714908687983815, 0.938029150527678, 0.9498424406022452, 0.9526842632748769, 0.9517714210741157, 0.8284961035308194, 0.8938552824379977, 0.8473972161497445, 0.9194011054058394, 0.8996836863930816, 0.8033659825713537, 0.7714865420593058, 0.7719399109328022, 0.7841947011419367, 0.8679757732130924, 0.7614867533290838, 0.7762016901944495, 0.7154983055496331, 0.7488810093398965, 0.9159147727811054, 0.6782950965989518, 0.8092354926473646, 0.7188965375534868, 0.8383049507303689, 0.8215360556887188, 0.7889723383621621, 0.7665315287627157, 0.7653853128719712, 0.7925345094882064, 0.5292380046908234, 0.5704183492686032, 0.4911434554890207, 0.5132564884968672, 0.50715934885359, 0.503605865348467, 0.5796315091312054, 0.55776612798841, 0.547534465599741, 0.6884544749200103, 0.6780852685606165, 0.6745040231549281, 0.8453875823506958, 0.8182316893453421, 0.8060054776735824, 0.8986137759382293, 0.7739972510181725, 0.7995805281229774, 0.8327961959200837, 0.8630443531465437, 0.8272788187823945, 0.06611277181297937, 0.057496109248435956, 0.046482967978860645, 0.06332996286474246, 0.03719740535140137, 0.05788225314476536, 0.06270161361477644, 0.059056014574774385, 0.0895977064410225, 0.10265149628178094, 0.09945602448669666, 0.11842175776965747, 0.13766266535167793, 0.12424952393447675, 0.11167276662152503, 0.09745482079848733, 0.08891140727579971, 0.11360307524497659, 0.1440005270968563, 0.1496974401789134, 0.18191858035887398, 0.1701409614110767, 0.14184911019562474, 0.1482232968882914, 0.13872443431783377, 0.17567806793631568, 0.1619224246077885, 0.08312185321860865, 0.08543873950009617, 0.10834971354523404, 0.07899089811984417, 0.08126837571212764, 0.09075842915814014, 0.11410714183626769, 0.10435274124140981, 0.08707043448494645, 0.23444499288973297, 0.17787156672352245, 0.17094833414831623, 0.20193656859182962, 0.18627966620685454, 0.17394092180439036, 0.21203943711699724, 0.21592461535608687, 0.15591500850457618, 0.22499233021978993, 0.7091599936174318, 0.19994228353953092, 0.2260385748178083, 0.2154457750576011, 0.2518590246013007, 0.25394827694344235, 0.9316275991256496, 0.24394408549663804, 0.765775385647282, 0.7658465624964517, 0.19839224024463153, 0.8506211840155584, 0.39798801502962344, 0.8886596565842932, 0.7905727735804078, 0.513277695526364, 0.6794369588506577, 0.811453312861749, 0.9250755782015813, 0.6649601832398859, 0.2067832284701674, 0.19372974751980931, 0.811548430047013, 0.8287672468283218, 0.9685980019497527, 0.8525265705555753, 0.18252983212382512, 0.17628324159393782, 0.18039946035841037, 0.17855559651911412, 0.2011536269599209, 0.17108404310872227, 0.15627694935709902, 0.1700460309616525, 0.2202078229333554, 0.05357518356840041, 0.05903638244597553, 0.0679234773416807, 0.08947931301706435, 0.06868332188724002, 0.06019488037664178, 0.04343632430484845, 0.0965189426079156, 0.07745776216794109]}, "mutation_prompt": null}
{"id": "9de26e02-a9b8-4468-9c48-ac772756cbd4", "solution": "import numpy as np\nfrom scipy.optimize import minimize\n\nclass QuantumMemeticDEWithAdaptiveCrossover:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.scale_factor_low = 0.4\n        self.scale_factor_high = 0.8  # Adjusted scaling factor for diversity\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.local_search_rate = 0.25  # Slightly reduced to favor global search\n        self.dynamic_population_resizing = True\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        while self.evaluations < self.budget:\n            if self.dynamic_population_resizing:\n                self.update_population_size()\n            for i in range(self.population_size):\n                if self.evaluations >= self.budget:\n                    break\n                trial_vector = self.mutate(i)\n                trial_vector = self.crossover(trial_vector, self.population[i])\n                if np.random.rand() < self.local_search_rate:\n                    trial_vector = self.stochastic_local_search(trial_vector, func)\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.fitness[i] = trial_fitness\n                    self.population[i] = trial_vector\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx]\n\n    def evaluate_population(self, func):\n        for i in range(self.population_size):\n            if self.evaluations < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.evaluations += 1\n\n    def mutate(self, idx):\n        indices = [i for i in range(self.population_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        adaptive_scale_factor = np.random.uniform(self.scale_factor_low, self.scale_factor_high)\n        mutant_vector = self.population[a] + adaptive_scale_factor * (self.population[b] - self.population[c])\n        return np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n    def crossover(self, mutant_vector, target_vector):\n        crossover = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        trial_vector = np.where(crossover, mutant_vector, target_vector)\n        return trial_vector\n\n    def stochastic_local_search(self, vector, func):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        local_vector = vector + perturbation\n        local_vector = np.clip(local_vector, self.lower_bound, self.upper_bound)\n        if func(local_vector) < func(vector):\n            vector = local_vector\n            if np.random.rand() < 0.3:  # Reduced chance for intensive local search\n                result = minimize(func, vector, method='BFGS', tol=1e-5)\n                if result.success and func(result.x) < func(vector):\n                    vector = np.clip(result.x, self.lower_bound, self.upper_bound)\n        return vector\n\n    def update_population_size(self):\n        reduction_ratio = 0.7  # Slightly adjusted reduction ratio\n        if self.evaluations > self.budget * 0.5:\n            new_size = max(5 * self.dim, int(self.population_size * reduction_ratio))\n            if new_size < self.population_size:\n                self.population = self.population[:new_size]\n                self.fitness = self.fitness[:new_size]\n                self.population_size = new_size", "name": "QuantumMemeticDEWithAdaptiveCrossover", "description": "Quantum-Inspired Memetic DE with Adaptive and Stochastic Sampling for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 99, "fitness": 0.5296810080328721, "feedback": "The algorithm QuantumMemeticDEWithAdaptiveCrossover got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.36.", "error": "", "parent_id": "890c519f-b214-4902-82e1-a5eab21b1f72", "metadata": {"aucs": [0.9935863783116112, 0.9928645938203312, 0.9908624727007307, 0.992941260979449, 0.9929129752255692, 0.9913451053240797, 0.993491838068866, 0.9928471563284867, 0.9906644709650338, 0.9793916759515664, 0.9781558580878146, 0.9621523047627434, 0.9741099601926047, 0.9783948879096334, 0.9753853128838829, 0.9818419381323399, 0.9730584201663488, 0.9576048892620957, 0.09942679765366624, 0.09432043850444949, 0.10408149129881838, 0.09535768109842524, 0.0905706922453774, 0.0847437466634059, 0.10194605076004737, 0.09201174134653534, 0.070943176072091, 0.053695510780874756, 0.06966708205404226, 0.05454569420354238, 0.050622234695710144, 0.05487768748486155, 0.03927047975275577, 0.05564942736795897, 0.04814259415975486, 0.06112519624161539, 0.9912017909614386, 0.9849650776052753, 0.9903505752759025, 0.9911437806762053, 0.9834516926113488, 0.9897599318559401, 0.9922540454020987, 0.9834976844164866, 0.9897451449512711, 0.858746623705975, 0.7742371884719013, 0.7546677278211849, 0.8653325773914525, 0.8706346241170386, 0.9073677480099502, 0.7475680053690295, 0.7642595472642646, 0.876559355627771, 0.5901970015367314, 0.5993495694153881, 0.45537078573419043, 0.6485692167355985, 0.602762927769777, 0.5475440110955405, 0.5763509514815932, 0.6742068198636471, 0.6049344203894693, 0.9550398704464026, 0.9563244405619729, 0.9207529230335828, 0.9484189004625968, 0.9594333644051818, 0.9552402038024097, 0.8693119611348293, 0.9536906394353348, 0.947860781676139, 0.959526916183588, 0.939522190302834, 0.9642770119907487, 0.9583011461267233, 0.9397073465820679, 0.9527086369229831, 0.9456581212311829, 0.9597826368971859, 0.9287766570914119, 0.8121136101740705, 0.7679980346946373, 0.7992086558413773, 0.7700063438738933, 0.830583129044981, 0.9281781793919506, 0.864903328305765, 0.7663489128455004, 0.9061491855289233, 0.7902401023819996, 0.7169007805408005, 0.780378813951816, 0.8044821025995291, 0.8199215889578045, 0.7703379775474409, 0.8826108936842598, 0.8098499396819393, 0.77349161270747, 0.7957164002533803, 0.868797596598014, 0.7917970599068715, 0.8988033571826879, 0.8151751845177996, 0.7946436384206614, 0.5582265060931577, 0.6439295031839364, 0.4554705005500841, 0.5332273230116291, 0.5303031797524782, 0.5026204835350219, 0.555473770293919, 0.5465123151966598, 0.5452992503108661, 0.7123356555988151, 0.6171868504596495, 0.6818454808995853, 0.816478957221297, 0.860256699867042, 0.8124744898694081, 0.780707021862779, 0.7919619768394093, 0.8302030256441861, 0.8651007225254529, 0.8063955375853373, 0.8486945631133758, 0.05854550846725959, 0.06073111856466418, 0.09894735600590121, 0.09478312182878978, 0.08369988377774484, 0.08387002878002459, 0.06972502331858543, 0.08595044022716136, 0.0700630783367473, 0.19962639532860404, 0.11307325453823414, 0.11842175776965747, 0.10541552723724545, 0.11164031880919134, 0.11779265073174483, 0.10562691827827075, 0.1026667803164617, 0.10144484038047974, 0.16510544057417154, 0.17210739329354097, 0.18359530619289066, 0.16908151525686388, 0.17793128342183662, 0.1557734598782985, 0.17317819930211176, 0.2021796918933384, 0.17162714122528555, 0.10433541036980076, 0.10109290979467966, 0.1042900768169982, 0.11337511583676407, 0.09546883771286796, 0.11131880802990313, 0.10399607876204042, 0.10568376252583911, 0.14409546183990418, 0.1570169703381329, 0.15021653933719048, 0.20352081918050013, 0.23663396104864087, 0.18621281058712713, 0.18128457360629868, 0.19065007052913674, 0.16313378696261938, 0.2222326069855306, 0.8349495131631436, 0.20111980418829833, 0.22028443705031364, 0.19774817151932222, 0.8752580191181066, 0.2098879826564708, 0.23906072118427069, 0.22460327928524215, 0.20189544212905175, 0.19977936271889574, 0.6571744133527144, 0.6053545499562825, 0.17632810657535158, 0.7172019209358249, 0.9470886617492512, 0.9051069173303297, 0.5864913716622848, 0.823392197357556, 0.796435399926841, 0.8547166051840581, 0.7905661603282895, 0.21670042596251082, 0.8217660984207356, 0.6243313200115925, 0.43697546690150624, 0.7902160355607513, 0.5558420850467196, 0.15008224982179486, 0.18597583631559378, 0.16564285989764682, 0.17961912833285953, 0.16665933555794943, 0.17901742285092948, 0.18722997940567843, 0.1575571187126079, 0.16643166195791803, 0.06827725391799522, 0.07369881528891797, 0.07319544736711492, 0.0884416618089715, 0.0741466642330324, 0.08869949368603447, 0.06113121550198097, 0.05634166678239849, 0.05620138303773381]}, "mutation_prompt": null}
