{"id": "8b79e4b7-c27c-4ccc-ae01-3bce980dd12e", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.max_evaluations = budget\n    \n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                # Evaluate the current particle\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # PSO velocity and position update\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.velocities[i] + cognitive_component + social_component\n                self.particles[i] = self.particles[i] + self.velocities[i]\n                \n                # Ensure particles remain within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Evaluate trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "A novel hybrid algorithm combining Particle Swarm Optimization (PSO) with Differential Evolution (DE) for enhanced exploration and exploitation capabilities.", "configspace": "", "generation": 0, "fitness": 0.12002981925473348, "feedback": "The algorithm HybridPSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.16504156882343324, 0.11280415317626413, 0.17924816232477148, 0.23191025908344798, 0.15711618900411395, 0.17435572534003618, 0.16587614760388314, 0.17308606847153152, 0.1838410255326598, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039360696299736264, 0.045513713750024, 0.0378891973788521, 0.04217233523105568, 0.04825169116322181, 0.04319127006057166, 0.03735694751467822, 0.045977550843013026, 0.04899405925225653, 0.05054638871163264, 0.025454419160703567, 0.01734956700760215, 0.04366512859084104, 0.02429537684075911, 0.01760700574229135, 0.02668085496489514, 0.044736871458206595, 0.0226407374917188, 0.9875687345874359, 0.9891868091210378, 0.9937621277716746, 0.9834126115598799, 0.9907900612862962, 0.9868242246067758, 0.9936561917459471, 0.9931434851287961, 0.9893704684158133, 0.07432670483881043, 0.04961796276868213, 0.05453151367288356, 0.08770654147702839, 0.11695654630839547, 0.062093179213665084, 0.0720334442127043, 0.0833339769699818, 9.999999999998899e-05, 0.15366645421696468, 0.050150082883918756, 0.09061858845458959, 0.14445194428129693, 0.130077399298413, 0.10148898143048846, 0.10617010422215623, 0.09918557578695686, 0.12155335730077843, 0.04389475961134537, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013907343687217466, 9.999999999998899e-05, 0.000858299705487453, 9.999999999998899e-05, 9.999999999998899e-05, 0.027841029929700167, 0.009904681916557245, 0.00915178261157601, 9.999999999998899e-05, 0.013571676997027327, 0.027852708068880183, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028212226921179195, 0.005166794227543514, 0.02992973342844052, 0.0516469369459539, 0.01180672123665516, 0.009089687310097405, 0.027872573219911323, 0.0063189485433600145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006945404832930935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18695558010159763, 0.19736813763827998, 0.1801204113290632, 0.17968909403511557, 0.19794118661719173, 0.16703194681101396, 0.15968761634364925, 0.1678722860192594, 0.1878734100762104, 0.05748159916959117, 0.06571202391394104, 0.06439965820291982, 0.04498545577434798, 0.03343654189089196, 0.038284667453030496, 0.040694413705278376, 0.05739417429484861, 0.08892803507655045, 0.15939491288653718, 0.14539762953358837, 0.1265605836064999, 0.1250933524536304, 0.14694095053359035, 0.15110802390039935, 0.13260700962588512, 0.15345197864702043, 0.16717615797054675, 0.17303620895174177, 0.16340047410898295, 0.16418492370587734, 0.15310244638184523, 0.14476542081894217, 0.16602848147781568, 0.1637821751911659, 0.17875281946820343, 0.14874677710734252, 0.08650351274927193, 0.1008163151014152, 0.11097384708770042, 0.10894666847979662, 0.12996025368916797, 0.14359183928929653, 0.1035579155950549, 0.13341119328713535, 0.10653340812459133, 0.1494435176189154, 0.14749027426142425, 0.1533223149470585, 0.14633313588880825, 0.11722861991819411, 0.14042115443736825, 0.15520017834949118, 0.17053934546208926, 0.17452033064863515, 0.003748405224530904, 0.0836212052738714, 0.13590634819654257, 0.14384102780050667, 0.12123972638142477, 0.15855758624558225, 0.03249683573963158, 0.12335372585871573, 0.138477529521579, 0.2064140986741997, 0.1415006985847438, 0.14740499678803975, 0.17907465091076757, 0.15315802571462578, 0.11684470846716888, 0.09485777279206975, 0.16268698324865183, 0.1612146026942599, 0.14117546559984206, 0.1382010064138952, 0.15486860825076287, 0.09504018329707964, 0.12106532106018819, 0.10597609363063876, 0.18470254361232485, 0.11322614619666438, 0.18852401120361673, 0.1875639474299603, 0.18816998708029997, 0.18440575455618646, 0.1992339287902074, 0.1814300210709352, 0.17741193627078355, 0.18143487280003223, 0.18497558179332452, 0.17917483178719973, 0.049182423212572934, 0.05955115697111801, 0.04000919335137554, 0.061910195550438085, 0.03650081301365937, 0.03929156043178572, 0.04508356618798426, 0.03881572853034665, 0.04762527147705331]}, "mutation_prompt": null}
{"id": "912e6351-d370-4721-9ebe-d8d5c5ae48e0", "solution": "import numpy as np\n\nclass HybridPSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.max_evaluations = budget\n    \n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                # Evaluate the current particle\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # PSO velocity and position update\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.velocities[i] + cognitive_component + social_component\n                self.particles[i] = self.particles[i] + self.velocities[i]\n                \n                # Ensure particles remain within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Evaluate trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODE", "description": "A novel hybrid algorithm combining Particle Swarm Optimization (PSO) with Differential Evolution (DE) for enhanced exploration and exploitation capabilities.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8b79e4b7-c27c-4ccc-ae01-3bce980dd12e", "metadata": {"aucs": [0.16504156882343324, 0.11280415317626413, 0.17924816232477148, 0.23191025908344798, 0.15711618900411395, 0.17435572534003618, 0.16587614760388314, 0.17308606847153152, 0.1838410255326598, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039360696299736264, 0.045513713750024, 0.0378891973788521, 0.04217233523105568, 0.04825169116322181, 0.04319127006057166, 0.03735694751467822, 0.045977550843013026, 0.04899405925225653, 0.05054638871163264, 0.025454419160703567, 0.01734956700760215, 0.04366512859084104, 0.02429537684075911, 0.01760700574229135, 0.02668085496489514, 0.044736871458206595, 0.0226407374917188, 0.9875687345874359, 0.9891868091210378, 0.9937621277716746, 0.9834126115598799, 0.9907900612862962, 0.9868242246067758, 0.9936561917459471, 0.9931434851287961, 0.9893704684158133, 0.07432670483881043, 0.04961796276868213, 0.05453151367288356, 0.08770654147702839, 0.11695654630839547, 0.062093179213665084, 0.0720334442127043, 0.0833339769699818, 9.999999999998899e-05, 0.15366645421696468, 0.050150082883918756, 0.09061858845458959, 0.14445194428129693, 0.130077399298413, 0.10148898143048846, 0.10617010422215623, 0.09918557578695686, 0.12155335730077843, 0.04389475961134537, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.013907343687217466, 9.999999999998899e-05, 0.000858299705487453, 9.999999999998899e-05, 9.999999999998899e-05, 0.027841029929700167, 0.009904681916557245, 0.00915178261157601, 9.999999999998899e-05, 0.013571676997027327, 0.027852708068880183, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028212226921179195, 0.005166794227543514, 0.02992973342844052, 0.0516469369459539, 0.01180672123665516, 0.009089687310097405, 0.027872573219911323, 0.0063189485433600145, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006945404832930935, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.18695558010159763, 0.19736813763827998, 0.1801204113290632, 0.17968909403511557, 0.19794118661719173, 0.16703194681101396, 0.15968761634364925, 0.1678722860192594, 0.1878734100762104, 0.05748159916959117, 0.06571202391394104, 0.06439965820291982, 0.04498545577434798, 0.03343654189089196, 0.038284667453030496, 0.040694413705278376, 0.05739417429484861, 0.08892803507655045, 0.15939491288653718, 0.14539762953358837, 0.1265605836064999, 0.1250933524536304, 0.14694095053359035, 0.15110802390039935, 0.13260700962588512, 0.15345197864702043, 0.16717615797054675, 0.17303620895174177, 0.16340047410898295, 0.16418492370587734, 0.15310244638184523, 0.14476542081894217, 0.16602848147781568, 0.1637821751911659, 0.17875281946820343, 0.14874677710734252, 0.08650351274927193, 0.1008163151014152, 0.11097384708770042, 0.10894666847979662, 0.12996025368916797, 0.14359183928929653, 0.1035579155950549, 0.13341119328713535, 0.10653340812459133, 0.1494435176189154, 0.14749027426142425, 0.1533223149470585, 0.14633313588880825, 0.11722861991819411, 0.14042115443736825, 0.15520017834949118, 0.17053934546208926, 0.17452033064863515, 0.003748405224530904, 0.0836212052738714, 0.13590634819654257, 0.14384102780050667, 0.12123972638142477, 0.15855758624558225, 0.03249683573963158, 0.12335372585871573, 0.138477529521579, 0.2064140986741997, 0.1415006985847438, 0.14740499678803975, 0.17907465091076757, 0.15315802571462578, 0.11684470846716888, 0.09485777279206975, 0.16268698324865183, 0.1612146026942599, 0.14117546559984206, 0.1382010064138952, 0.15486860825076287, 0.09504018329707964, 0.12106532106018819, 0.10597609363063876, 0.18470254361232485, 0.11322614619666438, 0.18852401120361673, 0.1875639474299603, 0.18816998708029997, 0.18440575455618646, 0.1992339287902074, 0.1814300210709352, 0.17741193627078355, 0.18143487280003223, 0.18497558179332452, 0.17917483178719973, 0.049182423212572934, 0.05955115697111801, 0.04000919335137554, 0.061910195550438085, 0.03650081301365937, 0.03929156043178572, 0.04508356618798426, 0.03881572853034665, 0.04762527147705331]}, "mutation_prompt": null}
{"id": "493961e8-161e-4749-b7ef-51dbc7b0d38d", "solution": "import numpy as np\n\nclass DualPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                # Evaluate the current particle\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # PSO velocity and position update\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = 0.5 * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] = self.particles[i] + self.velocities[i]\n                \n                # Ensure particles remain within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Evaluate trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n        \n        return self.global_best_position, self.global_best_score", "name": "DualPhasePSODE", "description": "A dual-phase exploration-exploitation hybrid leveraging PSO for exploration and DE for adaptive exploitation, dynamically balancing both phases.", "configspace": "", "generation": 2, "fitness": 0.2430924111502962, "feedback": "The algorithm DualPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "8b79e4b7-c27c-4ccc-ae01-3bce980dd12e", "metadata": {"aucs": [0.8055069862966702, 0.7809514152148813, 0.8368041540319173, 0.8197271451231011, 0.8233643410353542, 0.1898061391064947, 0.7565499718605176, 0.8046888307719746, 0.7679097883719609, 0.06970050483636236, 0.03915043365970128, 0.5716632479675173, 0.04229860065521551, 0.0441947086219161, 0.5254845208910652, 0.04593348093330474, 0.6771690749874639, 0.004496696230207986, 0.15196806383439432, 0.09951923737296398, 0.17607795791081338, 0.16364394874131083, 0.1525241117430416, 0.16762684875142753, 0.1641865355488109, 0.1516955577896555, 0.13609219443480747, 0.10275719618597523, 0.14200303760987043, 0.12478272490669717, 0.13116431256969896, 0.10602162084797606, 0.1371730315595172, 0.1321586176814208, 0.13224215222310176, 0.12159109960982806, 0.9873772186985602, 0.9899994807195241, 0.9908717207867752, 0.9902464038815246, 0.987353477397066, 0.9873046950256816, 0.9882576487786633, 0.9904707215000796, 0.9872020826591841, 0.3270081225071021, 0.05959542950092522, 0.05994670815452552, 0.14932134384271845, 0.3231367378449733, 0.400876864886637, 0.1241279852790933, 0.08914847597151598, 0.05045674613848805, 0.690444078519886, 0.16242245215176898, 0.22561014886088482, 0.7727000875119323, 0.11595190744658868, 0.1886301836127845, 0.1707669191359692, 0.12438484597682398, 0.4579978164499945, 0.16673635053135327, 0.11924108557839519, 0.23705127678535642, 0.12067946912571437, 0.12802820790563074, 9.999999999998899e-05, 0.2136890761021878, 0.1642767764095222, 0.12813892925349102, 0.17347977811835313, 0.05423328285716211, 0.17847325109998524, 0.17256012210619498, 0.16462841023961428, 0.179462584320757, 0.23580356374328604, 0.03252588613075036, 0.200105766491802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001774938473843024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005072781960056227, 0.10769276297548591, 0.008695108453115608, 0.061051418879144115, 0.08910709849179854, 0.03018059232787651, 0.05103651693947464, 0.05353437776624537, 0.05510898712421053, 0.036124151498269974, 0.0448948144471879, 0.026429231782584606, 0.05401114888096781, 0.07150396385129465, 0.07653314548126566, 0.24994195600242552, 0.09079469827397169, 0.20613152692012648, 0.07694763274409921, 0.07305592014453288, 0.04096544690968007, 0.13999253990395044, 9.999999999998899e-05, 0.08582627841373947, 0.006398722474585505, 0.09753688445495878, 0.053591829675211144, 0.07930086666068659, 0.5926293520835977, 0.5099139529296288, 0.5004832030254629, 0.47744867255922063, 0.5101513751322984, 0.18294664803110727, 0.5269589700914776, 0.5092465986800838, 0.5398503857388994, 0.08368930269473263, 0.060604702398594834, 0.10828226659922568, 0.07506855743814234, 0.1388719272309823, 0.1215860848241822, 0.11955704986821747, 0.10038750747915859, 0.12904492727805883, 0.16587483029541983, 0.20543059703705757, 0.1639859296233943, 0.2650283076100123, 0.28002802172673014, 0.17774563665371734, 0.1458906302838766, 0.1542340396119949, 0.1923045754656072, 0.2505623479210298, 0.32911040226509913, 0.32622215004263044, 0.3663785013727838, 0.2664361339234843, 0.29113396846387607, 0.38351892644326613, 0.47428208859395005, 0.2706290266180237, 0.12143723834777775, 0.16784606498185406, 0.13756574523296827, 0.26734161313790616, 0.27661598336056514, 0.22338117075467312, 0.24306073662853522, 0.307853332506568, 0.21275479684406184, 0.23411675747317018, 0.17295924569403487, 0.178485626883224, 0.20580015499109405, 0.20315408348813924, 0.21899012360530723, 0.3252385625979698, 0.20704662796979945, 0.1882622009674093, 0.2125920681206761, 0.2161452912131997, 0.18232870968214543, 0.19356637582011293, 0.19662848760740315, 0.5082465090570072, 0.24427670939800405, 0.21116538157625053, 0.20501239939758498, 0.8356303041173465, 0.16878695264988963, 0.12450404500452039, 0.6863365983114893, 0.19809336379439613, 0.19851967160577866, 0.09974008450925997, 0.16958637759215056, 0.16147550452482096, 0.15457146961634538, 0.16817072510497888, 0.36427552520764817, 0.1116029509315164, 0.16740207281295938, 0.21137310277191068, 0.2130579053480236, 0.2032853679495824, 0.6402516752891914, 0.1791713485306211, 0.2050515881724535, 0.1812767129142422, 0.2047377225454945, 0.19195149535852407, 0.190203755032044, 0.1801015084251476, 0.17852671307396473, 0.1870563930849497, 0.07611551437682351, 0.0810935839972412, 0.08335353324789518, 0.0819549375343408, 0.09121379734050494, 0.08754032945615564, 0.0761491004378575, 0.08342917249466741, 0.0830900026862832]}, "mutation_prompt": null}
{"id": "9cba56a9-9432-45ba-b1c1-6841255526c3", "solution": "import numpy as np\n\nclass AdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.8\n        self.c1 = 1.5\n        self.c2 = 2.5\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                # Evaluate the current particle\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # Adaptive PSO velocity and position update\n            w = 0.5 + np.random.rand() / 2\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = w * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] = self.particles[i] + self.velocities[i]\n                \n                # Ensure particles remain within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Evaluate trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptivePSODE", "description": "An adaptive PSO-DE hybrid using dynamic parameter adjustment for enhanced exploration-exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.16213622086170806, "feedback": "The algorithm AdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.20.", "error": "", "parent_id": "493961e8-161e-4749-b7ef-51dbc7b0d38d", "metadata": {"aucs": [0.12518530166382047, 0.12535461106157197, 0.39395051167344086, 0.3874088576703846, 0.15657426569290778, 0.14098063783088377, 0.33537479166865813, 0.327684173856136, 0.18617690862480007, 9.999999999998899e-05, 0.028209798701063993, 9.999999999998899e-05, 0.0399252946847688, 0.03467595200724205, 9.999999999998899e-05, 9.999999999998899e-05, 0.0528886044273853, 0.004757258238466289, 0.10612286533974369, 0.08783517206037972, 0.11565708825064136, 0.0687396465386988, 0.06594735741002022, 0.08676451796377749, 0.06744894898247744, 0.05079597438479866, 0.08815610729190937, 0.07611175643425727, 0.07804897946885192, 0.09391269940973179, 0.07225640432631808, 0.0445620750731609, 0.10465783827884079, 0.0664257887144073, 0.07263384708372123, 0.0812567610817041, 0.9937828995395378, 0.98924134748304, 0.9901492886459544, 0.9836088944377668, 0.9909071017362203, 0.9800703033851061, 0.9907802633712697, 0.9904606553554207, 0.9941997748056189, 0.1558913940382225, 0.05505152340087638, 0.05326365280671086, 0.14028484157094623, 0.18360552287776943, 0.13711149881061702, 0.1194207420454737, 0.14531009393650585, 0.08189463782636941, 0.13642705792139986, 0.18004031665848652, 0.19806573268490268, 0.20324279331999873, 0.1878663272003953, 0.11440308424687717, 0.13621286466393545, 0.21834225533564977, 0.15662258354549374, 0.11004547779099305, 0.10740427534112418, 0.11106070438509141, 0.11389368201083239, 0.062224246401472394, 0.08512320592287448, 0.12108375175876229, 0.12975883811935185, 0.12476997530451939, 0.11046602851466991, 0.01647662959585705, 0.1424848430273411, 0.13011751922163128, 0.06764738051895436, 0.11383442851091041, 0.0556954502872391, 0.07255702174534184, 0.0629029924439124, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050551148185024486, 0.007105419155966408, 0.028604733536434335, 0.011658377040844825, 9.999999999998899e-05, 9.999999999998899e-05, 0.01730794235886446, 0.01389083247010936, 0.0601244173373674, 9.999999999998899e-05, 0.02007348138484155, 0.013849228177686523, 9.999999999998899e-05, 0.016668840041395794, 9.999999999998899e-05, 0.028954366723579317, 0.011233706281146949, 0.013779215150733992, 0.030998533726431687, 9.999999999998899e-05, 0.08292850014992181, 9.999999999998899e-05, 0.004419665826356001, 0.0027679065015742133, 0.0424006420993126, 9.999999999998899e-05, 0.06984463097363003, 0.31531853053283443, 0.3362797426331292, 0.3262359253464171, 0.38394053722557486, 0.3816666154925361, 0.3848019092120939, 0.3283866036057711, 0.3542932568278415, 0.3291403011064178, 0.05770311465704692, 0.0633461625487356, 0.05008493645020973, 0.08186624327913217, 0.1186737124167323, 0.09058167660701111, 0.07187556166974263, 0.08465036683504001, 0.08171685802589779, 0.11772438016696418, 0.17165510867290645, 0.16809728506295818, 0.18146568310320232, 0.19448457308625078, 0.14209779266629907, 0.14720560974968555, 0.2112848456709352, 0.14591122643188248, 0.2535947023211885, 0.1801742293529225, 0.19559086868978526, 0.18404332285024194, 0.230015270209866, 0.2552705191675605, 0.2656042575524078, 0.26047828549790997, 0.14544240934583652, 0.1635898370717105, 0.21523331458538209, 0.13855067207470306, 0.1467831806311749, 0.17871277845683398, 0.16368065317922065, 0.11936214932698386, 0.17869072094125915, 0.17914370717518047, 0.1772356769992457, 0.18085242980247562, 0.18327690129086038, 0.17127697758604976, 0.18249122636932458, 0.18111137166271696, 0.18221891539208268, 0.17886386330846393, 0.1698707537917482, 0.17533832443915764, 0.20343079633015715, 0.19035154389483921, 0.1730542108573816, 0.16049264232103178, 0.192486725359982, 0.19125577549345474, 0.15767073590395575, 9.999999999998899e-05, 0.17693093228053114, 0.16817886807066718, 0.11311070470467766, 0.4448329438122912, 0.1962651745340671, 0.19544137646808846, 0.09941844615439843, 0.16834841638040887, 0.12491196400776827, 0.16069015246756913, 0.1648592497285477, 0.1503288628384416, 0.10898820333286507, 0.1636879885637048, 0.26899865926129773, 0.19424586447525127, 0.184832874837506, 0.18426992350086135, 0.18952923403409327, 0.19657534817959066, 0.20466722818128547, 0.17744832625285833, 0.19211418965497873, 0.19426655248956004, 0.1913633541827351, 0.17336221506661642, 0.1793440912863158, 0.08491952912626144, 0.08118040246399127, 0.07029884716626844, 0.0772260850822235, 0.0982875926155079, 0.06443251792336957, 0.06454552906671629, 0.06728773552774514, 0.08085972852590351]}, "mutation_prompt": null}
{"id": "e0b37385-082b-47af-bcb3-14167dfdd682", "solution": "import numpy as np\n\nclass DualPhasePSO_DE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.5 + np.random.rand() * 0.5  # Randomized mutation factor between 0.5 and 1.0\n        self.crossover_rate = 0.9  # Increased crossover rate for better exploration\n        self.c1 = 1.5  # Reduced cognitive component weight\n        self.c2 = 2.5  # Increased social component weight\n        self.momentum = 0.9  # Added adaptive momentum to PSO\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                # Evaluate the current particle\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # PSO velocity and position update with adaptive momentum\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.momentum * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] = self.particles[i] + self.velocities[i]\n                \n                # Ensure particles remain within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # DE mutation and crossover with self-adaptive mutation factor\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Evaluate trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n        \n        return self.global_best_position, self.global_best_score", "name": "DualPhasePSO_DE_Adaptive", "description": "A dual-phase hybrid using adaptive momentum in PSO for increased convergence speed and self-adaptive DE for robust exploitation.", "configspace": "", "generation": 4, "fitness": 0.13009886918872043, "feedback": "The algorithm DualPhasePSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "493961e8-161e-4749-b7ef-51dbc7b0d38d", "metadata": {"aucs": [0.2508799567521156, 0.18801614726978977, 0.2774111216623337, 0.2615054589837209, 0.17958275099010712, 0.1840320484259692, 0.17308140367377522, 0.1477865694577435, 0.1793150573832103, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03987647990158838, 0.05140325641891286, 0.06694003528393477, 0.0485992616845069, 0.05829238466646547, 0.0778050619065247, 0.058985684908102076, 0.030532156118851184, 0.060275564641357415, 0.022594946011594952, 0.034924565512996386, 0.04070695036063898, 0.05017592860213904, 0.04317091080893476, 0.041160790512967504, 0.032387891527160706, 0.057043119803934506, 0.04188501002142442, 0.9930999569214841, 0.9831782311153914, 0.991046338567969, 0.9729081332487148, 0.9940796756349967, 0.9837160722509481, 0.99081381060277, 0.9931795420240628, 0.9887436194918447, 0.059290679891988884, 0.028104004294139617, 0.028003409655335654, 0.11209472581538338, 0.12836561054409557, 0.0975831139182799, 0.0992312771126268, 0.12435214758473556, 9.999999999998899e-05, 0.17810728302402878, 0.05679767290258897, 0.10461621664655707, 0.1645316794629944, 0.15277625882751922, 0.11158279971477136, 0.11872846062065223, 0.12140979209101099, 0.09706762671604574, 0.014807018157915852, 0.012947202936027358, 9.999999999998899e-05, 9.999999999998899e-05, 0.029189320993203927, 0.04758642979091565, 0.03910945578717384, 9.999999999998899e-05, 0.05679469960028405, 0.009839928676555254, 0.02204566529817953, 0.009458735097598425, 0.031500479469945275, 9.999999999998899e-05, 0.020662105133210984, 0.003199926245168183, 0.034926922217237144, 0.015284048733353095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03545351763257609, 0.007797209928398163, 0.013135771703452703, 0.0256412369673501, 0.009877516937288444, 0.008948985749252292, 0.021668015009380315, 0.01994297253758337, 0.003537629625820826, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012360385690900144, 0.014184174004343353, 0.00015317716243656854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029454429382015812, 0.01850687293841835, 0.010644075472656334, 0.19289363721976227, 0.13142946666614463, 0.24845196940054015, 0.1994562678678049, 0.13440991754774845, 0.20138137628971198, 0.22042595181340752, 0.13437371103786666, 0.23187071923487712, 0.04687689661339589, 0.04795183786448687, 0.07749433921682336, 0.07484038243215596, 0.03525601630993169, 0.06446190681362074, 0.05694097550370458, 0.060343569701941435, 0.042220648348232914, 0.14861763517818105, 0.15500379440389445, 0.14481951652044955, 0.15219264451246928, 0.14636002747746202, 0.14331448411524728, 0.18589219723781525, 0.13894948835998822, 0.12769693549053118, 0.13822215567830776, 0.19698325423940555, 0.1765676220340865, 0.17441492821300086, 0.16454331705956993, 0.13882190933931726, 0.1778598277060588, 0.19591602310946243, 0.1541514199805588, 0.12525654279226384, 0.12237252908154239, 0.1047430496088746, 0.1349309065023765, 0.11174882322896174, 0.09651434812345305, 0.11267425201559633, 0.15088753427506985, 0.08580109681397097, 0.17721910697088883, 0.11239324066246104, 0.17292864132529995, 0.16515273032889, 0.1380728990651785, 0.16238272588556701, 0.15814815573215002, 0.1677627164678137, 0.18748333845878373, 0.09082152578000258, 0.13934742212512352, 0.14849294739595642, 0.15961371510447864, 0.13810244820491957, 0.16306593163279526, 0.1516703095730303, 0.15481560996598132, 0.17227972037199546, 0.40263886421004014, 0.16605241071267207, 0.1130606534321612, 0.23541758420885384, 0.1666912469210836, 0.16398479483956252, 0.2295070636492058, 0.16963842845622945, 0.20974654330336917, 0.11305101285239982, 0.10599500852256138, 0.10814042827756998, 0.15911040638154705, 0.1782443639711555, 0.14447390231626067, 0.18146471255932173, 0.1858503547698226, 0.1088079313753435, 0.17584586938009783, 0.19644624165022573, 0.17640693391817186, 0.200098213908928, 0.1684926303071963, 0.19557283697989847, 0.1952783269245174, 0.18623492248135065, 0.1732155169053443, 0.0470762731532024, 0.04190452063855832, 0.05566861907839615, 0.06682839058440604, 0.04975879439038722, 0.050427022401192345, 0.0577569019144164, 0.044401139739816076, 0.05804128076658022]}, "mutation_prompt": null}
{"id": "534d2b47-c75f-44ce-b747-f4d4797e7344", "solution": "import numpy as np\n\nclass AdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                # Evaluate the current particle\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                # Update personal best\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                # Update global best\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # PSO velocity and position update\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] *= 0.4\n                self.velocities[i] += cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                # Ensure particles remain within bounds\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            # DE mutation and crossover\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                # Evaluate trial vector\n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                # Selection\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            # Random walk phase for diversification\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:  # Small chance to perform random walk\n                        random_step = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiPhasePSODE", "description": "An adaptive multi-phase algorithm integrating PSO, DE, and random walk strategies for robust global optimization.", "configspace": "", "generation": 5, "fitness": 0.2551460313285273, "feedback": "The algorithm AdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "493961e8-161e-4749-b7ef-51dbc7b0d38d", "metadata": {"aucs": [0.8505395533896611, 0.8442326391925099, 0.8280087855487346, 0.8424291374166419, 0.1835039621726663, 0.7836440898711754, 0.8439140306258821, 0.8456273778689167, 0.8566963990466571, 9.999999999998899e-05, 0.041190437531593904, 9.999999999998899e-05, 0.6894637217876372, 0.04640227985383605, 0.059603044576664654, 0.7164653110357513, 0.05282704758746826, 0.5907551540398815, 0.17484431545967238, 0.1706039072814447, 0.13543849659188778, 0.1548048976262575, 0.14952157923651122, 0.0652676629818596, 0.13547659906023057, 0.056157933266624105, 0.14723417067180855, 0.11064775324975218, 0.13407648096155134, 0.13371581622812045, 0.17438443065857667, 0.14223398621040162, 0.11246026421293387, 0.11657358936978213, 0.1403646407423863, 0.12065652072154898, 0.9863815967738936, 0.9789387584814427, 0.9904977103392496, 0.9910004220712358, 0.9863075689125594, 0.9867420750471229, 0.9903001745283264, 0.9869473767906454, 0.9885579186239353, 0.24124147648569538, 0.5314041932099065, 0.48845626801364295, 0.15028327515023243, 0.14924049929392202, 0.4511150674847736, 0.08847546286179864, 0.08864311088746868, 0.0854775621549112, 0.17269420044024464, 0.2195768545308011, 0.2262846139552761, 0.20169903167817516, 0.21803809002208063, 0.20427617764064543, 0.7522126067236318, 0.12669223273919417, 0.6981685664105007, 0.1418115347754212, 0.17873290950888876, 0.21600556590924902, 0.16499919017243736, 0.18499814346624954, 0.11915592759750382, 0.1787866974832072, 0.16278233977216572, 0.19189703599992458, 0.2087162326858224, 0.21688796972318825, 0.20039319165834846, 0.21771720581409493, 0.1053322208339561, 0.1947827522610387, 0.24065596298507252, 9.999999999998899e-05, 0.10459456256732336, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02977722141508643, 9.999999999998899e-05, 0.01595882479517219, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035258100886656596, 0.03185256684853177, 0.03504418161065492, 0.05954319727343993, 0.013615007474350072, 0.005006437601686398, 0.045327540701695535, 0.03322529643506511, 0.04276960374852312, 0.05073076352469108, 0.035670235593251665, 9.999999999998899e-05, 0.12473811619933495, 9.999999999998899e-05, 0.16092469803726017, 0.10152040860201161, 0.1112726213194215, 0.09324315748685985, 0.0429376832568269, 0.15214367787716276, 0.18195121968565287, 0.006284739460254651, 0.006202507332759732, 0.06276914550870638, 0.049571184281626435, 0.04933903816055574, 0.08087189604901579, 0.5008628977801848, 0.5531707165509349, 0.5179368396217662, 0.597076935722641, 0.5043330993585231, 0.5336641136992213, 0.512972512814417, 0.5342503634243836, 0.5491090198491109, 0.06730714328972665, 0.13307907565048793, 0.09691978611468566, 0.14464754736141183, 0.08697533124515044, 0.12211083912711018, 0.13037697015035388, 0.11894162396321772, 0.07851535819326783, 0.17751938670097844, 0.45338782994787374, 0.21421312906753054, 0.24010957165289304, 0.25092643130132475, 0.21477682412301524, 0.18485436109945952, 0.1837601565671757, 0.26191095315805346, 0.31405845574029867, 0.23866751578640155, 0.41667079095244774, 0.2788689222530516, 0.2797549671576117, 0.3248384716404209, 0.5190208262985945, 0.40751310929603957, 0.34862884287514073, 0.2523297430872924, 0.15192583045583252, 0.15050325104158202, 0.16101171217263544, 0.22039265658171503, 0.31347397358962514, 0.14716923612429167, 0.33805278460584764, 0.276101017588706, 0.20802418021604263, 0.23587063556901433, 0.1798085015360339, 0.19826984982526297, 0.1805309177725123, 0.20817991579355566, 0.21724525039356157, 0.19138513241269928, 0.21235588696234242, 0.1845737200116605, 0.19216793537261845, 0.19853033197725112, 0.22308683348753466, 0.6500795389610079, 0.25124053114390354, 0.22095495440538393, 0.22604777310980706, 0.21972290464256283, 0.8497900231907723, 0.16860393947193664, 0.15488605573773673, 0.12934066650156606, 0.2009226348618488, 0.1998505104461643, 0.12587138516005802, 0.16947229861344482, 0.15195998763024987, 0.6124496658063163, 0.11069823941950796, 0.5748315846708933, 0.2722229393595752, 0.22034435424074916, 0.21181382422281814, 0.1961976646009732, 0.1879714216741386, 0.6810822401905448, 0.2151355855579392, 0.17830303327265662, 0.19359356345373036, 0.17682161956708964, 0.20336292918888443, 0.198833498575971, 0.1808346083099288, 0.1883976841428725, 0.19760095874043437, 0.09050668852479504, 0.08912863974852447, 0.08020949307229075, 0.07589935555675298, 0.09364614274089222, 0.07464399062148219, 0.0806099818880952, 0.08122440974791045, 0.07729800836868472]}, "mutation_prompt": null}
{"id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "solution": "import numpy as np\n\nclass AdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Slightly increased cognitive component\n        self.c2 = 1.9  # Slightly decreased social component\n        self.inertia_weight = 0.5  # Introduced inertia weight for velocity update\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:  # Slightly increased chance for random walk\n                        random_step = np.random.normal(0, 0.5, self.dim)  # Changed to Gaussian random step\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiPhasePSODE", "description": "Multi-strategy optimization combining adaptive PSO, DE, and enhanced random walk to improve convergence and exploration balance.", "configspace": "", "generation": 6, "fitness": 0.26935989291473345, "feedback": "The algorithm AdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "534d2b47-c75f-44ce-b747-f4d4797e7344", "metadata": {"aucs": [0.7168794144931709, 0.7618170344743114, 0.7992242014950119, 0.797641647029368, 0.7929087786683535, 0.7778963170951906, 0.7605785236591284, 0.812321835606031, 0.7834492689045571, 0.24602374752019351, 0.039868954142841195, 0.5484441889907619, 0.6285513959883033, 0.04682762721388822, 0.6425845437668903, 0.5052505458876411, 0.6377365932739697, 0.6655203766923895, 0.13892747992493581, 0.16838602933196867, 0.13483249858355173, 0.14089145173914452, 0.1287413270457448, 0.12955466093571433, 0.14793632398457723, 0.13604157577948117, 0.2729073758901288, 0.1386310752282418, 0.1336109303712123, 0.13063362004187273, 0.12525184600793904, 0.14450281760405015, 0.12387803104831341, 0.1439252630490504, 0.09693341193155047, 0.15611475574557843, 0.9936072859282069, 0.9859915265712242, 0.9901674124966269, 0.9818482215894809, 0.9814393031253223, 0.9894968485886739, 0.990125662460498, 0.9901005336527908, 0.9865645927799931, 0.37801395860124065, 0.4348969498763319, 0.4505827702629719, 0.3797579924009661, 0.4057054925401592, 0.43732612631964907, 0.3647583522609732, 0.43340717429209286, 0.4237254979855042, 0.2187530984762971, 0.29429846649169056, 0.7653328563499785, 0.2314772202437182, 0.2688404977228621, 0.7218612631188674, 0.3317527687715508, 0.21384793098834054, 0.22036439409615816, 0.12386999499350226, 0.1244646571451683, 0.14764883429044806, 0.1485823975562156, 0.12808379435091333, 0.16600549765806538, 0.18668424967248642, 0.11105808698402886, 0.12863912277656686, 0.17774160661918958, 0.09253951637835378, 0.20465799820535102, 0.12824418656553715, 0.16350354804778766, 0.15686324524467565, 0.12878588256395795, 0.0870216696714653, 0.2055276905010497, 9.999999999998899e-05, 0.03869409652771827, 0.0360179332588092, 0.015327634342536478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1655904734899184, 0.030463394532836308, 0.017906182803383852, 0.03249393400452971, 0.09220012325527294, 0.008344044858907718, 0.011898490717547117, 0.04991611028335041, 0.02825384417583754, 0.07210372504987395, 0.1532455870752092, 9.999999999998899e-05, 0.04587159280136188, 0.3133080913828058, 0.0828057264003974, 0.1240521223675145, 0.089455605729439, 0.0630053910520384, 0.1695340408723487, 0.06463981409095054, 0.04099289145887686, 0.26378812556473596, 0.025923442228893534, 0.009310728515010802, 0.04135852226362058, 0.055936828233318914, 0.048311080354122016, 0.07998495025950958, 0.49925588136833754, 0.5238653791412415, 0.5385185109759969, 0.5674675909148643, 0.48903505839352956, 0.45531645828450973, 0.5174660856280642, 0.49977035122243463, 0.5362825311410273, 0.10245209789214782, 0.11276468550830343, 0.13143511219605952, 0.10391984612344163, 0.13561556694058363, 0.0881937551190225, 0.11929250780942824, 0.06507901299394381, 0.16908922667606074, 0.16336398095555238, 0.15376542642454827, 0.1826024469542864, 0.24954978210923817, 0.3047121222417064, 0.1562570158716139, 0.3111514910695641, 0.3221958483686207, 0.18436124816445842, 0.19904681697618798, 0.41941015681972627, 0.29559082673323356, 0.3699996190723668, 0.39150141083603873, 0.4099015837218484, 0.4035065330993338, 0.4504999877567093, 0.4238858928914384, 0.16887233087171938, 0.18099905999972954, 0.14124309632254772, 0.19728529311225917, 0.19530019438829826, 0.25811738387962835, 0.21665171222950907, 0.2837675963110454, 0.2934653126699558, 0.1854542644826208, 0.20679267738385598, 0.17284994316586766, 0.1820387300472721, 0.16467124051843707, 0.207856448969855, 0.1853791652505804, 0.18459077439471072, 0.21513936850681004, 0.23115409562360378, 0.21698741623722395, 0.24035588524067608, 0.18524349442961097, 0.2174269848711946, 0.20223438814408423, 0.20179163237127828, 0.188359544908151, 0.19812775618020728, 0.8399128601441067, 0.15044644853862132, 0.15358082640564175, 0.7846386574456294, 0.19887856528098913, 0.16933734065841366, 0.09975056482648725, 0.16945437369637184, 0.1643402166439517, 0.1547956840367446, 0.16756814810161247, 0.12376484336506477, 0.41671078330605826, 0.3788253739209573, 0.20968103518557502, 0.2111333269644723, 0.21228850338659755, 0.2105279373987079, 0.1851358102918208, 0.19169933204659473, 0.19409083739707134, 0.1855190385947061, 0.20149836492013606, 0.21808797430869342, 0.20199300939925002, 0.19365668093429744, 0.18708510806090206, 0.08223372262338557, 0.07574708285526177, 0.08638866521021371, 0.0825656877295623, 0.07854594008452676, 0.08319034611465725, 0.08603729248640413, 0.08069496829278544, 0.08312770570729777]}, "mutation_prompt": null}
{"id": "59a23655-a13d-4245-bf93-37b40d0661d7", "solution": "import numpy as np\n\nclass EnhancedMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.6\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate or j == np.random.randint(0, self.dim):\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.3, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiStrategyOptimizer", "description": "Enhanced multi-strategy optimization combining self-adaptive PSO, DE, and stochastic perturbations for improved exploration and convergence.", "configspace": "", "generation": 7, "fitness": 0.23216071912853434, "feedback": "The algorithm EnhancedMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.5967431919049007, 0.4828823855472598, 0.5429080050364214, 0.657100811005288, 0.7078376088993193, 0.6833363113239178, 0.6848730098169626, 0.657692070231721, 0.6713154494333522, 0.06120106657931612, 0.3924621929997194, 0.17191567409941655, 0.2911840690363192, 0.13259898344357623, 0.34747660317721696, 9.999999999998899e-05, 0.047911249025033076, 0.3403119062541974, 0.13417568249003364, 0.1237145261300453, 0.09521088337182682, 0.13069977738735483, 0.0682610654154383, 0.07119811067131232, 0.15348679546586141, 0.09946195118370638, 0.19920905496992702, 0.10692549357844838, 0.1270643721571929, 0.11160006283426849, 0.12228536498633125, 0.11844345378715204, 0.09137094585339078, 0.11356868308420254, 0.10362960830041046, 0.15296542014814296, 0.989432521775915, 0.9821282241377678, 0.9903931079818346, 0.9909697275055985, 0.9857663721045068, 0.9829557087948775, 0.9894412877507004, 0.9895034153251474, 0.9902152588418416, 0.30216884159651924, 0.25542768568793883, 0.3221239626207424, 0.32293300879694586, 0.2733300482177774, 0.34856913484629115, 0.35766763332146945, 0.2829010497536708, 0.27452348001704463, 0.19481969332532867, 0.27291019790429494, 0.22121546620002508, 0.18899620336977474, 0.20333561431468916, 0.26915870822538035, 0.23047154608465792, 0.14909959079017265, 0.2259076583486842, 0.14798401730624555, 0.29847732895069934, 0.16992206531478937, 0.14653686174743286, 0.15101763713145522, 0.14894447442875514, 0.18525115036334883, 0.1803052747476056, 0.15588252836791328, 0.17613139569099479, 0.11210210946150201, 0.11238909706570044, 0.15008145492452418, 0.13334594044458914, 0.13669822753116256, 0.1589838275324571, 0.13253271699877367, 0.17224582515410036, 9.999999999998899e-05, 9.999999999998899e-05, 0.04190269092418042, 0.030795371040796993, 9.999999999998899e-05, 0.035588617725342164, 0.0009479734904722648, 9.999999999998899e-05, 9.999999999998899e-05, 0.07193832810181489, 0.018227818074436852, 0.03733917593310321, 0.08613623852925034, 0.008078092501664802, 0.014426630750186242, 0.04843570230294569, 0.018181516264884734, 0.04145037556268272, 0.035484486031483575, 0.0284470455860395, 0.06313920127732253, 0.08101274156702143, 0.08391280578690108, 0.07064948972526996, 0.07311436956482376, 0.08479309086365905, 0.04814448843810404, 0.03795645446980911, 0.05241326268481172, 0.06121448743620039, 0.030811711158039046, 0.040103771248632625, 0.058449532531988035, 0.17888246819983633, 0.05786307741479546, 0.07798872688056036, 0.4356620383831513, 0.46205489856939563, 0.4568224562691475, 0.4505272016921895, 0.501344640646282, 0.48129807710848305, 0.4688634449301936, 0.5017546749309802, 0.47067234356290255, 0.1416898744574817, 0.11292212728850026, 0.10620652521002882, 0.08163458369836318, 0.08869147954187084, 0.10331299285617701, 0.08530244649681296, 0.10910789275719945, 0.11304122656384918, 0.2108013483841541, 0.14258029777643155, 0.15970744609686027, 0.42664102471280263, 0.2907192877303797, 0.16996053595028338, 0.1744036098286812, 0.25432305042244896, 0.1988807248278759, 0.24068937313718908, 0.33727754027189694, 0.2476552478829407, 0.188950716957075, 0.19515395442910366, 0.27117664318111623, 0.2680093119818995, 0.356642120482595, 0.32326869836983574, 0.22310876896013143, 0.18529894757529208, 0.1491151712994695, 0.18579304885731573, 0.18574026797284093, 0.2405170365180711, 0.23622036896056897, 0.24629798941420877, 0.2637239489978399, 0.21064502753873782, 0.20009944383792677, 0.18397544056171866, 0.1922245566863806, 0.19826548105128494, 0.17963047180551273, 0.18627385664745166, 0.20507152893774638, 0.1973632223373566, 0.2014755911340611, 0.1826088649347528, 0.2171076524641955, 0.1981732719983812, 0.3251178059622346, 0.1772259054839227, 0.19865380682855072, 0.19556633094462095, 0.19730672525264403, 0.7603662446789186, 0.1602325725219591, 0.15378350610847413, 0.58961832221859, 0.19423798899319977, 0.16540070034716103, 0.13360351949777582, 0.1682277311407202, 0.16305022155661497, 0.31452954777536934, 0.20650339094214354, 0.12608063286030957, 0.46053678268548603, 0.16577840776754804, 0.20898738010443696, 0.21081232514261483, 0.4202703416148853, 0.20540659315486431, 0.2168521712220669, 0.18920554699415948, 0.18746249467738485, 0.18615642644653185, 0.1968048848253191, 0.18346222510311494, 0.19285662100311673, 0.19659876734700577, 0.1971336526082379, 0.07759691512162703, 0.07493025312784862, 0.08357961768114441, 0.09309742587635661, 0.07905167585501405, 0.0765233299274165, 0.08025222249490471, 0.08579022119248692, 0.08493561830112284]}, "mutation_prompt": null}
{"id": "d8cfb0ac-a3c7-441f-a57b-8f20befb8dff", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor for balance\n        self.crossover_rate = 0.8  # Adjusted crossover rate for exploration\n        self.c1 = 2.2  # Enhanced cognitive component\n        self.c2 = 1.8  # Modified social component\n        self.inertia_weight = 0.6  # Adjusted inertia weight for stability\n        self.max_evaluations = budget\n        self.random_walk_prob = 0.18  # Dynamic random walk probability\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < self.random_walk_prob:\n                        random_step = np.random.normal(0, 0.5, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveMultiPhasePSODE", "description": "Enhanced Multi-phase optimization using dynamic adaptive PSO, DE, and strategic random walk to optimize exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.23478843058481982, "feedback": "The algorithm EnhancedAdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.5319803358775388, 0.5968921344294482, 0.641523649695559, 0.5781694617948814, 0.6699377627622829, 0.7210191877920067, 0.5879488030432443, 0.690063830298024, 0.646944230385067, 0.26756404205302664, 0.22976535753176164, 0.036646763033054586, 9.999999999998899e-05, 0.2936648101533553, 0.31426005095172493, 0.23923467791962028, 0.048078005040436245, 0.3858721527529081, 0.16170348304581095, 0.09825688946824507, 0.12605726765743808, 0.15110609909561068, 0.1000350649293772, 0.12170522610591505, 0.09439162664262091, 0.14860731247318582, 0.19375716587415193, 0.10459018069327808, 0.11738209740960259, 0.10918961050034415, 0.1455190275151539, 0.09413467771618067, 0.07725476832435285, 0.1293177447992654, 0.13267919389568983, 0.11484141404980508, 0.9928395265821242, 0.9850618862942881, 0.9901733535918035, 0.9826829503741302, 0.9846437303237365, 0.9826334495053074, 0.9900571051782381, 0.98952025144719, 0.9902737643633835, 0.3436216904053746, 0.3335352482557866, 0.3090408378892837, 0.2977888630318535, 0.2642097490223059, 0.27596177727408666, 0.2916500652628031, 0.31469965328943583, 0.3007227795424876, 0.24703766167336527, 0.4433740750901851, 0.5908388263326088, 0.25109186663305627, 0.23617018562535452, 0.18726572321518364, 0.2088242966677586, 0.23229748944389916, 0.266201279548702, 0.11833019740480011, 0.1527233022018969, 0.16247738506571108, 0.10918426700076178, 0.14327178049684353, 0.27428939660113627, 0.1421074058809707, 0.14780907506348884, 0.1531872197932882, 0.12914246371503668, 0.10512323174273097, 0.13943148719212872, 0.17854329465692975, 0.1491102478679135, 0.13401001611447505, 0.14386734502830512, 0.09043332317622099, 0.16637007871368936, 9.999999999998899e-05, 0.007208765704626918, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010546044784813802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0700401488891379, 0.025412116564889065, 0.08371921363368051, 0.09400234425854492, 0.045824680979045684, 0.03823198735679212, 0.027369923626419768, 0.06705085829500912, 0.06362996463134185, 0.03459787631832589, 0.03709569703975668, 0.050454575247498856, 0.06290427508751417, 0.062314287056882134, 0.10347385409608267, 0.07772623661775524, 0.0472356366920923, 0.06140419889807003, 0.06041090624592893, 0.04446696885953516, 0.1340663027146718, 0.0052766452778049144, 0.08311985703848401, 0.13766205295731704, 0.17127909998357282, 0.059914633659169936, 0.07966515765806492, 0.4609867543888688, 0.44190394741568817, 0.42433784543897235, 0.4632621926979633, 0.49027227562366327, 0.47290204870443653, 0.4663691290806924, 0.4251375450150193, 0.4155392001709497, 0.07411562102755465, 0.11529835917847997, 0.1196393242092878, 0.09617183723868672, 0.1320051229991992, 0.11235183324522946, 0.08233012132823969, 0.07502910805713037, 0.06902007607173222, 0.1862968224691458, 0.1881498420382055, 0.17566111665433415, 0.18375359289141313, 0.22716212896112187, 0.20493434368209607, 0.33459084025673635, 0.2008067301923009, 0.15292751048081477, 0.32951509120073375, 0.36416307422180394, 0.2698585075401646, 0.1997933688873248, 0.2948051108226517, 0.3477308821593502, 0.30374715929735263, 0.3380188489082956, 0.26716794661005394, 0.21722705225740313, 0.16683971660017216, 0.2439420713072583, 0.2953341657662417, 0.17678139878915822, 0.18591357344832327, 0.21719492163397458, 0.20017242815698788, 0.25816141665712544, 0.2029468413148806, 0.19460470779479933, 0.19288084378820347, 0.22628773803176017, 0.2166057365012567, 0.19573392464398998, 0.22731483547223408, 0.19164492240553288, 0.1709222008854545, 0.19906182719735677, 0.2102877145326293, 0.24215978049825593, 0.22804378528356484, 0.19858141813412544, 0.22000538098531297, 0.2311680364534111, 0.24526666635617, 0.2191860588544966, 0.16383969894625294, 0.16507794579276747, 0.15384344015804674, 0.7604904699008461, 0.19767667230647257, 0.1935132885561619, 0.09970806082873873, 0.1686008737546566, 0.1854548306773981, 0.16108955940109249, 0.16803579226157195, 0.28505224116282424, 0.2053257253643912, 0.3735616643624535, 0.21178659741033745, 0.21181278364697342, 0.48588815791018936, 0.29668024431015727, 0.19286325596382903, 0.19557422564348692, 0.21059608081064085, 0.1916052405316243, 0.22196404355099864, 0.20430395645442356, 0.17926095118533247, 0.18307528056174283, 0.18034248802535768, 0.0840962892354622, 0.08059198847600513, 0.06896816624544067, 0.08516321890291978, 0.09313593708740553, 0.08447285794430504, 0.07835402764711474, 0.07323517767914423, 0.07060733124587881]}, "mutation_prompt": null}
{"id": "cd2335fb-e910-4662-89b6-a1cc9ef4ea26", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.crossover_rate = 0.8    # Adjusted crossover rate\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.45   # Modified inertia weight\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.12:  # Adjusted chance for random walk\n                        levy_step = np.random.normal(0, 1, self.dim) * 0.1  # Introduced Levy flight step\n                        candidate_vector = np.clip(self.particles[i] + levy_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveMultiPhasePSODE", "description": "Enhanced multi-strategy optimization combining adaptive PSO with DE and Levy flight for improved exploration and convergence.", "configspace": "", "generation": 9, "fitness": 0.2637208183153987, "feedback": "The algorithm EnhancedAdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.7956393143371258, 0.7955366168653137, 0.8270174329162064, 0.8695477220480721, 0.8683231103365737, 0.8250185887861192, 0.8129713674285278, 0.7910616532446045, 0.8146954912267649, 0.07733615100101454, 0.4817577117714059, 0.07902533146276491, 0.6882554128146818, 0.5826579849926984, 0.06582629722498479, 0.017301163173688683, 0.6429660884510984, 0.64908972268698, 0.511829694872459, 0.12596028432099338, 0.14111544241470997, 0.43391460337642096, 0.11199821175926172, 0.14143847611431903, 0.16786264934991812, 0.3460897684989169, 0.13698075294441536, 0.13602836924285744, 0.10837204767036435, 0.1223100677252471, 0.10723480028746324, 0.10555476867944635, 0.12267228364515681, 0.0710620920603402, 0.1263277661966975, 0.11804685673302506, 0.9928581195996459, 0.9854945140768342, 0.9902950790767743, 0.975460647032469, 0.992794347393083, 0.9865950722358902, 0.9903614260045804, 0.9905854777723844, 0.9900053593519329, 0.39484158986322293, 0.47588462451661406, 0.457832585430762, 0.4170179672015166, 0.4081144082663286, 0.42576626826656316, 0.43628973708971186, 0.3800960414846447, 0.4143456177885465, 0.2219746299371741, 0.2866529710564055, 0.3264119547179699, 0.2774482492157092, 0.1923157919219688, 0.2589842811212538, 0.25811100202861326, 0.21698671840294526, 0.11584510162464035, 0.12185325984631379, 0.18570545979769293, 0.21094977167856677, 0.12537575012445357, 0.1285473705043021, 0.19030356914942514, 0.2070708923637523, 0.2518134235235655, 0.17808826394823773, 0.19347012530482022, 0.008377731834276925, 0.1777221468073551, 0.1790702112686826, 0.19720728018917744, 0.18672339770694701, 0.1249757676925457, 9.999999999998899e-05, 0.23851857855083136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006843229218186364, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05277004323393797, 0.03588195751130807, 0.07313066560934423, 0.08428908332486895, 0.004590502052730927, 0.021730227883773434, 0.12666371695430612, 0.03242163539741072, 0.07694535839077377, 0.17000120659601248, 0.031543297243376234, 0.05366744433145798, 0.07158828586579324, 0.07227414432588686, 0.15355359727617046, 0.10061571450073481, 0.09324444511057806, 0.09177983161267855, 0.06265944101100307, 0.011276856711446293, 0.23943696370617829, 0.014561585327669713, 0.051226351102504175, 0.062186906789365115, 0.05467037662952445, 0.047287594145231204, 0.08793936225347565, 0.5165412815428818, 0.4705813867610753, 0.5064641060086328, 0.5889303808926158, 0.47290167676112727, 0.5367716374750999, 0.5182823151437193, 0.5343435029993172, 0.5110884038198957, 0.1481191251124686, 0.10366954510379378, 0.08998061349852537, 0.10840462768974302, 0.10879730285021849, 0.09994439058752558, 0.0902031277359141, 0.10790679044287121, 0.12087962328627322, 0.19140545949269794, 0.22104508699566106, 0.2659138637846703, 0.1783487580087536, 0.2267132535272961, 0.24131074082356285, 0.20069910906850907, 0.1945547770607583, 0.2515972445161747, 0.24828989032597437, 0.25281654686498234, 0.3974198254964165, 0.35336296377676046, 0.30241475668475193, 0.40874737220342006, 0.27153743969063693, 0.4263747394164361, 0.41059489622723244, 0.24569647342796042, 0.1806218387728915, 0.16172449587349802, 0.25304141116897627, 0.24071045286347204, 0.34307157248761444, 0.1582408188619554, 0.24473345838314275, 0.19090206797556808, 0.167811119828276, 0.18831912251439853, 0.20801663813062166, 0.1873186889818783, 0.24725111033878, 0.18171809159421637, 0.20618207451385828, 0.19745209307955713, 0.1957921967864289, 0.19109477500673844, 0.2337764265792801, 0.1912763011975841, 0.24057433357240765, 0.2277783956223216, 0.20484172387328992, 0.21468053742679172, 0.21318395488976716, 0.20023070911567886, 0.8552609274144155, 0.16741337238390208, 0.15461184394960092, 0.8499684302118884, 0.20003256549144177, 0.16930745146508397, 0.1667290072701587, 0.16991619509722877, 0.1521565297424411, 0.1540531642006816, 0.203979423776544, 0.20574925138856837, 0.20828212801451074, 0.16947358634404808, 0.20974725114291493, 0.10481492136027659, 0.21041269228417248, 0.1268158556482758, 0.19467940005027484, 0.19744187365994625, 0.19311826430022971, 0.18851099038550023, 0.20119502678186052, 0.1994136210880445, 0.19797425168488203, 0.21752784715788243, 0.19471122967856913, 0.08003255706731471, 0.09169044263036108, 0.07667837711959491, 0.07468254340905911, 0.08336419124413097, 0.09799421403512809, 0.09210170528140804, 0.06608658378479393, 0.08128199778850853]}, "mutation_prompt": null}
{"id": "8da3a3fd-606b-4a4b-8eef-19305d479d27", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly decreased mutation factor for better stability\n        self.crossover_rate = 0.8  # Increased crossover rate to enhance diversity\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight_max = 0.9  # Dynamic inertia weight max\n        self.inertia_weight_min = 0.4  # Dynamic inertia weight min\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        iteration = 0\n        while evaluations < self.max_evaluations:\n            inertia_weight = ((self.inertia_weight_max - self.inertia_weight_min) *\n                              (self.max_evaluations - evaluations) / self.max_evaluations) + self.inertia_weight_min\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                crossover_points = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector[crossover_points] = mutant_vector[crossover_points]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:  # Probability for random walk\n                        random_step = np.random.normal(0, 0.5, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveMultiPhasePSODE", "description": "Enhanced AdaptiveMultiPhasePSODE utilizing dynamic inertia and self-adaptive DE parameters for improved balance between exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.18443050165188193, "feedback": "The algorithm EnhancedAdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.4025428239636294, 0.42308728256412065, 0.45228372727101407, 0.5200077141346663, 0.4249413024986646, 0.438272164401755, 0.4577836724251273, 0.4161829885626459, 0.5375674490462632, 0.04532092700860557, 0.10529442319311388, 9.999999999998899e-05, 0.023375565964160683, 0.013708417047051058, 9.999999999998899e-05, 0.02579528535997866, 0.06120787386316329, 0.22959151905581499, 0.096573768806276, 0.09900843112929147, 0.08526039335212121, 0.14420808057730194, 0.08242799179646665, 0.0770020655729029, 0.10772540492117644, 0.09464665328224053, 0.08571819729028085, 0.10147513524889162, 0.06288167528388855, 0.053642826666120524, 0.09435749534003557, 0.07829800632317152, 0.07159403090834571, 0.0730050586868749, 0.08878028294404738, 0.09644728576217798, 0.993594803508031, 0.981799495784089, 0.9903521021641971, 0.9864442690468178, 0.9885399715521601, 0.9709848030388546, 0.9906362093026364, 0.9892680824915779, 0.9899259674501941, 0.21251936902987933, 0.2085979209897022, 0.1698400966191128, 0.2170292028694134, 0.22537183922401716, 0.1975516167842396, 0.20000489287907153, 0.20509037670542574, 0.20406422568861482, 0.2356667562482715, 0.17086480556744388, 0.1815027289598634, 0.19060011371225427, 0.21543482243388024, 0.1769252414829089, 0.17361468401075164, 0.18864108800075052, 0.2692679392284799, 0.08343769300111781, 0.08121397978704537, 0.07487670219985865, 0.06590408424762717, 0.16882585413470952, 0.09578794282174363, 0.11220015068353606, 0.09667486384634072, 0.09807193727997054, 0.0990561726198812, 0.10402302920002271, 0.0916112723091197, 0.06606928808115242, 0.06446238220187295, 0.1353116960249412, 0.10795955421748804, 0.06489316156977021, 0.09023969134223231, 9.999999999998899e-05, 9.999999999998899e-05, 0.00013225631069269106, 0.0032322449241716233, 0.00013245748503543098, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04978116878259842, 0.020345581332851026, 0.01947945381962779, 0.06701669165922108, 0.000977755783576173, 0.015619379363239982, 0.034887857931305555, 0.04585792754030116, 0.05141616269412319, 0.02021475204028489, 0.012913941596987333, 0.01593112686186393, 0.05066642121624276, 0.017359724055110215, 0.030086268359399204, 0.024626988653730808, 0.024280539837000847, 0.02188213731566835, 0.028247202786538805, 0.02897199559854291, 0.06820566505489134, 0.055683244984922387, 0.07159185926441147, 0.09606344532115962, 0.05699495779154751, 0.038060153492481597, 0.06059672007992356, 0.4110582254867038, 0.32671138417605006, 0.3888472661521142, 0.363424057569637, 0.34458949728173915, 0.4043018096361123, 0.3308120277993263, 0.33336419895406266, 0.3537609122475106, 0.07799656731754545, 0.08136240074769208, 0.08912080647991005, 0.07850455393081379, 0.08926733271881637, 0.08982339599511902, 0.06355158173592701, 0.0768642774899787, 0.06656838488361116, 0.15181133717413509, 0.1425062425313346, 0.18332136042681768, 0.16397311304739215, 0.17482899344857905, 0.169873119211582, 0.22003906663163553, 0.15080284055812387, 0.15796258077777292, 0.21294828358298978, 0.2219344487151521, 0.22415903266861636, 0.17361925821394275, 0.2568615179154947, 0.19433868511770647, 0.2726802892340584, 0.26616179800592743, 0.15979981997019876, 0.0984668844106309, 0.15366982004676466, 0.1776318984167794, 0.13271654479577033, 0.15548799333050323, 0.19014269335272993, 0.20427455281649542, 0.19685493807112853, 0.18931298002260422, 0.16885864689749397, 0.18825141153099856, 0.17332376022375917, 0.20177984492496892, 0.14647010244123504, 0.16759645056103234, 0.1897666744294394, 0.18459029337196842, 0.19749040038868138, 0.17240190635882313, 0.17664761339894708, 0.19890691832504614, 0.19206991700290132, 0.18006249637137006, 0.20075781072451648, 0.17469355959136668, 0.17802425861283477, 0.17192542137185263, 0.5192051220799198, 0.16522093618663236, 0.14897792207991167, 0.18177119500822458, 0.1931672956699334, 0.12799880009128772, 0.09914126099718523, 0.16767343070444674, 0.3259409570616152, 0.26088411884806695, 0.16517007520350147, 0.1894164419569061, 0.18337137662087033, 0.29678833713305397, 0.32654986099066363, 0.12374230660577634, 0.14491877537518139, 0.20705947004250358, 0.18561412435618307, 0.1827981820498663, 0.18439388936957346, 0.17956871749942294, 0.19683165655953794, 0.21357268964805987, 0.20083635655774357, 0.18391092369902518, 0.20238893860159957, 0.05852877729682937, 0.07501945970218316, 0.07653403431501815, 0.06567019582510569, 0.08075162415576032, 0.06648945350415414, 0.06372461456073486, 0.0617343873996673, 0.07507150689567754]}, "mutation_prompt": null}
{"id": "e8889855-1f44-4132-8dc1-1e1bc3606a42", "solution": "import numpy as np\n\nclass EnhancedMultiPopDynamicSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.sub_population_size = 10\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor for diversity\n        self.crossover_rate = 0.75\n        self.c1 = 2.0  # Balanced cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.4  # Tuned inertia weight for faster convergence\n        self.dynamic_weight = 0.9  # Introduced dynamic weight for adaptive tuning\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.sub_population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.pop_size):\n                    if np.random.rand() < 0.125:  # Adjusted chance for random walk\n                        random_step = np.random.normal(0, 0.5 * self.dynamic_weight, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPopDynamicSearch", "description": "Enhanced Multi-population Dynamic Search Algorithm employs adaptive multi-population management, hybrid strategies, and dynamic parameter tuning to tackle diverse black box optimization challenges efficiently.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedMultiPopDynamicSearch' object has no attribute 'pop_size'\").", "error": "AttributeError(\"'EnhancedMultiPopDynamicSearch' object has no attribute 'pop_size'\")", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {}, "mutation_prompt": null}
{"id": "2d177d2e-6f00-416d-b15e-bec7ba235dbe", "solution": "import numpy as np\n\nclass AdaptiveMultiPhasePSODERefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = np.random.uniform(0.8, 1.0)  # Randomized mutation factor for diversity\n        self.crossover_rate = np.random.uniform(0.6, 0.8)  # Randomized crossover rate for adaptability\n        self.c1 = 1.9  # Balanced cognitive component\n        self.c2 = 2.1  # Adjusted social component\n        self.inertia_weight = np.random.uniform(0.4, 0.6)  # Dynamic inertia weight\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # Further increased chance for random walk\n                        random_step = np.random.normal(0, 0.6, self.dim)  # More exploratory Gaussian random step\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiPhasePSODERefined", "description": "Enhanced multi-strategy optimization using adaptive PSO, DE with parameter adaptations, and a refined random walk for improved convergence and exploration.", "configspace": "", "generation": 12, "fitness": 0.2518246783396827, "feedback": "The algorithm AdaptiveMultiPhasePSODERefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.8327650218041229, 0.6658892334313691, 0.7999371276650831, 0.7660423687292931, 0.6905674690619451, 0.8001138261233695, 0.8000909775413704, 0.7022531936035754, 0.8457352823498762, 0.07259656842277307, 0.03579158825156792, 9.999999999998899e-05, 0.6012062961893256, 0.39585951061330826, 0.4398598882201925, 0.5588125846778778, 0.014694654859451983, 0.648251430121253, 0.10820505438470152, 0.1339731541067838, 0.4194998243075444, 0.16198364504091567, 0.2002616243139277, 0.17447415013375123, 0.16137369131739976, 0.10706853953873707, 0.3174646758600962, 0.1250676992831391, 0.08390949548674453, 0.10953945165482515, 0.13946617798922, 0.10649751643032301, 0.09818918680599276, 0.11840617373107065, 0.10308749991167021, 0.14404375895096677, 0.9863424962785812, 0.9809242849282959, 0.9900809412997104, 0.9896952046982063, 0.9901665436303276, 0.9849511422260021, 0.9868965420496844, 0.9886189804578523, 0.9855065407671632, 0.4202229067400626, 0.27018139563902577, 0.4814010023433677, 0.44093729721172825, 0.14310644626893376, 0.15511313306427055, 0.3995203370769045, 0.2972747779219773, 0.43982666809864346, 0.3323076533352247, 0.23763943954432876, 0.591951518337803, 0.20610272161315557, 0.23594655189315383, 0.20761946889644145, 0.2747211146610363, 0.2068320868468615, 0.2320079645604609, 0.17557988052094298, 0.14304307210642653, 0.1484746543833424, 0.18006225029398815, 0.14004569894738672, 0.1768287150445521, 0.18042491146663675, 0.14768187574218172, 0.12816368373731335, 0.19231730399820646, 0.104046990098835, 0.1842393500459052, 0.17471094036758295, 0.13156830740487513, 0.12513144437225843, 0.12495135770635257, 9.999999999998899e-05, 0.21979542580349065, 9.999999999998899e-05, 9.999999999998899e-05, 0.05127659600746082, 9.999999999998899e-05, 9.999999999998899e-05, 0.037681148657833674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0542165762511706, 0.02798472417425346, 0.15322612558087823, 0.049176040349922734, 0.005577940884275656, 0.004377960240777745, 0.13198329705961964, 0.046191408558693525, 0.047602153206595776, 9.999999999998899e-05, 0.15549409407218662, 0.030183364010612057, 0.08335865403821408, 0.15229645784460477, 0.07683293149333459, 0.09353688321247633, 0.10969937154743914, 0.06765159305296475, 0.04867978726141409, 0.04008218643165895, 0.11451907857128552, 0.0481320413128693, 0.0735471543567976, 0.04376251413236809, 0.07742005797212836, 0.07772361583313736, 0.21671831316518297, 0.5214109639682201, 0.39840799499404234, 0.5856228934316532, 0.516785591512638, 0.4310100068338949, 0.600552279278649, 0.5164986453473268, 0.4750043277420345, 0.5106930111435584, 0.11716107079249327, 0.11586660625432965, 0.10528086366075118, 0.12335514441894535, 0.14533845899218178, 0.1400624891718053, 0.10634479353673687, 0.09135746192649807, 0.09126521828782419, 0.20180036092665476, 0.22539066059714774, 0.1850843473327044, 0.2592721949087933, 0.21061447846009262, 0.1454895008198388, 0.2577592469495835, 0.1376903165465143, 0.15923690189027762, 0.23826867519531292, 0.3000740739956127, 0.28263579699431474, 0.40597577685454866, 0.20157817031376501, 0.40475823248370413, 0.36026741317581046, 0.3408302926079462, 0.1582635752239474, 0.32172660558914024, 0.1938932640988299, 0.13632563615944004, 0.2100052935925043, 0.14450337083638332, 0.25440372309336945, 0.263861466598155, 0.19975693250046767, 0.2686655373301535, 0.22638034009182517, 0.18159994078033015, 0.21104826986098113, 0.18360831187894555, 0.15671897263092072, 0.19347555440721653, 0.20033014939680394, 0.20327388111775835, 0.2199972964142881, 0.24949203268516962, 0.19395070912543866, 0.21562452825337697, 0.18882690019492732, 0.2326982289093994, 0.17700649180164818, 0.19482186583852512, 0.20171995729311487, 0.20806999118301128, 0.8316887547456691, 0.16840247951199994, 0.1537664620077569, 0.17159644042095534, 0.20015859428271887, 0.19767180715323351, 0.09977238259664267, 0.168219398107312, 0.1617509722417908, 0.12615415013376807, 0.16735505402287376, 0.3588761218883433, 0.21048752077203248, 0.32603427734550183, 0.5023240315584815, 0.2118770918531473, 0.20796755303931436, 0.10412733237859828, 0.18703823973770517, 0.18065868182338762, 0.19598402072942778, 0.1998233546722148, 0.19644772783047648, 0.20016497412696987, 0.19543917733131888, 0.21822184465363226, 0.2059391473593607, 0.09594428515352416, 0.08922053389469453, 0.10096433247141412, 0.08849508415182261, 0.08412506673145903, 0.08490069750453766, 0.09312956378066051, 0.08233879406650702, 0.09240005043674282]}, "mutation_prompt": null}
{"id": "578a4bfe-ce3e-48f7-97d6-f7683bd61156", "solution": "import numpy as np\n\nclass AdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Slightly increased cognitive component\n        self.c2 = 1.9  # Slightly decreased social component\n        self.inertia_weight = 0.5  # Introduced inertia weight for velocity update\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                \n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                \n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                \n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n            \n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                \n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_score = func(trial_vector)\n                evaluations += 1\n                \n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                \n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:  # Slightly increased chance for random walk\n                        random_step = np.random.normal(0, 0.5, self.dim)  # Changed to Gaussian random step\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        \n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        \n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        \n                        if evaluations >= self.max_evaluations:\n                            break\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiPhasePSODE", "description": "Multi-strategy optimization combining adaptive PSO, DE, and enhanced random walk to improve convergence and exploration balance.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.7168794144931709, 0.7618170344743114, 0.7992242014950119, 0.797641647029368, 0.7929087786683535, 0.7778963170951906, 0.7605785236591284, 0.812321835606031, 0.7834492689045571, 0.24602374752019351, 0.039868954142841195, 0.5484441889907619, 0.6285513959883033, 0.04682762721388822, 0.6425845437668903, 0.5052505458876411, 0.6377365932739697, 0.6655203766923895, 0.13892747992493581, 0.16838602933196867, 0.13483249858355173, 0.14089145173914452, 0.1287413270457448, 0.12955466093571433, 0.14793632398457723, 0.13604157577948117, 0.2729073758901288, 0.1386310752282418, 0.1336109303712123, 0.13063362004187273, 0.12525184600793904, 0.14450281760405015, 0.12387803104831341, 0.1439252630490504, 0.09693341193155047, 0.15611475574557843, 0.9936072859282069, 0.9859915265712242, 0.9901674124966269, 0.9818482215894809, 0.9814393031253223, 0.9894968485886739, 0.990125662460498, 0.9901005336527908, 0.9865645927799931, 0.37801395860124065, 0.4348969498763319, 0.4505827702629719, 0.3797579924009661, 0.4057054925401592, 0.43732612631964907, 0.3647583522609732, 0.43340717429209286, 0.4237254979855042, 0.2187530984762971, 0.29429846649169056, 0.7653328563499785, 0.2314772202437182, 0.2688404977228621, 0.7218612631188674, 0.3317527687715508, 0.21384793098834054, 0.22036439409615816, 0.12386999499350226, 0.1244646571451683, 0.14764883429044806, 0.1485823975562156, 0.12808379435091333, 0.16600549765806538, 0.18668424967248642, 0.11105808698402886, 0.12863912277656686, 0.17774160661918958, 0.09253951637835378, 0.20465799820535102, 0.12824418656553715, 0.16350354804778766, 0.15686324524467565, 0.12878588256395795, 0.0870216696714653, 0.2055276905010497, 9.999999999998899e-05, 0.03869409652771827, 0.0360179332588092, 0.015327634342536478, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1655904734899184, 0.030463394532836308, 0.017906182803383852, 0.03249393400452971, 0.09220012325527294, 0.008344044858907718, 0.011898490717547117, 0.04991611028335041, 0.02825384417583754, 0.07210372504987395, 0.1532455870752092, 9.999999999998899e-05, 0.04587159280136188, 0.3133080913828058, 0.0828057264003974, 0.1240521223675145, 0.089455605729439, 0.0630053910520384, 0.1695340408723487, 0.06463981409095054, 0.04099289145887686, 0.26378812556473596, 0.025923442228893534, 0.009310728515010802, 0.04135852226362058, 0.055936828233318914, 0.048311080354122016, 0.07998495025950958, 0.49925588136833754, 0.5238653791412415, 0.5385185109759969, 0.5674675909148643, 0.48903505839352956, 0.45531645828450973, 0.5174660856280642, 0.49977035122243463, 0.5362825311410273, 0.10245209789214782, 0.11276468550830343, 0.13143511219605952, 0.10391984612344163, 0.13561556694058363, 0.0881937551190225, 0.11929250780942824, 0.06507901299394381, 0.16908922667606074, 0.16336398095555238, 0.15376542642454827, 0.1826024469542864, 0.24954978210923817, 0.3047121222417064, 0.1562570158716139, 0.3111514910695641, 0.3221958483686207, 0.18436124816445842, 0.19904681697618798, 0.41941015681972627, 0.29559082673323356, 0.3699996190723668, 0.39150141083603873, 0.4099015837218484, 0.4035065330993338, 0.4504999877567093, 0.4238858928914384, 0.16887233087171938, 0.18099905999972954, 0.14124309632254772, 0.19728529311225917, 0.19530019438829826, 0.25811738387962835, 0.21665171222950907, 0.2837675963110454, 0.2934653126699558, 0.1854542644826208, 0.20679267738385598, 0.17284994316586766, 0.1820387300472721, 0.16467124051843707, 0.207856448969855, 0.1853791652505804, 0.18459077439471072, 0.21513936850681004, 0.23115409562360378, 0.21698741623722395, 0.24035588524067608, 0.18524349442961097, 0.2174269848711946, 0.20223438814408423, 0.20179163237127828, 0.188359544908151, 0.19812775618020728, 0.8399128601441067, 0.15044644853862132, 0.15358082640564175, 0.7846386574456294, 0.19887856528098913, 0.16933734065841366, 0.09975056482648725, 0.16945437369637184, 0.1643402166439517, 0.1547956840367446, 0.16756814810161247, 0.12376484336506477, 0.41671078330605826, 0.3788253739209573, 0.20968103518557502, 0.2111333269644723, 0.21228850338659755, 0.2105279373987079, 0.1851358102918208, 0.19169933204659473, 0.19409083739707134, 0.1855190385947061, 0.20149836492013606, 0.21808797430869342, 0.20199300939925002, 0.19365668093429744, 0.18708510806090206, 0.08223372262338557, 0.07574708285526177, 0.08638866521021371, 0.0825656877295623, 0.07854594008452676, 0.08319034611465725, 0.08603729248640413, 0.08069496829278544, 0.08312770570729777]}, "mutation_prompt": null}
{"id": "11e95311-625d-4217-8bf5-d1cad40227f7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.05 \n        self.c2 = 1.95  \n        self.inertia_weight = 0.6  \n        self.max_evaluations = budget\n        self.cooling_factor = 0.99  # New cooling factor for adaptive parameter tuning\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.4, self.dim)  # Adjusted Gaussian random step\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveMultiPhasePSODE", "description": "Enhanced adaptive multi-phase algorithm integrating local search heuristics and adaptive parameter tuning for improved exploration and exploitation in optimization tasks.", "configspace": "", "generation": 14, "fitness": 0.2740556024022824, "feedback": "The algorithm EnhancedAdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "a411db5a-8ed8-49c2-a9cc-2cd55cced323", "metadata": {"aucs": [0.8003218247598869, 0.8037538381033454, 0.8406239508165341, 0.830267741939837, 0.8297137706137393, 0.8425816786698934, 0.8325897186429749, 0.8117524571377996, 0.8203726001680541, 0.6540196949426851, 0.040111778247736374, 0.0390906724982637, 0.04173705855905918, 0.19435571676591534, 0.6915362470958838, 0.7256177028331732, 0.018437983878645148, 0.679415687151304, 0.1445198755962871, 0.15704341926341914, 0.1449318433958846, 0.1626495965880126, 0.1279902144781132, 0.07264199594557508, 0.11060058389067651, 0.12752369240109052, 0.16148677434227598, 0.11263369839460702, 0.10257062071120049, 0.12300555277611569, 0.11435054227222685, 0.1401127827346076, 0.09945998576894599, 0.10177850437828895, 0.15226468065423016, 0.1134772637363558, 0.9936201582557919, 0.9852549848737409, 0.9897197014724883, 0.9776768393780837, 0.981505826884191, 0.9860067684497856, 0.9904536618090609, 0.9923084867587288, 0.9895181351481616, 0.5573899220395538, 0.5892163026141963, 0.6048941178046883, 0.5878940002709848, 0.6423909361754203, 0.5904687286674322, 0.49018951574078284, 0.4897860056752569, 0.6148329872125019, 0.22451538750407096, 0.620121026848167, 0.22686376148767262, 0.8025550472773436, 0.8163351713103959, 0.20647980067641392, 0.217701387219696, 0.19305004465870013, 0.22071962886799334, 0.110951150717428, 0.18826073224466744, 0.1479377909443419, 0.12417945052003576, 0.18356021465701378, 0.11828115536937311, 0.17580836848734793, 0.15674432016058004, 0.17360978088270473, 0.07533605853677194, 0.11431872841434865, 0.1793583593681518, 0.2134603053895121, 0.15869743933007963, 0.11540886916586679, 0.19746265128211393, 0.098253757864189, 0.03983142317003008, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01511599937723418, 9.999999999998899e-05, 9.999999999998899e-05, 0.014139366130365816, 9.999999999998899e-05, 9.999999999998899e-05, 0.031067291334077707, 0.03264825091270562, 0.03074245026976319, 0.08277346096421223, 0.0037335832458502693, 0.020418317132053887, 0.019386204399055584, 0.10060390335918978, 0.04269223485515472, 9.999999999998899e-05, 0.09635977727834832, 0.13460974420763816, 0.08260040174049899, 0.13132936510191195, 0.07983039693330207, 0.09374579877974598, 0.14791493052956628, 0.06451567242433609, 0.04226851583882252, 0.04087154471627019, 0.18431660142211737, 0.0063431679258044715, 0.04949393622223275, 0.060633393799326085, 0.06557374237118985, 0.07534171859854577, 0.05663900056619475, 0.5079566928343158, 0.5139777775021306, 0.5369401501193878, 0.5677387628785457, 0.5106429338135066, 0.5046706506647394, 0.5211479138558113, 0.5671440630109741, 0.5215284986348607, 0.06644696882220347, 0.13081927209525712, 0.1204725330018962, 0.07946510140938301, 0.08363919471657755, 0.10586643074541568, 0.15012812589661229, 0.11516416018156328, 0.1305131610444239, 0.18369641764971545, 0.3938854676578476, 0.2122173626849021, 0.1684022745323488, 0.48289172926480783, 0.16831158769226917, 0.3744997782369105, 0.19630429207069777, 0.17909697097948885, 0.3034202505267123, 0.30170768314325347, 0.44965035277880305, 0.21962410001492894, 0.25561442178238125, 0.3633451703029402, 0.32509809014851676, 0.30706287811644417, 0.16244459768454467, 0.19059606685231278, 0.28050266592798523, 0.16776269690013546, 0.33115712894270377, 0.1953358019256788, 0.21643370440080245, 0.22100729367384775, 0.27093544572556516, 0.24684612303036635, 0.2287394483177193, 0.20930969373245067, 0.18985055662967865, 0.1827786322318633, 0.19683786288137672, 0.2227477831224759, 0.18164851693840733, 0.22795245234597306, 0.21418983901239208, 0.19531474087037703, 0.1915598591656521, 0.6488912293956612, 0.2403181984870334, 0.2020744410992783, 0.24034891725333118, 0.2015610643396909, 0.21405574255947235, 0.196986399237141, 0.8562527836220861, 0.18182586568951042, 0.15348649630752864, 0.19592813584946656, 0.19912187857282948, 0.1687550558306189, 0.09983547195511566, 0.168818099499343, 0.1649957576965133, 0.08303569902800978, 0.20699439041535028, 0.20712003885377728, 0.4147885251667982, 0.1640182332579445, 0.6434991344719456, 0.2049621461850406, 0.2113050438174403, 0.5344798263934334, 0.19983242782549782, 0.18679695794424056, 0.18828662576264665, 0.1918157059873935, 0.1945263095817984, 0.19300862157965126, 0.19362768378344886, 0.20156003656000465, 0.19766551837884894, 0.08318610888145217, 0.08901134528899968, 0.08197713472159085, 0.09431367146534286, 0.08369392907226925, 0.08709476874230826, 0.0886856403922398, 0.08213080551481566, 0.0875167111291939]}, "mutation_prompt": null}
{"id": "267ab01a-fd62-4f52-bec0-50c9144444ed", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.05\n        self.c2 = 1.95\n        self.inertia_weight = 0.6\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n        self.quantum_factor = 2.5  # Quantum potential well factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.4, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            quantum_adjustment = self.quantum_factor * np.random.randn(self.dim)\n            self.global_best_position = np.clip(self.global_best_position + quantum_adjustment, self.lower_bound, self.upper_bound)\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n\n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredAdaptiveAlgorithm", "description": "Quantum-inspired adaptive algorithm with enhanced global search via quantum potential wells and adaptive parameter cooling.", "configspace": "", "generation": 15, "fitness": 0.12883650324370546, "feedback": "The algorithm QuantumInspiredAdaptiveAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "11e95311-625d-4217-8bf5-d1cad40227f7", "metadata": {"aucs": [0.18634518407831846, 0.1938079965714219, 0.1703263806751273, 0.2204185429271892, 0.18262247018992717, 0.20768709623720727, 0.1926423263737851, 0.20879797849304482, 0.21282266354971113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044507724888416256, 0.04967594535266795, 0.050370060403395644, 0.05118236406226151, 0.05642653989904356, 0.05159053054510454, 0.046538079037795055, 0.05228567997643241, 0.05691140593145172, 0.03209433152217478, 0.03292998868240371, 0.02528773987448929, 0.0336020921287401, 0.02658037573719263, 0.029568685471287437, 0.03806242234743695, 0.03303367539664137, 0.040697633755429896, 0.9160293046169761, 0.989526437554056, 0.9932511302963507, 0.9184107041854522, 0.9856732477758183, 0.905684823435352, 0.9780995270925306, 0.9858631225758423, 0.9864993560629702, 0.07799128525663068, 0.09660391714902927, 0.0842856382616608, 0.09866141499738734, 0.08166504089184434, 0.09046423343310672, 0.10541512643896844, 0.11266141519453954, 0.1291210302344069, 0.1236226647133335, 0.10150934318888338, 0.1509157090066614, 0.13449235474987198, 0.1317872762265464, 0.12454590398370458, 0.1272691992634214, 0.12831422055613562, 0.1277292797758115, 9.999999999998899e-05, 0.03757410346922696, 0.011183989001061656, 0.002617212607846753, 9.999999999998899e-05, 0.007548673312340548, 0.02915170496617614, 9.999999999998899e-05, 0.00700084252374511, 9.999999999998899e-05, 0.0152180179945679, 0.005985226944205335, 0.0034638352030044173, 0.0006772212797792054, 0.022057375188967443, 0.017040956550862907, 0.0008232116955645408, 0.050164773655692496, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049165260312757364, 0.0721326839670724, 0.043382550435568046, 0.04801914539032681, 0.028914909328311644, 0.05149557005827088, 0.02681354327148089, 0.05105247310153882, 0.03299268523456245, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0018510365735997514, 9.999999999998899e-05, 0.001687326197393313, 9.999999999998899e-05, 0.007337008414604718, 0.014176654236990771, 0.009067875907841305, 0.20551400796381625, 0.2141559147698795, 0.1947647788037239, 0.19398425002342368, 0.20362619588674713, 0.19318192561732883, 0.2276003309999196, 0.23157801475566242, 0.1912233089787313, 0.05175024357918134, 0.050346512202110505, 0.06743713502741211, 0.052727639485145805, 0.04643853475657633, 0.066780935681648, 0.041286509060374565, 0.05907217890834093, 0.058212985357125935, 0.17767489252470037, 0.1498589675738673, 0.1334534357970273, 0.13077788249017086, 0.1400611663088357, 0.1381559096539211, 0.1379833937720456, 0.14243841895184017, 0.13969724592913213, 0.1664781989787929, 0.17673783256773112, 0.1666865269036507, 0.18197067971243863, 0.16028169417707938, 0.1623624920281309, 0.16230921279815247, 0.17530835197877093, 0.1770380850810921, 0.11677456044036316, 0.12038053951803163, 0.10703952967854802, 0.12114237452632004, 0.11331924723448394, 0.1022283945134177, 0.10845533571483479, 0.12103951952119973, 0.10831641728974517, 0.17981818879662936, 0.15171183846068703, 0.1693040769497991, 0.1584597244096414, 0.1602403432120334, 0.14195782569188253, 0.1568310257054376, 0.14052997257365318, 0.1457729060037538, 0.14401148910499784, 0.140547150184119, 0.14948687522602433, 0.15755101446821773, 0.15817230946526017, 0.14346275319240143, 0.1379562512867426, 0.1340287537568594, 0.14085427434873743, 0.16035934742291702, 0.15976179010109204, 0.13730140469113628, 0.1693461916518776, 0.15393929298645848, 0.17551015133439019, 0.12811065439215052, 0.1926821087493643, 0.14581135594841255, 0.16234588498032243, 0.164414039001335, 0.204905560287157, 0.19593456325398806, 0.13058797865621086, 0.14353009880834378, 0.17528574585434276, 0.20027380559378138, 0.18786369222772115, 0.19116124855639693, 0.17708763127044946, 0.17584441236811477, 0.1816610019494571, 0.1740795018086726, 0.1926058493913234, 0.18165627952728325, 0.19126600626923107, 0.17857550280340528, 0.04851980634325914, 0.052183672372388856, 0.04840504463025408, 0.043494361501388856, 0.04889403711509399, 0.04888923971374681, 0.047836784988362746, 0.04398904965199668, 0.051218636231454506]}, "mutation_prompt": null}
{"id": "ecc1c295-3808-4c11-956e-8aaea2fe52f1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMultiPhasePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.05 \n        self.c2 = 1.95  \n        self.inertia_weight = 0.6  \n        self.max_evaluations = budget\n        self.cooling_factor = 0.99  # New cooling factor for adaptive parameter tuning\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                velocity_update_nonlinear = np.tanh(self.velocities[i] + cognitive_component + social_component)\n                self.velocities[i] = self.inertia_weight * velocity_update_nonlinear\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.4, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveMultiPhasePSODE", "description": "Adaptive multi-phase PSO with mutation cooling, improved exploration, and convergence acceleration through nonlinear velocity update strategies.", "configspace": "", "generation": 16, "fitness": 0.2656640617642653, "feedback": "The algorithm EnhancedAdaptiveMultiPhasePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "11e95311-625d-4217-8bf5-d1cad40227f7", "metadata": {"aucs": [0.919954072816036, 0.9205558360842241, 0.9255690067775291, 0.9136642354592218, 0.9198729801071782, 0.9160543128621732, 0.921888563810526, 0.910733388968412, 0.9001889368266864, 0.12862041259133672, 0.2267701456050213, 0.803947602160528, 0.09658115172277826, 0.07233244425527152, 9.999999999998899e-05, 0.0016075789261138507, 0.22114847276240956, 0.012512377760227178, 0.14199830192458796, 0.1601063117696494, 0.09592657000747773, 0.1052163181812954, 0.14677586580335555, 0.14244007167364525, 0.09414938422543673, 0.11693027469784067, 0.1333976247840989, 0.06927173012547228, 0.1095443301688358, 0.07205259543981979, 0.10807247952432897, 0.0846993035599295, 0.09283204405969425, 0.14211639428915845, 0.08231597890851972, 0.1446810005383331, 0.9647690164064839, 0.9736958834943363, 0.9581606117956968, 0.9655210166670918, 0.9588659431285247, 0.9730428754556514, 0.9700182889387798, 0.9776218866410219, 0.9808412103099541, 0.5446564153688176, 0.43371245346265264, 0.4402133084787705, 0.2447385839557149, 0.23343806199155748, 0.6149519854630918, 0.2874078596785875, 0.20228843062217117, 0.491364227868876, 0.3591039026712345, 0.22777188029152895, 0.20811416576313924, 0.19342823820069166, 0.28056819462654936, 0.21057058537712403, 0.16897988807909392, 0.15204404676334415, 0.3328954704902318, 0.14153570171024843, 0.12777085316941061, 0.1454931349485078, 0.1635826290483634, 0.1462291732037675, 0.15439780742883324, 0.15137892481789528, 0.14379165161653584, 0.1458603089065098, 0.16015117081826702, 0.12916045285996347, 0.12917919689127033, 0.21098907272030243, 0.13273017644415264, 0.14467988056734737, 0.1987146010546862, 0.11994021613556671, 0.1438867361598659, 9.999999999998899e-05, 9.999999999998899e-05, 0.021424080313269922, 0.037167101222201016, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005786583873195195, 0.06978642481973296, 0.07272567317487244, 0.10426488170328718, 0.04226361554172231, 0.049291445063168626, 0.03354604003692241, 0.04983435194478769, 0.0511421107359854, 0.06007276762125968, 0.06650454736351508, 0.5683083862790399, 0.11794871357071313, 0.09964109555071432, 0.2128352741361036, 0.0812208471486765, 0.22165666049977295, 0.14923196178270481, 0.13376328889670674, 0.08254437883558752, 0.0440363773311272, 0.16464109853832598, 0.0884127425787028, 0.13982748437352188, 0.06669140874231894, 0.36551939659275534, 0.2581744886860592, 0.0793610734799679, 0.5993093290688114, 0.5191120469282907, 0.5318749143290336, 0.5431128767061915, 0.43700513958237386, 0.5096953072028039, 0.4958342980790167, 0.48851863015105323, 0.5740230098668534, 0.1054673342218313, 0.1603141470424625, 0.08429085033654427, 0.14305900724412735, 0.48520858557635627, 0.12521802922059744, 0.1051006782921522, 0.1138538707242962, 0.10541951429584973, 0.2526538671461569, 0.26152365764420227, 0.2593056399499566, 0.18833352819474825, 0.26563064333367226, 0.23318246528551478, 0.21553549711618114, 0.2286499078676828, 0.19443403301728746, 0.4169806912940065, 0.30225108904488596, 0.4127792112455415, 0.22246022149372957, 0.3322301095494773, 0.3877417708995311, 0.28747602226344005, 0.3286861248710825, 0.46382506207467866, 0.14927102639950895, 0.21649536922301849, 0.15056375362703023, 0.2116970415611671, 0.21320777466414698, 0.20195191022936831, 0.28996847012009663, 0.37475392896596627, 0.16241946947588204, 0.23406593473869453, 0.2874855684426879, 0.23077293495980178, 0.24169636431499053, 0.21161780850729306, 0.224866214896001, 0.23264521223897905, 0.22732059299982155, 0.20821808971767886, 0.17362194633977657, 0.180359039436495, 0.18926954948585195, 0.17400006022840298, 0.18933264701044095, 0.18522649003654623, 0.20885237204011342, 0.21205799105063394, 0.18905229464401863, 0.7247344475083988, 0.18730181133818946, 0.15319006530847346, 0.1728939986650323, 0.9343112873044737, 0.20037927382452514, 0.15105525116482643, 0.16933271244686499, 0.17230116765448622, 0.4827639046050761, 0.20761337185794992, 0.3386911253591858, 0.2119537181860246, 0.15414868967734163, 0.20901617315771837, 0.10459815712320175, 0.30741432990072237, 0.27677751176256815, 0.19642227768153075, 0.22653332632967393, 0.1857091388717117, 0.2013650926647137, 0.188707816622123, 0.21817659525425304, 0.18610800223413482, 0.20034706347354325, 0.19330917195621755, 0.1028777961707047, 0.088814667735999, 0.07753059437239862, 0.08494212470056373, 0.10091864679389706, 0.11898432223959865, 0.08288131169875745, 0.09065403999798582, 0.09868286881752641]}, "mutation_prompt": null}
{"id": "732d5e2d-9cf3-4ff3-85ea-b37f48963506", "solution": "import numpy as np\n\nclass AdaptivePSODETemperatureDecay:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.05 \n        self.c2 = 1.95  \n        self.inertia_weight = 0.6  \n        self.max_evaluations = budget\n        self.temperature = 1.0  # Initial temperature for parameter decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.4, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            # Temperature-based parameter decay\n            self.mutation_factor *= self.temperature\n            self.inertia_weight *= self.temperature\n            self.temperature *= 0.99  # Decaying temperature\n\n        return self.global_best_position, self.global_best_score", "name": "AdaptivePSODETemperatureDecay", "description": "Adaptive Particle Swarm and Differential Evolution Hybrid with Temperature-based Parameter Decay for Enhanced Global Search Efficiency.", "configspace": "", "generation": 17, "fitness": 0.2145237060828848, "feedback": "The algorithm AdaptivePSODETemperatureDecay got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "11e95311-625d-4217-8bf5-d1cad40227f7", "metadata": {"aucs": [0.6630753106112411, 0.38721197766253, 0.47793649365473523, 0.6243542641267632, 0.5984335743961904, 0.6665759430184259, 0.5818490979816322, 0.5334162740799401, 0.4148149786357922, 0.07347621155822925, 0.04142374898728818, 0.031035001449701616, 0.23707468485627436, 0.056917651313126205, 9.999999999998899e-05, 0.11162006786789003, 0.1095534582454466, 0.14190325362953138, 0.10381206799737319, 0.10056068325472223, 0.08585496018355276, 0.10601006494601573, 0.07869248947388463, 0.0661179928341451, 0.11493838859430128, 0.09065597801382064, 0.10841844815431745, 0.10689518106447982, 0.11461383903563549, 0.11236696385883138, 0.09529177117932652, 0.07197954996071554, 0.07369170227446542, 0.12857822688749643, 0.06337177871694821, 0.10670852631106131, 0.9936196995215923, 0.9852728215594676, 0.9897263836603889, 0.9776826469248587, 0.981506671614376, 0.9860085431058095, 0.990456954452287, 0.99231033264967, 0.9895188783574068, 0.2885700669984609, 0.25990152634307273, 0.18647414854902422, 0.21867540503669458, 0.21285904229180208, 0.25802222145632503, 0.19333243058174332, 0.2256022518638512, 0.2100708327492764, 0.2262934660018071, 0.13023568764027293, 0.22983612321128855, 0.20898757974893123, 0.27372433831276854, 0.1993724719068427, 0.8856363869026522, 0.3260123329473066, 0.22252129074292948, 0.09636101856906576, 0.13984287899739933, 0.15541705966091945, 0.14181886091139617, 0.12722725758015274, 0.1280814557202119, 0.141362070789403, 0.2300852582025784, 0.1359775456716159, 0.0693400637282553, 0.11127524763745256, 0.17639578231268427, 0.15533557781487528, 0.14459769576507076, 0.15228999912204633, 0.2243946798100135, 0.09426522777323976, 0.08162319606825408, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1291228659183996, 0.0294671480086538, 0.02355244359258757, 0.08404538921248494, 9.999999999998899e-05, 0.00713236776480386, 0.048827527664053516, 0.08408623039724317, 0.05328200651064707, 9.999999999998899e-05, 0.07593247905893208, 0.05813569229088389, 0.10517132993449707, 0.1516949802316775, 0.08102430087276025, 9.999999999998899e-05, 0.18274033582438798, 0.07924544215326501, 0.15420843215443458, 0.04265656041687471, 0.16497597053006208, 0.010645009986674281, 0.06145659190961361, 0.06496281960908457, 0.07519420985134384, 0.05174173514061298, 0.049146996486808314, 0.49421165842620585, 0.3596081018839612, 0.6063935075787619, 0.42946670549772326, 0.3763928221224203, 0.41342865796623596, 0.39492536130746925, 0.33628427215694956, 0.4314885699040427, 0.15486478649736657, 0.10651163567521671, 0.09663815624414929, 0.12272170617180855, 0.08969241161665609, 0.09765242506087057, 0.09288750912109756, 0.08889354206296629, 0.11007128258099075, 0.1774373295658379, 0.18965244919585666, 0.1672124248736302, 0.16502905130904932, 0.2825572270688287, 0.21074385855453182, 0.18886130320336225, 0.1799951438637306, 0.2269213972967139, 0.1946601040413033, 0.36977786047442984, 0.37638554521389556, 0.2586574389310503, 0.20344917513409244, 0.25540489190581717, 0.37627956638341653, 0.325213777272521, 0.15802206808503338, 0.2319062897980546, 0.1594412303890902, 0.1583416715725593, 0.19238305076808582, 0.2045141355069251, 0.22187948870570884, 0.19713838051696908, 0.25893273123957017, 0.2497125569329084, 0.2021367132256, 0.20350105280531583, 0.2248290101393996, 0.23035831742604984, 0.20846754305362392, 0.1954984650668421, 0.19722671038359785, 0.20384304534730546, 0.2535532856196402, 0.18707137325459522, 0.24619609906744877, 0.1892232237528283, 0.20865275369047342, 0.17885762122397464, 0.18770745255365895, 0.28280565466313945, 0.20517621381247275, 0.2183370681290796, 0.18530378855177476, 0.18453158794493352, 0.15333930175957144, 0.19668743557297874, 0.19957185078371953, 0.16865410921261226, 0.09987910594282545, 0.16874342517629792, 0.1628095988166236, 0.08299426972090751, 0.20106392187475186, 0.16807344066966057, 0.34848004942589716, 0.11201918820199608, 0.5344616082453344, 0.20931586777598665, 0.2113086927721325, 0.1932375200634564, 0.203344478838558, 0.16721545042185115, 0.17121033768803995, 0.1712967446568533, 0.20074409553259165, 0.18211817389685847, 0.20070991389490078, 0.18267521575364476, 0.2175054503157533, 0.08370217357881216, 0.09803027597253111, 0.08522432393284618, 0.0786068591871033, 0.09235064047534158, 0.09779160281756849, 0.08661106618117287, 0.06837857493197808, 0.06614462882018324]}, "mutation_prompt": null}
{"id": "947c946e-3123-4c31-a425-24463ebaa0f2", "solution": "import numpy as np\n\nclass HybridPSODEAdaptiveCooling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7  \n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # Slightly increased cooling factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly higher probability for local perturbation\n                        random_step = np.random.normal(0, 0.35, self.dim)  # Adjusted Gaussian random step\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSODEAdaptiveCooling", "description": "Hybrid Particle Swarm and Differential Evolution with adaptive cooling and Gaussian perturbation for enhanced exploration and precision.", "configspace": "", "generation": 18, "fitness": 0.27004971619415125, "feedback": "The algorithm HybridPSODEAdaptiveCooling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "11e95311-625d-4217-8bf5-d1cad40227f7", "metadata": {"aucs": [0.8262210376179211, 0.8344252427724902, 0.8358371291632183, 0.8561274985523999, 0.8659997813396954, 0.8573829040962283, 0.8422054510759612, 0.8609736439085907, 0.8561772295078117, 0.7371606751213376, 9.999999999998899e-05, 0.06931147312880093, 0.5012880872464219, 0.04501743969572669, 0.06317618071744002, 0.2708571550443626, 0.5814416629009871, 0.7486353240944856, 0.12277966178005484, 0.14996723104001064, 0.13516235395562237, 0.15283744509368824, 0.07184585463369653, 0.07310824932402338, 0.1451327294586714, 0.1242806280757841, 0.11353813085581843, 0.12034032485027324, 0.10512434869201948, 0.07894809882485498, 0.11735220623837428, 0.11642966813963818, 0.14589524881184734, 0.08874261263247796, 0.12895051369098942, 0.11064677733424055, 0.9900187397700272, 0.9828816777112803, 0.9931820920509822, 0.9658396913303078, 0.9862785048042411, 0.9900552540220772, 0.9903460092612517, 0.9858397416459517, 0.9898523846002298, 0.5966160448544805, 0.645716273019792, 0.5620841177258382, 0.4713062899301649, 0.6163374470776295, 0.5708646496657492, 0.5793775607736447, 0.49443340437260963, 0.5211190295402923, 0.640001564339755, 0.35179923183364703, 0.36434989407194174, 0.20086464414812477, 0.18746368461390872, 0.1885586105703957, 0.21092292138697943, 0.22556053953166255, 0.20473715975091455, 0.12728092126734136, 0.1585939652604006, 0.1474195357655661, 0.13742464825510214, 0.1249265041798493, 0.1719548092699812, 0.10511864005917015, 0.15442947134303764, 0.16046668168104883, 0.39086948912716746, 0.11893324474777767, 0.18171677630035965, 0.12239043999881938, 0.20799314738542118, 0.1299820295306401, 0.11753606924786486, 0.0718887150500781, 0.12636443711454481, 9.999999999998899e-05, 9.999999999998899e-05, 0.04939911793283369, 9.999999999998899e-05, 9.999999999998899e-05, 0.013822153226730416, 9.999999999998899e-05, 9.999999999998899e-05, 0.026852901160409393, 0.023440749941900707, 0.024186684893327426, 0.055340568779144506, 0.11749562916231149, 0.0024418852741934227, 0.02962920097983701, 0.0971158785386026, 0.06676597723232258, 0.036470087055161304, 0.19794815743174654, 0.033734792596331165, 0.048154037009320194, 0.09901728427228795, 0.09130866862046172, 0.08369929460062198, 0.09479686695055733, 0.14267329272493245, 0.08085877589655688, 0.10276350752306207, 0.08264676863082387, 0.07544572499464297, 0.14397303323873534, 0.044692956821308916, 0.06151496075482232, 0.04835079397215247, 0.05607251518524392, 0.0786403530748574, 0.48759398046605973, 0.5019471744730606, 0.4730301743942732, 0.4872981357405596, 0.5263608293252067, 0.5437814976812845, 0.5747843881520656, 0.5606389602858075, 0.5239712765298572, 0.07221879975753942, 0.08410438406193022, 0.07813377595598137, 0.13673399801441355, 0.1097065508511238, 0.12777344788413592, 0.0758697489114658, 0.05984604522907688, 0.12526440485208146, 0.1954018510976171, 0.3314593567031682, 0.18599781556797257, 0.3332229732194867, 0.30442749152974424, 0.1791374399010338, 0.14862168623869698, 0.3390579294451339, 0.3233448015260424, 0.2496635140939828, 0.3021319191488253, 0.21864193747642513, 0.370288893437257, 0.2426254945748758, 0.3598923564482125, 0.29513445863475074, 0.5210877062292434, 0.4809344885517406, 0.27805592090186493, 0.1816094881898198, 0.18890378513925377, 0.26374632343491344, 0.16612058407524743, 0.21605034704709225, 0.2666849522669955, 0.25504996578311434, 0.2127438423798944, 0.18609374786036015, 0.21159703289455167, 0.1877924023057873, 0.1829847394916162, 0.2219150227946679, 0.21549148067206192, 0.1840762725200905, 0.20764926399504624, 0.19672280855042323, 0.21565216960194244, 0.21026781811613415, 0.19682182150315353, 0.2113391769718812, 0.2153822214762937, 0.2038787351528596, 0.20910142319842884, 0.2165894314628699, 0.19040335773575934, 0.8561796140360763, 0.16919799933448043, 0.15278490941502532, 0.838755832585636, 0.1986797101456914, 0.16893946313834163, 0.09978963271653596, 0.16930793683026224, 0.16465559678582808, 0.3016393535829254, 0.1665615649688018, 0.37021216833844617, 0.19791120736238976, 0.345957287049828, 0.21064748096440822, 0.21051830125504023, 0.21256373031798836, 0.2118969443008698, 0.18389629509380634, 0.19532807244562334, 0.19251976707196827, 0.223267559568896, 0.18874342454706516, 0.1767300328704967, 0.18059438994993493, 0.20623782980004612, 0.20485416381063304, 0.0866011522866389, 0.07817630205902792, 0.08151237951339407, 0.08543777794832563, 0.08568064237402906, 0.09435526979958175, 0.09096370984168278, 0.08516490947570621, 0.09665315855972367]}, "mutation_prompt": null}
{"id": "d3749a71-9cbf-4ec7-8345-7e323d098d68", "solution": "import numpy as np\n\nclass HybridQuantumAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, 0.3, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridQuantumAdaptivePSODE", "description": "Hybrid Quantum-Inspired PSO with Adaptive Differential Evolution for dynamic exploration-exploitation balance in high-dimensional search spaces.", "configspace": "", "generation": 19, "fitness": 0.26361978017024595, "feedback": "The algorithm HybridQuantumAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "11e95311-625d-4217-8bf5-d1cad40227f7", "metadata": {"aucs": [0.841786156149741, 0.8446008258946414, 0.8457801234499895, 0.8618376691878815, 0.8301657527587476, 0.8471782459310676, 0.8320275621923777, 0.8518753353925174, 0.8410465231802617, 0.7202910760317156, 9.999999999998899e-05, 0.7554365688683155, 0.7346363918259821, 0.04668401844026926, 0.04561031544477412, 0.0509489015255018, 0.7700040525618017, 0.056886902452675914, 0.12666339422732198, 0.10467209797441135, 0.14773123631251583, 0.1657600115253679, 0.1315506759068259, 0.09532281303068502, 0.10131185716490398, 0.10636959491639808, 0.14523524718785252, 0.07510709882874977, 0.10323367082768398, 0.13565871683968067, 0.14952425996494767, 0.11499061216414197, 0.14578855201131014, 0.13455456791824183, 0.11175930064866701, 0.10762543014246673, 0.989938109721377, 0.9821087514977372, 0.9937200725603116, 0.9822038470010428, 0.9899040709927284, 0.9864886841651853, 0.9904164618569189, 0.986016958969927, 0.9904024279103775, 0.5898811839592963, 0.41387618864688147, 0.4370494715787232, 0.287106611982607, 0.4033596784495208, 0.5868336178625115, 0.4022316067902647, 0.47863107334466737, 0.49665030863471615, 0.2172618529198287, 0.20561577356820882, 0.3767508707176698, 0.26803442498788166, 0.21088127236484233, 0.21329375520517502, 0.19909337346751554, 0.20561874715791495, 0.36174853719339795, 0.14131313735880247, 0.16085175650951966, 0.1428598885591027, 0.09493932554409656, 0.165856382053445, 0.1412140465768429, 0.1557792711992082, 0.15967775671521944, 0.14224624109796602, 0.10990342810521747, 9.999999999998899e-05, 0.18980589645113666, 0.1893933666076748, 0.12196605486452738, 0.18456632881959423, 0.0962618251516002, 0.09683847104106535, 0.1870548226445803, 9.999999999998899e-05, 9.999999999998899e-05, 0.05517647580502849, 0.006115757550736234, 9.999999999998899e-05, 0.01890030221346206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04810754224361391, 0.029692144480078286, 0.08122315498555566, 0.010165029869477427, 0.00022261278874480261, 0.003950244311064277, 0.10443849665254279, 0.0392414262572498, 0.03638360775777272, 0.03365811786450523, 0.008920781340956863, 0.06732461550663871, 0.09112319129704993, 0.07172386900586936, 0.12386774134874345, 0.09717640611239298, 0.06684114579493616, 0.0688240071514592, 0.040954711858363635, 0.08001866989474615, 0.05273061222515485, 0.02544526638645106, 0.1582168311450416, 0.04951425565135337, 0.05585010055342776, 0.055984038677791115, 0.08841368668594918, 0.5263371367507952, 0.47242416934972375, 0.5037912552489435, 0.5249953695431855, 0.4729048257642201, 0.506798116976966, 0.533502187690676, 0.4671108893957632, 0.5012310264235316, 0.08798946709703359, 0.09504523077056148, 0.10444088398428486, 0.10909630820761451, 0.13562505732933183, 0.1056856170871957, 0.10314755042870472, 0.11049422232059147, 0.08276408108089361, 0.216199881558491, 0.2170631112347663, 0.18071812040508795, 0.3455587767342274, 0.34002007382413424, 0.21320783766248275, 0.19566399915440347, 0.3205095119592818, 0.2028125275080921, 0.221919887449188, 0.45783178685810677, 0.432005126788896, 0.19607184748284234, 0.20912418581913284, 0.22322675661957647, 0.38263319155734454, 0.39685354736132705, 0.20754712387865726, 0.21526553857855268, 0.18404629740514844, 0.15922561216350917, 0.23694919022921335, 0.2973771792772816, 0.21336543441754297, 0.23664143767284396, 0.27507638564338643, 0.15623239743420925, 0.2026602840614109, 0.20228346424657861, 0.23482645794387946, 0.2230248671572974, 0.21068875629198192, 0.20335410672977827, 0.22706559120241276, 0.19248434195790953, 0.21956318519995044, 0.2049881171618575, 0.17383914167581238, 0.2192672726403626, 0.19813732992689836, 0.21638248186160813, 0.20143674279831025, 0.18605931819232835, 0.19031600820002903, 0.700322421426918, 0.8765708396603085, 0.1670519403697126, 0.15400828680965117, 0.8591378732037722, 0.19694958688556252, 0.16668867000048215, 0.0997411278928787, 0.1701518747646309, 0.16433664961746886, 0.15254298587940596, 0.16779971899558443, 0.16623714311649396, 0.20514537439049396, 0.5474424870454946, 0.2044721064238827, 0.20801930463190743, 0.7419524512393051, 0.20973197399560173, 0.1916288544135185, 0.20897502872318652, 0.20047673132064459, 0.19653767367951236, 0.2050752041126931, 0.20001439211115213, 0.21077649880092553, 0.217010184769321, 0.18150894923648342, 0.0820540416580885, 0.07158001030523553, 0.09024606366137833, 0.08447167439098224, 0.08432788675408798, 0.08639274600397695, 0.08107960970596229, 0.048616865446581725, 0.08358352085028053]}, "mutation_prompt": null}
{"id": "674f4f55-1d70-437e-b6b8-f6d6934842e7", "solution": "import numpy as np\n\nclass EnhancedProbabilisticMultiPhasePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.05 \n        self.c2 = 1.95  \n        self.inertia_weight = 0.6  \n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # Slightly adjusted cooling factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.3, self.dim)  # Adjusted Gaussian random step variance\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedProbabilisticMultiPhasePSO", "description": "Probabilistically enhanced multi-phase PSO with adaptive cooling, mutation, and local Gaussian perturbation for robust global search.", "configspace": "", "generation": 20, "fitness": 0.2750939669437348, "feedback": "The algorithm EnhancedProbabilisticMultiPhasePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "11e95311-625d-4217-8bf5-d1cad40227f7", "metadata": {"aucs": [0.8451725137437749, 0.8437339612240536, 0.8765110147166311, 0.856344315598729, 0.876897094209625, 0.8717818907496634, 0.8675029551532709, 0.8663746050610881, 0.870902851485991, 0.5299031017772463, 0.7469672069414593, 0.7846912770618615, 0.7641529196440959, 0.7575733382961678, 0.23018287506888124, 0.061913740928318806, 0.7609285738052821, 0.05625437547223011, 0.12808668675640655, 0.14953516556521118, 0.14067557550310084, 0.11803833856405277, 0.07123794597035649, 0.16631234349387547, 0.13054605560505383, 0.12821747704902609, 0.06280637217200058, 0.09545976416438984, 0.13005744313514456, 0.1311794391725143, 0.10170115535509927, 0.14987803278449685, 0.1259878303084313, 0.141744885357883, 0.0611289248583442, 0.1050241838493432, 0.9936206231279902, 0.9852379253806745, 0.9897165409142624, 0.9775834460045218, 0.9815035244700057, 0.9859982281688775, 0.9904502871754228, 0.9923056726697609, 0.989517229544371, 0.44512958181667894, 0.45769054149378585, 0.569073313880674, 0.5124905563293816, 0.5329482961812062, 0.3990288658554312, 0.460091800741557, 0.45267907703059607, 0.5476733693841955, 0.2271243904871615, 0.16836141462212617, 0.2250751561742862, 0.3474824176059953, 0.26810093266251933, 0.21928417137899936, 0.14986152827783195, 0.17451594654833258, 0.21468636197596402, 0.34403352767349427, 0.3381554903463204, 0.15997995898326167, 0.12704093660642324, 0.12448232480721055, 0.1260838687329524, 0.16070782317653287, 0.12159143758307578, 0.2130579453323458, 0.17211222926513126, 0.11265888977254834, 0.19128822854229943, 0.12649217743960695, 0.16301034881628407, 0.16704413814484054, 0.1712498349298741, 0.0989800271118092, 0.09842180959973734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018548597498807107, 9.999999999998899e-05, 9.999999999998899e-05, 0.013371227436791533, 9.999999999998899e-05, 9.999999999998899e-05, 0.052027299332218946, 0.0457422677295759, 0.048328227484371045, 0.024334514283290476, 0.004459269127132903, 0.014611837328898813, 0.096774373873042, 0.10916927743082228, 0.04445754566161064, 0.0622853970560906, 0.09018680830019588, 0.12986584032637272, 0.10908801796285583, 0.09293484121501783, 0.28266602168983923, 0.09251071775652997, 0.10296382505940072, 0.06962010759696591, 0.08014238881980018, 0.04314232645423233, 0.1474094986817579, 0.04451298221657851, 0.007197769636297147, 0.13969174938444795, 0.18546138147899405, 0.06323343980525986, 0.059129571054318486, 0.531863273870133, 0.5492667211929241, 0.5169983381208759, 0.6130013949920669, 0.4859580460924833, 0.5241285440856849, 0.48248656148078284, 0.4871922145698856, 0.507336456246527, 0.08425078493262461, 0.10778928886555783, 0.07954813093847424, 0.18195883906101995, 0.1307109698690767, 0.09162633026625899, 0.09611792378670048, 0.09146329401197872, 0.1152942304489043, 0.4328998375466492, 0.19003633570084866, 0.3383114695978735, 0.2257622455585877, 0.2576641679426639, 0.1799983121895964, 0.1928761474660109, 0.22150536697714174, 0.2304384595528577, 0.256447959835322, 0.26333585647626845, 0.3215278152811195, 0.38869456111871126, 0.21514584768014766, 0.4471090548465777, 0.28099872236771783, 0.38619987639172637, 0.4716116445723254, 0.1252959230578201, 0.235446895423031, 0.14652902010119073, 0.22923413003071247, 0.1774588452047854, 0.31386486337831676, 0.2151954107363515, 0.3316132676065846, 0.27889182543205115, 0.20780901088957526, 0.20531528901481244, 0.1901459443545782, 0.1851819319371153, 0.20761530000538375, 0.20719276411109344, 0.2428533862166533, 0.2294344375064682, 0.27709208719636125, 0.199488332687199, 0.18509866812733922, 0.2058379112973645, 0.19406301209150756, 0.22225628449919455, 0.19611739377851312, 0.1960182969915002, 0.19983908024435426, 0.22112182641810774, 0.8771092006655936, 0.16770157090621884, 0.15335811231887908, 0.8619869972720371, 0.19913637855957944, 0.16838005407441092, 0.09989779677072219, 0.16868873580694632, 0.16330113253618106, 0.0829996837815854, 0.1683788165026212, 0.2102182739621049, 0.36406577295707854, 0.11256065529917791, 0.3573657113938521, 0.11250485053788284, 0.21140610586951847, 0.433973789383463, 0.18975329081117043, 0.20637585885707987, 0.19204621912184527, 0.19278538720484129, 0.1995708115885163, 0.2057406278948506, 0.1924104693141896, 0.1921624504726417, 0.19542580329538772, 0.07682668991267727, 0.08555120728890364, 0.0852037886641509, 0.08790525002408645, 0.08921427381475966, 0.08301370643388695, 0.07920951340416393, 0.09382588705268136, 0.10308027476997772]}, "mutation_prompt": null}
{"id": "28061797-0a1b-422b-aaa2-cfb222d3420b", "solution": "import numpy as np\n\nclass HybridDifferentialEvolutionPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = np.random.uniform(0.6, 0.8)\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.97\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, 0.25, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridDifferentialEvolutionPSO", "description": "Hybrid Differential Evolution and PSO with adaptive differential control and dynamic velocity scaling for enhanced exploration.", "configspace": "", "generation": 21, "fitness": 0.26547402414302756, "feedback": "The algorithm HybridDifferentialEvolutionPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "674f4f55-1d70-437e-b6b8-f6d6934842e7", "metadata": {"aucs": [0.7868422917685156, 0.8001276014521134, 0.7949841912745271, 0.8254098177299849, 0.8271243636875498, 0.8184663357325426, 0.8069117904080496, 0.8247411575896609, 0.8081339612943147, 0.13083399229561388, 0.020574831075334754, 0.6610002293245973, 0.036981643799244734, 0.6855062954694265, 0.5990864345995872, 0.046733075008971725, 0.6809124718019897, 0.6565403618302614, 0.14473708007935948, 0.10916871655139526, 0.14662597792079612, 0.1515651403238728, 0.12669999688699696, 0.12007820044710915, 0.14449809016330506, 0.12333047271078756, 0.07557956626933449, 0.09752684174161519, 0.12206051360385062, 0.13468622231178218, 0.1490966843877548, 0.13749364696742872, 0.12720248963791814, 0.09888120336675565, 0.11429120729840836, 0.11246118381832004, 0.9907543155245051, 0.9843877181704574, 0.9849389311754814, 0.9792416557430572, 0.9800517369229266, 0.9662928415381294, 0.9848962462485484, 0.9890940424089149, 0.9840931646105245, 0.5724030137098293, 0.5789394865933553, 0.360734588393971, 0.47358783407984206, 0.4826781256284326, 0.28362498055428864, 0.4715250876422802, 0.4258588613719637, 0.3702096167905644, 0.2162893165001497, 0.5560303856535838, 0.22542144930363595, 0.19106932645168972, 0.18613875090306697, 0.20654932813515448, 0.2095226530061065, 0.21308058809499808, 0.3089701985930915, 0.15295443695004884, 0.15183409141923754, 0.16189876781811885, 0.12061919619167061, 0.17179698311397884, 0.20139463874345997, 0.11597922177613851, 0.16681687843096638, 0.1921367000133427, 0.1453008982450027, 0.117882615320555, 0.14705355366985406, 0.1650172883798925, 0.18503193575246912, 0.2951306851642963, 0.1000644044663419, 9.999999999998899e-05, 0.14062880103632047, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010504007228506973, 9.999999999998899e-05, 0.014732563841905022, 9.999999999998899e-05, 9.999999999998899e-05, 0.04342809905174749, 0.03522594477796481, 0.10426759685210418, 0.07947083063041172, 0.000774337756957566, 0.08174059303691505, 0.135451257543447, 0.037950452397957246, 0.05128610040344117, 0.06974012383238837, 0.032331212804559084, 0.04512465864158677, 0.08145739259903384, 0.08488921089858592, 0.0850733458044568, 0.24421311277824242, 0.08593226656204933, 0.06237084417803884, 0.263551455057657, 0.0552256800318246, 0.13112174639773966, 0.007222183524612458, 0.14423218191163667, 0.05017370657226661, 0.05231984687169111, 0.0467629341093605, 0.13152624029456383, 0.5233875654414403, 0.4727391058116356, 0.4949927557856042, 0.558335355225879, 0.5328105552408833, 0.5243750886299117, 0.48839217968326387, 0.5034819572176328, 0.5435172073795815, 0.0853089027471442, 0.11181782926725448, 0.12275956177446934, 0.11148775407204214, 0.10399629974151592, 0.10024729071283711, 0.10010257254442656, 0.1199977418850725, 0.10260376438892349, 0.16228487113825885, 0.19514405318071304, 0.22073980271942828, 0.3756307319169423, 0.2545204510078779, 0.22613491536035435, 0.2519983493507554, 0.17174312711330753, 0.1847016613510868, 0.3081478837115227, 0.2581060798292467, 0.33916476150069386, 0.2658374228110548, 0.20474648495355374, 0.2848902982970891, 0.3660015770481668, 0.5063548796694692, 0.30676911948367536, 0.22722889098221366, 0.20986019594898786, 0.251948546588628, 0.21046393539162578, 0.28093662424943167, 0.3515273539283996, 0.23034106784376485, 0.2474623289044382, 0.14835041818378158, 0.2598711599749135, 0.1450923712724681, 0.19649325633404213, 0.20649077697374063, 0.16187758555114173, 0.2431244779529006, 0.19952381962240906, 0.19366773738247955, 0.18066546882425882, 0.18908234209476327, 0.20456848369829972, 0.18173358251662708, 0.20097466532781239, 0.18125695790013885, 0.23697417156125844, 0.17909285131962027, 0.22721919111890843, 0.2090062758313892, 0.8553271341968797, 0.16040796839506388, 0.15364614384110697, 0.17570515865681313, 0.19866351866100485, 0.16435230225208108, 0.0989759285047992, 0.16896878976282204, 0.8088234802846374, 0.3886170001006827, 0.1543025180766997, 0.10913845582749016, 0.6618949615291863, 0.38630932108023086, 0.43860592649875263, 0.2112727376427168, 0.20964098429946576, 0.10405844817159637, 0.20375625613687376, 0.17725445605055923, 0.1760799863218957, 0.1897430367059545, 0.19100732382110086, 0.19537379900635676, 0.1897670111717331, 0.18607732792892528, 0.19408876364211802, 0.09066579702369659, 0.07577244281957685, 0.07189568508473021, 0.0914326812769134, 0.07403580164494417, 0.07834311876537503, 0.08153500526985025, 0.08465821252967276, 0.08036788937951989]}, "mutation_prompt": null}
{"id": "940df8a3-6c23-4f9f-ae74-d8ef524804ab", "solution": "import numpy as np\n\nclass EnhancedProbabilisticMultiPhasePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.75\n        self.c1 = 2.05 \n        self.c2 = 1.95  \n        self.inertia_weight = 0.6  \n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # Slightly adjusted cooling factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.3, self.dim)  # Adjusted Gaussian random step variance\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedProbabilisticMultiPhasePSO", "description": "Probabilistically enhanced multi-phase PSO with adaptive cooling, mutation, and local Gaussian perturbation for robust global search.", "configspace": "", "generation": 21, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "674f4f55-1d70-437e-b6b8-f6d6934842e7", "metadata": {"aucs": [0.8451725137437749, 0.8437339612240536, 0.8765110147166311, 0.856344315598729, 0.876897094209625, 0.8717818907496634, 0.8675029551532709, 0.8663746050610881, 0.870902851485991, 0.5299031017772463, 0.7469672069414593, 0.7846912770618615, 0.7641529196440959, 0.7575733382961678, 0.23018287506888124, 0.061913740928318806, 0.7609285738052821, 0.05625437547223011, 0.12808668675640655, 0.14953516556521118, 0.14067557550310084, 0.11803833856405277, 0.07123794597035649, 0.16631234349387547, 0.13054605560505383, 0.12821747704902609, 0.06280637217200058, 0.09545976416438984, 0.13005744313514456, 0.1311794391725143, 0.10170115535509927, 0.14987803278449685, 0.1259878303084313, 0.141744885357883, 0.0611289248583442, 0.1050241838493432, 0.9936206231279902, 0.9852379253806745, 0.9897165409142624, 0.9775834460045218, 0.9815035244700057, 0.9859982281688775, 0.9904502871754228, 0.9923056726697609, 0.989517229544371, 0.44512958181667894, 0.45769054149378585, 0.569073313880674, 0.5124905563293816, 0.5329482961812062, 0.3990288658554312, 0.460091800741557, 0.45267907703059607, 0.5476733693841955, 0.2271243904871615, 0.16836141462212617, 0.2250751561742862, 0.3474824176059953, 0.26810093266251933, 0.21928417137899936, 0.14986152827783195, 0.17451594654833258, 0.21468636197596402, 0.34403352767349427, 0.3381554903463204, 0.15997995898326167, 0.12704093660642324, 0.12448232480721055, 0.1260838687329524, 0.16070782317653287, 0.12159143758307578, 0.2130579453323458, 0.17211222926513126, 0.11265888977254834, 0.19128822854229943, 0.12649217743960695, 0.16301034881628407, 0.16704413814484054, 0.1712498349298741, 0.0989800271118092, 0.09842180959973734, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018548597498807107, 9.999999999998899e-05, 9.999999999998899e-05, 0.013371227436791533, 9.999999999998899e-05, 9.999999999998899e-05, 0.052027299332218946, 0.0457422677295759, 0.048328227484371045, 0.024334514283290476, 0.004459269127132903, 0.014611837328898813, 0.096774373873042, 0.10916927743082228, 0.04445754566161064, 0.0622853970560906, 0.09018680830019588, 0.12986584032637272, 0.10908801796285583, 0.09293484121501783, 0.28266602168983923, 0.09251071775652997, 0.10296382505940072, 0.06962010759696591, 0.08014238881980018, 0.04314232645423233, 0.1474094986817579, 0.04451298221657851, 0.007197769636297147, 0.13969174938444795, 0.18546138147899405, 0.06323343980525986, 0.059129571054318486, 0.531863273870133, 0.5492667211929241, 0.5169983381208759, 0.6130013949920669, 0.4859580460924833, 0.5241285440856849, 0.48248656148078284, 0.4871922145698856, 0.507336456246527, 0.08425078493262461, 0.10778928886555783, 0.07954813093847424, 0.18195883906101995, 0.1307109698690767, 0.09162633026625899, 0.09611792378670048, 0.09146329401197872, 0.1152942304489043, 0.4328998375466492, 0.19003633570084866, 0.3383114695978735, 0.2257622455585877, 0.2576641679426639, 0.1799983121895964, 0.1928761474660109, 0.22150536697714174, 0.2304384595528577, 0.256447959835322, 0.26333585647626845, 0.3215278152811195, 0.38869456111871126, 0.21514584768014766, 0.4471090548465777, 0.28099872236771783, 0.38619987639172637, 0.4716116445723254, 0.1252959230578201, 0.235446895423031, 0.14652902010119073, 0.22923413003071247, 0.1774588452047854, 0.31386486337831676, 0.2151954107363515, 0.3316132676065846, 0.27889182543205115, 0.20780901088957526, 0.20531528901481244, 0.1901459443545782, 0.1851819319371153, 0.20761530000538375, 0.20719276411109344, 0.2428533862166533, 0.2294344375064682, 0.27709208719636125, 0.199488332687199, 0.18509866812733922, 0.2058379112973645, 0.19406301209150756, 0.22225628449919455, 0.19611739377851312, 0.1960182969915002, 0.19983908024435426, 0.22112182641810774, 0.8771092006655936, 0.16770157090621884, 0.15335811231887908, 0.8619869972720371, 0.19913637855957944, 0.16838005407441092, 0.09989779677072219, 0.16868873580694632, 0.16330113253618106, 0.0829996837815854, 0.1683788165026212, 0.2102182739621049, 0.36406577295707854, 0.11256065529917791, 0.3573657113938521, 0.11250485053788284, 0.21140610586951847, 0.433973789383463, 0.18975329081117043, 0.20637585885707987, 0.19204621912184527, 0.19278538720484129, 0.1995708115885163, 0.2057406278948506, 0.1924104693141896, 0.1921624504726417, 0.19542580329538772, 0.07682668991267727, 0.08555120728890364, 0.0852037886641509, 0.08790525002408645, 0.08921427381475966, 0.08301370643388695, 0.07920951340416393, 0.09382588705268136, 0.10308027476997772]}, "mutation_prompt": null}
{"id": "eedec01c-f33b-4c3f-bd8f-292872837059", "solution": "import numpy as np\n\nclass MultiStrategyAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # increased mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7  # increased inertia weight for better exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:  # decreased probability for exploration\n                        random_step = np.random.normal(0, 0.2, self.dim)  # decreased variance for finer local search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "MultiStrategyAdaptivePSO", "description": "Multi-strategy PSO with adaptive velocity and selective Gaussian perturbation for improved convergence.", "configspace": "", "generation": 23, "fitness": 0.2756322039291093, "feedback": "The algorithm MultiStrategyAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "674f4f55-1d70-437e-b6b8-f6d6934842e7", "metadata": {"aucs": [0.7645660983867084, 0.758702709510273, 0.7890045465220392, 0.799529608554374, 0.8068439657809132, 0.8011044829188833, 0.797719920986778, 0.8054784248644092, 0.8050927496133504, 0.6566219659789216, 0.642811444329723, 0.6763562179848432, 0.6568078738648955, 0.673355089456021, 0.0006722403139971522, 0.6103930116510664, 0.6369315679753754, 0.655028218113178, 0.12708325789336727, 0.11592316891131016, 0.11902166773061795, 0.13257883632073642, 0.09252579419086449, 0.1675774787928671, 0.10601901423963134, 0.1399275630424398, 0.1392594427875592, 0.09779209693484192, 0.10820930574809429, 0.09711300361964914, 0.10853102255022573, 0.10485176522086082, 0.1326888090091417, 0.16364731277967626, 0.09125893276978747, 0.11745154215595521, 0.9936082033565319, 0.9889687827793732, 0.9903046410862011, 0.9816001085707398, 0.9848418748835199, 0.9893225551984364, 0.9900092203125976, 0.9899343417265245, 0.9897581008470192, 0.545620970146784, 0.5047437051552723, 0.5628855058971001, 0.5400781469745635, 0.4304379342505251, 0.4131106163549816, 0.5344353763715834, 0.5419208220591951, 0.5484137860819237, 0.21198962668859456, 0.2755480472088795, 0.2186829581081955, 0.3269002953280117, 0.18479661346530563, 0.2057762847732293, 0.14647338202543836, 0.626632951407246, 0.22625516557818992, 0.17551530594548148, 0.2397648181160924, 0.17597092500139355, 0.25433378124518113, 0.15108012593700937, 0.11826705207489374, 0.165911459269252, 0.14778239237964785, 0.14421291407518988, 0.13800447747083433, 0.10018790654144827, 0.2545270678586691, 0.11955569066394423, 0.17049137685594085, 0.15885205891565346, 0.12396148759395587, 0.09048802960194913, 0.1986647232010842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0592883660970599, 0.021576940186926352, 0.069066075299825, 0.10091275005572076, 0.0050204690019846065, 0.03401776153086866, 0.04753252483087378, 0.04403771197890671, 0.0442343230507829, 0.042441674445949484, 0.04492101213376554, 0.04112631044814263, 0.09823166668116168, 0.07918509876210444, 0.08522443101837784, 0.0833063573417181, 0.08238523985667945, 0.08995703751569695, 0.24857641096031713, 0.041289298112793804, 0.21415799309076333, 0.05751419121929213, 0.10845829846884203, 0.07924314418948031, 0.0534629928871323, 0.05540131218685729, 0.0734609259765523, 0.5163310216915183, 0.45530577508754577, 0.520006605550026, 0.5300496662249472, 0.5048610370085826, 0.4935226764815269, 0.5350639107040676, 0.491111556606584, 0.4982395754506149, 0.06662196426980938, 0.05252773189168525, 0.1088752809422171, 0.13276348553926853, 0.11429592928233434, 0.15655783768509024, 0.08633195666655591, 0.08775801919808224, 0.14606196962843665, 0.3466730062439366, 0.28477709874932167, 0.16993502166712837, 0.23263856243383163, 0.31461639639555894, 0.30066633132370835, 0.19956776946908616, 0.30681265845229067, 0.17800728015090594, 0.2557640711168194, 0.4781951221338687, 0.5057913820026636, 0.35603988698256295, 0.27275227825529214, 0.3081990129204336, 0.5019795074261533, 0.36836171225806946, 0.34668821102950764, 0.3254834577885839, 0.2282505722831759, 0.14420776865644291, 0.1768295671857819, 0.27019325342219447, 0.2751969842266999, 0.19204008052536437, 0.23893945298656616, 0.09204882425478389, 0.20736866294135103, 0.18159079400627298, 0.18804978863325683, 0.17963169867575202, 0.17135606592704755, 0.21744886074330894, 0.2085171522636411, 0.22260718942982105, 0.21803005366668204, 0.19989976330483716, 0.18907996626287216, 0.18137036028945364, 0.18285588642029083, 0.20267975430264418, 0.20474493217368694, 0.188887724719896, 0.22986382929696192, 0.19177153940525793, 0.8415791527314207, 0.15031097167714214, 0.1522503342834871, 0.16957929511945513, 0.19913959655713764, 0.16322380489456023, 0.09902397043493438, 0.17023095125961296, 0.15936078942089593, 0.4910916519584866, 0.16697758321873846, 0.09209719882114986, 0.6678293359251442, 0.6288955261916302, 0.2100298787416175, 0.10479958976199744, 0.2112065939796648, 0.21330531492594207, 0.1949458727743032, 0.1946423531522542, 0.18914407133450395, 0.21906619364828628, 0.18553062548421462, 0.19621963632062545, 0.1940629533971574, 0.19119602131187652, 0.19713309255954836, 0.08397795793041474, 0.08792232954651569, 0.08343591099265124, 0.08825384565946714, 0.0888879949408602, 0.08119926555817236, 0.08532022878110035, 0.08410830386756041, 0.09385048059689016]}, "mutation_prompt": null}
{"id": "c7604671-7b17-41d7-9222-44f0017fc7ec", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.c1 = 1.5  # Adjusted cognitive coefficient\n        self.c2 = 2.5  # Adjusted social coefficient\n        self.inertia_weight = 0.9  # Dynamic inertia weight for better exploration initially\n        self.inertia_dampening = 0.99\n        self.max_evaluations = budget\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                neighbors = np.random.choice(self.population_size, size=3, replace=False)\n                local_best_position = self.personal_best_positions[neighbors[np.argmin([self.personal_best_scores[j] for j in neighbors])]]\n                \n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (local_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # Probability to explore\n                        random_step = np.random.normal(0, 0.1, self.dim)  # Reduced variance for fine-tuning\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            self.inertia_weight *= self.inertia_dampening\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhanced Adaptive PSO integrates dynamic neighborhood topology and adaptive inertia weight to boost global exploration and local exploitation balance.", "configspace": "", "generation": 24, "fitness": 0.18753336137533072, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.42320221804893743, 0.441596607747349, 0.4639704925649466, 0.504245915395897, 0.4933260224661924, 0.568089189062951, 0.5797740563234316, 0.47362906391441817, 0.48860251784673847, 0.20240266460076595, 0.24180944596411946, 0.26326661933632467, 0.2691478244725024, 0.2424441569237099, 0.25427211064112476, 0.25597872108006914, 0.24596111432832846, 0.2736269896736456, 0.08570491367045652, 0.08852906703299324, 0.07300843602791518, 0.07600557786189199, 0.07286876105722351, 0.07645653548629994, 0.0960547097881912, 0.04565015686448348, 0.07845979632062172, 0.0778094884757553, 0.059832955840312785, 0.053600721445815735, 0.06904115828745594, 0.06608280961034474, 0.06341724044792996, 0.0700394160716743, 0.0785401981720093, 0.058402261249946075, 0.9955088299867902, 0.991456894828352, 0.99132317778691, 0.9877250635121457, 0.9905645972255198, 0.9893988206092997, 0.9905617087303161, 0.9913683299752232, 0.986339321217927, 0.181200572099931, 0.20296801497643235, 0.19206311465337866, 0.211888229673167, 0.16917913466744927, 0.21410760541131257, 0.18764525876415628, 0.2140904331869996, 0.17996711739369708, 0.2189587927720572, 0.17720760924749757, 0.18387123551849738, 0.20192750569856455, 0.19787331917673923, 0.17948197294368895, 0.19111951465826582, 0.17497092491073585, 0.19611363538395632, 0.08916245750330853, 0.10489168238792079, 0.10097292945477088, 0.09179010156074474, 0.127121079688576, 0.10248558326993784, 0.09633872748278394, 0.0940874981046238, 0.103654536810597, 0.11083764816363495, 0.10792762519861876, 0.11045394870366765, 0.09850599967724538, 0.09316296307905081, 0.09730014439644186, 0.08436234730174053, 0.10829612475023098, 0.0810400778674637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002984348900363365, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044894389421123226, 0.053787970357477954, 0.0237354120219323, 0.0607259013319037, 0.011316962702447753, 9.999999999998899e-05, 0.042119882353244376, 0.02323355478687339, 0.05119054535650247, 9.999999999998899e-05, 9.999999999998899e-05, 0.00037825525546864025, 0.012513484299593758, 0.038218413406184815, 0.013725335878057021, 9.999999999998899e-05, 0.039590323697259344, 0.05976049019684326, 0.03355467502326448, 0.033132081576921935, 0.040673702692955116, 0.06756088543436656, 0.04684928757418527, 0.031515292118900806, 0.05522803900117579, 0.04990823689165513, 0.06744308036471902, 0.34876006153034256, 0.3117772044914304, 0.36466899238817196, 0.3706241128900444, 0.35254996375557845, 0.39761465333214885, 0.3605270991197964, 0.3294835232942902, 0.33715719554089796, 0.07959843034128389, 0.0808024358189634, 0.06543968533281364, 0.060576979211168, 0.06796927378003637, 0.08036913994310124, 0.061074092138290736, 0.07401960834779553, 0.055597672392679987, 0.14135648954372138, 0.1495747780007456, 0.1582554400838202, 0.1950525876229584, 0.16503315078325942, 0.13705615567305818, 0.18334455948097306, 0.2326793734067817, 0.1680615505103762, 0.25021222839842594, 0.2115021901518762, 0.21774943075135622, 0.19755168518217092, 0.1799081321987398, 0.1789149187058532, 0.25699955362683, 0.2706227908916824, 0.2567136319959946, 0.14877103096274347, 0.15699601595060464, 0.17366809488171298, 0.17223130602233583, 0.162025024909197, 0.16348595780246555, 0.16250869050433225, 0.1782953833547234, 0.19269866690006776, 0.15520087368929658, 0.1802405770653227, 0.16722999811144224, 0.16924316400569883, 0.16396956385102535, 0.15864169420325303, 0.17645001399407922, 0.17155107423454885, 0.1729657628622817, 0.1732439128825416, 0.16220293417155685, 0.1684625790166352, 0.16562441233210956, 0.15962804221172788, 0.15708926916973032, 0.15270740429357998, 0.15911950002247888, 0.15631745478246595, 0.17042104870342467, 0.16137245333993233, 0.31467334825480664, 0.1824569006786454, 0.17989922250078705, 0.178374029596854, 0.17839791752326384, 0.15106799070051713, 0.18679005373530355, 0.16193421278104725, 0.16320159881723084, 0.16301579490018014, 0.17710937830044715, 0.178235283520066, 0.17549976944545453, 0.20654801852392213, 0.20860505630166393, 0.20825023390732722, 0.1808610712912676, 0.18208240286749044, 0.18348889793062673, 0.19718975648424808, 0.18330031040163375, 0.18780901458567, 0.18735674663137125, 0.19526583033216005, 0.18176766261730948, 0.06748760015802235, 0.06331467877077557, 0.05894357026286001, 0.07134925040269247, 0.06622833500247816, 0.06444135002116014, 0.06512759087000608, 0.06609316251288333, 0.058116646395930505]}, "mutation_prompt": null}
{"id": "af5d99ec-f1be-4706-9222-fd43dedfc928", "solution": "import numpy as np\n\nclass MultiStrategyAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # increased mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7  # increased inertia weight for better exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:  # decreased probability for exploration\n                        random_step = np.random.normal(0, 0.2, self.dim)  # decreased variance for finer local search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "MultiStrategyAdaptivePSO", "description": "Multi-strategy PSO with adaptive velocity and selective Gaussian perturbation for improved convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7645660983867084, 0.758702709510273, 0.7890045465220392, 0.799529608554374, 0.8068439657809132, 0.8011044829188833, 0.797719920986778, 0.8054784248644092, 0.8050927496133504, 0.6566219659789216, 0.642811444329723, 0.6763562179848432, 0.6568078738648955, 0.673355089456021, 0.0006722403139971522, 0.6103930116510664, 0.6369315679753754, 0.655028218113178, 0.12708325789336727, 0.11592316891131016, 0.11902166773061795, 0.13257883632073642, 0.09252579419086449, 0.1675774787928671, 0.10601901423963134, 0.1399275630424398, 0.1392594427875592, 0.09779209693484192, 0.10820930574809429, 0.09711300361964914, 0.10853102255022573, 0.10485176522086082, 0.1326888090091417, 0.16364731277967626, 0.09125893276978747, 0.11745154215595521, 0.9936082033565319, 0.9889687827793732, 0.9903046410862011, 0.9816001085707398, 0.9848418748835199, 0.9893225551984364, 0.9900092203125976, 0.9899343417265245, 0.9897581008470192, 0.545620970146784, 0.5047437051552723, 0.5628855058971001, 0.5400781469745635, 0.4304379342505251, 0.4131106163549816, 0.5344353763715834, 0.5419208220591951, 0.5484137860819237, 0.21198962668859456, 0.2755480472088795, 0.2186829581081955, 0.3269002953280117, 0.18479661346530563, 0.2057762847732293, 0.14647338202543836, 0.626632951407246, 0.22625516557818992, 0.17551530594548148, 0.2397648181160924, 0.17597092500139355, 0.25433378124518113, 0.15108012593700937, 0.11826705207489374, 0.165911459269252, 0.14778239237964785, 0.14421291407518988, 0.13800447747083433, 0.10018790654144827, 0.2545270678586691, 0.11955569066394423, 0.17049137685594085, 0.15885205891565346, 0.12396148759395587, 0.09048802960194913, 0.1986647232010842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0592883660970599, 0.021576940186926352, 0.069066075299825, 0.10091275005572076, 0.0050204690019846065, 0.03401776153086866, 0.04753252483087378, 0.04403771197890671, 0.0442343230507829, 0.042441674445949484, 0.04492101213376554, 0.04112631044814263, 0.09823166668116168, 0.07918509876210444, 0.08522443101837784, 0.0833063573417181, 0.08238523985667945, 0.08995703751569695, 0.24857641096031713, 0.041289298112793804, 0.21415799309076333, 0.05751419121929213, 0.10845829846884203, 0.07924314418948031, 0.0534629928871323, 0.05540131218685729, 0.0734609259765523, 0.5163310216915183, 0.45530577508754577, 0.520006605550026, 0.5300496662249472, 0.5048610370085826, 0.4935226764815269, 0.5350639107040676, 0.491111556606584, 0.4982395754506149, 0.06662196426980938, 0.05252773189168525, 0.1088752809422171, 0.13276348553926853, 0.11429592928233434, 0.15655783768509024, 0.08633195666655591, 0.08775801919808224, 0.14606196962843665, 0.3466730062439366, 0.28477709874932167, 0.16993502166712837, 0.23263856243383163, 0.31461639639555894, 0.30066633132370835, 0.19956776946908616, 0.30681265845229067, 0.17800728015090594, 0.2557640711168194, 0.4781951221338687, 0.5057913820026636, 0.35603988698256295, 0.27275227825529214, 0.3081990129204336, 0.5019795074261533, 0.36836171225806946, 0.34668821102950764, 0.3254834577885839, 0.2282505722831759, 0.14420776865644291, 0.1768295671857819, 0.27019325342219447, 0.2751969842266999, 0.19204008052536437, 0.23893945298656616, 0.09204882425478389, 0.20736866294135103, 0.18159079400627298, 0.18804978863325683, 0.17963169867575202, 0.17135606592704755, 0.21744886074330894, 0.2085171522636411, 0.22260718942982105, 0.21803005366668204, 0.19989976330483716, 0.18907996626287216, 0.18137036028945364, 0.18285588642029083, 0.20267975430264418, 0.20474493217368694, 0.188887724719896, 0.22986382929696192, 0.19177153940525793, 0.8415791527314207, 0.15031097167714214, 0.1522503342834871, 0.16957929511945513, 0.19913959655713764, 0.16322380489456023, 0.09902397043493438, 0.17023095125961296, 0.15936078942089593, 0.4910916519584866, 0.16697758321873846, 0.09209719882114986, 0.6678293359251442, 0.6288955261916302, 0.2100298787416175, 0.10479958976199744, 0.2112065939796648, 0.21330531492594207, 0.1949458727743032, 0.1946423531522542, 0.18914407133450395, 0.21906619364828628, 0.18553062548421462, 0.19621963632062545, 0.1940629533971574, 0.19119602131187652, 0.19713309255954836, 0.08397795793041474, 0.08792232954651569, 0.08343591099265124, 0.08825384565946714, 0.0888879949408602, 0.08119926555817236, 0.08532022878110035, 0.08410830386756041, 0.09385048059689016]}, "mutation_prompt": null}
{"id": "073762d3-0503-4881-a395-9a420601635d", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # adjusted mutation factor\n        self.crossover_rate = 0.8\n        self.c1 = 1.5 + np.random.rand()  # dynamic cognitive coefficient\n        self.c2 = 1.5 + np.random.rand()  # dynamic social coefficient\n        self.inertia_weight = 0.8  # modified inertia weight for better stability\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # adjusted cooling factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # adjusted probability for exploration\n                        random_step = np.random.normal(0, 0.3, self.dim)  # adjusted variance for exploration jumps\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptivePSO", "description": "Hybrid Adaptive PSO with Gaussian jumps and dynamic learning rates for enhanced exploration and exploitation balance.", "configspace": "", "generation": 26, "fitness": 0.25583061021738523, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8133108621879818, 0.7740976840266118, 0.8206963374817806, 0.8122486096576991, 0.7751093128282117, 0.8276071402610795, 0.7981031886540995, 0.7705319576289674, 0.8209400932159895, 0.7231479872973814, 0.036984431004081, 0.7178496212909868, 0.2377967859463429, 0.042604193689848247, 0.005490370625293006, 9.999999999998899e-05, 0.14172577437166778, 0.7346050724079409, 0.13354367184528526, 0.31585970610055336, 0.1310986215854999, 0.13526454339270622, 0.06700341966826362, 0.1058124335039371, 0.14537501035844702, 0.12123344767288213, 0.07169068879805418, 0.11223177649915395, 0.1053944009034572, 0.12861587426779275, 0.1255932537872232, 0.09575331284826771, 0.12996375778972347, 0.0062898800367505725, 0.11971476136508086, 0.12136223627881393, 0.9940824584257723, 0.9857168440384829, 0.9901748965996438, 0.9673769762811824, 0.989659478829182, 0.9891062867367441, 0.9936855582400197, 0.9896668044734009, 0.9826610221899825, 0.6470031336824195, 0.3025402131974544, 0.47580886622957064, 0.43095387404000385, 0.26619837903389454, 0.6601131485804943, 0.48510736111778263, 0.3591927760146588, 0.5758658241386678, 0.7511500516430499, 0.22565791292952564, 0.5832285928361958, 0.18182645806132425, 0.20179258617557316, 0.20712826999976053, 0.2224824528507897, 0.2020591278040792, 0.20739976676687233, 0.15106530371482751, 0.1454786556729014, 0.1908651346207384, 0.10691221151059271, 0.14477633040121418, 0.1222766643782437, 0.16411881313207555, 0.15043388936412505, 0.12054936721866472, 0.1484463508388093, 0.11008522141481591, 0.1459863651631187, 0.11612484802084322, 0.11891643909818961, 0.16969247883216954, 0.1807023316126688, 0.07808189275115696, 0.09811764534955003, 9.999999999998899e-05, 9.999999999998899e-05, 0.04168405620115412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05983957076562796, 0.036795728428124286, 0.07914405467000052, 0.052980130315193, 0.02099480986980673, 0.005079181672024813, 0.0471197750436122, 0.037568654413387415, 0.04164001907834047, 0.04476887853805578, 0.09103577519174666, 0.20589071710596374, 0.12499566522397965, 0.06056905739811047, 0.08739802769179039, 0.09159953836972767, 0.06051353174610408, 0.06884795626495543, 0.04132570513427525, 0.048611803175348745, 0.1306351743739098, 0.00611252695098774, 0.005737100705271003, 0.0359403263589857, 0.12294643902335634, 0.0550963054119753, 0.07756330690787272, 0.4932972822141397, 0.4527576470484065, 0.4767534241567698, 0.5069104159263453, 0.46850154556055346, 0.4740962468272435, 0.48291780648258487, 0.4946790302141031, 0.5323174149393644, 0.08364745567392207, 0.09282154689027089, 0.05814595153151714, 0.11640200392211575, 0.10036650096431099, 0.1289658151165699, 0.06650416293076977, 0.09316823048121092, 0.061570125018727384, 0.28303802562944225, 0.1536964165270579, 0.16996560118191972, 0.2891522883443234, 0.3623489887822713, 0.17470422724071488, 0.19865923143726216, 0.2774907702206352, 0.2601298326229663, 0.2643481238612201, 0.25197415279901725, 0.2373554409465174, 0.20644592459335254, 0.21333912604117455, 0.37065020138252425, 0.36252473175817657, 0.35702413265112753, 0.13123836382250864, 0.0903932163797122, 0.26525132197715195, 0.17658719460745687, 0.182120353321228, 0.14997776316881428, 0.20497830047285948, 0.19042181974304684, 0.25091457247105386, 0.23650889184384682, 0.19538998278814745, 0.16887831874158687, 0.1918585069306462, 0.2233353505074407, 0.18889633383957904, 0.21239704954497507, 0.2415250203935979, 0.18258737470454534, 0.2407341728211425, 0.23058557564477755, 0.20437137250331416, 0.5695260107677335, 0.22674257986814084, 0.1986829110627798, 0.1864359928262015, 0.22906710863126112, 0.2142814807137946, 0.20825629990529837, 0.8631610453870865, 0.1623993841414263, 0.15334938972174528, 0.8554030512294338, 0.1961595755561275, 0.13131029271857952, 0.0993426674194765, 0.1688923422461508, 0.17051389576069065, 0.08186984668564057, 0.164616615761506, 0.20224551145206637, 0.20520771758833634, 0.1678783796913007, 0.2065500393915265, 0.2100078701771757, 0.20885832144851524, 0.680134574736937, 0.20829452443598861, 0.21114372165297468, 0.20039421774492627, 0.19928105589055922, 0.2199193705467093, 0.19491878173902788, 0.19143082676831524, 0.21112884192588866, 0.20722169449429262, 0.09357845643706642, 0.06767451726662932, 0.08199082395754886, 0.07966909288746249, 0.08496493880715228, 0.08291727585731767, 0.0903504742941943, 0.07309991463374355, 0.08666659526164289]}, "mutation_prompt": null}
{"id": "1b1d4338-9737-4876-96a8-b99e065e56aa", "solution": "import numpy as np\n\nclass EnhancedMultiStrategyAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 1.5  # Adjusted learning factor for cognitive component\n        self.c2 = 2.5  # Adjusted learning factor for social component\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        neighborhood_radius = 0.1  # Introduced neighborhood search radius\n\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # Adjusted probability for exploration\n                        random_step = np.random.normal(0, neighborhood_radius, self.dim)  # Variable neighborhood search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            neighborhood_radius *= 0.95  # Gradually decrease search radius for exploitation\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiStrategyAdaptivePSO", "description": "Improved multi-strategy PSO with adaptive learning factors and variable neighborhood search for enhanced exploration-exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.2575265341667277, "feedback": "The algorithm EnhancedMultiStrategyAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7890865520500537, 0.7655344582046767, 0.7770555673223231, 0.759758748378473, 0.755705485121523, 0.7646732249329472, 0.7448328226898033, 0.7624222014622446, 0.8181085715964417, 0.5464367513510964, 0.48193356413547295, 0.6310578360388659, 0.6055869487862655, 0.5292720257220138, 0.6533766536446826, 0.526830885925067, 0.44591526781400925, 0.6487576001876414, 0.15796173110704426, 0.04044140191705359, 0.11680664326857837, 0.13849018797296486, 0.06800684078774555, 0.11057438872539038, 0.054844028501186415, 0.044427535929869366, 0.15233539612744207, 0.10888874717472541, 0.12614851996308585, 0.11324005217133959, 0.14709087594062953, 0.11754276360587157, 0.1065094097597985, 0.09132845046052085, 0.13999328157281865, 0.12751493003900782, 0.9943866214477736, 0.9929713021197155, 0.9900927653967041, 0.9673196982784203, 0.9897636751441499, 0.9891697265239683, 0.9937871370401533, 0.9937302994786644, 0.9933306176202436, 0.5038330276435012, 0.5183758503929692, 0.4353634970345591, 0.5306023846758127, 0.4679080119755862, 0.5281536770357764, 0.395700908147791, 0.5267586443550505, 0.44081797460222094, 0.22412625795568952, 0.3374162428991645, 0.13604252558068097, 0.19879204634122383, 0.11611507637488849, 0.26758118273764286, 0.09288845573468718, 0.12369632230104322, 0.148237144693377, 0.11062221800379135, 0.16305791884010545, 0.1104614422767134, 0.16061546088811007, 0.14040543213649848, 0.10907416173657725, 0.12045585069502796, 0.16940392457320397, 0.1589238216672496, 0.1506973709106696, 0.11600549522276593, 0.17625168180531603, 0.1804066544354388, 0.12839059639901773, 0.1924924061546467, 0.17753090044654252, 9.999999999998899e-05, 0.14971807291023742, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027688139889651797, 9.999999999998899e-05, 9.999999999998899e-05, 0.003475837573640228, 9.999999999998899e-05, 9.999999999998899e-05, 0.05820367672138038, 0.03674530995244807, 0.07017760055101385, 0.09623965808654433, 9.999999999998899e-05, 0.004017071965131236, 0.01494016000460574, 0.022273112789471416, 0.05019224767552133, 0.04359194716130299, 0.030046621868400014, 0.02927275725721923, 0.07968898007534275, 0.09659241951438491, 0.12389797590291951, 0.08334817407063222, 0.091563800693924, 0.05913808953370914, 0.03859609575381295, 0.038664590316702, 0.03845401498350587, 0.0756855680416022, 0.1652317120643294, 0.008442364760912424, 0.05303557585833063, 0.051642800673855294, 0.08547942546452358, 0.49612369670643885, 0.47214227322391134, 0.5287065601441527, 0.5271637423152564, 0.4703829606403189, 0.5053672315348408, 0.5361400954271553, 0.5646587108026199, 0.49383638633712557, 0.05782962267420899, 0.07501881320141579, 0.05198038355902024, 0.12569294195841707, 0.0782464655688353, 0.10587170501577547, 0.09618293373183473, 0.10319652169545246, 0.10545313015121538, 0.1854875783197828, 0.15773773510486921, 0.2884220674163821, 0.23817702134984053, 0.2969625193814962, 0.11583305454673032, 0.24355570623634304, 0.18749125066626815, 0.20723426414098323, 0.33696718369346035, 0.23378794917716994, 0.3467298384327361, 0.1515923450600647, 0.18694017401797258, 0.45539429702827294, 0.4304826033527167, 0.27675131626647065, 0.17223985583587398, 0.07406374211271327, 0.11406683348656965, 0.24646129360590407, 0.2783094742898161, 0.2403513711216959, 0.11541406087460959, 0.1858105071140993, 0.2623932745389088, 0.2062001965319582, 0.20963339640906697, 0.22652010007692203, 0.1997095220807238, 0.1809646536063204, 0.14746287357122478, 0.21107382154404875, 0.20119361972779692, 0.2289770049582298, 0.19305674828541253, 0.18685131534779287, 0.21281409653774053, 0.1921892264023951, 0.2221278020023394, 0.21189571301942456, 0.2277469773873828, 0.19559815387952317, 0.1884079078484615, 0.5621059914901327, 0.7781666134877889, 0.12437970752680483, 0.15193250776312384, 0.16920776650028235, 0.198551840324648, 0.1597124193560192, 0.09949611963475458, 0.16757831920060473, 0.1494145862043813, 0.08230860134019624, 0.20277216204303083, 0.12368180768728199, 0.7146331778630818, 0.16324664612196682, 0.20765534868254953, 0.21180160532841208, 0.21076805631207685, 0.5782910908401901, 0.18289874197482836, 0.22612284767141033, 0.18400622768160868, 0.1823805061943483, 0.19120234176189788, 0.19319160179092676, 0.2006744416969174, 0.2342663664692941, 0.19124894094559186, 0.0762292005541223, 0.07904805297955497, 0.08776008447751626, 0.09715344755033073, 0.08553440903970788, 0.08169223560693006, 0.0757342422181404, 0.0805689943207406, 0.09804914606861459]}, "mutation_prompt": null}
{"id": "c70c3b8c-1ccb-4f5a-9806-48bf3aa65d55", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # slightly decreased mutation factor\n        self.crossover_rate = 0.65   # slightly decreased crossover rate\n        self.c1 = 1.8\n        self.c2 = 2.2  # slightly increased social component\n        self.inertia_weight = 0.75  # slightly increased inertia weight for better balance\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # slightly increased cooling factor for smoother decay\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.14:  # further decreased probability for exploration\n                        random_step = np.random.normal(0, 0.15, self.dim)  # further decreased variance for finer search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptivePSO", "description": "Hybrid Particle Swarm Optimization with adaptive strategies, including mutation cooling, refined exploration, and hybrid particle enhancements for robust optimization.", "configspace": "", "generation": 28, "fitness": 0.26585628656478777, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8087738420015137, 0.8223812800345537, 0.8510902081483196, 0.8381487167465361, 0.8315607714121467, 0.8299647785513087, 0.8405469880586247, 0.8300679073240026, 0.8185850680253082, 0.7024462225814379, 0.23144432199378462, 0.12410955568134852, 0.36162075946462247, 0.04314462931296237, 0.7279699578279597, 0.7309685466531646, 0.7188821573091542, 0.7278633390897724, 0.12649578616429202, 0.6390039582058512, 0.13220887490391664, 0.1095709540072608, 0.14823631632500367, 0.14378260150490918, 0.1585493378475772, 0.13883062487849218, 0.05630366784439089, 0.172395227835627, 0.1296527733248216, 0.16015548818893188, 0.10659041215176512, 0.04928763173339645, 0.14936959128144645, 0.11522049748404983, 0.06573348781288024, 0.12531055022473991, 0.9936357914024346, 0.9885426691955259, 0.9905311562364881, 0.9860331177124707, 0.9894088078258751, 0.9905330736616791, 0.9936747213367225, 0.9938120119116095, 0.9926832377047394, 0.6269757823662537, 0.5143598392256669, 0.5611189410047859, 0.29449906664535164, 0.47373876643564905, 0.5750176659795336, 0.5009957500504862, 0.5137753693764874, 0.44128907615525426, 0.21887994484972506, 0.05976857484733533, 0.16843068424298346, 0.20514415869631353, 0.1253855715031994, 0.18935708382152294, 0.12800233439854636, 0.1254898593326872, 0.1483971094883082, 0.09370299558525752, 0.15425446364077544, 0.09599773659700472, 0.15514927482246677, 0.16062939061574288, 0.13833318086740543, 0.21959489209439886, 0.15130149521600722, 0.1805597377766318, 0.19452367927713576, 0.11340291561248017, 0.12017416230379818, 0.14121685600346356, 0.1983143396983471, 0.1569113113053876, 0.12471899318582524, 0.09672553695331665, 0.1623150270540482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.040336577409257335, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04293409626691247, 0.052240870252308946, 0.06514085943039194, 0.03426517771483617, 0.014683305345060571, 0.010985333695477717, 0.0493705715598628, 0.06271301227517634, 0.0462348160009326, 0.032068107469384044, 0.034325335480509644, 0.045591911517520955, 0.08637466354468903, 0.13712905827707944, 0.250893530168538, 0.09027166529882358, 0.11654422576402701, 0.0672720490207599, 0.10998570063485891, 0.0436882108234562, 0.10129171464660558, 0.017903673698736577, 0.19843136142282958, 0.0280842699802204, 0.06219038469930405, 0.054369007995453966, 0.07918272335514542, 0.4871082712934467, 0.48440260904633825, 0.5266007441517371, 0.5330465097056694, 0.5095648021323382, 0.5362321775520801, 0.527597282952572, 0.5083431135965891, 0.519733476117432, 0.05639712881347714, 0.11705740510806739, 0.0742093835019545, 0.11911144829873865, 0.09076287166471686, 0.14307232318668028, 0.13875019695595203, 0.1257889678766172, 0.1040321498357869, 0.46346214827510135, 0.15397814770607643, 0.18727916010280532, 0.2759721406667025, 0.2367553313337979, 0.22917998182343313, 0.2437422869946997, 0.17678094198792227, 0.2205136940496527, 0.38280827108868853, 0.32655527804600315, 0.44206880396386716, 0.20845864074083353, 0.21097519663846698, 0.3572371412461529, 0.22768460668709434, 0.23079467110268925, 0.20038381819647666, 0.1725607145639273, 0.18611824558882628, 0.1349973509838185, 0.24659240127046167, 0.20721312279449677, 0.23357090484399745, 0.2522189232013069, 0.250708073394571, 0.2526777720943615, 0.21317187923629932, 0.18960984769146538, 0.20864342228477806, 0.21656413276384645, 0.1970773109936368, 0.18752108012215063, 0.20360425872270138, 0.20281590694666218, 0.24089255136456422, 0.2334315067267554, 0.19341650744921357, 0.1956491238057112, 0.20151008124515102, 0.23732653945441484, 0.20120919734218445, 0.23475885739882352, 0.18183356543017026, 0.18868497211940116, 0.8397067289577778, 0.16802116575103443, 0.15377363244304998, 0.8466782687776573, 0.19739788337865483, 0.16418319150918392, 0.09944906050707936, 0.16950807391164102, 0.1518056157434977, 0.1526748053464405, 0.20454742634825518, 0.12503757534387694, 0.5410263109318871, 0.16783129067686509, 0.2045192525692392, 0.21039589618663135, 0.21002381672720483, 0.21113170567955009, 0.19369288636295423, 0.1920516805232576, 0.19951227539177396, 0.18014791401486052, 0.21713948754534784, 0.18474831074638898, 0.180988576372497, 0.20438143752424653, 0.2052217482656048, 0.10200032385160596, 0.09004352205045474, 0.09715728531022683, 0.08790183257063544, 0.09076654939191942, 0.08458320652742968, 0.08455506743906083, 0.09687643524380796, 0.08578308609704088]}, "mutation_prompt": null}
{"id": "0fb0a120-f4c1-4199-a0a0-63a8c874c5d6", "solution": "import numpy as np\n\nclass RefinedMultiStrategyAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.9  # increased inertia weight for further exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.975  # slightly increased cooling for gradual change\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:  # further decreased exploration probability\n                        random_step = np.random.normal(0, 0.1, self.dim)  # reduced variance for precise local search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "RefinedMultiStrategyAdaptivePSO", "description": "A refined Multi-strategy PSO that leverages adaptive inertia and mutation cooling for improved exploitation-exploration balance.", "configspace": "", "generation": 29, "fitness": 0.2609711162007659, "feedback": "The algorithm RefinedMultiStrategyAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8324984065845638, 0.8135340056561512, 0.8289471196569114, 0.8223959396895641, 0.8458515961570494, 0.814910591461895, 0.8330646432836184, 0.7905224466164602, 0.8337934561491285, 0.03827224698068188, 0.7202751597891617, 0.7296076915082856, 0.7492098733481616, 0.10149056131950351, 0.7291110122795603, 0.04886119592398952, 0.4024234525231214, 0.7568501096048923, 0.10210818379122122, 0.12610336178645376, 0.11601563332368992, 0.10927291254402338, 0.13351447144161155, 0.068909772594142, 0.11665102400327909, 0.09493566587635471, 0.12477578486661756, 0.12067988888867587, 0.1033216119385787, 0.11933424742805188, 0.10569152741326893, 0.136355050027283, 0.10652125334820906, 0.13501775273686856, 0.12149526584526993, 0.10271974994935695, 0.9893145420889214, 0.9898105786245242, 0.9906143475434289, 0.9818623021714541, 0.9903116979320264, 0.9901243185796369, 0.990306968215147, 0.9906300981852996, 0.9905970912697749, 0.449184515137556, 0.36904741588215373, 0.40008790125353644, 0.328235443434305, 0.34820690841853963, 0.5105704323404127, 0.4478613226077387, 0.4006411594473748, 0.31444389377883286, 0.21916868801067113, 0.20043019427246123, 0.2983050257786033, 0.185146660574811, 0.18446063215020647, 0.13335137937956354, 0.22445314685626439, 0.12137703163573732, 0.1705669530165116, 0.1689696756811383, 0.1172965468748216, 0.1463354076305804, 0.14417591046220535, 0.1220612973895524, 0.14435756881361572, 0.15873845699144928, 0.22415076541323753, 0.14533711344444278, 0.16187832328216045, 0.11704345944865635, 0.11644861603312895, 0.1291402053213837, 0.2139931276689956, 0.11684542197501702, 0.1816797613986859, 0.09328650725606624, 0.09474923143260183, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014990109477208025, 0.031112026609368182, 9.999999999998899e-05, 9.999999999998899e-05, 0.05888060928827932, 0.028117609261066323, 0.05492762086858438, 0.0618916954959281, 0.014196409878080352, 0.02704500930724496, 0.02998672675632752, 0.055993179937700144, 0.043657588858783125, 0.04611340736804925, 0.03280802519477333, 0.047380373468081105, 0.20298251767453035, 0.15258498807007492, 0.2705152783568605, 0.09242437681964966, 0.06898087356199178, 0.14425878404609516, 0.1396617076059793, 0.0549083152899319, 0.16677074799841318, 0.03326269752327449, 0.021259718994605437, 0.014157097196950574, 0.1642663970637268, 0.055131336919464924, 0.07514259422207703, 0.49159399532804504, 0.4598380257952773, 0.4888190286246453, 0.47907113582111416, 0.5279531927130383, 0.5525828256054663, 0.4888316985954041, 0.4277713963538504, 0.49090262793334727, 0.06658750087481569, 0.13796352462741157, 0.13020162870339702, 0.1074144531627631, 0.11153657280003537, 0.12380765597306653, 0.08508527285310552, 0.06364069003517892, 0.1291955235499257, 0.1873684461468672, 0.1417735558970895, 0.20273860230444385, 0.21643593956781304, 0.16985853127630812, 0.2509146583349897, 0.2557892839581679, 0.1550077025287232, 0.2442532499873461, 0.28468246624357807, 0.28712116880104954, 0.3759246311356118, 0.38677854306935167, 0.36533956406951873, 0.42239887220860606, 0.3490579764600533, 0.32648094025095553, 0.17002194922307623, 0.25269512601513866, 0.23123141057123886, 0.155634125558187, 0.203660340733405, 0.1875342083514634, 0.2571448817768355, 0.15390342484168484, 0.2944199088057735, 0.18340949656816352, 0.20948322479738457, 0.2155019741273736, 0.25498046420398846, 0.20058766044592724, 0.16784083512710768, 0.19045829434907535, 0.2035241477304327, 0.18252709719257676, 0.19940865542879338, 0.7349714839545868, 0.1820943509440066, 0.187637190259483, 0.21958434096143553, 0.18581928546754112, 0.19097425636066134, 0.18808327209704845, 0.1990258411738398, 0.1848554420023002, 0.16467319029528915, 0.16835076627085632, 0.15076928758159047, 0.8339834574939157, 0.19880174585566945, 0.19459405283518316, 0.09974837235310663, 0.16872282438520558, 0.1523727481521675, 0.4326913322059036, 0.16699766151000317, 0.23422133277037704, 0.3761136608523258, 0.45390894181333485, 0.6129507598602362, 0.2117013765194965, 0.21286821435319503, 0.10434886676600685, 0.18430255090219538, 0.1971449527654433, 0.23287860463028387, 0.22601977419857056, 0.19250718112932896, 0.19681113815444917, 0.1808664624563563, 0.2116635215327688, 0.188703883924336, 0.050459235635903266, 0.08148054584666897, 0.0765549114853018, 0.08215901976333895, 0.08235544366150738, 0.09009409718753336, 0.06291895041059359, 0.0971953596229197, 0.08134476897319398]}, "mutation_prompt": null}
{"id": "ded3510b-f20e-4e08-876d-b0a772030092", "solution": "import numpy as np\n\nclass QuantumInspiredHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.inertia_weight = 0.65\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredHybridPSO", "description": "Quantum-inspired hybrid PSO combining wave function sampling with enhanced mutation and crossover for robust optimization.", "configspace": "", "generation": 30, "fitness": 0.2594687858997685, "feedback": "The algorithm QuantumInspiredHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8526487199223607, 0.8422630679665374, 0.8407661585799047, 0.8722795872245926, 0.8645579258837863, 0.8458411062503538, 0.8640142213433055, 0.8702884072910197, 0.8418617497327731, 0.7416197925435842, 0.03942951240647685, 0.066599834407438, 0.012580119909573528, 0.2543725936454817, 0.0005596115431766302, 0.07366598797100155, 0.5739477570140608, 0.7573498119038082, 0.1342484904457225, 0.14779473783994723, 0.1211180200334877, 0.628732960502794, 0.6276137855258742, 0.11941573033697861, 0.12845278167791108, 0.14958722007676606, 0.13185854814891595, 0.11129725421770587, 0.146458907977011, 0.13725289813409713, 0.12605792502425828, 0.10240498921759555, 0.13272558986613225, 0.10747815669535743, 0.10809907581194311, 0.10174090639048483, 0.9890723408158762, 0.9862194579500737, 0.9904924921282404, 0.9836885279853878, 0.9928149206995492, 0.989678677411473, 0.9902012433485481, 0.9905044788768518, 0.9905004294161862, 0.5311995419082209, 0.6298907522361564, 0.3896210037485923, 0.2999484935012101, 0.5334218235794954, 0.35113958825940084, 0.44911608339254383, 0.5997341144150931, 0.34188549401709356, 0.2265442295173934, 0.18750109795632341, 0.1367575551573822, 0.19016033460175052, 0.11666575111190491, 0.1875086565731825, 0.17492692715321245, 0.23975526788648915, 0.2272850346590467, 0.1401496726444309, 0.09275165255679096, 0.1567123979689219, 0.16777877002019237, 0.12002056902953462, 0.1261669508379606, 0.14488605052741477, 0.10384426313038297, 0.18526845868999486, 0.16200504775862878, 0.10772351123710211, 0.14868335477120798, 0.13459822865705517, 0.16710314273964544, 0.1804637550695647, 0.1582607183462047, 9.999999999998899e-05, 0.1015053488076797, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007016734543734859, 0.052491115764322416, 0.01642190374106811, 0.0201243083792062, 9.999999999998899e-05, 9.999999999998899e-05, 0.0723741964356821, 0.05432120857297795, 0.05147062753975973, 0.06943763594095687, 0.03762089528724755, 0.013241730151867026, 0.03811522861833905, 0.048830904429030486, 0.052635430551799756, 0.050836512158040525, 0.03341116626508778, 0.03496605459351998, 0.07718354129613603, 0.0760787767639245, 0.07340013461345918, 0.13087192848428608, 0.1976597715534153, 0.06917139035976272, 0.16284775235573667, 0.04447043710507548, 0.0440209889673997, 0.006194257688187821, 0.17057433721807125, 0.01229828329607463, 0.047928517765071454, 0.13164158618452382, 0.07851629691664241, 0.5044952794216606, 0.5172440349805874, 0.5406061494761316, 0.515551526867783, 0.5197042535214336, 0.5598261937546815, 0.4647500359630943, 0.5309986739501174, 0.4939505947802647, 0.08477594920956466, 0.10582078035927611, 0.1037576188095245, 0.12548300872397844, 0.1022129413316426, 0.09701959690594708, 0.08980511783910428, 0.06474872616508909, 0.0801562388571434, 0.2806103213914215, 0.2113714101601879, 0.20078620896846067, 0.16680680574598916, 0.23026232498045474, 0.5031847421978843, 0.261688316134725, 0.20102347209846294, 0.21618328795506692, 0.32221019058924083, 0.3509076498421343, 0.3367470210771376, 0.3440643820648914, 0.2371476589100655, 0.4619308864995846, 0.3813190595272624, 0.48589916721413906, 0.3729522365682518, 0.10163324366783322, 0.1827621324413704, 0.18984372996441823, 0.15832080425849548, 0.3061489283914235, 0.2572011994882504, 0.208111266886975, 0.26401713839169383, 0.16232510644850606, 0.21345098024833775, 0.17161972975230544, 0.20360380125069955, 0.2024320791882388, 0.19530948287768957, 0.1953648027217454, 0.2174051052734992, 0.1970061267077029, 0.21685187170601927, 0.18584942463036236, 0.18628046441608104, 0.18452875683102044, 0.2279613840505046, 0.20878949007118897, 0.19828262204880087, 0.19747120117466266, 0.21492304849294053, 0.20489356088249366, 0.589988279945491, 0.16356707096748835, 0.15326279385866892, 0.17265915728245163, 0.19901467169782827, 0.8551364058063515, 0.09975193161775964, 0.1688466027839528, 0.15632044726108962, 0.1546930581578645, 0.1127341246281921, 0.15288936734234926, 0.7339628006523681, 0.1687709901821507, 0.11099582778724837, 0.20853689994428626, 0.1267109060810957, 0.1039390743009806, 0.18640748029020093, 0.19778572712332243, 0.17553282462294484, 0.21123833808708392, 0.21420533442923972, 0.21595197929351284, 0.20245545963903167, 0.1918670560003013, 0.17422525208149198, 0.09950710805508134, 0.10063860489709964, 0.08310000917417926, 0.07994795226887441, 0.08593379280254376, 0.07020343913145932, 0.079516784081337, 0.07250885565130427, 0.08614819321571743]}, "mutation_prompt": null}
{"id": "aaa4da85-cbb3-4157-941b-b1b3d88fda2d", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.65\n        self.c1 = 1.8\n        self.c2 = 2.2\n        self.inertia_weight = 0.8\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:\n                        random_step = np.random.normal(0, 0.15, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhanced PSO with tuned exploration-exploitation balance and adaptive parameter cooling.", "configspace": "", "generation": 31, "fitness": 0.2240313030062472, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.5671273012014687, 0.5839620586737382, 0.6147326386228985, 0.632224204440371, 0.6027490188993399, 0.5956527694439733, 0.6260000668662309, 0.5970972753381376, 0.5954879390903374, 0.3087136044543497, 0.030822254636952318, 0.2805964857860368, 0.02273132339787265, 0.02877135142582976, 0.17304568850482938, 0.3335819885122666, 0.26608158015427463, 0.01175642700219437, 0.11960572840090411, 0.11341582792089033, 0.2676611828777703, 0.11056653072511413, 0.12946431028781968, 0.1371010018103963, 0.12979269886520528, 0.13215600512257808, 0.11310389176168179, 0.11967553892094607, 0.1282507618369102, 0.09666902425329504, 0.12579800064636348, 0.06763061170887563, 0.11949878168960237, 0.1199745154156533, 0.11643512827410796, 0.13300437634167173, 0.9868288354713588, 0.9920494511846565, 0.9886142074833422, 0.9828796425147232, 0.9876022838387595, 0.9785265498003911, 0.9879889921610941, 0.9876212629624126, 0.987199203099524, 0.2634986714982275, 0.2335269587909501, 0.33688946389300223, 0.2607294121433046, 0.3214899828789335, 0.34397783809823546, 0.27177950997229183, 0.307112818193891, 0.27724778195915356, 0.27721340855514387, 0.5127428080544696, 0.19914050410949757, 0.20325952827858895, 0.1995368266853791, 0.22321823204994562, 0.11248645512614497, 0.12666978821927966, 0.15734945679267553, 0.08344904328694247, 0.139154948196326, 0.12538152356097032, 0.08714776748789099, 0.13035499719616217, 0.13843418399877172, 0.11872125161643321, 0.12345941528759063, 0.14143869763216121, 0.1003743738702495, 0.10998880660734889, 0.12306238579527329, 0.15955891577863057, 0.1372486816068882, 0.10580360591214122, 0.17072377813890094, 0.07347420233207014, 0.16759588359714594, 0.022560907648385697, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027330833909593455, 9.999999999998899e-05, 0.02199862418521903, 0.054178379694392986, 0.03663721441744461, 0.06582891693601411, 0.06469586269294891, 0.002752890360882554, 0.018621983462638658, 0.028269933218423304, 0.05642706288215982, 0.022522832594221054, 0.026394884777392158, 0.04174269725538271, 0.08801446964873072, 0.06292944413234869, 0.05711550749421346, 0.045479571068724134, 0.05975218047919861, 0.05071592280032544, 0.05574439293694011, 0.11677783321305835, 0.04443708541955371, 0.011223865423365176, 0.04735256479782324, 0.04402247254914504, 0.030687656934211938, 0.08424691164181708, 0.1071860550469379, 0.0693059475202299, 0.47219299573719287, 0.419428864536759, 0.49361489852658125, 0.39602359151772293, 0.4197706556503049, 0.40935321572774974, 0.3996782024791272, 0.4249433036631254, 0.42669188903457567, 0.09981156559185222, 0.09202479126496621, 0.04078748339820837, 0.0908851311045189, 0.09612990044939473, 0.09247258607191777, 0.05747369110032108, 0.0858833670026603, 0.13393339950758887, 0.201510155066437, 0.1420486707956552, 0.4292934196073651, 0.25075521262252753, 0.21242649988946216, 0.197066044826391, 0.14602532258120793, 0.19330982072715708, 0.22884609755647867, 0.22922661710490333, 0.1953206860516543, 0.32033445721620435, 0.2970479023089515, 0.1826410454281694, 0.28944737685684174, 0.31183350382971253, 0.33091388100802177, 0.3209761854598352, 0.19207035468443479, 0.20459509716791247, 0.19346867582860772, 0.24535293410500425, 0.18331818844668168, 0.22296219055750022, 0.2881930938430787, 0.23506308934967368, 0.23549242165444084, 0.18121410981447905, 0.17336301281088673, 0.18670521884259617, 0.18401086741538197, 0.19700884285247422, 0.19217806862549414, 0.20186586892918157, 0.1954865768842058, 0.1970211830413623, 0.2006880822174889, 0.20133980137485008, 0.17628041782507065, 0.17497253782229982, 0.20395099130602423, 0.37918194745989364, 0.22090280182604316, 0.1994596185031009, 0.18066409051909216, 0.7054428877571892, 0.16655564951745583, 0.15288912208722671, 0.726233480547344, 0.19542863327911364, 0.18878057160508677, 0.12309869222292291, 0.1694084991896998, 0.6515064501803426, 0.1454413651300105, 0.1535296981649097, 0.1105673341979112, 0.36192975027973684, 0.12434698641052533, 0.19645599438073658, 0.20476680281395943, 0.2077143185082274, 0.20898862114606864, 0.19820984532990582, 0.2002923906684363, 0.20750597974992147, 0.19785984687736302, 0.2018473180720245, 0.19609669924771855, 0.19914817294849063, 0.1924137975910316, 0.21004974694614598, 0.07822132013343908, 0.06560443728325771, 0.07685823522154855, 0.06976978640046327, 0.07524113550771072, 0.08031006203919455, 0.09554404661015048, 0.07649184979277202, 0.06483202285129952]}, "mutation_prompt": null}
{"id": "f80b95e8-0ced-4bc8-a9f9-158b393819c5", "solution": "import numpy as np\n\nclass HybridSelfAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 1.5 \n        self.c2 = 2.5 \n        self.inertia_weight = 0.6\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridSelfAdaptivePSO", "description": "Hybrid Self-Adaptive PSO with Differential Mutation and Localized Gaussian Exploration.", "configspace": "", "generation": 32, "fitness": 0.26390026734834154, "feedback": "The algorithm HybridSelfAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8228054817636759, 0.8407291599135454, 0.8323695269683676, 0.8269762022005632, 0.8556629939397654, 0.8461908322796352, 0.8038530712931264, 0.8024415758080337, 0.8427062031569973, 0.650247208165565, 0.6872111783900888, 0.7322358280665913, 0.38093741800029923, 0.7187208494430091, 0.7406310040071479, 0.047103436867922954, 0.7358970317090139, 0.7170421459023049, 0.15713398621610808, 0.17108421310217325, 0.1119713075290929, 0.06938082057915851, 0.6018580679870618, 0.13513108076955482, 0.1470809942344573, 0.14165167177004534, 0.10589534822006352, 0.08993843597864015, 0.13581168369041896, 0.1344812198791655, 0.12035732633399854, 0.04885702439675765, 0.08563332801747003, 0.1198682529905103, 0.09054037857302644, 0.13154351794464259, 0.9943825111530668, 0.992962773360297, 0.9900885832548358, 0.9824199677585589, 0.9893356568985036, 0.989173861337723, 0.9937521672170521, 0.9937403610689779, 0.9897373648843135, 0.6362649375660467, 0.5217948826931278, 0.5965155088038903, 0.4713423491267378, 0.4640819253401518, 0.6226070572284592, 0.6279074417368143, 0.524516311018836, 0.4817224791643211, 0.22693151180260396, 0.15909997701748213, 0.1711484214981327, 0.2063635770387574, 0.18824235529689748, 0.1302653781187122, 0.2110511811500757, 0.1253457560320539, 0.23042854004652458, 0.0917964729028452, 0.2488459210289875, 0.17406129266359727, 0.1547495385569615, 0.1232374408622059, 0.15028536599169096, 0.15574647342974024, 0.17226473761761663, 0.1719618626933096, 0.11765703572064778, 0.11929489999872622, 0.12098130470396551, 0.20642892136259983, 0.34560323134214976, 0.14087030462471029, 0.18271863040358016, 9.999999999998899e-05, 0.20605247730162568, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02806593652927225, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011285577865648433, 9.999999999998899e-05, 9.999999999998899e-05, 0.09196414469241976, 0.05030294130567603, 0.04043227240863578, 0.0862594655646941, 0.0011555116039924096, 0.009155936801801157, 0.12503500473671758, 0.0562801641918792, 0.029330382371342223, 0.05347622564097276, 0.03191987116686845, 0.04674373446585667, 0.26741888929608937, 0.07494560837904118, 0.13092350035410272, 0.10974058299001244, 0.09438706663015362, 0.09250405798546402, 0.25632763911440337, 0.058372537411789605, 0.046495132783362036, 0.04640333166441635, 0.008141433848005364, 0.04221878292495329, 0.057084202226731606, 0.058998329854252574, 0.08172215037193331, 0.5191580134738849, 0.49539736989603445, 0.5733584152140947, 0.5132238601885774, 0.5174734949663788, 0.5110304723027228, 0.5479415213103025, 0.5023781007874961, 0.5118532429177836, 0.0591100824173193, 0.0757385982376163, 0.09435628201009605, 0.11924868045838843, 0.0910218055433919, 0.15403257231246748, 0.07576468102856215, 0.1362045541595811, 0.07207547234950984, 0.18333341935915715, 0.1582078767466244, 0.1766044612714337, 0.26216760820857743, 0.1916976815696042, 0.22320035553590345, 0.27132824704248204, 0.27412513651751136, 0.22747430821315107, 0.2625986333554874, 0.3450724320705929, 0.262774779235981, 0.14463594664729884, 0.3728527530838459, 0.2670937740764395, 0.5096725019540487, 0.28633021050103713, 0.18158697758511022, 0.08323550608729069, 0.21169671241020804, 0.14512114894035, 0.15039085152245812, 0.18590746840986172, 0.16225239099844424, 0.15640022280593824, 0.2299440494436651, 0.25677108819266714, 0.19833802967965553, 0.20283362606383537, 0.15913758928030508, 0.1889772383894267, 0.23393211423254956, 0.2123176630932656, 0.20174850156871027, 0.17724899409638162, 0.2164307356044458, 0.19418843814523035, 0.1960656937134454, 0.20822285750046365, 0.21737217765555583, 0.20411479248479358, 0.17909160478893882, 0.1893627817364142, 0.2162589645899039, 0.20494048312270463, 0.10508514303278849, 0.1853838056183208, 0.15250923363884217, 0.17069764825887468, 0.19837090239376154, 0.16668687473698196, 0.09985053716280234, 0.1693434622726645, 0.1631008053713887, 0.0828643314256775, 0.20617952283781327, 0.4392780241501507, 0.20792492551965014, 0.12677277148197919, 0.2055354444329679, 0.12710459473351943, 0.2119740863438343, 0.20932678110606007, 0.20044761566252078, 0.19651797225544454, 0.19035356930029979, 0.19892809726697613, 0.1980485068925103, 0.1901361188358086, 0.20972375001815358, 0.18187473056025882, 0.19736557239924968, 0.09311029821143546, 0.0676273157367494, 0.08016624496348068, 0.07517228118709796, 0.08539230556581645, 0.0740181279092974, 0.09108522252868556, 0.049408362969529995, 0.08917476334766139]}, "mutation_prompt": null}
{"id": "fb8f4043-51f1-4007-9c87-980ec598af7b", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # slightly decreased mutation factor for diversity\n        self.crossover_rate = 0.75  # slightly increased crossover rate\n        self.c1 = 2.05  # slightly increased cognitive component\n        self.c2 = 1.95  # slightly decreased social component\n        self.inertia_weight = 0.72  # adjusted inertia weight for better exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.97  # adjusted cooling for gradual convergence\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.20:  # adjusted probability for exploration\n                        random_step = np.random.normal(0, 0.25, self.dim)  # adjusted step size for exploration\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredPSO", "description": "Quantum-inspired PSO with adaptive cooling and mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.2611692669791117, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8576647691524937, 0.8576909596211658, 0.8674320547732665, 0.8777183007656261, 0.8841546390178243, 0.8773478476369745, 0.6145172977622774, 0.8604685726167949, 0.8799502042196804, 0.7559969095060246, 0.04042704721537793, 0.17723992281213885, 9.999999999998899e-05, 0.04607500070007886, 0.26857797357753554, 0.7838980751633418, 0.11000430454946108, 0.8061346955484421, 0.1799993555436995, 0.11328942487073723, 0.17807243970833841, 0.06632927421254786, 0.15166713300630885, 0.07264822636443113, 0.17373795056007146, 0.06971392527666975, 0.1108228577851984, 0.09556901171414889, 0.1325235609475519, 0.10421167128723041, 0.1053677322954798, 0.12820185479926882, 0.10090203350089288, 0.14955269536045357, 0.12695025243714286, 0.09663836898180966, 0.9928006545509402, 0.9846777520414551, 0.986515556718661, 0.9816030316270311, 0.9896478966819937, 0.9888585732988048, 0.9905824070672961, 0.9922733296717607, 0.9896755097040535, 0.42597070956922123, 0.3968803098499497, 0.3816715827108397, 0.22903842118580853, 0.21401366535002941, 0.4423621821971896, 0.35815431950586774, 0.4145650957784206, 0.4693852246014921, 0.22360725320882735, 0.21727311914058278, 0.22273796286837755, 0.20687135029067116, 0.18860637282797765, 0.21069988009247587, 0.7856936083052481, 0.21763614746852789, 0.37868801698294685, 0.18212461178341477, 0.12311991996359795, 0.14862853485465333, 0.1599457847035599, 0.15473019886557215, 0.1473302185605877, 0.1533547583176018, 0.21069221478820954, 0.19051114375623723, 0.17261639049184996, 0.10998619970754009, 0.12469648214641293, 0.12763061631743766, 0.1570131059800295, 0.1316248717653692, 0.1252392014881929, 9.999999999998899e-05, 0.35344857370704363, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004092286303372106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037787826268404934, 0.0314578147414748, 0.06583942950202759, 0.10031308850961418, 0.048393531438102544, 0.032812351016351604, 0.14703028418920294, 0.056951315516199474, 0.048412554683450404, 0.07859429092022507, 0.1219781131512353, 0.05246499608893085, 0.09862102482491664, 0.0924421082457828, 0.07600932055793763, 0.09998898272677159, 0.09671235945851275, 0.08492080836538973, 0.15115786847693946, 0.04219352333212578, 0.049716579304488584, 0.019474087989580613, 0.0873973537277003, 0.23134084931445997, 0.059285661382524224, 0.060035590111820025, 0.05636730614702301, 0.5197003226087731, 0.49699418422093744, 0.6453507817026274, 0.5356739777378166, 0.5516461302849454, 0.5298853572626153, 0.5356825334424503, 0.5622759291199737, 0.4468281008150079, 0.09079230025336982, 0.07253076013761817, 0.11962902652758489, 0.12743007684231578, 0.12135918869837803, 0.10717670658587519, 0.06758976869977473, 0.07563582542908276, 0.13914677226751848, 0.2648345253540382, 0.19778530588262322, 0.17674552324092563, 0.24955870020990267, 0.23435409572271337, 0.15312199296746987, 0.14062153470127303, 0.19162186588770957, 0.43454970991362585, 0.2951224648166729, 0.3437513935018788, 0.3160006309511858, 0.20666100626488182, 0.23420462322134794, 0.30898902639408465, 0.3062917275357985, 0.4262918761211625, 0.371216987193451, 0.24989259017955157, 0.21361494135806258, 0.12243489843136612, 0.27329291664532207, 0.1944346430429469, 0.2919588288559942, 0.21550973303694831, 0.233271739567376, 0.25894325725783407, 0.21871776081148342, 0.18529341542116107, 0.19604287736650128, 0.2210497914332502, 0.22273945903194015, 0.2348221779073365, 0.19943137042015813, 0.2148608587040487, 0.19671100459363278, 0.20765813151555668, 0.20325038565129872, 0.2091335311950836, 0.19000733836740014, 0.24080474201476998, 0.1851241939101833, 0.1819076196809779, 0.2375273831608633, 0.21488223080516955, 0.10461203177385436, 0.8672825992851645, 0.1540744076075331, 0.8611955679917749, 0.19877719939328908, 0.16859335500610162, 0.09948482722276553, 0.16825314454936902, 0.16419243851327414, 0.15160763599180194, 0.1642554603722478, 0.28813123384430683, 0.3120040578328118, 0.2568472860162273, 0.20766416619992167, 0.11271202711221062, 0.5438972318943098, 0.10463454192794974, 0.19988274145895724, 0.1853869437384067, 0.19940205617621687, 0.19481480930228712, 0.210843866189936, 0.17532473642543178, 0.1886143786741723, 0.21233937365266886, 0.1977020612901218, 0.08357351271989633, 0.09535591325293424, 0.09312593921762014, 0.07922086534686446, 0.08307846481650816, 0.0790265640857224, 0.09797797683905685, 0.0977343295771338, 0.09678201689988242]}, "mutation_prompt": null}
{"id": "a30e02a2-428a-42da-9d07-a5d4b08616b4", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.c1 = 2.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.9\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.6\n        self.max_evaluations = budget\n        self.cooling_factor = 0.95\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] = np.clip(self.particles[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n                trial_score = func(trial_vector)\n                evaluations += 1\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhanced PSO with self-adaptive strategies and dynamic parameter tuning for robust optimization.", "configspace": "", "generation": 34, "fitness": 0.2327466097878552, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8173727353829208, 0.8743856741327994, 0.7531679822147841, 0.5493273521939335, 0.48694485997436177, 0.8258316983014902, 0.8624608820819415, 0.7304485878536543, 0.5939377965055066, 0.04197374198667436, 0.13833648376636776, 9.999999999998899e-05, 0.11897519519436828, 0.10983060291919411, 9.999999999998899e-05, 9.999999999998899e-05, 0.0818537152920471, 0.32314177302328784, 0.07042853644634306, 0.1502232112018801, 0.166659556805289, 0.1497127449594765, 0.11607691759660721, 0.12351928626465869, 0.11154986410753265, 0.16316357085508737, 0.13372751278191897, 0.11655741969340594, 0.10805788072916567, 0.11509943582109994, 0.11051865589107424, 0.12200665068135985, 0.14922867870386658, 0.10735509295187873, 0.10805155007876166, 0.11396955712670043, 0.987509895426911, 0.9882084029623275, 0.9868121260782741, 0.9833060020946682, 0.9817364363547073, 0.9829076040405551, 0.9837374374657222, 0.9875273134554127, 0.9856104953972226, 0.40624456462860414, 0.27038411804317997, 0.23251654308989955, 0.27110983035322467, 0.2518664930594531, 0.2581339033825144, 0.2836330735097724, 0.2908145956381004, 0.2530406029455913, 0.22398772769162656, 0.11950307284082295, 0.24860177395770566, 0.21156047226941932, 0.2090078883053268, 0.21250635018016817, 0.12394140263826503, 0.21994087069629997, 0.26017519929709043, 0.16212184825559217, 0.16850240278028483, 0.11719348876920543, 0.0973375738149942, 0.15611108896546644, 0.12035829536635378, 0.15880423449743553, 0.12166933940730251, 0.1441602615693628, 0.17645809835699744, 0.11769751129135875, 0.13281063116326275, 0.12159516438387041, 0.12338056129247887, 0.21209037506924588, 0.1419781051917336, 9.999999999998899e-05, 0.19035456117265837, 9.999999999998899e-05, 0.0020135179567116746, 9.999999999998899e-05, 0.0006325822517719848, 9.999999999998899e-05, 9.999999999998899e-05, 0.009164562459038517, 9.999999999998899e-05, 0.07448664819495987, 0.06850765284242566, 0.02547774505714151, 0.11841596105885632, 0.07934459058081722, 0.008527709285455431, 0.021542454450165116, 0.06288406420923642, 0.06026878148981818, 0.06405300807466574, 0.047538174602343, 0.034203277021118805, 0.05271839157907854, 0.08727583661420268, 0.11261025236662559, 0.1122766066400529, 0.09029806573751009, 0.09601757480316997, 0.10583894731787569, 0.08663542930021595, 0.042166675748387394, 0.09387445244160864, 0.02517519270559676, 0.01967303421896871, 0.29397132114130753, 0.08917499077485169, 0.07981936464863792, 0.2348232696680227, 0.4746350175352363, 0.4975127512495884, 0.5278891887052424, 0.5014558952284791, 0.46446574005711205, 0.5168704376742829, 0.5058421457423775, 0.4015680348951841, 0.5562127266545142, 0.11062756926058881, 0.06615434845518153, 0.07852115549245131, 0.10215530028976105, 0.12325120164730563, 0.1169065513766876, 0.16309167514893652, 0.13320407734798478, 0.17064731450729176, 0.19166287029352846, 0.24010852587945075, 0.20980183982810052, 0.1902139823635809, 0.3252277910877118, 0.19334328857841487, 0.26316552621711076, 0.3973643309355417, 0.23147878045317072, 0.3820382076639296, 0.27974380811321553, 0.39858967924081534, 0.2897435593531742, 0.21478608312761538, 0.2996523980028998, 0.3103197277128191, 0.29589681572111626, 0.20947871772950388, 0.2644168806410584, 0.23984514476396113, 0.2665347970188823, 0.1413470427647573, 0.16187377030408456, 0.19343721542497594, 0.22043301314970187, 0.2223648190700065, 0.3076418015333192, 0.22902635674245153, 0.23208046179913366, 0.19206216419030853, 0.20413399734821447, 0.21218187891961005, 0.21445193880838365, 0.2554988299967006, 0.2022255188399147, 0.20005693408579006, 0.24147448139736527, 0.17212136633693975, 0.1960053130174858, 0.20030736525949722, 0.18516121698332988, 0.18277758301072144, 0.2149839902058951, 0.1813838565301178, 0.21499835787084043, 0.6100309718429453, 0.16050017026603036, 0.15037445429982832, 0.17154621130322356, 0.19730168269805215, 0.1989886404115403, 0.1866380265154196, 0.16921906751526894, 0.2119888915463961, 0.08233652541297287, 0.15399753904017777, 0.11213992352323277, 0.2955293278632275, 0.16769231850910105, 0.2062934782765775, 0.2114319945489218, 0.20774168397305637, 0.3461540155018882, 0.20870003813721505, 0.1903828486302247, 0.21279185871372908, 0.22110036093256602, 0.2209340296028468, 0.20095277298212455, 0.24488956582174493, 0.18630647541014678, 0.20231370569588725, 0.0885667025103396, 0.08969497508573787, 0.13022099243837293, 0.08147232367608814, 0.0922854151723157, 0.08556421032523087, 0.09519853965883618, 0.09860810083327964, 0.07977364000827492]}, "mutation_prompt": null}
{"id": "ae31c6bf-639e-496b-b39c-f6025a0c1a95", "solution": "import numpy as np\n\nclass HybridAdaptiveChaoticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.9\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_factor = 0.7\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      cognitive_component + social_component +\n                                      chaos_factor * np.sin(np.pi * self.particles[i]))\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            chaos_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveChaoticPSO", "description": "Hybrid Particle Swarm with Adaptive Cooling and Chaos-Enhanced Mutation for Diverse Exploration and Exploitation.", "configspace": "", "generation": 35, "fitness": 0.19019624643979557, "feedback": "The algorithm HybridAdaptiveChaoticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.3848220248537225, 0.37674656407301776, 0.3781778184755443, 0.4135242504407082, 0.41554588401663006, 0.399167061952846, 0.37447677767233456, 0.37332387418268875, 0.3881188436338805, 0.02030254077127469, 0.009938661103041757, 0.015866384333564354, 0.03752670085306131, 0.017977316231482132, 0.05061832483554318, 0.014528110453448373, 0.03702381108325992, 0.008323327842205464, 0.092015287348022, 0.08930231323823645, 0.09489364339120798, 0.10711254558554262, 0.11388379669873172, 0.09843694342610632, 0.1112645397244012, 0.09338750149869046, 0.12446261733849184, 0.10495814730800435, 0.08607504045474856, 0.08728778936359449, 0.0909382012408656, 0.0864064482683281, 0.09862083788793863, 0.08693451336176528, 0.08270449994609586, 0.09912354323680628, 0.9927211904065175, 0.987155261192524, 0.9874311481868493, 0.9824593769499217, 0.9862611804292332, 0.9866360213849894, 0.9880987762671121, 0.9916718213776732, 0.9862152550117571, 0.24066554947682983, 0.1961827883315398, 0.2449975371173666, 0.23547325025748955, 0.17846401066688922, 0.254504060841253, 0.2453130584352352, 0.23261041718535658, 0.2313199705745541, 0.16918856902219837, 0.21020602257892662, 0.199995459179808, 0.19727340238465696, 0.2014086119856655, 0.1845576470570357, 0.5251813835848601, 0.12261445236049262, 0.17866264021166212, 0.06296214309525816, 0.12448476968083944, 0.11295005082087317, 0.12890331321834203, 0.10587532671202093, 0.07133375979132928, 0.09919970925638844, 0.1300819517559645, 0.11348943744580864, 0.12552239093137219, 0.08427603656305838, 0.11615272192369486, 0.1016636460395024, 0.12151950279602808, 0.16582876118068401, 0.09502295575562003, 0.08910879953437723, 0.0721104589125584, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02976047253884806, 0.00011463449281623461, 9.999999999998899e-05, 0.01795117427552051, 9.999999999998899e-05, 0.0009715766514458712, 0.04359069684082684, 0.036800620641356585, 0.04627184668921713, 0.1895016009960555, 9.999999999998899e-05, 0.003006403677649039, 0.08500762210072876, 0.036024923642956286, 0.019910668586481606, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001685191022785526, 9.999999999998899e-05, 0.0027582536623631526, 0.008300659710056113, 9.999999999998899e-05, 0.001605955944830595, 9.999999999998899e-05, 0.030094068481483216, 0.02659383699817175, 0.02965288527763532, 0.015825353562319622, 0.012806981212792334, 0.08854447978487057, 0.04418583969429368, 0.07144204618042693, 0.05878648063931036, 0.3380699170213859, 0.367151830336341, 0.3638053840857439, 0.34773585918741046, 0.36045226960015075, 0.35048039268493725, 0.38610003447260666, 0.3838928799430381, 0.3833314280787261, 0.08334562417110847, 0.09377999147977412, 0.08444814566016445, 0.09790689668304298, 0.10653685900990117, 0.09075028088218073, 0.08293237346904825, 0.11722370748387623, 0.08619133317726424, 0.2076496882178278, 0.17946903037806938, 0.15618524243409138, 0.15820812475577417, 0.1729416595550587, 0.17652364593577385, 0.19309326639909274, 0.23441889442386632, 0.1618704624627677, 0.25563482287153405, 0.2396319824708033, 0.2548177699258446, 0.2741839609944765, 0.2566955715247816, 0.19382393315644808, 0.253339870757857, 0.25140839908343393, 0.26864310912925493, 0.18276237006846074, 0.1946977967777913, 0.19338188012927404, 0.1851488539035855, 0.16478453677656069, 0.18838893711267857, 0.15965928087077297, 0.21252364115733824, 0.19735006308645509, 0.19694813252058718, 0.215213659173494, 0.16860429198654203, 0.16990361126583253, 0.17488476310659296, 0.18503262553815658, 0.1835640121543155, 0.17567504901718312, 0.19397470070431344, 0.2359444204702308, 0.17907833189187516, 0.1993921679283993, 0.19652524275176175, 0.1720824845706569, 0.18982876846622265, 0.25708638270967865, 0.2034029890207717, 0.1920557475151904, 0.5321833705161234, 0.16985861838464167, 0.14707189607797788, 0.1561404751960579, 0.18833578469770407, 0.13063118498584847, 0.18213796663539228, 0.16820420670447767, 0.5714277480825034, 0.14695316771960698, 0.1475930458473016, 0.11053716609364606, 0.3714097364020881, 0.36330924306616985, 0.1977597865255254, 0.20607734574960945, 0.3154486054034481, 0.20588390453808336, 0.18173473987104294, 0.18151226096347706, 0.18828269291681698, 0.1828825944284005, 0.19448352300981464, 0.18340579443739446, 0.18116863310074538, 0.18100695560120172, 0.18081599755244238, 0.07167985823040013, 0.0729218092672379, 0.07869108529698532, 0.08171480284934862, 0.0948102520647226, 0.07754890640537182, 0.07920715849403348, 0.07834863719036533, 0.07829220872897513]}, "mutation_prompt": null}
{"id": "2dd53374-5bb6-4ae8-a882-896ae6491d57", "solution": "import numpy as np\n\nclass HybridPSO_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.6\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.inertia_weight = 0.9\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridPSO_DE", "description": "Hybrid Particle Swarm Optimization and Differential Evolution with dynamic parameter adjustments for diverse problem landscapes.", "configspace": "", "generation": 36, "fitness": 0.27244990939223757, "feedback": "The algorithm HybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8373487368180068, 0.8222297195639808, 0.8323999954739518, 0.8282712764062301, 0.817506198595864, 0.8096855548059289, 0.8244750823637891, 0.8330680833932907, 0.8323661727645764, 9.999999999998899e-05, 0.06958625861819423, 0.036923625894010215, 0.7157230255232394, 0.04410621761498912, 9.999999999998899e-05, 9.999999999998899e-05, 0.05590437444494489, 0.10197760662642519, 0.13243720084985378, 0.1686948894805842, 0.14990816210095204, 0.15296115352792694, 0.11062819776749344, 0.17210402919296208, 0.11965759215089566, 0.13281871494815445, 0.12625043606716058, 0.09764041135816026, 0.09069648015152654, 0.08958748521390514, 0.1097878845485466, 0.11480777882496074, 0.09804427018424244, 0.11990532441903579, 0.10315137452374123, 0.11361911511965062, 0.9874147760490763, 0.9874453715859992, 0.9870124331415987, 0.9828466521080583, 0.982966471180437, 0.9814316524998689, 0.9859297189904228, 0.9790352732580042, 0.9856695819532636, 0.5233529599829887, 0.4111032162907562, 0.40921554680115435, 0.4843030380114297, 0.38619566352829127, 0.30803613970321453, 0.3666790220514078, 0.5339052056205601, 0.4567028675984445, 0.8168819703988326, 0.21398098530425902, 0.17025116433113308, 0.8373298199725222, 0.20981849045885403, 0.18582409828103597, 0.15172877917899763, 0.17304621861202418, 0.8277632641047652, 0.11884052560771974, 0.1517770936012588, 0.1421838162590977, 0.13456934170292278, 0.12426125165432311, 0.14063180215980686, 0.16461327414872506, 0.15252275530741077, 0.14526848935898384, 0.14860621346533787, 0.11254222520115631, 0.16694864882205307, 0.13295286945712725, 0.1400719803160817, 0.17147048217483263, 0.14371766886948023, 0.09331009570433835, 0.12713190464100588, 9.999999999998899e-05, 9.999999999998899e-05, 0.08694702768725748, 0.0029470142256668996, 9.999999999998899e-05, 9.999999999998899e-05, 0.004700186432127329, 9.999999999998899e-05, 9.999999999998899e-05, 0.033967392745894553, 0.01959646470273768, 0.06266254593874077, 0.07349242617092822, 9.999999999998899e-05, 0.018514823351172494, 0.055302953333132066, 0.016459467068700384, 0.027356552292349234, 0.04580886639030046, 0.03309952672307814, 0.1702785067908117, 0.20498836543735754, 0.3687533985884974, 0.0696619370463708, 0.24887429772299507, 0.3042437312340631, 0.0762452927727989, 0.2059925753281483, 0.04065459893115786, 0.05103687657240974, 0.00608081111850356, 0.1930538782023199, 0.05756097572798957, 0.35406119536540015, 0.09367532513511923, 0.05084888170659818, 0.5025294681480283, 0.5253037937222829, 0.43927281356770076, 0.4953759644529736, 0.5014194826459877, 0.5649310876159653, 0.5160309634186933, 0.5762554019840789, 0.5579176080842854, 0.09185179628453077, 0.051842224322855124, 0.0777049644083172, 0.11030934890339938, 0.11393271737472221, 0.13253884319631726, 0.1138416489927444, 0.14874664413195893, 0.6899683115581509, 0.17507801216043484, 0.43228895783592025, 0.2395186096372176, 0.2661756619206531, 0.3571776584035271, 0.15998899632701902, 0.4132703542452487, 0.47093445716313875, 0.16309798804821407, 0.4087152179919159, 0.2500078782430508, 0.3549452473960004, 0.32963823294795225, 0.22779119036050266, 0.41869667928844756, 0.4404889374798582, 0.3729237632110608, 0.4576549751943737, 0.2373348344835592, 0.16344710820066388, 0.2555299689356654, 0.17440746650999517, 0.23954478767375043, 0.37709116315820246, 0.1485803594348858, 0.28287915903115135, 0.3612422825244863, 0.23327405489275865, 0.21581442154131414, 0.20261864727749002, 0.17703797353603745, 0.20941519334547298, 0.20974645613598952, 0.23476817460565724, 0.20274050716121605, 0.22119150472480542, 0.20627798634396433, 0.1939897745364585, 0.18527539639183643, 0.1971867665831848, 0.24254053728182268, 0.1912536764912206, 0.18211419135115547, 0.1797872566216171, 0.23876801025442207, 0.8532235183689332, 0.16888558574187573, 0.152389437047586, 0.8383968702725262, 0.1978747764220734, 0.8516889914932135, 0.15881302568164957, 0.17084347019483026, 0.14731788026030956, 0.08240489502468029, 0.15414914639998645, 0.20147250295580033, 0.20586131769124683, 0.16729191837433832, 0.36628396093273363, 0.20443833112541632, 0.12567274221328462, 0.5295263799577621, 0.20186561272911085, 0.18325025314829013, 0.23627075369409878, 0.19018444387267386, 0.2235651740850566, 0.1872439581458749, 0.218737571107824, 0.1910208584197306, 0.21186663851892162, 0.07446995251506427, 0.09166774105148978, 0.10465646638767889, 0.08564134215726504, 0.08174021376718688, 0.09948662592245217, 0.09821146722589691, 0.09516277021365516, 0.10615113237761997]}, "mutation_prompt": null}
{"id": "6bb8e016-1b69-4f39-be17-67242b7c9778", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # slightly reduced initial mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 1.5  # reduced cognitive coefficient\n        self.c2 = 2.5  # increased social coefficient\n        self.inertia_weight = 0.6  # slightly reduced inertia weight for more control\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # adjusted cooling factor for slower cooling\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # adjusted probability for exploration\n                        random_step = np.random.normal(0, 0.15, self.dim)  # reduced variance for more precise search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhanced PSO with adaptive velocity, dynamic exploration, and mutation cooling for improved optimization.", "configspace": "", "generation": 37, "fitness": 0.2656543169988938, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8500342386675253, 0.845336223096637, 0.8398610331055276, 0.841456987849587, 0.8464291322596892, 0.8507939699928682, 0.8422427495730186, 0.8337262482434464, 0.8193667893031594, 0.6962978163225215, 0.03843772513359367, 0.026731899708560714, 0.06287804570939004, 0.05747118423901487, 0.733801607922301, 0.5176360419877011, 0.7339679908942159, 0.054706041158134044, 0.14512089258299332, 0.17724066537420435, 0.13359729610376725, 0.6250936415862017, 0.6214300024363087, 0.06899723946366809, 0.1307226900563897, 0.14549018004785974, 0.14937732702744433, 0.1375677430424077, 0.14560744590401664, 0.10669830895713839, 0.13279058197416327, 0.04659482781800872, 0.13700059556237343, 0.12369821031549033, 0.1602695374940406, 0.10781599067421244, 0.9943439196094163, 0.9899995658851565, 0.9902879537458262, 0.9824736773182557, 0.9867194187239612, 0.9860188947552302, 0.9937324419331988, 0.9937223666402597, 0.9897596286209842, 0.6358192531472064, 0.6283316376452255, 0.6108773872499909, 0.6694762064564901, 0.5584711327995894, 0.6306861645438167, 0.5036359728157948, 0.5900412509005969, 0.5553896202998341, 0.22411485782265905, 0.20674301262963735, 0.17144569710228574, 0.2684388333304031, 0.18702057346678091, 0.16728673135773586, 0.17585232414540264, 0.1328634113836351, 0.5278899920394077, 0.12599109507501782, 0.11918962363295305, 0.13207471297381523, 0.12238186718084032, 0.19668021998731255, 0.16716329020783882, 0.17662526020199, 0.1670958388978011, 0.16943552218814695, 0.10463466403705934, 0.12142871485482942, 0.12587319793846496, 0.11090562135370297, 0.1768049926394215, 0.1345469814688044, 0.09892510835412172, 9.999999999998899e-05, 0.11996510024010132, 9.999999999998899e-05, 9.999999999998899e-05, 0.004491389309145388, 9.999999999998899e-05, 9.999999999998899e-05, 0.003352493528529732, 0.0028164015106889595, 9.999999999998899e-05, 9.999999999998899e-05, 0.030699614177838175, 0.03577415989459021, 0.025541165295818402, 0.08574495877070498, 0.0020195347877084435, 0.004509778930462338, 0.1477167081475571, 0.019329490509204295, 0.02640891824623648, 0.04689454513075908, 0.03549444993518025, 0.0566820003412396, 0.13128227788906865, 0.07499016245778645, 0.10318650331184531, 0.09188333073083865, 0.10872856212586068, 0.0942415744880083, 0.13565118227456752, 0.0901267794826155, 0.29368857733138354, 0.03706090191214828, 0.1342715781850813, 0.013112167666063934, 0.05643919189615065, 0.0565309652499183, 0.07857955761725133, 0.5288090229686395, 0.5368478171483007, 0.5109955871422558, 0.5304271713623041, 0.5160179539941944, 0.6217121003990854, 0.5019214953982793, 0.5306752444408752, 0.5686400670048775, 0.06902873662630404, 0.10825128385513327, 0.057277334606364305, 0.108425433369842, 0.13268308472082102, 0.09217847912461585, 0.07552413006892789, 0.11098343523829102, 0.09764768651949562, 0.25597907567288625, 0.2213772328043313, 0.17324781292286207, 0.25918376914174934, 0.3468577201622055, 0.14811851487852778, 0.2209898942556755, 0.18367822411413193, 0.22122741060492257, 0.22443404334699912, 0.2057577694520213, 0.2529652189818228, 0.25857159030393595, 0.2192919510976905, 0.392770796166652, 0.4215723471395628, 0.3467746725981581, 0.4875343790132224, 0.1788387660505718, 0.225225265860306, 0.21710188987924062, 0.24287125601017656, 0.17321411109960339, 0.1166756875196241, 0.19651239868942993, 0.2478087843392014, 0.19065136336643518, 0.221733305099041, 0.19029247212886058, 0.19057099180444625, 0.18886697217525183, 0.20461992130824946, 0.19735067155975505, 0.20905669959781703, 0.2318763038468986, 0.22381040975315292, 0.24148454617673598, 0.18118655723217414, 0.24891432178112316, 0.1874542506837208, 0.17787686892297372, 0.18239193798446818, 0.19712721513020637, 0.24043574791325872, 0.2449569238563265, 0.16203114876225977, 0.16518085604291477, 0.15368460185823318, 0.8398632024986625, 0.1997155528428386, 0.13483708694359486, 0.09984262163126334, 0.16877180782340528, 0.1597815999052964, 0.08266831982925049, 0.16790925211769203, 0.8078314412778734, 0.20687345238433685, 0.1668086028800122, 0.21011450289069944, 0.12712560000019435, 0.2117310025633664, 0.2098195833665777, 0.18123695478224577, 0.1906830093382127, 0.19074047676220462, 0.17670791758576165, 0.19884661070137377, 0.20136398272021483, 0.2117517573751313, 0.19949196342267894, 0.22755129455144618, 0.08788715682130566, 0.07165253973125796, 0.070943298812433, 0.08223078670540618, 0.07128421593632794, 0.08870104034235304, 0.07721459742980774, 0.08332067233621654, 0.07244827405037246]}, "mutation_prompt": null}
{"id": "722d3a48-d2b6-4148-91ec-4e593701ab96", "solution": "import numpy as np\n\nclass HybridAdaptivePSODE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.9\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.15, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n\n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptivePSODE", "description": "Hybrid PSO with adaptive inertia and differential evolution crossover for enhanced exploration and exploitation.", "configspace": "", "generation": 38, "fitness": 0.2486439047219933, "feedback": "The algorithm HybridAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7995589072957234, 0.8031503067423618, 0.7961485950416717, 0.8209339133353222, 0.8099386990764668, 0.8235506383205917, 0.8129551860708435, 0.8217512504197129, 0.8255297043538117, 0.025765321138144337, 0.037145189874647766, 0.06873060598815295, 0.042917201767414204, 0.2765627336091575, 9.999999999998899e-05, 0.004395385783744987, 0.7031577045349879, 0.4853795798181034, 0.13462532176746755, 0.036711914346419294, 0.1651393768156859, 0.129927815226344, 0.12087426465010087, 0.09681995226102558, 0.13502395598200123, 0.12460033188212061, 0.10946374710075868, 0.1276737730081544, 0.12638960546453815, 0.12234193397640869, 0.11266669545250896, 0.08675912083312609, 0.10768487084193179, 0.11746786708160273, 0.07644972262463756, 0.13362727976003408, 0.9903892743289847, 0.9740698326270659, 0.9935440776672638, 0.9864658621062052, 0.9850401367631791, 0.9821268259669063, 0.9936360498641378, 0.9899739742161155, 0.986675911585836, 0.5753792080098048, 0.35446435268603227, 0.4352573341190382, 0.2709733055358329, 0.49906946593367996, 0.3734576676376934, 0.31847552952561065, 0.4710009127619681, 0.4041836248041759, 0.2181381540968712, 0.2096805586615882, 0.2158059698179874, 0.18066231678882871, 0.1989772472753233, 0.20331597291559378, 0.20756103536128034, 0.1354760683982167, 0.3701717511854389, 0.11426764973623327, 0.20516611693132036, 9.999999999998899e-05, 0.1451069895249677, 0.153568356575154, 0.13965931145442534, 0.16838387374709873, 0.14407676877230502, 0.17437323696079077, 0.1383088247090234, 0.11496014698761081, 0.13070590351711198, 0.11292795180769277, 0.15465148407850027, 0.20193625113592983, 0.18407951618821505, 0.07885151663289691, 0.09433011757653986, 0.004029049334983381, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028456775478071572, 0.08382020159162218, 0.060889994656595836, 0.11155212829913996, 0.01349217352037213, 0.03221754501001595, 0.05256190660233517, 0.04601465293278728, 0.04855835748319293, 0.04410978031409052, 0.046575376165558735, 0.04430068481965155, 0.08990765975783865, 0.08354910771064461, 0.0679274967377903, 0.08744912474828348, 0.06366630858473277, 0.22206689846158312, 0.11052488723054399, 0.040801894085210955, 0.10558805058576615, 0.038536733231784304, 0.057441278081312386, 0.024032594284735254, 0.07349370784876141, 0.05351023411067157, 0.09241753848416212, 0.45974590185964925, 0.4578464671349445, 0.517511290397098, 0.5527588801635546, 0.4627722361931025, 0.5154221657503999, 0.4593984884973804, 0.483488209272681, 0.5104370571498704, 0.07692664704048968, 0.06785788485480648, 0.13377069075003856, 0.13138224043850955, 0.10034286165089501, 0.10815405782836429, 0.06718665701032311, 0.0963427603584418, 0.07856250094804385, 0.24801041595680884, 0.2816303296544699, 0.1551122143732322, 0.2602304432602819, 0.15505810392450892, 0.17510925246986575, 0.18710367677600392, 0.2805231742738795, 0.19406971370268944, 0.2477813467303902, 0.2983921063962166, 0.23645015648250278, 0.3317469536672264, 0.31582461121957983, 0.39702343587940736, 0.3873781152974123, 0.37025817387216353, 0.1721575085161121, 0.1515000276938947, 0.2272535347770409, 0.25286419267230853, 0.30996362323664806, 0.2022895730069113, 0.22276173968187585, 0.27998713606153935, 0.24603127844527273, 0.25097098279999897, 0.21115281448910894, 0.19991937500673163, 0.19583243835176622, 0.21959605946986216, 0.190300980632352, 0.20462938635989225, 0.1931266619371017, 0.22713603584291853, 0.19720696253633319, 0.19523284141232222, 0.22706361624613158, 0.22307602052543618, 0.16755080958977064, 0.7263151972312292, 0.531127942370414, 0.23549931815304004, 0.23402635337455513, 0.21394255643337556, 0.8555271326206845, 0.16483622353772376, 0.15275822253019522, 0.1860584326105853, 0.19768747502233752, 0.1681511283745717, 0.09947243650154158, 0.16708003833491147, 0.15428891783618315, 0.1994213567351345, 0.11234067862625963, 0.20740771138776326, 0.20327554128205205, 0.16003669953253485, 0.20531855696276613, 0.12691579079116488, 0.5592218580922268, 0.6595189238272637, 0.187260419329786, 0.20470685957484303, 0.19486161151581372, 0.17784051039633775, 0.2333808455773374, 0.2140086895144957, 0.21561842390911723, 0.2039575231637848, 0.19955503367060579, 0.06831743426696701, 0.08734011320964696, 0.08669155688613195, 0.0868831194321481, 0.08368191271620185, 0.07654208632957327, 0.08465616544302479, 0.0878901825032955, 0.09481257044192093]}, "mutation_prompt": null}
{"id": "cdf5848b-f5e4-41ea-85b7-8a73fc235fc7", "solution": "import numpy as np\n\nclass MultiStrategyAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # increased mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7  # increased inertia weight for better exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:  # decreased probability for exploration\n                        random_step = np.random.normal(0, 0.2, self.dim)  # decreased variance for finer local search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "MultiStrategyAdaptivePSO", "description": "Multi-strategy PSO with adaptive velocity and selective Gaussian perturbation for improved convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7645660983867084, 0.758702709510273, 0.7890045465220392, 0.799529608554374, 0.8068439657809132, 0.8011044829188833, 0.797719920986778, 0.8054784248644092, 0.8050927496133504, 0.6566219659789216, 0.642811444329723, 0.6763562179848432, 0.6568078738648955, 0.673355089456021, 0.0006722403139971522, 0.6103930116510664, 0.6369315679753754, 0.655028218113178, 0.12708325789336727, 0.11592316891131016, 0.11902166773061795, 0.13257883632073642, 0.09252579419086449, 0.1675774787928671, 0.10601901423963134, 0.1399275630424398, 0.1392594427875592, 0.09779209693484192, 0.10820930574809429, 0.09711300361964914, 0.10853102255022573, 0.10485176522086082, 0.1326888090091417, 0.16364731277967626, 0.09125893276978747, 0.11745154215595521, 0.9936082033565319, 0.9889687827793732, 0.9903046410862011, 0.9816001085707398, 0.9848418748835199, 0.9893225551984364, 0.9900092203125976, 0.9899343417265245, 0.9897581008470192, 0.545620970146784, 0.5047437051552723, 0.5628855058971001, 0.5400781469745635, 0.4304379342505251, 0.4131106163549816, 0.5344353763715834, 0.5419208220591951, 0.5484137860819237, 0.21198962668859456, 0.2755480472088795, 0.2186829581081955, 0.3269002953280117, 0.18479661346530563, 0.2057762847732293, 0.14647338202543836, 0.626632951407246, 0.22625516557818992, 0.17551530594548148, 0.2397648181160924, 0.17597092500139355, 0.25433378124518113, 0.15108012593700937, 0.11826705207489374, 0.165911459269252, 0.14778239237964785, 0.14421291407518988, 0.13800447747083433, 0.10018790654144827, 0.2545270678586691, 0.11955569066394423, 0.17049137685594085, 0.15885205891565346, 0.12396148759395587, 0.09048802960194913, 0.1986647232010842, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0592883660970599, 0.021576940186926352, 0.069066075299825, 0.10091275005572076, 0.0050204690019846065, 0.03401776153086866, 0.04753252483087378, 0.04403771197890671, 0.0442343230507829, 0.042441674445949484, 0.04492101213376554, 0.04112631044814263, 0.09823166668116168, 0.07918509876210444, 0.08522443101837784, 0.0833063573417181, 0.08238523985667945, 0.08995703751569695, 0.24857641096031713, 0.041289298112793804, 0.21415799309076333, 0.05751419121929213, 0.10845829846884203, 0.07924314418948031, 0.0534629928871323, 0.05540131218685729, 0.0734609259765523, 0.5163310216915183, 0.45530577508754577, 0.520006605550026, 0.5300496662249472, 0.5048610370085826, 0.4935226764815269, 0.5350639107040676, 0.491111556606584, 0.4982395754506149, 0.06662196426980938, 0.05252773189168525, 0.1088752809422171, 0.13276348553926853, 0.11429592928233434, 0.15655783768509024, 0.08633195666655591, 0.08775801919808224, 0.14606196962843665, 0.3466730062439366, 0.28477709874932167, 0.16993502166712837, 0.23263856243383163, 0.31461639639555894, 0.30066633132370835, 0.19956776946908616, 0.30681265845229067, 0.17800728015090594, 0.2557640711168194, 0.4781951221338687, 0.5057913820026636, 0.35603988698256295, 0.27275227825529214, 0.3081990129204336, 0.5019795074261533, 0.36836171225806946, 0.34668821102950764, 0.3254834577885839, 0.2282505722831759, 0.14420776865644291, 0.1768295671857819, 0.27019325342219447, 0.2751969842266999, 0.19204008052536437, 0.23893945298656616, 0.09204882425478389, 0.20736866294135103, 0.18159079400627298, 0.18804978863325683, 0.17963169867575202, 0.17135606592704755, 0.21744886074330894, 0.2085171522636411, 0.22260718942982105, 0.21803005366668204, 0.19989976330483716, 0.18907996626287216, 0.18137036028945364, 0.18285588642029083, 0.20267975430264418, 0.20474493217368694, 0.188887724719896, 0.22986382929696192, 0.19177153940525793, 0.8415791527314207, 0.15031097167714214, 0.1522503342834871, 0.16957929511945513, 0.19913959655713764, 0.16322380489456023, 0.09902397043493438, 0.17023095125961296, 0.15936078942089593, 0.4910916519584866, 0.16697758321873846, 0.09209719882114986, 0.6678293359251442, 0.6288955261916302, 0.2100298787416175, 0.10479958976199744, 0.2112065939796648, 0.21330531492594207, 0.1949458727743032, 0.1946423531522542, 0.18914407133450395, 0.21906619364828628, 0.18553062548421462, 0.19621963632062545, 0.1940629533971574, 0.19119602131187652, 0.19713309255954836, 0.08397795793041474, 0.08792232954651569, 0.08343591099265124, 0.08825384565946714, 0.0888879949408602, 0.08119926555817236, 0.08532022878110035, 0.08410830386756041, 0.09385048059689016]}, "mutation_prompt": null}
{"id": "0ac05812-9b14-40cc-a8c9-e0ac9189f678", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # adjusted mutation factor\n        self.crossover_rate = 0.75\n        self.c1 = 2.1 \n        self.c2 = 1.9  \n        self.inertia_weight = 0.6  # adjusted inertia weight\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # altered cooling factor\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.12:  # slightly altered exploration probability\n                        random_step = np.random.normal(0, 0.15, self.dim)  # finer local search adjustment\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhanced Particle Swarm Optimization integrating adaptive learning strategies and mutation for diverse exploration and exploitation balance.", "configspace": "", "generation": 40, "fitness": 0.2668385646824798, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8681821376651839, 0.8598428689147956, 0.8773549155533882, 0.863870975542857, 0.8590057902841204, 0.8759681649823355, 0.8627750464146849, 0.8866594307207213, 0.8813103807655188, 0.07218339098061388, 0.03442304287454767, 0.7770008329770379, 9.999999999998899e-05, 0.791250934701376, 0.13881127058148124, 0.05038811616215677, 0.006415729046933882, 0.05777363274515357, 0.1148428824649369, 0.12744491528065605, 0.16724621884990043, 0.5418956845274172, 0.1417054915107714, 0.13899228918684148, 0.171735875144559, 0.1376005437375829, 0.7741681530281145, 0.11788729660582797, 0.1136508588327515, 0.10031300432123824, 0.09987511135557925, 0.13640319472028273, 0.13927274274120804, 0.16864951960419117, 0.12209816823062447, 0.14494634850594645, 0.9878829848186225, 0.9842333756642476, 0.990364994620037, 0.9707992067521551, 0.9901934514368073, 0.9418730272635965, 0.9898452642494874, 0.9937562213982457, 0.9865580534720447, 0.5300893715071409, 0.38278142210750155, 0.5156479841341983, 0.49257030990473405, 0.2327345442707366, 0.49103604683253255, 0.5126033223020514, 0.5932755238955831, 0.5380536738339707, 0.1713876823924253, 0.20648439171570598, 0.38568150089919395, 0.2097428520597926, 0.1883870420400221, 0.215888253480241, 0.3785274800997438, 0.12543888236708467, 0.21721744526150544, 0.09526237255697811, 0.15611861921679593, 0.14904716178680077, 0.16080954293214822, 0.13063895584967744, 0.1751193092476364, 0.17406600387015803, 0.17781876811643016, 0.12953722891762987, 0.1639181127599486, 0.1068627430247645, 0.1432885279796965, 0.1674847749660996, 0.24406494248222232, 0.17739035303723483, 0.1847883774282224, 9.999999999998899e-05, 0.18947318991900386, 9.999999999998899e-05, 9.999999999998899e-05, 0.04392408000330561, 0.021241902546976554, 0.01592081681574109, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1152213482977219, 0.03449250962398254, 0.0369238065105475, 0.023143711966720715, 0.0831848575155435, 0.00596845935172674, 0.006723300060068715, 0.08961946257028008, 0.06814050610677425, 0.05472089011697023, 0.093438471098509, 0.3239012239425231, 0.0571609860950133, 0.10437468683062856, 0.09942863130448243, 0.3919356852891781, 0.09619223381595998, 0.0839807032848372, 0.08598620966722426, 0.08977853900305577, 0.042191322195863745, 0.07979515003084414, 0.006349251477014706, 0.00703765387332389, 0.17650066076079296, 0.056869636364804466, 0.057109855067061455, 0.1992951682458579, 0.5555844900473971, 0.45096072873769877, 0.5659876175450513, 0.50746671759204, 0.5944904127004822, 0.49693363658151646, 0.5358469583828954, 0.5066935731367939, 0.5090439790239676, 0.09701933852205025, 0.10691156308455085, 0.06870431711132186, 0.1089176026548806, 0.12905642931463646, 0.13837720807383302, 0.167698834748636, 0.07690469435514291, 0.11313450118301938, 0.33514580973274133, 0.17760826519755013, 0.17295752809383136, 0.2491952201112415, 0.1950888020531948, 0.2571578705521316, 0.46697585493414095, 0.17062219505806808, 0.2242248310853171, 0.3064278403878872, 0.3226169449409523, 0.37827752158754824, 0.4621815275025516, 0.21800722040804754, 0.3483898290099491, 0.3761391594571085, 0.47557938142713896, 0.42034987225953846, 0.17372368212729106, 0.18541250144395938, 0.16135663800104105, 0.3740147282705175, 0.30563086255762395, 0.22717712846772176, 0.22136136337838663, 0.27147035208652526, 0.21884748894612827, 0.20866651767859312, 0.19589403936170258, 0.21587551132583727, 0.19856454977018145, 0.15327937717278128, 0.25964737895766454, 0.22268675704877838, 0.20705948987966827, 0.24001037611828901, 0.2423676562396183, 0.21631052914483073, 0.24682693680422518, 0.22157930214012334, 0.1859261535474096, 0.18697063267100567, 0.2074640040190927, 0.21864807902446404, 0.215382484503575, 0.16899310412022928, 0.1661512218843365, 0.15394935837663304, 0.1722363357297343, 0.8828290846596196, 0.19990138715679906, 0.11834942574630058, 0.16870069314606573, 0.16298410226385973, 0.08275216487896064, 0.20920107084357298, 0.49948739577199974, 0.20996780073990007, 0.16887304752153254, 0.2088084718094787, 0.10450308122353602, 0.1551173510951932, 0.2111691363620226, 0.19938797879858705, 0.19094074126854965, 0.20760269540834875, 0.1741759854319922, 0.18826725168422687, 0.178214272203713, 0.20789207283403044, 0.1974648951820548, 0.18328188272468815, 0.08358067607966513, 0.11009753581668125, 0.08121031238115739, 0.07332899490278066, 0.08145909784260053, 0.09458451110984356, 0.09430285784088466, 0.08143930878132577, 0.07515189824731972]}, "mutation_prompt": null}
{"id": "3dea9d59-71f0-4da8-8645-b1386d0c4423", "solution": "import numpy as np\n\nclass EnhancedDiversePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25  # increased population size\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))  # wider velocity range\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # adjusted mutation factor\n        self.crossover_rate = 0.65  # adjusted crossover rate\n        self.c1 = 1.5  # adjusted cognitive component\n        self.c2 = 2.5  # adjusted social component\n        self.inertia_weight = 0.9  # increased inertia weight for improved exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.97  # adjusted cooling factor\n        self.exploration_probability = 0.2  # adjusted exploration probability\n        self.local_search_variance = 0.3  # adjusted local search variance\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = np.copy(self.particles[i])\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = np.copy(self.particles[i])\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = np.copy(trial_vector)\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = np.copy(trial_vector)\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = np.copy(trial_vector)\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < self.exploration_probability:\n                        random_step = np.random.normal(0, self.local_search_variance, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = np.copy(candidate_vector)\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = np.copy(candidate_vector)\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = np.copy(candidate_vector)\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedDiversePSO", "description": "Enhanced Diversified Particle Swarm Optimization with Adaptive Strategy and Spatial Awareness.", "configspace": "", "generation": 41, "fitness": 0.26867729880355284, "feedback": "The algorithm EnhancedDiversePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7889692058761014, 0.8130709190997165, 0.802948139580516, 0.8026036063609704, 0.8041506457931562, 0.8035496896041741, 0.7988667074639556, 0.7911512754780332, 0.8043767862420408, 9.999999999998899e-05, 0.6565121402034558, 0.6923066506788278, 0.664290801711046, 0.67367468747661, 0.039873831328084086, 0.6823351055023861, 0.016788053070218356, 0.6441153689621368, 0.14130780159128065, 0.14172348828897652, 0.1222738102759302, 0.06954953660676133, 0.10328045755974713, 0.17223828474846792, 0.14068825371883376, 0.1353969578066313, 0.06633089352150312, 0.09951293188319665, 0.12140417434444006, 0.11943837459218776, 0.11830665786465966, 0.08971230192565816, 0.09522388761669065, 0.13312784016592938, 0.06333023355782608, 0.13135604332510498, 0.9924994853458162, 0.9928201619566863, 0.9871674772939943, 0.987265161097652, 0.987282134356175, 0.9822797698557251, 0.9879152576137854, 0.9876480014149335, 0.9910124776053191, 0.5327484782141745, 0.554526814920012, 0.5374254506434946, 0.5306139727024785, 0.5106766305702218, 0.5825908085343192, 0.5487742014844246, 0.5044891567583114, 0.5104457454103638, 0.21966264708907235, 0.21624672021708435, 0.2151529964096187, 0.6365728656118095, 0.1892833675510568, 0.19997619403744482, 0.21000811661354202, 0.3038561958161544, 0.14383761769102998, 0.16129886118478265, 0.08467433072210173, 0.15096478346534314, 0.15486671753130288, 0.11698306261904512, 0.11389473450571219, 0.223185532135456, 0.1448588932438093, 0.11826559836679484, 0.15651439000437717, 0.11993101212317159, 0.1848437940449732, 0.2006748811111253, 0.10395506232641782, 0.16608567225622095, 0.18183873872342848, 0.09362792365605632, 0.08969471597977785, 0.00031430269412158207, 9.999999999998899e-05, 9.999999999998899e-05, 0.0028007185030807236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04695078690134158, 0.03472000104946815, 0.050794406145153514, 0.07570992029488133, 0.02170229994700079, 0.013671040795474654, 0.0733349806701854, 0.028099734327983295, 0.01602858166977361, 0.04562897186683079, 0.0941184544181427, 0.06940513625720746, 0.11245319431991319, 0.08144987673979265, 0.06878004259617332, 0.08061120086803453, 0.06390116899734744, 0.06437788040941594, 0.10641588925967138, 0.12799988712621013, 0.5102099447555877, 0.11326103206931093, 0.005981799211665972, 0.16993309885581387, 0.07619911297789661, 0.0760813003697951, 0.117814527435673, 0.5128775816118377, 0.4822233536590437, 0.4958300789079997, 0.5184592923701417, 0.5210271456574391, 0.502220045213019, 0.5133269316997829, 0.49607340852531734, 0.49838015806800173, 0.06799288009059923, 0.07707798307403246, 0.11560830094866503, 0.14770947372538923, 0.07891075095625477, 0.09877672268824012, 0.05989629102432137, 0.10713820991115175, 0.10395189699222851, 0.15646226763563953, 0.19694651588122336, 0.2695253949518859, 0.23833804406605807, 0.2213282965524408, 0.16723913268901758, 0.21408795180409168, 0.19307538137312297, 0.21960427267755822, 0.4911115210560445, 0.2604699092966728, 0.29108554206464987, 0.19716079760116845, 0.1492281350597705, 0.36878242800788896, 0.40921448780073977, 0.3122003220619386, 0.27768125979727676, 0.22140493045923415, 0.1935250748750278, 0.2614462179700138, 0.14602344613091045, 0.18867604409016125, 0.18730344109448194, 0.16231348403622992, 0.23189599726496402, 0.2506333248063616, 0.19392687487113813, 0.15203236703287182, 0.2028282706762662, 0.20337235098756945, 0.16637782009070656, 0.1734200911525715, 0.19328767404832925, 0.18346668176862446, 0.1877856773831944, 0.20628997338030153, 0.23417745596363304, 0.1857669835384399, 0.19727351064495713, 0.18888832318219906, 0.1945840453800447, 0.1810347180794437, 0.20131559363580886, 0.19034343253130415, 0.8146662536680327, 0.8227614365612698, 0.1522995382749741, 0.8279984713096066, 0.198458618032906, 0.1946998353415892, 0.09920220276349845, 0.16844823178920432, 0.2076732372598843, 0.31020326877471227, 0.49009018934829585, 0.11038742482888864, 0.20243953356016542, 0.12475664444066281, 0.4071971677996379, 0.20886740242471902, 0.2098615696629681, 0.43963525758252364, 0.18040322098914663, 0.16991306800776163, 0.180802904903561, 0.18456817061534025, 0.18814201190410884, 0.18521299905114474, 0.17883273931483457, 0.20211266035056552, 0.20845231817764687, 0.10444912666646011, 0.08580772679762594, 0.08304463713477728, 0.07925616818485437, 0.08832320679405514, 0.08235814480040915, 0.09442094916272892, 0.060848644341406355, 0.07501414419920238]}, "mutation_prompt": null}
{"id": "12951a06-8118-4134-9c42-40f0cc07fd17", "solution": "import numpy as np\n\nclass HybridDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.95  # slightly increased mutation factor\n        self.crossover_rate = 0.65\n        self.c1 = 2.1  # adjusted cognitive component\n        self.c2 = 1.9  # adjusted social component\n        self.inertia_weight = 0.8  # slightly increased inertia for exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # adjusted cooling rate for mutation and inertia\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # slight increase in exploration probability\n                        random_step = np.random.normal(0, 0.15, self.dim)  # reduced variance for precise search\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridDynamicPSO", "description": "Hybrid Particle Swarm Optimization with Dynamic Multi-Staged Mutation and Adaptive Inertia.", "configspace": "", "generation": 42, "fitness": 0.2598150081241904, "feedback": "The algorithm HybridDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8213549281806474, 0.8175482445292541, 0.8163884635970231, 0.8454978816693021, 0.8335575683482006, 0.8416546631229188, 0.820781035034261, 0.8139247268548323, 0.8508470695484017, 0.6574192819017859, 0.038178323110189205, 0.07291271428087187, 0.05825195407361805, 0.04262351742485715, 0.2445266186970756, 0.046578295064874875, 0.7266680348872285, 0.04965905067759213, 0.09306775878736095, 0.1486647883467347, 0.12254992198001202, 0.09593671357680045, 0.10969637194690607, 0.06993825784061813, 0.07169702803505973, 0.13975576928115263, 0.10645175832106657, 0.10793601549635046, 0.11452223698874764, 0.12275740945605862, 0.113667049639122, 0.142859418129217, 0.12210895019611057, 0.12377778518695193, 0.11920258758620073, 0.12859111011777258, 0.9935735385739134, 0.9862418655605227, 0.9902785989608891, 0.9851136758146787, 0.9848383166654737, 0.9862140136607198, 0.9898088102594744, 0.9886148676818406, 0.98658546624979, 0.43357175148759186, 0.425890804606897, 0.61139481859118, 0.39436870515915157, 0.3325839068630283, 0.3942427482151515, 0.45288812680301604, 0.5551360153374696, 0.5526254954647609, 0.20942820865806633, 0.17024854664653832, 0.3499889899938675, 0.2613128113970937, 0.19918439851828584, 0.829241210097325, 0.3390420777670502, 0.22997265132131917, 0.7666120638722791, 0.08977232618002728, 0.35409820129927183, 0.16346306618359863, 0.1655518429152315, 0.14879687680089249, 0.16096470269718754, 0.14968731441904692, 0.13412023032224896, 0.1744079997985678, 0.14178416286385476, 0.11312899481630012, 0.16655317139987547, 0.14713431705620317, 0.12370438102083448, 0.1431787481345329, 0.21613971462348291, 9.999999999998899e-05, 0.16896435747828542, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012571737737191002, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00743818346807934, 0.06265488574673439, 0.02780211598950355, 0.03570370659148869, 0.06089411747451845, 0.006983668994860137, 0.0005511427714609551, 0.0959040403580006, 0.07028999385980972, 0.059604346500128136, 0.06182543574112953, 0.03214091576053213, 0.15668600168416102, 0.08912057483592728, 0.07225573517742379, 0.07413169266947262, 0.08730576786426769, 0.07787801994871857, 0.07137721129931507, 0.10482505499136296, 0.04694960786831015, 0.17854740741237185, 0.023308792422975455, 0.0519682144517547, 0.05816300151472409, 0.0546606410844237, 0.05445319598331411, 0.052569695081543744, 0.44528673394460383, 0.45066181806203065, 0.48145312011990893, 0.5161308340518962, 0.5861220327890138, 0.5267457307153605, 0.47898236130453065, 0.4934122140435572, 0.5141323080230071, 0.08043937314250049, 0.09333716173967044, 0.09360233736406898, 0.11521333958675006, 0.10139363126028234, 0.10229840311991101, 0.09140794251603834, 0.0857393838974645, 0.13971445780861946, 0.2075229505138262, 0.21826565442899037, 0.23352289485560873, 0.2829963062615427, 0.3646773230916509, 0.21731138647363546, 0.455593813026022, 0.2785390374005903, 0.24167286328222937, 0.3862764971199927, 0.23867910175257634, 0.2679727459193464, 0.27834508314016193, 0.21053551643806467, 0.38719487451756307, 0.49924609452491153, 0.5049454141584695, 0.4219724101837319, 0.2320418391433302, 0.17143694841712864, 0.15610727268013402, 0.19113145899677042, 0.29221778193752657, 0.2642969012398968, 0.16351407050060152, 0.3766831130290429, 0.28146447863404855, 0.16989557049593162, 0.17332479852370963, 0.17749418059349809, 0.21508368570257475, 0.17525107250320104, 0.19701068595244609, 0.2225204692144761, 0.17378801230394014, 0.18887962785957324, 0.20954152990576203, 0.1983190101597756, 0.21055125013703524, 0.19893377049986538, 0.18221907165888473, 0.241443764025414, 0.18966465783336994, 0.38180347646292023, 0.18470707811147735, 0.16520481638821238, 0.16864725669006442, 0.17105302811970757, 0.8589094286651371, 0.1971989970535909, 0.16199285546592856, 0.09959910737652866, 0.16848593375802778, 0.15701027785477384, 0.36397757307600653, 0.1671452688965821, 0.12512082486370857, 0.2048265531954886, 0.16571041111706342, 0.4327714116873238, 0.20916140855126053, 0.2113123274525539, 0.20632012994592575, 0.1904954495891572, 0.19878390523034162, 0.1916358399990875, 0.19680540255645962, 0.2329883722215106, 0.21923450173970416, 0.18190606721735325, 0.18978834599765937, 0.207139272891821, 0.08538010267005247, 0.08106242866939051, 0.09958089212381294, 0.08664029996555422, 0.07610439850081552, 0.09804964068313671, 0.09002862433593595, 0.07023217959192074, 0.07769859414757141]}, "mutation_prompt": null}
{"id": "9a22ecd1-e276-4f1c-b044-145358f78c20", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    dynamic_probability = 0.15 * (1 - evaluations / self.max_evaluations)\n                    if np.random.rand() < dynamic_probability:\n                        random_step = np.random.normal(0, 0.2, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptivePSO", "description": "Enhanced Adaptive PSO with dynamic mutation, crossover, and inertia strategies for diverse exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.27031633096182095, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7953575832656845, 0.7541280647480778, 0.8039138617830603, 0.8108332170039314, 0.8043464914579123, 0.8152109831303265, 0.8003878405747138, 0.7507430450830662, 0.8039164146761806, 0.06550215792291547, 0.6396796366462347, 0.6373650803383649, 0.6101926177547048, 0.6667197555670703, 0.6673407972894163, 0.6354656839343584, 0.05386153893536283, 0.6915914138065964, 0.1294360293357547, 0.11287866488434062, 0.1624659340259954, 0.16178468362095877, 0.14109580945699585, 0.16256639619513902, 0.1078674646914849, 0.14036382749662824, 0.1442058326926936, 0.12496716716209433, 0.10629356608043194, 0.10697673733222002, 0.1389938355814191, 0.12049735949135743, 0.09423579332358079, 0.12602643747174802, 0.09345493719167064, 0.09508934688025839, 0.9936082033565319, 0.9889687827793732, 0.9903046410862011, 0.9816001085707398, 0.9848418748835199, 0.9893225551984364, 0.9900092203125976, 0.9899343417265245, 0.9897581008470192, 0.49917710852409725, 0.5338703809120212, 0.5680487298707246, 0.6302943263746545, 0.5309810891426467, 0.5753628651675843, 0.5672944002536149, 0.5322376130524163, 0.5541931682517296, 0.21339536972689477, 0.22026779732703372, 0.2834996335355512, 0.2032695147726713, 0.20145991883941838, 0.21305646035888604, 0.1357370321858754, 0.17376848417656643, 0.20234890532585137, 0.19238956343472569, 0.1476268846178893, 0.1666629440864713, 0.17697406828838524, 0.1596269106479682, 0.11491861361063327, 0.12216528614053745, 0.11079537260833416, 0.1025819108639795, 0.17286498006937523, 0.11442574649193138, 0.10975994967949232, 0.15140071196391014, 0.12702982392333628, 0.18705224390667086, 0.1259314511152314, 0.08923041485913108, 0.3030690277419992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004006487006843473, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011554527808836812, 0.0616424135045589, 0.02503275683394257, 0.060499823134588904, 0.0714737010380806, 9.999999999998899e-05, 0.012362056843277736, 0.04779771869203053, 0.05557488348422013, 0.03945280765640091, 0.14671164555214433, 0.042065216188524546, 0.0414809206748874, 0.08153445644251511, 0.08022623391276484, 0.08236753413503906, 0.09090912622540259, 0.08666130786337822, 0.08655262717311252, 0.19854922673426223, 0.05774991278256547, 0.3118482549689232, 0.03359052581502564, 0.25773147390462814, 0.0844701490856945, 0.05319717070287222, 0.04730145506711392, 0.07704058470970254, 0.520074093136486, 0.5178992493752603, 0.4859860879081934, 0.5449986317811827, 0.5026421408842487, 0.4875099788654511, 0.5171482545587317, 0.5158871966041576, 0.5039090241622974, 0.08290706692904604, 0.05368273035658366, 0.16261902374832404, 0.10101676346902799, 0.1300381249737358, 0.10651903574590083, 0.08642622938536881, 0.07707811871461623, 0.1025963166166548, 0.2310396937296606, 0.17614695213958753, 0.1727577958021297, 0.1936511834122865, 0.5337816708462129, 0.13371214423444067, 0.15372186997453918, 0.28648482541458276, 0.1769383840380364, 0.26177373766305134, 0.3850890112811245, 0.28209022134248096, 0.3568636093760541, 0.23814381287757558, 0.2513505214219788, 0.4918951655230579, 0.5331629464473472, 0.1709625318502067, 0.22053476531393257, 0.20161307891327984, 0.16537970582728467, 0.17073610033073328, 0.3173026371799643, 0.34185906017228795, 0.15468363360390303, 0.28068445476038306, 0.08550764747796002, 0.2245066931956784, 0.20556771275922248, 0.2036171217507622, 0.1846368430085391, 0.18197408596229236, 0.19758717574138984, 0.20704741989491027, 0.22318511963101617, 0.20669716167880137, 0.19989325899299504, 0.21448311507291495, 0.19430735066111116, 0.2144590495971731, 0.20063171235984922, 0.20017367581899004, 0.21932119638452807, 0.21710274774498683, 0.19980933346636853, 0.8324327387141399, 0.15080317196256843, 0.15269888635834616, 0.16963763443408464, 0.1992869801535545, 0.16687084982500378, 0.09908872476187935, 0.1702184748369544, 0.15105392275561225, 0.4420363974516367, 0.16659976444442715, 0.5455837631108171, 0.4863764590399552, 0.45997920196460396, 0.20981777773697796, 0.10480631652612249, 0.21163839408036533, 0.21316225025758384, 0.2032320002756698, 0.19400525194217833, 0.19849418255715912, 0.2447481371920921, 0.19082949225676293, 0.21295810049788344, 0.17925298718813376, 0.19155755310289158, 0.2266913767868779, 0.07472307273185474, 0.08009569068969336, 0.08555918291103515, 0.09145095686021742, 0.07326484082209228, 0.07691784930321699, 0.07993662984639904, 0.07683501648368507, 0.08042575892286608]}, "mutation_prompt": null}
{"id": "f2b51da0-e394-4b8c-9454-d44037b9912c", "solution": "import numpy as np\n\nclass QuantumInspiredMultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor\n        self.crossover_rate = 0.8  # increased crossover rate\n        self.c1 = 1.5  # reduced cognitive component to balance exploration\n        self.c2 = 2.5  # increased social component to enhance convergence\n        self.inertia_weight = 0.6  # adjusted inertia weight for dynamic balance\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # adjusted cooling factor for gradual parameter adjustment\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                for j in range(self.dim):\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector[j] = mutant_vector[j]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # slightly increased probability for exploration\n                        quantum_step = np.random.normal(0, 0.15, self.dim)  # using a quantum-inspired perturbation\n                        candidate_vector = np.clip(self.particles[i] + quantum_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredMultiStrategyPSO", "description": "Quantum-Inspired Multi-strategy PSO leveraging quantum principles for enhanced exploration and convergence.", "configspace": "", "generation": 44, "fitness": 0.26120902463048373, "feedback": "The algorithm QuantumInspiredMultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.8216886126894699, 0.8179270650014631, 0.8485119702203644, 0.8579564883701094, 0.8331391186602085, 0.8388004795789658, 0.8535289515353858, 0.8403106131353324, 0.8465478046659363, 0.04053556678630943, 0.6082783662990032, 0.23617476764175704, 0.7109660329045888, 0.7572532995276675, 0.06153944771380593, 0.7305893656656779, 0.16544208408383188, 0.05534378214247515, 0.09058803056550346, 0.1620145486572333, 0.14781668045685126, 0.10542614112034698, 0.12372614205499666, 0.11545514820765368, 0.12953542012976782, 0.11522084455763126, 0.06789144275776904, 0.5149130020923398, 0.6503054237076051, 0.0983717232095962, 0.1278998308534809, 0.09970301464412368, 0.08994367400512726, 0.09102778061640493, 0.12240939732856149, 0.10309548674643099, 0.9942846691908248, 0.9850637236135482, 0.9899800457584165, 0.9853615765885453, 0.989924582198959, 0.9895554279057718, 0.9937242789600178, 0.9900991760107319, 0.9889467177689621, 0.5544319568534486, 0.5493874707308014, 0.48525639643964913, 0.5205120947457933, 0.5700484149508245, 0.6242010657942265, 0.555146889047649, 0.649389117337553, 0.5202665014014947, 0.22589520523395545, 0.16519470697053273, 0.22350588129518323, 0.19798611460096982, 0.1729630902655377, 0.14022218462015446, 0.22704012395935846, 0.17256360454052733, 0.19937276368636847, 0.09293322552697958, 0.08965370986540222, 0.16231011244532434, 0.09713388204944551, 0.12695434376913706, 0.15428190928592445, 0.16340694495752017, 0.10900624649007173, 0.2974693770394844, 0.19394816915358326, 0.1089889903772766, 0.20177288114341607, 0.10942265179809496, 0.13876889547901572, 0.22099921479626206, 0.1927936076637785, 0.09976957488000515, 0.13624071521329406, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0529977528128005, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08386425805320685, 0.03018304563718288, 0.05548635439816041, 0.10050966249996873, 0.004872510832184207, 0.009003270330332103, 0.0921568914636891, 0.05478154965424986, 0.030385095920037575, 0.03300696162583949, 0.03324811228647684, 0.047026854377478444, 0.10028239085958668, 0.0753479085044233, 0.07095183787455683, 0.09516816726100918, 0.0983995584806644, 0.09183545832994156, 0.044569629956407564, 0.04108318187729054, 0.10896431379672034, 0.028244673215111704, 0.010189830106841713, 0.0667823450712034, 0.09209433532929145, 0.05541247138790173, 0.15965791510548877, 0.5314110817017863, 0.46579642255998777, 0.5111871138284458, 0.512983036803142, 0.4930365217173458, 0.5459405130201327, 0.5195938488122533, 0.49446739601651957, 0.4978157577153073, 0.1353337273258094, 0.06162642371986604, 0.1104380734991246, 0.10976928781354311, 0.10651703653537858, 0.10182728280956832, 0.06737775336099694, 0.101944928661449, 0.09470432826397701, 0.30774592372493703, 0.24209926193578335, 0.15953658292043638, 0.20677018619988208, 0.2817327778978195, 0.19499804658504827, 0.15381138472841827, 0.2434907104739522, 0.21562555591804689, 0.2465894230341803, 0.435826960410027, 0.24206379363955444, 0.35306237921511496, 0.22673289627425686, 0.3426488365950925, 0.18327331368487243, 0.44485135157288647, 0.15552821032747488, 0.08349876289337166, 0.11675585921956977, 0.1584973237404933, 0.23641352669786653, 0.2509633791067821, 0.24634775529062103, 0.1466010894930454, 0.2686137120896812, 0.24989518722660375, 0.22579903004619273, 0.19848263818674416, 0.18816307718845193, 0.16942788284251997, 0.19375983896105708, 0.20770064059368865, 0.21217365025161994, 0.21824439685171826, 0.2183421939407384, 0.19901520322684552, 0.1890671936132844, 0.24940730170501868, 0.2405827789549999, 0.19428989227073212, 0.2067012360111422, 0.21423510651844302, 0.21288399153200976, 0.21842695145791502, 0.10510904120138476, 0.16779631042674048, 0.15387446911433167, 0.8647627387467554, 0.20008276835201533, 0.19802479351278712, 0.0997599387996122, 0.16950145919633886, 0.15275433559398666, 0.08311866106447086, 0.20883144911388418, 0.3956771823912708, 0.20614940795430925, 0.16401688493097644, 0.20646064981112267, 0.2120080708939932, 0.5317200391816959, 0.20704394730693676, 0.1889064283192884, 0.18090576255305502, 0.20757818386446647, 0.18829342901068213, 0.17825967827346034, 0.20603412824933032, 0.1880259864710151, 0.19456048957768735, 0.19593349818264638, 0.07059411079484912, 0.07737223089277179, 0.09319196709530697, 0.07778439017834227, 0.09616970784318879, 0.08543224201698307, 0.0804992312470042, 0.09350896469525483, 0.07559689632732403]}, "mutation_prompt": null}
{"id": "0b68f93a-b2f3-4caa-9999-5c6b2963a9a8", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.agents = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.best_agent = None\n        self.best_fitness = np.inf\n        self.F = 0.8  # differential weight\n        self.CR = 0.9  # crossover rate\n        self.max_evaluations = budget\n        self.alpha = 0.95  # cooling factor for F\n        self.beta = 0.97  # cooling factor for CR\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.agents[i])\n                evaluations += 1\n                \n                if score < self.fitness[i]:\n                    self.fitness[i] = score\n\n                if score < self.best_fitness:\n                    self.best_fitness = score\n                    self.best_agent = self.agents[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.agents[a] + self.F * (self.agents[b] - self.agents[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.agents[i])\n                if np.random.rand() < self.CR:\n                    crossover_point = np.random.randint(self.dim)\n                    trial_vector[crossover_point] = mutant_vector[crossover_point]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.fitness[i]:\n                    self.agents[i] = trial_vector\n                    self.fitness[i] = trial_score\n\n                if trial_score < self.best_fitness:\n                    self.best_fitness = trial_score\n                    self.best_agent = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.1:  # exploration chance\n                        random_step = np.random.normal(0, 0.1, self.dim)  # small variance for local search\n                        candidate_vector = np.clip(self.agents[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.fitness[i]:\n                            self.agents[i] = candidate_vector\n                            self.fitness[i] = candidate_score\n\n                        if candidate_score < self.best_fitness:\n                            self.best_fitness = candidate_score\n                            self.best_agent = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.F *= self.alpha\n            self.CR *= self.beta\n        \n        return self.best_agent, self.best_fitness", "name": "HybridAdaptiveDE", "description": "Hybrid Differential Evolution with Adaptive Parameters and Dynamic Mutation for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 45, "fitness": 0.15629257714437175, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.3844981469745926, 0.34470761412327544, 0.37475000908467104, 0.3668340659213747, 0.4041176153787557, 0.39924372231883976, 0.3823591985324237, 0.37971079904314453, 0.4016752870372222, 0.04581291150769051, 0.002398218148229714, 0.1013366636744224, 0.02210724528094632, 0.023644074845553975, 0.03399233697619197, 0.06603122955937724, 0.017723809393069168, 0.05788104245796444, 0.12097656815579272, 0.12067810406411594, 0.12895720163725055, 0.12044832822095175, 0.10778888292068167, 0.11485839634478057, 0.13871238232721794, 0.1246298450854465, 0.1219626665017991, 0.09777385757016288, 0.10502790438311949, 0.1232523719831976, 0.10150011202345977, 0.12534094493419234, 0.12181780236215567, 0.11807162739434385, 0.07875854458787812, 0.1135430035576599, 0.9023358870108782, 0.8993661301863698, 0.9224252377005939, 0.909759324998176, 0.9380804482957835, 0.8935145009720264, 0.9177562921560516, 0.8997196628216055, 0.895018412478353, 0.09517601382590579, 0.09285969651801529, 0.07468398310991309, 0.09453466878835148, 0.05838059789703309, 0.09573598634353586, 0.07074799814544908, 0.05736874903166189, 0.13128962945340694, 0.14781546349593155, 0.1552957370851571, 0.13717208320568175, 0.15959775441305368, 0.13709149426659073, 0.16962944555015147, 0.1142346524633806, 0.16232879173837267, 0.14667830155689698, 0.038783503728868296, 0.031237485847132818, 0.09374913199710067, 0.08400037328722498, 0.09583905115392732, 0.07568056960844782, 0.06909964600880558, 0.09262634900919275, 0.058244026247521785, 0.08543157096115372, 0.06638885466743394, 0.0652037354435463, 0.10111833292903394, 0.10515800446181855, 0.08673129594290663, 0.09215215366536667, 0.08853409640204679, 0.08523540676167374, 9.999999999998899e-05, 9.999999999998899e-05, 0.0010026683557414762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046255951610706725, 0.07293651763868692, 0.07805574900626033, 0.015441630463383427, 0.02402508728693642, 0.05951021852405358, 0.06317111836424827, 0.05515584260315587, 0.06726400592722526, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05174215667085624, 0.01586728969485285, 0.030537575464613886, 0.03172784530640327, 0.018352804196091754, 0.0559430100912367, 0.05690311716233587, 0.03125781590938714, 0.04290016327716606, 0.2728881322844261, 0.28984275431329565, 0.3301321393310651, 0.31379323947390825, 0.24620839521197913, 0.31632237893930815, 0.25365156271913025, 0.27681608595690366, 0.27675462993966526, 0.06382213146385207, 0.07872795990502635, 0.05689562550571414, 0.06206333205890702, 0.06101002192976501, 0.08488424707682829, 0.07801460060917176, 0.07531046105501737, 0.058634491451290516, 0.12369413506065707, 0.11269626641473518, 0.15181561212720285, 0.14192603440966323, 0.17711307963673695, 0.12818154630032208, 0.14212615020567532, 0.13554387769445653, 0.12213496034866367, 0.1524370766504779, 0.15252785216392417, 0.15760696341954883, 0.17072216850603017, 0.18990301531626308, 0.1968869753844208, 0.183119480981623, 0.19201303459038532, 0.1537049515414266, 0.11378815568258893, 0.14653678260894498, 0.11538719986584822, 0.09418606665600415, 0.1181259279990089, 0.14216792272493317, 0.14210652428784054, 0.1252763921775769, 0.12427582429712836, 0.15116459263016768, 0.15795279964646292, 0.16130417872240832, 0.17570551560780734, 0.17568854357061758, 0.18331297589939355, 0.169806097261474, 0.15717097287086035, 0.16947931194356647, 0.17621323421814272, 0.1748820805356871, 0.1737139463986458, 0.173885519466342, 0.1828196610733276, 0.18868318743551138, 0.20037560831079082, 0.16702341685806454, 0.18643531523103607, 0.13179838727313875, 0.1536349656304472, 0.20416840895624533, 0.21454588629753613, 0.318819401653188, 0.15279405825361958, 0.1469099003215404, 0.2506405726906862, 0.16421718622895132, 0.17535811664592615, 0.1815561616753124, 0.11968178503614202, 0.15844629907085905, 0.16418112911987792, 0.1445679553705317, 0.09912628745088992, 0.1662272196675485, 0.16710490956728585, 0.16011019964235407, 0.17825429932204284, 0.17515159817002512, 0.1491992011601596, 0.17667548918433973, 0.14050929967508186, 0.17362778850715166, 0.17759761871066748, 0.15899292751086236, 0.06327095036466057, 0.05473976243342371, 0.053057888625827054, 0.06187819492973412, 0.0767206686339057, 0.05564563775114617, 0.05723182602958421, 0.04967338873092353, 0.04920453543821646]}, "mutation_prompt": null}
{"id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveSwarm", "description": "Hybrid Adaptive Swarm with Differential Mutation and Dynamic Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 46, "fitness": 0.2844495813169738, "feedback": "The algorithm HybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "eedec01c-f33b-4c3f-bd8f-292872837059", "metadata": {"aucs": [0.7824656250664669, 0.8229242187852728, 0.8144353984907605, 0.8088924053694231, 0.8333615603336164, 0.8227827160048221, 0.81798987206897, 0.8147286911246422, 0.7999782518768724, 0.07381014766132954, 0.04059993901430625, 0.6643052319549253, 0.6657448064083178, 0.034740749776505986, 0.223613072111979, 0.693406037372297, 0.6576638537772735, 0.6795967718963172, 0.1712608993904554, 0.14221438647648843, 0.15549478043945786, 0.11342176278164284, 0.12747356359092887, 0.11921425891376747, 0.1356036318599919, 0.1457319005537827, 0.1381408899717762, 0.11582619434100527, 0.12557812445008165, 0.12130250031969103, 0.10193720572256282, 0.09638316146285597, 0.12124614727918703, 0.10351938187590626, 0.10979394736951087, 0.13123080989000446, 0.985619691052244, 0.9751725846659155, 0.986605371167275, 0.9736712348394414, 0.9850933642409258, 0.9748275826538493, 0.985413744050068, 0.9865336157630624, 0.9820839475248891, 0.5519248656285033, 0.6160555750443458, 0.6047235260031147, 0.5936306547106167, 0.6352003896970237, 0.6139829215311647, 0.5294617252805286, 0.5663199358976178, 0.4743684922888022, 0.16445206967461035, 0.20353686281703187, 0.22236811134578516, 0.26612838442416364, 0.20976082270761143, 0.8122161965596711, 0.12289727698927055, 0.6882267846554695, 0.2352009089330418, 0.15147668680026072, 0.19372083761631909, 0.16122053668090175, 0.1796085176669081, 0.20216363374134783, 0.1705158927391851, 0.17543725134736088, 0.16551347268730987, 0.16273443874380977, 0.17692601077991954, 0.12098141016088526, 0.09524617738061703, 0.17832744269799528, 0.2163624916536827, 0.2038562402377435, 0.1975014510728641, 0.08867633617904869, 0.17139940505942508, 9.999999999998899e-05, 0.030774770876256685, 0.0051908655931202086, 0.032079208994214015, 0.00164483349076594, 0.0009306844648397927, 0.02907593146056331, 9.999999999998899e-05, 0.02555229568630657, 0.08479155310887398, 0.025811411819601227, 0.0451009431389362, 0.04371240916694774, 9.999999999998899e-05, 0.011146419021738851, 0.06621120049007856, 0.05883775547793735, 0.06229238928593528, 0.05411886642019015, 0.03648739860081063, 0.044857058403988015, 0.0986613568942647, 0.24616468968261818, 0.07670640224698522, 0.09412213814739823, 0.06791435483088659, 0.07663457099449766, 0.041628494359551405, 0.10848809057907838, 0.20628272193759667, 0.04012138025126566, 0.13067759702283033, 0.10692344089177697, 0.2306405088291812, 0.09942571050262416, 0.11270209515482943, 0.4810022982401774, 0.591299495418655, 0.5152389758036653, 0.5198386537715382, 0.5682921761657862, 0.5699644460979733, 0.5678505206506081, 0.49246932614206973, 0.507325099268175, 0.1148008957774771, 0.1107363459051206, 0.06663421322476848, 0.11464766847520191, 0.1241488840142867, 0.1652447877947334, 0.10868997231074196, 0.08399466037875014, 0.09930537648202897, 0.21899496556187892, 0.34147455912170266, 0.167930032397118, 0.25342987310556275, 0.5029852815203113, 0.1804637554756382, 0.3548969374881744, 0.1694950601714338, 0.2060780463695051, 0.31730094887310256, 0.4201368724672284, 0.3252629711719417, 0.46340957355525947, 0.2160661844818983, 0.2211658908135381, 0.2802108081664092, 0.4720889410043192, 0.20819416004536284, 0.0813455212656583, 0.3236150288871622, 0.17752033675330858, 0.2086202530163601, 0.2602553812297911, 0.2323160478172076, 0.21522508099948323, 0.2364910340775882, 0.261670721230591, 0.2075002660538504, 0.20659728247056997, 0.20576486122539972, 0.18940488762799912, 0.21037459260975677, 0.22195155191097038, 0.2106630087422614, 0.21073614169412336, 0.2084191073590489, 0.23383054414230342, 0.20200484483246806, 0.6613813905419892, 0.47040937006529726, 0.6734460380780735, 0.24253502538646787, 0.21254002778827885, 0.2351130834508598, 0.230046208210697, 0.8458790928976583, 0.12600315717226984, 0.15346500804633612, 0.8582523016765803, 0.1998961953344347, 0.11596005578898472, 0.09957104759789837, 0.1700069443647988, 0.16121984436750503, 0.08265716523400479, 0.2074140632083057, 0.43561075177423525, 0.4057115390197351, 0.16722050175222047, 0.207210434324559, 0.10444860446511539, 0.5885558748556533, 0.1761091554802653, 0.19337512880869423, 0.19276571142252374, 0.17640610237257004, 0.1931775083172722, 0.1862377755190533, 0.19288954366580457, 0.20769620890769624, 0.19297247544772722, 0.18691208240214818, 0.08782811723351946, 0.08861340613935387, 0.08581318063631282, 0.09066441646000711, 0.09376215529152054, 0.08703456628556872, 0.08197733939520424, 0.08146078817739266, 0.08591770844238467]}, "mutation_prompt": null}
{"id": "79f4cde5-0500-4190-8363-b1048dc0588d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.c1 = 2.5 \n        self.c2 = 1.5 \n        self.inertia_weight = 0.8\n        self.max_evaluations = budget\n        self.cooling_factor = 0.95\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = np.where(np.random.rand(self.dim) < 0.5, trial_vector, mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.15:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveSwarm", "description": "Enhanced Swarm with Non-linear Dynamic Parameters and Local Search for Improved Convergence in Diverse Landscapes.", "configspace": "", "generation": 47, "fitness": 0.24325541058998684, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.6798898658727441, 0.8909463435138896, 0.6202815617955939, 0.6514541262317812, 0.5608541315888116, 0.9040555675258654, 0.9083708680087769, 0.9079449008160307, 0.7007256598223628, 0.28650239622728135, 0.0426210944943759, 0.3808836657492183, 0.39564313648443383, 0.12012263632598064, 0.11676078772385567, 0.05929554295541928, 0.1117380617978484, 0.5250901169439209, 0.1418389673009769, 0.13777052953070978, 0.11530985430204632, 0.15568441723974014, 0.1300190762854896, 0.15045818521215515, 0.1160905848113496, 0.13799066108432212, 0.11299717633686501, 0.10130323179371803, 0.11892042605987174, 0.15209789922858086, 0.11994736660791316, 0.12727973496706946, 0.14106237029545554, 0.09302093314665849, 0.08417400971014044, 0.1266579607806263, 0.9831009046048921, 0.9783277513741786, 0.9865629689618776, 0.9865440683512966, 0.9829320133566517, 0.9857648667278628, 0.9869142822751004, 0.9775256871958746, 0.9827163843322239, 0.2860464137864597, 0.23630391415010243, 0.2730336477872586, 0.33688857077661327, 0.24505674647396658, 0.4562779866676425, 0.33486190653510783, 0.3547273795411384, 0.242393766725297, 0.1688337673589102, 0.16922789946654704, 0.24759192505955374, 0.2724509395862854, 0.19217071162396537, 0.27679659255783273, 0.5294651400651486, 0.17766806467191532, 0.1624313282665516, 0.12923707103143622, 0.1506468142982168, 0.15908426157344568, 0.1744640410252245, 0.12730301525643484, 0.11603830091816547, 0.20116539175662462, 0.14325816526325275, 0.15949948407843673, 0.14389477592695255, 0.11805847930786384, 0.12584042281484675, 0.12548295556311773, 0.1716925549626438, 0.15250946282351052, 0.18349183752138865, 0.1341144588938381, 0.1563884242612299, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0457325948347892, 0.037745075448008536, 0.049427342326279544, 0.03540642138747829, 9.999999999998899e-05, 9.999999999998899e-05, 0.10685677819593653, 0.09427633653892975, 0.04635086975531466, 0.049742796112713816, 0.06180116034349281, 0.1446989854130063, 0.10006365602906753, 0.07967914747558258, 0.07990972449417189, 0.10430216405282022, 0.17415467916759897, 0.07678447594273752, 0.03970027280677002, 0.173056564018658, 0.24353623947348269, 0.06808435983181138, 0.04058090260525338, 0.01669455025894606, 0.13898204074319043, 0.13629171147363284, 0.081829504981911, 0.46774896229090823, 0.5215191696313696, 0.5781533714608369, 0.49884206881325344, 0.47680777656364315, 0.43438326905974123, 0.4185373967684327, 0.473644401907766, 0.4945211628724986, 0.1091926434173105, 0.15456345126497695, 0.09001358901125478, 0.12009910324934903, 0.0874532772970833, 0.11917756571491678, 0.10448238528743259, 0.11309895852459229, 0.13504500525248986, 0.2070468634013194, 0.15639350776580918, 0.22833692749873002, 0.19082317112625713, 0.3118107698683783, 0.1752013699227073, 0.2018030335103913, 0.19393018825324393, 0.23304043239805372, 0.29756449898297255, 0.27513412640189727, 0.22467657842547528, 0.32546498699159443, 0.3553967393992513, 0.27021348408116774, 0.27672924961017487, 0.4282948208544918, 0.1605781493889017, 0.2400210764273576, 0.1837028749786117, 0.21061377196587938, 0.30207695673565194, 0.20983287248998073, 0.1917752685935894, 0.1950809332544804, 0.25810053567793934, 0.26909470843191463, 0.17559887955268483, 0.20085609745813393, 0.23994168449099051, 0.2392181974805917, 0.1873883850440644, 0.20615542419721156, 0.2186762086085129, 0.20746193907192356, 0.2565398633124579, 0.20608038979572885, 0.19718571806162688, 0.22576843839166183, 0.18996718439805316, 0.22820901066601673, 0.21021423654578764, 0.22033526250524715, 0.6178689711080931, 0.19204793283985144, 0.6131113773397561, 0.16826047695763702, 0.15095261115098224, 0.16843976789863757, 0.19952765972288256, 0.19652383134184837, 0.09947135663209905, 0.16961417844269322, 0.16174113221296027, 0.1543738446115418, 0.21012562786184952, 0.20479203598938078, 0.20442528274287974, 0.16677589451304997, 0.20968866958176324, 0.21034600866206343, 0.3858914741355217, 0.22822716181154057, 0.18887755928625327, 0.18777430203191725, 0.19237665160544448, 0.2047558834217723, 0.20781245594318754, 0.18380936144705673, 0.20308601154859007, 0.201824062782766, 0.2092645323225637, 0.10738732127751316, 0.07828915879175946, 0.091220583301312, 0.09777070470883753, 0.1006632275328353, 0.09104026199070958, 0.08982987406339593, 0.09569973629658579, 0.08248558128251116]}, "mutation_prompt": null}
{"id": "f6e8c24b-4736-4af3-9521-f6ddc63d63ab", "solution": "import numpy as np\n\nclass MultiStrategyAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "MultiStrategyAdaptiveSwarm", "description": "Multi-Strategy Adaptive Swarm with Enhanced Mutation and Dynamic Crossover for Robust Search and Optimization Efficiency.", "configspace": "", "generation": 48, "fitness": 0.2844495813169738, "feedback": "The algorithm MultiStrategyAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.7824656250664669, 0.8229242187852728, 0.8144353984907605, 0.8088924053694231, 0.8333615603336164, 0.8227827160048221, 0.81798987206897, 0.8147286911246422, 0.7999782518768724, 0.07381014766132954, 0.04059993901430625, 0.6643052319549253, 0.6657448064083178, 0.034740749776505986, 0.223613072111979, 0.693406037372297, 0.6576638537772735, 0.6795967718963172, 0.1712608993904554, 0.14221438647648843, 0.15549478043945786, 0.11342176278164284, 0.12747356359092887, 0.11921425891376747, 0.1356036318599919, 0.1457319005537827, 0.1381408899717762, 0.11582619434100527, 0.12557812445008165, 0.12130250031969103, 0.10193720572256282, 0.09638316146285597, 0.12124614727918703, 0.10351938187590626, 0.10979394736951087, 0.13123080989000446, 0.985619691052244, 0.9751725846659155, 0.986605371167275, 0.9736712348394414, 0.9850933642409258, 0.9748275826538493, 0.985413744050068, 0.9865336157630624, 0.9820839475248891, 0.5519248656285033, 0.6160555750443458, 0.6047235260031147, 0.5936306547106167, 0.6352003896970237, 0.6139829215311647, 0.5294617252805286, 0.5663199358976178, 0.4743684922888022, 0.16445206967461035, 0.20353686281703187, 0.22236811134578516, 0.26612838442416364, 0.20976082270761143, 0.8122161965596711, 0.12289727698927055, 0.6882267846554695, 0.2352009089330418, 0.15147668680026072, 0.19372083761631909, 0.16122053668090175, 0.1796085176669081, 0.20216363374134783, 0.1705158927391851, 0.17543725134736088, 0.16551347268730987, 0.16273443874380977, 0.17692601077991954, 0.12098141016088526, 0.09524617738061703, 0.17832744269799528, 0.2163624916536827, 0.2038562402377435, 0.1975014510728641, 0.08867633617904869, 0.17139940505942508, 9.999999999998899e-05, 0.030774770876256685, 0.0051908655931202086, 0.032079208994214015, 0.00164483349076594, 0.0009306844648397927, 0.02907593146056331, 9.999999999998899e-05, 0.02555229568630657, 0.08479155310887398, 0.025811411819601227, 0.0451009431389362, 0.04371240916694774, 9.999999999998899e-05, 0.011146419021738851, 0.06621120049007856, 0.05883775547793735, 0.06229238928593528, 0.05411886642019015, 0.03648739860081063, 0.044857058403988015, 0.0986613568942647, 0.24616468968261818, 0.07670640224698522, 0.09412213814739823, 0.06791435483088659, 0.07663457099449766, 0.041628494359551405, 0.10848809057907838, 0.20628272193759667, 0.04012138025126566, 0.13067759702283033, 0.10692344089177697, 0.2306405088291812, 0.09942571050262416, 0.11270209515482943, 0.4810022982401774, 0.591299495418655, 0.5152389758036653, 0.5198386537715382, 0.5682921761657862, 0.5699644460979733, 0.5678505206506081, 0.49246932614206973, 0.507325099268175, 0.1148008957774771, 0.1107363459051206, 0.06663421322476848, 0.11464766847520191, 0.1241488840142867, 0.1652447877947334, 0.10868997231074196, 0.08399466037875014, 0.09930537648202897, 0.21899496556187892, 0.34147455912170266, 0.167930032397118, 0.25342987310556275, 0.5029852815203113, 0.1804637554756382, 0.3548969374881744, 0.1694950601714338, 0.2060780463695051, 0.31730094887310256, 0.4201368724672284, 0.3252629711719417, 0.46340957355525947, 0.2160661844818983, 0.2211658908135381, 0.2802108081664092, 0.4720889410043192, 0.20819416004536284, 0.0813455212656583, 0.3236150288871622, 0.17752033675330858, 0.2086202530163601, 0.2602553812297911, 0.2323160478172076, 0.21522508099948323, 0.2364910340775882, 0.261670721230591, 0.2075002660538504, 0.20659728247056997, 0.20576486122539972, 0.18940488762799912, 0.21037459260975677, 0.22195155191097038, 0.2106630087422614, 0.21073614169412336, 0.2084191073590489, 0.23383054414230342, 0.20200484483246806, 0.6613813905419892, 0.47040937006529726, 0.6734460380780735, 0.24253502538646787, 0.21254002778827885, 0.2351130834508598, 0.230046208210697, 0.8458790928976583, 0.12600315717226984, 0.15346500804633612, 0.8582523016765803, 0.1998961953344347, 0.11596005578898472, 0.09957104759789837, 0.1700069443647988, 0.16121984436750503, 0.08265716523400479, 0.2074140632083057, 0.43561075177423525, 0.4057115390197351, 0.16722050175222047, 0.207210434324559, 0.10444860446511539, 0.5885558748556533, 0.1761091554802653, 0.19337512880869423, 0.19276571142252374, 0.17640610237257004, 0.1931775083172722, 0.1862377755190533, 0.19288954366580457, 0.20769620890769624, 0.19297247544772722, 0.18691208240214818, 0.08782811723351946, 0.08861340613935387, 0.08581318063631282, 0.09066441646000711, 0.09376215529152054, 0.08703456628556872, 0.08197733939520424, 0.08146078817739266, 0.08591770844238467]}, "mutation_prompt": null}
{"id": "b7cb00e2-851e-4fb5-a0e6-a3bef88ee438", "solution": "import numpy as np\n\nclass AdaptiveSwarmStochasticMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + np.random.uniform(0.8, 1.2) * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight = 0.5 + 0.5 * np.random.rand()\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveSwarmStochasticMutation", "description": "Adaptive Swarm Optimization with Stochastic Mutation and Dynamic Inertia for Balanced Exploration and Exploitation.", "configspace": "", "generation": 49, "fitness": 0.18741485467665878, "feedback": "The algorithm AdaptiveSwarmStochasticMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.4618649299596064, 0.3325258527420245, 0.3426378842704677, 0.45491481557416324, 0.401531047770165, 0.41220985889983563, 0.48509152216376883, 0.45812195725982097, 0.376370626448744, 0.034683877288871234, 0.028050096626165977, 0.07843168715764548, 0.00584149759920205, 0.01741880272876606, 0.004901238609593572, 0.030569289577096592, 0.028850487864648167, 0.012561595506905943, 0.11193426186948419, 0.09406760255871172, 0.11672499262880087, 0.11028524228521963, 0.10709014269243666, 0.10474435118568604, 0.11057955966745225, 0.09991489008996302, 0.1024547993202437, 0.12580583328019934, 0.07855775290675515, 0.07138952657911724, 0.0819179191034356, 0.09319586477820663, 0.09234659609575868, 0.0928922587074652, 0.08199219865821761, 0.0881991776300054, 0.9776582301404091, 0.9768726952289359, 0.9903743280360315, 0.9862614122283894, 0.9853761360228517, 0.9846365199823683, 0.9896006577180394, 0.9775726715642348, 0.9772460786651055, 0.21128424904422605, 0.1360893373343408, 0.20673397163943408, 0.18866855852209363, 0.1730286117330283, 0.1839612269960229, 0.2221120550037391, 0.18912898078619444, 0.13715176946084762, 0.21983537677271392, 0.160347006038689, 0.21482560689097752, 0.23347982585485183, 0.2464252570767863, 0.2077488773215861, 0.2579808806418743, 0.17804006830681995, 0.21116491553838135, 0.12402149539358964, 0.14027960510519843, 0.10315184770778518, 0.12186490525634397, 0.09073987288260887, 0.08658828419066755, 0.14142964754239107, 0.11695086434846269, 0.16281423985565102, 0.10566559116105145, 0.10647238832196326, 0.11310982313097662, 0.12191517976764588, 0.09985202868547627, 0.1444498000422062, 0.10787138456351508, 0.06456749727268252, 0.10866799017878914, 0.01920235042243368, 9.999999999998899e-05, 9.999999999998899e-05, 0.020038657662494685, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06954689765486277, 0.004778507050947178, 0.07342748898121809, 0.07161061900273524, 9.999999999998899e-05, 0.010210305444317447, 0.09767145865551907, 0.047245787660304406, 0.05748776762897234, 0.005805123674567203, 0.00010714878692563712, 9.999999999998899e-05, 0.006626701175455274, 9.999999999998899e-05, 0.005051008512058752, 0.00568944070495947, 0.0041534205850588535, 9.999999999998899e-05, 0.028653220885677344, 0.03442029887398801, 0.07389211348172287, 0.08870747587860772, 0.008723068114196542, 0.01944457034648972, 0.08419087700827244, 0.05745852147567654, 0.0692763939899238, 0.3866044710376093, 0.31488935517103667, 0.4181269615192956, 0.3511816179671666, 0.3257111217604045, 0.35705993446709394, 0.3654653777489023, 0.3190892364847636, 0.377574773093055, 0.0807897146124642, 0.0830545210503627, 0.1058379948274325, 0.09304123002932296, 0.06634763488126261, 0.07683175784510676, 0.08170383959867855, 0.07138249442465605, 0.07905509268059108, 0.2079149216682562, 0.173083229384014, 0.1659886421831045, 0.24903180871684039, 0.16850748411303607, 0.1534786576076863, 0.2839873177532797, 0.1613391020554158, 0.19880267505685323, 0.23519809288150895, 0.23768813744130335, 0.23272402344133347, 0.2378445990639384, 0.23867315911179865, 0.2322290972544533, 0.296093968949926, 0.2959152022364243, 0.16040700403979846, 0.1797618756200665, 0.17774829834887018, 0.17834191977500236, 0.18308851739741816, 0.14269490474593016, 0.1533081391585136, 0.16333254665031094, 0.1445632160511786, 0.16943387729227233, 0.20157696670693537, 0.18711585739211123, 0.18632695501000662, 0.17199644905076716, 0.16564796796639003, 0.19406329967585734, 0.1910970132154971, 0.1788452178756581, 0.25196388325790553, 0.167433665080034, 0.1893460328313471, 0.17774462538871993, 0.19402698325550982, 0.1739178669601602, 0.1748779270419809, 0.1698355258663885, 0.17854101073873319, 0.18648144993762517, 0.510118690178273, 0.16721346474123255, 0.15352285562422763, 0.6367635346871663, 0.19690344636056156, 0.3517321141291825, 0.10000800838857826, 0.1681073412727404, 0.1846537611385065, 0.1519006044219905, 0.20278197549450594, 0.19892535995339589, 0.19996868070550777, 0.2796535383115376, 0.1877430202282795, 0.1043849568241012, 0.308193694011065, 0.10403486300734055, 0.1876708884638817, 0.18323324294659482, 0.18004981355137883, 0.19954743358182303, 0.19374891146463114, 0.18472470915798744, 0.18135733200552306, 0.21382146072614683, 0.1894543098655671, 0.06691071393174641, 0.08986020301972075, 0.07623254313230576, 0.08003511342926617, 0.07466636404512794, 0.07798391487191003, 0.06337643122840741, 0.06761318493606305, 0.06973887417463975]}, "mutation_prompt": null}
{"id": "40608e90-12c9-4da9-89c9-803218d221aa", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = self.particles[i].copy()\n                if np.random.rand() < self.crossover_rate:\n                    mask = np.random.rand(self.dim) < 0.5\n                    trial_vector[mask] = mutant_vector[mask]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveSwarm", "description": "Enhanced Hybrid Adaptive Swarm with Stochastic Perturbation for Improved Diversification and Convergence.", "configspace": "", "generation": 50, "fitness": 0.2692942930624152, "feedback": "The algorithm HybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.7916087262238536, 0.7930720875382636, 0.8053990963168325, 0.7792106030618702, 0.8154284122209831, 0.7916785310258322, 0.8110916898332892, 0.8174282168010617, 0.8182188973446476, 0.6882473553561126, 0.6310838473744862, 0.6875148037737895, 0.6266674451429818, 0.6876276270978982, 0.6194799936972757, 0.04105618745915762, 0.6608128613736595, 0.6735649242909459, 0.12395711550781274, 0.11896882374361228, 0.16015865967585707, 0.1236926086279263, 0.06791387668708704, 0.07135639449010456, 0.12334016864200659, 0.1097240637730742, 0.1592929469116081, 0.11035140686130618, 0.1136620570965381, 0.12322706466512612, 0.09369521003727421, 0.10854539721290035, 0.09764950380510107, 0.16067350172925976, 0.13209399954600798, 0.11103524782390373, 0.9851919640279654, 0.982172273290765, 0.9889239207830425, 0.987707027690065, 0.9861997319800896, 0.9814189036900364, 0.9904485197498767, 0.9893168798132203, 0.9844537745539789, 0.50724173318488, 0.49648068446011173, 0.5242377726223512, 0.41023299910104893, 0.5277251343449081, 0.450904684966984, 0.5509438472154569, 0.4886760270479307, 0.44462412244155114, 0.22036099970868062, 0.19074549380327877, 0.16897145135095504, 0.1905731982162524, 0.3557480726318385, 0.18629400923979367, 0.19973820072668735, 0.17331153666958565, 0.11422107824800876, 0.09711390828208244, 0.09007907957295136, 0.08934209289523865, 0.15966078023262564, 0.15561539056896867, 0.09163935493109765, 0.18134615145013078, 0.1732579632148079, 0.21390938207785182, 0.12352055729749212, 0.11429812698298647, 0.12381985792198413, 0.16866304567467305, 0.13716572142839845, 0.16910905723642333, 0.19031655096974054, 0.0985513752594277, 0.18331536331419185, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011673498673346883, 9.999999999998899e-05, 0.0689509473243386, 0.030977991478534417, 0.015299374138067479, 0.06407279609619632, 0.034874662082475694, 0.008481913784122663, 0.03532824630151843, 0.08924916094400281, 0.04201639957885295, 0.04133843493155542, 0.06064286303912558, 0.030827217684449182, 0.11947810882177579, 0.09591511971629008, 0.07321660929199192, 0.06568831246787832, 0.08594634357524411, 0.06149507404114174, 0.07927883926674317, 0.3248347247763509, 0.04020416100919155, 0.0412395600327089, 0.021531938703409415, 0.017014653221684828, 0.03461770898465788, 0.16221584768268626, 0.05051405206980142, 0.17175650004869025, 0.4953297394099553, 0.49231982490721815, 0.46561629101763036, 0.5133127206320809, 0.5051386518029638, 0.5682077561968523, 0.5466815762079111, 0.4695437116538699, 0.4925414253310191, 0.087655679393844, 0.06070219253986975, 0.06216625854823565, 0.09186277907843743, 0.1165478644929413, 0.12163334553491711, 0.07563860198679628, 0.0874699879257973, 0.12588470310502853, 0.19313463077717674, 0.12561653470322565, 0.15705289132561884, 0.2577640201935023, 0.35452035125752435, 0.15686012546313954, 0.30971832379031805, 0.26163430491306827, 0.19986941993918916, 0.22928816438262944, 0.3715108672652271, 0.3134285266940575, 0.3299271993703372, 0.23094177378456138, 0.36546770630452563, 0.30846638582926156, 0.44111148010135115, 0.20478934622300082, 0.1889055060181779, 0.30202185258511705, 0.12562238494724354, 0.1977908955743185, 0.19599084912678166, 0.20710396509780837, 0.2631914936174641, 0.2667026829936312, 0.264340093610245, 0.19508343789437899, 0.19636297386816126, 0.191437937157655, 0.1939191743411809, 0.20445496921522877, 0.19554978216354657, 0.24244683842856662, 0.21178318875207958, 0.1792714566336885, 0.607297321117215, 0.20200994061605204, 0.23173485302998498, 0.21232576187181185, 0.20966392138359002, 0.20531595804497726, 0.1937102967979396, 0.23407553775742596, 0.20458837207919955, 0.8908040463542574, 0.1675090834300652, 0.15397189309045933, 0.7902716087294629, 0.198703312162829, 0.1965391206797641, 0.14857055384446516, 0.16993695489405325, 0.1563043573103139, 0.1667722436905129, 0.20644178823141646, 0.3280209837335706, 0.20586452149361478, 0.3982579133685211, 0.5061466171632287, 0.10479365770918736, 0.2087400689590928, 0.10388269879537948, 0.1889432044393864, 0.19757905020615885, 0.18664806935374345, 0.1920928224200642, 0.20263109978143823, 0.1919811609925225, 0.19131535681425527, 0.18585175143990795, 0.19913589711512159, 0.08651852285744754, 0.09500617021450997, 0.0824821807202426, 0.08409890525864427, 0.08251455762656856, 0.0825174022841294, 0.0899066920085223, 0.08047511502158122, 0.07928924788002101]}, "mutation_prompt": null}
{"id": "147ec4dc-9c18-460e-92cd-31069944d150", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n        self.initial_temp = 1.0\n        self.temperature = self.initial_temp\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, self.temperature, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.temperature *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarm", "description": "Enhanced Hybrid Swarm with Adaptive Temperature-Based Mutation for Improved Convergence.", "configspace": "", "generation": 51, "fitness": 0.2740123502436147, "feedback": "The algorithm EnhancedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8023677754417238, 0.800017535225608, 0.8109179031518298, 0.8270896819611714, 0.8310509409555632, 0.8273311959963981, 0.8276771529678385, 0.8258623169262552, 0.8171172205063475, 0.6771107924713733, 0.037038326014553924, 0.6884102947373292, 0.6397870267099757, 0.19830234140113734, 0.6576342582139705, 9.999999999998899e-05, 0.6565773636223415, 0.6971145170623714, 0.11982822244020686, 0.13596305223056437, 0.1302518288618295, 0.16045367410786726, 0.15021286848770665, 0.13796967271004978, 0.1465747549080576, 0.12749161382644558, 0.14420583481310623, 0.12606876231790776, 0.13795453200762475, 0.1515573465143576, 0.1177194373891256, 0.14927079085013306, 0.14183389989956263, 0.11885817575569713, 0.11188656012037479, 0.1299959308551779, 0.9858981824660018, 0.974797325351738, 0.9863422825561826, 0.9784414887774898, 0.9862239088068567, 0.9746221923421963, 0.9898218678287026, 0.986530838470335, 0.98171385618051, 0.5833058243922379, 0.6004688987573864, 0.5533147203418718, 0.3116072477610641, 0.5721976463627452, 0.49716933653622897, 0.46113597921041216, 0.5303290222228985, 0.5606472129267923, 0.21840183295760596, 0.20312113691515532, 0.31702542509832976, 0.2064400749649239, 0.7394370849818801, 0.26883749510072497, 0.22158900541951476, 0.23801153278345522, 0.2485354681047104, 0.1719456692811102, 0.1723454243659155, 0.12631466715331185, 0.16235125961054853, 0.15922650902246915, 0.12035617010951061, 0.18107460846771617, 0.12610889738202546, 0.16579997785830214, 0.12298349195060199, 0.06779987608304805, 0.07448337633289814, 0.21608361152148925, 0.1425416294288847, 0.1917720618593075, 0.1801050620294251, 9.999999999998899e-05, 0.1981258689183545, 9.999999999998899e-05, 9.999999999998899e-05, 0.000887090453153383, 0.0004475319601809913, 9.999999999998899e-05, 0.060203792788378285, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04641665286482821, 0.06072136828428176, 0.04842300072577366, 0.05146158444740545, 0.0003117904825238327, 0.00815098183274443, 0.08809020515741273, 0.05140011079463569, 0.05989585900360983, 0.04273648017696852, 9.999999999998899e-05, 0.044676301476752056, 0.07049074225880958, 0.08755208085270005, 0.06767005003307058, 0.09982129015179253, 0.06560590454818738, 0.0628018799643516, 0.05528480508315681, 0.10857707465153921, 0.26840310596601125, 0.009353640906674232, 0.30489797549860065, 0.024437821038507, 0.26174979009064614, 0.12477102388569983, 0.12272492105988986, 0.5192065863462008, 0.5003530590023837, 0.5027654087349485, 0.5238543502514341, 0.5063461319540761, 0.52570755194614, 0.5144230483260992, 0.525301875265068, 0.5518953627479828, 0.08705414719745697, 0.1272732843651957, 0.10685360823535028, 0.09806985408240021, 0.1291728007915346, 0.13250365177650836, 0.08889948451038832, 0.10720820905684647, 0.09761827773585718, 0.18410690165193966, 0.16891798352389376, 0.3093002019790514, 0.2411335249377755, 0.22549887357873577, 0.166571371073424, 0.39153786280934133, 0.17677341295855453, 0.18823355817369136, 0.43004816866558526, 0.3281841478648072, 0.45446697243896095, 0.4030234906318384, 0.21679251368728292, 0.26669238712517007, 0.3925217480260067, 0.4071158655642789, 0.16945298311373969, 0.08715789444658362, 0.2978147012993553, 0.14507460517187343, 0.18823367667090996, 0.24445409241618643, 0.19040551508652326, 0.13384786371983426, 0.2593105339952618, 0.2543838030128146, 0.20554664094695163, 0.20017793645312165, 0.21800371492994575, 0.18496552089716278, 0.19273172460382215, 0.22419648057748642, 0.19474262537223763, 0.21613717336016103, 0.22057906742010436, 0.18730390385288187, 0.19052867464016265, 0.24545867229623763, 0.2030157191528117, 0.20391436985243327, 0.20016962510126335, 0.20546686264260705, 0.21701097920943035, 0.20234468903573166, 0.8686653664969638, 0.17014240943463266, 0.15436874241088794, 0.8542092992612504, 0.1992435994902204, 0.1992071394076117, 0.09970544293377148, 0.17008752722773002, 0.1571429431290955, 0.0829411715064694, 0.2063841924508395, 0.12049379146886063, 0.5893032200092718, 0.36191552633829793, 0.20686480710726896, 0.10459598885622723, 0.6378140464156283, 0.12625097593661683, 0.19333379826907726, 0.17890991712673676, 0.17516999016766843, 0.21106977563841023, 0.20005195325396297, 0.17047493646676626, 0.18785400048296086, 0.18465564604529194, 0.21327944263361864, 0.08044233423354563, 0.08636974750781734, 0.08770335782800265, 0.08350099226348595, 0.09377907530694296, 0.07976826399523385, 0.09098423387308852, 0.09092955430135075, 0.07744521015858097]}, "mutation_prompt": null}
{"id": "ec8afca1-89ea-42e0-ace4-8716fedab2ee", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def levy_flight(self, L):\n        return np.random.standard_cauchy(self.dim) * L\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        L = 1.5\n                        levy_step = self.levy_flight(L)\n                        candidate_vector = np.clip(self.particles[i] + levy_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarm", "description": "Enhanced Hybrid Adaptive Swarm incorporating Lévy Flights for improved global exploration.", "configspace": "", "generation": 52, "fitness": 0.27434883975206226, "feedback": "The algorithm EnhancedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.7973911202568927, 0.8272861530227881, 0.8238710108376127, 0.8372134005158867, 0.8164503685051561, 0.8335165845714047, 0.81877547338133, 0.8060989556097055, 0.8120354906185095, 0.6769157188393707, 9.999999999998899e-05, 0.6121264915666421, 0.6817455049627268, 0.0428323100016198, 0.04877307582786217, 0.6703184473366279, 0.0529604984121117, 0.048003164615421756, 0.14485822057287645, 0.1356658652865872, 0.13879595304527115, 0.13322266341252365, 0.0742070659569738, 0.15158179766386615, 0.312368078795737, 0.15803718197352046, 0.15925627345844262, 0.11112628146401948, 0.10579561499697432, 0.13433930882894163, 0.10508327784322191, 0.11423973004700128, 0.1498452245381373, 0.16564618124510289, 0.11169938390319534, 0.14143880666331587, 0.9896885395465073, 0.9696572717157511, 0.9901897556865249, 0.9905083025237023, 0.9895341496696002, 0.9783456728762173, 0.9854240063823697, 0.9865225725263602, 0.9864470048151934, 0.3858589932692129, 0.6090961439896576, 0.545985034536597, 0.47600703288972246, 0.5708192195715815, 0.37048099464791207, 0.489276779303634, 0.5992924372802473, 0.5518132875953761, 0.16728417239803528, 0.21872298050103622, 0.21866092604434084, 0.2697926243938785, 0.1900901547470315, 0.18773990069461888, 0.23086814985294424, 0.19174612400348467, 0.3100692316148983, 0.103417213691124, 0.18657386234690887, 0.15783573450170296, 0.15452554337269853, 0.16565488852771904, 0.12309097918706124, 0.19171641083276236, 0.15195418808159533, 0.22089109672859097, 0.12057438125706799, 0.053434073918638414, 0.17978745679374075, 0.17549827410801644, 0.13972161366321523, 0.13277217847686829, 0.1920785795505353, 0.035772290300064236, 0.1422337754291002, 9.999999999998899e-05, 0.06454807849064093, 9.999999999998899e-05, 0.026987728636338915, 9.999999999998899e-05, 0.0066392903117246105, 0.007519500963948711, 9.999999999998899e-05, 0.09119639529703671, 0.0661926893012138, 0.04487092174645968, 0.05552407958061689, 0.022586250615969194, 9.999999999998899e-05, 0.03285040684714258, 0.09806520611605796, 0.07214738418903288, 0.03860067778465348, 0.04603573195683819, 0.03826667949867646, 0.0428518594888454, 0.0708358664488562, 0.07295951346649576, 0.11717773487576943, 0.08952034291739619, 0.06544002957329853, 0.07356356232646999, 0.21296872436885506, 0.1563888418941859, 0.14373543322142468, 0.023545551973291334, 0.06556949086065778, 0.008578145241821988, 0.08108407479176605, 0.09758862153037284, 0.078230549701925, 0.5516219237266675, 0.47823255610519333, 0.49837202934191693, 0.5172478096645625, 0.5227547648169268, 0.5645204263120265, 0.5365191065969015, 0.5787439986911092, 0.531568335553249, 0.11552052042808736, 0.14850689805896566, 0.11150983772505241, 0.11786621678597653, 0.07594680432968848, 0.10954999193950443, 0.1165549164746531, 0.10665140981665522, 0.09059301998081504, 0.2618910221055897, 0.1494901374822435, 0.24884686123004984, 0.3163430017997667, 0.27558307978056595, 0.24525071713088176, 0.1458438202517447, 0.1796421199194922, 0.23690165576125044, 0.3643742447927327, 0.3221716492560659, 0.30791263276711156, 0.37470616283787783, 0.22158959978033188, 0.35330382802227567, 0.2196928455424778, 0.5335050415122403, 0.4395886740158683, 0.08600159351929992, 0.20477535090224086, 0.178484893462175, 0.29405170410072, 0.14520631820965224, 0.23330723746122972, 0.2230738094510324, 0.25477084023263574, 0.22380129360096457, 0.20423808423036127, 0.2547199871145176, 0.2072869750913332, 0.19981438057800205, 0.20814058647133704, 0.20433429427811634, 0.21686489240595574, 0.21997987544479214, 0.194806169845833, 0.19286939010123383, 0.21139875570438016, 0.18148197438373304, 0.17680499905682023, 0.5630230853137452, 0.19414367588251957, 0.19270534096395886, 0.725026253804294, 0.22785824292101875, 0.8225821213629859, 0.164824531646257, 0.15156718958966853, 0.8557257693573235, 0.530911676185265, 0.15630831415293855, 0.16098193548198292, 0.16893482726257536, 0.16127746795225062, 0.1530255753812647, 0.20422041554034476, 0.20541930406006648, 0.5579109241080047, 0.16641740953773065, 0.20875000946817812, 0.2076698928235875, 0.7976373091170336, 0.7226373142515028, 0.17906778790055378, 0.1837616587762816, 0.19326163669533247, 0.2061888460731549, 0.19047668783773486, 0.193303829109159, 0.1762232082402233, 0.18493151844922895, 0.20141898312341733, 0.09800119890213099, 0.09034737081719035, 0.09166379406538039, 0.08880652056136518, 0.09538956227764062, 0.08680388099790437, 0.09761022598492419, 0.08981401565379732, 0.08394496239364013]}, "mutation_prompt": null}
{"id": "a3463656-2a60-4632-9ad7-8ef8da73401f", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveSwarm", "description": "Hybrid Adaptive Swarm with Differential Mutation and Dynamic Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.7824656250664669, 0.8229242187852728, 0.8144353984907605, 0.8088924053694231, 0.8333615603336164, 0.8227827160048221, 0.81798987206897, 0.8147286911246422, 0.7999782518768724, 0.07381014766132954, 0.04059993901430625, 0.6643052319549253, 0.6657448064083178, 0.034740749776505986, 0.223613072111979, 0.693406037372297, 0.6576638537772735, 0.6795967718963172, 0.1712608993904554, 0.14221438647648843, 0.15549478043945786, 0.11342176278164284, 0.12747356359092887, 0.11921425891376747, 0.1356036318599919, 0.1457319005537827, 0.1381408899717762, 0.11582619434100527, 0.12557812445008165, 0.12130250031969103, 0.10193720572256282, 0.09638316146285597, 0.12124614727918703, 0.10351938187590626, 0.10979394736951087, 0.13123080989000446, 0.985619691052244, 0.9751725846659155, 0.986605371167275, 0.9736712348394414, 0.9850933642409258, 0.9748275826538493, 0.985413744050068, 0.9865336157630624, 0.9820839475248891, 0.5519248656285033, 0.6160555750443458, 0.6047235260031147, 0.5936306547106167, 0.6352003896970237, 0.6139829215311647, 0.5294617252805286, 0.5663199358976178, 0.4743684922888022, 0.16445206967461035, 0.20353686281703187, 0.22236811134578516, 0.26612838442416364, 0.20976082270761143, 0.8122161965596711, 0.12289727698927055, 0.6882267846554695, 0.2352009089330418, 0.15147668680026072, 0.19372083761631909, 0.16122053668090175, 0.1796085176669081, 0.20216363374134783, 0.1705158927391851, 0.17543725134736088, 0.16551347268730987, 0.16273443874380977, 0.17692601077991954, 0.12098141016088526, 0.09524617738061703, 0.17832744269799528, 0.2163624916536827, 0.2038562402377435, 0.1975014510728641, 0.08867633617904869, 0.17139940505942508, 9.999999999998899e-05, 0.030774770876256685, 0.0051908655931202086, 0.032079208994214015, 0.00164483349076594, 0.0009306844648397927, 0.02907593146056331, 9.999999999998899e-05, 0.02555229568630657, 0.08479155310887398, 0.025811411819601227, 0.0451009431389362, 0.04371240916694774, 9.999999999998899e-05, 0.011146419021738851, 0.06621120049007856, 0.05883775547793735, 0.06229238928593528, 0.05411886642019015, 0.03648739860081063, 0.044857058403988015, 0.0986613568942647, 0.24616468968261818, 0.07670640224698522, 0.09412213814739823, 0.06791435483088659, 0.07663457099449766, 0.041628494359551405, 0.10848809057907838, 0.20628272193759667, 0.04012138025126566, 0.13067759702283033, 0.10692344089177697, 0.2306405088291812, 0.09942571050262416, 0.11270209515482943, 0.4810022982401774, 0.591299495418655, 0.5152389758036653, 0.5198386537715382, 0.5682921761657862, 0.5699644460979733, 0.5678505206506081, 0.49246932614206973, 0.507325099268175, 0.1148008957774771, 0.1107363459051206, 0.06663421322476848, 0.11464766847520191, 0.1241488840142867, 0.1652447877947334, 0.10868997231074196, 0.08399466037875014, 0.09930537648202897, 0.21899496556187892, 0.34147455912170266, 0.167930032397118, 0.25342987310556275, 0.5029852815203113, 0.1804637554756382, 0.3548969374881744, 0.1694950601714338, 0.2060780463695051, 0.31730094887310256, 0.4201368724672284, 0.3252629711719417, 0.46340957355525947, 0.2160661844818983, 0.2211658908135381, 0.2802108081664092, 0.4720889410043192, 0.20819416004536284, 0.0813455212656583, 0.3236150288871622, 0.17752033675330858, 0.2086202530163601, 0.2602553812297911, 0.2323160478172076, 0.21522508099948323, 0.2364910340775882, 0.261670721230591, 0.2075002660538504, 0.20659728247056997, 0.20576486122539972, 0.18940488762799912, 0.21037459260975677, 0.22195155191097038, 0.2106630087422614, 0.21073614169412336, 0.2084191073590489, 0.23383054414230342, 0.20200484483246806, 0.6613813905419892, 0.47040937006529726, 0.6734460380780735, 0.24253502538646787, 0.21254002778827885, 0.2351130834508598, 0.230046208210697, 0.8458790928976583, 0.12600315717226984, 0.15346500804633612, 0.8582523016765803, 0.1998961953344347, 0.11596005578898472, 0.09957104759789837, 0.1700069443647988, 0.16121984436750503, 0.08265716523400479, 0.2074140632083057, 0.43561075177423525, 0.4057115390197351, 0.16722050175222047, 0.207210434324559, 0.10444860446511539, 0.5885558748556533, 0.1761091554802653, 0.19337512880869423, 0.19276571142252374, 0.17640610237257004, 0.1931775083172722, 0.1862377755190533, 0.19288954366580457, 0.20769620890769624, 0.19297247544772722, 0.18691208240214818, 0.08782811723351946, 0.08861340613935387, 0.08581318063631282, 0.09066441646000711, 0.09376215529152054, 0.08703456628556872, 0.08197733939520424, 0.08146078817739266, 0.08591770844238467]}, "mutation_prompt": null}
{"id": "28d36c64-1984-4fa9-9be4-ee44dbd1fcf8", "solution": "import numpy as np\nimport cmath\n\nclass QuantumInspiredAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            # Quantum-inspired update\n            for i in range(self.population_size):\n                amplitude = np.abs(cmath.exp(complex(0, np.pi * np.random.rand())))\n                phase_shift = (self.personal_best_positions[i] + self.global_best_position) * amplitude\n                phase_shift = np.clip(phase_shift, self.lower_bound, self.upper_bound)\n                score = func(phase_shift)\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = phase_shift\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = phase_shift\n\n                if evaluations >= self.max_evaluations:\n                    break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredAdaptiveSwarm", "description": "Quantum-Inspired Adaptive Swarm integrating quantum superposition states to enhance exploration and exploitation balance.", "configspace": "", "generation": 54, "fitness": 0.23965123472160796, "feedback": "The algorithm QuantumInspiredAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.7011252174466168, 0.7296530852993892, 0.705374428497058, 0.7220174245910307, 0.7462491194962236, 0.7515207514258302, 0.7225830750483355, 0.7332876327002036, 0.7549269037547417, 0.557444371842053, 0.0352873029069648, 0.0341853814349834, 9.999999999998899e-05, 0.03011285995702151, 9.999999999998899e-05, 0.5362783383869144, 0.015321184665094356, 0.511290018190861, 0.07038133250596079, 0.12658573051366462, 0.11073776741223995, 0.13752267270319973, 0.07059214729399077, 0.11596160617004081, 0.15344226306804698, 0.06554472627570118, 0.1633664623944895, 0.1543426014481324, 0.12100492609305513, 0.0967803242720996, 0.09245190603193931, 0.0451446847082243, 0.13870403273155585, 0.13386709112784356, 0.1218237842126646, 0.0993082641872659, 0.9948183967845243, 0.8756212824307712, 0.9946938832763713, 0.9384934253264712, 0.9844106497641432, 0.9789127440200305, 0.9910706418497585, 0.9914108465607249, 0.9950300556774065, 0.4090786434317192, 0.38757458093763775, 0.3764172055509448, 0.42552931742693323, 0.41582551308838955, 0.4264010034513027, 0.39235834943685255, 0.3320949201768084, 0.352502211766753, 0.21914268814864135, 0.6369674600755539, 0.1625836490371606, 0.20479524848194697, 0.200492797090995, 0.20588939750838253, 0.1348645412906181, 0.2243965141336557, 0.14891310889755205, 0.1456805531522175, 0.1622966089967497, 0.12080600601975089, 0.11620935123969411, 0.1717404324428078, 0.1665018316669542, 0.3705232496386558, 0.16078741304908295, 0.16382180924371914, 0.17341624889645935, 9.999999999998899e-05, 0.11248002871186635, 0.11342919640107196, 0.15300759749415171, 0.14088437424481604, 0.1492813922070303, 0.0874617042553496, 0.18218217348562582, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022943797527013476, 9.999999999998899e-05, 9.999999999998899e-05, 0.006566591044446568, 9.999999999998899e-05, 9.999999999998899e-05, 0.07667125135920327, 0.019538074142889106, 0.07732494051145855, 0.03660902790902343, 9.999999999998899e-05, 0.00478730061478605, 0.07164967130544841, 0.045027298962792894, 0.048390410930162386, 0.041691435504636276, 0.02506429660202647, 0.028980191272558686, 0.06898474117319042, 0.061581600946263304, 0.07606251728251157, 0.09132864785088846, 0.10202241227108677, 0.048420721876910156, 0.09481307419368346, 0.04023720784526719, 0.17592711626604418, 0.010522289265193052, 0.0631887436605697, 0.0056236605853328125, 0.07600734712740453, 0.05151669153426541, 0.08999187311011514, 0.4964108219927922, 0.42948930156595944, 0.42699538918062585, 0.47883835829432697, 0.459616836620086, 0.5096756736171162, 0.5001039301974681, 0.4447365998077013, 0.45826299092404266, 0.0668002892614229, 0.07117359788735333, 0.061290548955598934, 0.09719643030743408, 0.10039919293509525, 0.09936393711750391, 0.07769881406610002, 0.10290434317972263, 0.10268832030187403, 0.1822155054935075, 0.17524037698768624, 0.17893995746270253, 0.23805683647744968, 0.22944029608743854, 0.14246792574857936, 0.2534751502175798, 0.17774440389078117, 0.2655852688129038, 0.40508707126690047, 0.27088184252749026, 0.28967657518966816, 0.3346003024412759, 0.21098203167211782, 0.3556524403898813, 0.33727630084589255, 0.4172767392286518, 0.212083819382345, 0.07701355025407608, 0.20355281917360635, 0.23405116848424512, 0.18380808491006828, 0.20268026784735382, 0.14077275549450696, 0.258311803477428, 0.3096451943168326, 0.26747527047570663, 0.20645947160326938, 0.21613530137733594, 0.19787016699830706, 0.19844723798305808, 0.16373550951376015, 0.20220359656177989, 0.1733690659353011, 0.2102760409668194, 0.17574083062690538, 0.19119383292334913, 0.1847652175908222, 0.19721156705353438, 0.2310642251000723, 0.19590815128562822, 0.18641109268879108, 0.4868325248386963, 0.20634418431795398, 0.20126859669622887, 0.7582386209680148, 0.1682134486535679, 0.1538855393777001, 0.7606449591168044, 0.19915121558910653, 0.14525521340125547, 0.09894227600625272, 0.16951418138769092, 0.15921803415911162, 0.1530589266752057, 0.2031230444612171, 0.5083012172225498, 0.39195355716133984, 0.1664986202500457, 0.20771611921251198, 0.10415787254433417, 0.47712029688395063, 0.21134009039032686, 0.19437846071617992, 0.19265637229855004, 0.1997095126399494, 0.21196630893611446, 0.20398703677288954, 0.1810635727897757, 0.17524776112845597, 0.1762483236920538, 0.1708592889643885, 0.0730325946206829, 0.08217655051370476, 0.07399295963084729, 0.0818509031103406, 0.08089476648310734, 0.07334563559730667, 0.06765210101951247, 0.08828641123312153, 0.08051775919217907]}, "mutation_prompt": null}
{"id": "21c25f9b-b7a6-4e9b-b423-3975042f28a2", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.6\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        c1 = self.c1_initial + (evaluations / self.max_evaluations) * (2.0 - self.c1_initial)\n        c2 = self.c2_initial + (evaluations / self.max_evaluations) * (2.0 - self.c2_initial)\n        \n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarm", "description": "Enhanced Hybrid Swarm Algorithm with Adaptive Parameters and Stochastic Search for Improved Exploration and Exploitation.", "configspace": "", "generation": 55, "fitness": 0.24701178498349505, "feedback": "The algorithm EnhancedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8007797116469586, 0.9028436469397455, 0.830293654387803, 0.9163737271228738, 0.9102619102366442, 0.9141934262125287, 0.8926255546730222, 0.9149708639387022, 0.6730654986476272, 0.2181337522319985, 0.047078322730739086, 9.999999999998899e-05, 0.2688308406102339, 0.04851420529297723, 0.12927794178498808, 0.020770939267496624, 0.2034899735664809, 9.999999999998899e-05, 0.15128658190273103, 0.18316984953568183, 0.1453087125616912, 0.11673533089572796, 0.07259731078854859, 0.11808784208214296, 0.12116237558724274, 0.10816293219934836, 0.1575961961338015, 0.10758391938052447, 0.11264687678691698, 0.10159647253087567, 0.09614721887530808, 0.10822679278846459, 0.11395681621194731, 0.06158018436540991, 0.0838293094413115, 0.05807681720199076, 0.977970909714291, 0.9703048329512721, 0.9822221315829132, 0.9848028558628446, 0.9790320919729038, 0.9696197812957184, 0.9855984070424977, 0.9813435272050278, 0.9806841548242256, 0.4472975736106628, 0.3050203068921997, 0.4830210403128349, 0.3515216859031962, 0.3944249153551733, 0.3177386106601543, 0.41361611515805163, 0.33930111343123237, 0.15629868367154887, 0.3400228431062121, 0.1362341773337271, 0.3877864957434074, 0.1943032091645901, 0.15913728502973878, 0.21553901589788083, 0.12705674171823123, 0.23522843349009537, 0.32138876833904073, 0.14858540417918287, 0.1321336063054167, 0.1313777305031366, 0.14522838816941308, 0.16835671054124213, 0.1440043782783592, 0.14187316329000987, 0.13929856747610325, 0.16272893912201747, 0.15639012927563112, 9.999999999998899e-05, 0.1314343978979261, 0.1480690458146322, 0.1278357540545776, 0.1270701003226894, 0.15149678962559432, 0.09892416069558918, 0.12327810926561356, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004498753201606975, 9.999999999998899e-05, 0.03209865587492966, 0.07187033664733988, 0.02755680671070515, 0.08173121715014309, 0.10645534518253574, 0.005043801926654323, 9.999999999998899e-05, 0.1994092601739389, 0.06439582520388976, 0.04137221667953361, 0.22950000089396794, 0.05345514248841843, 0.15820700784301478, 0.09176205337818755, 0.09835758287463159, 0.08813680321712603, 0.13185807431931296, 0.07396243703557026, 0.07516068628357075, 0.16272013591339451, 0.10069350528226628, 0.19648227106125116, 0.02677668225996055, 0.010484123656236854, 0.006665737387670512, 0.17171970798733438, 0.05762518071282574, 0.0852236257477238, 0.4972081962302808, 0.5206891257026751, 0.499915347806722, 0.5019942721948283, 0.44129634471689905, 0.409699368055811, 0.5249344986029792, 0.5125837189637765, 0.49247792365441456, 0.07876245858279451, 0.10968401055116395, 0.07812764712853182, 0.11592066665975942, 0.055937221112717816, 0.09173643117223584, 0.13586946662379018, 0.11094083304237812, 0.1303952301653739, 0.25208850341353084, 0.16908682688562549, 0.1613454205456052, 0.364758306929135, 0.2970794826272962, 0.3084577088813987, 0.3263120708913364, 0.15906985505207616, 0.20732455761749213, 0.3247617572084168, 0.2930008404660802, 0.42207468709959783, 0.30224222558754077, 0.3218213014400835, 0.2679226399531458, 0.22861693800173855, 0.4375800040853479, 0.18234149216698037, 0.32155990687564484, 0.20684683568605933, 0.17008488306255398, 0.22645797974370285, 0.21442086194003296, 0.1740002737295766, 0.2271573927478303, 0.2941139889000274, 0.09940166830267694, 0.23106955209193714, 0.1811653871686021, 0.1917936817011362, 0.26313347148298627, 0.22736454499461844, 0.235638546809243, 0.19620114301842495, 0.2302338144464796, 0.1891358294661004, 0.20961951153759661, 0.1953420759357387, 0.18634541393394954, 0.19954612824519624, 0.19898997116494388, 0.19719507748820952, 0.20659703588225886, 0.19951420027475875, 0.20768952073355207, 0.7741008005105015, 0.12609252139272598, 0.15418056585136253, 0.931036668653434, 0.2011314094816825, 0.19970896969119345, 0.12261899636450346, 0.1696932661359739, 0.15277868063111089, 0.15414955278211606, 0.20852002091780542, 0.07312503441064488, 0.4082219253420448, 0.16766455750317177, 0.21145159500331778, 0.10491613804123079, 0.4958857878495677, 0.39372320130447214, 0.17632067270812646, 0.1881284418157403, 0.19300659629681483, 0.19430707236203282, 0.2115746144588384, 0.20216569950639152, 0.18966385187474355, 0.19661650345746629, 0.21131746713341648, 0.09830875209748446, 0.10051573199463526, 0.10221588636125256, 0.0979188279044807, 0.10549478932938294, 0.10094643529670755, 0.09382029084629817, 0.06850617618687682, 0.08186241001294525]}, "mutation_prompt": null}
{"id": "f00f6854-b111-46f8-8f3d-121d84630657", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.75\n        self.c1 = 2.05\n        self.c2 = 2.05\n        self.inertia_weight = 0.6\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n        self.search_space_shrink = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                crossover_decision = np.random.rand(self.dim) < self.crossover_rate\n                trial_vector[crossover_decision] = mutant_vector[crossover_decision]\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.05, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.lower_bound *= self.search_space_shrink\n            self.upper_bound *= self.search_space_shrink\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarm", "description": "Enhanced Hybrid Swarm Algorithm with Adaptive Mutation and Dynamic Search Space Adjustment for Improved Global Convergence in Multi-Dimensional Optimizations.", "configspace": "", "generation": 56, "fitness": 0.17683558153142048, "feedback": "The algorithm EnhancedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.14.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8025514396669644, 0.7806481631252887, 0.8559883191984917, 0.3889804225311999, 0.39122508871703, 0.4457272331689155, 0.413780044529235, 0.40194011417895403, 0.4419656451242566, 0.05486862606427767, 0.0566311217251525, 0.14457298148063857, 0.12161703741008278, 0.37232821432284413, 0.09724644873837662, 0.14377948795773976, 0.07339789774266958, 0.1335008869549993, 0.16353722153259564, 0.12311025727961133, 0.1623192784798081, 0.11174619159906507, 0.12141952548746793, 0.0975985878232517, 0.10988019479295941, 0.11144963311433509, 0.09261377308634833, 0.10994874625983408, 0.10646017124298779, 0.08993215887372952, 0.11243175124041915, 0.09690604381827983, 0.08985889134740987, 0.11001348516626552, 0.12778762942715094, 0.09230005861102941, 0.18507698242990445, 0.1362731902457328, 0.1644297228073316, 0.0921595428098757, 0.16596800567000103, 0.15889852085757739, 0.16621619676709432, 0.19588733414846415, 0.16610378229252787, 0.21990067700635785, 0.21078627154999463, 0.2160755974259203, 0.20865616305894819, 0.18749645396757164, 0.20803857462219766, 0.2277273697778206, 0.21643712002222903, 0.07389576965341771, 0.3730619119625771, 0.2101917818341681, 0.20335545318096815, 0.16692315455404771, 0.30914514195695, 0.11634833555501556, 0.16426122125632048, 0.212131215374202, 0.2046509107383474, 0.15213537615931272, 0.10589177797444449, 0.15087809899764992, 0.15473881555763624, 0.1489697854786084, 0.1453100406285417, 0.17477697320418084, 0.18805147103135456, 0.1528781388459738, 0.15302540507572993, 0.019752086092621135, 0.13126709201971476, 0.1415466181938122, 0.1272576410377777, 0.17510745618849233, 0.12326565637366327, 0.059934405524866285, 0.1381152303998806, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09183969077429988, 0.06003644000161945, 0.09428492342434258, 0.13573068732459526, 0.022073212619858396, 0.014032733454717339, 0.09378996085146518, 0.030734386946481784, 0.07414329217757676, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08470246888072941, 0.04833629724015642, 0.1279385118196551, 0.06840701936469173, 0.048715260681043815, 9.999999999998899e-05, 0.05448938073985532, 0.050168034530745365, 0.04237738162225635, 0.5144422752586877, 0.5009082225090141, 0.49392912567575453, 0.42316414825146365, 0.391449497611983, 0.35666140382938705, 0.5081776480825526, 0.4157957742461964, 0.5442836137199993, 0.0939257744062525, 0.1134744827822336, 0.08470871541297365, 0.08335360392177804, 0.0816464481644833, 0.08806222875982117, 0.08394419006121812, 0.09573731320814716, 0.11571522655223432, 0.150694419918033, 0.14683662978481116, 0.1908543704089184, 0.1586260357217627, 0.153697676586403, 0.13207485176754785, 0.15093253782810134, 0.14802204100388028, 0.2114814036282341, 0.30525489841850695, 0.27225826852597135, 0.25600177216678743, 0.3688575706451548, 0.18013533059783315, 0.45554315641399246, 0.2904143123192626, 0.2645621982335046, 0.2880846883526944, 0.0728662348138912, 0.2375785166073342, 0.23037069028737955, 0.16769991990782196, 0.2394349145151835, 0.2228418957865579, 0.11751300685495425, 0.24065579169948237, 0.19679530853520566, 0.21240062147445338, 0.19921411268424338, 0.20182739742350808, 0.19498982105734974, 0.1990749430381069, 0.22584542520461726, 0.1953805195732401, 0.21347726607821405, 0.2366467629395983, 0.19338937486184316, 0.19380792308192918, 0.22417955081206242, 0.19288574076691933, 0.19220535328848287, 0.24038804268197345, 0.21880683881931162, 0.2168751965851632, 0.17558392281774993, 0.6002760402450221, 0.11387628575885356, 0.12934826194854576, 0.7525018503024316, 0.19682682908208704, 0.1676619666168444, 0.10540534875756546, 0.1811205297305467, 0.15978245373444533, 0.15241625958163862, 0.30044356865559363, 0.29687792365137944, 0.20792407922791423, 0.16761527031696222, 0.20872632506099464, 0.11607101479541948, 0.31809017234438686, 0.10029494406048745, 0.18639747034073584, 0.1724406170108459, 0.21324559374913, 0.18804758349168071, 0.1713640928006016, 0.18000291829152792, 0.1961539704596329, 0.18917339520640786, 0.18753969521095226, 0.07952741569476385, 0.08692059062422974, 0.09996791729321464, 0.09376476476717999, 0.08598018882118263, 0.07883481909730039, 0.08150455505541376, 0.0759614411520273, 0.09119158629314583]}, "mutation_prompt": null}
{"id": "c98db887-f7b1-4ecf-89c6-387ec695e3af", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveSwarm", "description": "Hybrid Adaptive Swarm with Differential Mutation and Dynamic Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 47, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.7824656250664669, 0.8229242187852728, 0.8144353984907605, 0.8088924053694231, 0.8333615603336164, 0.8227827160048221, 0.81798987206897, 0.8147286911246422, 0.7999782518768724, 0.07381014766132954, 0.04059993901430625, 0.6643052319549253, 0.6657448064083178, 0.034740749776505986, 0.223613072111979, 0.693406037372297, 0.6576638537772735, 0.6795967718963172, 0.1712608993904554, 0.14221438647648843, 0.15549478043945786, 0.11342176278164284, 0.12747356359092887, 0.11921425891376747, 0.1356036318599919, 0.1457319005537827, 0.1381408899717762, 0.11582619434100527, 0.12557812445008165, 0.12130250031969103, 0.10193720572256282, 0.09638316146285597, 0.12124614727918703, 0.10351938187590626, 0.10979394736951087, 0.13123080989000446, 0.985619691052244, 0.9751725846659155, 0.986605371167275, 0.9736712348394414, 0.9850933642409258, 0.9748275826538493, 0.985413744050068, 0.9865336157630624, 0.9820839475248891, 0.5519248656285033, 0.6160555750443458, 0.6047235260031147, 0.5936306547106167, 0.6352003896970237, 0.6139829215311647, 0.5294617252805286, 0.5663199358976178, 0.4743684922888022, 0.16445206967461035, 0.20353686281703187, 0.22236811134578516, 0.26612838442416364, 0.20976082270761143, 0.8122161965596711, 0.12289727698927055, 0.6882267846554695, 0.2352009089330418, 0.15147668680026072, 0.19372083761631909, 0.16122053668090175, 0.1796085176669081, 0.20216363374134783, 0.1705158927391851, 0.17543725134736088, 0.16551347268730987, 0.16273443874380977, 0.17692601077991954, 0.12098141016088526, 0.09524617738061703, 0.17832744269799528, 0.2163624916536827, 0.2038562402377435, 0.1975014510728641, 0.08867633617904869, 0.17139940505942508, 9.999999999998899e-05, 0.030774770876256685, 0.0051908655931202086, 0.032079208994214015, 0.00164483349076594, 0.0009306844648397927, 0.02907593146056331, 9.999999999998899e-05, 0.02555229568630657, 0.08479155310887398, 0.025811411819601227, 0.0451009431389362, 0.04371240916694774, 9.999999999998899e-05, 0.011146419021738851, 0.06621120049007856, 0.05883775547793735, 0.06229238928593528, 0.05411886642019015, 0.03648739860081063, 0.044857058403988015, 0.0986613568942647, 0.24616468968261818, 0.07670640224698522, 0.09412213814739823, 0.06791435483088659, 0.07663457099449766, 0.041628494359551405, 0.10848809057907838, 0.20628272193759667, 0.04012138025126566, 0.13067759702283033, 0.10692344089177697, 0.2306405088291812, 0.09942571050262416, 0.11270209515482943, 0.4810022982401774, 0.591299495418655, 0.5152389758036653, 0.5198386537715382, 0.5682921761657862, 0.5699644460979733, 0.5678505206506081, 0.49246932614206973, 0.507325099268175, 0.1148008957774771, 0.1107363459051206, 0.06663421322476848, 0.11464766847520191, 0.1241488840142867, 0.1652447877947334, 0.10868997231074196, 0.08399466037875014, 0.09930537648202897, 0.21899496556187892, 0.34147455912170266, 0.167930032397118, 0.25342987310556275, 0.5029852815203113, 0.1804637554756382, 0.3548969374881744, 0.1694950601714338, 0.2060780463695051, 0.31730094887310256, 0.4201368724672284, 0.3252629711719417, 0.46340957355525947, 0.2160661844818983, 0.2211658908135381, 0.2802108081664092, 0.4720889410043192, 0.20819416004536284, 0.0813455212656583, 0.3236150288871622, 0.17752033675330858, 0.2086202530163601, 0.2602553812297911, 0.2323160478172076, 0.21522508099948323, 0.2364910340775882, 0.261670721230591, 0.2075002660538504, 0.20659728247056997, 0.20576486122539972, 0.18940488762799912, 0.21037459260975677, 0.22195155191097038, 0.2106630087422614, 0.21073614169412336, 0.2084191073590489, 0.23383054414230342, 0.20200484483246806, 0.6613813905419892, 0.47040937006529726, 0.6734460380780735, 0.24253502538646787, 0.21254002778827885, 0.2351130834508598, 0.230046208210697, 0.8458790928976583, 0.12600315717226984, 0.15346500804633612, 0.8582523016765803, 0.1998961953344347, 0.11596005578898472, 0.09957104759789837, 0.1700069443647988, 0.16121984436750503, 0.08265716523400479, 0.2074140632083057, 0.43561075177423525, 0.4057115390197351, 0.16722050175222047, 0.207210434324559, 0.10444860446511539, 0.5885558748556533, 0.1761091554802653, 0.19337512880869423, 0.19276571142252374, 0.17640610237257004, 0.1931775083172722, 0.1862377755190533, 0.19288954366580457, 0.20769620890769624, 0.19297247544772722, 0.18691208240214818, 0.08782811723351946, 0.08861340613935387, 0.08581318063631282, 0.09066441646000711, 0.09376215529152054, 0.08703456628556872, 0.08197733939520424, 0.08146078817739266, 0.08591770844238467]}, "mutation_prompt": null}
{"id": "f7274274-655f-4d03-87bb-1976a096bbae", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Slight adjustment to improve diversity\n        self.crossover_rate = 0.75  # Enhanced crossover probability\n        self.c1 = 1.5  # Adjusted cognitive coefficient\n        self.c2 = 2.5  # Adjusted social coefficient\n        self.inertia_weight = 0.6  # Adjusted for better balance\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98  # Modified cooling factor for controlled convergence\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Increased local search probability for better exploration\n                        random_step = np.random.normal(0, 0.15, self.dim)  # Adjusted local search step size\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedSwarmOptimizer", "description": "Enhanced Swarm Optimization with Adaptive Learning and Dynamic Local Search for Improved Convergence.", "configspace": "", "generation": 58, "fitness": 0.28008817621333537, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8659022078432268, 0.8652712918547246, 0.8320525901889739, 0.8485010205857012, 0.8654061079183244, 0.8486917308172156, 0.8659268406586452, 0.8470129550121992, 0.8537548799441548, 0.7620169489528033, 0.7278093959864173, 0.7321102164857437, 0.7335846388956204, 0.17191160981274456, 0.344170641004211, 0.23028793120255509, 0.05789618206804803, 0.7487666372682684, 0.1757189632886892, 0.17828378832491398, 0.11983162372455514, 0.13866228948929782, 0.1383733543651533, 0.07236768301551588, 0.1635435210522148, 0.06607312264383036, 0.16614131012153943, 0.11551993279167505, 0.16161175120966165, 0.15246394517820117, 0.1372707289896753, 0.09186991474201367, 0.11141441346679404, 0.13118632145743447, 0.14373952883035168, 0.13132437887191828, 0.9856772969425919, 0.902743572577488, 0.9900065559820234, 0.9816299066710337, 0.9864295758907505, 0.9820782546253215, 0.9888889570470732, 0.9855400287751608, 0.9861490102082769, 0.5635022817374444, 0.5610572922236585, 0.5550065960261866, 0.50652502093654, 0.5039116521200662, 0.5748516809207773, 0.5607676176979454, 0.5025276571007636, 0.49826709172181294, 0.17075810398979463, 0.1372715921373081, 0.2255160253340015, 0.26961850619027394, 0.2761514970234028, 0.19012656393937988, 0.16552000529179878, 0.23557949988151072, 0.1649086452618741, 0.1211988393125315, 0.1511701440190626, 0.1807146647079444, 0.12658026922332066, 0.1803944230561454, 0.22996243721239806, 0.1975221033896396, 0.16491698824267564, 0.11653499024582803, 0.14945963427566644, 9.999999999998899e-05, 9.999999999998899e-05, 0.127043909946022, 0.10546159685607526, 0.16035674513409526, 0.1746987919200872, 9.999999999998899e-05, 0.16080236778424806, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.031071032425871947, 9.999999999998899e-05, 0.020171855264121796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09299550341006291, 0.03551381182467772, 0.060134487667966474, 0.1350879354902872, 9.999999999998899e-05, 0.01973681752888201, 0.10056311884525582, 0.09105889258251554, 0.010049241098198713, 0.03812006373313703, 0.03417864973970841, 0.1787674492948148, 0.08078422379251993, 0.08802183706252287, 0.11192673495405647, 0.0962645699970397, 0.07605500674343202, 0.08295508490572634, 0.052572578314430074, 0.04247421456053069, 0.08268502198143124, 0.024085287670562727, 0.1984014926503993, 0.07177770546537054, 0.14693230624308817, 0.056395168757082725, 0.2566334357133374, 0.4952622252036125, 0.5014831704855137, 0.5150113333234252, 0.5566413321947986, 0.5129934957499767, 0.5271835525371398, 0.5544897808515858, 0.547927172788723, 0.5635849105073654, 0.07072074937970452, 0.1081864401314766, 0.06537352577976285, 0.10778855811853394, 0.0933675742478165, 0.12260494501788888, 0.09071366609224474, 0.1084848605172769, 0.1401041567921476, 0.3207941883548737, 0.2896021322645098, 0.17884029300946624, 0.2573820963254724, 0.5799681423670107, 0.27846491303782317, 0.26301397814809047, 0.16391669413551968, 0.2020524225707555, 0.21298918035100245, 0.33492812576932096, 0.29299195430863223, 0.28449522040922404, 0.31350829114723755, 0.185610894752267, 0.32740353901165187, 0.48420273021867566, 0.19001602958349217, 0.10310383533277545, 0.19063829636439933, 0.3262735280432546, 0.2943053241242911, 0.19654819952779, 0.2795153448890155, 0.20282441949506613, 0.30064238833985735, 0.26609989872598894, 0.15778713850331239, 0.17652917678700086, 0.21375408899023196, 0.21130080594348077, 0.18546715375636658, 0.23795092077189361, 0.20229855395885366, 0.20547943695399906, 0.20631231688834273, 0.2020619206018378, 0.20678557194964975, 0.24168592607993833, 0.571039773658411, 0.19679578006121912, 0.2043039830625859, 0.17719195410317623, 0.22312323041892246, 0.2162423093820972, 0.9022753533378259, 0.12577581173536578, 0.1540601033329313, 0.9009341292628206, 0.1998787014494181, 0.11678612680354561, 0.13268389766746136, 0.17004042041319722, 0.15355732656171162, 0.08272203933339628, 0.2107206186377506, 0.6606647475811476, 0.5142453636675935, 0.16745582759476418, 0.21130436251807094, 0.10461192453180135, 0.7066655465548002, 0.7290919106914518, 0.19727099460431785, 0.201814637765646, 0.20053244675686044, 0.21861092677269145, 0.19265630475270346, 0.19614724354220647, 0.1952054668122034, 0.19055127347917755, 0.1937942721854743, 0.05212197007258024, 0.054073996814863357, 0.08977870549837375, 0.09129452212976319, 0.08181234525300118, 0.08255605134063171, 0.0871673073876531, 0.09301076233171501, 0.088196751347692]}, "mutation_prompt": null}
{"id": "7a196e75-7907-4151-a0bf-a033efbd8730", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n        self.velocity_adjustment_factor = 0.05  # New parameter for adaptive velocity adjustment\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                velocity_adjustment = self.velocity_adjustment_factor * np.abs(self.global_best_position - self.particles[i])\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] + cognitive_component + social_component \n                                      + velocity_adjustment)\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.1, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridAdaptiveSwarm", "description": "Enhanced Hybrid Adaptive Swarm with Adaptive Velocity Adjustment and Environmental Adaptation for Robust Optimization.", "configspace": "", "generation": 59, "fitness": 0.28424124322502486, "feedback": "The algorithm EnhancedHybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8416342144595105, 0.8273326187629919, 0.8185052543073095, 0.8064978647547544, 0.8086014696092059, 0.8130424153073915, 0.8339995289695084, 0.8293004268941746, 0.8442329267441069, 0.6835429231897752, 0.055825557257416, 0.692608176547528, 0.6813555873067957, 0.6702435035011655, 0.025699797479737607, 0.6385116347828201, 0.7168070758551612, 0.6073905546297005, 0.292003344017441, 0.12567752332544768, 0.14401408683065875, 0.1568801463917776, 0.11918363459801329, 0.11008367547100184, 0.15998178533877982, 0.11393181919648765, 0.1254251417098985, 0.14956869008996876, 0.12809169020719002, 0.1149477886093444, 0.13766458516850255, 0.11372902061940182, 0.13663127520490415, 0.13170600809810729, 0.10436920302809338, 0.13463898712733735, 0.9858687673896326, 0.9784327836791746, 0.9898940923073654, 0.9737208121103261, 0.9850129367466628, 0.9768006853989167, 0.9824531560074715, 0.9852703162008724, 0.9821222459328589, 0.5725859372847748, 0.6116063796344602, 0.5476273078014071, 0.5191494566410905, 0.4997504598762019, 0.552358373590979, 0.5533293686022618, 0.5618212954847597, 0.390390745060886, 0.22250033629206012, 0.16328045789625645, 0.2236456286825934, 0.19060473233151498, 0.2714626795351196, 0.20967472967947143, 0.16413939196638383, 0.3244560154845558, 0.7197279223169029, 0.19288435995049147, 0.19387931973482853, 0.11771347168232227, 0.16335027109002398, 0.1840148248642961, 0.17492912044304954, 0.16227762654751043, 0.18333406628117355, 0.17261969667836585, 0.19931572987760449, 0.11701226681128885, 0.1160351822607869, 0.13414794768331362, 0.12411920621376027, 0.14022295616338065, 0.12205797872127677, 0.09636870215493032, 0.09891114351163033, 9.999999999998899e-05, 0.000889721667909904, 9.999999999998899e-05, 0.01719221729102738, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009444060808063703, 9.999999999998899e-05, 0.02677347726451207, 0.07986094446980274, 0.03494564794718813, 0.051167208888320936, 0.1464616548686618, 0.013673038545219618, 0.012747348600283148, 0.13031068490424091, 0.050493264239955926, 0.04263519507538238, 0.04393649178125503, 0.09362778092682389, 0.04553715564596694, 0.09919916027732467, 0.06919985032356402, 0.08482547196389445, 0.1441419177747566, 0.06404019613859824, 0.16728397856238608, 0.07185870461361232, 0.3221929690267783, 0.20205977235223438, 0.03530832410204421, 0.0661657212754122, 0.057946937895285155, 0.29477839956603347, 0.055315100868011724, 0.07806498655638894, 0.5296275267281667, 0.5202742991608571, 0.5750351379318446, 0.5066232073044944, 0.49737285081961835, 0.5181712709687676, 0.5615090650648482, 0.4907787827937726, 0.5434625399407749, 0.06773330642469122, 0.14837484133790402, 0.06258682313555897, 0.12129780927090072, 0.11555933082426961, 0.14328471473730664, 0.10152030025843128, 0.12837193484316356, 0.1403629877942234, 0.21066919264851813, 0.14912910730122186, 0.1681280305307873, 0.1485330287064457, 0.2198767555321437, 0.1547793336253117, 0.5412106561381593, 0.21394329254229272, 0.23084552363714272, 0.2939037842685155, 0.354220667677299, 0.38081955947827884, 0.3095956807932475, 0.21596048308657767, 0.35416186958470663, 0.31854896527328147, 0.4148553495503364, 0.21741967063602463, 0.14407680971872705, 0.2522640151408656, 0.19796449134618777, 0.19991359384567653, 0.2423535478323654, 0.21383000092611737, 0.17388964351353864, 0.36918740186462407, 0.2903700495825876, 0.18655189167671693, 0.2252554937022926, 0.20806279687402407, 0.2339084884660696, 0.19656049389990982, 0.17985983326429655, 0.22211845617958081, 0.22476352162886326, 0.23073063315426623, 0.1950550748899954, 0.604298177248425, 0.21977204556356278, 0.1945820153813005, 0.23728664227469176, 0.19496084216893828, 0.21489074012138254, 0.24092687542498992, 0.2833526777034817, 0.8367434030317211, 0.165174858122086, 0.15396622045544084, 0.8717651039252234, 0.1985171918265709, 0.8300488939129929, 0.09982720010587542, 0.168644627962521, 0.1519082595552207, 0.08268468282720365, 0.2099570243162454, 0.2073205187997864, 0.5301268064289564, 0.1677643701793904, 0.20669490636737764, 0.10476731948883278, 0.6236279292397586, 0.10421596482080753, 0.1787808888587077, 0.19368209797408154, 0.19671641511783755, 0.17760756156036572, 0.21150729488233988, 0.1906398712359888, 0.1992258439286294, 0.17542773944581747, 0.197862674899145, 0.08727420416923415, 0.08156140217043961, 0.0877258819379414, 0.09650720412289138, 0.09636683444334981, 0.07702090392417704, 0.08597754021989035, 0.09487189672086294, 0.07964451639421621]}, "mutation_prompt": null}
{"id": "441e11f0-a3e5-41bb-8908-b32d4058e236", "solution": "import numpy as np\n\nclass QuantumAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.95\n        self.crossover_rate = 0.8\n        self.c1 = 2.0\n        self.c2 = 1.5  \n        self.inertia_weight = 0.9\n        self.quantum_influence = 0.2\n        self.max_evaluations = budget\n        self.cooling_factor = 0.98\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                quantum_jump = np.random.normal(0, self.quantum_influence, self.dim)\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component + quantum_jump\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:\n                        random_step = np.random.normal(0, 0.15, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumAdaptiveSwarm", "description": "Quantum-Inspired Adaptive Swarm with Enhanced Particle Dynamics for Diverse Exploration and Convergence.", "configspace": "", "generation": 60, "fitness": 0.1957856406834755, "feedback": "The algorithm QuantumAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.38635963952907826, 0.3518240477231822, 0.3725288174224969, 0.4315770830731326, 0.3771194954975805, 0.3745121343763599, 0.38055360794605464, 0.3853043010306608, 0.3724139057343048, 0.029768686551520873, 9.999999999998899e-05, 9.999999999998899e-05, 0.003260754994553805, 0.0015467080303053216, 9.999999999998899e-05, 9.999999999998899e-05, 0.013274699571922843, 0.0109127667802692, 0.10768030800034134, 0.16490123766162523, 0.10060854895764515, 0.09461481324836496, 0.0963667822675478, 0.15720467841477948, 0.11396770520580635, 0.1067346849305495, 0.10936279704394258, 0.09230786733204699, 0.08982954634262819, 0.10462882202694712, 0.09440010676188393, 0.09388752065855077, 0.09369457508280266, 0.08125554845473959, 0.08709870781756601, 0.09128510077355145, 0.9804317341045027, 0.9732296481959071, 0.9888162369110548, 0.9742905464665059, 0.9854830837551654, 0.9002093816072755, 0.9847696430924568, 0.9825766570900563, 0.9852968256319251, 0.2430481151121916, 0.23869114265878755, 0.2357120815085686, 0.26481524592757877, 0.2268531335618177, 0.24097564592457654, 0.2697987681867946, 0.23511273557459522, 0.25278640074411407, 0.31742772803237573, 0.21115154612066167, 0.3001367288755813, 0.32537794603020376, 0.30196315652176686, 0.2993508213410693, 0.19188777219249298, 0.27010934093513284, 0.30303524719929187, 0.1112667683379377, 0.13352313916052028, 0.12221715190799787, 0.19043526182926385, 0.1556284739984829, 0.1341473305859241, 0.13911616379819203, 0.14204595869252157, 0.14237492387999862, 0.13523385190563475, 0.10367509621170246, 0.11987308810423469, 0.12204716235695012, 0.13254305496408525, 0.13115631025378627, 0.1502857980474821, 0.07996517442255191, 0.16150672523335707, 9.999999999998899e-05, 0.01795571584443678, 0.007835551532598628, 0.018165298367171845, 0.013999804450727571, 0.00408796788156085, 0.008551378615891392, 9.999999999998899e-05, 0.017131300475035638, 0.05063564127611009, 0.07458027014324364, 0.0713832637170061, 0.09957410475831008, 0.013817159238928789, 0.039900818298099106, 0.10195218083011581, 0.11442650375763985, 0.037541624630432535, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07184084288008796, 0.09029079393989636, 0.0765804047441403, 0.0698002256518675, 0.04475491045444757, 0.05126786717378895, 0.06863884080274096, 0.05939178291875524, 0.07429036195424232, 0.3476869517765352, 0.3844430542363212, 0.34750128776543965, 0.35412433486300066, 0.35194128146828807, 0.354341236755211, 0.3646650025079675, 0.36074215117099306, 0.3567006962414365, 0.10881198138263304, 0.09568301310254956, 0.10271668781273524, 0.08507910120398376, 0.1041026845074382, 0.09991452746054752, 0.0962045374174626, 0.10618352887002769, 0.0828191921535184, 0.2413358376398288, 0.20421153734892816, 0.16303634988075233, 0.146740157090548, 0.23587927388121566, 0.1511022678615609, 0.1665165539379817, 0.15305846284314906, 0.19092347732563963, 0.2656487551111424, 0.2592562695778754, 0.2714059523816126, 0.2511053246748125, 0.24859980050542785, 0.2771285891215325, 0.2610626201612636, 0.28697989576513117, 0.18288701220570558, 0.1882670930238861, 0.19964128824369487, 0.15449117143458624, 0.1845577344305408, 0.1696610239511971, 0.18706942143040672, 0.16774203224540962, 0.22111630258012793, 0.17995029879014657, 0.20450442055793494, 0.21439718178707468, 0.189609680559355, 0.19429008776611523, 0.22042160490538432, 0.22193913640041496, 0.20833504704761563, 0.20310474417356872, 0.22076965106044677, 0.22054913409086407, 0.19690989908804413, 0.19407834173555283, 0.20281249416268388, 0.20712042660373398, 0.18759999219749068, 0.19973301475047267, 0.1813826978094687, 0.188543919592154, 0.519436204518435, 0.16697654417695718, 0.15354180516513716, 0.17067205257711215, 0.19626847246228818, 0.1958241440055436, 0.12256042362119024, 0.17019853765450976, 0.15983015789787192, 0.08284657038438326, 0.16839812304357005, 0.2974391868055275, 0.20672686472855595, 0.1670740983609036, 0.20416114680767994, 0.2096592942481046, 0.3662270614253964, 0.3487172158068774, 0.1685754466056122, 0.1809369198534193, 0.18071961714544327, 0.19289424140234745, 0.18253142655246135, 0.18108176979091817, 0.18772989651662841, 0.19921831119012656, 0.19212306796593415, 0.0896421641652867, 0.09818006166614013, 0.08471056113613018, 0.08123945563856128, 0.08700800321224067, 0.08773573816375324, 0.09159837980864682, 0.08226724550154207, 0.08475158862380927]}, "mutation_prompt": null}
{"id": "a71a1b68-e719-4309-a7d3-e30d4167f5db", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # narrower initial velocity range\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # slightly reduced to encourage exploration\n        self.crossover_rate = 0.75  # slightly increased to enhance exploitation\n        self.c1 = 1.5  # reduced cognitive component\n        self.c2 = 2.5  # increased social component\n        self.inertia_weight = 0.5  # reduced to promote convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # slower cooling to maintain exploration longer\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                trial_vector = np.copy(self.particles[i])\n                if np.random.rand() < self.crossover_rate:\n                    trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                trial_score = func(trial_vector)\n                evaluations += 1\n\n                if trial_score < self.personal_best_scores[i]:\n                    self.particles[i] = trial_vector\n                    self.personal_best_scores[i] = trial_score\n                    self.personal_best_positions[i] = trial_vector\n\n                if trial_score < self.global_best_score:\n                    self.global_best_score = trial_score\n                    self.global_best_position = trial_vector\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # slightly increased chance for stochastic jumps\n                        random_step = np.random.normal(0, 0.2, self.dim)  # increased step size\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridAdaptiveSwarm", "description": "Enhanced Hybrid Adaptive Swarm with Adaptive Learning Strategy for Improved Convergence via Dynamic Adjustment of Parameters.", "configspace": "", "generation": 61, "fitness": 0.2780640195055782, "feedback": "The algorithm EnhancedHybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8347590683702885, 0.8150653169161276, 0.7953936338922811, 0.8445849055127264, 0.8319756068258878, 0.8210532812213112, 0.8498493843207526, 0.835079431064475, 0.8119932149094806, 0.7216532008906769, 0.04069189737020806, 0.6054208915734104, 0.6689938984859166, 0.6476492128076926, 0.6751660535388462, 0.03065848084507561, 0.6798924800826734, 0.6803277587059783, 0.15060491341818183, 0.11752608222383587, 0.15234812703017198, 0.16103341167611884, 0.07297506731318226, 0.11668689674779731, 0.1436119162351317, 0.07288484581290866, 0.1651216096292435, 0.15904671925233038, 0.13152264787005774, 0.11793990720646985, 0.13343276093258305, 0.12228235370772311, 0.15003391488246287, 0.14572784733464628, 0.13341031694373962, 0.10690069808633251, 0.9806297286245755, 0.9137742684029344, 0.9900243270755344, 0.9776978583878406, 0.9788351130687302, 0.9811278561639099, 0.9863490302805511, 0.9824608772584779, 0.9864960845928066, 0.5454140232661995, 0.5551885681815705, 0.5197982353516304, 0.5021604066431955, 0.6184154526125168, 0.46258578690029495, 0.5643726264026805, 0.5108939988057628, 0.46667872928418797, 0.2740507335018587, 0.29291645067066385, 0.21885528799421128, 0.21214296178800007, 0.20485956136823535, 0.19878250330288927, 0.14898047746677712, 0.3655939695966761, 0.211987638921334, 0.10300227736411505, 0.2324482297226429, 0.12814062995714026, 0.1262250121858578, 0.18297117196570134, 0.12893275863217368, 0.17486607359566353, 0.17477916934249826, 0.18299835347053772, 0.2006211927298377, 9.999999999998899e-05, 9.999999999998899e-05, 0.3709451968827756, 0.10839351470406167, 0.21746474182209163, 0.1275344741877814, 9.999999999998899e-05, 0.1388735519884976, 9.999999999998899e-05, 9.999999999998899e-05, 0.007441846225929805, 0.0018542868932966972, 9.999999999998899e-05, 0.027430108080253146, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07045447993465237, 0.05680169759358522, 0.040411884915793284, 0.08148216773280914, 0.00021960309879798245, 0.010749950260780627, 0.07331799687568497, 0.11726645257587298, 0.0519239179633918, 0.06788369583300213, 0.0764729814423959, 0.12423614082366186, 0.07338665969572156, 0.11931998375702535, 0.1325093769744906, 0.09352759918247067, 0.14457943708129228, 0.09378674134015252, 0.06764587863711735, 0.04238260606705824, 0.09341319498172829, 0.21014489688904836, 0.1287057020370097, 0.006396553749791756, 0.13055316807719142, 0.05769629992277514, 0.1786677087378954, 0.4817886209341079, 0.5540434435944306, 0.5083220041785266, 0.4995647272416841, 0.48685085776019577, 0.5156053316838289, 0.5291381315772334, 0.5200391962401227, 0.5577651919909963, 0.10912705083373331, 0.11420285228473659, 0.09188729504657056, 0.08880596463256207, 0.10503997069462478, 0.100930788883417, 0.13682781635363317, 0.12376823298327966, 0.10000995939506496, 0.18072074631211088, 0.17051471371305704, 0.20731060671473556, 0.2112698374691382, 0.3877049584232677, 0.12304171313751977, 0.29214374423928424, 0.1977443937796879, 0.1451002291941631, 0.36433212991749986, 0.4450203889867156, 0.41759670627655965, 0.37265484869423426, 0.24640727752856417, 0.24900288348572963, 0.5355111069388836, 0.2796637272659115, 0.2463381251371286, 0.08580376215812102, 0.22445568367732138, 0.26277181575316244, 0.29193690038885056, 0.20271839575876993, 0.3254204425743351, 0.34434637126845036, 0.27715903061295577, 0.2116466686429771, 0.20993308509019504, 0.23308978652109247, 0.19899404968803447, 0.2143562295152196, 0.2102326486871008, 0.19359519595664654, 0.26976442753354135, 0.2238097510923336, 0.21913969924364773, 0.199264802541401, 0.24340553908835105, 0.20993758108987426, 0.20101629526341003, 0.22368164989539763, 0.19362545001814402, 0.23140732312607937, 0.20651357763437161, 0.21376918830713176, 0.8421275007028353, 0.12506011862382782, 0.15382903997573216, 0.8823197088755572, 0.20005129552807688, 0.11687520158429088, 0.0997956824479006, 0.1693993558368424, 0.15360050100688183, 0.08272129130092021, 0.21115236673401205, 0.12338026590405204, 0.5503997139766454, 0.5382357117329069, 0.21180205938059316, 0.10485985142151533, 0.8384776398225562, 0.10447952325353693, 0.18273499654454395, 0.2093437239718775, 0.19905063767533748, 0.20499560415215634, 0.20116586662290048, 0.20078147344008235, 0.19498637631005644, 0.20732032436712478, 0.2019849949300505, 0.07451820882793547, 0.06084059011779175, 0.09703786173681361, 0.08284140004482066, 0.08803082985853639, 0.09533036624736191, 0.09351773844923461, 0.08650144098439083, 0.08055835068251094]}, "mutation_prompt": null}
{"id": "0740b8b2-898a-4e8b-adb3-a86683e0a9f6", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n        self.exploration_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if evaluations < self.max_evaluations:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarm", "description": "Enhanced Hybrid Swarm with Adaptive Mutation, Self-Adjusting Inertia, and Dynamic Exploration for Improved Performance.", "configspace": "", "generation": 62, "fitness": 0.28530727912696435, "feedback": "The algorithm EnhancedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "69c31a3d-0ba4-445e-88bf-053d1bbffc4f", "metadata": {"aucs": [0.8008076507811832, 0.8254512522866739, 0.8095388521207066, 0.8262326630697923, 0.8337174789405783, 0.8314101529524096, 0.8101826129570207, 0.8234228707212743, 0.8354418318271115, 0.6325076708968309, 0.04196488650860086, 0.6895864470765873, 0.6384206797467401, 0.26999782020554686, 0.05250782022264777, 0.0741315771515274, 0.6667271334761491, 0.020876732058568437, 0.167835774114094, 0.11600472578321441, 0.1170317445637058, 0.15689752607816776, 0.468771160608499, 0.11903479416478913, 0.10729697488053536, 0.42609200872938713, 0.13384771827301467, 0.1180849363915244, 0.12197752636395032, 0.13642595001701174, 0.13568251611348137, 0.12211972140311189, 0.134435723185383, 0.14438788971309002, 0.10289755147202628, 0.3432155467552853, 0.9819316799222126, 0.9765684048198982, 0.9890368354870797, 0.9776803438261339, 0.9811475042047577, 0.9807794559218155, 0.9814259016040233, 0.98177244158569, 0.9801510154144, 0.563338492569269, 0.5282507499543423, 0.4806578823542832, 0.5797752294787988, 0.47922522269844214, 0.5643988522004648, 0.5011038759183171, 0.5766257748066106, 0.46039961109605443, 0.22709204361192847, 0.33372950825349634, 0.21734063317422447, 0.20816788866948244, 0.20861550350796376, 0.2029865745007562, 0.2127055715851257, 0.6203339583778817, 0.11630166981070456, 0.19399976923703466, 0.1719623047867217, 0.08741885233898006, 0.17257282830385046, 0.19466306451298976, 0.19428820036815098, 0.19758984091328458, 0.17854638674612344, 0.2246648353554509, 0.14497684727675098, 9.999999999998899e-05, 9.999999999998899e-05, 0.1277394325020248, 0.10572249234088649, 0.11895663009521762, 0.11641128896294284, 0.14783168797108426, 0.19719802925570118, 9.999999999998899e-05, 9.999999999998899e-05, 0.009051125314031516, 0.015493906611025343, 9.999999999998899e-05, 0.001236132041151694, 9.999999999998899e-05, 0.002790750431864164, 9.999999999998899e-05, 0.11032335968963203, 0.07806459711352076, 0.07862135549216087, 0.08839515533893749, 0.013444167078737745, 0.015947738142683687, 0.09281876903011488, 0.0493596864691177, 0.08071959209559842, 0.059020655822423995, 0.10220478919804243, 0.04551635158745593, 0.07405271643062694, 0.06977756858252127, 0.0767920746855425, 0.09079276415210147, 0.06869573029962872, 0.06622950184885701, 0.0674078066968492, 0.07455691883711368, 0.18090551142882427, 0.013325191120938107, 0.12913373233605985, 0.007914041440922448, 0.15068603168456407, 0.06392639302475567, 0.07960869559037309, 0.5273562584477092, 0.4897140133425858, 0.5236514634230858, 0.5134605342449583, 0.5616209211144767, 0.5062964470504963, 0.5210627516319917, 0.529828009463401, 0.5386897725569886, 0.0647757773546711, 0.1428739626063632, 0.05997234904321558, 0.125591553247961, 0.11631937119301072, 0.11835447776765051, 0.12481851164883628, 0.08793771823623142, 0.09153655857652576, 0.3031575894372801, 0.16899118202718733, 0.2854382424396752, 0.16254167280447895, 0.3143469699325564, 0.2528067192895137, 0.2506577604850476, 0.18941918775744526, 0.3344144458357011, 0.3514610347925172, 0.47022021980770246, 0.39906146311824053, 0.40856366022241863, 0.21621349148826963, 0.33275116884128497, 0.41434321752130554, 0.5410440404414512, 0.1731713486822951, 0.09207217360664477, 0.2706091837076836, 0.2112290168585952, 0.23360915500017054, 0.19747828691599179, 0.12401565837508133, 0.1851694066144638, 0.29830165882731985, 0.08800569248876178, 0.19551138737968543, 0.21524558175992303, 0.17523131342321885, 0.22272652901447487, 0.19483991094432807, 0.21233719748519975, 0.19969488856598538, 0.19658446786904837, 0.22691534091917087, 0.1982997311563155, 0.2403818912609842, 0.6181598781984461, 0.19364353301390247, 0.20526850695483612, 0.20357901548612845, 0.6595842540462278, 0.22102024100528017, 0.7030566746581113, 0.8719619404863993, 0.1676382100965762, 0.15377860109336194, 0.8486051130714293, 0.19976413243640045, 0.14826097009106376, 0.09986152562507689, 0.16845059256396822, 0.7599362859726686, 0.4408552435276971, 0.20830121420008696, 0.3795079355934664, 0.5010860717573418, 0.4492785219952705, 0.20781506460139354, 0.10425811683103314, 0.7420273138124795, 0.45708614799324254, 0.1817781752630857, 0.2111864131995861, 0.19852805751775704, 0.19204837870841096, 0.19008053412996861, 0.18402112204437804, 0.18500606933851604, 0.18014816823812196, 0.19798363473506886, 0.08781446402525284, 0.08723285327345853, 0.08434282993449616, 0.09383783185506978, 0.09153950787255638, 0.09875482187657325, 0.0801985090748143, 0.09820129359269703, 0.08159833603727074]}, "mutation_prompt": null}
{"id": "9a299e97-48f2-4b3a-9096-a3401aae3ea7", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99\n        self.exploration_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if evaluations < self.max_evaluations:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if evaluations < self.max_evaluations:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarm", "description": "Enhanced Hybrid Swarm with Adaptive Mutation, Self-Adjusting Inertia, and Dynamic Exploration for Improved Performance.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0740b8b2-898a-4e8b-adb3-a86683e0a9f6", "metadata": {"aucs": [0.8008076507811832, 0.8254512522866739, 0.8095388521207066, 0.8262326630697923, 0.8337174789405783, 0.8314101529524096, 0.8101826129570207, 0.8234228707212743, 0.8354418318271115, 0.6325076708968309, 0.04196488650860086, 0.6895864470765873, 0.6384206797467401, 0.26999782020554686, 0.05250782022264777, 0.0741315771515274, 0.6667271334761491, 0.020876732058568437, 0.167835774114094, 0.11600472578321441, 0.1170317445637058, 0.15689752607816776, 0.468771160608499, 0.11903479416478913, 0.10729697488053536, 0.42609200872938713, 0.13384771827301467, 0.1180849363915244, 0.12197752636395032, 0.13642595001701174, 0.13568251611348137, 0.12211972140311189, 0.134435723185383, 0.14438788971309002, 0.10289755147202628, 0.3432155467552853, 0.9819316799222126, 0.9765684048198982, 0.9890368354870797, 0.9776803438261339, 0.9811475042047577, 0.9807794559218155, 0.9814259016040233, 0.98177244158569, 0.9801510154144, 0.563338492569269, 0.5282507499543423, 0.4806578823542832, 0.5797752294787988, 0.47922522269844214, 0.5643988522004648, 0.5011038759183171, 0.5766257748066106, 0.46039961109605443, 0.22709204361192847, 0.33372950825349634, 0.21734063317422447, 0.20816788866948244, 0.20861550350796376, 0.2029865745007562, 0.2127055715851257, 0.6203339583778817, 0.11630166981070456, 0.19399976923703466, 0.1719623047867217, 0.08741885233898006, 0.17257282830385046, 0.19466306451298976, 0.19428820036815098, 0.19758984091328458, 0.17854638674612344, 0.2246648353554509, 0.14497684727675098, 9.999999999998899e-05, 9.999999999998899e-05, 0.1277394325020248, 0.10572249234088649, 0.11895663009521762, 0.11641128896294284, 0.14783168797108426, 0.19719802925570118, 9.999999999998899e-05, 9.999999999998899e-05, 0.009051125314031516, 0.015493906611025343, 9.999999999998899e-05, 0.001236132041151694, 9.999999999998899e-05, 0.002790750431864164, 9.999999999998899e-05, 0.11032335968963203, 0.07806459711352076, 0.07862135549216087, 0.08839515533893749, 0.013444167078737745, 0.015947738142683687, 0.09281876903011488, 0.0493596864691177, 0.08071959209559842, 0.059020655822423995, 0.10220478919804243, 0.04551635158745593, 0.07405271643062694, 0.06977756858252127, 0.0767920746855425, 0.09079276415210147, 0.06869573029962872, 0.06622950184885701, 0.0674078066968492, 0.07455691883711368, 0.18090551142882427, 0.013325191120938107, 0.12913373233605985, 0.007914041440922448, 0.15068603168456407, 0.06392639302475567, 0.07960869559037309, 0.5273562584477092, 0.4897140133425858, 0.5236514634230858, 0.5134605342449583, 0.5616209211144767, 0.5062964470504963, 0.5210627516319917, 0.529828009463401, 0.5386897725569886, 0.0647757773546711, 0.1428739626063632, 0.05997234904321558, 0.125591553247961, 0.11631937119301072, 0.11835447776765051, 0.12481851164883628, 0.08793771823623142, 0.09153655857652576, 0.3031575894372801, 0.16899118202718733, 0.2854382424396752, 0.16254167280447895, 0.3143469699325564, 0.2528067192895137, 0.2506577604850476, 0.18941918775744526, 0.3344144458357011, 0.3514610347925172, 0.47022021980770246, 0.39906146311824053, 0.40856366022241863, 0.21621349148826963, 0.33275116884128497, 0.41434321752130554, 0.5410440404414512, 0.1731713486822951, 0.09207217360664477, 0.2706091837076836, 0.2112290168585952, 0.23360915500017054, 0.19747828691599179, 0.12401565837508133, 0.1851694066144638, 0.29830165882731985, 0.08800569248876178, 0.19551138737968543, 0.21524558175992303, 0.17523131342321885, 0.22272652901447487, 0.19483991094432807, 0.21233719748519975, 0.19969488856598538, 0.19658446786904837, 0.22691534091917087, 0.1982997311563155, 0.2403818912609842, 0.6181598781984461, 0.19364353301390247, 0.20526850695483612, 0.20357901548612845, 0.6595842540462278, 0.22102024100528017, 0.7030566746581113, 0.8719619404863993, 0.1676382100965762, 0.15377860109336194, 0.8486051130714293, 0.19976413243640045, 0.14826097009106376, 0.09986152562507689, 0.16845059256396822, 0.7599362859726686, 0.4408552435276971, 0.20830121420008696, 0.3795079355934664, 0.5010860717573418, 0.4492785219952705, 0.20781506460139354, 0.10425811683103314, 0.7420273138124795, 0.45708614799324254, 0.1817781752630857, 0.2111864131995861, 0.19852805751775704, 0.19204837870841096, 0.19008053412996861, 0.18402112204437804, 0.18500606933851604, 0.18014816823812196, 0.19798363473506886, 0.08781446402525284, 0.08723285327345853, 0.08434282993449616, 0.09383783185506978, 0.09153950787255638, 0.09875482187657325, 0.0801985090748143, 0.09820129359269703, 0.08159833603727074]}, "mutation_prompt": null}
{"id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "solution": "import numpy as np\n\nclass AdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor for slower decay\n        self.exploration_factor = 0.1\n        self.exploration_phase = True  # Track exploration vs exploitation phase\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveBiPhaseSwarm", "description": "Adaptive Bi-Phase Swarm Optimization with Temperature-Based Exploration Control to Enhance Convergence.", "configspace": "", "generation": 64, "fitness": 0.30033138552752425, "feedback": "The algorithm AdaptiveBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "0740b8b2-898a-4e8b-adb3-a86683e0a9f6", "metadata": {"aucs": [0.8387792691726152, 0.8048915103839938, 0.8211624155187738, 0.8325145706575148, 0.8588221127773608, 0.826374519233586, 0.8506684697796467, 0.8584326311895265, 0.8366270557487654, 0.582804920422145, 0.7001992167962512, 0.6528117177159258, 0.5747720154845336, 0.6950825044065594, 0.6584910109928482, 0.6193200019868275, 0.7126938804250005, 0.5650319592982975, 0.14941087515682538, 0.1526706506150196, 0.1608774108266704, 0.16850388525540716, 0.07417087385047927, 0.15783063929036745, 0.14080057758713316, 0.17517186408614194, 0.6393569475226261, 0.13542651034650388, 0.15143753570967888, 0.10286908972848818, 0.16742331015241851, 0.13963195639629955, 0.4136990459224793, 0.12707470276910793, 0.11322211979242836, 0.09621661269038573, 0.9824954798073919, 0.9774720743151041, 0.990598539031067, 0.9773454926292526, 0.978245590869082, 0.9765005365313397, 0.984152955633922, 0.9876107861072613, 0.9868833169713772, 0.488639853625204, 0.6403105455618188, 0.6200905602009656, 0.6821251950692909, 0.5566528638734676, 0.6568247435900232, 0.5599444790308998, 0.6067419321972007, 0.558238587686372, 0.2214492445417674, 0.3509189017449368, 0.1713030722119403, 0.21845005198745604, 0.21580529563645867, 0.26140893709678126, 0.3759811124442348, 0.2272201655483218, 0.17539038547451713, 0.19070509153013204, 0.1291647034562986, 0.10694573415924002, 0.17362374325012164, 0.18741439340069566, 0.17302589746014474, 0.1782609584114021, 0.18843350356920385, 0.19041444014836229, 0.12870354143999851, 0.021259161804396576, 0.143517412667319, 0.2065055570215254, 0.17481577581270735, 0.18760033466879034, 0.2238689560109749, 9.999999999998899e-05, 0.12130431432530353, 9.999999999998899e-05, 0.015668250506885473, 0.005347024302129855, 0.007195193728892435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07531935473982754, 0.02766803853638089, 0.09322313452998188, 0.059386194878164544, 9.999999999998899e-05, 0.0016863888766088797, 0.10620891831262502, 0.033103127307588354, 0.05446690544611743, 0.1417936319358556, 0.0361185400164844, 0.22861174445561983, 0.07495533272296229, 0.09258265249854991, 0.06754435796248726, 0.09393339445122106, 0.0674310803751621, 0.09856368486138312, 0.0801832881697021, 0.08514185292835941, 0.2493159611977932, 0.017965841849578612, 0.08688795125730553, 0.008586335509034093, 0.09070138725542476, 0.08951001311637485, 0.09022298780690674, 0.4981969319592804, 0.5132174637570487, 0.5295751545552156, 0.5137227332826444, 0.510867710702765, 0.5053646584980389, 0.5453735534888602, 0.5160975656305622, 0.544258083839561, 0.08402447646853306, 0.07596612581995121, 0.0707339839636284, 0.091811563044777, 0.10664493081020177, 0.09444433394813112, 0.12883258402548492, 0.11171951237699307, 0.098571976284206, 0.17000069359458536, 0.20601375270856348, 0.32034178118040224, 0.16883749390193048, 0.3797864230768456, 0.3091152610076431, 0.3206162041834095, 0.3542995472239273, 0.19532499711331153, 0.29567976629592085, 0.4076556650901688, 0.3134545584907058, 0.46748140590139164, 0.22471466809486584, 0.5105102666049826, 0.6479604726711579, 0.5218784962430099, 0.1738277309670102, 0.1885436296955446, 0.28407560066176674, 0.17917131398607455, 0.20109640253015126, 0.20118073220792376, 0.23649660495351021, 0.1614708615859194, 0.24184991671668754, 0.2417276140158484, 0.20664020143206696, 0.2272206916194457, 0.17606136302987474, 0.19321741389675995, 0.19239961479019974, 0.20610560314886806, 0.21088802902801695, 0.22680393248537634, 0.19764612193475595, 0.6135316913651988, 0.18808997263537186, 0.22913005161805566, 0.24467664336260875, 0.6139963179698282, 0.24089177824426256, 0.20287995846652362, 0.7128630992276968, 0.21755767159102068, 0.8651209887282019, 0.1632239484345418, 0.1548145611500482, 0.8930728895328767, 0.2015734103282636, 0.19900736117783902, 0.09975719216523082, 0.16899748407950432, 0.16001286067913045, 0.6364803725813226, 0.20702264534165005, 0.16406134463609456, 0.20704190775575337, 0.16771222885984627, 0.20652565982634397, 0.14239516178566358, 0.7359718122370003, 0.4758168968680647, 0.24460403526587282, 0.2012701129332669, 0.20767197322660436, 0.20398595763522054, 0.20081266101346973, 0.19175143078323997, 0.18716392145007688, 0.18416075451951142, 0.1951112593910609, 0.08388077288172735, 0.09317538768764622, 0.1063966604443638, 0.09685325302711867, 0.09645922290194775, 0.04958669273436389, 0.07528195247203551, 0.07219991622216859, 0.07970804640499063]}, "mutation_prompt": null}
{"id": "a415d1c2-8ce2-4c01-93e1-0bea11203054", "solution": "import numpy as np\n\nclass AdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly reduced for improved stability\n        self.crossover_rate = 0.8  # Increased to promote recombination\n        self.c1 = 2.1  # Slightly adjusted for better convergence balance\n        self.c2 = 1.9  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.994  # Further adjusted to maintain diversity\n        self.exploration_factor = 0.1\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.4:  # Increased probability for local search\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Adjusted phase switching frequency\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveBiPhaseSwarm", "description": "Adaptive Bi-Phase Swarm Optimization with Dynamic Exploration-Exploitation Balance and Local Search Enhancements.", "configspace": "", "generation": 65, "fitness": 0.294389551373413, "feedback": "The algorithm AdaptiveBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8291146433295331, 0.8186696086023851, 0.8268780331315626, 0.8156734850047571, 0.8291579500873325, 0.8099161053038504, 0.8597412092071165, 0.8550046080179845, 0.8369398932883189, 0.7469516729104961, 0.6237945192163592, 0.5455638166246448, 0.6920384110738871, 0.6565610139741402, 0.6871615809884591, 0.7035289397511586, 0.7215139578752868, 0.6940157489432455, 0.11910061539617967, 0.14147788502211767, 0.12532128065609538, 0.14301348921142143, 0.07176141986382978, 0.17967285338659333, 0.15892200235225495, 0.14888707032128456, 0.15051814149885245, 0.1293461784358524, 0.12821136174385306, 0.112026381562779, 0.14374673604451071, 0.10156014644483058, 0.10925923477361899, 0.12046889743106726, 0.13138318109330116, 0.1084024943531624, 0.9868966599540486, 0.9798557764495153, 0.9866585794875146, 0.9834089360295426, 0.9841278469178992, 0.9801127230303535, 0.9843674545429566, 0.9851136365702122, 0.9860710257922103, 0.521521002836472, 0.5776702825889961, 0.5712932818611649, 0.5116201773229783, 0.6459777947216068, 0.5841748703866096, 0.5377815514017231, 0.5664352308601401, 0.5223933080533651, 0.22438055643154164, 0.20779192691789783, 0.20939184724587845, 0.21261883420240246, 0.19010810476987217, 0.7675024476846388, 0.1293699305198499, 0.20251744697000684, 0.22746343887541876, 0.17938460141039236, 0.19411392263972205, 0.18181428383251264, 0.19843866659529152, 0.21690377132440286, 0.24732052425309425, 0.1820520139523829, 0.1976782627160557, 0.18437966775571102, 0.12844187340975333, 0.1267051024080036, 0.1244879790423532, 0.18590486464468237, 0.12479098219070728, 0.17143945975353214, 0.2424691910449409, 9.999999999998899e-05, 0.10401111629872684, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024729924952562987, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06868171935290213, 0.03610516647892559, 0.06771657747626236, 0.07872984212530831, 0.0051318346485415, 0.05875630789542252, 0.10748174952174105, 0.08861849756099294, 0.06702909073252594, 0.0481177402722196, 0.08114586963867965, 0.05154597531786842, 0.0983776774127888, 0.19593785208721592, 0.13922502554073657, 0.09301484788342529, 0.07049973947798405, 0.1711406249772739, 0.05905171336179482, 0.04218771414104161, 0.09765061325727331, 0.009031554638489925, 0.061901457542130056, 0.008798657619387806, 0.08092877930831566, 0.1752179275614213, 0.09775731467747883, 0.5691549504616953, 0.4742139922542917, 0.5165339535222588, 0.5708326438203366, 0.5792377812951359, 0.5275001532863854, 0.5718119873437395, 0.5474401747396578, 0.5639602863855273, 0.09280058615941122, 0.09792494361505011, 0.0645990606323803, 0.11433828609628305, 0.17549762142546388, 0.11523615353598105, 0.12422157799625388, 0.086550241567659, 0.1686369968564635, 0.3717789068430474, 0.22740743578581601, 0.5949482631249894, 0.2503189867868506, 0.3696585698659819, 0.21162979846505559, 0.3276164574535372, 0.1507481322500437, 0.21639506742737247, 0.39799463998401274, 0.25016604791961095, 0.31029422898265524, 0.3434666404350786, 0.26381611494362156, 0.38180346419276023, 0.4203929175770822, 0.48716288978884936, 0.3506256270250726, 0.18102962437303138, 0.22277104509285728, 0.17633485894453804, 0.2694718879305861, 0.25083098586890196, 0.2064253330871232, 0.27753083633374864, 0.25255097459513487, 0.10109957021381566, 0.222773628622444, 0.17834113952388542, 0.1790358828302422, 0.2422814622686439, 0.20101210311822326, 0.2154262643530196, 0.22617956160142494, 0.24282719611764692, 0.21684588806619587, 0.2022378654346807, 0.22099919547649916, 0.23269454461347383, 0.23695047004887537, 0.20477650184318008, 0.21748210545355162, 0.5931016320646096, 0.47246082532221345, 0.19317719715605086, 0.8883065775785051, 0.16044466706852367, 0.15453749290241647, 0.8787336190737796, 0.20041781580590867, 0.1973702838600201, 0.09964916000990343, 0.17006452430298447, 0.16107056757389615, 0.15535507042504382, 0.2097758243716913, 0.19221235695111916, 0.43182405598743656, 0.16779845978206054, 0.207455473606737, 0.1136390670823163, 0.6471507841293274, 0.20958733603134938, 0.21465722541205168, 0.2019708902172903, 0.19663489191624672, 0.2190899670038935, 0.21214148258642052, 0.1970322028099215, 0.2229322366789348, 0.22794372934311757, 0.2042555070483314, 0.09700319703518667, 0.09343826465607907, 0.07744362128109827, 0.08596237111537541, 0.07856504892124672, 0.09076922194019299, 0.08692269617520265, 0.10230419362164578, 0.0926417340720338]}, "mutation_prompt": null}
{"id": "99e265ca-25d0-4349-b8df-0a98d91fc742", "solution": "import numpy as np\n\nclass AdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor for slower decay\n        self.exploration_factor = 0.1\n        self.exploration_phase = True  # Track exploration vs exploitation phase\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveBiPhaseSwarm", "description": "Adaptive Bi-Phase Swarm Optimization with Temperature-Based Exploration Control to Enhance Convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8387792691726152, 0.8048915103839938, 0.8211624155187738, 0.8325145706575148, 0.8588221127773608, 0.826374519233586, 0.8506684697796467, 0.8584326311895265, 0.8366270557487654, 0.582804920422145, 0.7001992167962512, 0.6528117177159258, 0.5747720154845336, 0.6950825044065594, 0.6584910109928482, 0.6193200019868275, 0.7126938804250005, 0.5650319592982975, 0.14941087515682538, 0.1526706506150196, 0.1608774108266704, 0.16850388525540716, 0.07417087385047927, 0.15783063929036745, 0.14080057758713316, 0.17517186408614194, 0.6393569475226261, 0.13542651034650388, 0.15143753570967888, 0.10286908972848818, 0.16742331015241851, 0.13963195639629955, 0.4136990459224793, 0.12707470276910793, 0.11322211979242836, 0.09621661269038573, 0.9824954798073919, 0.9774720743151041, 0.990598539031067, 0.9773454926292526, 0.978245590869082, 0.9765005365313397, 0.984152955633922, 0.9876107861072613, 0.9868833169713772, 0.488639853625204, 0.6403105455618188, 0.6200905602009656, 0.6821251950692909, 0.5566528638734676, 0.6568247435900232, 0.5599444790308998, 0.6067419321972007, 0.558238587686372, 0.2214492445417674, 0.3509189017449368, 0.1713030722119403, 0.21845005198745604, 0.21580529563645867, 0.26140893709678126, 0.3759811124442348, 0.2272201655483218, 0.17539038547451713, 0.19070509153013204, 0.1291647034562986, 0.10694573415924002, 0.17362374325012164, 0.18741439340069566, 0.17302589746014474, 0.1782609584114021, 0.18843350356920385, 0.19041444014836229, 0.12870354143999851, 0.021259161804396576, 0.143517412667319, 0.2065055570215254, 0.17481577581270735, 0.18760033466879034, 0.2238689560109749, 9.999999999998899e-05, 0.12130431432530353, 9.999999999998899e-05, 0.015668250506885473, 0.005347024302129855, 0.007195193728892435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07531935473982754, 0.02766803853638089, 0.09322313452998188, 0.059386194878164544, 9.999999999998899e-05, 0.0016863888766088797, 0.10620891831262502, 0.033103127307588354, 0.05446690544611743, 0.1417936319358556, 0.0361185400164844, 0.22861174445561983, 0.07495533272296229, 0.09258265249854991, 0.06754435796248726, 0.09393339445122106, 0.0674310803751621, 0.09856368486138312, 0.0801832881697021, 0.08514185292835941, 0.2493159611977932, 0.017965841849578612, 0.08688795125730553, 0.008586335509034093, 0.09070138725542476, 0.08951001311637485, 0.09022298780690674, 0.4981969319592804, 0.5132174637570487, 0.5295751545552156, 0.5137227332826444, 0.510867710702765, 0.5053646584980389, 0.5453735534888602, 0.5160975656305622, 0.544258083839561, 0.08402447646853306, 0.07596612581995121, 0.0707339839636284, 0.091811563044777, 0.10664493081020177, 0.09444433394813112, 0.12883258402548492, 0.11171951237699307, 0.098571976284206, 0.17000069359458536, 0.20601375270856348, 0.32034178118040224, 0.16883749390193048, 0.3797864230768456, 0.3091152610076431, 0.3206162041834095, 0.3542995472239273, 0.19532499711331153, 0.29567976629592085, 0.4076556650901688, 0.3134545584907058, 0.46748140590139164, 0.22471466809486584, 0.5105102666049826, 0.6479604726711579, 0.5218784962430099, 0.1738277309670102, 0.1885436296955446, 0.28407560066176674, 0.17917131398607455, 0.20109640253015126, 0.20118073220792376, 0.23649660495351021, 0.1614708615859194, 0.24184991671668754, 0.2417276140158484, 0.20664020143206696, 0.2272206916194457, 0.17606136302987474, 0.19321741389675995, 0.19239961479019974, 0.20610560314886806, 0.21088802902801695, 0.22680393248537634, 0.19764612193475595, 0.6135316913651988, 0.18808997263537186, 0.22913005161805566, 0.24467664336260875, 0.6139963179698282, 0.24089177824426256, 0.20287995846652362, 0.7128630992276968, 0.21755767159102068, 0.8651209887282019, 0.1632239484345418, 0.1548145611500482, 0.8930728895328767, 0.2015734103282636, 0.19900736117783902, 0.09975719216523082, 0.16899748407950432, 0.16001286067913045, 0.6364803725813226, 0.20702264534165005, 0.16406134463609456, 0.20704190775575337, 0.16771222885984627, 0.20652565982634397, 0.14239516178566358, 0.7359718122370003, 0.4758168968680647, 0.24460403526587282, 0.2012701129332669, 0.20767197322660436, 0.20398595763522054, 0.20081266101346973, 0.19175143078323997, 0.18716392145007688, 0.18416075451951142, 0.1951112593910609, 0.08388077288172735, 0.09317538768764622, 0.1063966604443638, 0.09685325302711867, 0.09645922290194775, 0.04958669273436389, 0.07528195247203551, 0.07219991622216859, 0.07970804640499063]}, "mutation_prompt": null}
{"id": "363d4027-a303-43a1-8b2a-37b558c1f827", "solution": "import numpy as np\n\nclass QuantumAdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.1\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    crossover_prob = np.random.rand()\n                    if crossover_prob < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumAdaptiveBiPhaseSwarm", "description": "Quantum-Inspired Adaptive Bi-Phase Swarm Optimization with Enhanced Escape Mechanisms and Adaptive Crossover.", "configspace": "", "generation": 67, "fitness": 0.30033138552752425, "feedback": "The algorithm QuantumAdaptiveBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8387792691726152, 0.8048915103839938, 0.8211624155187738, 0.8325145706575148, 0.8588221127773608, 0.826374519233586, 0.8506684697796467, 0.8584326311895265, 0.8366270557487654, 0.582804920422145, 0.7001992167962512, 0.6528117177159258, 0.5747720154845336, 0.6950825044065594, 0.6584910109928482, 0.6193200019868275, 0.7126938804250005, 0.5650319592982975, 0.14941087515682538, 0.1526706506150196, 0.1608774108266704, 0.16850388525540716, 0.07417087385047927, 0.15783063929036745, 0.14080057758713316, 0.17517186408614194, 0.6393569475226261, 0.13542651034650388, 0.15143753570967888, 0.10286908972848818, 0.16742331015241851, 0.13963195639629955, 0.4136990459224793, 0.12707470276910793, 0.11322211979242836, 0.09621661269038573, 0.9824954798073919, 0.9774720743151041, 0.990598539031067, 0.9773454926292526, 0.978245590869082, 0.9765005365313397, 0.984152955633922, 0.9876107861072613, 0.9868833169713772, 0.488639853625204, 0.6403105455618188, 0.6200905602009656, 0.6821251950692909, 0.5566528638734676, 0.6568247435900232, 0.5599444790308998, 0.6067419321972007, 0.558238587686372, 0.2214492445417674, 0.3509189017449368, 0.1713030722119403, 0.21845005198745604, 0.21580529563645867, 0.26140893709678126, 0.3759811124442348, 0.2272201655483218, 0.17539038547451713, 0.19070509153013204, 0.1291647034562986, 0.10694573415924002, 0.17362374325012164, 0.18741439340069566, 0.17302589746014474, 0.1782609584114021, 0.18843350356920385, 0.19041444014836229, 0.12870354143999851, 0.021259161804396576, 0.143517412667319, 0.2065055570215254, 0.17481577581270735, 0.18760033466879034, 0.2238689560109749, 9.999999999998899e-05, 0.12130431432530353, 9.999999999998899e-05, 0.015668250506885473, 0.005347024302129855, 0.007195193728892435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07531935473982754, 0.02766803853638089, 0.09322313452998188, 0.059386194878164544, 9.999999999998899e-05, 0.0016863888766088797, 0.10620891831262502, 0.033103127307588354, 0.05446690544611743, 0.1417936319358556, 0.0361185400164844, 0.22861174445561983, 0.07495533272296229, 0.09258265249854991, 0.06754435796248726, 0.09393339445122106, 0.0674310803751621, 0.09856368486138312, 0.0801832881697021, 0.08514185292835941, 0.2493159611977932, 0.017965841849578612, 0.08688795125730553, 0.008586335509034093, 0.09070138725542476, 0.08951001311637485, 0.09022298780690674, 0.4981969319592804, 0.5132174637570487, 0.5295751545552156, 0.5137227332826444, 0.510867710702765, 0.5053646584980389, 0.5453735534888602, 0.5160975656305622, 0.544258083839561, 0.08402447646853306, 0.07596612581995121, 0.0707339839636284, 0.091811563044777, 0.10664493081020177, 0.09444433394813112, 0.12883258402548492, 0.11171951237699307, 0.098571976284206, 0.17000069359458536, 0.20601375270856348, 0.32034178118040224, 0.16883749390193048, 0.3797864230768456, 0.3091152610076431, 0.3206162041834095, 0.3542995472239273, 0.19532499711331153, 0.29567976629592085, 0.4076556650901688, 0.3134545584907058, 0.46748140590139164, 0.22471466809486584, 0.5105102666049826, 0.6479604726711579, 0.5218784962430099, 0.1738277309670102, 0.1885436296955446, 0.28407560066176674, 0.17917131398607455, 0.20109640253015126, 0.20118073220792376, 0.23649660495351021, 0.1614708615859194, 0.24184991671668754, 0.2417276140158484, 0.20664020143206696, 0.2272206916194457, 0.17606136302987474, 0.19321741389675995, 0.19239961479019974, 0.20610560314886806, 0.21088802902801695, 0.22680393248537634, 0.19764612193475595, 0.6135316913651988, 0.18808997263537186, 0.22913005161805566, 0.24467664336260875, 0.6139963179698282, 0.24089177824426256, 0.20287995846652362, 0.7128630992276968, 0.21755767159102068, 0.8651209887282019, 0.1632239484345418, 0.1548145611500482, 0.8930728895328767, 0.2015734103282636, 0.19900736117783902, 0.09975719216523082, 0.16899748407950432, 0.16001286067913045, 0.6364803725813226, 0.20702264534165005, 0.16406134463609456, 0.20704190775575337, 0.16771222885984627, 0.20652565982634397, 0.14239516178566358, 0.7359718122370003, 0.4758168968680647, 0.24460403526587282, 0.2012701129332669, 0.20767197322660436, 0.20398595763522054, 0.20081266101346973, 0.19175143078323997, 0.18716392145007688, 0.18416075451951142, 0.1951112593910609, 0.08388077288172735, 0.09317538768764622, 0.1063966604443638, 0.09685325302711867, 0.09645922290194775, 0.04958669273436389, 0.07528195247203551, 0.07219991622216859, 0.07970804640499063]}, "mutation_prompt": null}
{"id": "f13e7310-9def-43ce-b9cf-954906eebc7f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.1\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            w = self.inertia_weight * (1 - (evaluations / self.max_evaluations))\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = w * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (np.random.rand() * (self.particles[b] - self.particles[c]))\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveBiPhaseSwarm", "description": "Enhanced Adaptive Bi-Phase Swarm Optimization with Dynamic Component Weighting and Adaptive Mutation Control for Robust Convergence.", "configspace": "", "generation": 68, "fitness": 0.2993497683274471, "feedback": "The algorithm EnhancedAdaptiveBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8287597929065531, 0.8439795703389651, 0.847905941999286, 0.843543303091276, 0.8563764647598072, 0.8288063259707779, 0.8611000622960576, 0.838002389392566, 0.8536646140618385, 0.5901008606533535, 0.6997077491242271, 0.6758863847967371, 0.6974727239841332, 0.7240317711561861, 0.6143174062082787, 0.7010980521067892, 0.7168945328605572, 0.7112607897308497, 0.14643791110599924, 0.12074097462195676, 0.15218482083975982, 0.12121430230546537, 0.16405782868331098, 0.1457070044821972, 0.1731173095383296, 0.15184676250550133, 0.6990010449139635, 0.13917027749788835, 0.13482987000114732, 0.4124965270161147, 0.15649173768738833, 0.09280494686532381, 0.5051859785105335, 0.13415799686064434, 0.13917209958695753, 0.09238929538598617, 0.9845224878434687, 0.9785426090797003, 0.9900242022871978, 0.9842347466067772, 0.9801768044845403, 0.9748585711770517, 0.9908033666800128, 0.9861458772433616, 0.9899602896685195, 0.6421635949102242, 0.6319492323140901, 0.5654620638205692, 0.6060349950712662, 0.44506823820866126, 0.47812451084075924, 0.5480150074933843, 0.5185478024893668, 0.5268484208734479, 0.221473515996521, 0.27198768192063294, 0.24589732030807654, 0.2125088882253532, 0.18792247353843006, 0.20642888261100456, 0.16440565574217159, 0.2258982304214493, 0.8137987089618604, 0.0945122130066296, 0.19158317279029202, 0.17980423622808428, 0.17486496426580433, 0.12697180122291063, 0.18057883000289077, 0.18494887930348636, 0.22334387346556095, 0.21493266901972308, 0.1438103396155841, 9.999999999998899e-05, 0.11054290594274752, 0.18058209479014864, 0.26903905963855046, 0.2104243060108686, 0.21835809206711443, 9.999999999998899e-05, 0.1818908418129367, 9.999999999998899e-05, 9.999999999998899e-05, 0.024826555236217795, 0.05588510610942443, 9.999999999998899e-05, 0.015710277966949793, 0.004271290161824481, 9.999999999998899e-05, 0.05234901185497398, 0.0810235599157737, 0.018898442057007747, 0.03874013764209672, 0.08521050711435163, 0.01060405355249272, 0.0033795466688097964, 0.08724372900407618, 0.05507286679894441, 0.050667944297386525, 0.13909589711956416, 0.11239897708416446, 0.05258833173726729, 0.07705398138006281, 0.07651778294291856, 0.07557877061831264, 0.10052341336347126, 0.11171928081125748, 0.11248726558537059, 0.07536287818284204, 0.08908292393839767, 0.17117178520370413, 0.015175174416272585, 0.14207625422827586, 0.01179966094116447, 0.07440330153717933, 0.05742210695570871, 0.08448533624024823, 0.49397966309418395, 0.5116508810847639, 0.5147859997888611, 0.5160514421630678, 0.5218241407937234, 0.5071123288249098, 0.5654803618130104, 0.5058593544456591, 0.5251794562347913, 0.06912957822744525, 0.0741385894591371, 0.0650655727210444, 0.07591515241363955, 0.13201677732727768, 0.12998569649193636, 0.0708977353610366, 0.09886647273006077, 0.13106642332934393, 0.38089983483250367, 0.44295869600786675, 0.17234302015245506, 0.3142912522848611, 0.21382567086610438, 0.23360579237130197, 0.1922594727893464, 0.2404816039346821, 0.18051667061098975, 0.2583916042163904, 0.24562654078964385, 0.24321418220038282, 0.4362613678237939, 0.2627670455012654, 0.34991605575087037, 0.399502941032692, 0.29734418069900515, 0.21583596099769942, 0.09026973460290033, 0.16536332749740268, 0.1800986697895849, 0.1832930348758045, 0.19704304779069615, 0.36556134197306567, 0.21493815054152166, 0.2813495208621619, 0.24991625106688775, 0.21403309982118213, 0.16464156065044566, 0.2397375564628026, 0.2314294676190708, 0.14931145817279445, 0.19326759596509968, 0.19400051233682925, 0.18793123711649717, 0.21604662656610452, 0.24625273127557645, 0.5976205502091068, 0.19839661724918478, 0.2177625728896947, 0.21895785040396654, 0.21289253818353981, 0.218811704172704, 0.21971650152960165, 0.511919978340535, 0.9055472333961092, 0.18544636202351739, 0.1549387905442161, 0.887240251817563, 0.19872700832664447, 0.19990672920620212, 0.09983810122731973, 0.16951620390596056, 0.15165984321148862, 0.155224696087926, 0.21073765364673458, 0.40159882258833424, 0.6118944510666249, 0.4722706828039859, 0.20943907600886635, 0.10447737643709443, 0.6740544722108652, 0.5270229248139411, 0.20038668376623947, 0.20281771641555968, 0.18799833428135382, 0.1912810724520685, 0.18320111167144382, 0.20308766728672434, 0.19757120088704772, 0.20594312667068593, 0.21395596688626461, 0.08279350981175626, 0.08171107313842663, 0.08865495361493103, 0.08121463087761238, 0.09445672298618213, 0.08326435350647698, 0.08662070346773487, 0.08944185561958007, 0.08066380642012538]}, "mutation_prompt": null}
{"id": "e00b7d93-ea4f-45e4-bd6e-e57622118ab8", "solution": "import numpy as np\n\nclass AdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.1\n        self.exploration_phase = True \n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Adjust phase switch frequency\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor * 0.999  # Slightly enhanced cooling for inertia weight\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveBiPhaseSwarm", "description": "Temperature-Controlled Adaptive Bi-Phase Swarm Optimization with Enhanced Stochastic Exploration.", "configspace": "", "generation": 69, "fitness": 0.29441689914730446, "feedback": "The algorithm AdaptiveBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8451340137732886, 0.8265978053641345, 0.8562083672815942, 0.8623989789582946, 0.8436813632666645, 0.8369754499332518, 0.8625077381508026, 0.8549451977457532, 0.8360403757553972, 0.7187837692721548, 0.7022682074175075, 0.6678787540129965, 0.6160716288516513, 0.6009768909972798, 0.6670790616344163, 0.6719006203680274, 0.7275246717832369, 0.693059559646483, 0.681351528181054, 0.11063932444847124, 0.16404311135080263, 0.16348986973013702, 0.06992174503890491, 0.12831458517083305, 0.16669486690009838, 0.15772171585278139, 0.17829189082102004, 0.11771608554067114, 0.1461544532013208, 0.13154854962132212, 0.1526806226605688, 0.13466094013315155, 0.11822770635001578, 0.12770774102747873, 0.13936817995329498, 0.1305064491974608, 0.9843720167262375, 0.9791201264483708, 0.9905984132584592, 0.9815420068471172, 0.9857607297536949, 0.9767711019721582, 0.9858952931615276, 0.9871869437778739, 0.9863290531739166, 0.5742644649486504, 0.5427011326913063, 0.6139136685534547, 0.6210669164158025, 0.5358958597432044, 0.6472488950751558, 0.5455364970211207, 0.6114868043897845, 0.5542064698323212, 0.36327778203699557, 0.1990941780527884, 0.16984697680038408, 0.26457858249942456, 0.213874565091264, 0.20520582408672494, 0.22461334497633034, 0.3418293233225451, 0.21207927759431855, 0.18207999556278942, 0.18195673112207322, 0.16751817792263468, 0.1266078485470281, 0.19970990960115098, 0.1967682195321072, 0.17550283668570077, 0.1878286758697183, 0.17556998676454405, 0.2227651480380508, 0.11837568610224969, 0.15253085462542315, 0.17092094100362354, 0.13137127829812467, 0.1289988652812779, 0.24396224614264916, 0.09050337869464853, 0.1849902426115555, 9.999999999998899e-05, 0.0033102175560261182, 9.999999999998899e-05, 0.044497799607174815, 9.999999999998899e-05, 0.07128185623004046, 0.009723067064676849, 9.999999999998899e-05, 0.0368466677248962, 0.03947778038248051, 0.010518113756076142, 0.06601033552407354, 0.09895541860060675, 0.016391133774320443, 0.010453875270442614, 0.09107278030861221, 0.017936909186270333, 0.041032036877746925, 0.10156368497958523, 0.03308520803345705, 0.19094211116428828, 0.0728423306878262, 0.0749630869229655, 0.1516102464684591, 0.09622214821387065, 0.06916851035861615, 0.06909416344050756, 0.1723249234680383, 0.0413573627866195, 0.10510257664867151, 0.024307718261249334, 0.04654882272073424, 0.022625902266902864, 0.09061070514047165, 0.05722278375293832, 0.116604884080169, 0.4829805790330731, 0.4925726290692728, 0.502210527548524, 0.52912085239073, 0.49290088492849804, 0.5392552864958455, 0.514765912540235, 0.5322883693911142, 0.5387683056842827, 0.16852060749695918, 0.07726699405893522, 0.04058854486000907, 0.13679489867229755, 0.15721827956041856, 0.12627256262415754, 0.11258996053851256, 0.09039157849935142, 0.08677291388602393, 0.1963458900149806, 0.2783964969866558, 0.23603702074725064, 0.16940612957982448, 0.3517724958809173, 0.26394970367525106, 0.34137134531272406, 0.3308831362258935, 0.2582803440716126, 0.23143983474542018, 0.4153086541831914, 0.26891276671527875, 0.3598115603112624, 0.21003660332871965, 0.2925523016550322, 0.41087228922355645, 0.27459733435606026, 0.17486113305093187, 0.07761011738715484, 0.2219273329909064, 0.15721474868367313, 0.2953184463938452, 0.2174460574994712, 0.18584494978799337, 0.3303686807428192, 0.27802056386360585, 0.14425568969449798, 0.21437993907765052, 0.19628369973342452, 0.21149572172400677, 0.19186812927300556, 0.20188328189669302, 0.2481558588049333, 0.22436387426490934, 0.20400264368805132, 0.2034334961567058, 0.21340028308160586, 0.19288383366076245, 0.24255842769432778, 0.611016571814154, 0.24073352928543568, 0.24285508382971333, 0.23872320351446574, 0.21416600848368839, 0.4971054766629306, 0.8698177304602374, 0.1263609253935266, 0.15463457476200404, 0.8550512694847381, 0.20062611781108552, 0.19900169957135794, 0.09967304379955655, 0.16955507876285159, 0.1622487084341796, 0.1669414005570632, 0.2068090310252494, 0.5815030979365066, 0.2085156168319915, 0.16835302566031807, 0.20884559861197904, 0.2049003842381628, 0.5376505574476579, 0.5987203309537814, 0.20675484484247741, 0.19947446870784147, 0.22337869791102227, 0.17660196960639063, 0.20506818612834588, 0.23026925639681517, 0.18823246068437516, 0.19912469709920455, 0.18120907835915245, 0.08047358658130765, 0.08249333664069913, 0.08061269838629181, 0.07189753700185664, 0.0741601562840225, 0.07051838313264558, 0.08406298769867337, 0.10708774100627705, 0.09055730926745797]}, "mutation_prompt": null}
{"id": "549f7fa4-2f94-45fe-832a-54ed6f7d9801", "solution": "import numpy as np\n\nclass TemperatureControlledSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25  # Adjusted population size\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Modified mutation factor\n        self.crossover_rate = 0.75  # Modified crossover rate\n        self.c1 = 1.5  # Adjusted cognitive component\n        self.c2 = 2.5  # Adjusted social component\n        self.inertia_weight = 0.6  # Adjusted inertia weight\n        self.max_evaluations = budget\n        self.cooling_factor = 0.990  # Adjusted cooling factor for slower decay\n        self.exploration_factor = 0.15  # Adjusted exploration factor\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Adjusted probability\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            if evaluations % 150 == 0:  # Adjusted phase switch interval\n                self.exploration_phase = not self.exploration_phase\n\n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "TemperatureControlledSwarm", "description": "Temperature-Controlled Population Variance Optimization to Enhance Adaptive Swarm Search Efficiency.", "configspace": "", "generation": 70, "fitness": 0.29076344219129546, "feedback": "The algorithm TemperatureControlledSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8570914596880803, 0.8470280727465835, 0.8693606166129697, 0.8485880979816167, 0.8611375049142889, 0.8645283093750753, 0.8347042528757602, 0.8750152559431607, 0.8319855103696483, 0.7172629162305497, 0.5932845508567025, 0.6417724328070995, 0.751888331195605, 0.6465533029269419, 0.7071433684953522, 0.6367893559418896, 0.6231536225539398, 0.7198354104419717, 0.13673736741241882, 0.1787137606934417, 0.12188707979452573, 0.16544862677925554, 0.14413839450892751, 0.12364617639709197, 0.5395221945751938, 0.15165856037547076, 0.15321285032655518, 0.10780324880937764, 0.13870473491330393, 0.15169066715326185, 0.12999997660796414, 0.04719228095303807, 0.11422987695887932, 0.07006549588639632, 0.12296183626969126, 0.14067044524722405, 0.991959442282063, 0.9931119070023482, 0.9890808110655436, 0.970861275922441, 0.988446412065079, 0.9822343882620848, 0.9886550447882516, 0.980975404780803, 0.9823003535868065, 0.4708949261280634, 0.6442792840279937, 0.570451833594841, 0.4940757220279659, 0.5592250476664535, 0.5549699839724482, 0.5424319813383692, 0.5194968651479392, 0.46587148049549154, 0.2130502112432867, 0.21097064262450438, 0.23563589279547725, 0.3412268928268174, 0.19066347503763958, 0.2719614816947302, 0.13640346220381294, 0.2175754625270261, 0.11547000150075859, 0.1302326556283473, 0.17849842912439995, 0.29934808278757397, 0.1842162355461754, 0.12792323324152943, 0.25607013145404156, 0.18065218045301767, 0.27959807495272315, 0.19706414669798, 0.12803039659666338, 0.13050730987242765, 0.19510421742818185, 0.16913941231430707, 0.3078188421936495, 0.1700182948134985, 0.19815280769948385, 0.1359691131237245, 0.19383759031702907, 9.999999999998899e-05, 0.03390274773030577, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007115121085708553, 0.008633326556970133, 9.999999999998899e-05, 0.05004870945015771, 0.05006506127887422, 0.04024852047059502, 0.02560229794353508, 0.06386765257695459, 0.024976520883421505, 9.999999999998899e-05, 0.103137667828052, 0.012927292694889014, 0.012365838250185335, 0.048128057369462796, 0.12148226278563723, 0.054862164749603703, 0.13277092314674077, 0.10927015970796206, 0.07497843122896153, 0.1510383598057028, 0.10373457833937993, 0.07465858547720106, 0.06324829865012249, 0.04154551594999123, 0.32105884322330025, 0.02002365027381825, 0.03260969862550389, 0.028533594033329224, 0.18565831333158422, 0.06294187491399639, 0.08284200555415555, 0.5170990800884785, 0.5023219505284034, 0.5520618126408592, 0.6297056716153144, 0.5586981198079533, 0.5146197948538449, 0.5138782910398595, 0.5522994861789672, 0.5407797726578358, 0.13009001151569477, 0.11357524333358593, 0.11384277892193895, 0.15897313778403654, 0.10196167826916647, 0.10470200625506254, 0.11342696938264818, 0.10653140965330643, 0.09377188043979257, 0.17859298044346184, 0.2103028278335115, 0.22872237263922657, 0.15857652612298756, 0.24842574394571115, 0.1718399984182022, 0.2775965026051346, 0.4661528933605732, 0.20590776344160044, 0.2357797237933723, 0.3378057076086761, 0.2990325954043739, 0.2348942233016562, 0.17733755295428888, 0.26902887687066523, 0.41348320999817145, 0.4514045575638437, 0.39195789506652823, 0.22140093867876154, 0.22035665878636757, 0.25275854100102, 0.22750444277090498, 0.2003511196447081, 0.26395556111785523, 0.2655613618244068, 0.3093494762519067, 0.26313413020331555, 0.22409374260027437, 0.15515735443836387, 0.207886965860138, 0.21713002596336772, 0.16552493855654393, 0.23172702648457733, 0.2012732943099832, 0.20269785050503852, 0.2085258302160964, 0.19822039603896302, 0.22001300571388782, 0.2504119393875541, 0.19671209608848417, 0.21310748433072313, 0.24811321159295752, 0.22687679971712482, 0.19330641590403197, 0.19765908807520505, 0.8663054502947455, 0.16284768341108757, 0.15386232710107783, 0.8997249763405164, 0.1989629760789139, 0.1993776668980204, 0.09977253153654986, 0.16949619538083593, 0.21147960453381343, 0.15435904303140213, 0.15613477364181194, 0.11290470311420009, 0.20645093776033896, 0.4234480661979556, 0.20869799164690173, 0.10469723643029338, 0.7555625533351203, 0.56959101329089, 0.21855099267918543, 0.21085145069805444, 0.17890297039359504, 0.18669721841417697, 0.20242138467895388, 0.21488421686161663, 0.20908148530994808, 0.20649145232635502, 0.2038443905249192, 0.09869864768253589, 0.07465756642702237, 0.09879389346866796, 0.08404926130947044, 0.08847430485856744, 0.09361604009183089, 0.08743085863467626, 0.05203837533240785, 0.09100967081291855]}, "mutation_prompt": null}
{"id": "bfeca18a-c5aa-470c-bbbf-1b2bccd4d53e", "solution": "import numpy as np\n\nclass AdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.7\n        self.c1 = 2.0 \n        self.c2 = 2.0  \n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor for slower decay\n        self.exploration_factor = 0.1\n        self.exploration_phase = True  # Track exploration vs exploitation phase\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveBiPhaseSwarm", "description": "Adaptive Bi-Phase Swarm Optimization with Temperature-Based Exploration Control to Enhance Convergence.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8387792691726152, 0.8048915103839938, 0.8211624155187738, 0.8325145706575148, 0.8588221127773608, 0.826374519233586, 0.8506684697796467, 0.8584326311895265, 0.8366270557487654, 0.582804920422145, 0.7001992167962512, 0.6528117177159258, 0.5747720154845336, 0.6950825044065594, 0.6584910109928482, 0.6193200019868275, 0.7126938804250005, 0.5650319592982975, 0.14941087515682538, 0.1526706506150196, 0.1608774108266704, 0.16850388525540716, 0.07417087385047927, 0.15783063929036745, 0.14080057758713316, 0.17517186408614194, 0.6393569475226261, 0.13542651034650388, 0.15143753570967888, 0.10286908972848818, 0.16742331015241851, 0.13963195639629955, 0.4136990459224793, 0.12707470276910793, 0.11322211979242836, 0.09621661269038573, 0.9824954798073919, 0.9774720743151041, 0.990598539031067, 0.9773454926292526, 0.978245590869082, 0.9765005365313397, 0.984152955633922, 0.9876107861072613, 0.9868833169713772, 0.488639853625204, 0.6403105455618188, 0.6200905602009656, 0.6821251950692909, 0.5566528638734676, 0.6568247435900232, 0.5599444790308998, 0.6067419321972007, 0.558238587686372, 0.2214492445417674, 0.3509189017449368, 0.1713030722119403, 0.21845005198745604, 0.21580529563645867, 0.26140893709678126, 0.3759811124442348, 0.2272201655483218, 0.17539038547451713, 0.19070509153013204, 0.1291647034562986, 0.10694573415924002, 0.17362374325012164, 0.18741439340069566, 0.17302589746014474, 0.1782609584114021, 0.18843350356920385, 0.19041444014836229, 0.12870354143999851, 0.021259161804396576, 0.143517412667319, 0.2065055570215254, 0.17481577581270735, 0.18760033466879034, 0.2238689560109749, 9.999999999998899e-05, 0.12130431432530353, 9.999999999998899e-05, 0.015668250506885473, 0.005347024302129855, 0.007195193728892435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07531935473982754, 0.02766803853638089, 0.09322313452998188, 0.059386194878164544, 9.999999999998899e-05, 0.0016863888766088797, 0.10620891831262502, 0.033103127307588354, 0.05446690544611743, 0.1417936319358556, 0.0361185400164844, 0.22861174445561983, 0.07495533272296229, 0.09258265249854991, 0.06754435796248726, 0.09393339445122106, 0.0674310803751621, 0.09856368486138312, 0.0801832881697021, 0.08514185292835941, 0.2493159611977932, 0.017965841849578612, 0.08688795125730553, 0.008586335509034093, 0.09070138725542476, 0.08951001311637485, 0.09022298780690674, 0.4981969319592804, 0.5132174637570487, 0.5295751545552156, 0.5137227332826444, 0.510867710702765, 0.5053646584980389, 0.5453735534888602, 0.5160975656305622, 0.544258083839561, 0.08402447646853306, 0.07596612581995121, 0.0707339839636284, 0.091811563044777, 0.10664493081020177, 0.09444433394813112, 0.12883258402548492, 0.11171951237699307, 0.098571976284206, 0.17000069359458536, 0.20601375270856348, 0.32034178118040224, 0.16883749390193048, 0.3797864230768456, 0.3091152610076431, 0.3206162041834095, 0.3542995472239273, 0.19532499711331153, 0.29567976629592085, 0.4076556650901688, 0.3134545584907058, 0.46748140590139164, 0.22471466809486584, 0.5105102666049826, 0.6479604726711579, 0.5218784962430099, 0.1738277309670102, 0.1885436296955446, 0.28407560066176674, 0.17917131398607455, 0.20109640253015126, 0.20118073220792376, 0.23649660495351021, 0.1614708615859194, 0.24184991671668754, 0.2417276140158484, 0.20664020143206696, 0.2272206916194457, 0.17606136302987474, 0.19321741389675995, 0.19239961479019974, 0.20610560314886806, 0.21088802902801695, 0.22680393248537634, 0.19764612193475595, 0.6135316913651988, 0.18808997263537186, 0.22913005161805566, 0.24467664336260875, 0.6139963179698282, 0.24089177824426256, 0.20287995846652362, 0.7128630992276968, 0.21755767159102068, 0.8651209887282019, 0.1632239484345418, 0.1548145611500482, 0.8930728895328767, 0.2015734103282636, 0.19900736117783902, 0.09975719216523082, 0.16899748407950432, 0.16001286067913045, 0.6364803725813226, 0.20702264534165005, 0.16406134463609456, 0.20704190775575337, 0.16771222885984627, 0.20652565982634397, 0.14239516178566358, 0.7359718122370003, 0.4758168968680647, 0.24460403526587282, 0.2012701129332669, 0.20767197322660436, 0.20398595763522054, 0.20081266101346973, 0.19175143078323997, 0.18716392145007688, 0.18416075451951142, 0.1951112593910609, 0.08388077288172735, 0.09317538768764622, 0.1063966604443638, 0.09685325302711867, 0.09645922290194775, 0.04958669273436389, 0.07528195247203551, 0.07219991622216859, 0.07970804640499063]}, "mutation_prompt": null}
{"id": "31eb7b87-6a17-4df7-b0ec-3c6104f55847", "solution": "import numpy as np\n\nclass DynamicHierarchicalBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.c1 = 1.5 \n        self.c2 = 2.5  \n        self.inertia_weight = 0.6\n        self.max_evaluations = budget\n        self.cooling_factor = 0.993\n        self.exploration_factor = 0.15\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n            else:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 80 == 0:\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "DynamicHierarchicalBiPhaseSwarm", "description": "Dynamic Hierarchical Bi-Phase Swarm Optimization with Adaptive Exploration-Exploitation Balance to Enhance Convergence Robustness.", "configspace": "", "generation": 72, "fitness": 0.2961641753887047, "feedback": "The algorithm DynamicHierarchicalBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8539919023249356, 0.8935307363762199, 0.8601093180503236, 0.8443216309777638, 0.8496039984588887, 0.8512041331847134, 0.8562227528377301, 0.8632964619770902, 0.829248523152692, 0.6862308071896897, 0.5859154845062764, 0.6620368796723399, 0.7445267289774328, 0.7344071844286901, 0.711791053352445, 0.7771914591529607, 0.7115947863767336, 0.6638805701015273, 0.139352026664048, 0.1465381838466967, 0.149649417202103, 0.1627967141929002, 0.07491874328107773, 0.17426624466311913, 0.14780162351264203, 0.12086000452718249, 0.1513516985010689, 0.16893237274541084, 0.1333908349535483, 0.13897818530779893, 0.13855818023772204, 0.11436142581277997, 0.12871573991553598, 0.06905713734005736, 0.10345495373010705, 0.14640625715247169, 0.989769359976661, 0.9719761224247847, 0.9900986306423712, 0.9884098280903835, 0.9878112595183722, 0.9868853808170311, 0.9896896126094034, 0.9900160206769612, 0.9893122354134986, 0.5662249101989589, 0.5148455760914222, 0.6577619161594697, 0.7068739914866935, 0.6548063939637265, 0.4662700489862899, 0.548922226935307, 0.5727343657989676, 0.5038804723831101, 0.826870852710185, 0.2183366972548786, 0.22985219830928294, 0.1923786548023393, 0.20912381627924737, 0.8893709768857332, 0.21549810569381966, 0.17728454277406347, 0.2658439867581873, 0.1003610240706605, 0.18330966291738793, 0.12986507463885322, 0.18446937595493273, 0.19241952925267258, 0.18449613237442952, 0.18231146269779652, 0.214602295822945, 0.18949618556458725, 0.21331386241061656, 0.11929388122774731, 0.14877748902880472, 0.19494367875991736, 0.18063673947507064, 0.18646754075592054, 0.13045269412714244, 9.999999999998899e-05, 0.12592948984445762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.015284386731164834, 9.999999999998899e-05, 9.999999999998899e-05, 0.05326435508377414, 9.999999999998899e-05, 0.05071093717982089, 0.05045361173143681, 0.031702681052150905, 0.05142610081965615, 0.04987794675350232, 9.999999999998899e-05, 0.014415681229344557, 0.07012849334911153, 0.05349953494816495, 0.04571870435788983, 0.07208916858135295, 0.03598663202401753, 0.06624171647957278, 0.16791267830813617, 0.07605134940224456, 0.0785000824998866, 0.10400642085973999, 0.1189734515772436, 0.06989278497616813, 0.04643505028767103, 0.044504625911335416, 0.09516225168149539, 0.19329883719879382, 0.12251884121607615, 0.06639901105658641, 0.13899794981184055, 0.057716783751780576, 0.1304420535933527, 0.5411863523437117, 0.5116427582405378, 0.5221531935579683, 0.5101396187403261, 0.5517944525448255, 0.5746675657742828, 0.5459575873419339, 0.5433458349930855, 0.566578180825119, 0.0728853843764824, 0.05422269343414898, 0.07114171714897444, 0.1394544324165694, 0.08329699160556359, 0.1164358043413446, 0.11069237253579378, 0.08903652356324021, 0.09526039261253116, 0.15653634624156298, 0.20457217288045282, 0.21024699919324297, 0.26562565339590394, 0.4118807199762625, 0.1886267558332625, 0.40085318781460544, 0.1947345578038494, 0.2684332244995663, 0.25763013972133764, 0.40438988276191323, 0.43935758697381533, 0.29773509065960047, 0.37527443869397425, 0.4610166486681484, 0.4673378005289788, 0.4257820649652796, 0.16680764992564945, 0.0867804203185002, 0.23323447757488502, 0.27937791305413084, 0.175265728948379, 0.2384016733923865, 0.19680289398005402, 0.20512466079392944, 0.3044314793570173, 0.2522465494849394, 0.1929148756330784, 0.21876158382070565, 0.20772708862362455, 0.24228583556401395, 0.16322871322079013, 0.19843166607653906, 0.21838444313665029, 0.19886723588839228, 0.21885271651442195, 0.20257652841215557, 0.23532514649244318, 0.20383503967074634, 0.1928352956346523, 0.2037888987692681, 0.18735719420982144, 0.18063582398675282, 0.1820995292797224, 0.24361634665046517, 0.8767251636123846, 0.1624189269026347, 0.1542065789537519, 0.8871406997230706, 0.20005938241974885, 0.13113856707608507, 0.10003962518021636, 0.1701787100336143, 0.152795373181409, 0.08296604696361831, 0.21052371967167505, 0.1240664950814051, 0.5157342714368145, 0.16807771486006062, 0.20673191878401997, 0.10490800232791808, 0.7538855608670837, 0.660410935175775, 0.18661028787990952, 0.18713910393387845, 0.23192500757602985, 0.2369574222127484, 0.17982406063643064, 0.19527745947327813, 0.19366350288055667, 0.2105815024693316, 0.2030822037753921, 0.10699138535151165, 0.09313316104924252, 0.09583218239056746, 0.09721930123106193, 0.09410010270036151, 0.0845100325823076, 0.09586821904641218, 0.053324029624756575, 0.08059211176972658]}, "mutation_prompt": null}
{"id": "2ef6d269-f7c6-4204-842f-b22c7b01340d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveBiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.6, 0.6, (self.population_size, self.dim))  # Adjusted velocity range\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Slightly adjusted mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.65  # Adjusted inertia weight\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.1\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        diversity = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = 0.5 * (trial_vector + mutant_vector)\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            if evaluations % 95 == 0:  # Slightly adjusted phase switch frequency\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedAdaptiveBiPhaseSwarm", "description": "Enhanced Adaptive Bi-Phase Swarm Optimization incorporating Stochastic Perturbation to Improve Solution Diversity and Convergence.", "configspace": "", "generation": 73, "fitness": 0.29562446743220633, "feedback": "The algorithm EnhancedAdaptiveBiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.8194386485487775, 0.8264099500825596, 0.8314142863195075, 0.8324286440867621, 0.8395839737277919, 0.8671518052132283, 0.8624898814282682, 0.8528480329252297, 0.8411368109200067, 0.7028662497052498, 0.5508412916964778, 0.7185070118075199, 0.7108636924147547, 0.6520992168154504, 0.6861972772365226, 0.6573167579905557, 0.6956138610305237, 0.6947023370419916, 0.1542347592695531, 0.14943523127406477, 0.14396922243900845, 0.16520418598080144, 0.07283532101478973, 0.16872784392935047, 0.15071678542389655, 0.15006265185970025, 0.14315520444061258, 0.13145997795982423, 0.09809249355394456, 0.11482874688657796, 0.14645988109487917, 0.10837445602319584, 0.13991805523904477, 0.1629342044699903, 0.1099613239646402, 0.1442470030099413, 0.9796157686306189, 0.975852910262322, 0.9905935924234861, 0.9733816276437273, 0.979741656061054, 0.9699518945946126, 0.9839640800077097, 0.9872888369006824, 0.9868719330057282, 0.60539125717674, 0.6094133944158897, 0.6056519075263963, 0.5750616546459517, 0.593896974771383, 0.5691791670337712, 0.5225887396482728, 0.529794013952404, 0.5056975770142759, 0.22441926654484046, 0.20775442134948086, 0.16715236230026165, 0.1915421990279751, 0.2729659594769972, 0.3621532059924003, 0.17756390842280212, 0.22976867828444036, 0.15045072647290803, 0.17923361560197937, 0.19182047540792213, 0.19289068043033042, 0.1253594070324292, 0.1882960306156971, 0.17726582165079563, 0.18763354442284685, 0.1736684792457618, 0.17264282365520955, 0.20251958408640824, 0.002013835119502816, 0.10527227133870187, 0.12436486789525336, 0.21473346904914759, 0.20901914048742465, 0.21992282403405128, 0.13156046998510407, 0.10067047418293018, 9.999999999998899e-05, 0.0025560282849810267, 0.006817593714309456, 0.05470739198425778, 9.999999999998899e-05, 9.999999999998899e-05, 0.0762873011983567, 9.999999999998899e-05, 0.001980079602426077, 0.06596191955329889, 0.024189052979759484, 0.04935237397925518, 0.09680080461221152, 9.999999999998899e-05, 0.01518362929524153, 0.06093749408973703, 0.06805126583520249, 0.053505337627069105, 0.09527273775921563, 0.032590196929651705, 0.045326317874250566, 0.07576831642608994, 0.07823551988166022, 0.11655934919965438, 0.0989215825066454, 0.06651847817338441, 0.08204441111289595, 0.0866532988637222, 0.10087636319871984, 0.2155411192410014, 0.017911340001557585, 0.08851379867200138, 0.021785502088654485, 0.11519492521334729, 0.16694154258436245, 0.08274933153121289, 0.5265579427637659, 0.5119297106266663, 0.5287504646642889, 0.5558736718896873, 0.49651324902336025, 0.47673671648505933, 0.5384671767930744, 0.5318013137369129, 0.5383810766265511, 0.11974274464684131, 0.12008094857827889, 0.08195917040531708, 0.09632036382229558, 0.10485251619570701, 0.12500162528313108, 0.0714117151566599, 0.10680301108709556, 0.1002838124939266, 0.20973022821990717, 0.18948199485910733, 0.5032999773746647, 0.26987477146011296, 0.27184045392672884, 0.20437200508923348, 0.20565460809744296, 0.183633305828526, 0.19434670218239902, 0.3363484032616786, 0.35243455624000986, 0.40994506532146435, 0.3188047911286428, 0.3878689046165871, 0.5031165440252434, 0.3703193488457287, 0.6056780749328965, 0.33171627018585315, 0.07740052830621114, 0.1824533073647583, 0.1620092527813386, 0.2601923922147499, 0.19911926628121468, 0.24444263677644995, 0.21308908188932107, 0.4378224509101266, 0.07460808547294617, 0.21542905904240428, 0.1807956165071013, 0.21928457186051065, 0.22631992430358283, 0.24710999156030578, 0.21761033411870945, 0.2255736048703436, 0.2102489088812295, 0.20226378902575104, 0.24374143598207632, 0.19951266266527046, 0.21538558241575767, 0.21906176873843342, 0.7340583123151091, 0.23142545726093333, 0.23579510813826488, 0.25839943619945904, 0.20800781488660414, 0.8553137627956475, 0.12628274425616204, 0.15470849188152846, 0.8980947438322113, 0.19943720203318127, 0.19906677976652953, 0.1488454674372106, 0.16931894170980522, 0.16024397434719684, 0.5255041713330109, 0.2097637093179464, 0.5511709686424338, 0.21096047256342576, 0.16889361314351536, 0.21005316042401623, 0.10479017899669585, 0.636067222506022, 0.8072661300914932, 0.20144641312016243, 0.2149385052841446, 0.1800268135808294, 0.19226405007572844, 0.20991319793900043, 0.20190627986464382, 0.2054752233727597, 0.18127651077968554, 0.20497462798667176, 0.09590633104389035, 0.09361590270605624, 0.0909893887756893, 0.0905924069771783, 0.08505226305491664, 0.09229566636172826, 0.08676206891400984, 0.08291953393618245, 0.10029742119369056]}, "mutation_prompt": null}
{"id": "b0377923-105f-4635-b02b-8b35e02070fe", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly reduced mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Increased cognitive component\n        self.c2 = 1.9  # Decreased social component\n        self.inertia_weight = 0.6  # Reduced inertia weight for faster convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.996  # Adjusted cooling factor for different decay rate\n        self.exploration_factor = 0.15  # Increased exploration factor\n        self.adaptive_mutation = 0.05\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly reduced random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Switch phases every 120 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Enhanced Multi-Phase Swarm Optimization with Adaptive Mutation Control for Improved Convergence.", "configspace": "", "generation": 74, "fitness": 0.3049017299292589, "feedback": "The algorithm EnhancedMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "e7180e4f-f7f9-4fc6-b8cb-e230edd7bc6f", "metadata": {"aucs": [0.868376597977421, 0.8599684296209293, 0.881907284699789, 0.8817981304763994, 0.8782286169703105, 0.8320329598309161, 0.8753340250728163, 0.8567827600452298, 0.835133327110839, 0.7334069552497461, 0.7233259212052423, 0.7085616276548696, 0.733299588455351, 0.7149908659689703, 0.7001682747057044, 0.5544609435360084, 0.5824413013758059, 0.7238386223643003, 0.17485318973781738, 0.113609530084268, 0.1453708106762962, 0.15530403739385856, 0.17077266203709218, 0.13798185016062947, 0.05780572993975053, 0.12084256774785285, 0.4625359953088469, 0.14492150656084324, 0.17978128376662916, 0.46457013056396335, 0.15437340104484243, 0.11840379753070007, 0.13896075563128685, 0.14773215449486088, 0.15227169427736553, 0.14244028043555645, 0.9872043760238632, 0.9826347069352321, 0.9906572222909417, 0.9869103897766742, 0.9871096512289319, 0.9865068892254468, 0.9866096555794052, 0.986702912800172, 0.9865456688891193, 0.6243378369734709, 0.655891274823478, 0.6412361058508882, 0.6829195065458997, 0.5390490086371699, 0.6223520742567127, 0.6455032409951298, 0.6194513764114673, 0.5710635671061743, 0.17291478181165143, 0.15540101703690123, 0.21480621708444758, 0.2797133463130468, 0.2663872376702028, 0.2081961764314565, 0.15855368869687592, 0.16581229781628914, 0.2007275349479416, 0.10238427582035126, 0.19362196704791135, 0.17827829011417673, 0.13029928051099504, 0.18374229246624574, 0.1833126808761777, 0.19444232943209738, 0.20210314966651066, 0.11807753009792976, 0.19527108350050149, 0.11887387781710512, 0.13115108585216695, 0.1959254459985802, 0.3745258816609588, 0.19862872921422636, 0.21880767718245353, 9.999999999998899e-05, 0.21613882992118438, 9.999999999998899e-05, 9.999999999998899e-05, 0.032233289729648784, 0.07820629162496384, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012314830679409638, 0.05361080554430486, 9.999999999998899e-05, 0.044744112734891095, 0.041659896506688, 0.10448106141815205, 0.08561223903948534, 9.999999999998899e-05, 0.01101379834529781, 0.043449448526291956, 0.060492290223763456, 0.050142302679423434, 0.03470904886226911, 0.06428236115890995, 0.1923712087768209, 0.1271997916351364, 0.3592906978350021, 0.0896771782588196, 0.12403831002031951, 0.2941897487951045, 0.07203749355686573, 0.04808698111170673, 0.04301348783049741, 0.237284352233205, 0.051048453628932844, 0.031081794774595606, 0.020001997150258077, 0.08236011505266472, 0.09169006076457276, 0.05825995482400681, 0.5160779798025504, 0.5796718355648198, 0.539037154430671, 0.5630524210959394, 0.5415166670447795, 0.5484783027824239, 0.6026075154668025, 0.5607308275421558, 0.603307114501201, 0.10886850451654173, 0.14296516741076448, 0.09823699666623364, 0.11458275716142874, 0.0786617406758624, 0.10463296813643197, 0.06121408269486106, 0.09302726097936598, 0.10513524726154277, 0.1777790768599805, 0.3640676356715433, 0.22311799683478328, 0.3805160830002673, 0.35827514970694707, 0.17175705945018838, 0.6640912905101208, 0.22249816424392588, 0.23251846722486735, 0.2954736475202452, 0.20423628963245233, 0.20778907851132156, 0.264777093977661, 0.22020398567240063, 0.34998096525833355, 0.42314637397319865, 0.28676405053739396, 0.2841995953298062, 0.2504068629422983, 0.28588448896592633, 0.20060387871699337, 0.16945242632172552, 0.22385982946607497, 0.20985445888712173, 0.23613239106807582, 0.28471999455351693, 0.2339006697889019, 0.20129035333994205, 0.1963313106701845, 0.2051328529573766, 0.21602494288112384, 0.19705935197439195, 0.22567250893333413, 0.2364148322872024, 0.1859805100112759, 0.21959360980614862, 0.18871224540812614, 0.22249415541174045, 0.20419833455460723, 0.7798448461526082, 0.2237564108864183, 0.23000967375886783, 0.23600979928712695, 0.23996097935255534, 0.2033053236306528, 0.9158690216328449, 0.12580033805055169, 0.1543471842335693, 0.8831790355437801, 0.20042463491202334, 0.19749025832002876, 0.18793212426113015, 0.16997220968182958, 0.1532131912444593, 0.690971587890103, 0.21155425263723027, 0.4037971599487734, 0.6791365408320804, 0.16880412353327612, 0.2114818110771438, 0.1044347270694439, 0.21148496164823205, 0.5891772424141132, 0.1890836243706473, 0.20788497984744825, 0.19787210464994365, 0.18639288423842515, 0.21463688487040278, 0.18456701096454842, 0.1847788017624843, 0.1833852816776771, 0.2011370496193734, 0.06616231695229746, 0.10823231201569328, 0.1050999496395596, 0.08877648688834217, 0.07175798659968424, 0.1436180603852727, 0.09201977303326436, 0.08702563072685932, 0.09209869712104124]}, "mutation_prompt": null}
{"id": "2529300b-5181-4e09-8ff7-3ad3f2e9d755", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly reduced mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Increased cognitive component\n        self.c2 = 1.9  # Decreased social component\n        self.inertia_weight = 0.6  # Reduced inertia weight for faster convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.996  # Adjusted cooling factor for different decay rate\n        self.exploration_factor = 0.15  # Increased exploration factor\n        self.adaptive_mutation = 0.05\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly reduced random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Switch phases every 120 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Enhanced Multi-Phase Swarm Optimization with Adaptive Mutation Control for Improved Convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.868376597977421, 0.8599684296209293, 0.881907284699789, 0.8817981304763994, 0.8782286169703105, 0.8320329598309161, 0.8753340250728163, 0.8567827600452298, 0.835133327110839, 0.7334069552497461, 0.7233259212052423, 0.7085616276548696, 0.733299588455351, 0.7149908659689703, 0.7001682747057044, 0.5544609435360084, 0.5824413013758059, 0.7238386223643003, 0.17485318973781738, 0.113609530084268, 0.1453708106762962, 0.15530403739385856, 0.17077266203709218, 0.13798185016062947, 0.05780572993975053, 0.12084256774785285, 0.4625359953088469, 0.14492150656084324, 0.17978128376662916, 0.46457013056396335, 0.15437340104484243, 0.11840379753070007, 0.13896075563128685, 0.14773215449486088, 0.15227169427736553, 0.14244028043555645, 0.9872043760238632, 0.9826347069352321, 0.9906572222909417, 0.9869103897766742, 0.9871096512289319, 0.9865068892254468, 0.9866096555794052, 0.986702912800172, 0.9865456688891193, 0.6243378369734709, 0.655891274823478, 0.6412361058508882, 0.6829195065458997, 0.5390490086371699, 0.6223520742567127, 0.6455032409951298, 0.6194513764114673, 0.5710635671061743, 0.17291478181165143, 0.15540101703690123, 0.21480621708444758, 0.2797133463130468, 0.2663872376702028, 0.2081961764314565, 0.15855368869687592, 0.16581229781628914, 0.2007275349479416, 0.10238427582035126, 0.19362196704791135, 0.17827829011417673, 0.13029928051099504, 0.18374229246624574, 0.1833126808761777, 0.19444232943209738, 0.20210314966651066, 0.11807753009792976, 0.19527108350050149, 0.11887387781710512, 0.13115108585216695, 0.1959254459985802, 0.3745258816609588, 0.19862872921422636, 0.21880767718245353, 9.999999999998899e-05, 0.21613882992118438, 9.999999999998899e-05, 9.999999999998899e-05, 0.032233289729648784, 0.07820629162496384, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012314830679409638, 0.05361080554430486, 9.999999999998899e-05, 0.044744112734891095, 0.041659896506688, 0.10448106141815205, 0.08561223903948534, 9.999999999998899e-05, 0.01101379834529781, 0.043449448526291956, 0.060492290223763456, 0.050142302679423434, 0.03470904886226911, 0.06428236115890995, 0.1923712087768209, 0.1271997916351364, 0.3592906978350021, 0.0896771782588196, 0.12403831002031951, 0.2941897487951045, 0.07203749355686573, 0.04808698111170673, 0.04301348783049741, 0.237284352233205, 0.051048453628932844, 0.031081794774595606, 0.020001997150258077, 0.08236011505266472, 0.09169006076457276, 0.05825995482400681, 0.5160779798025504, 0.5796718355648198, 0.539037154430671, 0.5630524210959394, 0.5415166670447795, 0.5484783027824239, 0.6026075154668025, 0.5607308275421558, 0.603307114501201, 0.10886850451654173, 0.14296516741076448, 0.09823699666623364, 0.11458275716142874, 0.0786617406758624, 0.10463296813643197, 0.06121408269486106, 0.09302726097936598, 0.10513524726154277, 0.1777790768599805, 0.3640676356715433, 0.22311799683478328, 0.3805160830002673, 0.35827514970694707, 0.17175705945018838, 0.6640912905101208, 0.22249816424392588, 0.23251846722486735, 0.2954736475202452, 0.20423628963245233, 0.20778907851132156, 0.264777093977661, 0.22020398567240063, 0.34998096525833355, 0.42314637397319865, 0.28676405053739396, 0.2841995953298062, 0.2504068629422983, 0.28588448896592633, 0.20060387871699337, 0.16945242632172552, 0.22385982946607497, 0.20985445888712173, 0.23613239106807582, 0.28471999455351693, 0.2339006697889019, 0.20129035333994205, 0.1963313106701845, 0.2051328529573766, 0.21602494288112384, 0.19705935197439195, 0.22567250893333413, 0.2364148322872024, 0.1859805100112759, 0.21959360980614862, 0.18871224540812614, 0.22249415541174045, 0.20419833455460723, 0.7798448461526082, 0.2237564108864183, 0.23000967375886783, 0.23600979928712695, 0.23996097935255534, 0.2033053236306528, 0.9158690216328449, 0.12580033805055169, 0.1543471842335693, 0.8831790355437801, 0.20042463491202334, 0.19749025832002876, 0.18793212426113015, 0.16997220968182958, 0.1532131912444593, 0.690971587890103, 0.21155425263723027, 0.4037971599487734, 0.6791365408320804, 0.16880412353327612, 0.2114818110771438, 0.1044347270694439, 0.21148496164823205, 0.5891772424141132, 0.1890836243706473, 0.20788497984744825, 0.19787210464994365, 0.18639288423842515, 0.21463688487040278, 0.18456701096454842, 0.1847788017624843, 0.1833852816776771, 0.2011370496193734, 0.06616231695229746, 0.10823231201569328, 0.1050999496395596, 0.08877648688834217, 0.07175798659968424, 0.1436180603852727, 0.09201977303326436, 0.08702563072685932, 0.09209869712104124]}, "mutation_prompt": null}
{"id": "4b235bb1-289d-4ed4-972e-bf59b16e97fe", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25  # Increased population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Adjusted velocity range\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.crossover_rate = 0.75  # Slightly increased crossover rate\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7  # Increased inertia weight for stability\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Slightly adjusted cooling factor\n        self.exploration_factor = 0.2  # Increased exploration factor\n        self.adaptive_mutation = 0.06  # Increased adaptive mutation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Slightly increased random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveParticleSwarm", "description": "Adaptive Particle Swarm with Enhanced Exploration and Exploitation Phases for Efficient Global Optimization.", "configspace": "", "generation": 76, "fitness": 0.2997663761925161, "feedback": "The algorithm AdaptiveParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8029860598701621, 0.7637338073425559, 0.803872339198595, 0.8235450560805444, 0.776499434007607, 0.784190859927527, 0.7761159014897732, 0.7861567650199012, 0.7552998242995274, 0.5574165836206828, 0.6421812886138573, 0.566358873650692, 0.5325065938855744, 0.6496737704512632, 0.614931976468837, 0.6441425733435149, 0.4890679191170093, 0.6370693736989529, 0.17302210918564975, 0.136436946781481, 0.4037712628165263, 0.14205733740531812, 0.12862738300198817, 0.23295456231806355, 0.4994322178913623, 0.15779854068696675, 0.4649230350188368, 0.1259804617507443, 0.1547465300716222, 0.13308033823571863, 0.12558492226529283, 0.14496803399168512, 0.13506405274624944, 0.10503496507365395, 0.11056031466529093, 0.1187809558389532, 0.9880686159881684, 0.9884411994610162, 0.9876529245924445, 0.9783469649674394, 0.9876156992049571, 0.987428648218377, 0.9855815424516494, 0.9846552550040417, 0.98654094937798, 0.5231330315874293, 0.42114901081694156, 0.399548271202522, 0.5770108868871737, 0.48389280799112944, 0.5526919215464574, 0.517994285710524, 0.4937905771987392, 0.44721562957930394, 0.7051431079191016, 0.21057163976553117, 0.3047237098899418, 0.21246344548320417, 0.21011029620628052, 0.2096581147111628, 0.17112517995910204, 0.14952595704380978, 0.319965089413648, 0.1315458296215627, 0.2303936910238471, 0.16624550625064094, 0.1746275189973121, 0.23188541141394137, 0.12908474692210725, 0.179482490277864, 0.10987660526846244, 0.2794098783465696, 0.18901410679299058, 0.11115455998752755, 0.17609201508805894, 0.1832885761124089, 0.14899391772620052, 0.12443365644216742, 0.2192812815579398, 0.12574636040444165, 0.2077773458677905, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006841377998063947, 9.999999999998899e-05, 0.03363892997343976, 0.010154281812494781, 9.999999999998899e-05, 9.999999999998899e-05, 0.049841816828468666, 0.07139227126483272, 0.04722923523592726, 0.0590119925705882, 9.999999999998899e-05, 0.034226923619741, 0.06136563593355382, 0.05564175193524057, 0.05066885292506562, 0.047171157235061045, 0.04046881939761482, 0.17823307566995938, 0.3155103310587013, 0.08379048509128828, 0.06775506105997064, 0.21627453265968477, 0.2270181031669367, 0.06342816760144565, 0.07812330772134901, 0.04172809399909516, 0.022246518321493602, 0.022967045990898605, 0.061457966170613165, 0.0991571832871685, 0.09052892547490377, 0.056836119975631316, 0.15315663295264514, 0.48214282619191373, 0.46699727945151603, 0.5461362165703885, 0.5622908265558654, 0.4942179094279422, 0.540083828935665, 0.5161084101724255, 0.5127262333884177, 0.5709403094819421, 0.07898716510283743, 0.08950192962302828, 0.09043880716522013, 0.09018624507273199, 0.5246931325982687, 0.09912692690726721, 0.09111567972662848, 0.09544255750590513, 0.07834694517744734, 0.18955632538106537, 0.22432730941927592, 0.43706249780232387, 0.43256349099055647, 0.2679876302508336, 0.18485063547319347, 0.17090302568024252, 0.4481640033377473, 0.27811504381225116, 0.4242374061202183, 0.38794110386639136, 0.3008400217776158, 0.27242169566865226, 0.2199302043200848, 0.39382966510177453, 0.465793641829771, 0.4175546095071855, 0.4942781406778186, 0.23816247049575678, 0.1930111827889155, 0.19994704079596304, 0.16541919666878058, 0.3732231685590074, 0.2316362899803157, 0.2752700890592946, 0.31722284816292645, 0.39813508553534527, 0.2122814799861451, 0.21192800839518489, 0.21507886609128124, 0.1818331408628383, 0.20859866603390753, 0.20051082510012286, 0.1809962497124089, 0.206359433761106, 0.23881054302261417, 0.23757620281368075, 0.20315936697133796, 0.5874875244486737, 0.21648749113412302, 0.2144317096694902, 0.23475312080895905, 0.2198898801298963, 0.22417516452505837, 0.5842312951951119, 0.8756600267285876, 0.16907588290017173, 0.15379934872163792, 0.837576755160621, 0.20027663837545884, 0.19834450357174105, 0.19558788201056254, 0.16999445513794087, 0.2095363864885339, 0.08222419869851438, 0.1550451890956217, 0.737810237588189, 0.2050005558755359, 0.4546453602584042, 0.20800912356029388, 0.10481951303526893, 0.5840206000163387, 0.5608023971890416, 0.1886704125353359, 0.1769740122717589, 0.18253742519978167, 0.23792124103999202, 0.22326191513404847, 0.19058972341664748, 0.18778323918791373, 0.2085840445826449, 0.18657175678760163, 0.09706201960286731, 0.0952261169167905, 0.08531426010768406, 0.08966538093426457, 0.09345440813221861, 0.09727644261226576, 0.08052703473435685, 0.07490994639826254, 0.09300697575216199]}, "mutation_prompt": null}
{"id": "428d586c-e61b-4c08-9025-5656ef9821d8", "solution": "import numpy as np\n\nclass DynamicHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.65\n        self.c1 = 2.0  # Balanced cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.1\n        self.adaptive_mutation = 0.04\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "DynamicHybridSwarm", "description": "Dynamic Hybrid Swarm Optimization with Dual Phase Control and Adaptive Feedback for Enhancing Convergence.", "configspace": "", "generation": 77, "fitness": 0.2841562205213029, "feedback": "The algorithm DynamicHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8168915715638556, 0.8082257016821254, 0.8312437552456283, 0.8417175101410632, 0.839936030608318, 0.8312271622097136, 0.8135779488216803, 0.7892671607806974, 0.840781685522682, 0.7208623124012585, 0.6175703998278115, 0.6558452834747739, 0.6067498756997612, 0.6520646588911612, 0.6384687457423646, 0.7031113987468637, 0.5596039388010641, 0.7419163344361814, 0.5969879445116533, 0.03646324855880867, 0.1457729519262242, 0.0745627141812043, 0.07221263297830971, 0.3516262057779542, 0.14698753769046757, 0.15490851466532674, 0.17083071236833225, 0.14571200966450948, 0.12519150698332648, 0.14335771753430704, 0.11543061162443613, 0.13203302793215665, 0.13248348502513163, 0.14702843334387394, 0.14659134923837536, 0.1388464108880062, 0.9875897134264439, 0.982754740886472, 0.990688290145433, 0.9875455407932383, 0.9876495396982377, 0.9831120997238991, 0.9870902492009767, 0.9874082401384766, 0.989458704446318, 0.5857400078958266, 0.5504478216231541, 0.47506089935929163, 0.5004993805869694, 0.5781888503276538, 0.6050423094055373, 0.545144420948735, 0.4877261451615488, 0.5981472251443825, 0.16971218819083278, 0.22089407748022027, 0.16729823444860592, 0.2711084195648996, 0.26928799092858735, 0.11606147320882187, 0.12070315018520017, 0.15030628159443027, 0.23823536690001812, 0.09603728018976365, 0.17017050873795836, 0.17743199485484273, 0.1749114036727185, 0.1980127189036135, 0.1732127068966287, 0.19786051568249863, 0.17255154831021613, 0.30439409029450715, 0.1894506045451556, 0.11676992687528198, 0.19822373191288445, 0.12439651407330765, 0.24311269501705657, 0.21311699371058257, 0.2117424406988404, 9.999999999998899e-05, 0.1964298669974246, 9.999999999998899e-05, 9.999999999998899e-05, 0.0922514434226801, 0.04372811301968138, 9.999999999998899e-05, 0.0659300933628949, 0.01768788588790271, 9.999999999998899e-05, 0.06843201661781273, 0.08687434810530192, 0.027992998343016717, 0.08399717988712274, 0.0561019973252167, 0.011906522290705657, 0.004499960802277547, 0.07444357463871987, 0.04337460944817362, 0.05554369704653783, 0.046835963025294025, 0.11349548645681029, 0.03948602854507022, 0.08626648462693809, 0.06811296269070499, 0.07364065436962208, 0.09257889814374232, 0.06373848134001525, 0.06917254190733546, 0.0425298729964827, 0.04123161802163722, 0.14627228679228788, 0.060162839304429894, 0.007215658146402126, 0.045080939392689645, 0.0782352045999698, 0.057271467889616345, 0.2243280891212004, 0.5344883855344886, 0.4893281329209799, 0.5388317064944457, 0.5382056762432978, 0.5170042527038057, 0.5164667005607009, 0.5520668497534371, 0.5579043665697874, 0.5678398366743126, 0.07604928192037552, 0.0591324974561489, 0.08579808267392308, 0.13518618316485242, 0.11383689186753876, 0.12084422741031264, 0.10932448056637023, 0.09399557258483271, 0.1027896225085918, 0.2524696103622319, 0.180837533089648, 0.19855497754545326, 0.36387092707068025, 0.20087198890192381, 0.1760460190802049, 0.4036654681879366, 0.17028662029348485, 0.22432984828069513, 0.3501691877695401, 0.21271533194534287, 0.4493279317757217, 0.24312372135941418, 0.19715762688587535, 0.2701390173283724, 0.19134621896308712, 0.29569397993412727, 0.2908369967127312, 0.16029804866264508, 0.2101886247968181, 0.16703807387504277, 0.27159707079987605, 0.18953743107579868, 0.1826608990655233, 0.20566940328459105, 0.3343263168497992, 0.09774736596626099, 0.22906441520930887, 0.185654115722801, 0.20180124053439774, 0.20208954069102514, 0.15401589529080828, 0.21002194218824355, 0.20572937635682498, 0.20228606996974674, 0.2028211653088311, 0.23746624796189164, 0.32964547304885305, 0.2529974194076068, 0.2011026225316136, 0.23015813811792984, 0.19266070366714927, 0.22976813795470763, 0.21536621306587844, 0.22004903034447854, 0.8730319121469765, 0.12642486429408129, 0.15331555430408383, 0.8575209173333607, 0.19812264169369398, 0.19506283061024143, 0.12251351258008669, 0.16962997175287853, 0.15258500564856126, 0.5730626968708001, 0.2083196680909386, 0.34264648924307994, 0.20286204398018903, 0.1686439412660471, 0.2098600038548415, 0.10479863131768996, 0.20875761116999414, 0.8125938015752296, 0.20034405256060206, 0.18142822140240988, 0.20097832094746393, 0.19650244281606333, 0.21905197942926635, 0.18741705711438916, 0.1834435405537015, 0.2030340254945966, 0.19333675687562257, 0.08525331413821369, 0.08708947260761013, 0.09081294937116868, 0.09711892646033515, 0.08193600260159495, 0.07057751166206583, 0.08855290596726029, 0.08163078409010138, 0.08145122608787736]}, "mutation_prompt": null}
{"id": "e552d4e8-02b3-4666-9d58-f5218d5b0a0d", "solution": "import numpy as np\n\nclass AdaptiveMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor for better exploration\n        self.crossover_rate = 0.75  # Adjusted crossover rate\n        self.c1 = 2.2  # Further increased cognitive component\n        self.c2 = 1.8  # Further decreased social component\n        self.inertia_weight = 0.65  # Fine-tuned inertia weight for balance\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Fine-tuned cooling factor\n        self.exploration_factor = 0.18  # Further increased exploration factor\n        self.adaptive_mutation = 0.06\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly reduced random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 110 == 0:  # Adjusted phase switching frequency\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiPhaseSwarm", "description": "Adaptive Multi-Phase Swarm Optimization with Enhanced Exploration and Adaptive Learning Rates for Improved Convergence.", "configspace": "", "generation": 78, "fitness": 0.30340320664733766, "feedback": "The algorithm AdaptiveMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.871979491203169, 0.8234414387159261, 0.8419674409301788, 0.8698903581494024, 0.8618987906512369, 0.8653656847612926, 0.8603771237725361, 0.8672495315977709, 0.8345797312440693, 0.7314979762436744, 0.6636062320367755, 0.6715063617900945, 0.671672968288928, 0.5941054699165425, 0.7499416583185637, 0.7135048522767435, 0.7495787382037442, 0.7185515326183345, 0.14186606948460323, 0.15276754222896016, 0.15576139363129715, 0.11487860730348876, 0.16683050369748031, 0.1181081800290038, 0.16483294067121712, 0.535590742430194, 0.15706198204554256, 0.11594477265664205, 0.11553598780729535, 0.11035441472773222, 0.1340254414618841, 0.13933874770839516, 0.1386932960437003, 0.13443841997584283, 0.11738666804190212, 0.11366696897927775, 0.9874257490866876, 0.9793603332685665, 0.9906325897926481, 0.9873922337445649, 0.986752840378372, 0.9870562880228642, 0.9840809262966308, 0.9832198359272429, 0.9871152362275214, 0.5270985028944117, 0.6136174484084898, 0.4353730699286402, 0.5346850781564098, 0.5678749927277174, 0.5259200964038919, 0.6246152052729416, 0.5433431340130253, 0.5236945443816958, 0.17163928018987495, 0.19922215846502167, 0.754432550483409, 0.793457855355248, 0.19131788591479892, 0.20348270935733004, 0.20535814728291113, 0.14544383200123445, 0.213717101170791, 0.13709241305831565, 0.19584930784432353, 0.18304362096270776, 0.12986934103566383, 0.18395888157941243, 0.1686922289007492, 0.18003473528966174, 0.1806217785689771, 0.19110757306205994, 0.21890437616936909, 0.11923873845014255, 0.20074619840139707, 0.17219579494758286, 0.4955436294589831, 0.17371561324011908, 0.198612862773885, 0.09696120535847008, 0.19800949315417293, 0.0010350086509431922, 0.013457559472141667, 0.00991792757839316, 0.009287886668662204, 0.023823570816437156, 9.999999999998899e-05, 0.0015251060669805305, 9.999999999998899e-05, 9.999999999998899e-05, 0.05367543679541398, 0.025518563927298787, 0.06918838137846506, 0.1298644616950123, 0.012522206158255944, 0.028191511380319056, 0.07956579355370252, 0.04626026385245807, 0.0487301954427527, 0.052968584890354053, 0.06790917254868889, 0.12697288438611853, 0.14580157187874954, 0.10699215184116107, 0.07613171212739489, 0.09411566100040669, 0.21198026610991594, 0.08107330492320486, 0.1477661278269703, 0.040880829280136144, 0.15481176862169355, 0.10532275954461534, 0.0503509635663586, 0.015282457759276835, 0.09457248114857686, 0.059841453452206816, 0.08440808342886263, 0.5175594189026933, 0.5429259627720395, 0.48907559231520004, 0.5796025503788853, 0.5637981841090716, 0.5263811063246631, 0.5386892099161897, 0.503198835298301, 0.5465646693245654, 0.08296127558341881, 0.09018698771855727, 0.10099265900068055, 0.15571719539647566, 0.12446401423571407, 0.1336754428286291, 0.11145590546641959, 0.09058489571972494, 0.12977028267159707, 0.27484370002970304, 0.1939206060446711, 0.15342329321302217, 0.33145322986476555, 0.377503873807424, 0.165800589694599, 0.22922036642449994, 0.18827231642046083, 0.2350808635029107, 0.2575028005893072, 0.367462209220904, 0.369178242040917, 0.3059678872730518, 0.2149146247143362, 0.3770881933516882, 0.23474054361564223, 0.5010863966406336, 0.4611792012924786, 0.2274923266956671, 0.26621342895463884, 0.19392216783998784, 0.3198579309993337, 0.20499603146888035, 0.26520780526757504, 0.2275406154280052, 0.2730274569749316, 0.25060972180144425, 0.18018169843770193, 0.24994808063845553, 0.190190840702403, 0.21363835774405904, 0.21020094551319968, 0.2051153128251466, 0.19363907649533907, 0.19254409481423307, 0.20855253102144367, 0.18814564532439015, 0.2186545245675191, 0.22115706137293567, 0.22010056478981144, 0.22603170377265558, 0.20177668014209715, 0.2420038546694927, 0.18826807741856433, 0.20596113790127224, 0.8770606150133824, 0.15576842675731117, 0.15420348019408447, 0.8454314688446138, 0.20006093984192475, 0.13129787718661445, 0.12932751728218028, 0.16952426775061558, 0.15196775300949905, 0.6979954761017231, 0.20852275002818066, 0.4610845519331933, 0.5901536928865618, 0.1674169697477812, 0.20957635033660305, 0.1045459824502819, 0.7061865313336158, 0.6636260879619027, 0.1880251496170029, 0.18681622238065398, 0.2058555108050859, 0.20841320948533848, 0.19987282507992477, 0.23109267520787902, 0.18881242036065327, 0.287189893654892, 0.19972797194807912, 0.09324606774974076, 0.11551463703829612, 0.09580872088566961, 0.09973120651520218, 0.10122830225854429, 0.12076664138669035, 0.0822096491561517, 0.07525181211504184, 0.05118659741069842]}, "mutation_prompt": null}
{"id": "ea4711bd-49fa-4d68-942d-4b85b808bcae", "solution": "import numpy as np\n\nclass AdaptiveExplorationExploitationSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.7  # Increased inertia weight for more exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor for different decay rate\n        self.exploration_factor = 0.1  # Adjusted exploration factor\n        self.adaptive_mutation = 0.07\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                \n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 150 == 0:  # Switch phases every 150 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveExplorationExploitationSwarm", "description": "Adaptive Exploration-Exploitation Swarm Optimization with Dynamic Parameter Adjustment for Enhanced Convergence.", "configspace": "", "generation": 79, "fitness": 0.28035286861746755, "feedback": "The algorithm AdaptiveExplorationExploitationSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8193521298723357, 0.8193667241522509, 0.7856541142478629, 0.8196279651750861, 0.823449767303821, 0.7623056841782323, 0.8040558536533889, 0.8077015511088497, 0.7973648385155045, 0.6528668042562602, 0.6496608859803619, 0.6666413974163801, 0.6488454197837835, 0.6560212841269066, 0.6547294051409551, 0.6866586077502946, 0.551899906277219, 0.7060625900047256, 0.14198673686124352, 0.041554394643233405, 0.5860956029577935, 0.14877915616870652, 0.0717937034170234, 0.07130898195603508, 0.15433407444185798, 0.11937025441164661, 0.16111099801091555, 0.13863075639349687, 0.13863882082249657, 0.11473250573291682, 0.6375301332682254, 0.14544007280593918, 0.09013200845527647, 0.10544458386037947, 0.08918580785024821, 0.11266674741160254, 0.9875410600912895, 0.9793973820173235, 0.9906457666800612, 0.9874923847048939, 0.9874955890762948, 0.9831002404070887, 0.9845567727385434, 0.9868324552063916, 0.9894234146104145, 0.5867273093389509, 0.5897162881516103, 0.5070071721574334, 0.6135276264420009, 0.6459078155186782, 0.44405910290891404, 0.551611228102342, 0.47045897659820646, 0.496473647481374, 0.17324218470073116, 0.16658707213813562, 0.19410661519850558, 0.3611313756564617, 0.20850328717059108, 0.2094528599835095, 0.11472902074048075, 0.1313431648228507, 0.14119576316157656, 0.09557466925435709, 0.22413091981326405, 0.17464329063863604, 0.17375894449213214, 0.17803840957938977, 0.18248891701741066, 0.18955047896298394, 0.1905694523511473, 0.17568283453070088, 0.18646937231797533, 0.11787157217991606, 0.17788642251243159, 0.15454861470218895, 0.20090130395761174, 0.1615241996375273, 0.2217499931512228, 9.999999999998899e-05, 0.10786440578615253, 9.999999999998899e-05, 9.999999999998899e-05, 0.05902292792593722, 0.007869221844083896, 9.999999999998899e-05, 9.999999999998899e-05, 0.02910758706073424, 0.06435973114233962, 9.999999999998899e-05, 0.07589419911983075, 0.03189400657606989, 0.04274266831021234, 0.04267082861685034, 9.999999999998899e-05, 0.018828502893993737, 0.07844239681942766, 0.05853410867017883, 0.06289668044339902, 0.04440650640097743, 0.0818150814438261, 0.030584084033032144, 0.09967246643277416, 0.0675458297320145, 0.070824492266223, 0.0950058176172357, 0.09209279289779337, 0.06444576474592845, 0.0425127258263156, 0.057593631978277715, 0.0760026161941636, 0.011973892588928559, 0.08696850243352461, 0.010417196142087914, 0.07953821288084051, 0.10318035999109665, 0.0630920150408667, 0.5197494057916136, 0.49559402576001965, 0.49331033692721504, 0.5483396337591153, 0.5502500428343458, 0.49747925200444365, 0.5561512966235849, 0.5327126178917639, 0.554227627518993, 0.0789001757515938, 0.05818826063545934, 0.05597918677166713, 0.1309971170911931, 0.1306148797778537, 0.12762645380256343, 0.06954706143084388, 0.10340529287459543, 0.11204293736557625, 0.18052600681955377, 0.18385740768002956, 0.21633069461554255, 0.2873134311581529, 0.35529998152167774, 0.12782754815384523, 0.4605768129738623, 0.4541775515981129, 0.1688484286789188, 0.3756793116344205, 0.23613411511033677, 0.27972780203164316, 0.2948327358014523, 0.27456385818067497, 0.37820838196331397, 0.4012996292469818, 0.5083676531586809, 0.28974226479716825, 0.07736128581598734, 0.23533315309351277, 0.18116511244361544, 0.231426562773422, 0.1901754666107769, 0.2994176192794692, 0.21434529015448767, 0.30582056791803003, 0.08253862100774911, 0.2043419669488723, 0.20420460422000264, 0.2295706298798812, 0.23145870429173132, 0.1644046114677753, 0.20367881411856348, 0.23492253869749657, 0.18920372905943705, 0.21898586106367934, 0.21474536699294622, 0.21597264286842588, 0.2021765046601035, 0.24089354498424076, 0.2461522101704371, 0.20043039251361305, 0.21809185716498636, 0.20067982383289928, 0.22665286639130455, 0.8085405935303341, 0.1666288115376814, 0.15344632660751245, 0.8767685762258769, 0.19998114522393184, 0.19576584853089163, 0.1223371765669482, 0.16992501720939868, 0.15330432689633144, 0.1542059562487439, 0.20927767582346213, 0.18852577179254126, 0.4044241366776813, 0.41780810226943654, 0.20983424595901956, 0.10487761342017254, 0.20819993927481328, 0.10427936923932757, 0.2204430752102341, 0.20873502001984967, 0.19792196054119027, 0.19139878743232197, 0.2105498499128421, 0.18987864282656042, 0.19724424205895652, 0.20284339137678775, 0.21413137893019474, 0.06979361048643984, 0.10061752944870406, 0.10290544962721138, 0.09338299070655742, 0.07765416470993514, 0.09027757285467941, 0.08029047587810434, 0.08283564269896249, 0.09745114228717644]}, "mutation_prompt": null}
{"id": "2e9e576b-c282-4565-bc6e-71897e11755d", "solution": "import numpy as np\n\nclass AdaptiveMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25  # Increased population size for more diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Increased crossover rate\n        self.c1 = 1.7  # Modified cognitive component\n        self.c2 = 2.3  # Modified social component\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Slightly adjusted cooling factor\n        self.exploration_factor = 0.2  # Increased exploration factor\n        self.adaptive_mutation = 0.04\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Switch phases every 120 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveMultiPhaseSwarm", "description": "Adaptive Multi-Phase Swarm Optimization with Dynamic Component Adjustments for Enhanced Global Search.", "configspace": "", "generation": 80, "fitness": 0.2654157605665904, "feedback": "The algorithm AdaptiveMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.7631418846145439, 0.7503861581610688, 0.752475422310829, 0.7790593361962541, 0.8119836616065266, 0.7627856481385471, 0.738644851933212, 0.7412813831123364, 0.7846652114738135, 0.52884581396624, 0.5928136430775812, 0.4073543543161179, 0.5894436603068366, 0.5015536754990353, 0.42072872254266225, 0.42693589887651184, 0.4646563241314575, 0.5520836255335432, 0.5447136560790566, 0.4854175950538768, 0.1576890868914803, 0.1200816177671179, 0.10187708742989376, 0.14486264495827272, 0.2123569654198001, 0.1392586403692625, 0.13864191350129274, 0.14732878830834883, 0.14494451018782784, 0.0970407960265437, 0.12737874818868955, 0.13343886030005592, 0.12187901546654334, 0.09438350456141453, 0.10855305964619344, 0.12499093937029937, 0.9886504620470256, 0.9921401478792746, 0.991638216601292, 0.8797436047175947, 0.9799796418589295, 0.9852136538477866, 0.9887451781110835, 0.9803014439654268, 0.9848835940123006, 0.4481901493326341, 0.49637780640421747, 0.40107003127304175, 0.4398235703355342, 0.4501634429397915, 0.4216678790466286, 0.45590979618042415, 0.45176712158224985, 0.3965950814844771, 0.17218355806689956, 0.47589026969157733, 0.4810822726977402, 0.49475964377273063, 0.20692492441250065, 0.2651342303272398, 0.06962826843922065, 0.1267961063280778, 0.16661803548316434, 0.14460697411994494, 0.1003907178175012, 0.11753666751114056, 0.11550261082239488, 0.12720138973514417, 0.11809682896960327, 0.1831325804865861, 0.14440262408652793, 0.17944578077789153, 0.1805399773865165, 9.999999999998899e-05, 0.11584338087251433, 0.1210691727459382, 0.20364784928136692, 0.162957688434894, 0.16334754143301633, 9.999999999998899e-05, 0.21598228643263928, 9.999999999998899e-05, 9.999999999998899e-05, 0.015956414976118882, 0.009418017401280454, 0.012504603912258605, 0.02712119084319764, 0.0028690947399805378, 9.999999999998899e-05, 9.999999999998899e-05, 0.057450740645337506, 0.06076963886438247, 0.09326014246867365, 0.07858722126295037, 0.01329699597571421, 9.999999999998899e-05, 0.07210847989270042, 0.07084908113271848, 0.036286305355987536, 0.04118566688074676, 0.032752392274533526, 0.18564527810258813, 0.08409221895745467, 0.0872980391830952, 0.06562924205466247, 0.08299521717965852, 0.059956358214527605, 0.05987073175108104, 0.042456285509943514, 0.04987756800750198, 0.0660222486488472, 0.018191280146974576, 0.04958119822216178, 0.08647218037057358, 0.09762932334267538, 0.05391239942278914, 0.17566199253982517, 0.48684406309066375, 0.5040260328124855, 0.4675142823297853, 0.5012546473798765, 0.5161288508592072, 0.4883222852182244, 0.5162380771352459, 0.5186674828638864, 0.49352020373409, 0.09053769481274654, 0.10220948552918308, 0.08929973905555066, 0.10061694428862078, 0.1170973765870853, 0.10293107734281237, 0.07227972954750417, 0.12282369390057812, 0.11838618351748742, 0.18767937874124652, 0.17909471511501052, 0.17181986570246355, 0.27101928351171023, 0.30108999881218657, 0.21113904927414628, 0.39627322796249465, 0.4346789750359582, 0.24260699112171313, 0.27798055934837596, 0.22914608639125833, 0.4029444100707136, 0.35300093361112117, 0.20669941602245367, 0.3516135190284847, 0.25329679371906066, 0.3816102857983179, 0.22302600188971777, 0.2245370515479026, 0.22999356186981745, 0.18578893082192538, 0.16748369677641928, 0.19924131973262516, 0.2277253323287921, 0.2389524145140952, 0.24405307372416052, 0.18925461201054328, 0.18001985415977706, 0.21881640035382766, 0.22323406900965315, 0.20462800436753814, 0.20923027279263406, 0.20158530920434692, 0.2024949523912366, 0.20605186050117896, 0.19799065994163167, 0.23247508857981058, 0.20845888456698303, 0.23393758329947, 0.2418929470281963, 0.23433131706918953, 0.1980549754908184, 0.2152339742685847, 0.20337949934348676, 0.19630794985404532, 0.16387419359075905, 0.16557870265760344, 0.15376365915905954, 0.8261898127891038, 0.1992236139834167, 0.16565354134709087, 0.09952535636419779, 0.17018198689924213, 0.2105411873810259, 0.1514165830861668, 0.15564182437046803, 0.2922478626467404, 0.2043688509648669, 0.4533896012746341, 0.21083020617417025, 0.2112817271584405, 0.2109151355630191, 0.5876282591802503, 0.2299129038960528, 0.2073157382132187, 0.1830725583307361, 0.18661366230220888, 0.1982956151927201, 0.1924794776075519, 0.2071153945900034, 0.21659272297925514, 0.188932013023842, 0.07620448245728606, 0.0809851181195057, 0.0719385398460437, 0.06115654533112813, 0.09154958638347377, 0.08606329720764438, 0.06907567909309908, 0.07752139527267632, 0.08449005588016534]}, "mutation_prompt": null}
{"id": "9e0e6bd8-ca2d-4973-ad51-da1a116b09fe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # Slightly increased mutation factor\n        self.crossover_rate = 0.6  # Adjusted crossover rate\n        self.c1 = 1.8  # Dynamic cognitive component\n        self.c2 = 2.2  # Dynamic social component\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor\n        self.exploration_factor = 0.2  # Adjusted exploration factor\n        self.adaptive_mutation = 0.1\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Cognitive-Social Balance for Enhanced Exploration-Exploitation Trade-off.", "configspace": "", "generation": 81, "fitness": 0.28267079705841996, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8152550206301946, 0.8339655502983103, 0.8291427668786552, 0.8558493019204211, 0.8243274725695442, 0.8374011234857718, 0.8217687334942052, 0.8337559997680184, 0.8223961951372804, 0.7163591101969167, 0.5760739792361724, 0.6512585084450424, 0.7042155156564274, 0.6004835137090982, 0.6840119453547713, 0.533836767572784, 0.6473139626136544, 0.689264277093938, 0.17881386550595524, 0.13482854669120659, 0.128827231059937, 0.07037886609958677, 0.15751511910328064, 0.13771595964354566, 0.47324327942440425, 0.06613881676936129, 0.14295488384408017, 0.13037011973976753, 0.10949938039333229, 0.10227646225260212, 0.16045172529246465, 0.10031048252161456, 0.1344712845968401, 0.11498406347584056, 0.13555999611093017, 0.11260971658707664, 0.9876391630477481, 0.9765441577977763, 0.9907797981662875, 0.9877807818688756, 0.987521732386672, 0.0996162548448487, 0.9870629387318604, 0.9875019585049881, 0.9894514302353734, 0.6267228063001422, 0.5926905950165626, 0.5481966453979168, 0.6233730819051633, 0.6601823205151179, 0.5405822181256544, 0.5657523847450986, 0.5158451647083986, 0.5306261531922634, 0.22507896584047915, 0.3661111883530238, 0.16704101886042333, 0.3686251652437481, 0.1839259809764221, 0.20666470664108638, 0.22396339619784922, 0.6916364826745651, 0.21664782150238593, 0.130208420569199, 0.18185263032272592, 0.17645393054365377, 0.18964780996445352, 0.2034023892217176, 0.17766807855009048, 0.19930932414406777, 0.12669617414826573, 0.12665735933762678, 0.19659301102173266, 0.1175334895082657, 0.11375822748381104, 0.1819602836025218, 0.11461278971680189, 0.17088579541986004, 0.20065168738705674, 0.12575262247253471, 0.11385912944205523, 9.999999999998899e-05, 9.999999999998899e-05, 0.049839496918631654, 0.05508857784864141, 0.00017404882505012154, 9.999999999998899e-05, 0.04016606711027648, 0.01692809493592773, 9.999999999998899e-05, 0.04217354902189907, 0.030431716072648274, 0.06283271127943735, 0.08506768764155381, 0.0019238116916311387, 0.08338739132312456, 0.13116056223385708, 0.0464866203701636, 0.045395351572769194, 0.13507849611713885, 0.03340402085970695, 0.033327101341876886, 0.087164464001379, 0.072467256838888, 0.07043756150445535, 0.10181782959164043, 0.07111080284124183, 0.09140784310224137, 0.037102876934452245, 0.04478885611523398, 0.09023995356831749, 0.020981682041660288, 0.1676564671806675, 0.2845607001515541, 0.08718842980990049, 0.05466827225004367, 0.08702399558566665, 0.546754204125914, 0.4995812153459849, 0.5014263869643274, 0.5216460110339106, 0.5083083301064437, 0.5489434182477679, 0.5304097014257907, 0.5265974768936436, 0.5486436942875118, 0.1335210307636191, 0.07293929699745694, 0.08665001957168372, 0.12280603550084812, 0.11635591344691143, 0.11154120376523646, 0.07948709823202793, 0.10320275822515435, 0.07197286248512014, 0.13183532268068465, 0.29105792207863157, 0.1824053666716089, 0.24801269700076212, 0.3894438806341347, 0.17293296110189127, 0.19711205006408306, 0.19995041744849162, 0.16958030013132952, 0.27562365180115256, 0.2745787101445216, 0.2644866681636665, 0.3066871553419793, 0.2158708680146001, 0.47316097305900495, 0.27995570639707723, 0.4691862526432733, 0.1563281723917862, 0.07671167139607837, 0.20818716805328696, 0.14750108299002873, 0.16789425706156258, 0.18836064134598618, 0.2783285016966113, 0.18946659587258308, 0.26290466717661565, 0.30885142862737824, 0.1734092488445791, 0.203624713896164, 0.18153116549589177, 0.21018187625952534, 0.16390456774944273, 0.18998114491489693, 0.1995397538905137, 0.17305128070188436, 0.23356542665314795, 0.20888503627125965, 0.22155602329815005, 0.22349842746167792, 0.20676616514608903, 0.5140755425858388, 0.2059211053780885, 0.23123970292782248, 0.2028107231627514, 0.20226899483419447, 0.9007431625474379, 0.19783510725371956, 0.1511737918370042, 0.7777571643983684, 0.19977761157568286, 0.19627831868046708, 0.1204045656103302, 0.1692500666168939, 0.14991686228767853, 0.5492455779533356, 0.21017973919615496, 0.1515675542839694, 0.5122008470363085, 0.1674292716757152, 0.21111797205724303, 0.10481895182195222, 0.5661417901786159, 0.21127342154999718, 0.2118979036768236, 0.2062397112175426, 0.2172674436712364, 0.18691317646829841, 0.22961719073705622, 0.192611376616187, 0.2057964102043759, 0.19783884503053406, 0.18548380541247111, 0.08779902584248978, 0.07801325316532581, 0.08289401772135929, 0.08061032612219621, 0.09105649029691087, 0.07431446895090377, 0.09429565606733081, 0.07757041644219276, 0.08196891904264025]}, "mutation_prompt": null}
{"id": "4519fd91-391b-4171-a588-2220d7c36ed4", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly reduced mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Increased cognitive component\n        self.c2 = 1.9  # Decreased social component\n        self.inertia_weight = 0.6  # Reduced inertia weight for faster convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.996  # Adjusted cooling factor for different decay rate\n        self.exploration_factor = 0.15  # Increased exploration factor\n        self.adaptive_mutation = 0.05\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly reduced random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Switch phases every 120 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Enhanced Multi-Phase Swarm Optimization with Adaptive Mutation Control for Improved Convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.868376597977421, 0.8599684296209293, 0.881907284699789, 0.8817981304763994, 0.8782286169703105, 0.8320329598309161, 0.8753340250728163, 0.8567827600452298, 0.835133327110839, 0.7334069552497461, 0.7233259212052423, 0.7085616276548696, 0.733299588455351, 0.7149908659689703, 0.7001682747057044, 0.5544609435360084, 0.5824413013758059, 0.7238386223643003, 0.17485318973781738, 0.113609530084268, 0.1453708106762962, 0.15530403739385856, 0.17077266203709218, 0.13798185016062947, 0.05780572993975053, 0.12084256774785285, 0.4625359953088469, 0.14492150656084324, 0.17978128376662916, 0.46457013056396335, 0.15437340104484243, 0.11840379753070007, 0.13896075563128685, 0.14773215449486088, 0.15227169427736553, 0.14244028043555645, 0.9872043760238632, 0.9826347069352321, 0.9906572222909417, 0.9869103897766742, 0.9871096512289319, 0.9865068892254468, 0.9866096555794052, 0.986702912800172, 0.9865456688891193, 0.6243378369734709, 0.655891274823478, 0.6412361058508882, 0.6829195065458997, 0.5390490086371699, 0.6223520742567127, 0.6455032409951298, 0.6194513764114673, 0.5710635671061743, 0.17291478181165143, 0.15540101703690123, 0.21480621708444758, 0.2797133463130468, 0.2663872376702028, 0.2081961764314565, 0.15855368869687592, 0.16581229781628914, 0.2007275349479416, 0.10238427582035126, 0.19362196704791135, 0.17827829011417673, 0.13029928051099504, 0.18374229246624574, 0.1833126808761777, 0.19444232943209738, 0.20210314966651066, 0.11807753009792976, 0.19527108350050149, 0.11887387781710512, 0.13115108585216695, 0.1959254459985802, 0.3745258816609588, 0.19862872921422636, 0.21880767718245353, 9.999999999998899e-05, 0.21613882992118438, 9.999999999998899e-05, 9.999999999998899e-05, 0.032233289729648784, 0.07820629162496384, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012314830679409638, 0.05361080554430486, 9.999999999998899e-05, 0.044744112734891095, 0.041659896506688, 0.10448106141815205, 0.08561223903948534, 9.999999999998899e-05, 0.01101379834529781, 0.043449448526291956, 0.060492290223763456, 0.050142302679423434, 0.03470904886226911, 0.06428236115890995, 0.1923712087768209, 0.1271997916351364, 0.3592906978350021, 0.0896771782588196, 0.12403831002031951, 0.2941897487951045, 0.07203749355686573, 0.04808698111170673, 0.04301348783049741, 0.237284352233205, 0.051048453628932844, 0.031081794774595606, 0.020001997150258077, 0.08236011505266472, 0.09169006076457276, 0.05825995482400681, 0.5160779798025504, 0.5796718355648198, 0.539037154430671, 0.5630524210959394, 0.5415166670447795, 0.5484783027824239, 0.6026075154668025, 0.5607308275421558, 0.603307114501201, 0.10886850451654173, 0.14296516741076448, 0.09823699666623364, 0.11458275716142874, 0.0786617406758624, 0.10463296813643197, 0.06121408269486106, 0.09302726097936598, 0.10513524726154277, 0.1777790768599805, 0.3640676356715433, 0.22311799683478328, 0.3805160830002673, 0.35827514970694707, 0.17175705945018838, 0.6640912905101208, 0.22249816424392588, 0.23251846722486735, 0.2954736475202452, 0.20423628963245233, 0.20778907851132156, 0.264777093977661, 0.22020398567240063, 0.34998096525833355, 0.42314637397319865, 0.28676405053739396, 0.2841995953298062, 0.2504068629422983, 0.28588448896592633, 0.20060387871699337, 0.16945242632172552, 0.22385982946607497, 0.20985445888712173, 0.23613239106807582, 0.28471999455351693, 0.2339006697889019, 0.20129035333994205, 0.1963313106701845, 0.2051328529573766, 0.21602494288112384, 0.19705935197439195, 0.22567250893333413, 0.2364148322872024, 0.1859805100112759, 0.21959360980614862, 0.18871224540812614, 0.22249415541174045, 0.20419833455460723, 0.7798448461526082, 0.2237564108864183, 0.23000967375886783, 0.23600979928712695, 0.23996097935255534, 0.2033053236306528, 0.9158690216328449, 0.12580033805055169, 0.1543471842335693, 0.8831790355437801, 0.20042463491202334, 0.19749025832002876, 0.18793212426113015, 0.16997220968182958, 0.1532131912444593, 0.690971587890103, 0.21155425263723027, 0.4037971599487734, 0.6791365408320804, 0.16880412353327612, 0.2114818110771438, 0.1044347270694439, 0.21148496164823205, 0.5891772424141132, 0.1890836243706473, 0.20788497984744825, 0.19787210464994365, 0.18639288423842515, 0.21463688487040278, 0.18456701096454842, 0.1847788017624843, 0.1833852816776771, 0.2011370496193734, 0.06616231695229746, 0.10823231201569328, 0.1050999496395596, 0.08877648688834217, 0.07175798659968424, 0.1436180603852727, 0.09201977303326436, 0.08702563072685932, 0.09209869712104124]}, "mutation_prompt": null}
{"id": "2a1a8904-091f-4de4-a1f0-bd4ab9503dbf", "solution": "import numpy as np\n\nclass QuantumInspiredMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.7\n        self.c1 = 2.1\n        self.c2 = 1.9\n        self.inertia_weight = 0.6\n        self.max_evaluations = budget\n        self.cooling_factor = 0.996\n        self.exploration_factor = 0.15\n        self.adaptive_mutation = 0.05\n        self.phase_switch_prob = 0.5\n\n    def __call__(self, func):\n        evaluations = 0\n        exploration_phase = np.random.rand() < self.phase_switch_prob\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            else:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if np.random.rand() < self.phase_switch_prob:\n                exploration_phase = not exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "QuantumInspiredMultiPhaseSwarm", "description": "Adaptive Quantum-Inspired Multi-Phase Swarm Optimization using Probabilistic Phase Switching for Enhanced Exploration.", "configspace": "", "generation": 83, "fitness": 0.28355192123711526, "feedback": "The algorithm QuantumInspiredMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.842983180196809, 0.8618293589338346, 0.8628077710985256, 0.8291414762371553, 0.8569052786966957, 0.8555381101861746, 0.8621290033052452, 0.8373223121733198, 0.8321249803550808, 0.6405253228621982, 0.6900650539593687, 0.6141325955301562, 0.7057366056441293, 0.4455570546575701, 0.5771937107266225, 0.46664323263528895, 0.7017965625886132, 0.5828846692749872, 0.16870160559284708, 0.11887292206871958, 0.1713391373187627, 0.3122015484089702, 0.14556196580297243, 0.16111188273439825, 0.16762990759691, 0.1512586744515424, 0.06843097396122377, 0.09791464775983949, 0.15398795486387895, 0.11026968862399766, 0.13565621597255673, 0.14684794600535112, 0.14632959959539382, 0.1396944121694108, 0.10305183710534493, 0.14968642411684052, 0.9906343063595516, 0.9865421195572233, 0.9928466872187152, 0.9899530475515549, 0.9889922321758643, 0.9812581588849983, 0.99040035916645, 0.9860604419492848, 0.9881611977490128, 0.568144232782408, 0.5024246417513427, 0.5644898519325361, 0.6316087695955339, 0.3640111922405709, 0.5879043048400422, 0.5818050066462821, 0.5081806862210771, 0.4952773809134987, 0.21539288668725498, 0.5111359736403926, 0.6938117664612076, 0.21224255976954154, 0.20539759949607883, 0.20706618027626544, 0.1270439896806247, 0.2290721005141132, 0.24182495185839437, 0.0991869442696156, 0.25949070929474205, 0.2118309251853987, 0.16728252115222209, 0.1729269461045022, 0.12995433404197043, 0.18766311777631073, 0.20146971047637818, 0.1770036484016062, 0.2006035813975574, 0.11567672236706494, 0.17087442308118117, 0.12773285880286733, 0.11016722441368276, 0.17682037167378717, 0.21376973343774552, 0.09757706380263675, 9.999999999998899e-05, 9.999999999998899e-05, 0.004527545613651651, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0088201556707318, 0.00013309631461200233, 0.05975371794282147, 0.06888982639772512, 0.034678623904888406, 0.05029422826658925, 0.10681971866010265, 0.002547756249663191, 0.0041488923704416925, 0.07898292463228007, 0.03864196247461971, 0.02607855367396683, 0.12112890313602398, 0.07927940492295582, 0.12865434374776763, 0.07210813021723772, 0.08606529422705012, 0.07399066832060108, 0.18461367506221849, 0.11573489627966882, 0.06930029746680988, 0.134256472222403, 0.044829797309319686, 0.049609310593327405, 0.006697197252220177, 0.05100763756212545, 0.15680560035187008, 0.1389334359033947, 0.05481866723916917, 0.0783614759503245, 0.5697433879778665, 0.5495651225144319, 0.5237694621671378, 0.4990995119917697, 0.5337646922411214, 0.5302193395322714, 0.5157752009990018, 0.5214898982987836, 0.54917509646332, 0.08448284498346292, 0.10667044881189236, 0.09032794177669567, 0.10579449113187711, 0.0878707071202014, 0.12522808121497697, 0.07790810236740142, 0.07959412346280736, 0.09006167439816604, 0.17797092918329893, 0.3857684067314837, 0.2424933975989565, 0.31420615767923876, 0.2664834394398279, 0.17632686322332158, 0.23730942724658044, 0.18528845768231827, 0.19095771187944077, 0.25111837094029954, 0.2328687855995274, 0.31864807151408236, 0.22886328979518344, 0.32935282202680805, 0.23714396909776925, 0.3697782233626188, 0.38446551429942566, 0.18740830888976912, 0.1955058846638137, 0.22286207810459568, 0.15124464915101432, 0.2035815955847724, 0.28548570749665236, 0.20313184711187393, 0.17856871063712465, 0.2738990852288735, 0.20159906988630916, 0.19208929161844512, 0.15002309017692295, 0.19305040796931627, 0.19797267312946754, 0.20040227141224098, 0.21522883368809764, 0.21659208422523046, 0.19978406325963216, 0.22124206921039524, 0.1867021505869615, 0.20169553872502188, 0.23316545861407756, 0.22197232425022362, 0.22781950147781072, 0.23845081868632323, 0.2450478279614977, 0.20300747342949177, 0.21364128980878827, 0.8047602704316934, 0.12638143612797248, 0.1540193026043999, 0.17300705644204317, 0.20141057638803184, 0.19984946024771044, 0.10380413962518364, 0.17041087418988954, 0.16074065461272002, 0.8029627565071088, 0.16818020269142797, 0.4735490763846476, 0.21058701235734756, 0.3905860011874278, 0.20958275103715318, 0.213358917756592, 0.5486055762847994, 0.5609948566771702, 0.2035562304231715, 0.17814445289268788, 0.18129453054409228, 0.22772720719955175, 0.19257451369820588, 0.21773149235361, 0.17705965943751, 0.19235397608618443, 0.1854744648208979, 0.0879957191890326, 0.08671495915750127, 0.09728283515118508, 0.083704736947116, 0.0883927239308725, 0.07385932147779983, 0.07692607738217172, 0.08840764693958791, 0.09777615354788105]}, "mutation_prompt": null}
{"id": "015703e4-b63e-44c4-a3ce-8b68b97eea5e", "solution": "import numpy as np\n\nclass DynamicSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor for better exploration\n        self.crossover_rate = 0.7\n        self.c1 = 2.0  # Balanced cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7  # Increased inertia weight for broader exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Fine-tuned cooling factor\n        self.exploration_factor = 0.2  # Adjusted exploration factor\n        self.adaptive_mutation = 0.05\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        adaptive_inertia = self.inertia_weight\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = adaptive_inertia * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            adaptive_inertia *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "DynamicSwarmOptimization", "description": "Dynamic Swarm Optimization with Adaptive Inertia for Improved Convergence and Exploration.", "configspace": "", "generation": 84, "fitness": 0.2863067906336361, "feedback": "The algorithm DynamicSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8469033608163796, 0.8178585497943949, 0.8177274650206404, 0.8494297479833408, 0.8136291213345997, 0.8403446945145991, 0.8332518145382083, 0.8503611949732874, 0.8566984670527021, 0.7082545884066451, 0.6547506263230509, 0.6301584284388515, 0.7098770077147466, 0.5958697291238679, 0.6771251239548417, 0.587737298851432, 0.6015446154122132, 0.5832642985060559, 0.1119506542675981, 0.041076450483179316, 0.14143530825635897, 0.06985701611259287, 0.06335651042705581, 0.15506191957747884, 0.10820865258744128, 0.1479145394111261, 0.1652201303387204, 0.13733618894302724, 0.10509648422682571, 0.1397156028933454, 0.12350115925768734, 0.10675146825377013, 0.17039660739807072, 0.13818887817007963, 0.1273049159294083, 0.10888134271839556, 0.9872821913657096, 0.9826985197973731, 0.9906569393762702, 0.9869298690386974, 0.9874606910000201, 0.983595424530228, 0.9867461031457564, 0.9872318879207561, 0.9894461005365269, 0.5251097039092542, 0.5888457041263468, 0.6270341826817057, 0.6172036280181994, 0.48214686582199584, 0.5938576413274961, 0.5364881749227306, 0.5453341113475818, 0.5425500768858418, 0.17127158907157158, 0.19878884251744966, 0.2251737338921962, 0.2169259174070437, 0.20810950595080036, 0.20467671127195786, 0.6143014637075388, 0.2173081142884724, 0.15293343903542622, 0.12957760662548223, 0.18978080044948653, 0.17981141033076253, 0.1749033156030393, 0.1864989729622646, 0.2008217991773923, 0.17997566971331957, 0.20266543655415747, 0.19955872624439686, 0.19736325948982458, 0.11795929080385104, 0.12751394681186845, 0.19252703161835394, 0.1285873361700557, 0.19357341144998663, 0.21426000475435225, 0.09526013663267607, 0.18027225400392577, 9.999999999998899e-05, 9.999999999998899e-05, 0.009804708341648039, 0.04185947424270853, 9.999999999998899e-05, 0.005910207296223935, 9.999999999998899e-05, 9.999999999998899e-05, 0.11136719787230664, 0.06922632859234912, 0.0300687294602745, 0.04061510758105413, 0.08769897034129459, 0.002531047317056778, 0.03364138986643339, 0.1379286427896712, 0.07336931240567934, 0.04446788848453476, 0.033641815284601195, 0.07434681735934023, 0.10076432668990654, 0.09238308840989506, 0.06953143985365928, 0.07217026366124468, 0.10200996812660246, 0.06635486296212367, 0.06722628929813601, 0.045624379116104175, 0.043413922405088345, 0.1004494609567983, 0.0295014310273789, 0.040207421327974946, 0.02657974650870032, 0.07977595667921267, 0.054783018261926, 0.054972169158087114, 0.5146338592362247, 0.5246347240528306, 0.6115771710827305, 0.5095531939054723, 0.4903738548593297, 0.562935122288206, 0.5879131492250127, 0.5296495827852535, 0.5503832324911225, 0.11636069100042512, 0.08179758999431397, 0.05796062951019154, 0.09729765453874528, 0.11563120565725016, 0.13670185904505128, 0.12385484458356966, 0.09553728119851601, 0.14727326115265682, 0.2588824621271695, 0.20338473572370974, 0.2172369863043896, 0.2489733742529604, 0.42030454419728525, 0.16758032163996195, 0.3689038925889312, 0.2009522961764737, 0.20675017189571676, 0.24305171122963443, 0.21849097210049262, 0.2227007494733031, 0.2512792977110656, 0.1990221493614045, 0.4127403339752914, 0.28238774436197656, 0.4244784161212256, 0.16953804165402853, 0.23517589383153026, 0.17567442544896417, 0.13397995543607377, 0.23283479812744623, 0.20058974439691724, 0.3425655438057892, 0.34146463328391785, 0.2534964043418556, 0.17350784437258282, 0.19461399720943562, 0.2368597102351223, 0.18958134049881437, 0.205576486621037, 0.18575082322397118, 0.2002064882344875, 0.19507503341458343, 0.21777713324503323, 0.22461691686578833, 0.16949965695379765, 0.22582798435199447, 0.20654647228064427, 0.2230136986039296, 0.19721847843419948, 0.7145137417858405, 0.23534382531275477, 0.2137611599490401, 0.20152720106000965, 0.8843773540683689, 0.16270190565231224, 0.15426655426540614, 0.8590021402722184, 0.19809256209982673, 0.19696401668391594, 0.5277189066762568, 0.17003088512896425, 0.153084659152944, 0.15439013347555886, 0.2104286170182068, 0.15835647406686837, 0.5492096832925977, 0.16850265656112828, 0.20854476456747761, 0.10469138424095092, 0.21052739232926931, 0.7321091440064316, 0.19771049234051985, 0.18884272516041, 0.20530316436419282, 0.2111884215954477, 0.19914230087242069, 0.19149337350914364, 0.24268974504577168, 0.19593035639360146, 0.1806941803586507, 0.07277519057285098, 0.08386885113518616, 0.1083482324535513, 0.09044972386890948, 0.09111891772674485, 0.08185013392715701, 0.10303953647923914, 0.09500728007236925, 0.08270553262287117]}, "mutation_prompt": null}
{"id": "aaa8d6a2-bfcf-469b-aeb8-bd63f7e9fac4", "solution": "import numpy as np\n\nclass DynamicLearningPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.7  # Reduced mutation factor\n        self.crossover_rate = 0.6  # Reduced crossover rate\n        self.c1 = 2.0  # Slightly adjusted cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7  # Adjusted inertia weight for dynamic learning\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Fine-tuned cooling factor\n        self.exploration_factor = 0.2  # Higher exploration factor\n        self.adaptive_mutation = 0.04\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "DynamicLearningPSO", "description": "Dynamic Learning Particle Swarm Optimization integrating adaptive inertia and mutation for enhanced convergence.", "configspace": "", "generation": 85, "fitness": 0.2947172438471526, "feedback": "The algorithm DynamicLearningPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8162429393382274, 0.8055595151863206, 0.828372539948579, 0.8419802300877954, 0.8257438901483541, 0.8173879421809983, 0.8336359231005697, 0.8357617281009397, 0.8455165444913548, 0.6887496705579752, 0.5507921590728501, 0.6068351263415529, 0.6269094771861959, 0.6480522874609992, 0.7051201600182746, 0.5131895751428466, 0.6672983711922793, 0.7100357347225846, 0.1595302722561449, 0.12065412025312072, 0.14490232545829695, 0.1458685230732859, 0.10166568570699641, 0.1451961553748914, 0.13275828044600735, 0.14125023918905377, 0.15693405651184544, 0.11886516964775784, 0.1342359251169024, 0.11593550006630993, 0.11503981466648205, 0.1254707981546619, 0.1369776202480698, 0.11528150011761973, 0.11862011510311199, 0.1489577561783193, 0.9875695327999641, 0.9827638358833497, 0.9906835465314684, 0.9876011649344734, 0.987270527262288, 0.9831154292163332, 0.9871763054429465, 0.9875514401956197, 0.9894626444652753, 0.5972599529503346, 0.6369256113209065, 0.5030303112253807, 0.5282088533665084, 0.5555582657236386, 0.6202377695176304, 0.5358866853716827, 0.5588315156954441, 0.58095813675725, 0.1674245956715864, 0.21973932470953428, 0.351117381212538, 0.8659226760091059, 0.2681506211411009, 0.20642145120277877, 0.20081176048468174, 0.20691780170809793, 0.5415698712126742, 0.11946402157898006, 0.1802474807288501, 0.19526257464510177, 0.12111738530785043, 0.12861609895960957, 0.18484961815133993, 0.17850693980785837, 0.18831898280913228, 0.18038560655610358, 0.1922683098426059, 0.002626467938736443, 0.1819077967560898, 0.16086065505037095, 0.20765379475669588, 0.20876268521470542, 0.22993886031135946, 9.999999999998899e-05, 0.22105189579260742, 9.999999999998899e-05, 9.999999999998899e-05, 0.06992038534338973, 0.029061627613883534, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000484972237201009, 0.0686095400287029, 0.08480809938744938, 0.03859074148073449, 0.03797251185468686, 0.02619474628865104, 0.012892283266436433, 0.03860631151931426, 0.06226552496566562, 0.07253988158459357, 0.0516120641721487, 0.048163181171498204, 0.10433725564033158, 0.043909656072121495, 0.11805022503409668, 0.07056490243906755, 0.07647943027858672, 0.1292041060777276, 0.07914225645301753, 0.06694956218286807, 0.0542280593528931, 0.039227140657185355, 0.15399362480727263, 0.01521539115016457, 0.03760193836526071, 0.0076736063964404355, 0.08109838734894215, 0.05412515512641691, 0.20214833197636906, 0.5418838644250674, 0.5497866810575223, 0.5071888901312025, 0.515494276560416, 0.5363943212700699, 0.5747845332358056, 0.5335008860032828, 0.5237818892578683, 0.5420330504242487, 0.11473965904028571, 0.05998078771255877, 0.1373733945677037, 0.14762230629746742, 0.08168393172743149, 0.13785488371090782, 0.16632037202335193, 0.16952125294776288, 0.13044374225955813, 0.4096177280598484, 0.19626017535462592, 0.290080193219061, 0.21436885852754606, 0.39228644846696703, 0.18859439656430244, 0.278926340410912, 0.3067878600887559, 0.20798076382283692, 0.2930709158208763, 0.37037262253984815, 0.16435482472764706, 0.3449964495133443, 0.2210376378797141, 0.3393883572774653, 0.2538466747957375, 0.41860662313095043, 0.193119621113237, 0.165975137996913, 0.19702710265747536, 0.13868758722216967, 0.2187613723211269, 0.19387576142268503, 0.2679347798208811, 0.14033956481489385, 0.23362355044712235, 0.08935229887314144, 0.21561304708737672, 0.18062903751566006, 0.20867826167832348, 0.20366834759852503, 0.1998584652254427, 0.19650965799562115, 0.1949299715439372, 0.1873780403352343, 0.23585276261164112, 0.17869719249569516, 0.6213634547787934, 0.24391043751681152, 0.21646951403957282, 0.5350902803889264, 0.7447554160370216, 0.23810512924079053, 0.21144572707722686, 0.20830040330605948, 0.8801683144134459, 0.16055324155014172, 0.1532019747677852, 0.8584474916115963, 0.1990126072885008, 0.1959550978257083, 0.12211515640687398, 0.1678705491086312, 0.1532703070674597, 0.43632073890620604, 0.20917896422762527, 0.16032223744381768, 0.5943520673562858, 0.168753309078724, 0.20894728975872623, 0.10468746093710068, 0.7703916109514025, 0.4836179834859209, 0.18978493147336717, 0.1841377718742223, 0.1773191160687888, 0.18728062667995238, 0.19936596873648116, 0.19344578597641926, 0.20902383048153206, 0.18304481789940874, 0.18117948990297983, 0.08946103413564577, 0.09165081185294965, 0.08950618942167787, 0.08776339607814465, 0.08207666188133389, 0.0773813751863821, 0.0884457636824012, 0.08533502503228196, 0.0830333980785013]}, "mutation_prompt": null}
{"id": "acee63c2-1953-43d2-b554-3175e6f91927", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly reduced mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Increased cognitive component\n        self.c2 = 1.9  # Decreased social component\n        self.inertia_weight = 0.6  # Reduced inertia weight for faster convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.996  # Adjusted cooling factor for different decay rate\n        self.exploration_factor = 0.15  # Increased exploration factor\n        self.adaptive_mutation = 0.05\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly reduced random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Switch phases every 120 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Enhanced Multi-Phase Swarm Optimization with Adaptive Mutation Control for Improved Convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.868376597977421, 0.8599684296209293, 0.881907284699789, 0.8817981304763994, 0.8782286169703105, 0.8320329598309161, 0.8753340250728163, 0.8567827600452298, 0.835133327110839, 0.7334069552497461, 0.7233259212052423, 0.7085616276548696, 0.733299588455351, 0.7149908659689703, 0.7001682747057044, 0.5544609435360084, 0.5824413013758059, 0.7238386223643003, 0.17485318973781738, 0.113609530084268, 0.1453708106762962, 0.15530403739385856, 0.17077266203709218, 0.13798185016062947, 0.05780572993975053, 0.12084256774785285, 0.4625359953088469, 0.14492150656084324, 0.17978128376662916, 0.46457013056396335, 0.15437340104484243, 0.11840379753070007, 0.13896075563128685, 0.14773215449486088, 0.15227169427736553, 0.14244028043555645, 0.9872043760238632, 0.9826347069352321, 0.9906572222909417, 0.9869103897766742, 0.9871096512289319, 0.9865068892254468, 0.9866096555794052, 0.986702912800172, 0.9865456688891193, 0.6243378369734709, 0.655891274823478, 0.6412361058508882, 0.6829195065458997, 0.5390490086371699, 0.6223520742567127, 0.6455032409951298, 0.6194513764114673, 0.5710635671061743, 0.17291478181165143, 0.15540101703690123, 0.21480621708444758, 0.2797133463130468, 0.2663872376702028, 0.2081961764314565, 0.15855368869687592, 0.16581229781628914, 0.2007275349479416, 0.10238427582035126, 0.19362196704791135, 0.17827829011417673, 0.13029928051099504, 0.18374229246624574, 0.1833126808761777, 0.19444232943209738, 0.20210314966651066, 0.11807753009792976, 0.19527108350050149, 0.11887387781710512, 0.13115108585216695, 0.1959254459985802, 0.3745258816609588, 0.19862872921422636, 0.21880767718245353, 9.999999999998899e-05, 0.21613882992118438, 9.999999999998899e-05, 9.999999999998899e-05, 0.032233289729648784, 0.07820629162496384, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012314830679409638, 0.05361080554430486, 9.999999999998899e-05, 0.044744112734891095, 0.041659896506688, 0.10448106141815205, 0.08561223903948534, 9.999999999998899e-05, 0.01101379834529781, 0.043449448526291956, 0.060492290223763456, 0.050142302679423434, 0.03470904886226911, 0.06428236115890995, 0.1923712087768209, 0.1271997916351364, 0.3592906978350021, 0.0896771782588196, 0.12403831002031951, 0.2941897487951045, 0.07203749355686573, 0.04808698111170673, 0.04301348783049741, 0.237284352233205, 0.051048453628932844, 0.031081794774595606, 0.020001997150258077, 0.08236011505266472, 0.09169006076457276, 0.05825995482400681, 0.5160779798025504, 0.5796718355648198, 0.539037154430671, 0.5630524210959394, 0.5415166670447795, 0.5484783027824239, 0.6026075154668025, 0.5607308275421558, 0.603307114501201, 0.10886850451654173, 0.14296516741076448, 0.09823699666623364, 0.11458275716142874, 0.0786617406758624, 0.10463296813643197, 0.06121408269486106, 0.09302726097936598, 0.10513524726154277, 0.1777790768599805, 0.3640676356715433, 0.22311799683478328, 0.3805160830002673, 0.35827514970694707, 0.17175705945018838, 0.6640912905101208, 0.22249816424392588, 0.23251846722486735, 0.2954736475202452, 0.20423628963245233, 0.20778907851132156, 0.264777093977661, 0.22020398567240063, 0.34998096525833355, 0.42314637397319865, 0.28676405053739396, 0.2841995953298062, 0.2504068629422983, 0.28588448896592633, 0.20060387871699337, 0.16945242632172552, 0.22385982946607497, 0.20985445888712173, 0.23613239106807582, 0.28471999455351693, 0.2339006697889019, 0.20129035333994205, 0.1963313106701845, 0.2051328529573766, 0.21602494288112384, 0.19705935197439195, 0.22567250893333413, 0.2364148322872024, 0.1859805100112759, 0.21959360980614862, 0.18871224540812614, 0.22249415541174045, 0.20419833455460723, 0.7798448461526082, 0.2237564108864183, 0.23000967375886783, 0.23600979928712695, 0.23996097935255534, 0.2033053236306528, 0.9158690216328449, 0.12580033805055169, 0.1543471842335693, 0.8831790355437801, 0.20042463491202334, 0.19749025832002876, 0.18793212426113015, 0.16997220968182958, 0.1532131912444593, 0.690971587890103, 0.21155425263723027, 0.4037971599487734, 0.6791365408320804, 0.16880412353327612, 0.2114818110771438, 0.1044347270694439, 0.21148496164823205, 0.5891772424141132, 0.1890836243706473, 0.20788497984744825, 0.19787210464994365, 0.18639288423842515, 0.21463688487040278, 0.18456701096454842, 0.1847788017624843, 0.1833852816776771, 0.2011370496193734, 0.06616231695229746, 0.10823231201569328, 0.1050999496395596, 0.08877648688834217, 0.07175798659968424, 0.1436180603852727, 0.09201977303326436, 0.08702563072685932, 0.09209869712104124]}, "mutation_prompt": null}
{"id": "b46ae13c-89b5-4825-a8fe-18b7c526d3c7", "solution": "import numpy as np\n\nclass DynamicMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.75  # Slightly reduced mutation factor for balance\n        self.crossover_rate = 0.75  # Increased crossover rate\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Adjusted social component for balance\n        self.inertia_weight = 0.7  # Adjusted inertia weight for better exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Slightly increased cooling factor\n        self.exploration_factor = 0.2  # Increased exploration factor\n        self.adaptive_mutation = 0.1  # Increased adaptive mutation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Slightly increased random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "DynamicMultiPhaseSwarm", "description": "Dynamic Multi-Phase Swarm Optimization with Adaptive Parameters for Enhanced Convergence and Exploration Balance.", "configspace": "", "generation": 87, "fitness": 0.28940348036116886, "feedback": "The algorithm DynamicMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8406921220318478, 0.8191590427742658, 0.813528153395353, 0.8225732790862549, 0.8477437941547331, 0.8323104889725663, 0.8290253616971971, 0.847369309343575, 0.7931008115225295, 0.5555280925204227, 0.518179869252309, 0.6595485935699634, 0.698541127461643, 0.5400943889949075, 0.5963374061276976, 0.6052885962956274, 0.6764337858200227, 0.6298328037156768, 0.13901648662027377, 0.11865301334425749, 0.11744828720679867, 0.29919194736798405, 0.14133653604505447, 0.11618025123292353, 0.11454692127967281, 0.06770547309980701, 0.17691919413808666, 0.3429345233882899, 0.11189725002735851, 0.1268338272559728, 0.1415775952550299, 0.12642193813330305, 0.11348289519768828, 0.11886244778476862, 0.11482387009696049, 0.1335246569491696, 0.9874969849664882, 0.9783400057325261, 0.9906238625749966, 0.9869252916669078, 0.9873684236661265, 0.98227204884309, 0.984436333616228, 0.9868171276472649, 0.9893936917823765, 0.5520480472026719, 0.582581681275039, 0.604921334133409, 0.5948010130776593, 0.6061530849146719, 0.4718164835862302, 0.5372093724728872, 0.5622977907139164, 0.5602512437657354, 0.379085996337835, 0.2075652595304306, 0.34877807004191697, 0.2771599369482526, 0.18946908787052108, 0.11181002572987675, 0.21560334566841854, 0.19155854796648009, 0.2042509356520522, 0.11802067069706879, 0.18346319367757935, 0.1766051268667247, 0.16782039865070442, 0.18964927939360976, 0.17099445202162966, 0.17548188889359684, 0.17909681833934132, 0.18621389609915473, 0.21723068895755115, 0.11715967398408722, 0.22004911163853158, 0.20654435429578066, 0.26721934210474985, 0.1315606286266342, 0.2050530640504804, 9.999999999998899e-05, 0.16832530212599106, 9.999999999998899e-05, 9.999999999998899e-05, 0.04630388874695979, 0.040044698164259485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07079464272046299, 0.039715050993877954, 0.01041529564617083, 0.05935283298473537, 0.00023959467665790601, 0.01891694043750103, 0.08626586451231377, 0.019486619905485947, 0.04957390602057676, 0.08155873164766303, 0.08890137835117928, 0.17340754109674794, 0.08860611520823936, 0.08203269069196373, 0.07294063112771132, 0.1232851711026004, 0.2526504487480744, 0.08892538881668355, 0.05147259310052554, 0.04485894057738338, 0.04879609068366386, 0.02078135513042567, 0.01252049069747141, 0.03250381656979462, 0.08179025842546284, 0.05692805961659175, 0.08040701110030313, 0.5147055505562528, 0.49839593395073134, 0.514734274099928, 0.5415361729669403, 0.5260346711692785, 0.52527286090461, 0.5414108706802818, 0.5484129513779283, 0.5373134720112885, 0.07885859126794059, 0.08703502080232106, 0.04900261651523907, 0.1434586281450404, 0.08508895126031435, 0.10849837182042188, 0.1183727720555533, 0.0824626619523966, 0.08822064708929733, 0.19227656870043253, 0.2816733816234973, 0.3816566617832191, 0.2754518728847015, 0.34944825684735137, 0.16985401509566023, 0.7122002073327605, 0.18307642898063536, 0.2397763120243409, 0.3358021861534237, 0.31393030303618796, 0.3118534967112916, 0.3468666700392332, 0.2315305847407223, 0.2813162083354108, 0.38715395795377405, 0.29502765666350705, 0.171363063140052, 0.07697228749571261, 0.2601200325158517, 0.17195547439851855, 0.2976775974105158, 0.21327318701220943, 0.270797600289465, 0.2092440665722486, 0.27262578691546346, 0.22266139508662963, 0.19771108692244477, 0.1786711836718381, 0.1837617939269992, 0.20129479960387786, 0.20615518001222688, 0.20025160681121557, 0.20044468516504532, 0.1976224155683446, 0.22234758177257974, 0.21315530831293628, 0.2020480032312324, 0.22005599195578696, 0.24287548637548584, 0.17836994372240533, 0.2024132519945614, 0.18703242269628984, 0.6187374280296309, 0.20365859479393378, 0.8736097834802082, 0.12631901166528492, 0.15370595488803152, 0.8724050631643512, 0.19960934955743148, 0.7827119354680661, 0.11169889096275598, 0.169491080576187, 0.15268235383087225, 0.3842616585898352, 0.2108541862876555, 0.12280961407368374, 0.6744626526207009, 0.16729328216960582, 0.20777889520663906, 0.1041912250674808, 0.7564833329504268, 0.10437603961712139, 0.2081402267127962, 0.20484672839969342, 0.18669359106884809, 0.17417252617285317, 0.22011771436541894, 0.18922611546703838, 0.21770158984652999, 0.19229807961715484, 0.20982864385251576, 0.08683910225447977, 0.098689944894361, 0.09783940058580176, 0.09254705476380409, 0.09567116464742997, 0.08889538619186843, 0.08760435256626264, 0.07903288100215244, 0.08281279602300473]}, "mutation_prompt": null}
{"id": "75ec32d6-78af-43a3-a5a6-8011e51b2dd1", "solution": "import numpy as np\n\nclass QuantumEnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Fine-tuned mutation factor\n        self.crossover_rate = 0.75  # Adjusted crossover rate\n        self.c1 = 2.0\n        self.c2 = 2.0  # Balanced cognitive and social components\n        self.inertia_weight = 0.7  # Adjusted inertia weight\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Further adjusted cooling factor\n        self.exploration_factor = 0.2  # Increased exploration factor\n        self.adaptive_mutation = 0.1  # More adaptive mutation\n        self.exploration_phase = True\n        self.quantum_factor = 0.02  # Introduced quantum factor\n    \n    def quantum_perturbation(self, position):\n        return position + self.quantum_factor * np.random.normal(0, 1, self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n                    if np.random.rand() < 0.5:  # Include quantum factor occasionally\n                        trial_vector = self.quantum_perturbation(trial_vector)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            if evaluations % 100 == 0:  # Switch phases every 100 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n            self.quantum_factor *= self.cooling_factor  # Apply cooling to quantum factor\n\n        return self.global_best_position, self.global_best_score", "name": "QuantumEnhancedMultiPhaseSwarm", "description": "Quantum-Enhanced Multi-Phase Swarm Optimization with Dynamic Phase Switching for Superior Convergence.", "configspace": "", "generation": 88, "fitness": 0.2724511140131805, "feedback": "The algorithm QuantumEnhancedMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.7432187270639239, 0.7429852196176735, 0.7359497056279445, 0.7705862673137563, 0.782252355099034, 0.7900060320163427, 0.7729693050521418, 0.7795233835482367, 0.74818103886576, 0.5531967623233166, 0.40677395674932737, 0.47269005261127817, 0.5128534843693251, 0.47378061929708337, 0.5350834595852147, 0.5614169518365455, 0.4893195274054073, 0.5453352006018117, 0.13930582018833482, 0.11903815778887672, 0.15802773133699233, 0.2240229056476607, 0.11162000516441639, 0.14237274387650545, 0.13042761485356347, 0.1645797257681093, 0.12871749410561784, 0.1167185515215251, 0.11245681628401782, 0.126344619687771, 0.12085715540115782, 0.11439712069461783, 0.1475762988637498, 0.11963477189010863, 0.14240203525772455, 0.12111117740103217, 0.9812085221548449, 0.9862892783850389, 0.9824361829817656, 0.9757546292010472, 0.9818495186368956, 0.9701028091400505, 0.9820204248376032, 0.9710015423370673, 0.98449144189532, 0.3919327351722447, 0.46437890267849746, 0.430234255179053, 0.43269288643641857, 0.45237349664439164, 0.4806754254057306, 0.38170370985259827, 0.4179314446248106, 0.42983430794120603, 0.16913850131249308, 0.35016419196917725, 0.21617011267844355, 0.21324123070924084, 0.2640086356712644, 0.2603631647152551, 0.17997228631116868, 0.1317983132284013, 0.17253846185415678, 0.1814008062620418, 0.17131801806789337, 0.24252286291762348, 0.1302244374035325, 0.1760566725450351, 0.1732349783653464, 0.1585291836347804, 0.15982781958327485, 0.17087914937721704, 0.18412032781663934, 0.11518794601783089, 0.1162232957517112, 0.16525919469973016, 0.1503395490858871, 0.12338012060441739, 0.09980245367053353, 0.09720499688006001, 0.11243684912555763, 0.035028898175122225, 9.999999999998899e-05, 0.008566827169197322, 0.042057340532366094, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07818088408655166, 0.015724816165497812, 0.0696006108924474, 0.07392075931036579, 0.02560436806971933, 0.021508754186451706, 0.10781559611000469, 0.10177860821444396, 0.054548213472782714, 0.03855735299716345, 0.03148447143261324, 0.0756228821243834, 0.05966898374959162, 0.07953384591295254, 0.06513441380554885, 0.15080017516944066, 0.06242555587783705, 0.05739721027590983, 0.11551366201008673, 0.050770887953302535, 0.09900754769191966, 0.0831344224833751, 0.07659042171027508, 0.26224995015083075, 0.12316821831618019, 0.07483723894733962, 0.1277663485307139, 0.4807085012652167, 0.5292680567274395, 0.49388386361020364, 0.4707456205126338, 0.49459246753993913, 0.48293669669788064, 0.5332790093416079, 0.4646657764084128, 0.4751550347884774, 0.0886948340818301, 0.08829187474223621, 0.08768683092023222, 0.14417327814987435, 0.09607658486717296, 0.10290783897088163, 0.1069480880946696, 0.11027628113267673, 0.08415551997970816, 0.2752422679635479, 0.3607683431513047, 0.2309370186757097, 0.2821035345742924, 0.15844938928620889, 0.23716057094618082, 0.4427655583720407, 0.20357131295949615, 0.20943345076144793, 0.25123025322972303, 0.20608303274216289, 0.3904242428267499, 0.32513380922950597, 0.38584642759812904, 0.36631795485834084, 0.4146812961342199, 0.39361685572778315, 0.4901866789197977, 0.22002844045676706, 0.22250980322011427, 0.30418818991302554, 0.215877495156248, 0.17748374094399388, 0.2618175214131394, 0.29607198660791223, 0.2563108240588997, 0.2617121552752556, 0.2578932114563862, 0.15940793740406844, 0.18412114718173112, 0.19588131788154806, 0.20273543944018557, 0.1842848848411145, 0.20652105159606127, 0.1765349233639194, 0.21552475653461867, 0.2382087082061609, 0.23628026870452767, 0.18674237108789438, 0.20220337744777173, 0.22071307554660813, 0.19718203043150984, 0.21784341624323178, 0.20282105552049756, 0.22249501514384018, 0.1043814423275864, 0.16184978560118912, 0.7721356096387446, 0.7825173434459111, 0.19962983191201022, 0.19798104521588578, 0.163304783607768, 0.17040682832478993, 0.6972041134186138, 0.7623360460902758, 0.1563090813378083, 0.1120211935730776, 0.2066192859388103, 0.39034421757155824, 0.20451632525597285, 0.21218431122212866, 0.1035967601950557, 0.4657053468454382, 0.2204475734220287, 0.19641170027027333, 0.22716425366441162, 0.19986186175879983, 0.1842919762741999, 0.19218678090828056, 0.19016609337583634, 0.21137044863466015, 0.22581850452754126, 0.07953849700891646, 0.08816133439970397, 0.08619691084937908, 0.08202465978077522, 0.07828782825509095, 0.08150726943186493, 0.1009712634382981, 0.08565197230635713, 0.06795891214956118]}, "mutation_prompt": null}
{"id": "d6ed6997-b73e-42b8-a8fe-31bda01c6825", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted for better exploration\n        self.crossover_rate = 0.75  # Slightly increased for diversity\n        self.c1 = 2.0  # Balanced cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7  # Slightly increased inertia for stability\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Slightly adjusted cooling\n        self.exploration_factor = 0.2  # Increased for better exploration\n        self.adaptive_mutation = 0.07  # Increased adaptive mutation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.2:  # Increased random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases more frequently\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Multi-phase Adaptive Swarm Optimization with Enhanced Mutation and Phase Switching for Versatile Optimization.", "configspace": "", "generation": 89, "fitness": 0.2847260445946201, "feedback": "The algorithm EnhancedMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8290300286532024, 0.8420918971463464, 0.8295866599595071, 0.8457297279937104, 0.8232299033364309, 0.8379292520467043, 0.849606841910549, 0.8444611926618172, 0.8392220042895988, 0.7181815748970545, 0.5758058376735958, 0.6564988742117888, 0.6828458275498321, 0.6780678959364327, 0.5420446044976772, 0.6435754120540056, 0.6551995438011642, 0.7229736570316768, 0.13985855094503608, 0.03686150538216881, 0.13592797233808251, 0.717826208698217, 0.07002881306235031, 0.1160959013241154, 0.7119626647657838, 0.17429231810336676, 0.16269889828184037, 0.13703339949836135, 0.12258846640539467, 0.13995933571906538, 0.14804328276415568, 0.1443176309031211, 0.15429759671309606, 0.10689910098622146, 0.1241137770099573, 0.12060480950214658, 0.9875366037155896, 0.9786956037423926, 0.9906448839302588, 0.9870791608887861, 0.9874977367472986, 0.9822707514171621, 0.9845408543078151, 0.9868165325946853, 0.9894187341562873, 0.605711133429681, 0.6415956574633339, 0.6208079403868696, 0.5961930180583128, 0.5028211488298668, 0.634991101686363, 0.5118244365054326, 0.5231385692476366, 0.5108442001641809, 0.22598667912475323, 0.163996372336785, 0.17045034662077252, 0.26404624852138914, 0.18931361174698813, 0.21429025721535644, 0.20252838911396776, 0.12765646648046036, 0.13962930672645057, 0.11486834660769396, 0.17995595772195971, 0.18991668455215827, 0.1935847780373947, 0.17764969076993586, 0.12070872544610478, 0.1719913470207246, 0.19623366423774202, 0.20991576853538185, 0.1938323339604463, 0.11690100591411756, 0.12288706223859258, 0.18773984360124985, 0.1773269423165844, 0.1940562021352814, 0.22553128603593253, 9.999999999998899e-05, 0.12217409540035118, 9.999999999998899e-05, 9.999999999998899e-05, 0.05569358999186713, 0.012187013944634728, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09840693982560167, 0.02963803043998503, 0.11448562544977592, 0.048163234516832576, 0.006323288327594878, 0.013896204210115726, 0.07984680118974097, 0.04322277370138505, 0.05313728620662728, 0.05286808262982157, 0.06618597552958816, 0.19845002966082592, 0.0893385400337876, 0.06769913947021289, 0.07075254732527048, 0.11356920209284693, 0.1901715563381592, 0.0689670542116797, 0.05148094009510018, 0.03957506940969402, 0.17444693208390727, 0.016654282110557306, 0.06594978524530382, 0.018045374722043372, 0.08574605611719144, 0.05531497090018089, 0.05679447312168451, 0.5257368543462803, 0.4984553536552544, 0.5342929639423722, 0.5167252947985301, 0.5316169193194736, 0.5535658265565527, 0.5555521405051242, 0.5485544588887907, 0.5274232538772589, 0.07890473604866743, 0.12759667685188847, 0.09528056486840086, 0.1281386166672297, 0.11576029429200685, 0.11764568844395185, 0.13538402975249997, 0.09983416496007391, 0.09286679968849298, 0.18762271612514392, 0.26788902037974227, 0.31167171170236174, 0.24788705180536286, 0.27428719397094514, 0.10878513114153954, 0.2771532017837557, 0.40569811534133493, 0.260152233611022, 0.2695163050712873, 0.26886805684916604, 0.25446993239744775, 0.384086610725345, 0.23583238850136512, 0.2972991872909796, 0.4292977277708966, 0.3347980548907764, 0.15918417859386258, 0.0775956540867081, 0.25169307537331786, 0.18435305625187537, 0.18677162722998097, 0.19311430311262934, 0.20497215071802533, 0.20587318632842055, 0.31567318783834186, 0.20898685076187173, 0.20965331830521572, 0.20114753228972126, 0.2081922771633694, 0.19036902951597112, 0.1500491387604732, 0.20047217120212435, 0.21941280418146702, 0.19719032931480207, 0.19524766239317337, 0.2333470590388408, 0.24394917575216968, 0.21214078141542003, 0.20604888378875563, 0.24602839976376933, 0.20744288500418628, 0.18999204728561658, 0.20579361239010519, 0.21836944546077453, 0.87060348835742, 0.14525867989558805, 0.15375129184819014, 0.8787099294610445, 0.19904310158003313, 0.16197396286884214, 0.12207063630641246, 0.16991766616340187, 0.15211916136604087, 0.15346220864003535, 0.20882872190641977, 0.42730864659030954, 0.207255618076585, 0.16695446363711386, 0.21049244971479042, 0.10489001673446441, 0.2095120016590104, 0.49470339733645574, 0.18408554009233935, 0.19445498323179922, 0.2030003055564249, 0.19642924562205777, 0.20811338046388417, 0.19791688733928825, 0.18460816126379354, 0.21127251360231258, 0.2049363719586057, 0.07766431797848694, 0.08635053383068914, 0.08529689400069929, 0.08438791831466863, 0.0995470573238243, 0.15513292436578408, 0.08938807926568193, 0.07267540188320032, 0.07409532741381897]}, "mutation_prompt": null}
{"id": "17d3eeb3-f79e-4f51-9335-567d0c7e731a", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Slightly altered mutation factor for diversity\n        self.crossover_rate = 0.75  # Slightly increased crossover rate\n        self.c1 = 1.8  # Tweaked cognitive component\n        self.c2 = 2.0  # Tweaked social component\n        self.inertia_weight = 0.65  # Adjusted inertia weight for better balance\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Carefully adjusted cooling factor\n        self.exploration_factor = 0.2  # Enhanced exploration factor\n        self.adaptive_mutation = 0.06  # Adjusted adaptive mutation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases more frequently\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridAdaptiveSwarm", "description": "Hybrid Adaptive Swarm Optimization with Dynamic Parameter Adjustment for Enhanced Convergence and Exploration Balance.", "configspace": "", "generation": 90, "fitness": 0.3004873961900331, "feedback": "The algorithm HybridAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8624501245117517, 0.8541383329487183, 0.8284917207642338, 0.8777840361338032, 0.8581772111043926, 0.8364743116394054, 0.8522030436603042, 0.8464681762222648, 0.8815545340778362, 0.7333190725851466, 0.6108336237826199, 0.6674445351700572, 0.7446425190981405, 0.6954174995601896, 0.7065759721004246, 0.7932016242806259, 0.6802529003676803, 0.7411443458652318, 0.153755034512846, 0.04260794873919804, 0.1573997852633443, 0.17379855770465436, 0.15143757368787736, 0.11556225751035731, 0.15108202986398156, 0.15762363289415005, 0.17210892663071353, 0.13487287791520208, 0.13170353119406486, 0.15270452731157458, 0.12726335987736603, 0.11281373275646878, 0.1220058761841274, 0.1103121421288561, 0.14165838444903178, 0.3149858954628645, 0.9875269109562367, 0.9783667617549606, 0.9906582558291019, 0.9870173528076586, 0.9875291918160463, 0.9795899199301309, 0.9841936186046142, 0.9868409411254865, 0.9894097280812868, 0.700460525002003, 0.6256911821652567, 0.6383537664060146, 0.6747653655974016, 0.7219092200279387, 0.6016748464532526, 0.6564306203035698, 0.6636258284289152, 0.5765563038768504, 0.17265608493627826, 0.20440273385069607, 0.2460642483184482, 0.21388729730455236, 0.19144178887417396, 0.834847975427, 0.15916315094313305, 0.22181747362784432, 0.10224518016398543, 0.12680959016185767, 0.19570523126292894, 0.20229922445085546, 0.20822565639993607, 0.1280139220052311, 0.12403184476100393, 0.20357771688602877, 0.25989322589245034, 0.1887839975508434, 0.21889076893767867, 0.1204250754732713, 0.12932444785047215, 0.19248244881635035, 0.21723984010044062, 0.1962578118505146, 0.26165314514167815, 0.016208430087631176, 0.11346783950394479, 9.999999999998899e-05, 9.999999999998899e-05, 0.03582619221160088, 0.014742751286994316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10188258794847116, 0.07299326876660561, 0.047553498016176476, 0.07541092056648036, 0.06795031069897828, 0.014705158525063378, 0.017890059150542204, 0.10608820460732638, 0.07496710968367881, 0.0671591544605421, 0.04674994613496675, 0.07726652015892554, 0.09737274153147646, 0.09224119196539815, 0.08473584658086142, 0.07564744740019103, 0.09361016369078023, 0.07065663624914853, 0.0707257626389628, 0.04424183869353815, 0.044808543284416746, 0.16293514630058548, 0.25571825276069515, 0.012737440150676238, 0.0532343656640909, 0.08479695125242193, 0.05619396149309264, 0.22482288928210947, 0.54532119027391, 0.5434972819979873, 0.5217380368484243, 0.5500623055985923, 0.5650401348259102, 0.5504784860193928, 0.5479432627310394, 0.5654513548613207, 0.5618729561409481, 0.0648828350740126, 0.0957852727021784, 0.06651093409443198, 0.14448756760660675, 0.13625726033358532, 0.09431742706863222, 0.0823826737587744, 0.11233928063810394, 0.1097901025201623, 0.1439714792679433, 0.3217959482546836, 0.4695939644654661, 0.19484388826856414, 0.43003855021017434, 0.2066075706868844, 0.44342552692577064, 0.16601917240298136, 0.20523254676626723, 0.4726545851249725, 0.2698789756736405, 0.31993015484450094, 0.34693593770011044, 0.3058328187053313, 0.3491147674955647, 0.5089451366748436, 0.45799349781628007, 0.43464138633371263, 0.17209683370167117, 0.18378367880258106, 0.12272974694834049, 0.17759930862894213, 0.19905734416282195, 0.20268472886441646, 0.12380431410934667, 0.27192263048821297, 0.09463760017555689, 0.23213993689251688, 0.2163703974874781, 0.18222128910634283, 0.18020057030613712, 0.14731738983739617, 0.20037578576490267, 0.24773444328176508, 0.2036567500093811, 0.23044935421131596, 0.20059524258050954, 0.4295602706011884, 0.25091071123044817, 0.20633271905705175, 0.24953919155836723, 0.1902580627423085, 0.19126618021115427, 0.21514913227456323, 0.2078997019650688, 0.9019153901487229, 0.1631925237085381, 0.1542279740387601, 0.8713533126961217, 0.19920744827717773, 0.16249110750618545, 0.12159533776571663, 0.1702597499732832, 0.1530962770265213, 0.5039363072962045, 0.21159305091595904, 0.07295467603289085, 0.5543606391563007, 0.1677174757404668, 0.2094093697593381, 0.10486422621036473, 0.16466930001003688, 0.6880622773609455, 0.1994090372765931, 0.20042492074525786, 0.20188187222431475, 0.24208895305230915, 0.21501857517856682, 0.20667915993394004, 0.18708086835246707, 0.21355350238079374, 0.2289876986831887, 0.0816095210539759, 0.07334539915663574, 0.08821818494347955, 0.09154834682790769, 0.09247665874383126, 0.10890702267619057, 0.07391664189183178, 0.08634624463552576, 0.08201993109507333]}, "mutation_prompt": null}
{"id": "2e6b1a75-aaa9-46af-89a4-1a419bb0298f", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Increased mutation factor for more exploration\n        self.crossover_rate = 0.7\n        self.c1 = 2.0  # Balanced cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7  # Increased inertia weight for exploration\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.2  # Further increased exploration factor\n        self.adaptive_mutation = 0.1  # Increased adaptive mutation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "AdaptiveSwarmOptimization", "description": "Adaptive Swarm Optimization with Dynamic Mutation for Enhanced Global Exploration.", "configspace": "", "generation": 91, "fitness": 0.2941942701040645, "feedback": "The algorithm AdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8336773901849891, 0.8114325462420484, 0.8266589726918805, 0.8293865267607938, 0.859335455686937, 0.829873509394782, 0.8277110615436203, 0.8085452682784784, 0.8549245617120249, 0.6237670159738549, 0.7006377628439815, 0.6584920125993844, 0.5504386065121215, 0.7021343667898801, 0.7107465911173295, 0.7143350633636035, 0.7293355741443763, 0.6190341129192863, 0.15347224930992942, 0.07156009105928529, 0.15585024168059258, 0.7021832450994863, 0.1368477070072689, 0.1386039590875725, 0.1608171022241469, 0.06848387799684985, 0.16057926081674834, 0.16570136757934084, 0.1317173549133267, 0.16396090968305777, 0.12016277163566369, 0.13380230997614107, 0.1641162369186181, 0.15202096631431128, 0.11474405032250556, 0.11127272457141002, 0.9872155173857147, 0.9826450819465916, 0.9906333382161796, 0.9868491699012514, 0.9872199048415456, 0.9841063191964879, 0.9867007123712561, 0.9867375281584154, 0.9893934558725974, 0.5747949144840521, 0.45664438434244947, 0.540138949259056, 0.5051169178879873, 0.4383388508317395, 0.4147241297123305, 0.5857399760641657, 0.5251885949733082, 0.5165715718826176, 0.2221090790221627, 0.15877730631369447, 0.22540898144191057, 0.2188691332909577, 0.7701529641081665, 0.11654985893697523, 0.771974731779705, 0.14848095101717695, 0.6705861262816792, 0.11622987464410617, 0.17723633220720936, 0.18293636312532957, 0.1869246180618721, 0.18353553279265988, 0.19034033869466604, 0.17760762563578825, 0.18019769666929952, 0.20716865677217344, 0.19338214588678848, 0.11669944403576793, 0.13080197992139386, 0.18555542955851057, 0.184250876901912, 0.1777265628583955, 0.23003430703886696, 0.13166918199440314, 0.12596494604305775, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0364713092864265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07276715406586665, 0.025786147216288136, 0.09413286237116913, 0.033297826930293595, 0.07648811897438279, 0.0272184902741901, 0.013069756910303432, 0.008828449130297122, 0.1660864512881477, 0.04917396351656511, 0.05417616401063241, 0.032999263430094516, 0.09401561353025756, 0.03142383019602579, 0.10371446066152601, 0.0712587639045692, 0.07269239442982434, 0.10783901367601434, 0.14362759997850627, 0.0696235253906452, 0.04334043508917096, 0.041535788300966825, 0.12147705628822714, 0.038103958792468084, 0.018841196716097297, 0.05067598180074784, 0.11534400972878522, 0.05572605500276062, 0.05564316736796848, 0.524981269682764, 0.4928428739516547, 0.5189687746211618, 0.5745190566063547, 0.5601105236082383, 0.537885738183765, 0.5053233045233684, 0.5361269419488339, 0.5521961180070569, 0.10968096229865698, 0.06173722527274461, 0.12368302090859129, 0.1176751838475939, 0.10110464324329893, 0.1794404245703779, 0.09559347515708683, 0.11096078069118898, 0.10320873887907878, 0.3079016288532169, 0.20669778820640528, 0.2038615933877317, 0.2620630823234582, 0.33067798491027056, 0.16802548297421693, 0.41054660245018093, 0.2433513366156852, 0.1889276188459854, 0.33733722763146956, 0.21336986939953206, 0.24942785570368264, 0.27223440320508985, 0.38099443073821304, 0.3327415144279541, 0.27771085764174164, 0.3766976951719464, 0.16403566689191806, 0.25828484304471877, 0.17639488584518093, 0.1818006534656652, 0.227827890131853, 0.20086264839411316, 0.1457091192354656, 0.32265473279476475, 0.2846349279788669, 0.08549373482819012, 0.20581103641864118, 0.2330514497253121, 0.19987430124929606, 0.2145262059389298, 0.21899266472682244, 0.22794874073242932, 0.2249130711040228, 0.19825258922457478, 0.2321978397208413, 0.2159849035075636, 0.24943376296933029, 0.23790359330892275, 0.20813039726931415, 0.22381717264291312, 0.21095235165904935, 0.2165655181861572, 0.21318063660664988, 0.20365199477001383, 0.8698302645544806, 0.1567579121863053, 0.15397702651457834, 0.8324830541428057, 0.20055136613046565, 0.19720760941473248, 0.11596291079768906, 0.16913766318229595, 0.15373546818947526, 0.18723034276690265, 0.20974528192060293, 0.20020440914367144, 0.6840302613438698, 0.5557548743193717, 0.21055740388292765, 0.2022064827383122, 0.2105712993853467, 0.74249670384625, 0.19948164887351327, 0.21969962980092428, 0.21489730318905698, 0.2227394923858006, 0.1926890818663224, 0.25877996450867746, 0.19978383726625115, 0.20966647236132863, 0.19132424922798108, 0.08719193372018619, 0.09890479180947409, 0.0907275697984189, 0.0889708374796393, 0.08993211018543501, 0.05005206219078295, 0.09354464820997088, 0.10035786124279422, 0.09101315746396887]}, "mutation_prompt": null}
{"id": "30adddaa-c802-44cf-86b3-3ae82673eb57", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.8  # Slightly reduced mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.1  # Increased cognitive component\n        self.c2 = 1.9  # Decreased social component\n        self.inertia_weight = 0.6  # Reduced inertia weight for faster convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.996  # Adjusted cooling factor for different decay rate\n        self.exploration_factor = 0.15  # Increased exploration factor\n        self.adaptive_mutation = 0.05\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.25:  # Slightly reduced random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 120 == 0:  # Switch phases every 120 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Enhanced Multi-Phase Swarm Optimization with Adaptive Mutation Control for Improved Convergence.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.868376597977421, 0.8599684296209293, 0.881907284699789, 0.8817981304763994, 0.8782286169703105, 0.8320329598309161, 0.8753340250728163, 0.8567827600452298, 0.835133327110839, 0.7334069552497461, 0.7233259212052423, 0.7085616276548696, 0.733299588455351, 0.7149908659689703, 0.7001682747057044, 0.5544609435360084, 0.5824413013758059, 0.7238386223643003, 0.17485318973781738, 0.113609530084268, 0.1453708106762962, 0.15530403739385856, 0.17077266203709218, 0.13798185016062947, 0.05780572993975053, 0.12084256774785285, 0.4625359953088469, 0.14492150656084324, 0.17978128376662916, 0.46457013056396335, 0.15437340104484243, 0.11840379753070007, 0.13896075563128685, 0.14773215449486088, 0.15227169427736553, 0.14244028043555645, 0.9872043760238632, 0.9826347069352321, 0.9906572222909417, 0.9869103897766742, 0.9871096512289319, 0.9865068892254468, 0.9866096555794052, 0.986702912800172, 0.9865456688891193, 0.6243378369734709, 0.655891274823478, 0.6412361058508882, 0.6829195065458997, 0.5390490086371699, 0.6223520742567127, 0.6455032409951298, 0.6194513764114673, 0.5710635671061743, 0.17291478181165143, 0.15540101703690123, 0.21480621708444758, 0.2797133463130468, 0.2663872376702028, 0.2081961764314565, 0.15855368869687592, 0.16581229781628914, 0.2007275349479416, 0.10238427582035126, 0.19362196704791135, 0.17827829011417673, 0.13029928051099504, 0.18374229246624574, 0.1833126808761777, 0.19444232943209738, 0.20210314966651066, 0.11807753009792976, 0.19527108350050149, 0.11887387781710512, 0.13115108585216695, 0.1959254459985802, 0.3745258816609588, 0.19862872921422636, 0.21880767718245353, 9.999999999998899e-05, 0.21613882992118438, 9.999999999998899e-05, 9.999999999998899e-05, 0.032233289729648784, 0.07820629162496384, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012314830679409638, 0.05361080554430486, 9.999999999998899e-05, 0.044744112734891095, 0.041659896506688, 0.10448106141815205, 0.08561223903948534, 9.999999999998899e-05, 0.01101379834529781, 0.043449448526291956, 0.060492290223763456, 0.050142302679423434, 0.03470904886226911, 0.06428236115890995, 0.1923712087768209, 0.1271997916351364, 0.3592906978350021, 0.0896771782588196, 0.12403831002031951, 0.2941897487951045, 0.07203749355686573, 0.04808698111170673, 0.04301348783049741, 0.237284352233205, 0.051048453628932844, 0.031081794774595606, 0.020001997150258077, 0.08236011505266472, 0.09169006076457276, 0.05825995482400681, 0.5160779798025504, 0.5796718355648198, 0.539037154430671, 0.5630524210959394, 0.5415166670447795, 0.5484783027824239, 0.6026075154668025, 0.5607308275421558, 0.603307114501201, 0.10886850451654173, 0.14296516741076448, 0.09823699666623364, 0.11458275716142874, 0.0786617406758624, 0.10463296813643197, 0.06121408269486106, 0.09302726097936598, 0.10513524726154277, 0.1777790768599805, 0.3640676356715433, 0.22311799683478328, 0.3805160830002673, 0.35827514970694707, 0.17175705945018838, 0.6640912905101208, 0.22249816424392588, 0.23251846722486735, 0.2954736475202452, 0.20423628963245233, 0.20778907851132156, 0.264777093977661, 0.22020398567240063, 0.34998096525833355, 0.42314637397319865, 0.28676405053739396, 0.2841995953298062, 0.2504068629422983, 0.28588448896592633, 0.20060387871699337, 0.16945242632172552, 0.22385982946607497, 0.20985445888712173, 0.23613239106807582, 0.28471999455351693, 0.2339006697889019, 0.20129035333994205, 0.1963313106701845, 0.2051328529573766, 0.21602494288112384, 0.19705935197439195, 0.22567250893333413, 0.2364148322872024, 0.1859805100112759, 0.21959360980614862, 0.18871224540812614, 0.22249415541174045, 0.20419833455460723, 0.7798448461526082, 0.2237564108864183, 0.23000967375886783, 0.23600979928712695, 0.23996097935255534, 0.2033053236306528, 0.9158690216328449, 0.12580033805055169, 0.1543471842335693, 0.8831790355437801, 0.20042463491202334, 0.19749025832002876, 0.18793212426113015, 0.16997220968182958, 0.1532131912444593, 0.690971587890103, 0.21155425263723027, 0.4037971599487734, 0.6791365408320804, 0.16880412353327612, 0.2114818110771438, 0.1044347270694439, 0.21148496164823205, 0.5891772424141132, 0.1890836243706473, 0.20788497984744825, 0.19787210464994365, 0.18639288423842515, 0.21463688487040278, 0.18456701096454842, 0.1847788017624843, 0.1833852816776771, 0.2011370496193734, 0.06616231695229746, 0.10823231201569328, 0.1050999496395596, 0.08877648688834217, 0.07175798659968424, 0.1436180603852727, 0.09201977303326436, 0.08702563072685932, 0.09209869712104124]}, "mutation_prompt": null}
{"id": "6df53b2c-82e4-4b59-ad7f-3de24fd9a45d", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.6  # Slightly reduced crossover rate\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Adjusted social component to balance exploration and exploitation\n        self.inertia_weight = 0.7  # Increased inertia weight for stability\n        self.max_evaluations = budget\n        self.cooling_factor = 0.994  # Slightly modified cooling factor\n        self.exploration_factor = 0.18  # Increased exploration factor for initial phase\n        self.adaptive_mutation = 0.07  # Adjusted adaptive mutation for diversity\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Increased random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 150 == 0:  # Switch phases every 150 evaluations\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedMultiPhaseSwarm", "description": "Improved Multi-Phase Swarm Optimization with Dynamic Parameter Tuning for Enhanced Performance.", "configspace": "", "generation": 93, "fitness": 0.27338701569172963, "feedback": "The algorithm EnhancedMultiPhaseSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.7496140953359275, 0.7506161732246166, 0.7974668512390621, 0.7704679030270499, 0.7726532017413331, 0.7882288977970398, 0.7407158913827943, 0.8038169423031277, 0.7611096116417257, 0.4330482218215489, 0.5766846166507165, 0.4481749477571231, 0.5969378893838677, 0.6508152979252599, 0.5243076574885726, 0.527851768286622, 0.5616731515571851, 0.5469142636278612, 0.16537496367720983, 0.2379200447097639, 0.08103343193952406, 0.37188429659769073, 0.06894764282031285, 0.17556465136317423, 0.13186513789475118, 0.47322549890408194, 0.1589205626675133, 0.12239411014661183, 0.11736563634877384, 0.08620650940151242, 0.1300901475137649, 0.10631257819931039, 0.11189475933601878, 0.12672890694699923, 0.12971822711688985, 0.12301816935771925, 0.984310458128582, 0.9915045637269977, 0.9862652874963446, 0.9772236477806158, 0.9856817837475735, 0.9801061226643349, 0.9850334728556105, 0.9759209828106025, 0.9807559475045972, 0.5213101995231118, 0.37279973521055276, 0.45386574608001007, 0.3783444303154242, 0.3758302380229427, 0.46571769295072285, 0.4342286606514967, 0.3961817376647244, 0.418346781592292, 0.35170657010578865, 0.21920935603594904, 0.2227853119016926, 0.2698942134592337, 0.25636419441317304, 0.2705742888036823, 0.20392665211622762, 0.15529482504683878, 0.14575065327706616, 0.16478994435985483, 0.16599670482367201, 0.4540968551872929, 0.12861955251100177, 0.18187582392214086, 0.17363039431420146, 0.27615769741955276, 0.16368878086179395, 0.17285476519694754, 0.1571364073210143, 0.11457734331662373, 0.1262711382765046, 0.1887706723970014, 0.10539895864346294, 0.12156224135507931, 0.10144949712510765, 9.999999999998899e-05, 0.11551732399580361, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02359582206210964, 9.999999999998899e-05, 9.999999999998899e-05, 0.03041659631183624, 9.999999999998899e-05, 0.0001482249016977466, 0.07245323248495406, 0.03837267200104688, 0.08613926710013364, 0.08540750392838747, 0.019946403322561146, 0.02365956409573433, 0.13362464742569558, 0.08089012773861681, 0.056241569625957166, 0.041016372481486596, 0.18732386517319266, 0.11743563578735561, 0.06424939832003018, 0.0758996578647595, 0.06500435157114492, 0.0907936944679767, 0.06234772507707187, 0.060280414421352124, 0.21104514042684863, 0.04067299615172082, 0.06187164081042462, 0.04006831418543755, 0.050978698130061284, 0.19120458222791992, 0.08239129253801603, 0.061753264383384354, 0.09875073022479863, 0.4938353753622974, 0.49482363235054005, 0.49234640422697495, 0.5137992278878918, 0.5076592127058, 0.4925336666843029, 0.5547774167083683, 0.5186087554549013, 0.5010742445030085, 0.14319547328593596, 0.12245800996014755, 0.056233088070325676, 0.11359023430128634, 0.09575340251513897, 0.09675396098645395, 0.12366733825650622, 0.0743968509286429, 0.13007017246975106, 0.25908243080872295, 0.143064196950618, 0.18533165848778455, 0.381074630659332, 0.35647716397540785, 0.17994007285090519, 0.46853128835086943, 0.22316415374620824, 0.14274593574618089, 0.33225953087973836, 0.2713642755438773, 0.36393343905710684, 0.4401168938951392, 0.34585962019201655, 0.21542469810245268, 0.41908544428620575, 0.4344764377990602, 0.385930295518049, 0.26184071227606787, 0.17901753294841927, 0.2709213136952854, 0.2001525941971719, 0.2138098800264906, 0.21832812151305492, 0.20589345353583777, 0.24928705447062272, 0.17340282437413024, 0.206119646518383, 0.1613047447960525, 0.21059829018403375, 0.19470513385314336, 0.16065494829974303, 0.2006752112878718, 0.2036607159480851, 0.217585075542425, 0.21344113009997434, 0.2080315093877787, 0.21119595139184189, 0.23273458386831503, 0.2156273586045937, 0.21465363073457266, 0.19114455462467317, 0.2086199362212643, 0.1936751304314367, 0.18906716414345015, 0.19232960902950302, 0.16407858787506135, 0.15358176225676456, 0.7764395888535327, 0.19750249494299155, 0.19888429717333178, 0.13493411351146756, 0.1688765310848832, 0.21325257402944175, 0.6792319165384342, 0.15404492609901588, 0.2025754843071086, 0.590443593404109, 0.3883187968726801, 0.20723416316601073, 0.10518698671951843, 0.10375065783939186, 0.6046964539125352, 0.200813245421663, 0.20685829362034514, 0.1975361729155236, 0.20146561132877483, 0.1809618956951463, 0.19980314226602292, 0.18522170502283142, 0.19031709099744132, 0.20439929057467743, 0.07998611378678111, 0.08435407034237763, 0.0844536131432696, 0.09635700942901348, 0.08052646615879766, 0.07611433580741012, 0.07802052341370203, 0.07342956844976412, 0.07045414965359942]}, "mutation_prompt": null}
{"id": "95676d47-9eef-499f-9855-a9b15f14b122", "solution": "import numpy as np\n\nclass HybridEvolutionaryParticleSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor for better exploration\n        self.crossover_rate = 0.75  # Slightly increased crossover rate\n        self.c1 = 2.0  # Balanced cognitive component\n        self.c2 = 2.0  # Balanced social component\n        self.inertia_weight = 0.7  # Adjusted inertia weight for stability\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor\n        self.exploration_factor = 0.2  # More pronounced exploration factor for variety\n        self.adaptive_mutation = 0.1  # Increased adaptive mutation for greater variation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Slight increase in random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 150 == 0:  # Switch phases every 150 evaluations for balance\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridEvolutionaryParticleSwarm", "description": "Hybrid Evolutionary Particle Swarm with Adaptive Parameters for Robust Convergence Across Diverse Functions.", "configspace": "", "generation": 94, "fitness": 0.26769434037248285, "feedback": "The algorithm HybridEvolutionaryParticleSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8041560655921316, 0.7344225572775902, 0.750452838896912, 0.7728269651688908, 0.7070322092913977, 0.785123428239207, 0.7231210444664427, 0.7510074852545304, 0.7539977057947622, 0.4927031491555788, 0.46935492235825715, 0.38941897847011697, 0.4246122169577361, 0.5368625978407321, 0.5511644251318606, 0.4704170332862945, 0.49543416889308567, 0.5756038639067166, 0.1250449583818941, 0.1335544412980012, 0.14021744231337452, 0.1446023936812164, 0.14919857704025363, 0.13831995487520965, 0.42439027358587844, 0.12964580254687075, 0.15407182889846915, 0.1318544546780831, 0.12096069390129927, 0.12823461481002818, 0.13506217926421193, 0.11200520652169577, 0.12059390433165318, 0.1059556754139851, 0.10677830549030842, 0.10139217915353405, 0.9842356534216198, 0.9860099914269599, 0.9861612070003691, 0.9762740389966835, 0.9856368763568312, 0.9763448293667213, 0.9810917618347356, 0.9747578346826389, 0.9801889017690816, 0.4581281301569854, 0.3650834547024051, 0.4183778020482777, 0.46986027784908035, 0.42868164577836, 0.42469602096867154, 0.44709089836363725, 0.4113211297246787, 0.4192229255282863, 0.3518671504939077, 0.18822565084519371, 0.21294139563346248, 0.7716543342923347, 0.2141393683573345, 0.2425705073823221, 0.1864884414720317, 0.21676143148509897, 0.1632837722561684, 0.16338761448491168, 0.16644967082397233, 0.17213828476414494, 0.1646388100863858, 0.17360952273287478, 0.11317549660458903, 0.2071328907152502, 0.17770236473225665, 0.16440697846777652, 0.19130398572029295, 0.11238429418636164, 0.20219841932303384, 0.1818819799817063, 0.16313222251183035, 0.19222043235260355, 0.17004704326750308, 9.999999999998899e-05, 0.12490740873925044, 0.005722663225933511, 9.999999999998899e-05, 9.999999999998899e-05, 0.027320830421400988, 9.999999999998899e-05, 9.999999999998899e-05, 0.03425107175010722, 9.999999999998899e-05, 0.04677841347628653, 0.08607795479110303, 0.043368469948624755, 0.05424073775523375, 0.06952202568739685, 0.015070586599294389, 0.008749807603384396, 0.05715580689770683, 0.06176396571249643, 0.09997023842430808, 0.04156150040232842, 0.06125813484975806, 0.04414656864734934, 0.0716687956179729, 0.07651978334489085, 0.0637231192455251, 0.07936741877974163, 0.09460300040737057, 0.061031370491990256, 0.11704900565391363, 0.043517081650713774, 0.0914658849481973, 0.026022380353439956, 0.043472811051300186, 0.0955990160663499, 0.08025027655374761, 0.05977743527516066, 0.08063601644132945, 0.48545238851717587, 0.4804466081514548, 0.4869504876102947, 0.4963185800467962, 0.4866237530928361, 0.5138525262035455, 0.5315840882212839, 0.44946915710142166, 0.4993333914042555, 0.1034291395335789, 0.07639730905054698, 0.095404395009685, 0.10510573599226114, 0.13233410092523867, 0.13938988760886095, 0.1123283473643838, 0.08245467800451156, 0.09635762207341902, 0.26400217429904993, 0.13626747667745298, 0.1800337691565308, 0.24907442586166484, 0.3729093961598433, 0.318222665780987, 0.4207178698788059, 0.2728991431863249, 0.24250349809714344, 0.2977847810435359, 0.3576007583026545, 0.31327639911515803, 0.3425813790687864, 0.27395932201153095, 0.28350394381670907, 0.494986424752488, 0.3626609720805082, 0.44133939807232814, 0.1704415684649757, 0.17591918120822536, 0.24928415738074328, 0.21236075870853488, 0.1397142596053229, 0.15625752932690506, 0.3275474889227745, 0.28025790954791396, 0.23326609199964055, 0.1950767927223056, 0.16025557966531323, 0.20818766208566053, 0.2231278760173111, 0.18459550752769083, 0.20980164943901214, 0.23098431612887493, 0.18728444745394457, 0.20469178297147206, 0.214531813790375, 0.20237831689546248, 0.24518107213001616, 0.21524453674029753, 0.20898279094157268, 0.19300946285091636, 0.23243899702391224, 0.196526743862383, 0.21094363569647234, 0.7639468436348804, 0.16822819494869035, 0.15352176208477408, 0.5514392437835792, 0.19943743087459886, 0.19566617988044277, 0.1333438737394912, 0.1680803006633549, 0.21281319958951506, 0.3644024551274767, 0.1557819603841415, 0.1975928733344533, 0.5198654719482811, 0.40264840071930885, 0.19769543880321572, 0.18118565675604636, 0.20565170645705455, 0.2017363375712814, 0.19850853639627852, 0.18945972987156523, 0.19216094452170496, 0.19191197686370132, 0.20506326368438343, 0.1898179410295736, 0.21284110922195798, 0.18640249412951249, 0.18773489275155364, 0.08086310592533996, 0.08033937785710499, 0.07635598773534491, 0.09231042127299482, 0.07575896371762703, 0.09686545039401462, 0.08943287508869324, 0.07344050674945446, 0.07015512463263018]}, "mutation_prompt": null}
{"id": "c170ff87-d8e5-43e2-ad1c-3f641d09541e", "solution": "import numpy as np\n\nclass MultiPhaseSwarmAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 20\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Altered mutation factor\n        self.crossover_rate = 0.7\n        self.c1 = 2.0  # Adjusted cognitive component\n        self.c2 = 2.0  # Adjusted social component\n        self.inertia_weight = 0.7  # Modified inertia weight for dynamic convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling for improved adaptability\n        self.exploration_factor = 0.2  # Enhanced exploration factor\n        self.adaptive_mutation = 0.1  # Increased adaptive mutation\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                \n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                \n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # Switch phases more frequently\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "MultiPhaseSwarmAdaptive", "description": "Multi-Phase Swarm Optimization with Adaptive Mutation and Self-Adjusting Parameters for Dynamic Exploration and Exploitation.", "configspace": "", "generation": 95, "fitness": 0.29545036499330374, "feedback": "The algorithm MultiPhaseSwarmAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.7941684471995741, 0.8219701135562247, 0.8305105278928346, 0.8269902859887501, 0.8521399788874007, 0.8006574458290572, 0.8523708461702766, 0.8467222606658044, 0.8378580198358134, 0.6663089902884006, 0.5777847814613946, 0.49424767085029875, 0.6587054077035202, 0.5808489746015373, 0.6976243826075517, 0.5173087299377033, 0.5831571808321105, 0.675806885215761, 0.14021061543650992, 0.4698587180279553, 0.1586275500296893, 0.17231934455590414, 0.12745184625427863, 0.15735859243622796, 0.1473416138776531, 0.13603788620590207, 0.577979549893868, 0.4400221785534886, 0.12257483003881753, 0.14202133312312704, 0.13023542531496846, 0.12210408164169184, 0.14299139769264024, 0.12918904867547787, 0.11423858745669824, 0.120416083564574, 0.9875043163735412, 0.9783503736913187, 0.9906333382161796, 0.9874463519985689, 0.9873684263107684, 0.9833733326212443, 0.984041919281338, 0.9868508882782896, 0.9893934558725974, 0.47315846938616124, 0.6496700476865949, 0.6144139163392417, 0.5492295599406276, 0.6208762814099547, 0.5681006398749716, 0.599987960052067, 0.5593363836461002, 0.5240439284204021, 0.3690110988245636, 0.27339481131990717, 0.5353657434044699, 0.2723601710322845, 0.19073094350591024, 0.20400481458017106, 0.17124906856663025, 0.21511988997981069, 0.3493612541495781, 0.1002523238852342, 0.18411799079655522, 0.24581534905429714, 0.1158773399768428, 0.17937104292609984, 0.20096629520462272, 0.19211114835809862, 0.1804509988248938, 0.1848337037481691, 0.18984605060584736, 0.11523158501659003, 0.1272283599657763, 0.1737134553426476, 0.2615412757240029, 0.19642592582458573, 0.20740371688947878, 0.13294474989628435, 0.20456219735978876, 9.999999999998899e-05, 0.00023366796521873123, 0.008223135832857387, 0.042644458735161206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10421650827003903, 0.055488322071293394, 0.07565228332516838, 0.024106817531990954, 0.04075843412174496, 0.07941282160580632, 9.999999999998899e-05, 0.023681363206778605, 0.13517155121547753, 0.03633272885972161, 0.04457505423631303, 0.06447101292997448, 0.06040416347600697, 0.049588378398968014, 0.08767119145988944, 0.06975644634404465, 0.07437217578442945, 0.09694770812844578, 0.22997112900460148, 0.065911079937222, 0.08086448052161499, 0.04232724533989218, 0.04815996140876522, 0.026399054273566258, 0.019616944538729864, 0.018418440081570897, 0.08065666960883378, 0.05478992020930673, 0.08008991868965643, 0.5052050422256217, 0.4854852450119371, 0.5409293935480457, 0.5478591412864432, 0.5575135305492731, 0.5263986126631961, 0.5253543230499855, 0.5539274027204629, 0.5343443481599282, 0.11522923494419679, 0.09189473122794334, 0.04309720497022773, 0.10808002422542262, 0.12592210269050352, 0.08384894198090131, 0.11253588043923668, 0.09474559950770745, 0.10776043264003232, 0.20714600087994273, 0.1481230769693882, 0.25319861578635294, 0.3065365084220377, 0.24362872217980025, 0.16905620835863389, 0.36419858883321143, 0.20820029470638945, 0.22551420405689637, 0.25304991810834043, 0.4160284641151528, 0.3191756865605947, 0.29520796737150234, 0.2332080635467526, 0.3457515433353743, 0.2101978555115983, 0.5224774828917187, 0.45146689678457763, 0.09118014943302133, 0.2762161589453026, 0.2244966416252101, 0.21998721727936676, 0.1915358291008582, 0.27839655719675627, 0.18352221958661885, 0.3196684779851734, 0.1386089911820254, 0.19799724996468782, 0.21625239891454962, 0.23198833188727608, 0.24108573280041024, 0.2259780306176521, 0.2021091964250714, 0.22070051228085796, 0.19226740552289812, 0.1960601046485434, 0.21177125531331753, 0.2145635556160752, 0.24430357616331722, 0.24565376082546997, 0.22342136593771056, 0.18904022912445306, 0.19884267204447348, 0.22181265882181367, 0.690378223305173, 0.8788688478208179, 0.1264215919884909, 0.15399241188546076, 0.8936892951239034, 0.1993922221030905, 0.19703208708312447, 0.12035917912623972, 0.16945015099597693, 0.15357839919535288, 0.6252834644728589, 0.211557262130338, 0.20370695075342649, 0.5978073808868762, 0.16891357224353054, 0.20724641006272548, 0.10467278542214531, 0.7173186095087207, 0.10423204106180273, 0.20566940023686398, 0.18937446777355638, 0.21450052627107885, 0.21543007668029435, 0.2554002491637217, 0.21666872471865706, 0.2377442175075566, 0.19345744118223607, 0.20525613059689618, 0.0870506223343207, 0.084347905873849, 0.08254150878504007, 0.07757266934702434, 0.07605131925300934, 0.07778030501752708, 0.06815864622186696, 0.09337106324577804, 0.08860153609234966]}, "mutation_prompt": null}
{"id": "ca925273-db69-408a-b103-0546835eaef8", "solution": "import numpy as np\n\nclass HybridSwarmAdaptiveLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25  # Slightly increased population size\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85  # Adjusted mutation factor for better exploration\n        self.crossover_rate = 0.6  # Modified crossover rate for balance\n        self.c1 = 1.9\n        self.c2 = 2.1\n        self.inertia_weight = 0.5\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995  # Adjusted cooling factor\n        self.exploration_factor = 0.2  # Increased exploration factor for diversity\n        self.adaptive_mutation = 0.06\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:  # Adjusted random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:  # More frequent phase switching\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "HybridSwarmAdaptiveLocalSearch", "description": "Hybrid Swarm with Adaptive Local Search for Enhanced Convergence and Exploration Balance.", "configspace": "", "generation": 96, "fitness": 0.3100900950712282, "feedback": "The algorithm HybridSwarmAdaptiveLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "b0377923-105f-4635-b02b-8b35e02070fe", "metadata": {"aucs": [0.8619079992225525, 0.879732146659823, 0.845040478647084, 0.8324304351727506, 0.8534724847873423, 0.8765732031179359, 0.8797761145723447, 0.8726364822829937, 0.8538960106764719, 0.5800726558460473, 0.563762771148206, 0.6961076366702441, 0.7021658868071525, 0.7062397154977544, 0.6819614923733881, 0.5442180540841477, 0.5251431014861543, 0.7509758304365671, 0.14069667274157616, 0.15468467930595142, 0.49505575964443427, 0.16309699618043338, 0.1534409807630509, 0.11157335714310812, 0.0721635979025399, 0.16421045326105754, 0.17078318483447785, 0.11326460698979735, 0.12633047181403267, 0.11824465067540424, 0.4828765497080002, 0.12441220129323938, 0.11132264241971623, 0.1380981632755538, 0.1540722302805152, 0.17922854460231374, 0.9881683995629135, 0.9884457759759969, 0.987706106236043, 0.9795432373856406, 0.9817632626644415, 0.9855385179381057, 0.9870737288210697, 0.9834961631612363, 0.9841797305448535, 0.5823521723730298, 0.5780152637530775, 0.4877968232218245, 0.5004977317339314, 0.6346611910864051, 0.5900849387246594, 0.594094511230181, 0.5572454029277423, 0.5547904571286355, 0.2238681339221823, 0.3295325056449864, 0.6940642933715602, 0.2219099999816634, 0.15961776881931544, 0.24874420214510085, 0.12625451618796413, 0.12489073062950007, 0.11412647389981523, 0.1868934217421151, 0.2503001621926806, 0.12436015165104142, 0.12957790136683467, 0.21953040081318997, 0.12534286437613118, 0.19761846674585593, 0.17294509117269175, 0.20629719271107771, 0.19933452872541135, 0.12183290821001813, 0.13337661943733092, 0.21850741366540494, 0.12708630555566924, 0.18364527494595473, 0.19983347277871866, 0.10180487084051293, 0.19895029260518793, 9.999999999998899e-05, 9.999999999998899e-05, 0.006403086060759566, 0.00018232188830147322, 9.999999999998899e-05, 0.020830403042235823, 9.999999999998899e-05, 9.999999999998899e-05, 0.08177028378970919, 0.0632463005430316, 0.0531031919931193, 0.045505812787345334, 0.09120571935918997, 0.02286798824708225, 0.038626814878482185, 0.06154934329873818, 0.06825130582747019, 0.057422581866007905, 0.04994886701334855, 0.19421290303176497, 0.3167357731895102, 0.09449391252379047, 0.10352781457293281, 0.08292727573259939, 0.24227954258439888, 0.26086142045841576, 0.07165631669334893, 0.10095875861369008, 0.05566364573822302, 0.10937472817667859, 0.019291110233174202, 0.03859795133879129, 0.14516411953300645, 0.083979648177819, 0.11266113195708516, 0.08223409556760675, 0.5274507478528564, 0.5303158426206769, 0.5287586547006264, 0.5706612623273895, 0.5474793197337677, 0.5302299171809006, 0.5778401010881464, 0.536391288478212, 0.551760694063566, 0.12329814449259335, 0.08101948708090245, 0.06130446472992357, 0.10609451747515053, 0.07165638977259858, 0.1131661482638856, 0.09865422698895687, 0.09800600433564777, 0.08852142936104757, 0.16560013900205905, 0.2792737957283711, 0.23070552816341916, 0.38937287740332116, 0.3174894912723204, 0.258215247790634, 0.4690258287709119, 0.44852710872109924, 0.2437415324334431, 0.3215953916438016, 0.3190161562594257, 0.32131942529962, 0.3936642815608563, 0.20576989979591231, 0.28318108361792094, 0.5500537950734338, 0.5595268069293752, 0.5224364132671807, 0.2456977843583391, 0.21274211324293324, 0.2023570709445729, 0.21311783669005824, 0.27223387515388553, 0.259182608013486, 0.28051045556487686, 0.26359510254769214, 0.4124890804930569, 0.22425170268110073, 0.22253324272302577, 0.21002061621568424, 0.20247671863025363, 0.20066601666507322, 0.21681286328503102, 0.21692985193534364, 0.21029208174306102, 0.20500148326878853, 0.1913435628448772, 0.20712921367613546, 0.20127114580032646, 0.6425898815631708, 0.2229178719946665, 0.22594851584989406, 0.24803280602735578, 0.2060421322581355, 0.24127784991446932, 0.16570318755384217, 0.16010593001556683, 0.15373638643704346, 0.8765999000469368, 0.8867290692002916, 0.19914856662756242, 0.1343248993253774, 0.17015730302821974, 0.8674223977867815, 0.3982914533844766, 0.1566895109997487, 0.5425493799930885, 0.209661853759193, 0.5247517672838218, 0.21249410606211105, 0.10479927360148178, 0.6765473783969705, 0.6023538479674383, 0.20880879050125134, 0.2062591523915448, 0.19270294110983954, 0.19663726579681073, 0.2171063965482114, 0.19381326662390097, 0.19714823765561584, 0.1929011613864191, 0.18655563159071964, 0.07625858457327872, 0.08458147857883991, 0.08340843259311603, 0.07224405760261943, 0.0928676010780769, 0.08645685958858407, 0.08243007609253306, 0.08214839342527558, 0.0650772797639314]}, "mutation_prompt": null}
{"id": "048145b1-ffaa-49e1-929e-9c1b09a72596", "solution": "import numpy as np\n\nclass RefinedHybridSwarmAdaptiveLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 25\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.6\n        self.c1 = 1.9\n        self.c2 = 2.1\n        self.inertia_weight = 0.5\n        self.max_evaluations = budget\n        self.cooling_factor = 0.995\n        self.exploration_factor = 0.2\n        self.adaptive_mutation = 0.06\n        self.exploration_phase = True\n        self.divergence_threshold = 0.1  # New divergence threshold to trigger adaptive changes\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.3:\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            diversity = np.mean(np.std(self.particles, axis=0))\n            if diversity < self.divergence_threshold:\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "RefinedHybridSwarmAdaptiveLocalSearch", "description": "Refined Hybrid Swarm with Adaptive Local Search using Differential Learning for Improved Convergence and Exploration.", "configspace": "", "generation": 97, "fitness": 0.28381621162664983, "feedback": "The algorithm RefinedHybridSwarmAdaptiveLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "ca925273-db69-408a-b103-0546835eaef8", "metadata": {"aucs": [0.8187213515718694, 0.8438234951413102, 0.8385490564519442, 0.8064142629458635, 0.8522409781730957, 0.7474194290520026, 0.8565180664791563, 0.8397552021238766, 0.8486848013884334, 0.606112478983464, 0.46716617488937284, 0.6779847439088525, 0.6970769002114385, 0.5135382210389376, 0.6835610139658421, 0.5224683419177646, 0.621343545800809, 0.6778045680358609, 0.14613743149001712, 0.11288463827200013, 0.1259748749693843, 0.12826704620052765, 0.14999235700319802, 0.5432041366254972, 0.1351093190318161, 0.1131717967510405, 0.13276963466245872, 0.11631821812300147, 0.0976313083421515, 0.13045095219067226, 0.14214608915671523, 0.10276548616859293, 0.11793717769795964, 0.09336287978165636, 0.11883828138501651, 0.10704076190540013, 0.9886402619057908, 0.9887846248953484, 0.9883958743030506, 0.9700382912969904, 0.9791270037566292, 0.9846027333622913, 0.9847727533064614, 0.9798492242401368, 0.9842468598964853, 0.4938342369108274, 0.3787196948600423, 0.5309184770203778, 0.5451959683524348, 0.19892236743374037, 0.41928046964652577, 0.31717781824766444, 0.4770332439633015, 0.3582852612471821, 0.16745072860964305, 0.16578576167473913, 0.5028821691948429, 0.21450621198105435, 0.2064533899461709, 0.350047414537077, 0.13717237905784618, 0.22176708886443353, 0.16021749093067483, 0.3659524532570777, 0.18892210185851133, 0.18301792217562773, 0.16752106346344475, 0.18358521073115608, 0.1271893621041632, 0.1819787501315111, 0.1292987659450644, 0.17978690621713744, 0.20236460020110858, 0.11691730098695274, 0.16195348964194312, 0.19715469789210516, 0.1261428851825196, 0.238095243552351, 0.23361076862355734, 0.09361810460562248, 0.2334175682553722, 9.999999999998899e-05, 9.999999999998899e-05, 0.04541172365344193, 9.999999999998899e-05, 9.999999999998899e-05, 0.05695942188623937, 9.999999999998899e-05, 9.999999999998899e-05, 0.04088272323414277, 0.06071615621530069, 0.03140766318575383, 0.10197930341683137, 0.11663314691788551, 0.00561344730769564, 0.02570391381849113, 0.044319139714210865, 0.035592496456046896, 0.07344498636534358, 0.051797587078751706, 0.10906795683600956, 0.12375744673739808, 0.12995406628709694, 0.08840927337008075, 0.07581358695982687, 0.09677617729697197, 0.1095640624994847, 0.07075932523901662, 0.042821169929160185, 0.04217565235812959, 0.07078907688174296, 0.007960185615300541, 0.017514034437474235, 0.07048870601862145, 0.08465124764917131, 0.08251562304980564, 0.2035506958150849, 0.5241133736691033, 0.5084045845153786, 0.5248755546362576, 0.5374680370428004, 0.5369730234824018, 0.5721780190250304, 0.5642322604142993, 0.5303848311911359, 0.5270352713468787, 0.13687582114457086, 0.06845828860887393, 0.08178045004529744, 0.09359315298910065, 0.10516662474646965, 0.089596190683912, 0.06867290826394079, 0.10707474852169907, 0.06912240931076308, 0.241010718697255, 0.2909421200351915, 0.21342082950449182, 0.17076664950811482, 0.33789740081624176, 0.18560259601552376, 0.18457126160732673, 0.20348696863525606, 0.15548435522859905, 0.19937004235355182, 0.2516988793077646, 0.24021021723353453, 0.18627561259108538, 0.19885008780468727, 0.3612953090977349, 0.3481591292779025, 0.4186047271365252, 0.3212529513597703, 0.17968207580407325, 0.3023736710002183, 0.30333439035387233, 0.28649171823545183, 0.18805268131466357, 0.29071179303733874, 0.16952661085715504, 0.26346372600405166, 0.2631537068780735, 0.24812987831531452, 0.18626172467677748, 0.1892721359510927, 0.23912378264672773, 0.20687100980076145, 0.18968538722792405, 0.19922921015827522, 0.18681543776117082, 0.22040759238439422, 0.20648541467027592, 0.19309956714487397, 0.22972063088218442, 0.22333469631190528, 0.6992643480380425, 0.7663353219144807, 0.23458966765637546, 0.20678594162397324, 0.22191609178775984, 0.16496755383417405, 0.14212393423890823, 0.1537294103981851, 0.8637511753378262, 0.6624245595851681, 0.1995610474194781, 0.09981558190263495, 0.1702583696636506, 0.8579262651253234, 0.3941643409405262, 0.15664272575890792, 0.3850218871395583, 0.2088501017455403, 0.39015394120269153, 0.21036144194718887, 0.10446661086177067, 0.21184977292117524, 0.5357355850553184, 0.21134170146295117, 0.1860340532905338, 0.17992453402034347, 0.18316918728806464, 0.1888624623631916, 0.20398446059769226, 0.18057116484419766, 0.2011048488259115, 0.19584236718825543, 0.07770482302889159, 0.0788256437642374, 0.08217319860299144, 0.0883622138074921, 0.09009359704959374, 0.08662699222214665, 0.07935822697967465, 0.08988348124362633, 0.0841608190783627]}, "mutation_prompt": null}
{"id": "a907cd06-4ce9-447a-8e8d-1e7f3c8bf685", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmDynamicPhase:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for better exploration\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # Increased mutation factor for diversity\n        self.crossover_rate = 0.7  # Increased crossover rate\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.inertia_weight = 0.6  # Adjusted inertia weight for balance\n        self.max_evaluations = budget\n        self.cooling_factor = 0.99  # Slightly higher cooling factor\n        self.exploration_factor = 0.25  # Adjusted exploration factor\n        self.adaptive_mutation = 0.05\n        self.dynamic_phase_switch = 50  # Dynamic phase switching interval\n        self.exploration_phase = True\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.4:  # Increased random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        if evaluations >= self.max_evaluations:\n                            break\n\n            if evaluations % self.dynamic_phase_switch == 0:  # Dynamic phase switching\n                self.exploration_phase = not self.exploration_phase\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "EnhancedHybridSwarmDynamicPhase", "description": "Enhanced Hybrid Swarm with Dynamic Phase Switching and Adaptive Parameters for Robust Optimization.", "configspace": "", "generation": 98, "fitness": 0.2880094669559493, "feedback": "The algorithm EnhancedHybridSwarmDynamicPhase got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "ca925273-db69-408a-b103-0546835eaef8", "metadata": {"aucs": [0.8290535888824317, 0.7739299623474154, 0.812897554208769, 0.8096267098861951, 0.7996304088331675, 0.8199831733244122, 0.8309017332462058, 0.8304425132090614, 0.8442946741156359, 0.5291908323422498, 0.6398771894247949, 0.6741654738140488, 0.6467391233379478, 0.48158091646423196, 0.6825758220046267, 0.6830835678523185, 0.6152434844005932, 0.6432602434232263, 0.1323102190143085, 0.15223775142714402, 0.13173112118384145, 0.14802998156719893, 0.1325839823561028, 0.13594774666224363, 0.1114742124983581, 0.1493982050939987, 0.1274386977849068, 0.12209406154730973, 0.14047710479353315, 0.1009528460502439, 0.12489362754394573, 0.12171668674061398, 0.12774652250214402, 0.13574519070486735, 0.11754403978570227, 0.10883610456546722, 0.981647767652258, 0.9863037717872833, 0.9862622149961715, 0.9764042117849877, 0.9846453392741424, 0.9800586745739979, 0.9814407168754592, 0.9761560096021213, 0.9803259075236639, 0.553152260244366, 0.47901755206743923, 0.5739313705074489, 0.4962756780254354, 0.418397493528067, 0.5140744716477748, 0.5045322541748725, 0.41821909122271494, 0.4080701305608523, 0.27869022930613396, 0.19179860724909836, 0.6503816434826892, 0.27055707440631893, 0.19780921922747852, 0.21005014643225872, 0.168701603907635, 0.6678208626534927, 0.23259562761585484, 0.17598996103346942, 0.17209120878215667, 0.18543683849349613, 0.1789022597382225, 0.21215140658949339, 0.16778692014396368, 0.2931994841401643, 0.17745689183155222, 0.1761634045072471, 0.2027834224293773, 0.11901451766058457, 0.33288446922010084, 0.18148614394930895, 0.1469675782722628, 0.37463863580384227, 0.14153069857365574, 9.999999999998899e-05, 0.20120236482909382, 9.999999999998899e-05, 9.999999999998899e-05, 0.004394598808219241, 0.018511753472513326, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022689046996602347, 9.999999999998899e-05, 9.999999999998899e-05, 0.10272795061676021, 0.02785380761151557, 0.17161219095898617, 0.11532008386633696, 9.999999999998899e-05, 0.01496794989978012, 0.18021732456928585, 0.05588245689496052, 0.13366285483902307, 0.044532349293205487, 0.0335943288404571, 0.3020761922500008, 0.14230565357417269, 0.08980349203169413, 0.08622787621734318, 0.18427465737853976, 0.1179974034314395, 0.06944010692863067, 0.33039292535117215, 0.04352887971327002, 0.07887435025852774, 0.06886064135685288, 0.02257135749631467, 0.10986067388435805, 0.19745485905682447, 0.057903104511586534, 0.10250199607488919, 0.4954697826556045, 0.5358787721994551, 0.5699055532212337, 0.588057436154575, 0.5544360672432276, 0.5045342857491841, 0.5239996196980832, 0.5275680479839573, 0.5103931315697416, 0.09169959419811291, 0.1127071319490438, 0.11584199286815511, 0.138199027911019, 0.08726612834278824, 0.13105405722142205, 0.12116570277758931, 0.11261714012698298, 0.11803458900473329, 0.2434798548476006, 0.20630624579726753, 0.18419233127338708, 0.44458986665229927, 0.3233715485278762, 0.20992018553812375, 0.2300546852722758, 0.23946156657180717, 0.19282112766763926, 0.31610399486080476, 0.2995661386474441, 0.3361173529186178, 0.3081960362443751, 0.3993310750080922, 0.34380046069220915, 0.31908413592713236, 0.3817875146371069, 0.2791675050491713, 0.20989463929990337, 0.270426275644144, 0.24164447460061278, 0.16570238833191508, 0.1816020299119384, 0.16533959274252197, 0.26485118925306217, 0.25707148570867744, 0.25405875038103964, 0.22446042977485814, 0.14260904159037913, 0.2191736103222801, 0.20744067717784365, 0.16881432961600518, 0.20615856301064628, 0.20119944550378732, 0.22307314627613806, 0.22163179148609302, 0.21418873871753885, 0.2292633263108641, 0.2215540090899517, 0.23528562544274734, 0.21091456112257345, 0.20205360795899818, 0.20195917601522617, 0.2350084134713185, 0.2152957881384896, 0.8437361026368011, 0.1657069667487413, 0.15372413325700596, 0.8493894650751749, 0.19952580898073413, 0.19907300876406087, 0.1659509670640258, 0.16964743407458605, 0.2112576295889934, 0.5886178897847777, 0.1562870315661563, 0.11168177616868946, 0.2029912174194587, 0.1657200341247228, 0.20424596949986684, 0.10513065645448827, 0.10440317574362912, 0.44359927605005, 0.20775566914749488, 0.1853225591352088, 0.1936966043806757, 0.20337209781708776, 0.21841136524533766, 0.18891310260489014, 0.1768886034720032, 0.17650994509799, 0.20619109320310613, 0.11237551675366719, 0.09922448111146764, 0.07968782324595158, 0.08926794325913778, 0.09075140767973733, 0.09422132119590987, 0.11091797716802643, 0.08629732250296984, 0.07763475940114783]}, "mutation_prompt": null}
{"id": "154ee23b-0a95-403b-8958-4f4656210236", "solution": "import numpy as np\n\nclass ReinforcedHybridSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 30  # Increased population size for diversity\n        self.particles = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Reduced velocity range\n        self.personal_best_positions = np.copy(self.particles)\n        self.personal_best_scores = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_score = np.inf\n        self.mutation_factor = 0.9  # Slightly increased for enhanced exploration\n        self.crossover_rate = 0.7  # Increased crossover rate for more genetic diversity\n        self.c1 = 2.0  # Balanced cognitive factor\n        self.c2 = 2.0  # Balanced social factor\n        self.inertia_weight = 0.4  # Lower inertia for faster convergence\n        self.max_evaluations = budget\n        self.cooling_factor = 0.990  # More aggressive cooling factor\n        self.exploration_factor = 0.25  # Further increased for diversity\n        self.adaptive_mutation = 0.07  # Slightly increased adaptive mutation rate\n        self.exploration_phase = True\n        self.contextual_learning_rate = 0.05  # New parameter for contextual learning\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.max_evaluations:\n            for i in range(self.population_size):\n                score = func(self.particles[i])\n                evaluations += 1\n                if score < self.personal_best_scores[i]:\n                    self.personal_best_scores[i] = score\n                    self.personal_best_positions[i] = self.particles[i]\n                if score < self.global_best_score:\n                    self.global_best_score = score\n                    self.global_best_position = self.particles[i]\n                if evaluations >= self.max_evaluations:\n                    break\n\n            for i in range(self.population_size):\n                r1 = np.random.random(self.dim)\n                r2 = np.random.random(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.particles[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.particles[i])\n                self.velocities[i] = self.inertia_weight * self.velocities[i] + cognitive_component + social_component\n                self.particles[i] += self.velocities[i]\n                self.particles[i] = np.clip(self.particles[i], self.lower_bound, self.upper_bound)\n\n            if self.exploration_phase:\n                for i in range(self.population_size):\n                    indices = [index for index in range(self.population_size) if index != i]\n                    a, b, c = np.random.choice(indices, 3, replace=False)\n                    mutant_vector = self.particles[a] + self.mutation_factor * (self.particles[b] - self.particles[c])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    trial_vector = np.copy(self.particles[i])\n                    if np.random.rand() < self.crossover_rate:\n                        trial_vector = (1 - self.adaptive_mutation) * trial_vector + self.adaptive_mutation * mutant_vector\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < self.personal_best_scores[i]:\n                        self.particles[i] = trial_vector\n                        self.personal_best_scores[i] = trial_score\n                        self.personal_best_positions[i] = trial_vector\n                    if trial_score < self.global_best_score:\n                        self.global_best_score = trial_score\n                        self.global_best_position = trial_vector\n                    if evaluations >= self.max_evaluations:\n                        break\n\n            if not self.exploration_phase:\n                diversity = np.mean(np.std(self.particles, axis=0))\n                adaptive_step_size = self.exploration_factor * diversity\n                for i in range(self.population_size):\n                    if np.random.rand() < 0.4:  # Increased random step frequency\n                        random_step = np.random.normal(0, adaptive_step_size, self.dim)\n                        candidate_vector = np.clip(self.particles[i] + random_step, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_vector)\n                        evaluations += 1\n                        if candidate_score < self.personal_best_scores[i]:\n                            self.particles[i] = candidate_vector\n                            self.personal_best_scores[i] = candidate_score\n                            self.personal_best_positions[i] = candidate_vector\n                        if candidate_score < self.global_best_score:\n                            self.global_best_score = candidate_score\n                            self.global_best_position = candidate_vector\n                        if evaluations >= self.max_evaluations:\n                            break\n            \n            if evaluations % 100 == 0:\n                self.exploration_phase = not self.exploration_phase\n                if not self.exploration_phase:\n                    # Implement a contextual learning step to enhance adaptation\n                    mean_position = np.mean(self.particles, axis=0)\n                    self.global_best_position = self.global_best_position + self.contextual_learning_rate * (mean_position - self.global_best_position)\n            \n            self.mutation_factor *= self.cooling_factor\n            self.inertia_weight *= self.cooling_factor\n            self.exploration_factor *= self.cooling_factor\n            self.adaptive_mutation *= self.cooling_factor\n        \n        return self.global_best_position, self.global_best_score", "name": "ReinforcedHybridSwarm", "description": "Reinforced Hybrid Swarm with Adaptive and Contextual Learning for Robust Convergence.", "configspace": "", "generation": 99, "fitness": 0.300135725730867, "feedback": "The algorithm ReinforcedHybridSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "ca925273-db69-408a-b103-0546835eaef8", "metadata": {"aucs": [0.8963695600194957, 0.8665212901232631, 0.8934542433467645, 0.899590191500917, 0.8806146719336667, 0.9026574841389705, 0.8872760188280793, 0.884002665869968, 0.8728041675747248, 0.7572550194519354, 0.7643857693710526, 0.5560578060195267, 0.7420608005913745, 0.7311543267119329, 0.7912829778455828, 0.7126080433414821, 0.7560196823316139, 0.7637441299398379, 0.15047173163160532, 0.1537824563883381, 0.14735077685195663, 0.48306834181090097, 0.07162932796593469, 0.11168091950218006, 0.17709848823840535, 0.15398945693534627, 0.14488578008577502, 0.11506030716061799, 0.135815260471994, 0.15090717436531054, 0.11874906302775146, 0.14170340004577198, 0.14744270937239812, 0.09889341616753733, 0.1339245966166691, 0.1397432683671872, 0.9814847522866285, 0.9862288211865005, 0.9817896097565422, 0.9798541324516196, 0.9809639096666511, 0.9647333234747213, 0.9808652319811809, 0.9747738162057241, 0.9751603373521437, 0.4708281693648857, 0.5107040988176139, 0.5414987887812931, 0.5946281088357707, 0.49412973956342066, 0.5471495374150752, 0.5051724444047498, 0.4935581953733468, 0.5054290627965305, 0.37157914862998587, 0.3494136407103461, 0.2369205178302184, 0.1951419002686755, 0.280008336307343, 0.28149918118507544, 0.15927965655115528, 0.36126237679790585, 0.3351033806819178, 0.1967944201779136, 0.18988419914469412, 0.18115303170742603, 0.12088864683698552, 0.19100682900248656, 0.20831151603139353, 0.16337431161578264, 0.1860004734396491, 0.26971485401878115, 0.20840511673404138, 0.12257899837737662, 0.2061426929953658, 0.2256529394347957, 0.21983120468109785, 0.30214106663289086, 0.10394988768039659, 9.999999999998899e-05, 0.13129074782481553, 9.999999999998899e-05, 9.999999999998899e-05, 0.04555497015205312, 9.999999999998899e-05, 9.999999999998899e-05, 0.016062927252784687, 0.005191799396710883, 9.999999999998899e-05, 0.010992370324481304, 0.046575649488054816, 0.04577833873669601, 0.15652767200128115, 0.1093555601186681, 9.999999999998899e-05, 0.019030551081235858, 0.11853187003835008, 0.07645131718087705, 0.06587196555557606, 0.11968133701350803, 0.21895124148524903, 0.147111071311138, 0.13526007436724397, 0.16771042131270986, 0.13658186677771644, 0.2606576727379307, 0.27681583471596893, 0.1135251908287872, 0.31025818857493537, 0.04314502812557497, 0.0719684261473621, 0.2306224036094754, 0.032658264775469625, 0.07118145929420039, 0.09914742665650922, 0.05739200410752088, 0.09327162474821271, 0.527274126692965, 0.561308986616675, 0.5462959854277529, 0.5183499621938192, 0.5437951534092922, 0.5380943801378465, 0.5501929315676108, 0.5190232626565661, 0.5475345209347637, 0.05979219805172875, 0.07592342929265417, 0.0883831348736136, 0.09576555291255573, 0.07298762391228286, 0.09960362585171756, 0.07984395812039424, 0.10648784847339032, 0.06940450270706877, 0.22437185716193364, 0.27610819667912523, 0.2109489103754909, 0.2740410707317056, 0.3586554217168022, 0.3189049044136174, 0.2811984589821319, 0.18230857965662295, 0.20223202950412322, 0.39291058852918637, 0.2603558795823262, 0.35426403324179145, 0.2649724781060697, 0.2938984469410272, 0.33521167040170907, 0.29682694428113443, 0.2897237434058144, 0.30300999943876794, 0.09880747334636708, 0.32460561408326405, 0.22887511206119904, 0.18805291520796497, 0.16109839798363323, 0.19152908504067823, 0.2074409799798157, 0.21448448787808805, 0.22469650401838548, 0.2314215246075898, 0.15778515566818418, 0.1971119714223737, 0.24090622462725353, 0.1812781033851124, 0.21148404087491912, 0.23495229690210695, 0.20726232542504053, 0.19002178211109277, 0.6518008336018979, 0.24928036455290925, 0.25107851864252717, 0.20724032124040237, 0.7609260647901747, 0.1975946730390783, 0.25122236790074615, 0.21841317270983063, 0.24181750420403614, 0.10496730507405916, 0.1264755328710757, 0.15408650742808472, 0.8612756586352678, 0.19961259651814434, 0.2016416280838046, 0.8282814586168203, 0.16978376854755406, 0.21339182009360524, 0.45817275630208965, 0.15647802239000208, 0.0731583522521192, 0.21062811556432148, 0.16584472463574207, 0.2117478138542832, 0.10524963307034818, 0.10469469665281828, 0.511902884100278, 0.19811100685041128, 0.2007182460951792, 0.2132585473519285, 0.2069569385315052, 0.17978672010334706, 0.2037126113539185, 0.1950818861786765, 0.2001491294046166, 0.1871072819323063, 0.08402659715207428, 0.1011698377366218, 0.09191165569682758, 0.09461354480116169, 0.08432871535741215, 0.08441351143511078, 0.10616177459758747, 0.1049027486355184, 0.09141951080084365]}, "mutation_prompt": null}
