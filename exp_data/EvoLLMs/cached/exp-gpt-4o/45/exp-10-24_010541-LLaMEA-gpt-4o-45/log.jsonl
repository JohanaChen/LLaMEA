{"id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "solution": "", "name": "", "description": "", "configspace": "", "generation": 0, "fitness": -Infinity, "feedback": "No code was extracted.", "error": "", "parent_id": null, "metadata": {}, "mutation_prompt": null}
{"id": "1f0917cd-818d-495a-b5b3-a73066597da6", "solution": "import numpy as np\n\nclass HybridDESA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.current_eval = 0\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.current_eval < self.budget:\n                self.fitness[i] = func(self.population[i])\n                self.current_eval += 1\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx):\n        indices = [i for i in range(self.pop_size) if i != idx]\n        a, b, c = np.random.choice(indices, 3, replace=False)\n        F = 0.5 + np.random.rand() * 0.5\n        mutant = np.clip(self.population[a] + F * (self.population[b] - self.population[c]), \n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover_rate = 0.9\n        trial = np.copy(target)\n        for i in range(self.dim):\n            if np.random.rand() < crossover_rate:\n                trial[i] = mutant[i]\n        return trial\n\n    def annealing(self, candidate, current_temp):\n        new_solution = candidate + np.random.normal(0, 0.1, self.dim)\n        new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n        new_fitness = float('inf')\n        if self.current_eval < self.budget:\n            new_fitness = func(new_solution)\n            self.current_eval += 1\n        if new_fitness < self.best_fitness or np.random.rand() < np.exp((self.best_fitness - new_fitness) / current_temp):\n            self.best_fitness = new_fitness\n            self.best_solution = new_solution\n        return new_solution\n\n    def __call__(self, func):\n        self.evaluate_population(func)\n        current_temp = 1.0\n\n        while self.current_eval < self.budget:\n            for i in range(self.pop_size):\n                mutant = self.mutation(i)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = float('inf')\n                if self.current_eval < self.budget:\n                    trial_fitness = func(trial)\n                    self.current_eval += 1\n                \n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                else:\n                    self.population[i] = self.annealing(trial, current_temp)\n\n            current_temp *= 0.95\n\n        return self.best_solution", "name": "HybridDESA", "description": "Hybrid Differential Evolution and Simulated Annealing for adaptive exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "metadata": {}, "mutation_prompt": null}
{"id": "18ab9968-2842-4cb1-be1e-43b23219b2f2", "solution": "", "name": "", "description": "", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "metadata": {}, "mutation_prompt": null}
{"id": "2fa365e3-4df8-4557-9b46-26ec569b0795", "solution": "", "name": "", "description": "", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "metadata": {}, "mutation_prompt": null}
{"id": "40bccb55-8d6c-4eb7-9431-a5f15a4c2500", "solution": "", "name": "", "description": "", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "metadata": {}, "mutation_prompt": null}
{"id": "67d96fee-5dba-46a7-8a27-45547c851464", "solution": "", "name": "", "description": "", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "metadata": {}, "mutation_prompt": null}
{"id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 6, "fitness": 0.3281196113845518, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "03eb8915-e7c7-404a-bff8-ab6b8280e957", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "3e097369-fe9e-413d-bcf6-633ec91c11ae", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "11b2e8f2-a58c-49cd-8ee5-4f29586dc07a", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "48587b7a-3b6e-4be3-aa42-6ee36f899766", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "e0f1d151-bb5f-445e-af47-4f98813099b2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "576d961e-9390-4d49-aeb6-6f919d361578", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "a1eaedd6-2c7f-484a-8ffe-0720fcbf385e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def levy_flight(self, L):\n        beta = 1.5\n        sigma = (np.math.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.math.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.randn() * sigma\n        v = np.random.randn()\n        step = u / abs(v) ** (1 / beta)\n        return L * step\n\n    def resize_population(self, evaluations):\n        if evaluations < self.budget / 3:\n            return self.pop_size\n        elif evaluations < 2 * self.budget / 3:\n            return self.pop_size // 2\n        else:\n            return self.pop_size // 4\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            current_pop_size = self.resize_population(evaluations)\n            for i in range(current_pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with Lévy flight\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                L = self.levy_flight(1.0)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c]) + L * (self.population[a] - self.population[i])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution integrating Lévy flight and dynamic population resizing for improved exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.2195972034466989, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.5892497911193624, 0.575719391076361, 0.5679502771257947, 0.6064560511626382, 0.5905791796100475, 0.6006621124438765, 0.5558503666949691, 0.6116272124258015, 0.564744487540628, 0.26469787608620565, 0.21094350594988065, 0.2532043795981881, 0.26673077770965326, 0.25552702633164504, 0.26533736622406523, 0.29119025295571066, 0.26091667964415766, 0.2619908401675053, 0.1299096795360123, 0.136159525303985, 0.1463444119708105, 0.14544815038280157, 0.11881363601472528, 0.1522157405431913, 0.1429225805134352, 0.1313201905832595, 0.12267476456672344, 0.10849920563382442, 0.1299616547685165, 0.12628469179442714, 0.11151944091821553, 0.1165017930901775, 0.12255566705553478, 0.1115781746205754, 0.11317027811283864, 0.11553876803263974, 0.997470970903221, 0.9650875812906982, 0.9894389178139135, 0.9775450455590572, 0.9744548741843923, 0.9952049365195281, 0.9640727203568978, 0.9826649001721847, 0.9846104107970062, 0.20341500460769402, 0.18765042158743328, 0.21195870959795315, 0.21077931476976797, 0.20625204201759018, 0.21413346617779438, 0.21413753165048333, 0.2271814987335815, 0.20412675353550502, 0.2680011935641593, 0.252644516215476, 0.2782805737503111, 0.2978415034764096, 0.28760250889084316, 0.28131340672211835, 0.2771567035769874, 0.2799662725720232, 0.663117151799836, 0.12396662739493025, 0.15871110488198215, 0.14570955406183694, 0.12959935801362465, 0.1438176357889711, 0.14172047088149975, 0.1430772461085842, 0.13108468083439295, 0.13540275666461188, 0.08388196725405561, 0.11455447117993933, 0.11005893168286096, 0.13867807593050707, 0.1387292605325272, 0.13520395135575602, 0.1261090726700409, 0.1137895868266704, 0.11119166478260556, 0.017728981775394503, 0.03598242831262055, 0.004737118572600396, 0.006596643582455042, 0.01600923694443268, 9.999999999998899e-05, 0.01329360322070583, 0.03538152536625638, 0.017364844526309375, 0.1277265022304933, 0.12318011494061865, 0.09485365213703023, 0.0823707228697278, 0.09311135780119528, 0.11265240145567168, 0.12943654353255774, 0.1437035866318792, 0.1277407782300083, 0.02840610209305705, 0.00013761614612450845, 9.999999999998899e-05, 9.999999999998899e-05, 0.014581014836606121, 0.016203403805246097, 9.999999999998899e-05, 0.001972029627522187, 0.0012108141714068932, 0.10449155265191146, 0.10873221536793587, 0.09799485589213852, 0.10772879276496727, 0.12226201689704508, 0.11001419784588784, 0.11542176289991257, 0.11119398032080718, 0.09693630322942004, 0.4221704574018623, 0.42462787159519666, 0.39916814901240283, 0.42022718920754987, 0.43494034473420906, 0.42341322728890274, 0.4363718533586258, 0.4322232365425812, 0.42620616736807393, 0.10247887600892824, 0.09424975682576808, 0.09703742900872969, 0.09635073996908394, 0.08342874406829337, 0.08667127495580129, 0.0981947296932294, 0.08747774013639587, 0.08309180481932399, 0.13997845930985553, 0.14646176268175692, 0.14486319260046654, 0.15021631491487275, 0.14732497254262455, 0.17877194288137854, 0.12982032656440046, 0.15109823464597472, 0.15240751606710767, 0.24196535218946824, 0.2531781963957014, 0.24839837980671653, 0.22955273253959674, 0.23914503247801944, 0.22885617895924404, 0.24844154273509422, 0.2624785342588558, 0.2666609848666619, 0.18822615642298723, 0.1947780876730688, 0.19732034270365317, 0.17200175900843984, 0.1842170200767479, 0.16958670172041967, 0.17829593658934717, 0.18367273913586013, 0.17395791963752327, 0.17238860681811874, 0.19522353194473718, 0.18996842388081236, 0.19159835006202552, 0.23642375125026416, 0.17572342681688946, 0.17759741759530712, 0.18358448352367762, 0.1696653704067752, 0.18513702840113078, 0.18973976539959736, 0.18059822807898818, 0.2405028602888386, 0.20713145074378758, 0.1928716825392438, 0.19293289119489831, 0.19024116219140175, 0.1924132753142822, 0.19850524000685354, 0.18169503347895566, 0.15959950306854387, 0.16587960694065418, 0.16358677308071834, 0.23818674175425536, 0.2809622556181032, 0.26457688223421383, 0.23038191344244752, 0.159722185327562, 0.16043341445246173, 0.2362509590407319, 0.21971408808136716, 0.19695078914804864, 0.18250204336135434, 0.20208599682518624, 0.2853111270545112, 0.2043591980922128, 0.18166219434567543, 0.20030556635455965, 0.18325465090126747, 0.1917554008345448, 0.17556261246839966, 0.1753661101703421, 0.19068013084847546, 0.19522878025743873, 0.18248724632631275, 0.07911884754832499, 0.08044208426559707, 0.07593220968457559, 0.06629668659266519, 0.07639309488458679, 0.07892977655288358, 0.07575357503388935, 0.07448518737139997, 0.08914244550987482]}, "mutation_prompt": null}
{"id": "deac9444-a6c0-4855-a85d-61cca77b3c6c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Self-Adaptive Crossover and Mutation rates.", "configspace": "", "generation": 7, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.7918336179541142, 0.7875480471296565, 0.7817257936410131, 0.784181859144207, 0.7984987430771655, 0.7972245576844136, 0.8006454731467011, 0.7859279501557832, 0.7833071796970859, 0.6211701473645526, 0.6525734459211591, 0.6322234151217558, 0.6559722991188217, 0.6312925105651186, 0.6369286155157491, 0.6424199132191645, 0.6318565607912972, 0.631891240243449, 0.33957415508915667, 0.3956700713205247, 0.4745795311760376, 0.46967480363123304, 0.4069080460057276, 0.35284538976760504, 0.45638808514356854, 0.48912074858820387, 0.3782592825860446, 0.28264210981704196, 0.30103140562919384, 0.38203409079042927, 0.372027265611931, 0.35807349699247426, 0.1558418734917213, 0.1549994852365758, 0.31146498201329, 0.2961691552434004, 0.9704873497595765, 0.9463354954019196, 0.945952659474796, 0.9130200692490429, 0.9560478009333725, 0.9416364851634909, 0.957092751307732, 0.9438517216586361, 0.951093172054325, 0.39150316258838824, 0.3757044964659132, 0.3732040848307996, 0.35576434758827813, 0.36437745927749043, 0.37810733025289833, 0.3375416610987664, 0.35494120408741414, 0.36012913951943115, 0.4843713422277407, 0.5441992774497978, 0.5187726683332359, 0.549775085762449, 0.5348309745482812, 0.5985164471640689, 0.6165857945059479, 0.5224469838629782, 0.5721504971660665, 0.16712009478091006, 0.16925996355343054, 0.16989906623441753, 0.243463252757118, 0.20453129784204482, 0.1694051815799399, 0.17650838289772508, 0.1831770177568237, 0.19161994172412855, 0.15162689246590977, 0.17026049039875202, 0.12801252071508806, 0.1600004186832844, 0.17314777824682837, 0.22005783057112682, 0.12963661216576716, 0.1555044348279203, 0.21435318066966247, 0.06362254893808927, 0.05685714335787273, 0.08339936016705218, 0.11197602500886317, 0.05321621829974643, 0.09206462418647532, 0.0914315783612416, 0.07248187662051009, 0.09144243773354233, 0.19589814660855798, 0.22381982221226382, 0.2192649715972812, 0.15724110792765655, 0.11287118167827503, 0.1961962783026826, 0.20928241501268263, 0.23111098655460127, 0.26835045579898065, 0.021623071847992614, 0.016095427312254662, 0.043642126971907946, 0.08934172822392161, 0.06220694385242076, 0.06315884241434866, 0.047049171752912344, 0.024497963203726214, 0.06365305858228798, 0.19779508813856128, 0.16993327573293715, 0.13503107513555845, 0.1933147362491392, 0.16615856366112858, 0.19264898993409663, 0.14257184634444364, 0.16450445263909008, 0.17735674981094796, 0.5112862448481967, 0.5658375716755308, 0.5798548299916859, 0.5322426294049696, 0.5434270980436098, 0.5417036381015278, 0.5663162370231507, 0.5340333041778001, 0.5494674115310015, 0.11285053397506928, 0.12560036895348026, 0.10425738550334951, 0.12551430312420198, 0.1001268072282544, 0.10401750096693307, 0.1516810136933716, 0.09369134480231789, 0.1016213258891785, 0.1528185149611141, 0.14823286035743022, 0.14748401671451405, 0.20053972819842247, 0.13899038495240035, 0.1541075732681526, 0.1556641504811498, 0.168027359003745, 0.17948843209491128, 0.3688151803122174, 0.36582762682262415, 0.33295853554011334, 0.38657073777885, 0.3537294492167842, 0.3776784868185258, 0.3901200830269618, 0.4043146621281799, 0.3932096958201773, 0.24133032477182126, 0.2654840176191309, 0.2666507613388932, 0.243040736842017, 0.2318207396589742, 0.27663397428007597, 0.2570836490586136, 0.25375139093249444, 0.25094341433243406, 0.19547615834193488, 0.19757020029205863, 0.19255408515538452, 0.20746105652802715, 0.20842851933669904, 0.19094539730700633, 0.19343557627417463, 0.24876889284458803, 0.19283255792785337, 0.2624762171101255, 0.39026416427710775, 0.22497834237435177, 0.32559888485677246, 0.2057794491738224, 0.23645463612915008, 0.3755496544280351, 0.3526661962584582, 0.3362066490347708, 0.5070186499681897, 0.45655223106494414, 0.16915973922151661, 0.6203756136784658, 0.57916002486719, 0.7007873812364547, 0.548274735460783, 0.4364629200037431, 0.4630280763837573, 0.31473458198009685, 0.46644317318239814, 0.15968207257656652, 0.33004478755883926, 0.25266664490722646, 0.4907790602401497, 0.20986774520876228, 0.30090564044373314, 0.20234635511941934, 0.20517091633778195, 0.18694334713372662, 0.18427588708436793, 0.18089131743285392, 0.19533602193973187, 0.18155283983399484, 0.17615479612947893, 0.1859448758145399, 0.18788481427289316, 0.0822201595620885, 0.07773110279231787, 0.07932857994904641, 0.08030206165984277, 0.09216290014747541, 0.08643533654062974, 0.07543501565907662, 0.07380785891322617, 0.08601666444006784]}, "mutation_prompt": null}
{"id": "92125f7c-4855-4b16-8342-31bdced22398", "solution": "# Description: Adaptive Differential Evolution with Local Search Intensification and Adaptive Scaling.\n# Code:\nimport numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                \n                # Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = 0.5 * (mutant + local_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.1 * self.CR[i] + 0.9 * np.random.rand()\n                    self.F[i] = 0.1 * self.F[i] + 0.9 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Local Search Intensification and Adaptive Scaling.", "configspace": "", "generation": 14, "fitness": 0.3546664939753144, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "c88c1efa-7d84-413b-8fbd-5925b7010fca", "metadata": {"aucs": [0.8105595104107943, 0.8259240661040904, 0.8206742147842483, 0.8235112784181755, 0.8208742656442835, 0.81522446567983, 0.8186465532669359, 0.8156893271707939, 0.8178200982670359, 0.6651553685079996, 0.695531949672455, 0.6645555060038946, 0.6780977632241549, 0.6784498841245232, 0.6869145230838191, 0.6558062006281369, 0.6760435351787434, 0.6621817673040438, 0.4666806856484623, 0.4497395138228967, 0.3918564479287021, 0.5015276393745237, 0.3987811083316948, 0.5330802199841052, 0.6076365834871804, 0.4877296144250176, 0.48522389832493706, 0.38563707945870496, 0.1543123609240249, 0.1598167475963903, 0.40435273181073206, 0.16566323884334666, 0.16593862310188157, 0.3300223336465897, 0.37534206575914164, 0.35029036791975254, 0.9432590416211041, 0.9647734975838689, 0.953888649339044, 0.9731779356852167, 0.9443518628533112, 0.9392318479506776, 0.9375838700408187, 0.9529934505565124, 0.9631410494752052, 0.4368185414664212, 0.39963860992510436, 0.39256487448034894, 0.3895139580982675, 0.4371753236089847, 0.4358629492791062, 0.3864191533607647, 0.369849379599135, 0.4759484907101622, 0.7048912340341282, 0.690827457773268, 0.6842851808343016, 0.7114653776426325, 0.7201123284028415, 0.7081097738936329, 0.6868220205819234, 0.7383018209555599, 0.6411171072505404, 0.19883644125689692, 0.18568439306434403, 0.2052946870484731, 0.19766639493379734, 0.1966417408410479, 0.20406696224545517, 0.19817981355120218, 0.1551978644978106, 0.20529730843713956, 0.24943149781115792, 0.18125757838841727, 0.1978090535789956, 0.21851215644172295, 0.19946684841081197, 0.17337021268821518, 0.1705841114387706, 0.1627881252465675, 0.1775275215398575, 0.12912540414726414, 0.09993092538344295, 0.06930353374357257, 0.0851065450480426, 0.17593283028249096, 0.07621106699334945, 0.10962822574742914, 0.16736671992550978, 0.11170089960333007, 0.20644807880336935, 0.2785171725491421, 0.27109056693664224, 0.17187677678287305, 0.22441689635193007, 0.22901507735837734, 0.2561609790389041, 0.1604907511436341, 0.28403806143563637, 0.11089368816453682, 0.09752175059131385, 0.12961201873671802, 0.11369519068748213, 0.14257784347540658, 0.09519230570963666, 0.1082795708871701, 0.07641657988927997, 0.08850861897576046, 0.19983756371773453, 0.20293205927979874, 0.17783299116695817, 0.2330778515927766, 0.20948254796626886, 0.2332534248457826, 0.16958859624983202, 0.1685875153292653, 0.2027165873159511, 0.5670416145550063, 0.5520035371991707, 0.6116001309534245, 0.5623715816575607, 0.5811566974261289, 0.6097700032783291, 0.5918372922204851, 0.6029941599895727, 0.5936279867000179, 0.11110715038574615, 0.1120733052976931, 0.11767358730965116, 0.11313526850545241, 0.10214503547578102, 0.11246738438764436, 0.11847045732706951, 0.12001302524123225, 0.12456918754414859, 0.15418563334937296, 0.15323189299660445, 0.16671825780900473, 0.16022884805161886, 0.1365779939483005, 0.16471439029055568, 0.1656738988836145, 0.15541279426933885, 0.15312238223854202, 0.3783172898729179, 0.3870383754797492, 0.34947545306057715, 0.34915403846993753, 0.4159196892670928, 0.4041628319170818, 0.4117513328176703, 0.43854531137763564, 0.41730665381183474, 0.3135883302238419, 0.2829090154590441, 0.25467787802433606, 0.2854862235529285, 0.2687635275366087, 0.268851935922909, 0.28581352181583375, 0.28450833594203884, 0.3248783446883021, 0.21504298407861133, 0.21509009865133932, 0.20356610616744708, 0.19752565937966393, 0.1902191380031215, 0.2064139216563241, 0.20073456556149782, 0.21151372413872127, 0.20158841742455258, 0.3848150467616739, 0.3866579111568984, 0.2360389798616338, 0.4669514567108398, 0.3025822108870819, 0.5267678250791814, 0.39841303073821177, 0.32240470190156034, 0.32262473110905476, 0.16740353733830438, 0.16507707989511733, 0.6485927618432628, 0.18282488504562433, 0.6324587137407744, 0.5880925315968064, 0.16784670448327688, 0.5874102414738498, 0.5837223383588812, 0.6388186982340517, 0.544985538880802, 0.2041298970734563, 0.1582421816275782, 0.16093841976857126, 0.20193052512581589, 0.20717431678840048, 0.6026896071754011, 0.5531285723780579, 0.1810811694442176, 0.17967471569636106, 0.19230291092548346, 0.18769821029997202, 0.19714961622221094, 0.1861338355706168, 0.17690263817754925, 0.1947280826143999, 0.18141834676188706, 0.07701906864815122, 0.07642015430623306, 0.0861620117719849, 0.07350838379177949, 0.08209172950074739, 0.08382383163214235, 0.08830935273251939, 0.08968312278358548, 0.08297061901900271]}, "mutation_prompt": null}
{"id": "6dbd3fa8-cf23-4d30-a33b-ab943a87bd9b", "solution": "# Description: Adaptive Differential Evolution with Enhanced Diversity Maintenance and Stochastic Recombination.\n# Code:\nimport numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.1  # Enhanced local search probability\n\n    def __call__(self, func):\n        evaluations = 0\n        archive = []  # Diversity maintenance via archive\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced diversity\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                \n                # Local Search Intensification (with archive influence)\n                if np.random.rand() < self.local_intensification:\n                    if archive:\n                        archive_best = archive[np.argmin([func(ind) for ind in archive])]\n                        mutant = 0.5 * (mutant + archive_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Stochastic Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    # Update archive for diversity\n                    archive.append(self.population[i])\n                    if len(archive) > self.pop_size:\n                        archive.pop(np.random.randint(len(archive)))\n\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # Adjustments for better stochastic control\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.2 * self.CR[i] + 0.8 * np.random.rand()\n                    self.F[i] = 0.2 * self.F[i] + 0.8 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Enhanced Diversity Maintenance and Stochastic Recombination.", "configspace": "", "generation": 15, "fitness": 0.13927710656101328, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.14.", "error": "", "parent_id": "92125f7c-4855-4b16-8342-31bdced22398", "metadata": {"aucs": [0.3207978796321358, 0.3037707675253102, 0.3263319995223274, 0.303036966156905, 0.3265097003223443, 0.32484421844830935, 0.31760291092269477, 0.2893597700897358, 0.29612126139148287, 0.03628789542544508, 0.04541258917638191, 0.049734359661094074, 0.03679611967547769, 0.01435598635660229, 0.030244851725702904, 0.05486066238906173, 0.030932247984981953, 0.022923262588768756, 0.08542860558171339, 0.07707228323274085, 0.0871831221412902, 0.06854078908208883, 0.07793876249847531, 0.07566552452809605, 0.09552732489187032, 0.07115256278172855, 0.06823488377133802, 0.05615695627422723, 0.055856098808400256, 0.06622881605901199, 0.0612220367875882, 0.059298419506797706, 0.06507352252547238, 0.05815944038106846, 0.06532976411922409, 0.06271653398008092, 0.5757579556481864, 0.5015587741399403, 0.818992943419485, 0.7811725839974459, 0.743543347072529, 0.8184775983397488, 0.59901681475216, 0.7458138442836088, 0.7861486240565647, 0.10313634985419318, 0.08932836219670681, 0.084877978963532, 0.09482817403833999, 0.11199575635200654, 0.08120307808438143, 0.11696172941355598, 0.09111323916423575, 0.15220976735021008, 0.17367681326869444, 0.16832387118235403, 0.1366122300230811, 0.186780320354606, 0.16048993437416392, 0.16710685857089957, 0.161426997114279, 0.170316260531708, 0.16746664325848015, 0.053101301745863694, 0.0822866305877713, 0.06984821214665715, 0.07450954185223924, 0.08412545205191402, 0.06714045117874134, 0.06417160299641977, 0.09190163796418205, 0.06474635174398047, 0.047028606384871274, 0.06080024939446771, 0.07773287628511061, 0.07274111283369367, 0.06211984055953257, 0.07734815451930932, 0.06681746106803299, 0.040170060726983814, 0.09980500584530128, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0586239023669719, 0.03014506479258794, 0.03965081022191119, 0.06289916105303273, 0.051559950388153974, 0.05130649352279382, 0.033574420901093416, 0.07708055304803585, 0.041124511665837415, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024665083098832086, 0.026529518125969265, 0.03170209581414274, 0.03396913419731318, 0.05149493234409852, 0.04816095412178534, 0.04122394306882071, 0.03389672840666713, 0.02326067873703319, 0.26507874076173543, 0.2677949626557925, 0.28669273832323505, 0.3017428839384434, 0.30230854639411575, 0.27072927479245323, 0.29205959840587303, 0.26316267211240174, 0.2876524785138269, 0.057885487565005445, 0.06596491759347556, 0.06188157905658931, 0.06708487461517743, 0.0587186487374356, 0.06143353524915385, 0.07038191482558864, 0.05565616295042741, 0.06661605197284004, 0.10311732518229855, 0.11580041409398023, 0.12403106285586396, 0.1699852629336599, 0.15555276674515683, 0.1175948471095275, 0.09629529853670415, 0.13350349196336686, 0.13049992696125012, 0.22045286068296643, 0.2062346430624875, 0.19269818816411421, 0.1830341336124761, 0.18165568781877206, 0.18618261310914186, 0.19447782887226062, 0.209537836577238, 0.2059301184207909, 0.12896426196207667, 0.14096631920698433, 0.1267289863394866, 0.1367719526614135, 0.1118091563480823, 0.14092068046413664, 0.12912857029949287, 0.1294632685490793, 0.13130844724318835, 0.1633235187338441, 0.1605145476740497, 0.1781273130077754, 0.15877154770528634, 0.172096049950204, 0.16975097117025795, 0.15974028929078, 0.16687530666006822, 0.19076581278836646, 0.15233917578985767, 0.16085897701537288, 0.16310759159864296, 0.15495057175908333, 0.1419865832473295, 0.14934231355397865, 0.15945418482862717, 0.15978387966485186, 0.1624542905999935, 0.19234033436506026, 0.1284287961804279, 0.1495288176877877, 0.1303526641044811, 0.1187862223621804, 0.13981374104820388, 0.14616981166660026, 0.14391091442072523, 0.19107303828958078, 0.13900189253833595, 0.13271647088491723, 0.1694882442215101, 0.1276576755206008, 0.17148940196052576, 0.1842729037940255, 0.17793375776917797, 0.12854450857882982, 0.1603008264232525, 0.16816844664779385, 0.17105332221809333, 0.1782797658339783, 0.16415873243939183, 0.17403062924748336, 0.16416233628693322, 0.16009159274185147, 0.1607985337652108, 0.16597463679596425, 0.06198593456339063, 0.04585288982579927, 0.05715379496040318, 0.07290961605863777, 0.06416047468137243, 0.047462603655846425, 0.06287096551032323, 0.04992806315006637, 0.05916048219094483]}, "mutation_prompt": null}
{"id": "c116fdfe-4822-41d6-9700-b148eec4bb28", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)\n        self.local_intensification = 0.1\n        self.success_rate = np.zeros(self.pop_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                \n                # Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = np.mean([mutant, local_best], axis=0)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.85 * self.CR[i] + 0.15 * np.random.rand()\n                    self.F[i] = 0.85 * self.F[i] + 0.15 * np.random.rand()\n                    self.success_rate[i] += 1\n                else:\n                    self.CR[i] = 0.15 * self.CR[i] + 0.85 * np.random.rand()\n                    self.F[i] = 0.15 * self.F[i] + 0.85 * np.random.rand()\n\n            # Adaptive control mechanism\n            if evaluations % (self.pop_size * 2) == 0:\n                mean_success_rate = np.mean(self.success_rate)\n                self.local_intensification = max(0.05, self.local_intensification * (0.5 + mean_success_rate))\n                self.success_rate.fill(0)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Adaptive Control and Dynamic Scaling for Improved Convergence.", "configspace": "", "generation": 16, "fitness": 0.3351210253101208, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "92125f7c-4855-4b16-8342-31bdced22398", "metadata": {"aucs": [0.9044554676630205, 0.8942037356815229, 0.8950618546333208, 0.9101665460554128, 0.8977347772438709, 0.8937425385236814, 0.8989533237047733, 0.8967010351707791, 0.8994038156605962, 0.8379159622895545, 0.8271307362032427, 0.7996759570783345, 0.8253607433385615, 0.8081168176884043, 0.7941475310865328, 0.7762197122461434, 0.7618407960170412, 0.8214836085942261, 0.594416344662291, 0.6094881939505197, 0.17964354343494904, 0.14062544597929993, 0.6468681035910127, 0.7220083126599369, 0.6670468757770756, 0.7714739649230954, 0.634199913032689, 0.1340638470615797, 0.11024388090988357, 0.1393295835837427, 0.10611667776678024, 0.10672855597937392, 0.13958464815078064, 0.10917725954569724, 0.13821171146349776, 0.11040326362851305, 0.9315801273568933, 0.8942238287459794, 0.897192494813008, 0.9167690818381855, 0.9361450993951678, 0.9026539538726179, 0.9277660420987924, 0.9254668310563848, 0.9171451846760121, 0.19039078817677024, 0.23387877431822612, 0.1918403275008842, 0.36476289955508334, 0.2142447740982134, 0.19445417518526942, 0.19618685080452647, 0.23650596917289624, 0.17195384582239748, 0.6511854472794529, 0.5997519272812017, 0.5887393851305829, 0.27380983830786176, 0.21025623785653502, 0.36857094112848254, 0.34608899375809055, 0.766840954604062, 0.21795792962573024, 0.3732228702048407, 0.15331333257059154, 0.14343382561771545, 0.12654576738750967, 0.160664330772613, 0.2256890558593081, 0.13052276216454461, 0.1283965995915991, 0.1500672161778912, 0.1505997037409399, 0.13040712737028826, 0.14148000257089555, 0.12521364863856632, 0.14367037149022854, 0.15401844724827296, 0.13411950801472972, 0.14050259615136362, 0.13518680412122652, 0.0785989477113741, 0.07427268385509345, 0.13156905071613856, 0.09542697740460593, 0.08827838591852155, 0.07074798480737698, 0.058812438252036525, 0.09793109799879918, 0.06747578945821753, 0.1886811149191251, 0.1740657654948724, 0.19927756807083996, 0.20238928076574958, 0.15850237590616834, 0.18446076856725846, 0.23123252636227054, 0.23045890750678533, 0.25514192434620986, 0.1821120136321457, 0.15557902157950443, 0.062227498677973725, 0.18531875201360415, 0.1437499350791298, 0.37044240893475144, 0.31101458602324406, 0.11167769733979716, 0.14981250570678928, 0.13514922012295816, 0.1551534390383551, 0.290839305238175, 0.16303040152112658, 0.15664471288065074, 0.13131432747643412, 0.37716631652435506, 0.11894566931875283, 0.24456656518878195, 0.5935195439683418, 0.6629934092484469, 0.5343950833809552, 0.570391736132574, 0.5374219168055909, 0.5877089795055372, 0.57717014675158, 0.6178739694542976, 0.6375271392696482, 0.11915784779114968, 0.13610061919979854, 0.10262749649862413, 0.1285817448768687, 0.16409581042617105, 0.11307133963307792, 0.11315103777637736, 0.1166986224943003, 0.13353182512568584, 0.15796962927685765, 0.15835627027709964, 0.15371684133798258, 0.1728953727137783, 0.14714020175617792, 0.14542585179547818, 0.16034715014195478, 0.14717507739122027, 0.1592359823451427, 0.31475199723709957, 0.6059832219748673, 0.32429401319863127, 0.39136329123025004, 0.3716755285238582, 0.4837338502082552, 0.5047813132081561, 0.559243305078393, 0.3900408257206218, 0.29397919942279727, 0.24867236745831633, 0.3115587200789329, 0.21108358938056304, 0.29442062802676916, 0.2798490840505603, 0.3381317885059716, 0.2815698424446471, 0.29882794492393727, 0.18596007492131117, 0.21372234228073506, 0.20953492464467904, 0.21274833928999237, 0.22367877915211432, 0.21346168273815413, 0.20634534625428236, 0.1955967058124971, 0.20767772169407261, 0.1937816963187764, 0.18233348672189265, 0.21948013233783836, 0.18257242497257298, 0.18933099463414105, 0.1780660403516955, 0.22209285178605465, 0.596230930269649, 0.18440861318196577, 0.16085628545771613, 0.7287129394746559, 0.40783629887397066, 0.5909550704673615, 0.4810258214672827, 0.18663438249553232, 0.5097932418456967, 0.6697468825411017, 0.3389030412465387, 0.22455025570271336, 0.45739351378344884, 0.19545502226933098, 0.19868253619473242, 0.4261178275558708, 0.19562894948049625, 0.33371402970366293, 0.44039024859847375, 0.4232949944105687, 0.17758643426160703, 0.21372721446833642, 0.18191021999301615, 0.1733531368578115, 0.1950119933633334, 0.20284905772136674, 0.19506657108647518, 0.16807795634561384, 0.19259235108930195, 0.08598670998172131, 0.0863078158529128, 0.09125630311518762, 0.08357844311123375, 0.08732981846247034, 0.08462223593854301, 0.09210454699398796, 0.09046046894367443, 0.09793488193042099]}, "mutation_prompt": null}
{"id": "0cf7744e-fabd-46e8-a6ea-22eff7ef0a11", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(4, 10 + 3 * int(np.log(dim)))  # Dynamic population size\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.F = np.random.uniform(0.2, 0.8, self.pop_size)\n        self.local_intensification = 0.07  # Slightly increased local search probability\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                \n                # Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = 0.5 * (mutant + local_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Exponential Crossover\n                crossover_start = np.random.randint(self.dim)\n                crossover_length = 0\n                while crossover_length < self.dim and (np.random.rand() < self.CR[i] or crossover_length == 0):\n                    index = (crossover_start + crossover_length) % self.dim\n                    trial = np.copy(self.population[i])\n                    trial[index] = mutant[index]\n                    crossover_length += 1\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.2 * self.CR[i] + 0.8 * np.random.rand()\n                    self.F[i] = 0.2 * self.F[i] + 0.8 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Dynamic Population and Exponential Crossover.", "configspace": "", "generation": 17, "fitness": 0.30948434579280176, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.29.", "error": "", "parent_id": "92125f7c-4855-4b16-8342-31bdced22398", "metadata": {"aucs": [0.9374212277830632, 0.9296832269593837, 0.9336884795088802, 0.935940017187941, 0.941332764149728, 0.9396499588478097, 0.9423728439693742, 0.9334626260812446, 0.9412289960000624, 0.8693614826543827, 0.8837172119361417, 0.887155429931532, 0.8783984914370626, 0.8737298963082493, 0.9002843177120751, 0.8753601696280184, 0.8783421692244319, 0.8914477296847741, 0.8408381239877296, 0.8603757444038659, 0.8896966265944772, 0.8714853084994738, 0.8594321951076946, 0.8430057033305313, 0.9011445464202631, 0.8274983863931566, 0.8513868097742089, 0.16374399522303706, 0.18981362429065252, 0.1904981638347354, 0.18970188143211275, 0.19048213121472612, 0.18907238337645882, 0.862064087073652, 0.11841356805666947, 0.26580687565360506, 0.971798141641227, 0.9789136873527465, 0.9726318951998035, 0.9682019338441556, 0.9849786928623826, 0.9830222528372436, 0.9732871546863058, 0.9735893216123591, 0.9832849827700934, 0.28859144240635626, 0.23058571753099566, 0.3312244845647755, 0.2596172467736457, 0.1955757631738153, 0.22240498534253816, 0.2080560288660669, 0.17124383252479258, 0.20539321761086404, 0.17758100918242004, 0.13903942739341946, 0.15278194319172722, 0.26556060912642654, 0.2557643261779111, 0.2509442563385841, 0.28315917086513087, 0.2358387494277261, 0.29840302133080476, 0.27509887660193977, 0.22381399535853141, 0.21226225768790796, 0.22306175300088282, 0.2972366085359647, 0.1292360220166604, 0.31108645420640146, 0.23670916944933285, 0.21825151795340436, 0.1589538570699176, 0.1602629030345193, 0.17696816069048704, 0.17640724338826308, 0.18709817497511694, 0.19520626440869138, 0.14255900030669222, 0.14737690190192043, 0.1369070862428422, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009994788622997852, 0.07051226456263249, 0.05952618974387047, 0.08299018059061092, 0.05153117782661032, 0.06782167097368785, 0.045723339778072525, 0.06409881418721874, 0.05202103497591637, 0.06592216883488677, 0.06736935116321163, 0.0032451197925321695, 0.007976636084285227, 0.009979664933620347, 0.07531184827520776, 0.017339699579696055, 0.019602045609455998, 0.01398807465774532, 0.0193869273543944, 0.12983075358854168, 0.09140753221640752, 0.12352307995035339, 0.13885758446490382, 0.11976841598120991, 0.13765616288673532, 0.08726269312602708, 0.13472657300858282, 0.14863851005880746, 0.4282805974675, 0.44975558519149395, 0.531384983049735, 0.4054433539749107, 0.45787449658277946, 0.44610611101711073, 0.43991036247906745, 0.4422854053242533, 0.4536249504608105, 0.12959786024268083, 0.11891273739327046, 0.125711825349056, 0.11035148717316312, 0.0996261960157423, 0.09963826133848142, 0.1253363486178659, 0.10511260732014238, 0.0904151567455227, 0.1875717105441519, 0.15462585428242204, 0.1555873036404355, 0.17107197157066856, 0.17536169873141094, 0.18871235215100968, 0.15751544518889915, 0.18356986650152218, 0.2055127520770197, 0.23918812233069797, 0.2408756619391591, 0.20267937384614476, 0.2651746157293966, 0.1872981819992906, 0.2633009367059267, 0.26450539437948006, 0.2546785765278773, 0.22286243538172834, 0.15294615485381513, 0.18168111219943706, 0.18873297352295615, 0.19691193660718076, 0.2157932760767639, 0.18688253033565116, 0.178912722514326, 0.18237950865206953, 0.18365508781435702, 0.2330627707747419, 0.20179474084894478, 0.21430603252553992, 0.20470143977432131, 0.22998693388634284, 0.19995987727019127, 0.2308277896585299, 0.1952348036226993, 0.22647595964175504, 0.24420265034989763, 0.23393207608263034, 0.42065120305473636, 0.2210597721804094, 0.23271926547890376, 0.2484479688418455, 0.24618592048270949, 0.2401616534668276, 0.23591293182239237, 0.19965200437050235, 0.1877495122969809, 0.1873447484812325, 0.48129421465583344, 0.1847371422324492, 0.4694840491411396, 0.258060508612585, 0.30728987544575337, 0.3129832974248994, 0.43847473890753985, 0.24936947783273788, 0.21012046682691998, 0.19596058729411114, 0.21697734417556946, 0.21382400791096012, 0.20209942459316532, 0.24774153237342145, 0.18948339714049778, 0.17208762940573108, 0.18587616520000416, 0.19132588736031364, 0.1679138609926265, 0.1687569256979412, 0.18136678090074798, 0.20123235780916537, 0.1836707646036264, 0.2004221179982354, 0.08729123289204288, 0.07574679969946829, 0.07798809864926626, 0.0865249557734925, 0.093480961622183, 0.09659546730008695, 0.08559275133019417, 0.07434566575396584, 0.10395053872646454]}, "mutation_prompt": null}
{"id": "134b2f4b-adf5-45d8-a202-53777fc0808a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # Increased population size for better exploration\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # Adjusted crossover rate range\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # Adjusted scaling factor range\n        self.local_intensification = 0.07  # Slightly increased local search probability\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with adaptive strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c]) + np.random.normal(0, 0.1, self.dim)\n\n                # Stochastic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best_idx = np.random.choice(np.argsort(self.fitness)[:max(1, self.pop_size // 5)])\n                    local_best = self.population[local_best_idx]\n                    mutant = 0.5 * (mutant + local_best)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Dynamic Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.2 * self.CR[i] + 0.8 * np.random.rand()\n                    self.F[i] = 0.2 * self.F[i] + 0.8 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with Adaptive Mutation, Dynamic Crossover, and Stochastic Local Search.", "configspace": "", "generation": 18, "fitness": 0.22877374699800815, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "92125f7c-4855-4b16-8342-31bdced22398", "metadata": {"aucs": [0.5011642113361214, 0.4991263168958565, 0.48275232759007103, 0.48454257648420274, 0.5179360349195257, 0.5032363766655557, 0.5107983738048656, 0.4993460760556181, 0.4924805419716174, 0.15104121885994737, 0.15178572376833233, 0.1496892908448082, 0.12119441654482088, 0.1488268040345987, 0.15792554242144563, 0.15708381746696054, 0.16520541495331076, 0.14044315425150766, 0.15905495891100074, 0.1545525795282212, 0.15646862315783905, 0.15011198022298666, 0.15731026545963545, 0.151930606880887, 0.142333879170346, 0.15390400195795284, 0.13729767695835526, 0.13112157376869749, 0.14931488111257363, 0.12058940376927763, 0.17977019029601937, 0.1368047746373362, 0.1268880454204171, 0.133898626500625, 0.1330006875527181, 0.12417940786253456, 0.9135096723450852, 0.9660405239887639, 0.9817708109381941, 0.9361457306920316, 0.9092178963008071, 0.9169697370612603, 0.9650146356260239, 0.9352923525233138, 0.9332703522720426, 0.2514033455595883, 0.27515980039285315, 0.2440289530795441, 0.27816743630439233, 0.25667271731535, 0.25966736780724053, 0.2672798260413186, 0.2618027815831334, 0.2605843908439046, 0.33238762948142553, 0.429451087038049, 0.31232439138219836, 0.3095186477347731, 0.4692376069879257, 0.3283667920119925, 0.5548866790323765, 0.49841927851690293, 0.35968874868170875, 0.18012444978960374, 0.14324189917487506, 0.15255000085208592, 0.14335770344100074, 0.1480470130085012, 0.14704243274474138, 0.1447126323257909, 0.1656054616828867, 0.1527334014976539, 0.16029122212056301, 0.1359923957795458, 0.1335452350080657, 0.1436845502401266, 0.14213505462425768, 0.13878603816246216, 0.14408848994886136, 0.16331775309094687, 0.1537609566971636, 0.003248031603734658, 0.008047510283137993, 0.01095699223864599, 0.004457892337687341, 9.999999999998899e-05, 0.0004697703074026949, 0.02422486567547799, 0.010987642338912473, 0.0014974691798648188, 0.1128656837094113, 0.0661061875185105, 0.11186766910147528, 0.09931867426297813, 0.0971468004219842, 0.0821217110421667, 0.08392007743667096, 0.09197001621595335, 0.08165408670768215, 0.004504065531805823, 0.0015674400487254436, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014446360635149702, 9.999999999998899e-05, 0.1040140612315823, 0.09814807320077812, 0.09243194748330863, 0.10794654351222777, 0.12212921237236063, 0.11461328500584145, 0.10777161462032325, 0.10728023462174208, 0.09327284068467578, 0.442324810745662, 0.43213538882412983, 0.4372327869163827, 0.4660332804545827, 0.4257292997543174, 0.42025039665125463, 0.44023306222443936, 0.44310779524612576, 0.41587340407678774, 0.11785117695041569, 0.09487641155540483, 0.10144129243205824, 0.09519152288137944, 0.0937537337799842, 0.11883055749630744, 0.12414637390326155, 0.10032192402000761, 0.11222197248929555, 0.14951960046136226, 0.15905232620410292, 0.1325164991103045, 0.13558469870410228, 0.12619333801530686, 0.15914876718318627, 0.1780871232503114, 0.15354735524001295, 0.14357507489541566, 0.2842259374282178, 0.28883472434023794, 0.29113923027825994, 0.2865066891574811, 0.2752984186270766, 0.3236221706956348, 0.31512517702104026, 0.30113869655819414, 0.304004732411717, 0.2239586049939829, 0.21051150475112645, 0.22657741103451678, 0.21060736737602648, 0.19758086854256407, 0.19235409338443887, 0.22913856308810676, 0.229680049217309, 0.2345661441005248, 0.1864498093249607, 0.1964542201258469, 0.20586108452359908, 0.20300401935603318, 0.20318155476060362, 0.2086292055970942, 0.20138491917287904, 0.20455467696625662, 0.19466432461724836, 0.1977665410739553, 0.25348516635527785, 0.20823151997042444, 0.2805547005133169, 0.2372534675070096, 0.22071012811856539, 0.1925287714399907, 0.20217648724334492, 0.19313661191885378, 0.27059133148674086, 0.3136518032580372, 0.410328720005375, 0.19529050959073835, 0.44462332012399053, 0.2376049855873258, 0.22124841741647427, 0.2943466224684608, 0.4361196718698571, 0.21162133162332597, 0.19415657707601397, 0.2969321210024597, 0.19803551137796715, 0.19147763595882028, 0.1899218771967508, 0.2943599269941829, 0.3859333916145773, 0.20686197674993845, 0.19378797744249643, 0.18897094781688528, 0.17412195685243081, 0.1761697257255782, 0.19183665544023865, 0.1942528601680248, 0.17753729524222162, 0.1809576561532622, 0.18545006334482939, 0.08254190876021494, 0.09204456190560051, 0.0855692535199758, 0.08083029065811365, 0.08890676521585306, 0.08500954284157325, 0.07753531328844088, 0.07370251338869016, 0.08002946882016782]}, "mutation_prompt": null}
{"id": "85285168-736a-406e-820c-d5ddeb0f0f93", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.1  # adjusted probability\n        self.dynamic_scale = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = 0.5 * (mutant + local_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # adjusted adaptation\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.2 * self.CR[i] + 0.8 * np.random.rand()\n                    self.F[i] = 0.2 * self.F[i] + 0.8 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with Dynamic Scaling and Adaptive Local Search Strategy.", "configspace": "", "generation": 19, "fitness": 0.36208719663914846, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "92125f7c-4855-4b16-8342-31bdced22398", "metadata": {"aucs": [0.8396843410479641, 0.834021926662286, 0.8385282262738469, 0.8306708955069456, 0.8389942798008858, 0.8392561289810514, 0.8453604521792771, 0.8487093096828379, 0.8323421316684234, 0.7087240699050256, 0.702512396290653, 0.7025356035392187, 0.7168477766803336, 0.6996069158123308, 0.7264918818816669, 0.6698860529793429, 0.7084086898857376, 0.7075883686811031, 0.5063825848926629, 0.4285625715457628, 0.4649532111393325, 0.4302274134109427, 0.4429608553774729, 0.5020080333220466, 0.48222926077362094, 0.4116086460139491, 0.42476283113550717, 0.4233361045870472, 0.15498616998156778, 0.15943947962716842, 0.3498276071619191, 0.1643066238978783, 0.2836831587879248, 0.42600933763904614, 0.1620026092681084, 0.2972281235360682, 0.9450133302717543, 0.9607161767164611, 0.9662375324221935, 0.9394986921092133, 0.9507772942712257, 0.9428855934910052, 0.9458728433191849, 0.9496287213312058, 0.936248541573442, 0.48885076302992014, 0.43566431629556, 0.4392501604301875, 0.48659259906441876, 0.4246219159525917, 0.4520149234680374, 0.45223479653985266, 0.41541888243807157, 0.2447482376436526, 0.7370616924582576, 0.7254405339740377, 0.5857259836513438, 0.7277637238277601, 0.7488528427669215, 0.25282966723647926, 0.7413241288528813, 0.6687476514624626, 0.7344313057118215, 0.1779755089993963, 0.25484868727072874, 0.1667350432686735, 0.16720721237801484, 0.20575919251817876, 0.17315768575935386, 0.16796093663951106, 0.1817148359181583, 0.1654828596815594, 0.18610109346712034, 0.1655616056805025, 0.18299791625961714, 0.19569350467108693, 0.16187127483311503, 0.18330708057107092, 0.151150993808018, 0.14748758901181014, 0.21600983478501323, 0.1378871326560709, 0.10288820891994532, 0.10850116322578707, 0.12752538408014913, 0.13996806023097474, 0.0765399145484893, 0.1341720881487266, 0.03546899048605101, 0.10577026113455723, 0.18647360830544324, 0.2288851589401356, 0.2807734727663068, 0.24672386754801467, 0.29193334481955, 0.23596883770511534, 0.2677640612182989, 0.25109831444610586, 0.226139045307577, 0.05679786439750223, 0.15179486644126705, 0.11306844923917392, 0.06123173847184282, 0.10516448719289362, 0.08436960525655035, 0.06476034090046778, 0.12168016603810972, 0.14688043285539154, 0.20573075885177639, 0.18682886673859378, 0.22300931755053044, 0.24839264222825963, 0.25038666075936555, 0.2475742346641132, 0.21294105530909413, 0.19353750761918653, 0.18599348574730146, 0.6140939305474298, 0.5946480918085448, 0.6076045369465177, 0.5816626271638101, 0.5894160256444341, 0.5683283627932656, 0.5944034103098759, 0.6025682464527111, 0.6194066910003814, 0.13309779075219974, 0.12632051399822508, 0.11790592401369104, 0.10708295869174855, 0.11753195375667436, 0.12572280929071444, 0.10323643241842184, 0.10502418136636404, 0.10711538087642125, 0.14375536632733477, 0.1444436851244043, 0.1744833915956462, 0.15750720023023856, 0.1474873381366184, 0.17834106228457935, 0.14923923377671144, 0.15181343089311672, 0.1565772156952393, 0.39132584398450954, 0.4108443716377814, 0.43895926147352127, 0.42326072425858596, 0.4165747345646764, 0.401286745927964, 0.4945417594599235, 0.49307340750649253, 0.4487345591455959, 0.28379405327143126, 0.29156821870632155, 0.27377723877296245, 0.32395826269181693, 0.28054429469141906, 0.3172469281009247, 0.33875775696191135, 0.327967492819658, 0.30767628984982165, 0.20489922616126455, 0.21550383383132998, 0.22456367720336823, 0.19153416315572291, 0.22275869671216275, 0.19431311360009873, 0.20259902477660985, 0.1937229763861409, 0.21405427232664298, 0.35109922503252367, 0.46715485583244587, 0.32234621727774415, 0.4229545798671398, 0.41302898463742355, 0.5061011263120236, 0.4638631674446102, 0.4590041112382399, 0.24713215900339502, 0.22128293269030264, 0.5072950396970148, 0.20059376205296864, 0.5084174733082352, 0.1875255232172749, 0.7270387366371651, 0.1669396063930637, 0.7187415040892489, 0.1692281225855078, 0.7436193915657523, 0.6225151255054975, 0.6289725316024687, 0.5414935869314184, 0.5223370286404342, 0.20379524064006138, 0.6855173317079334, 0.20651459087988455, 0.20741444149527155, 0.18309117477792025, 0.18186393438605697, 0.17895576299609006, 0.2054845805130614, 0.21377645309736548, 0.18345845980279696, 0.19196437309284597, 0.18051225479610855, 0.18018200663804163, 0.07817757156995464, 0.09060114139694564, 0.07968756407702948, 0.07918097794943424, 0.08182834064781763, 0.07837889435608247, 0.08211915449214935, 0.08865938125850203, 0.08554416191228342]}, "mutation_prompt": null}
{"id": "a28f227d-0102-4c3a-a40f-12b3a42cf314", "solution": "import numpy as np\n\nclass HybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.5, 0.9, self.pop_size)\n        self.neighborhood_radius = 0.2  # probability of neighborhood exploration\n        self.dynamic_learning = 0.15\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic learning\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                learn_factor = 1.0 + self.dynamic_learning * (np.random.rand() - 0.5)\n                mutant = self.population[a] + learn_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Adaptive Neighborhood Exploration\n                if np.random.rand() < self.neighborhood_radius:\n                    neighborhood = np.random.choice(indices, 5, replace=False)\n                    neighborhood_best = self.population[neighborhood[np.argmin(self.fitness[neighborhood])]]\n                    mutant = 0.5 * (mutant + neighborhood_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()  # enhanced adaptation\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.3 * self.CR[i] + 0.7 * np.random.rand()\n                    self.F[i] = 0.3 * self.F[i] + 0.7 * np.random.rand()\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridDE", "description": "Hybrid Differential Evolution with Dynamic Learning and Adaptive Neighborhood Exploration.", "configspace": "", "generation": 20, "fitness": 0.35911713179433086, "feedback": "The algorithm HybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "85285168-736a-406e-820c-d5ddeb0f0f93", "metadata": {"aucs": [0.8586595761398299, 0.8578579461705043, 0.8493619331249699, 0.8399279613153576, 0.8560700601064674, 0.845865338781165, 0.8495015612440091, 0.8508866400505958, 0.8490405663234246, 0.7231643005616303, 0.7099847104163852, 0.7162781017261357, 0.7249446981633842, 0.7263542937372611, 0.7183493433875974, 0.7308346493975628, 0.7369092274371488, 0.7166854622795849, 0.43669312148145634, 0.3940757455489621, 0.5349836994267531, 0.47277252342688414, 0.38062897365290727, 0.4487282798727209, 0.521269860377237, 0.4427245467217955, 0.4922706282063566, 0.16301470574708743, 0.1643826758499668, 0.1621154786732213, 0.15866647548619695, 0.15153334638128269, 0.38092546546289274, 0.3603067001203736, 0.2839253367358948, 0.3324947805301529, 0.9357535621502521, 0.9367080350086047, 0.9225936327344981, 0.9586577804630981, 0.9836250068734104, 0.95074889458096, 0.93722770343171, 0.959302766126894, 0.9295605202019674, 0.3684234948867876, 0.36247042245507544, 0.3411748832279936, 0.4766357188353876, 0.48761111073649255, 0.49648807018342656, 0.43637874213921635, 0.3587583118224835, 0.4177171375495017, 0.7323218438816912, 0.7694579379601258, 0.6924071412461148, 0.6873743567944999, 0.770366539058839, 0.6784110416095039, 0.6594106034872933, 0.6970899432672251, 0.762000186047479, 0.16568000338618494, 0.21672031597312458, 0.19789483212310233, 0.18043070381615856, 0.1505751288022571, 0.17046888849499098, 0.21600152081236068, 0.1576438413466612, 0.16698570447236494, 0.16553375200776865, 0.1590542793623505, 0.14881314873796914, 0.1579268531278245, 0.2294847536645167, 0.16815750572201782, 0.1751839515841721, 0.1595741844465487, 0.14586458703226868, 0.08210201022442254, 0.12373107387786442, 0.11540104351542269, 0.12209309749697517, 0.14946778330611088, 0.08395820174612367, 0.14798782071454863, 0.15169882287521996, 0.10172320187206174, 0.29122949768609374, 0.21486033832030205, 0.25981650350406116, 0.17757385472163623, 0.11207991595806976, 0.18469437911383324, 0.30251904444028777, 0.27072569341672337, 0.2421006057212679, 0.10096589212812035, 0.11469791195720669, 0.1396294712770647, 0.08047231144232714, 0.103618553413371, 0.16184778221950413, 0.09935852932774292, 0.08991653162701352, 0.12388162347099896, 0.2623647810317238, 0.21576134730392382, 0.17535519817845457, 0.25197411466082065, 0.23850554282056402, 0.22852639200702662, 0.204187422067858, 0.217979175977858, 0.20940986012666474, 0.5684396421266451, 0.5767426892569949, 0.6206404277945319, 0.6088754549497415, 0.6036149371692614, 0.6176303952920927, 0.6093218704008935, 0.6076463220746604, 0.6149125995509346, 0.1127778295803693, 0.12645795020197748, 0.10737861899504753, 0.08992944934978464, 0.12700958564344278, 0.11012073287906898, 0.11245938816321122, 0.10458750373856218, 0.10593463165268036, 0.13563749220500343, 0.15617360582740691, 0.14738372833628688, 0.14663312012122953, 0.1348513942119991, 0.15838863447074658, 0.19214082848310732, 0.15064465088010914, 0.15206870684827478, 0.371192228889602, 0.40968091825656994, 0.4531037133085142, 0.44819139384026785, 0.461640392959178, 0.4724630256940493, 0.5231917159781042, 0.4974622875275869, 0.516932728553489, 0.2361902632090599, 0.2439299011628736, 0.28421926677748277, 0.266629946000546, 0.24640696879314883, 0.29062542237742583, 0.3134903588627339, 0.22353294068724539, 0.34340925303191605, 0.23228056058837254, 0.19470757425262641, 0.22346939467566984, 0.20120939643110647, 0.22173274440135338, 0.21483619208112537, 0.2224598450493499, 0.19095839256276226, 0.20808296389697745, 0.27573087090180914, 0.21750352085417068, 0.47823799106572396, 0.23089424128465919, 0.3222855559203849, 0.2227545739725263, 0.25902449817943696, 0.23190257790468116, 0.5680167698197458, 0.1778623238865884, 0.18270695529140457, 0.5709429225887881, 0.7433450154221773, 0.2867798173200774, 0.6529559297389712, 0.48837746574467256, 0.40757926943046363, 0.6263575779251352, 0.32632282141221325, 0.20157096993919088, 0.47780076262043847, 0.2048694014063962, 0.623136253748231, 0.4438477979499952, 0.3904299040519287, 0.5282337745923514, 0.2010256273007155, 0.1865551821422048, 0.18388880465043778, 0.1971956819015641, 0.18633498784081048, 0.20267440065044506, 0.18853903532572158, 0.1740241159917698, 0.18768376813635834, 0.18180081257376868, 0.0860111987154143, 0.08072535349794485, 0.09446484236013153, 0.09001528131389347, 0.08632998054543672, 0.08503520814048648, 0.08365284376958348, 0.10305859786741767, 0.08530981653838077]}, "mutation_prompt": null}
{"id": "528502e4-a95c-47f3-a38d-07883860932b", "solution": "import numpy as np\n\nclass ChaosEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.12  # increased probability for local search\n        self.dynamic_scale = 0.15  # increased dynamic scale\n        self.chaos_coefficient = 0.7\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.85 * self.CR[i] + 0.15 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.85 * self.F[i] + 0.15 * np.random.rand()\n                else:\n                    self.CR[i] = 0.25 * self.CR[i] + 0.75 * np.random.rand()\n                    self.F[i] = 0.25 * self.F[i] + 0.75 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ChaosEnhancedAdaptiveDE", "description": "Chaos-Enhanced Adaptive Differential Evolution with Dynamic Scaling and Chaotic Local Search Strategy.", "configspace": "", "generation": 21, "fitness": 0.36669874597392665, "feedback": "The algorithm ChaosEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "85285168-736a-406e-820c-d5ddeb0f0f93", "metadata": {"aucs": [0.8516777303699561, 0.8420100903715558, 0.8439172416654422, 0.8403588497302532, 0.8562194516651759, 0.8464452428713223, 0.837626320556198, 0.8458842226021219, 0.8504924421778526, 0.7156881488080657, 0.7153462319016233, 0.7017127344505695, 0.7143821728508449, 0.7162725320330415, 0.7065831707177768, 0.7179256665595887, 0.7196906123379285, 0.7061156869569589, 0.5033203172507426, 0.4577483367807428, 0.43187518163659555, 0.43366550745873333, 0.47776332014894074, 0.38446160912207705, 0.44113336113144175, 0.35315503655790625, 0.4974992439921514, 0.16036455015148765, 0.15750436682766067, 0.33950853941559633, 0.14445576184013043, 0.1496804677552449, 0.2971666085141853, 0.16242017062873038, 0.16116039953107753, 0.41828266649608026, 0.945324632989189, 0.9418045879608818, 0.955118811775254, 0.9733188070235521, 0.9388541966530447, 0.9658522302989205, 0.9477562878875243, 0.9502797288050124, 0.9432194115000343, 0.44627990705554343, 0.43840307523353916, 0.4836810015713542, 0.5228039315635292, 0.48308868849702613, 0.5137620051065892, 0.46304178165084164, 0.43170442466782377, 0.445070040229939, 0.7351837105335801, 0.640920460343434, 0.6726756917533631, 0.7825556709059193, 0.7108346251313481, 0.7378561877205343, 0.6935505435541429, 0.7833057085427051, 0.6452472882863279, 0.1800895039235405, 0.14857754685142577, 0.17920427368230885, 0.37265612856300956, 0.12617061106928562, 0.1606186163502651, 0.21777091554918038, 0.2126191100280792, 0.20991747298148944, 0.22239794620648978, 0.18023141472931514, 0.18672053271734834, 0.14714265063935128, 0.19365244513389546, 0.176373897930707, 0.1540734313076476, 0.15907239737036238, 0.17753263487030313, 0.13212241904713828, 0.12083150698448664, 0.11708146011077225, 0.15551923507141474, 0.09776218332561037, 0.07676802722478537, 0.16505570203566222, 0.12229238888741256, 0.20075525009597617, 0.23082048002196975, 0.19774035668851653, 0.24011962907230755, 0.24115032103253742, 0.2507074289316117, 0.24801635563349356, 0.2949441265512832, 0.24802412025749032, 0.2993216250730465, 0.06905201365019842, 0.11234499733196135, 0.06202649913394487, 0.08608763389953544, 0.12377773634495715, 0.13605099717683988, 0.07913325114695746, 0.11228574433513672, 0.11351386001450192, 0.1769193946053469, 0.20317930484987412, 0.22471309330914901, 0.22497569544786622, 0.21813269347505615, 0.26658773533317737, 0.2082628287925088, 0.20906748603272707, 0.20671699736884896, 0.6140045171491146, 0.5835153389929406, 0.5933375729920644, 0.5693977585154885, 0.6197328380031537, 0.5908543764083489, 0.5555005637341031, 0.5910280698768723, 0.5712021491061046, 0.12541289881108297, 0.12429668575643371, 0.1269242641016899, 0.125154380582727, 0.10356225717157597, 0.09635827305463096, 0.11158479819788703, 0.11359844800820396, 0.10904028619963979, 0.17015472800122822, 0.16186845074699507, 0.14440348710488216, 0.1546566169325393, 0.14571824936347788, 0.1349448398409533, 0.14664359891097067, 0.14412961675683, 0.13465156750745721, 0.4192534210729332, 0.41663047947796916, 0.45037905983421544, 0.42612625476393584, 0.42586638173536295, 0.42463585346338584, 0.4759623656451024, 0.4747618901065026, 0.49364143051028475, 0.3062090963697479, 0.25062300253670566, 0.28784620400866856, 0.24128975710584233, 0.3126970778592496, 0.28792273717505523, 0.3265406617161327, 0.33993404251161485, 0.3309666541796009, 0.2109183675807389, 0.20235092913901087, 0.18871973865931613, 0.19496587007181654, 0.2016747107610538, 0.1921849943720163, 0.19392012115991297, 0.2148276352954135, 0.20114021802003434, 0.2644295937461887, 0.5027827513184406, 0.3911890778960422, 0.2356562997176722, 0.46452624944269005, 0.20044237684501465, 0.27028964444399184, 0.3216565589064655, 0.39816632829679455, 0.6386362266501473, 0.7289425789912467, 0.17227111615117208, 0.7808058192911503, 0.685085963409322, 0.6644329763351611, 0.6530026770727535, 0.5253180698939407, 0.6751497710519554, 0.6866373420857477, 0.1641554971534388, 0.2076721528972556, 0.3413158573489674, 0.5213847858537168, 0.19896400087086896, 0.19902685211691118, 0.20641461708983844, 0.6115846263372586, 0.1772591900039937, 0.2279341817366759, 0.20758863336563615, 0.1756920186362304, 0.19493165433474047, 0.1882207329217207, 0.17193583116455935, 0.19274915255409286, 0.173739002737898, 0.08865959350619235, 0.08372187699254996, 0.0807382962418618, 0.08845878082296821, 0.08554751428889051, 0.08376106711618436, 0.08857855340721055, 0.0839171600514983, 0.08220095300721186]}, "mutation_prompt": null}
{"id": "69ca9a1d-9ba3-4537-87d1-a3a0b298e881", "solution": "import numpy as np\n\nclass AdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.15  # increased probability for local search\n        self.dynamic_scale = 0.2  # increased dynamic scale\n        self.chaos_coefficient = 0.8\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.3 * self.CR[i] + 0.7 * np.random.rand()\n                    self.F[i] = 0.3 * self.F[i] + 0.7 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveChaoticDE", "description": "Adaptive Differential Evolution with Chaotic Perturbation and Adaptive Crossover for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 22, "fitness": 0.3725506498688676, "feedback": "The algorithm AdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "528502e4-a95c-47f3-a38d-07883860932b", "metadata": {"aucs": [0.8455403158578642, 0.851529883619281, 0.8511666394641517, 0.854070764620264, 0.8475196238754061, 0.8309456665746452, 0.8416298042921087, 0.8502152686167717, 0.8502313914424582, 0.7317383724823259, 0.7401193135407678, 0.719023750782183, 0.7320840950533338, 0.7120803368894733, 0.7347397686605083, 0.7115069410871695, 0.7226742201437624, 0.7420850236991621, 0.40394871217503836, 0.5480749864120711, 0.1645003958865041, 0.429536361451063, 0.3836132546994846, 0.5549146625263024, 0.48490905749183744, 0.40850628713897297, 0.49295154017745624, 0.32540702928425624, 0.2575371737171024, 0.4307392218096686, 0.16049128276097835, 0.380889970617331, 0.3055394319398209, 0.41662363178679296, 0.40583275518266904, 0.31911453277377133, 0.9542088467879517, 0.9353756259647555, 0.9500384063510294, 0.9481489682987162, 0.9592435079922756, 0.9149533000246344, 0.9427512014689297, 0.9493006322818018, 0.9456427382600637, 0.5060485621994724, 0.3920731286821554, 0.4694228506918907, 0.5205079802995407, 0.4852639250240284, 0.5610157995682659, 0.48294740542069803, 0.4029674075999772, 0.4586425157108386, 0.7337556983233048, 0.6983909655307037, 0.5464042032194791, 0.7652963147521277, 0.7550121156219212, 0.21022428656917136, 0.4941424666020242, 0.7353521106825351, 0.7604331432266935, 0.19339937833820908, 0.17639879917789292, 0.20512435258846584, 0.31319559576870126, 0.22466439600554355, 0.2016954264950599, 0.4031236260815867, 0.19581859712263894, 0.174571437432677, 0.15517377163809365, 0.14102686236859185, 0.16061296721627405, 0.19408489206047663, 0.15014045193102354, 0.17985175302763878, 0.16492383182295922, 0.17943575245545762, 0.1945863452339881, 0.13044572415996247, 0.07487735050186184, 0.0884824984869107, 0.15489867366428556, 0.03375056644112284, 0.1225391075150759, 0.16253156045446981, 0.12452228227086126, 0.01233791879152013, 0.2263336739605476, 0.2409020966894425, 0.23929321962649308, 0.1588954997917763, 0.2877332163327315, 0.267687855562483, 0.2936131211053198, 0.2589173679902589, 0.24874212473333068, 0.052100051244589274, 0.15103334513649003, 0.056373376442899414, 0.08892449520253998, 0.1747272342552244, 0.13848806631308885, 0.07278822052098932, 0.150382127516847, 0.11016048103326137, 0.2253131383291408, 0.2223631669129571, 0.15607750994899017, 0.232116427458401, 0.2745716162500871, 0.21361093167556255, 0.2069560090074002, 0.21695160128101976, 0.23817387446180116, 0.6284607953257412, 0.5893577321211145, 0.6371446794411868, 0.6283311033296439, 0.6287072885082008, 0.6128027145046903, 0.6208975979296301, 0.6171471851127011, 0.6110993169233571, 0.11474547363119314, 0.12425448333453626, 0.12162427569247303, 0.11557416920736052, 0.10679133720566969, 0.10249933921034404, 0.13025075565320343, 0.10671301147925771, 0.11098754290955715, 0.185822917868965, 0.15295088133220092, 0.13476913209832997, 0.1627668576764778, 0.14774486344429583, 0.17618974804040244, 0.1313003163548212, 0.13854580499852054, 0.1468693248611277, 0.4897927495642319, 0.45520042910465086, 0.43284563096104334, 0.4214484882682187, 0.4421248262556441, 0.4513969104770418, 0.5144064631539391, 0.504490696308147, 0.4893745982697034, 0.2978711879988346, 0.3187084275754535, 0.3421264656719353, 0.23847258508393132, 0.3535020146881994, 0.3018249045450291, 0.3673855104521413, 0.33033480468802223, 0.34450975739035905, 0.20808959265147664, 0.20833320376592102, 0.21937843491710174, 0.19602975571191772, 0.20730964304685573, 0.19386550203469022, 0.21164893970564247, 0.2107402122120069, 0.21490015826106967, 0.4359161339196649, 0.5202034280027362, 0.5624949988343797, 0.3717528775667158, 0.48246984101857726, 0.4440867367342054, 0.323786650390379, 0.24581322590554677, 0.20274617634220737, 0.17028597883083108, 0.18123607563406896, 0.665693590753081, 0.6417985759237941, 0.18770587379394388, 0.7570911094121868, 0.7711492754332474, 0.4313729263741758, 0.48928221036899044, 0.7083385501564877, 0.16520298065825278, 0.5635325537412731, 0.491774714025379, 0.37555562104714824, 0.2049033674896592, 0.6936928904095838, 0.20637298060391662, 0.5597573486318553, 0.1779088752328295, 0.21580784761159155, 0.17893902904564762, 0.18124919598386613, 0.17533610677076517, 0.19326286533459813, 0.1754213401593936, 0.18587030471299304, 0.196114936996597, 0.08435207742433615, 0.08709497248455134, 0.07408881862008454, 0.07859316733609722, 0.08365596805830278, 0.08879368896995599, 0.08282969558861952, 0.08677428971770529, 0.08533061514420259]}, "mutation_prompt": null}
{"id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.2  # modified probability for local search\n        self.dynamic_scale = 0.25  # modified dynamic scale\n        self.chaos_coefficient = 0.7  # adjusted chaos coefficient\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.4 * self.CR[i] + 0.6 * np.random.rand()\n                    self.F[i] = 0.4 * self.F[i] + 0.6 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Chaotic Perturbation and Novel Mutation Strategy for Improved Diversity and Convergence.", "configspace": "", "generation": 23, "fitness": 0.3800438988478461, "feedback": "The algorithm EnhancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "69ca9a1d-9ba3-4537-87d1-a3a0b298e881", "metadata": {"aucs": [0.8642587286426702, 0.8609406490132158, 0.8728120986088378, 0.8681121240218025, 0.8629746384343402, 0.8634032037495901, 0.8595516975032913, 0.8574960091459829, 0.855462258412699, 0.736407306176335, 0.7500851045774101, 0.7445156499699622, 0.7603146841578602, 0.7314780778658387, 0.7435820993287903, 0.7344521890619385, 0.7323818436870567, 0.76038897495266, 0.4369637534117452, 0.4381576818601155, 0.43872001080120737, 0.4596818627196516, 0.48768630499778287, 0.16784913995853024, 0.4156773397657473, 0.5223554503745265, 0.440537554868219, 0.25794651127649204, 0.15311891545191847, 0.35623533132719953, 0.16010567377639617, 0.1579060078694714, 0.15817078399632212, 0.2889948146184663, 0.17171352443201993, 0.3952359530911187, 0.9207832713044425, 0.9539878575430775, 0.9663082305887337, 0.9316004974144727, 0.9309389232054249, 0.9628149526563502, 0.9570517648775765, 0.9431365867057501, 0.9513908935588261, 0.5270950244553669, 0.5087913948183946, 0.566276233469839, 0.5458894020584917, 0.5428972957080621, 0.5459884286328714, 0.4651415324538595, 0.4087930595137841, 0.4514859229570578, 0.7581598782772099, 0.7279619416912725, 0.21932550772528736, 0.8267670423887477, 0.7958240893876926, 0.7208376114730333, 0.6738457508856177, 0.7631088627442554, 0.7562115003604728, 0.1768681149640271, 0.1651719122494385, 0.17494609879137424, 0.1696374664710838, 0.16269592772866692, 0.1794613954029195, 0.1850620238492685, 0.23164049606178783, 0.16419276164748464, 0.19174775050019643, 0.14977699447468262, 0.14462675563402538, 0.18788857123489433, 0.17504617970622272, 0.17902533024333478, 0.17171321723563415, 0.17177166226070517, 0.13910531537135518, 0.10919775428684975, 0.06833647632499373, 0.08963455676467569, 0.1663664898542644, 0.06833451495816256, 0.07858745662230793, 0.12235936601916897, 0.15647569415572438, 0.07220850623507413, 0.2540285883843234, 0.29246589129783507, 0.2975967878514134, 0.20224993414383452, 0.26759536261074535, 0.21408936923586697, 0.32126464056633985, 0.31503395147019286, 0.3282976814337638, 0.09213023569034628, 0.08087871391830326, 0.11815008669688343, 0.08593161218996215, 0.16119172630658163, 0.16488452679609278, 0.07631024367344053, 0.1379124214596089, 0.14594438905710416, 0.1574415272608567, 0.20073868669669226, 0.20052949662794228, 0.24708264975599314, 0.27395534569097035, 0.26834777327511294, 0.23351786975646804, 0.15379770525462577, 0.2188108178262953, 0.6169813556927457, 0.6015301658348291, 0.6031188234819327, 0.6213732949642775, 0.6244523381402938, 0.6161058836067006, 0.6395791462367733, 0.6119576201936823, 0.6064445325266203, 0.10923409408382267, 0.11066539030053046, 0.12228735459633333, 0.1347363212609184, 0.1216972418138812, 0.11337772460052697, 0.11832808561599106, 0.11468855930828015, 0.10940118903350449, 0.12897711475092855, 0.13647349110250284, 0.14862928588230084, 0.1514605172650184, 0.15687395998772247, 0.16234563043613448, 0.16747790980138122, 0.15214753933752256, 0.11954674378315322, 0.44820700694137827, 0.46425560068195504, 0.45397799967520425, 0.4709118716857894, 0.42786787991147834, 0.47437366981269147, 0.561103992938048, 0.5016084219406233, 0.5459592336906501, 0.3298720050424384, 0.3227001439271786, 0.3216501459342145, 0.22331394970286178, 0.29638254617884263, 0.22206296010595483, 0.36537362363423, 0.35192194567534274, 0.38744851440843975, 0.2215590218356751, 0.19777628041230877, 0.21001458844401955, 0.2188595895062766, 0.22671462551996813, 0.21643816782960834, 0.20113713702500768, 0.19627291417262172, 0.2389488620616813, 0.23278855819161137, 0.47944435705039157, 0.47077617675359584, 0.281778275792426, 0.39812011626043387, 0.2689059253080168, 0.5039209064353017, 0.2346549864300591, 0.4696505300946161, 0.8144139527255649, 0.17987024001637386, 0.19097467172587268, 0.8227066033900299, 0.8260594890483264, 0.7301274103247045, 0.8266331223194627, 0.4328264673478277, 0.7218065354909698, 0.7502819398478842, 0.6549643156297577, 0.6649848369663592, 0.5534946647299477, 0.16684099748643244, 0.20226237882359133, 0.6527998439729179, 0.20806352736600198, 0.6019828559164369, 0.17395417724362028, 0.1865946654761489, 0.18697260155194928, 0.2198908097802038, 0.18413999878564147, 0.19757354245823666, 0.19095333595723452, 0.1828839488225612, 0.19116076093601908, 0.08509600550091201, 0.08136724543065577, 0.07883230139764275, 0.09359053919228788, 0.08324640183872567, 0.08778348891960575, 0.08594887824644992, 0.08526309813303956, 0.08634842094701634]}, "mutation_prompt": null}
{"id": "bbf39c87-2205-41e6-8600-f2977423375c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.2  # modified probability for local search\n        self.dynamic_scale = 0.25  # modified dynamic scale\n        self.chaos_coefficient = 0.7  # adjusted chaos coefficient\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.4 * self.CR[i] + 0.6 * np.random.rand()\n                    self.F[i] = 0.4 * self.F[i] + 0.6 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Chaotic Perturbation and Novel Mutation Strategy for Improved Diversity and Convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8642587286426702, 0.8609406490132158, 0.8728120986088378, 0.8681121240218025, 0.8629746384343402, 0.8634032037495901, 0.8595516975032913, 0.8574960091459829, 0.855462258412699, 0.736407306176335, 0.7500851045774101, 0.7445156499699622, 0.7603146841578602, 0.7314780778658387, 0.7435820993287903, 0.7344521890619385, 0.7323818436870567, 0.76038897495266, 0.4369637534117452, 0.4381576818601155, 0.43872001080120737, 0.4596818627196516, 0.48768630499778287, 0.16784913995853024, 0.4156773397657473, 0.5223554503745265, 0.440537554868219, 0.25794651127649204, 0.15311891545191847, 0.35623533132719953, 0.16010567377639617, 0.1579060078694714, 0.15817078399632212, 0.2889948146184663, 0.17171352443201993, 0.3952359530911187, 0.9207832713044425, 0.9539878575430775, 0.9663082305887337, 0.9316004974144727, 0.9309389232054249, 0.9628149526563502, 0.9570517648775765, 0.9431365867057501, 0.9513908935588261, 0.5270950244553669, 0.5087913948183946, 0.566276233469839, 0.5458894020584917, 0.5428972957080621, 0.5459884286328714, 0.4651415324538595, 0.4087930595137841, 0.4514859229570578, 0.7581598782772099, 0.7279619416912725, 0.21932550772528736, 0.8267670423887477, 0.7958240893876926, 0.7208376114730333, 0.6738457508856177, 0.7631088627442554, 0.7562115003604728, 0.1768681149640271, 0.1651719122494385, 0.17494609879137424, 0.1696374664710838, 0.16269592772866692, 0.1794613954029195, 0.1850620238492685, 0.23164049606178783, 0.16419276164748464, 0.19174775050019643, 0.14977699447468262, 0.14462675563402538, 0.18788857123489433, 0.17504617970622272, 0.17902533024333478, 0.17171321723563415, 0.17177166226070517, 0.13910531537135518, 0.10919775428684975, 0.06833647632499373, 0.08963455676467569, 0.1663664898542644, 0.06833451495816256, 0.07858745662230793, 0.12235936601916897, 0.15647569415572438, 0.07220850623507413, 0.2540285883843234, 0.29246589129783507, 0.2975967878514134, 0.20224993414383452, 0.26759536261074535, 0.21408936923586697, 0.32126464056633985, 0.31503395147019286, 0.3282976814337638, 0.09213023569034628, 0.08087871391830326, 0.11815008669688343, 0.08593161218996215, 0.16119172630658163, 0.16488452679609278, 0.07631024367344053, 0.1379124214596089, 0.14594438905710416, 0.1574415272608567, 0.20073868669669226, 0.20052949662794228, 0.24708264975599314, 0.27395534569097035, 0.26834777327511294, 0.23351786975646804, 0.15379770525462577, 0.2188108178262953, 0.6169813556927457, 0.6015301658348291, 0.6031188234819327, 0.6213732949642775, 0.6244523381402938, 0.6161058836067006, 0.6395791462367733, 0.6119576201936823, 0.6064445325266203, 0.10923409408382267, 0.11066539030053046, 0.12228735459633333, 0.1347363212609184, 0.1216972418138812, 0.11337772460052697, 0.11832808561599106, 0.11468855930828015, 0.10940118903350449, 0.12897711475092855, 0.13647349110250284, 0.14862928588230084, 0.1514605172650184, 0.15687395998772247, 0.16234563043613448, 0.16747790980138122, 0.15214753933752256, 0.11954674378315322, 0.44820700694137827, 0.46425560068195504, 0.45397799967520425, 0.4709118716857894, 0.42786787991147834, 0.47437366981269147, 0.561103992938048, 0.5016084219406233, 0.5459592336906501, 0.3298720050424384, 0.3227001439271786, 0.3216501459342145, 0.22331394970286178, 0.29638254617884263, 0.22206296010595483, 0.36537362363423, 0.35192194567534274, 0.38744851440843975, 0.2215590218356751, 0.19777628041230877, 0.21001458844401955, 0.2188595895062766, 0.22671462551996813, 0.21643816782960834, 0.20113713702500768, 0.19627291417262172, 0.2389488620616813, 0.23278855819161137, 0.47944435705039157, 0.47077617675359584, 0.281778275792426, 0.39812011626043387, 0.2689059253080168, 0.5039209064353017, 0.2346549864300591, 0.4696505300946161, 0.8144139527255649, 0.17987024001637386, 0.19097467172587268, 0.8227066033900299, 0.8260594890483264, 0.7301274103247045, 0.8266331223194627, 0.4328264673478277, 0.7218065354909698, 0.7502819398478842, 0.6549643156297577, 0.6649848369663592, 0.5534946647299477, 0.16684099748643244, 0.20226237882359133, 0.6527998439729179, 0.20806352736600198, 0.6019828559164369, 0.17395417724362028, 0.1865946654761489, 0.18697260155194928, 0.2198908097802038, 0.18413999878564147, 0.19757354245823666, 0.19095333595723452, 0.1828839488225612, 0.19116076093601908, 0.08509600550091201, 0.08136724543065577, 0.07883230139764275, 0.09359053919228788, 0.08324640183872567, 0.08778348891960575, 0.08594887824644992, 0.08526309813303956, 0.08634842094701634]}, "mutation_prompt": null}
{"id": "8ed0eb10-7801-4452-a1e0-52d6cde9cc32", "solution": "import numpy as np\n\nclass AdaptiveSelfOrganizingDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.5, 0.9, self.pop_size)\n        self.local_intensification = 0.25\n        self.dynamic_scale = 0.3\n        self.chaos_coefficient = 0.6\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * (1 - x * x)  # Logistic map variation\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()\n                    self.F[i] = 0.7 * self.F[i] + 0.3 * np.random.rand()\n                else:\n                    self.CR[i] = 0.5 * self.CR[i] + 0.5 * np.random.rand()\n                    self.F[i] = 0.5 * self.F[i] + 0.5 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveSelfOrganizingDE", "description": "Adaptive Self-organizing Differential Evolution with Chaos-Induced Exploration and Intensified Local Search for Robust Optimization.", "configspace": "", "generation": 25, "fitness": 0.28556047480475616, "feedback": "The algorithm AdaptiveSelfOrganizingDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.7783658385193392, 0.789802942768042, 0.790520060666057, 0.7850254814665, 0.7950875048312572, 0.784776803370206, 0.785452762569816, 0.8060538921419398, 0.7761180626097057, 0.6222235699276821, 0.6417918719157183, 0.6148201200226406, 0.6277586105370774, 0.6404896063167889, 0.6171435136343205, 0.6066369781453043, 0.617141795610164, 0.6276138511274068, 0.30044082098937475, 0.34989658235003895, 0.19468129737488238, 0.30068714869373536, 0.193165664904272, 0.2470396784317066, 0.3429938052492042, 0.19615185025083792, 0.2715026760768797, 0.2337684478604376, 0.15303518643945713, 0.17635547957591446, 0.17972793766840622, 0.2318770937330129, 0.22512923792398032, 0.2052053763212539, 0.2324087080153432, 0.1693069161513071, 0.9459801906713677, 0.9439452824191948, 0.951639007229352, 0.933940144790497, 0.9438288852067098, 0.950970198507895, 0.9548528582832605, 0.9699133054437267, 0.9458687479733521, 0.33143387089684406, 0.3065088082723334, 0.32484839824169254, 0.3313479516021035, 0.3015694342040709, 0.37271471049299776, 0.35104026937475263, 0.34603092291685067, 0.3076217319048462, 0.5297073318808234, 0.45346749048071633, 0.5647152582099693, 0.5585212265923534, 0.3132893610441677, 0.6262867531606906, 0.5295260467416678, 0.592139604993497, 0.5245658116004679, 0.16689676146643995, 0.14642478579456075, 0.16371175795182658, 0.16213352981901352, 0.22657563855179774, 0.1702345386585159, 0.17801816179688268, 0.17241085295151604, 0.18637118155808552, 0.12448562480723813, 0.10763001635085767, 0.1337625517102895, 0.1621393331222194, 0.21111417335903837, 0.16498046574098368, 0.15785122945567398, 0.17285426882812405, 0.14190603259258028, 0.0403111462881206, 0.010326601757423282, 0.02592305142704776, 0.02499066749322243, 0.06363011047634703, 0.03156895782922953, 0.02281213269033311, 0.028704275951281888, 0.03821629737345589, 0.09255668238344383, 0.12777660269860502, 0.12260567207866702, 0.13157629570724116, 0.12060431449971543, 0.14922766640504437, 0.17827448510829202, 0.11828880858239899, 0.15594694806283316, 0.0012044239676149981, 0.009610683517279672, 0.01607020968622397, 0.0260808570419776, 0.018814364362860214, 0.010714477277697032, 0.006163733429220386, 0.017037788162145295, 0.02450887252514078, 0.13693585679457632, 0.11006362297849814, 0.12006081340490615, 0.14851414001056362, 0.1600199358582468, 0.1366496818069154, 0.12303079808991657, 0.133786895980324, 0.14237408370275118, 0.48209743106543446, 0.504235335904004, 0.5100410953712893, 0.5255623994842128, 0.4959600697623824, 0.503781232974354, 0.5000148307427621, 0.4850412280193179, 0.5158289602161122, 0.0964298903273555, 0.0982479083659582, 0.11985738640975652, 0.1101789700982998, 0.09438464477291963, 0.10842931206591289, 0.08476303737743396, 0.10436980820212849, 0.11268493196317064, 0.1469120837475748, 0.15309341729589832, 0.1940992588157091, 0.16139794105795902, 0.14402619667483219, 0.14121109832207113, 0.14278267065030326, 0.1570672082701694, 0.15421161817861206, 0.31997566314590375, 0.29685985703289086, 0.30771227042080374, 0.31443968619422225, 0.31952728101343275, 0.3136741560014047, 0.34804886730463735, 0.3433221966587836, 0.38377358755812363, 0.2350189255518187, 0.21709147412471563, 0.2129004862641033, 0.22670014976466213, 0.19775001167551098, 0.18761561265456295, 0.22565915309490836, 0.26704005555936194, 0.22291056910633178, 0.20982123825891585, 0.18688632390123872, 0.2287494738420648, 0.1919418966625399, 0.18941279050574278, 0.20463884163426094, 0.1955911980528907, 0.19655408032282717, 0.19084097557539403, 0.20031585412535657, 0.3022115921713938, 0.22143085174107413, 0.33298561482541134, 0.19298013335773045, 0.21214262952994722, 0.23161009271475363, 0.2355626966512394, 0.19963010157552807, 0.16137643140140845, 0.18034015949942206, 0.1948710907453396, 0.28746500081215065, 0.29633119194575297, 0.4979197572235108, 0.22943079072450479, 0.25063689322180716, 0.36844595659487767, 0.3013416313757119, 0.1928787227837736, 0.25186536162900486, 0.1779766924763202, 0.36394944293236775, 0.18146173495830742, 0.36661700563753374, 0.20347447969278942, 0.1941205301233091, 0.1825787977869917, 0.18792964060068273, 0.1779675512466098, 0.18936677513112365, 0.1836627187397225, 0.1707261090500548, 0.1806495759531952, 0.17640060799923996, 0.20740569104215256, 0.08767645416697778, 0.07514712175650662, 0.09213826494770894, 0.08450602809124153, 0.07726674873918271, 0.08468424430861266, 0.07005361036870728, 0.0748778633574333, 0.07653188880145678]}, "mutation_prompt": null}
{"id": "b26e5eca-3724-4236-af69-344e9b3e8f06", "solution": "import numpy as np\n\nclass QuantumInspiredChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.25  # increased probability for local search\n        self.dynamic_scale = 0.3  # increased dynamic scale\n        self.chaos_coefficient = 0.6  # slightly adjusted chaos coefficient\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)\n    \n    def quantum_perturbation(self, x):\n        return x + np.random.normal(0, 0.1, size=x.shape)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                # Quantum-inspired perturbation\n                mutant = self.quantum_perturbation(mutant)\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.85 * self.CR[i] + 0.15 * np.random.rand()  # adjusted adaptive adjustment\n                    self.F[i] = 0.85 * self.F[i] + 0.15 * np.random.rand()\n                else:\n                    self.CR[i] = 0.35 * self.CR[i] + 0.65 * np.random.rand()\n                    self.F[i] = 0.35 * self.F[i] + 0.65 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumInspiredChaoticDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Chaotic Perturbation for Enhanced Global Exploration and Local Intensification.", "configspace": "", "generation": 26, "fitness": 0.2192424045971855, "feedback": "The algorithm QuantumInspiredChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.46660180771343973, 0.4867682465493762, 0.5043755780830748, 0.5067900821278489, 0.4875212134346827, 0.49930775351917256, 0.49982721813279063, 0.46688330926145327, 0.4945820231958844, 0.1336661460784011, 0.14233520235542751, 0.1677280824302978, 0.14256816598323496, 0.1395132349225936, 0.11731164002133865, 0.1518524785112495, 0.1392093080297775, 0.1491910847326815, 0.1504941492584705, 0.17120553734309507, 0.13656094435724353, 0.15367059722393006, 0.13821543727614516, 0.1590172067422011, 0.1561040956236297, 0.13775938567332524, 0.14545058515086984, 0.13534043616222968, 0.12580884993886865, 0.12948390626579298, 0.11541887984640142, 0.12516689532282776, 0.14103938163469043, 0.12522478326998898, 0.12226097103481626, 0.11983898973913598, 0.9608693726257461, 0.9449547755850287, 0.9492599056160659, 0.9690969155775766, 0.9260822378429215, 0.9077617857174547, 0.9442062724236566, 0.9294947658232631, 0.9523688635086627, 0.2459798046890036, 0.24830116759348064, 0.2349830030846698, 0.2575551523162465, 0.2577269610437368, 0.26337590198827177, 0.2627342107694701, 0.24001729585049436, 0.2573498863398761, 0.25464518844986384, 0.2761248700307979, 0.303312221925519, 0.2949373339138346, 0.5301982635718174, 0.32580957675635225, 0.2926364866193518, 0.3224534266016029, 0.3171357318968665, 0.1509074663936828, 0.16056635309968914, 0.1478549372826723, 0.16037783774393188, 0.15849635091406578, 0.14295096619247816, 0.15610230236426414, 0.15126277265842603, 0.15847980173820453, 0.1297117687316548, 0.14446654120449898, 0.13908490141392282, 0.1548103924297175, 0.1592923383719662, 0.13899532600595466, 0.12798014387923373, 0.14699708393603228, 0.15296591358708667, 0.008123355171938629, 0.0008062707854975537, 0.001143920618450256, 0.0020617391344327496, 9.999999999998899e-05, 9.999999999998899e-05, 0.01142941969754152, 0.0036136044586397853, 0.0037218526515117034, 0.07445505314273326, 0.0472345324980975, 0.06471252753529166, 0.058587446330650716, 0.05980101624588807, 0.06587560860526809, 0.08797211261771809, 0.09817624356200305, 0.08964036720009994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0035671260857238485, 9.999999999998899e-05, 0.09691972169283603, 0.09118347180609765, 0.09673044301802025, 0.09455324144368993, 0.10437223490965974, 0.10807789303079895, 0.10433237259510131, 0.10700035545991526, 0.09096108039201167, 0.4175138915774481, 0.4092027125199159, 0.4060014235998769, 0.41625289869542226, 0.43739504000217044, 0.4254925923972108, 0.4210362633849558, 0.4372548714799007, 0.42195649708752603, 0.08834651800500848, 0.0966550372021262, 0.09046863014968853, 0.09918715540094913, 0.08918913909463733, 0.09356630466162785, 0.09603992905064773, 0.09266285637786187, 0.12054871623751984, 0.12380455596602047, 0.1437485334897045, 0.12765670487787262, 0.1611241246678684, 0.15245140218493525, 0.1422028267451333, 0.15167848539965545, 0.13361344850267776, 0.15035558670488702, 0.2705134795259755, 0.2864225900626287, 0.25957021491053534, 0.2773405356411338, 0.2839590897421336, 0.2680283512320073, 0.28852596118644747, 0.2869247009745539, 0.29197688515425, 0.20008839006900403, 0.19848590901403673, 0.2007057611579509, 0.18623702765070071, 0.20091070561625313, 0.2046461901531479, 0.21808695881108353, 0.21031639039738637, 0.21868993708416073, 0.1854439015538515, 0.17910882594415345, 0.1863202235454936, 0.20678458463900506, 0.19438957022699244, 0.18938624351757005, 0.1894976958167367, 0.1846333446757068, 0.19765530159097178, 0.19455436215431388, 0.21259860355092908, 0.19702266660670553, 0.20037070884176422, 0.21267390691455834, 0.2049998462723278, 0.2073260972129909, 0.2093802294160576, 0.22277997955719286, 0.3461948229272118, 0.5581551420939543, 0.3696700417567885, 0.1733254727490675, 0.26921919435831154, 0.29910762786043565, 0.44991807280179597, 0.3494810343555229, 0.2045421510679999, 0.19839951012838952, 0.196630402508024, 0.2568496157906379, 0.19930201416559878, 0.19700402700031205, 0.19235548845196715, 0.20560988810222902, 0.20800989793611535, 0.3558405487002133, 0.183856862984203, 0.19599762389114128, 0.18145149747145983, 0.18323497365448627, 0.18584871604696196, 0.17811990074340378, 0.17840241293440195, 0.18280539711597743, 0.18906659328828823, 0.0694306225039849, 0.07880849384326016, 0.07882952920402664, 0.07777461329209168, 0.0743372977948733, 0.07776678713457896, 0.07495340591084809, 0.07727083450779115, 0.07620636828664062]}, "mutation_prompt": null}
{"id": "97c5e186-4ca1-40d4-b8ec-7b49af853830", "solution": "import numpy as np\n\nclass ChaoticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.3  # increased probability for local search\n        self.dynamic_scale = 0.3  # adjusted dynamic scale for mutation\n        self.chaos_coefficient = 0.85  # enhanced chaos coefficient for perturbation\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * local_best\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.7 * self.CR[i] + 0.3 * np.random.rand()\n                    self.F[i] = 0.7 * self.F[i] + 0.3 * np.random.rand()\n                else:\n                    self.CR[i] = 0.5 * self.CR[i] + 0.5 * np.random.rand()\n                    self.F[i] = 0.5 * self.F[i] + 0.5 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ChaoticAdaptiveDE", "description": "Chaotic Adaptive Differential Evolution with Enhanced Diversity Preservation and Dynamic Intensification for Robust Convergence.", "configspace": "", "generation": 27, "fitness": 0.37122099146180065, "feedback": "The algorithm ChaoticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8685418669865048, 0.8631095782979454, 0.8669748956144269, 0.8696005789993916, 0.861726309359552, 0.8584615602253174, 0.8664877095166552, 0.8590585417498396, 0.8645742462112033, 0.7460564166969652, 0.741740303737922, 0.752242598044111, 0.7569624428885441, 0.7543845834430648, 0.7396371334567708, 0.7326190121894356, 0.7511946085996617, 0.7537308906405911, 0.3615283427937336, 0.4401071723361045, 0.42991770548415076, 0.4602736278437296, 0.3931114753767463, 0.43919113470102633, 0.39913917448020053, 0.4125558412715583, 0.42835088940925814, 0.14301714247275688, 0.16398118687063945, 0.28336012583232506, 0.16309609018017468, 0.1597715075738546, 0.16328138212576382, 0.28460757223748445, 0.3745489719633036, 0.1587504753500254, 0.9125179542744948, 0.9202789468959575, 0.928788532414649, 0.9259428363932855, 0.945269169119281, 0.9269061472687291, 0.920980515748126, 0.9193408326727208, 0.9451241412045466, 0.3900619474581668, 0.5458979762810912, 0.5130671316846287, 0.5784124569014142, 0.561907807348673, 0.5742422775426566, 0.3894549264824273, 0.4853313420450789, 0.4673607908980154, 0.7377115265490699, 0.7350075974874287, 0.7374732301051461, 0.8202175908247283, 0.6515291803414722, 0.5010218411635632, 0.23775299021806362, 0.8049055860797091, 0.7638730712037833, 0.18245141346734783, 0.20331921465731362, 0.27161399422730914, 0.1808734396949866, 0.1675691237745094, 0.21767548571155249, 0.26991586520859456, 0.12819365851421682, 0.17501564253871016, 0.23109981746002084, 0.1962012982525434, 0.16105342758836705, 0.15331434596074378, 0.19125829697418162, 0.17664501549428002, 0.15494345656486674, 0.15406082415463174, 0.14019074884417282, 0.12011622498200358, 0.09303238183766427, 0.06288859906406508, 0.0667836947139846, 0.05579672885615106, 0.07508814636008487, 0.09620475487777747, 0.0438572833426617, 0.15733681954812528, 0.22488676392813722, 0.24374622379377175, 0.3014576190200311, 0.1630318530999888, 0.2677273756312464, 0.13278899044696468, 0.25667309755913836, 0.26311464667478546, 0.2973615004238158, 0.08202351587376744, 0.11185061970652255, 0.14698446219523342, 0.08675583260105979, 0.08691844686470218, 0.09111183872925088, 0.08281742939930392, 0.1553402897824182, 0.13575830353661966, 0.24010538124688752, 0.18135250476122644, 0.12029170292200908, 0.24845602694621916, 0.22062584334195212, 0.25711738663714867, 0.13575750066909076, 0.19672119709873614, 0.18210312299569398, 0.6435550507530727, 0.6098218385452453, 0.6369862498570902, 0.5567613885460869, 0.5795616844064428, 0.521936232351179, 0.6472210275509579, 0.617066745473598, 0.6146105677369493, 0.12404508749918952, 0.11263423062490552, 0.12047202334640372, 0.11297129334056077, 0.11423928895315727, 0.10501810156096303, 0.1245715661974871, 0.10539065522243907, 0.13716528038365539, 0.13054898275858517, 0.16523168850438275, 0.13836196315454186, 0.1765125232189645, 0.14337042970756997, 0.151789378147698, 0.1487679691489604, 0.1431484277030961, 0.15416638711837716, 0.401344093496924, 0.45193632181736454, 0.440609083195184, 0.40781247576324997, 0.45182676542255273, 0.496868361471435, 0.4961984287181843, 0.5333512149503332, 0.5576274067099265, 0.2945237193091863, 0.3001331061690301, 0.26747507711864826, 0.30357663059791573, 0.3042289740594174, 0.33429694803514054, 0.2826997095039485, 0.27191835377884344, 0.3953897818946439, 0.21507869563513493, 0.2318793901785805, 0.20830038786953686, 0.20333838669560467, 0.23236890725202564, 0.20633179898496956, 0.2120281143000795, 0.2128934588935799, 0.196153800945422, 0.3075232386496535, 0.50647670881494, 0.2142686413972832, 0.22804333135118737, 0.27824831344431955, 0.4862076714897854, 0.29307175667731866, 0.23433321125771644, 0.4742886371960887, 0.18033497870555915, 0.1848204262888744, 0.18329728858557948, 0.8215825554777016, 0.811148711603392, 0.8491834865364163, 0.8675623313826945, 0.19441033753853754, 0.7304254768589677, 0.7427736922174613, 0.6351806711558381, 0.381023491570908, 0.7256561440039945, 0.16690279069502834, 0.6655328438886565, 0.7554235348421228, 0.731292125779118, 0.31167240357846526, 0.18171819093933628, 0.1778066939857479, 0.17710306412944754, 0.18607467468985106, 0.18064001909541605, 0.17712752663223108, 0.18252127067286283, 0.19299311399271013, 0.1958292926346944, 0.0901112547942936, 0.08133843037888977, 0.0862569535055967, 0.08511008017766997, 0.08502069793158806, 0.1035869672683899, 0.08482885881085733, 0.0822643641604911, 0.08115182625859851]}, "mutation_prompt": null}
{"id": "fc18c3e2-bdb8-43ea-87e2-e97361f7fb5a", "solution": "import numpy as np\n\nclass StochasticAdaptiveChaoticQDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.25\n        self.dynamic_scale = 0.3\n        self.chaos_coefficient = 0.8\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def quantum_mutation(self, position):\n        return position + np.random.normal(0, 1, self.dim)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                if np.random.rand() < 0.2:\n                    mutant = self.quantum_mutation(mutant)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.5 * self.CR[i] + 0.5 * np.random.rand()\n                    self.F[i] = 0.5 * self.F[i] + 0.5 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticAdaptiveChaoticQDE", "description": "Stochastic Adaptive DE with Chaotic and Quantum Mutation for Enhanced Exploration and Convergence.", "configspace": "", "generation": 28, "fitness": 0.3502462353115796, "feedback": "The algorithm StochasticAdaptiveChaoticQDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8428073560417663, 0.8517455596701107, 0.860248876534789, 0.8357188870044537, 0.8407734820392655, 0.8500199933900467, 0.8452208843540667, 0.8433761755048621, 0.8472524748035811, 0.6850562742930568, 0.7218412353504897, 0.7124809343268284, 0.6932096621407079, 0.7003526930197138, 0.7188549951330095, 0.6897073081874108, 0.7002921188770204, 0.7092073220133864, 0.3927747311885007, 0.30209918074867403, 0.361383391913476, 0.36626348593223756, 0.3254957969851485, 0.3291736805582578, 0.42148301622928963, 0.3076274512625733, 0.2993346152128499, 0.2800458527456543, 0.2427476352471768, 0.317669231274484, 0.16363334968282728, 0.2629032561442396, 0.1546287241646176, 0.2266399490196851, 0.170929123188027, 0.15432129512450554, 0.9447730277800588, 0.9438761010149153, 0.9356774430578911, 0.9519370465473197, 0.918806940952841, 0.9487541547637777, 0.9478788309533622, 0.9539192518014012, 0.9733007511516193, 0.42984018063012164, 0.42297952870116884, 0.44093585668904833, 0.43938482781683974, 0.4833132227484086, 0.3909362270516761, 0.38221963298454165, 0.4617102600568729, 0.38436561214384535, 0.6920521472436191, 0.7866376824959025, 0.6848078473627186, 0.6228077619996315, 0.7394566183674561, 0.8391684546083253, 0.6344452476358233, 0.7954070086614876, 0.7104652703445318, 0.19278776905209738, 0.19264310070282542, 0.30116103119448345, 0.2147971933904167, 0.24042880034045722, 0.18889587912935069, 0.18403611765914596, 0.2072107345856341, 0.17354322211262718, 0.17062828132051688, 0.15172374865192562, 0.17465738571469724, 0.15545895803987753, 0.15836872925643386, 0.229575514520152, 0.1718755506711961, 0.17356824246278724, 0.19215099527960056, 0.07467855762878806, 0.08381248962292298, 0.07931573798249014, 0.05219414637026054, 0.06824255022741321, 0.07072761177616671, 0.04813172773631791, 0.09373662063102506, 0.06638396904289134, 0.2016902347528613, 0.14067671071732257, 0.1313439814423054, 0.18418471981084095, 0.19868687109026373, 0.16518199256126298, 0.17746889740781957, 0.2620916346047951, 0.20349768635488463, 0.12952108980060462, 0.0796389277103654, 0.11725398956152144, 0.09195749821488808, 0.09291465235492391, 0.12236058127879934, 0.12275625717169547, 0.11986783114132304, 0.10537521581396891, 0.1420775706448607, 0.17421499296097043, 0.20675091131268208, 0.19538319459696196, 0.24273916813665997, 0.20196509181286193, 0.17037686100704852, 0.18210651127356003, 0.15086881188256507, 0.6064928383363396, 0.6034720361184311, 0.5722128936033258, 0.5921681910728177, 0.5765956041430589, 0.5779601348786706, 0.5888780887649457, 0.6153785980042961, 0.6039292580945066, 0.10484740295419726, 0.11728109052202706, 0.11365205798421718, 0.14169806770652216, 0.10944459708068155, 0.10347493525891571, 0.09902971101759084, 0.10397567589707502, 0.11091321489210981, 0.15986722958518496, 0.13421780741500677, 0.1492994988983457, 0.1319711862659746, 0.1354649364618712, 0.1673764358051434, 0.13562154431105378, 0.1487438807382705, 0.15998381439060683, 0.39511134950664584, 0.4446088321870476, 0.4283985409311887, 0.43333859479424686, 0.44158440485826134, 0.42450729770191387, 0.44070693994876686, 0.5336768160960186, 0.49909300005481705, 0.29861569563395474, 0.2705699043966404, 0.2890492603710302, 0.28325855422180557, 0.3091039445532717, 0.2745098882929268, 0.2758087698728686, 0.2937369456849126, 0.34484595898246073, 0.22865842200241138, 0.23563400965756942, 0.22179747756232104, 0.21112522081081675, 0.20773733289897367, 0.22133257743744073, 0.20090056191801153, 0.19380323228490748, 0.22271940739296603, 0.343049779992339, 0.3890057103044239, 0.23909879181529226, 0.22285111300645066, 0.40897795047897434, 0.23592764596813476, 0.19458569243841328, 0.5196071508934628, 0.2099900931688614, 0.4789837278438249, 0.17241611488666564, 0.1597133073915138, 0.8228702914489835, 0.6825680492035517, 0.6764478307703957, 0.6021744867218586, 0.17447635948308304, 0.7988740037507938, 0.45628547487756843, 0.4467910145836479, 0.7129307719108047, 0.20859320837106, 0.20164209164014424, 0.19978485109453747, 0.2102822445063548, 0.32326147844861475, 0.3958864972188122, 0.19541172173824206, 0.18508664996277058, 0.19659462000771255, 0.24375894700212375, 0.1932529044125596, 0.19915338733613086, 0.18144208028757625, 0.19342757583030146, 0.19671738049864862, 0.09279169149562772, 0.08938026453477288, 0.07209164713811389, 0.08267763962905061, 0.08353120521533597, 0.08702052949230399, 0.10242833032485454, 0.08054307255837356, 0.09175429196963236]}, "mutation_prompt": null}
{"id": "413ae404-3a0a-46de-ba74-22c344e7f405", "solution": "import numpy as np\n\nclass HybridQuantumInspiredChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # adjusted crossover rate range\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # adjusted scaling factor range\n        self.local_intensification = 0.25  # adjusted probability for local search\n        self.dynamic_scale = 0.3  # adjusted dynamic scale\n        self.chaos_coefficient = 0.85  # increased chaos coefficient\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def quantum_grover_mutation(self, individual, best):\n        theta = np.arccos(individual / np.linalg.norm(individual))\n        new_theta = theta + np.random.uniform(-np.pi, np.pi, size=individual.shape)\n        return best + np.linalg.norm(best) * np.cos(new_theta)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = self.quantum_grover_mutation(mutant, local_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.7 * self.CR[i] + 0.3 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.7 * self.F[i] + 0.3 * np.random.rand()\n                else:\n                    self.CR[i] = 0.5 * self.CR[i] + 0.5 * np.random.rand()\n                    self.F[i] = 0.5 * self.F[i] + 0.5 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridQuantumInspiredChaoticDE", "description": "Hybrid Quantum-Inspired Chaotic Differential Evolution with Adaptive Mutation and Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 29, "fitness": 0.25176320973937677, "feedback": "The algorithm HybridQuantumInspiredChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.7273817678903882, 0.7350615114443956, 0.7328122258406411, 0.7371577226363333, 0.7322530878967921, 0.7325720855432318, 0.7652479034588812, 0.7347832285568867, 0.7166028292744367, 0.5007991787856675, 0.5072635817085108, 0.5289387296573046, 0.5118195249377839, 0.503462349788881, 0.5174458178505181, 0.5088783191947397, 0.4997785333578064, 0.5130192555272726, 0.1456180716550054, 0.14889597964104107, 0.18121273788221592, 0.14927713026060319, 0.1562046000386199, 0.17132097048442996, 0.20372643876098218, 0.24598892757420276, 0.15911532083756852, 0.13632732871417497, 0.12600659949678084, 0.14539962252220628, 0.14910409446124195, 0.12698321957623282, 0.13333498881508643, 0.11954733156870712, 0.12906560710732284, 0.13028977280714227, 0.9768485531952862, 0.972142878827826, 0.9791553461282707, 0.9760416802204118, 0.953056846772839, 0.978925780539707, 0.9773043146536867, 0.9923167237939998, 0.9556651142333854, 0.25571834336973087, 0.26930217444063487, 0.2364684677567861, 0.2844345419273362, 0.2631268152309585, 0.2906447281770651, 0.2835228031487371, 0.25291805668919787, 0.27501716229158724, 0.24128368789508592, 0.25969232375104667, 0.26336925339691775, 0.4298567442558555, 0.2190035630485182, 0.5132693276167823, 0.41660960382690504, 0.273590832709352, 0.44403418646715553, 0.15390208431203267, 0.15933581481812398, 0.1639886560520103, 0.1592294935109665, 0.13353139612294795, 0.13685712213604528, 0.15242629682345665, 0.1739499000250666, 0.1575767642870327, 0.17396625844109836, 0.15684250029994218, 0.14037692158095938, 0.16148093576760525, 0.15964675027293995, 0.1765760721873807, 0.15153303151027753, 0.15463064042841546, 0.1409506676911364, 0.02564379510678505, 0.017222072290828727, 0.003855667202777857, 0.013967836203967798, 0.011696183600920063, 0.022268733647029193, 0.01694480116557684, 0.008315188884735703, 0.0015363098955781807, 0.12238871141232321, 0.12675153847755483, 0.10234716867210814, 0.10700021011271332, 0.11050984432576882, 0.07802580464487141, 0.11665348922095276, 0.15509329962577412, 0.11930192437440001, 0.01184278906392866, 9.999999999998899e-05, 0.01917278282582724, 0.017915232409962845, 0.0015950410999675535, 0.0004715750816056685, 0.012410926117604304, 0.01742548771021013, 0.01870461433769466, 0.11431231131717301, 0.0926343142397098, 0.10687639092679269, 0.12380363528635896, 0.11133108918819057, 0.13847759933457127, 0.10941996740313131, 0.09648318894064245, 0.09813912007984704, 0.46157968283396045, 0.46440160127782026, 0.47998806406780115, 0.4623169183839051, 0.4779454140709015, 0.461753209125368, 0.4892695415135795, 0.4651170605479451, 0.4782873785469828, 0.08836591112112313, 0.08508729174225482, 0.08478476096744325, 0.10358379606244505, 0.08914673922526761, 0.08447418722037892, 0.08857991675848154, 0.08892162491730304, 0.09007703810107637, 0.15110907481604374, 0.16200872386596643, 0.1559378200354148, 0.16768849200387304, 0.13099779236095332, 0.13698190644893438, 0.13421710354614735, 0.13612518283380215, 0.13921491468814606, 0.3251016804084199, 0.2739451214987857, 0.30887652973614355, 0.29118395078309656, 0.3046332927366677, 0.2809055714533891, 0.3212890466983921, 0.30254983708993055, 0.3276129976100497, 0.1914619047353695, 0.19635381959534448, 0.20344984862947457, 0.18537007173625852, 0.16941282978118166, 0.15853364017112492, 0.1887169317839822, 0.21908977097757276, 0.2058202915279974, 0.19628507819190988, 0.18133871283359004, 0.19163337685088422, 0.19685255616005493, 0.21335159158865713, 0.1951206904900985, 0.195706741862812, 0.19372053417474622, 0.2049255227667227, 0.20584424335979767, 0.21002655866834452, 0.20412431848664803, 0.20723887883619174, 0.212776603886768, 0.2054768000932211, 0.2093428533429259, 0.21145745873387067, 0.21773154648949744, 0.33364429593431855, 0.41025353045864676, 0.16343252874544123, 0.1645000629480694, 0.29926750418567616, 0.23042784955179652, 0.15963866988176434, 0.21637217387713814, 0.27798737875727, 0.21118353204652773, 0.15714382689387585, 0.18700613809037936, 0.27109480073838355, 0.18969566211552424, 0.2976258072054435, 0.3283456750766196, 0.20169344094859998, 0.20518589238467033, 0.1868626804168465, 0.19335388131410913, 0.18485488856518162, 0.1965918300632803, 0.1927787403638881, 0.17559740161101833, 0.18384886140860413, 0.18046682862402708, 0.17981081469109395, 0.07422982983488602, 0.08257986618104773, 0.0825140361515645, 0.07067507542247864, 0.07431799528232674, 0.0723356853302286, 0.0718851029000056, 0.073894255387701, 0.08107820904929153]}, "mutation_prompt": null}
{"id": "0a3d806d-f3bf-41fd-bd67-4b56360670d7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.2  # modified probability for local search\n        self.dynamic_scale = 0.25  # modified dynamic scale\n        self.chaos_coefficient = 0.7  # adjusted chaos coefficient\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.4 * self.CR[i] + 0.6 * np.random.rand()\n                    self.F[i] = 0.4 * self.F[i] + 0.6 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Chaotic Perturbation and Novel Mutation Strategy for Improved Diversity and Convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8642587286426702, 0.8609406490132158, 0.8728120986088378, 0.8681121240218025, 0.8629746384343402, 0.8634032037495901, 0.8595516975032913, 0.8574960091459829, 0.855462258412699, 0.736407306176335, 0.7500851045774101, 0.7445156499699622, 0.7603146841578602, 0.7314780778658387, 0.7435820993287903, 0.7344521890619385, 0.7323818436870567, 0.76038897495266, 0.4369637534117452, 0.4381576818601155, 0.43872001080120737, 0.4596818627196516, 0.48768630499778287, 0.16784913995853024, 0.4156773397657473, 0.5223554503745265, 0.440537554868219, 0.25794651127649204, 0.15311891545191847, 0.35623533132719953, 0.16010567377639617, 0.1579060078694714, 0.15817078399632212, 0.2889948146184663, 0.17171352443201993, 0.3952359530911187, 0.9207832713044425, 0.9539878575430775, 0.9663082305887337, 0.9316004974144727, 0.9309389232054249, 0.9628149526563502, 0.9570517648775765, 0.9431365867057501, 0.9513908935588261, 0.5270950244553669, 0.5087913948183946, 0.566276233469839, 0.5458894020584917, 0.5428972957080621, 0.5459884286328714, 0.4651415324538595, 0.4087930595137841, 0.4514859229570578, 0.7581598782772099, 0.7279619416912725, 0.21932550772528736, 0.8267670423887477, 0.7958240893876926, 0.7208376114730333, 0.6738457508856177, 0.7631088627442554, 0.7562115003604728, 0.1768681149640271, 0.1651719122494385, 0.17494609879137424, 0.1696374664710838, 0.16269592772866692, 0.1794613954029195, 0.1850620238492685, 0.23164049606178783, 0.16419276164748464, 0.19174775050019643, 0.14977699447468262, 0.14462675563402538, 0.18788857123489433, 0.17504617970622272, 0.17902533024333478, 0.17171321723563415, 0.17177166226070517, 0.13910531537135518, 0.10919775428684975, 0.06833647632499373, 0.08963455676467569, 0.1663664898542644, 0.06833451495816256, 0.07858745662230793, 0.12235936601916897, 0.15647569415572438, 0.07220850623507413, 0.2540285883843234, 0.29246589129783507, 0.2975967878514134, 0.20224993414383452, 0.26759536261074535, 0.21408936923586697, 0.32126464056633985, 0.31503395147019286, 0.3282976814337638, 0.09213023569034628, 0.08087871391830326, 0.11815008669688343, 0.08593161218996215, 0.16119172630658163, 0.16488452679609278, 0.07631024367344053, 0.1379124214596089, 0.14594438905710416, 0.1574415272608567, 0.20073868669669226, 0.20052949662794228, 0.24708264975599314, 0.27395534569097035, 0.26834777327511294, 0.23351786975646804, 0.15379770525462577, 0.2188108178262953, 0.6169813556927457, 0.6015301658348291, 0.6031188234819327, 0.6213732949642775, 0.6244523381402938, 0.6161058836067006, 0.6395791462367733, 0.6119576201936823, 0.6064445325266203, 0.10923409408382267, 0.11066539030053046, 0.12228735459633333, 0.1347363212609184, 0.1216972418138812, 0.11337772460052697, 0.11832808561599106, 0.11468855930828015, 0.10940118903350449, 0.12897711475092855, 0.13647349110250284, 0.14862928588230084, 0.1514605172650184, 0.15687395998772247, 0.16234563043613448, 0.16747790980138122, 0.15214753933752256, 0.11954674378315322, 0.44820700694137827, 0.46425560068195504, 0.45397799967520425, 0.4709118716857894, 0.42786787991147834, 0.47437366981269147, 0.561103992938048, 0.5016084219406233, 0.5459592336906501, 0.3298720050424384, 0.3227001439271786, 0.3216501459342145, 0.22331394970286178, 0.29638254617884263, 0.22206296010595483, 0.36537362363423, 0.35192194567534274, 0.38744851440843975, 0.2215590218356751, 0.19777628041230877, 0.21001458844401955, 0.2188595895062766, 0.22671462551996813, 0.21643816782960834, 0.20113713702500768, 0.19627291417262172, 0.2389488620616813, 0.23278855819161137, 0.47944435705039157, 0.47077617675359584, 0.281778275792426, 0.39812011626043387, 0.2689059253080168, 0.5039209064353017, 0.2346549864300591, 0.4696505300946161, 0.8144139527255649, 0.17987024001637386, 0.19097467172587268, 0.8227066033900299, 0.8260594890483264, 0.7301274103247045, 0.8266331223194627, 0.4328264673478277, 0.7218065354909698, 0.7502819398478842, 0.6549643156297577, 0.6649848369663592, 0.5534946647299477, 0.16684099748643244, 0.20226237882359133, 0.6527998439729179, 0.20806352736600198, 0.6019828559164369, 0.17395417724362028, 0.1865946654761489, 0.18697260155194928, 0.2198908097802038, 0.18413999878564147, 0.19757354245823666, 0.19095333595723452, 0.1828839488225612, 0.19116076093601908, 0.08509600550091201, 0.08136724543065577, 0.07883230139764275, 0.09359053919228788, 0.08324640183872567, 0.08778348891960575, 0.08594887824644992, 0.08526309813303956, 0.08634842094701634]}, "mutation_prompt": null}
{"id": "49b76204-7ebf-4baf-92ff-28319d5a4d37", "solution": "import numpy as np\n\nclass DynamicMemeticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.25  # modified probability for local search\n        self.dynamic_scale = 0.3  # modified dynamic scale\n        self.chaos_coefficient = 0.75  # adjusted chaos coefficient\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * np.random.randn()\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.9 * self.CR[i] + 0.1 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.9 * self.F[i] + 0.1 * np.random.rand()\n                else:\n                    self.CR[i] = 0.5 * self.CR[i] + 0.5 * np.random.rand()\n                    self.F[i] = 0.5 * self.F[i] + 0.5 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DynamicMemeticDE", "description": "Dynamic Memetic Differential Evolution with Stochastic Adaptation and Chaos-enhanced Mutation for Improved Global Exploration and Local Exploitation.", "configspace": "", "generation": 31, "fitness": 0.3743523415501802, "feedback": "The algorithm DynamicMemeticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8662933026949649, 0.8555106646213918, 0.8616490979634968, 0.8695386498648341, 0.8670549563273506, 0.8654636236730779, 0.8640795065947376, 0.860926909108705, 0.8631825559619725, 0.7283929933257043, 0.7358102450434834, 0.7274140095305311, 0.7551824928856927, 0.7365564232391725, 0.7397223640139732, 0.7353696483897338, 0.7355767023272097, 0.7494704370895293, 0.49099959992713793, 0.5416861558375885, 0.46978703581070147, 0.4733293653691564, 0.5102259523150079, 0.4977672302314823, 0.48124497986405324, 0.42000978438026715, 0.5517042475708964, 0.16326991137732205, 0.16163908369836355, 0.3006316939680943, 0.16385044788618486, 0.3484008932840844, 0.14185128903669464, 0.41455063064436404, 0.34103242163520864, 0.25900854116880223, 0.9635957011488511, 0.9072069441462672, 0.9264206623197239, 0.9332980815450291, 0.9520326726884892, 0.9168902334806859, 0.9394340461342596, 0.9557673041764473, 0.9344380606560223, 0.49452534847662033, 0.5100096604597634, 0.3345767357163568, 0.5825793929923444, 0.5197619252545425, 0.5657349184988849, 0.43049714459779287, 0.4147099639862082, 0.4294461142047934, 0.6967972835920531, 0.679517738772464, 0.7034299900429304, 0.7134896691615231, 0.766385300367879, 0.724216555402952, 0.23491164732264735, 0.8153118163007387, 0.7367058369304711, 0.19143437989122436, 0.17017740097317224, 0.17118930810947441, 0.18727263529322014, 0.17959353971776615, 0.16687156080864718, 0.19771916905788722, 0.2074404328374163, 0.17585005397628506, 0.16599738910603679, 0.14142524467249118, 0.22298931386448095, 0.19780223409260733, 0.23131451654382051, 0.189563417796622, 0.17793078801816264, 0.17300277038277823, 0.14940898798750568, 0.06033144640069821, 0.11250479589518814, 0.08638917646733679, 0.10852102758549897, 0.11730248067786908, 0.07735524972895402, 0.13844658975745572, 0.08235898825307375, 0.1087143357188074, 0.24100526571251835, 0.276685856934647, 0.26211911365376694, 0.191698086599288, 0.1451638281235903, 0.17338486806051445, 0.27383325527031277, 0.22322607065134825, 0.2748632996102156, 0.08565020596821449, 0.09418605656588419, 0.1057191158999029, 0.08001863257073216, 0.1356072418171661, 0.10179914983979432, 0.11821048007297064, 0.12042355935658744, 0.12251053227691955, 0.17538723055570904, 0.2211565284671081, 0.2333612760595406, 0.22756060662966449, 0.20270144084646702, 0.24577724294802983, 0.17821248984022553, 0.20801672241430824, 0.15027444630766007, 0.6157017012693635, 0.5734998251788183, 0.5882314981738802, 0.6143713082325634, 0.5919602150039168, 0.624666557748026, 0.5931433448834214, 0.6060026352355645, 0.6214191948535723, 0.11146772871641009, 0.10501611397136768, 0.10434193376986844, 0.10767660442971361, 0.10710916085164335, 0.1351714877800574, 0.13163031523858704, 0.10865403839403898, 0.13564793064675273, 0.13677667196994103, 0.13585530768114584, 0.1389858774414119, 0.15485041843330605, 0.14281076621261768, 0.17647794260975302, 0.1259727969802774, 0.16061017060894645, 0.2433526773205673, 0.45079882674210925, 0.4451937592112788, 0.45113804630867493, 0.4265607046797122, 0.41613968110656685, 0.4658258408351862, 0.46386963437708906, 0.4998876990012656, 0.5100969241042185, 0.31806638952485444, 0.26398241316743165, 0.3018815322213515, 0.29307203187315234, 0.2953968167901838, 0.3010017776079016, 0.2555347506821941, 0.3538367400174437, 0.35792127086043, 0.2537040161108566, 0.19580147289734195, 0.23124137046169702, 0.21810046297332097, 0.1937602109425417, 0.2172531892537164, 0.21389496202190939, 0.21537833818168872, 0.21569586751400227, 0.47072212316524187, 0.4218548644838438, 0.4165538256149235, 0.503307549921318, 0.547040132921877, 0.4025564411009406, 0.4300932192937973, 0.4381402122035414, 0.36809904334329135, 0.18129477592433685, 0.18832109701929123, 0.1768750031612668, 0.8233192579065456, 0.8297634330102104, 0.8290390606270762, 0.7941256741394114, 0.6975969106842004, 0.7886171971119401, 0.6081756761076764, 0.2061469395708243, 0.5301561147549025, 0.5308359855672742, 0.16708715100147142, 0.4313020138561271, 0.13462716410121633, 0.21126945035578493, 0.5995190520419653, 0.1817124372667258, 0.17595932646626788, 0.182008856572355, 0.1838949577766279, 0.18704449578182547, 0.18357592845572324, 0.18547537047542895, 0.1689682705666341, 0.17766178308077374, 0.11617246448518004, 0.08111195834349039, 0.09672288257077377, 0.08352547436512325, 0.0897709236663985, 0.08264390414044087, 0.08544130837987629, 0.0822126234190026, 0.08599005522704517]}, "mutation_prompt": null}
{"id": "b117a714-afec-49dc-8d90-9e9f226fde94", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.2  # modified probability for local search\n        self.dynamic_scale = 0.25  # modified dynamic scale\n        self.chaos_coefficient = 0.7  # adjusted chaos coefficient\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.4 * self.CR[i] + 0.6 * np.random.rand()\n                    self.F[i] = 0.4 * self.F[i] + 0.6 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Chaotic Perturbation and Novel Mutation Strategy for Improved Diversity and Convergence.", "configspace": "", "generation": 24, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8642587286426702, 0.8609406490132158, 0.8728120986088378, 0.8681121240218025, 0.8629746384343402, 0.8634032037495901, 0.8595516975032913, 0.8574960091459829, 0.855462258412699, 0.736407306176335, 0.7500851045774101, 0.7445156499699622, 0.7603146841578602, 0.7314780778658387, 0.7435820993287903, 0.7344521890619385, 0.7323818436870567, 0.76038897495266, 0.4369637534117452, 0.4381576818601155, 0.43872001080120737, 0.4596818627196516, 0.48768630499778287, 0.16784913995853024, 0.4156773397657473, 0.5223554503745265, 0.440537554868219, 0.25794651127649204, 0.15311891545191847, 0.35623533132719953, 0.16010567377639617, 0.1579060078694714, 0.15817078399632212, 0.2889948146184663, 0.17171352443201993, 0.3952359530911187, 0.9207832713044425, 0.9539878575430775, 0.9663082305887337, 0.9316004974144727, 0.9309389232054249, 0.9628149526563502, 0.9570517648775765, 0.9431365867057501, 0.9513908935588261, 0.5270950244553669, 0.5087913948183946, 0.566276233469839, 0.5458894020584917, 0.5428972957080621, 0.5459884286328714, 0.4651415324538595, 0.4087930595137841, 0.4514859229570578, 0.7581598782772099, 0.7279619416912725, 0.21932550772528736, 0.8267670423887477, 0.7958240893876926, 0.7208376114730333, 0.6738457508856177, 0.7631088627442554, 0.7562115003604728, 0.1768681149640271, 0.1651719122494385, 0.17494609879137424, 0.1696374664710838, 0.16269592772866692, 0.1794613954029195, 0.1850620238492685, 0.23164049606178783, 0.16419276164748464, 0.19174775050019643, 0.14977699447468262, 0.14462675563402538, 0.18788857123489433, 0.17504617970622272, 0.17902533024333478, 0.17171321723563415, 0.17177166226070517, 0.13910531537135518, 0.10919775428684975, 0.06833647632499373, 0.08963455676467569, 0.1663664898542644, 0.06833451495816256, 0.07858745662230793, 0.12235936601916897, 0.15647569415572438, 0.07220850623507413, 0.2540285883843234, 0.29246589129783507, 0.2975967878514134, 0.20224993414383452, 0.26759536261074535, 0.21408936923586697, 0.32126464056633985, 0.31503395147019286, 0.3282976814337638, 0.09213023569034628, 0.08087871391830326, 0.11815008669688343, 0.08593161218996215, 0.16119172630658163, 0.16488452679609278, 0.07631024367344053, 0.1379124214596089, 0.14594438905710416, 0.1574415272608567, 0.20073868669669226, 0.20052949662794228, 0.24708264975599314, 0.27395534569097035, 0.26834777327511294, 0.23351786975646804, 0.15379770525462577, 0.2188108178262953, 0.6169813556927457, 0.6015301658348291, 0.6031188234819327, 0.6213732949642775, 0.6244523381402938, 0.6161058836067006, 0.6395791462367733, 0.6119576201936823, 0.6064445325266203, 0.10923409408382267, 0.11066539030053046, 0.12228735459633333, 0.1347363212609184, 0.1216972418138812, 0.11337772460052697, 0.11832808561599106, 0.11468855930828015, 0.10940118903350449, 0.12897711475092855, 0.13647349110250284, 0.14862928588230084, 0.1514605172650184, 0.15687395998772247, 0.16234563043613448, 0.16747790980138122, 0.15214753933752256, 0.11954674378315322, 0.44820700694137827, 0.46425560068195504, 0.45397799967520425, 0.4709118716857894, 0.42786787991147834, 0.47437366981269147, 0.561103992938048, 0.5016084219406233, 0.5459592336906501, 0.3298720050424384, 0.3227001439271786, 0.3216501459342145, 0.22331394970286178, 0.29638254617884263, 0.22206296010595483, 0.36537362363423, 0.35192194567534274, 0.38744851440843975, 0.2215590218356751, 0.19777628041230877, 0.21001458844401955, 0.2188595895062766, 0.22671462551996813, 0.21643816782960834, 0.20113713702500768, 0.19627291417262172, 0.2389488620616813, 0.23278855819161137, 0.47944435705039157, 0.47077617675359584, 0.281778275792426, 0.39812011626043387, 0.2689059253080168, 0.5039209064353017, 0.2346549864300591, 0.4696505300946161, 0.8144139527255649, 0.17987024001637386, 0.19097467172587268, 0.8227066033900299, 0.8260594890483264, 0.7301274103247045, 0.8266331223194627, 0.4328264673478277, 0.7218065354909698, 0.7502819398478842, 0.6549643156297577, 0.6649848369663592, 0.5534946647299477, 0.16684099748643244, 0.20226237882359133, 0.6527998439729179, 0.20806352736600198, 0.6019828559164369, 0.17395417724362028, 0.1865946654761489, 0.18697260155194928, 0.2198908097802038, 0.18413999878564147, 0.19757354245823666, 0.19095333595723452, 0.1828839488225612, 0.19116076093601908, 0.08509600550091201, 0.08136724543065577, 0.07883230139764275, 0.09359053919228788, 0.08324640183872567, 0.08778348891960575, 0.08594887824644992, 0.08526309813303956, 0.08634842094701634]}, "mutation_prompt": null}
{"id": "ff7a9015-1e1d-426d-95e5-6772dda2b7a7", "solution": "import numpy as np\n\nclass AdvancedChaoticDEwithMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.memory = np.zeros((self.pop_size, dim))  # Memory for adaptive learning\n        self.local_intensification = 0.25  # modified probability for local search\n        self.dynamic_scale = 0.3  # modified dynamic scale\n        self.chaos_coefficient = 0.68  # adjusted chaos coefficient\n    \n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n    \n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with adaptive memory influence\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c]) + 0.1 * self.memory[i]\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory[i] = self.population[i] - trial  # Update memory with successful perturbation\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = 0.8 * self.CR[i] + 0.2 * np.random.rand()  # modified adaptive adjustment\n                    self.F[i] = 0.8 * self.F[i] + 0.2 * np.random.rand()\n                else:\n                    self.CR[i] = 0.4 * self.CR[i] + 0.6 * np.random.rand()\n                    self.F[i] = 0.4 * self.F[i] + 0.6 * np.random.rand()\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdvancedChaoticDEwithMemory", "description": "Advanced Chaotic Differential Evolution with Adaptive Memory and Perturbation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 33, "fitness": 0.3609472588678442, "feedback": "The algorithm AdvancedChaoticDEwithMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8738134749741805, 0.8706295809090133, 0.8827307207516425, 0.8669413305344899, 0.8622584504837628, 0.8554032648235088, 0.8782316821065137, 0.8693081615306405, 0.8734026680125077, 0.7534941539632791, 0.7686923121966728, 0.7461573637428233, 0.7534432183900319, 0.7571982628828302, 0.7541844417099499, 0.7428979889232795, 0.7330156744047118, 0.7673251403341689, 0.4935435870336281, 0.48169289273638816, 0.49926475244956714, 0.514291783586398, 0.395809166300903, 0.3762769776227064, 0.43316635831156325, 0.37242998213031553, 0.4358142317167283, 0.23391387210190562, 0.14245687215510383, 0.15195752484864278, 0.1610349738919281, 0.28576129079504264, 0.14331814350597505, 0.26423057436017183, 0.18524180587467032, 0.16741414270501231, 0.9238216745485243, 0.9071429911362545, 0.9120834777184812, 0.9244256690397891, 0.9358882437403075, 0.9438917046676065, 0.9757253170440452, 0.8811615069106311, 0.9001642091438212, 0.5095517243701732, 0.548152639164057, 0.3380882156107077, 0.5803851828347497, 0.47608184652107677, 0.4177164032843701, 0.44410565674140434, 0.4304704159484891, 0.42586703247362157, 0.7319652978049134, 0.7275258164826315, 0.5842803186208974, 0.559491431769734, 0.7840153519169942, 0.7973392653176845, 0.7777053477913052, 0.7956698849358906, 0.22836664704787535, 0.15088711165415503, 0.16336665604076006, 0.18052411600702611, 0.24496104604659485, 0.35556012118817293, 0.17177790094533052, 0.15332881156351563, 0.17049325876584587, 0.18390737281612324, 0.1472979793403827, 0.19987237584619189, 0.18809755921753235, 0.18131092503264268, 0.18360061817792162, 0.15896401330086463, 0.1870414204907208, 0.1840908511020215, 0.15775313747277375, 0.028041290378327588, 0.1506306972804976, 0.0670343136521091, 0.04742937823781812, 0.05892111492812424, 0.04146376782349093, 0.1708092739082595, 0.0473436788507241, 0.15821611167617178, 0.23813175890338734, 0.21003588439848686, 0.21781287761365176, 0.17301310599737285, 0.2416901622129849, 0.11794445367478423, 0.3177061590064614, 0.277402164646687, 0.243215454667554, 0.18212739679209422, 0.07031282986619847, 0.08293051208472701, 0.08890529847861017, 0.14403780525780308, 0.17073629284111758, 0.143971470916874, 0.16001572103783834, 0.22326859604425997, 0.21697472252283656, 0.13747152476872493, 0.16820952037573256, 0.19564669622028408, 0.2441813509468077, 0.2272739621103076, 0.23718188648894434, 0.12187768405136812, 0.178283888888082, 0.6619879799407787, 0.6487677013625563, 0.6071457021460633, 0.6202918538707518, 0.5382493014579526, 0.5560709486128702, 0.6252863024032133, 0.6083444939316245, 0.6276517930630235, 0.12090751555675794, 0.11057809803561036, 0.10866108879779424, 0.11582982328507807, 0.13524607494678398, 0.11439034018252348, 0.1160972418513555, 0.1222589185295665, 0.12116909764444495, 0.1573211001118452, 0.1576967791636782, 0.1389458347335789, 0.1680845766943727, 0.14093591275619965, 0.1530187342570818, 0.14549593568609775, 0.1336019030758171, 0.1314861611227428, 0.5004696000433625, 0.4887377715396064, 0.48711360737726517, 0.5166784305787422, 0.537250208458802, 0.3972251671309298, 0.5323966605094317, 0.5496313873080456, 0.4886146570080978, 0.2660270890787165, 0.2711308962309473, 0.3240910441079682, 0.36548431609589405, 0.2885204094405488, 0.3490548349274898, 0.4258949429643277, 0.31984114782324236, 0.34026861099844496, 0.21071044280443352, 0.20383979651974793, 0.21387004916846697, 0.21955727817309012, 0.19191295275625042, 0.20066472668731572, 0.2679618974477005, 0.21031117776785913, 0.23989128750843125, 0.2171661608026153, 0.5711995951291904, 0.23555889039600564, 0.23060574201628314, 0.2268252805232075, 0.4888288799306477, 0.2917235544082576, 0.2357621582571855, 0.5815325258261661, 0.17864421045959766, 0.18308983662880662, 0.1609770967198083, 0.19630223459092466, 0.16623711298011945, 0.8480937680591693, 0.8347515172874521, 0.17281625404558876, 0.4434592096407234, 0.7107416114284331, 0.6001509956971027, 0.5966705994485697, 0.4413810420156208, 0.166650124134599, 0.20306269023211965, 0.7459220227294379, 0.34375731480367944, 0.20354386327122154, 0.18235007809611492, 0.17956927845001824, 0.19369802978527573, 0.17720013908874677, 0.18009231179840512, 0.17714449357822026, 0.17727197250410098, 0.17385555680365816, 0.18263679720339898, 0.08769747883757917, 0.0850582986916335, 0.08896605910274902, 0.08924024061405944, 0.0830244116159865, 0.09255676190160134, 0.09426380212882346, 0.08667306358225146, 0.0942690685890809]}, "mutation_prompt": null}
{"id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "solution": "import numpy as np\n\nclass HybridChaoticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.25  # modified probability for local search\n        self.dynamic_scale = 0.3  # modified dynamic scale\n        self.chaos_coefficient = 0.8  # adjusted chaos coefficient\n        self.learning_rate = 0.1  # learning rate for adaptive factors\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridChaoticAdaptiveDE", "description": "Hybrid Stochastic Differential Evolution Incorporating Chaotic Maps and Adaptive Learning for Improved Exploration and Exploitation.", "configspace": "", "generation": 34, "fitness": 0.4064667446767936, "feedback": "The algorithm HybridChaoticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "f16b3775-6489-4f6e-a55c-213b2dfda9ea", "metadata": {"aucs": [0.8885654555844937, 0.876254772770979, 0.8765070601443038, 0.8730452866267258, 0.8753067998243778, 0.8699043346297483, 0.877422850616077, 0.8694064043367762, 0.8633869426691301, 0.7727326651274818, 0.7800303670023003, 0.7685940204810149, 0.7557869167290342, 0.7546167004919999, 0.7738500556813143, 0.7580760306789673, 0.7509943413916913, 0.7520364855304258, 0.545428404000522, 0.5490603324059662, 0.5544484353635525, 0.6032006651787389, 0.5057422515342004, 0.6126827925301117, 0.5774013420468835, 0.6331470058106486, 0.6210771628997203, 0.14767276967844012, 0.17126684427103223, 0.14645419758017264, 0.5798335606788454, 0.14822678479722706, 0.16765828450285625, 0.502128523154164, 0.15259166503351607, 0.33836134287329545, 0.9599940111079562, 0.9229002090376826, 0.9676542856413346, 0.9361278324953283, 0.9202749058122431, 0.9341731574159154, 0.9527613738847722, 0.9553830550634413, 0.9733657015175755, 0.6168928397382942, 0.5645682669555547, 0.5739650534561005, 0.6084920069763161, 0.5846250279955424, 0.5647681195833754, 0.35740772165682455, 0.4996261254671479, 0.5027550379380717, 0.22138517109037426, 0.775459911375445, 0.7394906634253664, 0.3777891537044532, 0.7793987900197084, 0.8471218368416572, 0.8149179087354332, 0.83854506959701, 0.7915607420541929, 0.23599795653876343, 0.23681915738315207, 0.23315896929389146, 0.1796749355813767, 0.20337914661377565, 0.16441801996004146, 0.1850933121987609, 0.17318504095898846, 0.14939455169583415, 0.1584378899105866, 0.16501032149126182, 0.25760982464487714, 0.15160064418762909, 0.14176554934508856, 0.42204128231467897, 0.1810471880115535, 0.14595561921519018, 0.1414229925292615, 0.25543149020533296, 0.275176525409641, 0.0831147705317391, 0.22467002346291998, 0.10009472294601551, 0.13838399706361615, 0.14085031059883735, 0.14042343336155738, 0.09964721857350689, 0.26453943959879367, 0.4062053808164101, 0.452686808883607, 0.30384930605851024, 0.3615420490682464, 0.19862788586525115, 0.191181505365001, 0.4686014000470162, 0.4558607536615684, 0.16829765115844597, 0.1289046970258978, 0.06367420513560573, 0.10021144670688831, 0.09384783616264702, 0.15930283765455966, 0.11323593398450194, 0.1285938916216075, 0.14451544362429414, 0.17975898341771168, 0.2564018831566809, 0.22279037022419246, 0.3005662991336554, 0.3069701317752539, 0.23780771920895627, 0.15788590838500627, 0.19620705330922705, 0.21131019322486322, 0.6999486001114489, 0.6457963332191147, 0.6484083905742244, 0.6601848584976289, 0.6716544085024707, 0.6004615651764496, 0.6869017809577705, 0.6311820737748584, 0.6545976823190527, 0.11876756303414093, 0.1336381375182698, 0.12916882239581573, 0.15928714828823554, 0.12834474358793235, 0.12035169094650588, 0.1347149580812944, 0.12327979030585645, 0.12172605042899454, 0.15683582060977808, 0.17162412810831795, 0.17221598737105526, 0.15426115074722313, 0.14582355554028603, 0.1266942524493212, 0.15640227091569248, 0.16814193851260484, 0.1703105774683441, 0.49205957492328967, 0.44895952485869683, 0.43758846541966423, 0.49779649373410073, 0.5357448764660311, 0.5468169461418364, 0.5860437019090525, 0.5427694608268115, 0.5521869217820039, 0.3365173923488798, 0.368684379979319, 0.38702640792997944, 0.2856693193656321, 0.40933158564190464, 0.3761158331685375, 0.3099605643481542, 0.3673491401632929, 0.30460790924923487, 0.23842684860848673, 0.20032226388153507, 0.2008673728165037, 0.20792924240464283, 0.20450182578360354, 0.20504963322472636, 0.22408709260263282, 0.2082823732062451, 0.21590229815059792, 0.5509000310897971, 0.7106183607135637, 0.36185621693046377, 0.19793860216776926, 0.4875836951880643, 0.5227697627193854, 0.5804969649157585, 0.6839881529691216, 0.23712905319877675, 0.1967490275507202, 0.18449264038409574, 0.18509006266640615, 0.8504300255242253, 0.16460744196539767, 0.7757675757444121, 0.859994847286724, 0.17298224949847285, 0.7721556853867326, 0.790048676804619, 0.8020427090376694, 0.7665637197194024, 0.1947939209635361, 0.57241267495006, 0.6480439399450141, 0.813751505053261, 0.2051779768833154, 0.7099909025830833, 0.18814878493482146, 0.17657330073733501, 0.18440228204005626, 0.18740302459425706, 0.189519650475803, 0.19341776411180556, 0.18255994336715942, 0.185493028140584, 0.20177867164137253, 0.09141247371209482, 0.08755715292188126, 0.08711105598639224, 0.08831153578232354, 0.08848683062023532, 0.08957604195540425, 0.09832467205845297, 0.08157453656001235, 0.0839822087833707]}, "mutation_prompt": null}
{"id": "7519a817-e06e-41f1-a5bc-384a9b1cc779", "solution": "import numpy as np\n\nclass HybridChaoticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.25  # modified probability for local search\n        self.dynamic_scale = 0.3  # modified dynamic scale\n        self.chaos_coefficient = 0.8  # adjusted chaos coefficient\n        self.learning_rate = 0.1  # learning rate for adaptive factors\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridChaoticAdaptiveDE", "description": "Hybrid Stochastic Differential Evolution Incorporating Chaotic Maps and Adaptive Learning for Improved Exploration and Exploitation.", "configspace": "", "generation": 35, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8885654555844937, 0.876254772770979, 0.8765070601443038, 0.8730452866267258, 0.8753067998243778, 0.8699043346297483, 0.877422850616077, 0.8694064043367762, 0.8633869426691301, 0.7727326651274818, 0.7800303670023003, 0.7685940204810149, 0.7557869167290342, 0.7546167004919999, 0.7738500556813143, 0.7580760306789673, 0.7509943413916913, 0.7520364855304258, 0.545428404000522, 0.5490603324059662, 0.5544484353635525, 0.6032006651787389, 0.5057422515342004, 0.6126827925301117, 0.5774013420468835, 0.6331470058106486, 0.6210771628997203, 0.14767276967844012, 0.17126684427103223, 0.14645419758017264, 0.5798335606788454, 0.14822678479722706, 0.16765828450285625, 0.502128523154164, 0.15259166503351607, 0.33836134287329545, 0.9599940111079562, 0.9229002090376826, 0.9676542856413346, 0.9361278324953283, 0.9202749058122431, 0.9341731574159154, 0.9527613738847722, 0.9553830550634413, 0.9733657015175755, 0.6168928397382942, 0.5645682669555547, 0.5739650534561005, 0.6084920069763161, 0.5846250279955424, 0.5647681195833754, 0.35740772165682455, 0.4996261254671479, 0.5027550379380717, 0.22138517109037426, 0.775459911375445, 0.7394906634253664, 0.3777891537044532, 0.7793987900197084, 0.8471218368416572, 0.8149179087354332, 0.83854506959701, 0.7915607420541929, 0.23599795653876343, 0.23681915738315207, 0.23315896929389146, 0.1796749355813767, 0.20337914661377565, 0.16441801996004146, 0.1850933121987609, 0.17318504095898846, 0.14939455169583415, 0.1584378899105866, 0.16501032149126182, 0.25760982464487714, 0.15160064418762909, 0.14176554934508856, 0.42204128231467897, 0.1810471880115535, 0.14595561921519018, 0.1414229925292615, 0.25543149020533296, 0.275176525409641, 0.0831147705317391, 0.22467002346291998, 0.10009472294601551, 0.13838399706361615, 0.14085031059883735, 0.14042343336155738, 0.09964721857350689, 0.26453943959879367, 0.4062053808164101, 0.452686808883607, 0.30384930605851024, 0.3615420490682464, 0.19862788586525115, 0.191181505365001, 0.4686014000470162, 0.4558607536615684, 0.16829765115844597, 0.1289046970258978, 0.06367420513560573, 0.10021144670688831, 0.09384783616264702, 0.15930283765455966, 0.11323593398450194, 0.1285938916216075, 0.14451544362429414, 0.17975898341771168, 0.2564018831566809, 0.22279037022419246, 0.3005662991336554, 0.3069701317752539, 0.23780771920895627, 0.15788590838500627, 0.19620705330922705, 0.21131019322486322, 0.6999486001114489, 0.6457963332191147, 0.6484083905742244, 0.6601848584976289, 0.6716544085024707, 0.6004615651764496, 0.6869017809577705, 0.6311820737748584, 0.6545976823190527, 0.11876756303414093, 0.1336381375182698, 0.12916882239581573, 0.15928714828823554, 0.12834474358793235, 0.12035169094650588, 0.1347149580812944, 0.12327979030585645, 0.12172605042899454, 0.15683582060977808, 0.17162412810831795, 0.17221598737105526, 0.15426115074722313, 0.14582355554028603, 0.1266942524493212, 0.15640227091569248, 0.16814193851260484, 0.1703105774683441, 0.49205957492328967, 0.44895952485869683, 0.43758846541966423, 0.49779649373410073, 0.5357448764660311, 0.5468169461418364, 0.5860437019090525, 0.5427694608268115, 0.5521869217820039, 0.3365173923488798, 0.368684379979319, 0.38702640792997944, 0.2856693193656321, 0.40933158564190464, 0.3761158331685375, 0.3099605643481542, 0.3673491401632929, 0.30460790924923487, 0.23842684860848673, 0.20032226388153507, 0.2008673728165037, 0.20792924240464283, 0.20450182578360354, 0.20504963322472636, 0.22408709260263282, 0.2082823732062451, 0.21590229815059792, 0.5509000310897971, 0.7106183607135637, 0.36185621693046377, 0.19793860216776926, 0.4875836951880643, 0.5227697627193854, 0.5804969649157585, 0.6839881529691216, 0.23712905319877675, 0.1967490275507202, 0.18449264038409574, 0.18509006266640615, 0.8504300255242253, 0.16460744196539767, 0.7757675757444121, 0.859994847286724, 0.17298224949847285, 0.7721556853867326, 0.790048676804619, 0.8020427090376694, 0.7665637197194024, 0.1947939209635361, 0.57241267495006, 0.6480439399450141, 0.813751505053261, 0.2051779768833154, 0.7099909025830833, 0.18814878493482146, 0.17657330073733501, 0.18440228204005626, 0.18740302459425706, 0.189519650475803, 0.19341776411180556, 0.18255994336715942, 0.185493028140584, 0.20177867164137253, 0.09141247371209482, 0.08755715292188126, 0.08711105598639224, 0.08831153578232354, 0.08848683062023532, 0.08957604195540425, 0.09832467205845297, 0.08157453656001235, 0.0839822087833707]}, "mutation_prompt": null}
{"id": "80dece41-ad3c-4383-9ec6-e158bd8e5f44", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)  # Wider range for crossover rate\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Modified scaling factor range\n        self.local_intensification = 0.30  # Adjusted probability for local search\n        self.dynamic_scale = 0.4  # Increased dynamic scale for exploration\n        self.chaos_coefficient = 0.85  # Adjusted chaos coefficient for perturbations\n        self.learning_rate = 0.15  # Higher learning rate for adaptive parameters\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced dynamic scaling and hybrid strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic and Feedback-Based Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    feedback_factor = np.random.rand()  # Feedback mechanism for diversity\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best * feedback_factor\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Chaotic Perturbations and Dynamic Feedback Mechanisms for Robust Exploration and Exploitation.", "configspace": "", "generation": 36, "fitness": 0.288626358083004, "feedback": "The algorithm EnhancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.7367094717028551, 0.7284897015297185, 0.7327869534672338, 0.7191951583809815, 0.7049163963074161, 0.7023974712741297, 0.7132111728895132, 0.7155317716519758, 0.7114092420744358, 0.4426047118507953, 0.4608776895339157, 0.4635373748874859, 0.5104663955545303, 0.4931742391861017, 0.46598395851941243, 0.4460562708788438, 0.4015451473964061, 0.43028515969055847, 0.24267761169639046, 0.2127529563384889, 0.20576821042329174, 0.21022688341174078, 0.22216302059138993, 0.21689488776738142, 0.2271460604852299, 0.23755669811206304, 0.26190896508046635, 0.15060794183494508, 0.15846968855903087, 0.17757229463983237, 0.1622186838595826, 0.15043597496026284, 0.14361722274180122, 0.1642662789635766, 0.15413099923683893, 0.14497821816687773, 0.9849609519170087, 0.954234517572524, 0.8831807301887008, 0.9863287323839798, 0.9405773460026363, 0.9292103771789001, 0.9261618634943318, 0.8716860533975341, 0.8519183176885851, 0.3130706327306453, 0.2952101780855967, 0.2827569940557789, 0.2912516451732703, 0.3164726385797185, 0.31255041452802845, 0.2786818443913367, 0.26730397225496416, 0.2818881615889097, 0.62703784209167, 0.6476678801416587, 0.5646804230442881, 0.6145008189685142, 0.643829853654005, 0.3890896556034852, 0.5005141666537511, 0.5365921789980246, 0.5145463583665858, 0.22383643534129127, 0.18638376403246115, 0.20485699677272073, 0.2264803587319456, 0.18843244942247728, 0.14784758126845376, 0.17858817310153352, 0.19994237978610885, 0.2593768083897279, 0.23203895679217212, 0.19222683145963215, 0.18724501529974102, 0.23137156777552692, 0.244214176398857, 0.21588718324599798, 0.17280077462180865, 0.2047486630286356, 0.22372798582282782, 0.024901645155199215, 0.015987335493616417, 0.02116232775518334, 0.01417842362535282, 0.02269297130443848, 0.025901275673936297, 0.04920182255569838, 0.07305665361078395, 0.06762423402800888, 0.14026648678970755, 0.15617739991050206, 0.12594734679349417, 0.13342427433193793, 0.12761378327324369, 0.11699772934951636, 0.16278587517599574, 0.1554121938459988, 0.181562967492228, 0.011514863323517033, 0.04672356424629032, 0.007912768435170081, 0.021183467220380447, 0.04251107187650249, 0.012338141126481572, 0.030118433740993766, 0.01530390674914417, 0.03558860957170995, 0.1287928535909939, 0.13408512930226246, 0.15563145652441124, 0.13743325992899613, 0.13568105468340586, 0.12274384130212002, 0.11558768692213672, 0.10931344152759337, 0.1021017865601751, 0.4915476063359949, 0.5121311991525577, 0.48262361013656896, 0.4721305940527174, 0.45934310282318913, 0.4814862174485989, 0.49426624794684093, 0.49274473453100986, 0.5020417762388227, 0.10881839221144296, 0.10235388155331893, 0.09015250138319586, 0.09610257978514469, 0.10474221996210986, 0.10670382182151494, 0.11722008335168888, 0.10369272841410926, 0.09499674790007195, 0.1477864849159456, 0.14359310542466686, 0.14431418971697785, 0.1672838478525307, 0.14241797196926032, 0.18443727752204664, 0.16142897630817066, 0.1427147055217972, 0.1381933528640502, 0.3082653797270595, 0.3411605892402909, 0.30436104434257716, 0.3711951518446903, 0.3387991364028603, 0.3487551734611686, 0.3244615563492702, 0.3414432643025104, 0.3403544538389548, 0.24010955494041342, 0.2308279092044313, 0.24273674977434545, 0.27449431811672287, 0.263708761460691, 0.27138642857339923, 0.22633375200259065, 0.236344831827072, 0.22461085341706288, 0.21891574226437838, 0.2203076679036069, 0.22637606161588741, 0.24637747077810968, 0.20341747587519443, 0.2305823542658939, 0.22678815768547078, 0.2094656795645894, 0.21464728032601565, 0.193698356305395, 0.20607847585116956, 0.19441860884873985, 0.19616821309217825, 0.19646404844488374, 0.21143058592547537, 0.20120351989918106, 0.20248854107208902, 0.19997810609839062, 0.18679793131008893, 0.6911344970613194, 0.18267617117666024, 0.628837663498793, 0.1929792006154809, 0.6231925069843494, 0.7249478082015044, 0.5953732322864309, 0.16627251906094176, 0.5555610074041741, 0.44017307671645467, 0.5718943403711793, 0.19881515135333283, 0.20334920157548408, 0.20258869662151635, 0.3810294473315379, 0.4838812269087456, 0.3867424152938187, 0.17114923394926518, 0.19441851842838376, 0.1835475483899328, 0.1829435716468385, 0.19378448679003746, 0.18834391188806332, 0.20332337309942627, 0.19766887689590862, 0.178930078389807, 0.08551699366813759, 0.08407141064989776, 0.0908256391094967, 0.08721147593495593, 0.09177389536322278, 0.08732391675836004, 0.08815068142626936, 0.07719905261022564, 0.09949975890273943]}, "mutation_prompt": null}
{"id": "e1b08366-acef-452b-8d03-25892bfc0390", "solution": "import numpy as np\n\nclass EnhancedChaoticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.30  # increased probability for local search\n        self.dynamic_scale = 0.2  # adjusted dynamic scale\n        self.chaos_coefficient = 0.9  # optimized chaos coefficient\n        self.learning_rate = 0.15  # higher learning rate for adaptive factors\n        self.gaussian_mutation_prob = 0.2  # new Gaussian mutation probability\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and alternative strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n\n                # Gaussian Mutation\n                if np.random.rand() < self.gaussian_mutation_prob:\n                    mutant += np.random.normal(0, 0.1, self.dim)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedChaoticAdaptiveDE", "description": "Enhanced Stochastic Differential Evolution with Chaotic Maps, Adaptive Learning, and Dynamic Gaussian Mutation for Improved Exploration.", "configspace": "", "generation": 37, "fitness": 0.374854783653426, "feedback": "The algorithm EnhancedChaoticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8490289904602781, 0.8459247450097108, 0.8464845584722224, 0.8353101125027398, 0.8440907723259914, 0.8521884456614288, 0.8414816458867648, 0.8367029639376528, 0.8399147927657732, 0.672168582161802, 0.6758983051683605, 0.7016223549165866, 0.6708428110419722, 0.6837036894801207, 0.6928175853895499, 0.6732374017286737, 0.6769205977383501, 0.6810143054905623, 0.44745599023231075, 0.47536044435175695, 0.44004429720734495, 0.49140872545176073, 0.42353112580684615, 0.5044005585259392, 0.4903905023348003, 0.47880074564856556, 0.40949522146391615, 0.16583218483275564, 0.4383986220744053, 0.28255774004440415, 0.2219555044141437, 0.16316907979813589, 0.3022881762182722, 0.31587888027215005, 0.15706150481201597, 0.14943867931496913, 0.9305553263774778, 0.961110886924398, 0.9635583205267318, 0.9550077273651021, 0.9385891502105729, 0.9351327793158567, 0.926887149994092, 0.9290410988984306, 0.9298930183824787, 0.5176826802450645, 0.46254392392999355, 0.46680185255940243, 0.48221584070891543, 0.44905364859433805, 0.42737397236542807, 0.45181832596294336, 0.44315415525538404, 0.41758753043688834, 0.7199199811106155, 0.6531767661196366, 0.7299574079038555, 0.7474638587647977, 0.7698499525563789, 0.2747899306588486, 0.7790173429736419, 0.7893128865309347, 0.7579863361289302, 0.2375791820883082, 0.16633621977794633, 0.3216334077992087, 0.1577808292414773, 0.19171359012889588, 0.12533272329817702, 0.26628077336442535, 0.2308537438193845, 0.24493105532720216, 0.19052519114562616, 0.1868878519982191, 0.1650943179989619, 0.20263853033766077, 0.16925942109355596, 0.1704598824389857, 0.15776203421075785, 0.14992500011419652, 0.16025211054613642, 0.07343368948469975, 0.06574935281346406, 0.15528520711450888, 0.05169672247465218, 0.12943271981439852, 0.08279845351861403, 0.13796897054012858, 0.0685251346514415, 0.09665432360350545, 0.2626166550117648, 0.2666360814700811, 0.2893956206658934, 0.16246321196001245, 0.2505789666811573, 0.18147988749100952, 0.3304617835611653, 0.27270533520237505, 0.25258829848330744, 0.07730151438646082, 0.1405257292204356, 0.11649619810784939, 0.07379197438482243, 0.20540124144232197, 0.07326932156471233, 0.10859309873198197, 0.07623495604607666, 0.15375734340349412, 0.20826262661247974, 0.13552049900833918, 0.19820381644873364, 0.20352226803792905, 0.2065577903473984, 0.23478303106352283, 0.20744391360801084, 0.13925179614957983, 0.15667651738212607, 0.5746581915013397, 0.6502290176321415, 0.5864591712625491, 0.5958253114263519, 0.5643029184911105, 0.6123537235362548, 0.6464947580928201, 0.6115280146922716, 0.6518803864981281, 0.1424975408979393, 0.1360055233747236, 0.1072360684187732, 0.13210107033386398, 0.10462935378276339, 0.11374476319215443, 0.11894378107922599, 0.12285754119041226, 0.1327145856667754, 0.1461227112909257, 0.14193824841699065, 0.13731232438611618, 0.1576321292674866, 0.15562442269857935, 0.17107746000538426, 0.16648973944907708, 0.13906574604519906, 0.1541931931069367, 0.41119208893028525, 0.46252014410543585, 0.4300510676710133, 0.43781648928345684, 0.43348727898448947, 0.4672347221334887, 0.507614903886996, 0.48967543666907964, 0.5015496673376452, 0.24618263887998115, 0.2513432176094065, 0.3221284826433739, 0.1983646989266492, 0.2846368299104063, 0.3709568986431374, 0.3833772520488121, 0.3132442632334995, 0.33013339526354735, 0.2170940817069441, 0.20624610076685668, 0.1936290594508845, 0.20575343395254542, 0.2065371168230461, 0.21468893099935227, 0.2025109030542006, 0.21823234306291395, 0.1935274792945907, 0.23073056059859431, 0.26826395564625805, 0.2354167119055831, 0.4201409902670541, 0.219064867406495, 0.3543547731010056, 0.5506889422626187, 0.37569871014711276, 0.4365353252788845, 0.1820998985158926, 0.7940627707843408, 0.18064184957713914, 0.8644280300105134, 0.7938125429763568, 0.8140566863962069, 0.8192190674525242, 0.5983150336792098, 0.7222272516711055, 0.5985968717950005, 0.6177048889762963, 0.20430455814294557, 0.20544688979232473, 0.6312963747227002, 0.6732957965535856, 0.6003153069165786, 0.7044640009793689, 0.5093035437631213, 0.18230659295663254, 0.1999132211352378, 0.18559398959953044, 0.19205477098841717, 0.2044479616021455, 0.17464911713792353, 0.1826407916655417, 0.1827001707664645, 0.18194013749547755, 0.09426669632555928, 0.08024124639884811, 0.09069908448274167, 0.08345745775066093, 0.0857808383521067, 0.0809750425618686, 0.09636585029905964, 0.08223075234209631, 0.08262431799078673]}, "mutation_prompt": null}
{"id": "8da451b5-c2cd-459e-ae28-dca2463a384e", "solution": "import numpy as np\n\nclass EnhancedHybridChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population size for better exploration\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # slightly higher initial CR range\n        self.F = np.random.uniform(0.5, 0.9, self.pop_size)\n        self.local_intensification = 0.3  # increased probability for local search\n        self.dynamic_scale = 0.35  # increased dynamic scale for more diverse exploration\n        self.chaos_coefficient = 0.85  # slightly increased chaos coefficient\n        self.learning_rate = 0.15  # increased learning rate for faster adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced dynamic scaling and strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    chaos_scaled = 0.5 + chaos_value * (np.random.rand() - 0.5)  # more randomness in chaotic scaling\n                    mutant = chaos_scaled * mutant + (1 - chaos_scaled) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridChaoticDE", "description": "An enhanced hybrid differential evolution algorithm with a dynamic mutation strategy and adaptive chaotic exploration for robust optimization.", "configspace": "", "generation": 38, "fitness": 0.3845354642175423, "feedback": "The algorithm EnhancedHybridChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8624619363532091, 0.8459024583618745, 0.8636806295231174, 0.8682560404036268, 0.854225260573687, 0.850906631732551, 0.8677995370183014, 0.8469530167876064, 0.864903780132339, 0.7426766167235184, 0.7262052365368397, 0.7292190901390789, 0.7044325014726625, 0.734777420387883, 0.742997405071297, 0.7376428877747118, 0.7369332475198107, 0.7343319503119002, 0.5959601184618446, 0.5708953172707012, 0.4326963968235076, 0.5139536190415861, 0.45693172482132227, 0.6012676665347076, 0.5704252504995111, 0.5054195251435242, 0.5931394855329677, 0.40289390187187424, 0.4055095623421391, 0.15799173455421756, 0.141476247641106, 0.3621654659990149, 0.43388946642522996, 0.3728763059474963, 0.15998366812982479, 0.35548857558453795, 0.9319964674116904, 0.941402466481083, 0.9312563462154474, 0.9507275345629475, 0.9565836696497494, 0.9545441322812293, 0.9317965091207908, 0.8869335401335905, 0.935364139592685, 0.5700547231719674, 0.4683452758010087, 0.48754715529354975, 0.5293638316766998, 0.496204101759116, 0.5522111763799986, 0.3598403855745669, 0.5409326064066713, 0.5170255959588801, 0.7644011890734274, 0.22480778747948038, 0.8640325934835965, 0.7772194320097601, 0.2708384759999124, 0.7645816415456903, 0.7785169669239379, 0.8227995259754706, 0.7881566634684507, 0.17348338337353575, 0.1636656342583892, 0.1681636549344766, 0.16803297560802677, 0.17651321452018942, 0.23678392695970296, 0.1628919516511964, 0.1663144204018039, 0.21475531013166482, 0.19049139503937018, 0.17786425115725324, 0.16947252605108387, 0.1355280634771241, 0.16639439832430036, 0.14213841413274586, 0.14667239935471443, 0.15857869602769092, 0.16125828258123165, 0.07759023165345025, 0.1322389179853931, 0.12608844042681344, 0.08617012884540487, 0.03825373960911316, 0.021375924866725238, 0.17999690237187804, 0.1535597866977827, 0.11901967760363097, 0.2515833967447031, 0.2434441290526007, 0.3357306397422375, 0.2226318121276757, 0.23402349411989287, 0.25739795530989085, 0.3973486310781088, 0.26880988438894593, 0.3248590070964491, 0.0878713059722539, 0.13592729286692762, 0.08348865172317621, 0.07601360670013657, 0.104960551467848, 0.15148706347340135, 0.10193990227326266, 0.16773044854382768, 0.20293212398080995, 0.21142718611527478, 0.20515925803874757, 0.1990554130373089, 0.31329897593836187, 0.23211498514696816, 0.22406719085688276, 0.2738944600517146, 0.2380434892395099, 0.16735289968298517, 0.6922769848521426, 0.6405002422530304, 0.6317323606011518, 0.6376610132626759, 0.653547503571575, 0.6505775849034, 0.6071855449080956, 0.616262055747387, 0.6434826558296123, 0.11119921265363919, 0.11062092227895204, 0.16303143660863628, 0.12136341076840673, 0.11304989259160247, 0.12951917815778646, 0.16141615121087505, 0.10509526137098912, 0.09897643220131158, 0.1576567703997842, 0.15791636891863525, 0.16050694157407575, 0.13276698601129389, 0.2469001388299903, 0.17967356367639964, 0.1514313023486169, 0.14923960635871103, 0.2230132694310637, 0.42822927186957405, 0.4509850330683315, 0.49551337262248984, 0.5307712673037349, 0.5026067256687848, 0.5224648317325671, 0.5817988065270433, 0.5462244170086026, 0.5665395312149165, 0.25803111089164477, 0.3043639114556216, 0.30946974355306434, 0.3792431502720002, 0.3300442164964139, 0.3817591889731885, 0.3860661359226836, 0.4018907980722559, 0.3435773612588875, 0.22160108096577313, 0.19605123406842262, 0.20369554826584746, 0.1961185862015432, 0.19929673309396234, 0.22735651507162924, 0.21465921925844955, 0.20132412443862346, 0.20556177529068964, 0.528220573354812, 0.22742486797892547, 0.3124693965610771, 0.4841818195088743, 0.6699397642269811, 0.39334300880352424, 0.4836308893566583, 0.551708232894319, 0.4188362458590964, 0.1838343693813259, 0.16332915182708452, 0.18234199216673075, 0.7412011540370702, 0.6774783715078301, 0.6349352331735902, 0.6116902381282763, 0.3278868110123576, 0.1673094989304993, 0.16664126912065802, 0.6105075314719641, 0.649295605929082, 0.167478975450432, 0.20260670455766372, 0.16600444106053514, 0.7067069032569175, 0.6871119252893396, 0.7283305946029205, 0.1787279900372689, 0.18353909391383316, 0.19892403231464018, 0.17999005036495364, 0.18977737252596993, 0.18987220926612058, 0.19044368783700028, 0.21235354142343654, 0.17841748408314884, 0.0945279982353322, 0.08828303767710954, 0.0864514759193904, 0.10161696216622496, 0.07953396632132281, 0.08601172423064707, 0.0957985947251524, 0.08268497785089768, 0.0957700050664464]}, "mutation_prompt": null}
{"id": "98e9ee46-3cb1-4408-aa1b-351db52c1b64", "solution": "import numpy as np\n\nclass EnhancedHybridChaoticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.3  # increased likelihood for local search\n        self.dynamic_scale = 0.35  # refined dynamic scale\n        self.chaos_coefficient = 0.85  # adjusted chaos coefficient for exploration\n        self.learning_rate = 0.15  # heightened learning rate for adaptive factors\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Randomized Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.random.choice(np.argsort(self.fitness)[:3])]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridChaoticAdaptiveDE", "description": "Enhanced Hybrid Chaotic Adaptive DE with Randomized Intensification and Dynamic Adaptive Parameters for Superior Exploration.", "configspace": "", "generation": 39, "fitness": 0.3920940358827102, "feedback": "The algorithm EnhancedHybridChaoticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8777182969769807, 0.8705633654982899, 0.8849939958962485, 0.8650158605782275, 0.8752086305501653, 0.8763838335744589, 0.8869490177442569, 0.8866821699767691, 0.872433739592135, 0.7771536800101868, 0.7635228968070614, 0.7728730526681016, 0.7703709515387859, 0.7143000434307104, 0.7680606603694584, 0.7756156152722475, 0.7563502244288018, 0.7744636681561106, 0.5981864796587156, 0.5018010256009532, 0.5789814747364737, 0.5859548101664586, 0.5336480200045028, 0.5958859619507264, 0.17169018532931424, 0.5763096339098517, 0.5560337096179873, 0.3647234341864948, 0.16128227586722932, 0.14487301730225388, 0.1583102980488018, 0.16879267442822143, 0.4799594965644012, 0.16620055483824725, 0.1502270740492373, 0.4045727081257937, 0.9719629774301334, 0.8938827516445027, 0.9637858367013113, 0.9394402657359947, 0.9148489492839601, 0.952989892246187, 0.9394558151280116, 0.9086829240067049, 0.958896474590514, 0.4749683919827853, 0.19468781005449876, 0.20703033872961485, 0.41809994697518915, 0.5934272858187111, 0.4999115735638461, 0.45047717059710934, 0.2858415894880545, 0.3176603002184002, 0.8123946573953471, 0.7938173320198704, 0.21890011779708807, 0.8820924790563488, 0.8401887491744715, 0.8319666132778818, 0.8095030534017758, 0.7804744280950893, 0.2280287707287827, 0.2149137472019289, 0.16011077906898952, 0.17843641800872412, 0.12683688187577313, 0.12913443618954734, 0.4752784839792714, 0.1567298433016645, 0.23238814424373488, 0.24299413159609973, 0.2151380083885429, 0.16335796312645923, 0.1614709759807964, 0.17833545190308087, 0.1855542211434198, 0.1970304799440592, 0.14445436856262728, 0.16653038331270253, 0.16389603430559996, 0.25746767629993283, 0.12368839628011041, 0.1535250766970243, 0.12098335066877042, 0.049576675934177694, 0.1202925726834444, 0.19931922171939154, 0.22592933044854646, 0.07240516779474981, 0.34680717807395656, 0.26782430296120807, 0.38493607534635454, 0.19526665119881104, 0.09677738060600583, 0.3332896222253421, 0.3776778664943846, 0.4273746372650562, 0.3341596708744178, 0.10454684656852964, 0.23073113734166584, 0.06641941847518029, 0.12167131433706113, 0.18306463482534552, 0.15657668363805677, 0.13515689936501762, 0.08680895801120514, 0.22809272514850276, 0.23354114554451655, 0.2837918742017337, 0.14323502639771613, 0.298916821125647, 0.2226325595936337, 0.21605913441531643, 0.21172013154464786, 0.1404615988303738, 0.23470044094908782, 0.5812831837330954, 0.7594817907740404, 0.695763359626018, 0.6539031995721571, 0.6040074940626394, 0.5912038171870129, 0.7062010278243478, 0.6298424392686641, 0.6859910271966636, 0.11485392913189152, 0.10762624165088486, 0.11579828669359249, 0.11939588884921071, 0.12181331001968632, 0.165709374612534, 0.12247020285629273, 0.11889739611982619, 0.12940547112682033, 0.1601792663638043, 0.13105884114918032, 0.13537853816893297, 0.17212681118970485, 0.1384644898916204, 0.1660883898181248, 0.15667908171908906, 0.1421732201926902, 0.1453242991649606, 0.5193289435696355, 0.5184079414785628, 0.5423488740462362, 0.5150785261663717, 0.5201806156435191, 0.4823488782506249, 0.5948909153977608, 0.6018494286510164, 0.6099725958364549, 0.3766952828425175, 0.26723306631281407, 0.3811010658565813, 0.3441223331806187, 0.40893154027891454, 0.3888268683869569, 0.3929299972980944, 0.3586425529836931, 0.30887769768867623, 0.21866663614008686, 0.20491570983972252, 0.2023280014759773, 0.20347657274830921, 0.19996400340234943, 0.20656442818780985, 0.25150434921908904, 0.2059763845723792, 0.22250596856165772, 0.22185524028049852, 0.6377961612776486, 0.6221436158649591, 0.21688984260495658, 0.47565425325523836, 0.5995495542632554, 0.6963129205344998, 0.2054483671983759, 0.6682623768524807, 0.18611586515156864, 0.18604773648195172, 0.18482405896236176, 0.8168736066851854, 0.16660237281953016, 0.8687932178334772, 0.5057195857238934, 0.158313941218016, 0.7091478099800106, 0.77671866551295, 0.5767731430597809, 0.743712369698192, 0.6554208434674734, 0.2106441494551078, 0.20626386004388253, 0.6445963530100749, 0.4283120484180474, 0.7692929148520635, 0.19749269096363975, 0.20073111867886895, 0.19356715715852735, 0.1877988440121071, 0.19204796020952353, 0.19583694858999523, 0.18623978851316247, 0.17596600997711376, 0.18514736460471015, 0.08650656043638794, 0.08596157545561656, 0.08268344760327329, 0.08332792907064446, 0.09050020740371634, 0.08756183763231751, 0.09330128773417679, 0.09068728589813513, 0.09255131762331059]}, "mutation_prompt": null}
{"id": "b300cd9c-6a8e-48d6-a309-7a08a28cf5c2", "solution": "import numpy as np\n\nclass EnhancedChaoticDynamicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.initial_pop_size, dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.initial_pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.initial_pop_size)\n        self.local_search_prob = 0.3  # updated local search probability\n        self.dynamic_scale = 0.35  # enhanced dynamic scale factor\n        self.chaos_coefficient = 0.85  # updated chaos coefficient\n        self.learning_rate = 0.15  # increased learning rate\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        pop_size = self.initial_pop_size\n        while evaluations < self.budget:\n            for i in range(pop_size):\n                if evaluations >= self.budget:\n                    break\n                if pop_size > self.budget - evaluations:\n                    pop_size = self.budget - evaluations\n                    self.population = self.population[:pop_size]\n                    self.fitness = self.fitness[:pop_size]\n                    \n                # Mutation with dynamic scaling\n                indices = np.arange(pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_search_prob:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedChaoticDynamicDE", "description": "Enhanced Chaotic Differential Evolution with Dynamic Population and Adaptive Parameters for Improved Global Optimization.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 50 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 50 is out of bounds for axis 0 with size 50')", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {}, "mutation_prompt": null}
{"id": "a5aed32f-1a81-43ac-a201-f1e8a10b3f70", "solution": "import numpy as np\n\nclass EnhancedHybridChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.3\n        self.dynamic_scale = 0.35\n        self.chaos_coefficient = 0.85\n        self.learning_rate = 0.15\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * local_best\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridChaoticDE", "description": "Enhanced Hybrid Differential Evolution with Adaptive Chaotic Maps and Reinforced Local Search.", "configspace": "", "generation": 41, "fitness": 0.3886351227853719, "feedback": "The algorithm EnhancedHybridChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8665955861070431, 0.8663159539879104, 0.8569285071369567, 0.8667468992941825, 0.8609643335976607, 0.8571260426733713, 0.8571227197357525, 0.8650480720744905, 0.8736831207299718, 0.7590412905084687, 0.7437570430255074, 0.7533411151274954, 0.7628252953744381, 0.7513962916832033, 0.7626863505182322, 0.7474273069540213, 0.7371396255457425, 0.7590025813126866, 0.5218621180290584, 0.5175256497234855, 0.16885903426513338, 0.16864375271249832, 0.5827206956583031, 0.46295535097680274, 0.564536870233247, 0.5682071184565158, 0.5361802595592527, 0.36050918676428656, 0.16008135896562292, 0.41463308670868104, 0.4108033902155638, 0.3836201550066358, 0.16014160495446872, 0.42350614596440894, 0.47194875509750045, 0.16192155643960837, 0.9305020979933775, 0.9248736812193048, 0.9732489872967012, 0.9343160435635969, 0.9137786734277902, 0.925603506282491, 0.9522937663698922, 0.9464282192739013, 0.9244387982526028, 0.5831116789961819, 0.5816761668446373, 0.48991123755802557, 0.5494336058164189, 0.5449214243106546, 0.5854353239035412, 0.5116673752885217, 0.3269577557636254, 0.43044934611809593, 0.7821346516244119, 0.7883633900966751, 0.6408890965301863, 0.8365694130113099, 0.8200838775595789, 0.8135353727451309, 0.26617888693873604, 0.7998023525284902, 0.8094810485472155, 0.22134612935179543, 0.16080058590590174, 0.2249781265255807, 0.2161462348876183, 0.1624460731792644, 0.28754576235346097, 0.17794465528110182, 0.15326311858779695, 0.15560216065233723, 0.1958659287279988, 0.17001113522825795, 0.14937128701715974, 0.21734343054475258, 0.19443428232374182, 0.14311944041575952, 0.129390906795549, 0.26491858486305453, 0.14072211070758445, 0.19845227384406106, 0.20168576935256133, 0.11510674868736404, 0.25469584492200725, 0.13583988687231008, 0.1780957114066276, 0.1677148426365067, 0.23550351660042423, 0.25528651322533336, 0.2668952756535071, 0.30274675046726207, 0.30131121006430917, 0.24176580708004025, 0.23623013510141055, 0.23691744676494042, 0.42238337468871145, 0.2781577242119532, 0.35006988232404124, 0.19478240867451768, 0.1045277195820723, 0.17046101510063638, 0.09105527746488384, 0.19881201502455859, 0.13932446726169712, 0.12772485102690112, 0.11327096578561846, 0.09296393984390128, 0.19803591242920338, 0.20628252897330224, 0.24567207081770637, 0.3085984842830094, 0.29403334421555805, 0.25793109987203355, 0.17341718872622436, 0.16421570099892357, 0.22713769347553303, 0.7017407631037504, 0.6775017207317887, 0.6001528485894887, 0.5853048310080449, 0.6031301358703939, 0.6624155811778227, 0.6720203355680392, 0.6739482879964865, 0.6783034951650766, 0.1170045023901326, 0.0911058159765622, 0.1367260999758091, 0.1208615484118325, 0.12498050423291829, 0.14337330826485872, 0.1276388512584652, 0.12442456512428812, 0.13101503872233677, 0.1370009711640079, 0.15583817460181926, 0.1522467217431025, 0.15806115177914237, 0.14577299065190896, 0.14149522560518912, 0.15556198864716075, 0.21180174352203907, 0.1704005948375632, 0.45242858750905146, 0.46788492956196936, 0.47992940189804545, 0.46584471243821457, 0.4618795480456904, 0.48292324315145174, 0.5558986899659513, 0.5948502296266582, 0.5240104899528433, 0.290084480986031, 0.35085637572994355, 0.3329675388855019, 0.3199178129341419, 0.2233303661090722, 0.3531401483420523, 0.34293542937628085, 0.3878288471209008, 0.3762452278015136, 0.22498784957192375, 0.2268191519793098, 0.20157034251614347, 0.2094348455459134, 0.2101973523474071, 0.21187870603230452, 0.21341867933943282, 0.19883037867685582, 0.2059581812442257, 0.2243136217074504, 0.6522938939253666, 0.22940963189863717, 0.22913448938400804, 0.23126376802405024, 0.24299727199525856, 0.23866318718530455, 0.36760154182491056, 0.5422379264987944, 0.6724234968699732, 0.18564354616953782, 0.7708246946903424, 0.7773438617450271, 0.48411719939333664, 0.8135634796861329, 0.1663730921672335, 0.18213542973650632, 0.7611142463734828, 0.7749930048280818, 0.6010579610699258, 0.20502122004362766, 0.6018927022031312, 0.19890575828312196, 0.16667491001419366, 0.7519459633757766, 0.2106792595698479, 0.20518076270437102, 0.19624479697448127, 0.1813864849765605, 0.18612028129246017, 0.19010493383837979, 0.17891979610187625, 0.19584676910086185, 0.17914012236735743, 0.18045035912838103, 0.1854223262014253, 0.08318720888930997, 0.0884023337776263, 0.08919316441010394, 0.08799507745956436, 0.09337769243973781, 0.09586168094724945, 0.08773978786813863, 0.0847972184122715, 0.0830658694905726]}, "mutation_prompt": null}
{"id": "aef72b8d-90e0-4f3f-bd01-38f09479df99", "solution": "import numpy as np\n\nclass EnhancedChaoticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # adjusted population size for more diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)  # wider range for crossover rate\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # slightly reduced scaling factor range\n        self.local_intensification = 0.3  # increased probability for local search\n        self.dynamic_scale = 0.4  # increased dynamic scale\n        self.chaos_coefficient = 0.85  # fine-tuned chaos coefficient\n        self.learning_rate = 0.15  # increased learning rate for faster adaptation\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and advanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.2 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification using reinforcement\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.55 + chaos_value) * mutant + (0.45 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedChaoticAdaptiveDE", "description": "Enhanced Stochastic Differential Evolution using Adaptive Chaotic Dynamics and Reinforcement Learning for Superior Optimization.", "configspace": "", "generation": 42, "fitness": 0.3547642833620172, "feedback": "The algorithm EnhancedChaoticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8363962803451105, 0.8253005216109196, 0.8300125152525838, 0.8428330150723348, 0.834800847794968, 0.8338926508016973, 0.8287674264357971, 0.8371689424523758, 0.8283936711320885, 0.7096730934440088, 0.6894426509412626, 0.6953825014601916, 0.6954391836352132, 0.6791682294446089, 0.7021884776134351, 0.6992084117768904, 0.6699218273759907, 0.679755435174431, 0.4008442090453447, 0.3867358255815141, 0.39995379486467586, 0.40121296574764, 0.42689312815068126, 0.44787356943559553, 0.4359353729867601, 0.4098790147924979, 0.5138809899803332, 0.4057173187476898, 0.23049938498439726, 0.2752397130680959, 0.3395384075919956, 0.2349574598208941, 0.1843933718371371, 0.2652726133917649, 0.27300562707123377, 0.2566750291609873, 0.9408596562494117, 0.9655216102894698, 0.9390666881580667, 0.9279052516425115, 0.9410393963096777, 0.922328519933417, 0.9517924314053322, 0.9317876958912369, 0.9135082419730463, 0.4753707547193259, 0.5264077576884778, 0.4229250851096301, 0.4842642410896426, 0.5021438119330612, 0.47289620621401973, 0.44379102691408123, 0.4333304816736646, 0.41378780020877604, 0.7376253025411199, 0.6871721494754227, 0.6422968797425699, 0.762516231013039, 0.7308251646909216, 0.7599771467811777, 0.7283058805777731, 0.7358327843436152, 0.769872846247276, 0.203981768532006, 0.1741631235536657, 0.24934441305932464, 0.2070644803270678, 0.31278674216314284, 0.1961093278304279, 0.20946213962139737, 0.23992269759307194, 0.17866841551387946, 0.16956204652124707, 0.20055090386630714, 0.14140996486320478, 0.1829732182015097, 0.19871387005659624, 0.18981795121103828, 0.19692360239398343, 0.14871671123714314, 0.16735307003254019, 0.06175353166313524, 0.05109170251703743, 0.0627702028847974, 0.014253314380316073, 0.10151895251801146, 0.14288236689397105, 0.047152498055893166, 0.163436685051218, 0.19028057259286824, 0.2402437541141994, 0.18167264487231194, 0.2962023605587062, 0.2820895899941662, 0.1673445087060551, 0.2637496028959795, 0.2913564690119178, 0.30213036785212644, 0.337542774611703, 0.09908805283232835, 0.08361815624951263, 0.10021733328719329, 0.17795846596196352, 0.14459333876757863, 0.1533085906695818, 0.07337466664283399, 0.15863075752383482, 0.20203887866867976, 0.22638486200764696, 0.195977582472318, 0.16647500814435157, 0.2330408309853843, 0.22555350912518835, 0.22584401228961848, 0.1691028645694136, 0.20168180746585618, 0.22106099258685719, 0.5878650048988299, 0.5882157523678284, 0.6011912937895871, 0.6019211962716335, 0.6171858954335502, 0.6276376425345186, 0.6079229220318251, 0.6312041535478162, 0.5868344209842606, 0.13624845183475887, 0.118316031381412, 0.10064338178497201, 0.13369089620391927, 0.10968992504128816, 0.12360677090912542, 0.12794391568467622, 0.09690996121795614, 0.11907279828062312, 0.14977980057353957, 0.15397011286159035, 0.13139013833380053, 0.16896623938274424, 0.1465404182288752, 0.14905639598744835, 0.15923402169110545, 0.17590360860624932, 0.1465227186438337, 0.4251002118446141, 0.45275428150031927, 0.45357081184011017, 0.43479348303548737, 0.4319429085212503, 0.4340573305569738, 0.4476192159821589, 0.482250980478256, 0.47847229252954804, 0.29881591309969757, 0.2875840039269977, 0.2693883116423227, 0.34817092123568305, 0.27107221465674036, 0.30471936641875086, 0.28516065722537753, 0.3512067494420358, 0.2801501001398503, 0.19869291014229717, 0.19434258331881415, 0.20980539380460905, 0.2126168071146014, 0.20168538271739633, 0.21419958935472483, 0.2235477901816717, 0.20450910491282226, 0.22448192946110013, 0.2061425539947781, 0.22459964055780124, 0.39471865851615573, 0.3226162819115178, 0.2643939481315071, 0.2679765636439936, 0.23130666769630048, 0.3226613790696481, 0.539880656119341, 0.4820146964135871, 0.18183304483415264, 0.18108153994097087, 0.4941481908828932, 0.5684461349878673, 0.1973658988293252, 0.18438183738642733, 0.4549095918349624, 0.20528183474123585, 0.3405530656355009, 0.5888666585041981, 0.2103709683474393, 0.20721375121670693, 0.16302216708479356, 0.20475305971233215, 0.20677817944363042, 0.713763972494026, 0.3389422918274828, 0.1848524060851452, 0.18084160978356756, 0.1875103605363354, 0.18387365713276638, 0.1943314281228561, 0.18644115880110657, 0.18884652575421468, 0.1920203205935579, 0.17921982035041584, 0.08772107077118363, 0.0826602247220275, 0.07713649591341831, 0.08426527828310226, 0.08386645366759471, 0.08719646354434585, 0.07545421732919089, 0.08161320370988157, 0.0826855869034262]}, "mutation_prompt": null}
{"id": "e6727630-3181-4272-9275-41a5e3adb5e2", "solution": "import numpy as np\n\nclass EnhancedHybridChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # modified crossover rate bounds\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # modified scaling factor bounds\n        self.local_intensification = 0.3  # modified probability for local search\n        self.dynamic_scale = 0.25  # modified dynamic scale\n        self.chaos_coefficient = 0.7  # adjusted chaos coefficient\n        self.learning_rate = 0.15  # adjusted learning rate\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification with randomization\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    random_factor = np.random.rand()\n                    mutant = random_factor * mutant + (1 - random_factor) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive crossover adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()  # adaptive scaling adjustment\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridChaoticDE", "description": "Enhanced Differential Evolution with Hybrid Chaotic and Stochastic Dynamics for Balanced Exploration and Exploitation.", "configspace": "", "generation": 43, "fitness": 0.38221217396921714, "feedback": "The algorithm EnhancedHybridChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.9005696424401162, 0.889213763533216, 0.8788208124579162, 0.89620691938078, 0.8930180893810941, 0.8928771051601077, 0.8888625730863666, 0.9033889086106818, 0.880887441838638, 0.7755254288378947, 0.7984505063806311, 0.7966211283101942, 0.7885157540660765, 0.7699551678454162, 0.7962362651645284, 0.8001125620332051, 0.8025640460200729, 0.766881543211257, 0.720955658580867, 0.6477571693417802, 0.7338111792084903, 0.6627760104270775, 0.7206891591208804, 0.6725105368262226, 0.14442743381975776, 0.18220405149783303, 0.6114858633308089, 0.1785153993634866, 0.18015975879067758, 0.18262521719350222, 0.6032059298219921, 0.17430144427800964, 0.17522627839488558, 0.13889589648371226, 0.1416945392325606, 0.176167701853698, 0.9696172401141753, 0.9344916751459987, 0.9480572681516333, 0.9345428693509087, 0.9378856642919036, 0.9614535146642433, 0.9291091376296388, 0.9329907265862675, 0.9716054959220886, 0.4078850128405618, 0.6511911841683896, 0.3544729078040444, 0.6152566746640431, 0.5112575548081602, 0.5481314350352735, 0.5605512923892628, 0.4847343041507032, 0.5687523956904151, 0.8434225321761339, 0.7975067884940459, 0.22715742253803828, 0.27988528110001165, 0.27815531130973425, 0.2107972205285339, 0.6362394531972253, 0.8178256658868883, 0.2303557158358771, 0.23420487144180036, 0.1274519949566415, 0.19255585808639275, 0.1842361307697723, 0.24047088705900654, 0.11102567675098673, 0.15678684736767734, 0.476801334673539, 0.2173927319051645, 0.1983153010327634, 0.1441221815163093, 0.23010514809141858, 0.18284559105635922, 0.18137563347548769, 0.17485063357565667, 0.13488569515451765, 0.16516178259313385, 0.1684107468926721, 0.13717974310866665, 0.12075470694251911, 0.07968709494984427, 0.16989767463380978, 0.026263826782381705, 0.05579051473772001, 0.05449117711213691, 0.006974302507509633, 0.09245543506249232, 0.31818342300318514, 0.11554480025023861, 0.23088763329969364, 0.38428096018650326, 0.180454956750143, 0.196318335993804, 0.36104432443131995, 0.2719443391747346, 0.33470703042452643, 0.05394854299453966, 0.08588648146727684, 0.2466912609644375, 0.08521106747883223, 0.0964345470291249, 0.23791187947219516, 0.2002924111753308, 0.1285321275001312, 0.3277877282578263, 0.12307832315204736, 0.10308663457398903, 0.1839732375584513, 0.25156015767988527, 0.2211636994091556, 0.23946252122919365, 0.3244647417834199, 0.22183929124028168, 0.1271899773695886, 0.6543985204331315, 0.6439642940760806, 0.7039997452485416, 0.6278289985316998, 0.7303721767359396, 0.587939892877674, 0.6037736602659283, 0.6374157063399128, 0.6361226727374218, 0.13472696927227157, 0.12515047266884116, 0.14840262900118562, 0.12945643359381231, 0.1713053607488959, 0.09343201030398418, 0.1441393829412716, 0.14794983076967982, 0.12894892978617922, 0.2340318256119963, 0.1837325680307863, 0.2767905562398705, 0.23575305483605313, 0.19570344643991344, 0.16295439583882476, 0.2581350129350922, 0.30969501115847275, 0.2429614266963387, 0.3736881115220142, 0.5683483728324955, 0.563228978549147, 0.42665866757685533, 0.5381903008249975, 0.5715842795019485, 0.5960420038966995, 0.6750352878827339, 0.6837189313616768, 0.21547699930714403, 0.39784973718476213, 0.2429753525259445, 0.3488690624328452, 0.26796587004146344, 0.3353255741233474, 0.2510028487464042, 0.3503536785214182, 0.3989265731253695, 0.2234247216056766, 0.21411014590143906, 0.2205238229696851, 0.20806898783145245, 0.21041428445099908, 0.2219383554262644, 0.21536252886437646, 0.18583782752587763, 0.2288484957554049, 0.22086355773840616, 0.2419256197853321, 0.6967937010481446, 0.20671522574766288, 0.7572430330391908, 0.2081721318484986, 0.7050020498800627, 0.22102898560113138, 0.22675580862885214, 0.8268465492782296, 0.21003008639359522, 0.8890612121742792, 0.19644266603230087, 0.1476831012740668, 0.8208178263796273, 0.8211863306633084, 0.880239082283484, 0.7980556448576688, 0.4799325298157412, 0.16717152939193636, 0.209115153449278, 0.1558064925057815, 0.21254105382330502, 0.15758863640245402, 0.20710027008645315, 0.21123399406631582, 0.6989241012625403, 0.2109277976057924, 0.18325517121262946, 0.19967800455486284, 0.1801753694239997, 0.19498615590728063, 0.173019804315388, 0.18377608451554783, 0.17798529597181845, 0.18522468901762668, 0.08443349548820533, 0.09366478193052574, 0.08295407206414618, 0.08795465101158184, 0.08941470061557066, 0.08637994807243776, 0.09586225360407585, 0.0825524766247192, 0.08263108166393163]}, "mutation_prompt": null}
{"id": "f1773186-d5f4-43ad-b220-ab0dec96d8fb", "solution": "import numpy as np\n\nclass EnhancedHybridChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population size for exploration\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # adjusted crossover rate\n        self.F = np.random.uniform(0.5, 0.9, self.pop_size)   # adjusted differential weight\n        self.local_intensification = 0.3  # increased probability for local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale\n        self.chaos_coefficient = 0.85  # increased chaos coefficient\n        self.learning_rate = 0.15  # increased learning rate\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and novel strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Chaotic Local Search Intensification\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.55 + chaos_value) * mutant + (0.45 - chaos_value) * local_best\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()  # adaptive adjustment\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridChaoticDE", "description": "Enhanced Hybrid Chaotic Differential Evolution with Local Intensification and Adaptive Strategy for Robust Optimization.", "configspace": "", "generation": 44, "fitness": 0.36611657653579677, "feedback": "The algorithm EnhancedHybridChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.25.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8551418506349766, 0.8396299590600252, 0.8433990221469454, 0.8488968737819236, 0.8461890497913636, 0.8517034230496131, 0.8451814364946452, 0.8438592709654363, 0.8629330396695526, 0.70503491132674, 0.7042547361064214, 0.7360648377552651, 0.7118880938650467, 0.7027138763134219, 0.7294631149656106, 0.7216487003975561, 0.7065554719109687, 0.7214804886569595, 0.17324371429914687, 0.4942137896181298, 0.4148947568581244, 0.5773429326454275, 0.5370929549768917, 0.4687753285410753, 0.4152942855911812, 0.4599575611955158, 0.4484605293602334, 0.23860454416971566, 0.28756698768947986, 0.1540322071450071, 0.34392300735122516, 0.32838624736095956, 0.16529367652810378, 0.16157563013362963, 0.26950234116439586, 0.3757927316294748, 0.8860027461938006, 0.9954401506208997, 0.9383616809213069, 0.9300325278457284, 0.893009126228814, 0.9313578888995495, 0.9318375307649692, 0.9218744108392654, 0.9371230361671863, 0.4825308374344368, 0.5370729559671891, 0.4690515136598927, 0.5321478298095352, 0.4881852094097727, 0.42154218116746456, 0.4602856051010453, 0.3520456266287654, 0.44560051123529887, 0.7983263375256864, 0.7530788253522095, 0.21980628472086983, 0.7646282566230174, 0.6907161884911835, 0.78894497308309, 0.7009736438654025, 0.7218059028625565, 0.7881369729635015, 0.17384011299467472, 0.15599554956505712, 0.1642499676721263, 0.19238593174118757, 0.18588490332280105, 0.175597758770067, 0.2659735236224622, 0.1873312832569164, 0.1260498261509574, 0.20955458394687343, 0.17827351343115638, 0.16259665248515864, 0.17355674674357868, 0.13607422903151023, 0.15328902079487816, 0.17750948750909923, 0.191326518656746, 0.17331497675481222, 0.1699892234079613, 0.2098432439748914, 0.16306789763205543, 0.0371170170571028, 0.04552941151693535, 0.05234466312538644, 0.10232189883241194, 0.15435804376534357, 0.14940542484095698, 0.24779556785540946, 0.23877070249720123, 0.28493814782356963, 0.2996289238977532, 0.26414737674740696, 0.21086200450792014, 0.31721936671671747, 0.261592623751978, 0.20407219464574322, 0.183969321649753, 0.1277993428689035, 0.05751240547917369, 0.08194885495968596, 0.12090887335474199, 0.18106553400456316, 0.07706123056759207, 0.17088513042050113, 0.18364117741249786, 0.2787544648160307, 0.23342989713386675, 0.22126220054391887, 0.20715681466264746, 0.22809643371565091, 0.2368050134048394, 0.2281886682703439, 0.22216394620812174, 0.23308757027098193, 0.6774937090525258, 0.6281830396226087, 0.6351149742496547, 0.6229222164581376, 0.614824836303628, 0.6251122437457026, 0.670173683292588, 0.5792874857802219, 0.6406659992563285, 0.12333122204342417, 0.1278493332957571, 0.1139411849555223, 0.12182144920585614, 0.10667912774233446, 0.13124699362995962, 0.11787087169693533, 0.12674116700051852, 0.1423049162111234, 0.14479717651821866, 0.15244632870719033, 0.13976167205012402, 0.17491926469488406, 0.1428988866856694, 0.1304605004013174, 0.17292851101455964, 0.13793608626577603, 0.17117573442407752, 0.47003700554553696, 0.4230855707976652, 0.511201053070343, 0.45697154306364207, 0.4679820569735259, 0.41624727533081407, 0.5085409424398192, 0.5033769099958845, 0.5117873939289674, 0.3528340175707122, 0.34630096020254975, 0.33722621502120087, 0.28383535822324324, 0.33448648389835434, 0.3197984988948591, 0.22164264846111514, 0.37521521786558587, 0.34907107855285724, 0.20727542506812568, 0.217602361381926, 0.2135376045291829, 0.1981986797990536, 0.21034395173212395, 0.2035702281091698, 0.24269392563111147, 0.22599387727702835, 0.20356843345239384, 0.2296859805752155, 0.5590563771203851, 0.24630565615031597, 0.5108291765059148, 0.21284649426048685, 0.5083495910391861, 0.22497631588240874, 0.2142081968452918, 0.41193201566842585, 0.8080753762079226, 0.751312938766765, 0.18493416443061528, 0.18050726917820903, 0.7095845556200154, 0.18945689703314839, 0.18242939201314723, 0.18460565844062093, 0.16553138623533614, 0.4381009154583325, 0.4970916810343856, 0.20671087499595464, 0.5831151707372213, 0.44518359127057583, 0.1659361011164998, 0.21267313255659726, 0.7026015444293153, 0.5437896539571679, 0.19852143035222947, 0.1796809065552124, 0.20102155353409246, 0.18601230267235058, 0.19987618828157694, 0.18503267745793683, 0.17957077173449798, 0.1980997404858409, 0.17620174444345016, 0.08595843242549706, 0.08953317772854807, 0.09349849010131439, 0.08082085993473942, 0.08730431170891972, 0.08455919036717807, 0.08448248376921197, 0.0781449087323075, 0.09826258647305985]}, "mutation_prompt": null}
{"id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.35  # increased probability for local search\n        self.dynamic_scale = 0.25  # adjusted dynamic scale\n        self.chaos_coefficient = 0.9  # increased chaos coefficient for enhanced exploration\n        self.learning_rate = 0.15  # increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # added memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution Using Chaotic Maps with Temporal Memory and Dynamic Strategy Refinement for Improved Convergence.", "configspace": "", "generation": 45, "fitness": 0.414151335995919, "feedback": "The algorithm EnhancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "4cc2b173-163b-4aa5-9256-97f3d2a712be", "metadata": {"aucs": [0.8751462238744626, 0.8615447916498322, 0.8655688382313971, 0.8671698955976732, 0.8706668836575506, 0.8682744231031467, 0.8796592620385539, 0.8762687240409975, 0.8676790956815885, 0.7550501475506002, 0.7529218009738218, 0.7563710130449893, 0.7742863240103939, 0.7553654178433253, 0.7437312008888399, 0.7480084022395668, 0.749621127796825, 0.758583879721799, 0.4764999912390109, 0.4740485159886244, 0.5184214087414922, 0.507678395079189, 0.4993935348058327, 0.476567888949996, 0.5162679579313817, 0.4563093307206021, 0.47304454540550833, 0.14486392683646188, 0.4321436628293459, 0.1669729355450239, 0.4368892463345283, 0.37843965596086115, 0.1625284894458071, 0.1625159517074033, 0.1651110818453626, 0.4315048013376248, 0.9738603392941044, 0.9368834691056003, 0.9829761346292197, 0.9513066825952179, 0.9626904540374818, 0.9573010949472289, 0.9775167702197773, 0.9792956887877468, 0.9648217227626626, 0.6027289373194258, 0.6111705549523636, 0.5982152567530676, 0.6451061515474152, 0.6356905764832683, 0.5679412071433727, 0.5666322597532725, 0.5686575464005277, 0.5710245460998202, 0.781544583288611, 0.7847018557860265, 0.21835033698206008, 0.8419981415590678, 0.854326387394188, 0.7976322237358899, 0.7760699001125922, 0.8046704709123431, 0.8192149467464065, 0.44496436685768215, 0.22187975351853406, 0.22040849093811643, 0.3383013999352341, 0.4338907229892165, 0.21469594078843424, 0.3530662597346489, 0.441701563551375, 0.29033344833888786, 0.25918779083047916, 0.26080601406156, 0.22456245331248925, 0.3852039873976981, 0.3832116011156691, 0.28450662780922964, 0.3094638951974551, 0.24220145796206116, 0.20109846675877863, 0.21370720642581942, 0.23544342982823896, 0.21939583176805544, 0.2696609035855937, 0.1767541150842662, 0.14197653903681207, 0.2263382932387028, 0.16060476972114535, 0.22870261695317162, 0.3000875046370024, 0.30332212839869555, 0.3867821642581549, 0.3425336926618259, 0.3381337524718635, 0.30034442423533414, 0.33373224363544773, 0.43454394068218083, 0.333457364510624, 0.06372089964404326, 0.18966508557956663, 0.05069968926070667, 0.14878617463531463, 0.23679163709530127, 0.12235278073738387, 0.07502130961151976, 0.18015149003619357, 0.18712821205568253, 0.2918947517952988, 0.25051485279492103, 0.261319445264918, 0.30172203815743004, 0.3023519203488524, 0.29401757278995666, 0.25411640304356053, 0.22978380308813895, 0.24310528924139918, 0.661093446224694, 0.70527560489247, 0.6717040696759828, 0.6810068501655866, 0.6739803326514475, 0.6738104155061655, 0.6903953657619952, 0.6908110921193673, 0.6530836105746185, 0.11205771261117592, 0.1129958839248133, 0.11459979740173531, 0.12009149615775094, 0.11705860859653894, 0.14269706454972197, 0.11743580735351189, 0.13456934791990083, 0.10914807955382733, 0.16506683692927904, 0.15896905947725792, 0.13995085541153474, 0.13780253842021462, 0.13576688521089997, 0.14678489973025555, 0.18354921980013805, 0.1648337711723873, 0.15023215710442106, 0.5225457197911699, 0.45680082065282523, 0.5088098460713394, 0.5056799088204913, 0.4817586742220724, 0.5288656287384148, 0.5469482426716621, 0.5831648500779713, 0.5945758702380086, 0.27993847306159503, 0.308311637175544, 0.35427358864586755, 0.34484160699542243, 0.3581864690106108, 0.32689011169591453, 0.2651716675576069, 0.38339664560132036, 0.38763230794888237, 0.20372892464069547, 0.1922974452339986, 0.20360609738369984, 0.21559628233875494, 0.22410132462705157, 0.21292637970012573, 0.24118592751594092, 0.20426719800540638, 0.25186314850823777, 0.5255139459329365, 0.2401767673860763, 0.5763090172291238, 0.22897969308378985, 0.23065833373872757, 0.38272649605267095, 0.5405801629087105, 0.5400671208486515, 0.21948558121237416, 0.19009112580699683, 0.18700500651131013, 0.18472281857324613, 0.8116973391107587, 0.17632488347351571, 0.8670612993047824, 0.8184475460554732, 0.1750533732027434, 0.4436550455595324, 0.7682202271030227, 0.7549790925113905, 0.6942763778771341, 0.7066094120074125, 0.15338314756670401, 0.7262505778496848, 0.20635386204540074, 0.2109472654090837, 0.7910877444918637, 0.1927834511285792, 0.19267731832017276, 0.184710886755172, 0.19711018265239744, 0.19171332578346278, 0.18894588447973248, 0.17898709723546413, 0.18202386521160685, 0.18381680218871121, 0.09097268960470906, 0.09036632573864845, 0.08618367681785477, 0.08975560561922613, 0.09002849792188738, 0.08600890829948016, 0.08617607506172664, 0.08820311615540088, 0.07783046805397265]}, "mutation_prompt": null}
{"id": "a9d39c0c-5e80-4267-9d65-6d75a1099140", "solution": "import numpy as np\n\nclass OptimizedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population for diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # adjusted crossover range\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # refined mutation factor\n        self.local_intensification = 0.3  # slightly decreased local search probability\n        self.dynamic_scale = 0.3  # refined dynamic scale for mutation\n        self.chaos_coefficient = 0.95  # further increased chaos for exploration\n        self.learning_rate = 0.2  # adjusted learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)  # sine-based chaotic map for richer dynamics\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (0.9 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (0.8 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "OptimizedAdaptiveChaoticDE", "description": "Optimized Adaptive Chaotic Differential Evolution with Enhanced Strategy Diversification and Memory-Driven Learning for Superior Convergence.", "configspace": "", "generation": 46, "fitness": 0.29098874482515275, "feedback": "The algorithm OptimizedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.7863202145826294, 0.7688559803463801, 0.793018566863467, 0.77213152818423, 0.7831928590646081, 0.779073027942399, 0.7622647440638188, 0.7875347801535094, 0.78187211088117, 0.612181058360044, 0.596453196646797, 0.5839857199873708, 0.60003687819573, 0.6015835136352088, 0.587899570864672, 0.5991464652507725, 0.5930127269401426, 0.5903871054890839, 0.2161947914386425, 0.3332898082616692, 0.45173558189857843, 0.2463561969689113, 0.2863450926489636, 0.31021161090876936, 0.3349294797596436, 0.3506591075132831, 0.3586291620466344, 0.3232904931642776, 0.1937443264116807, 0.24414927429164168, 0.21272461014325472, 0.25866618864170765, 0.15458187860018202, 0.15432884994708762, 0.23815161469421597, 0.22818119918446134, 0.9173916309648834, 0.9751398262495626, 0.9232441646793352, 0.9804145683443893, 0.9268632148058757, 0.9601638921453216, 0.9629521719615463, 0.8973186981933157, 0.9422908212656382, 0.3376913981633316, 0.3259282354839005, 0.32417587326683683, 0.3338685431704965, 0.323150474976837, 0.3320389989276804, 0.30851472881803144, 0.28520147466644963, 0.28933457154685616, 0.560497063128258, 0.5253354095343943, 0.41863694666723616, 0.5953773270764042, 0.3885058324613536, 0.3889619798530731, 0.5010075206265371, 0.47936656899355967, 0.6636386326284527, 0.1558334769913743, 0.13780029335914623, 0.16510488400173107, 0.16407438726476697, 0.17185863198073692, 0.11982037108874943, 0.19713713840431335, 0.20233930583434023, 0.18228505337652867, 0.11228299609977987, 0.14853009123562877, 0.1522447759200335, 0.1658247714162988, 0.18759588118241122, 0.1332417875482408, 0.09459494825463621, 0.14462557025329625, 0.16537467831163544, 0.02817269871822814, 0.020741965452911626, 0.024529925019576182, 0.01637899491399275, 0.008811790237566286, 0.011116104513501535, 0.03580150510178004, 0.04616326892615141, 0.015277729269856932, 0.10522858383844214, 0.14345512902322466, 0.1101654941967043, 0.10777038195594812, 0.08046871361699537, 0.12279452740155028, 0.12802463810442877, 0.15943481078865518, 0.15464460043726835, 0.011936796543893458, 0.032682355692318366, 0.03447874134825668, 0.006437287112069812, 0.04544922854060207, 0.014442086233991014, 0.026201482533276255, 0.02364664515316328, 0.0357319777558921, 0.131850704266801, 0.15633557798535347, 0.12868750456934253, 0.1672683146156353, 0.1610098533005927, 0.13715853142338497, 0.14376326084410884, 0.1437088944744952, 0.12420271877001121, 0.5097834964493778, 0.4892590610172456, 0.5307656576701759, 0.47941081900222093, 0.5188394312528528, 0.4946518862379047, 0.4984127538306572, 0.5175536597356509, 0.4941381788537076, 0.11059586911029329, 0.10838339175099787, 0.11886010456248475, 0.10585794744542021, 0.11665383059925338, 0.13190774503763858, 0.09722269728129518, 0.09805659304160796, 0.10411723004395501, 0.14201083593261576, 0.15169431534053224, 0.16963189472303186, 0.1446229286065116, 0.1473031034310327, 0.14667173400057676, 0.17037319050330102, 0.15310927374885885, 0.1467341930763003, 0.325596269991852, 0.3435485040621712, 0.3319669718452045, 0.3409649968326768, 0.3501385163174313, 0.34502429711928384, 0.36149710218159037, 0.3871960082182089, 0.40172771315284594, 0.24823196844564477, 0.21656009430447465, 0.20940950068546316, 0.255640611096023, 0.22690778967716407, 0.23679583110305846, 0.24844333973483357, 0.2693473941341644, 0.24600143857209833, 0.18902847936277756, 0.19368537115236173, 0.19306957300548588, 0.22702999488875353, 0.18776451389546023, 0.18886267522677813, 0.20988457719192288, 0.22070106527874722, 0.2142543633348195, 0.29344781743469206, 0.23287477226827624, 0.19985397258666793, 0.19884847474782597, 0.2063647961571513, 0.23214320236569586, 0.38226486792517334, 0.31574120592529276, 0.2265990674261319, 0.37314516550438814, 0.24974222439466542, 0.29642230106340217, 0.2929774931475294, 0.5250173280031947, 0.4687415395329865, 0.5791380597929698, 0.29223347688200396, 0.18532331621546805, 0.19651538453869766, 0.16386774051308406, 0.2661784125091172, 0.15922931855865785, 0.2237331178570977, 0.18282648247583755, 0.20502527348995903, 0.3135476078429005, 0.3048300318868119, 0.20175885997857845, 0.18621978130473416, 0.1732197949066976, 0.18889333398826091, 0.17820789224493505, 0.19724109434058168, 0.19030039731041748, 0.1749925210789074, 0.19228480091035605, 0.08137513965467513, 0.07054193675975107, 0.10132680174185993, 0.08524856309616502, 0.08087537814914048, 0.08845184353832214, 0.07725818738648582, 0.08476982641783248, 0.08139774750399642]}, "mutation_prompt": null}
{"id": "7bed6e45-0e6e-4ae0-9c21-d09e66794bdb", "solution": "import numpy as np\n\nclass QuantumEnhancedChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.40\n        self.dynamic_scale = 0.30\n        self.chaos_coefficient = 0.7\n        self.learning_rate = 0.2\n        self.memory = np.zeros(self.dim)\n        self.quantum_perturbation = 0.1   # quantum-inspired perturbation factor\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_operator(self, x):\n        return x + self.quantum_perturbation * (2 * np.random.rand(self.dim) - 1)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = self.quantum_operator(mutant)\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumEnhancedChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Quantum-inspired Chaotic Perturbations for Superior Exploration-Exploitation Balance.", "configspace": "", "generation": 47, "fitness": 0.27769876540212757, "feedback": "The algorithm QuantumEnhancedChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.5363843652059775, 0.5398816748073186, 0.5550993544307277, 0.5475958674667523, 0.5399696181063467, 0.5300605937334465, 0.5157994767006477, 0.5346455301913589, 0.5419805508541589, 0.164681947162172, 0.17927737282338096, 0.23189467589106394, 0.19155339673251615, 0.17328600941787387, 0.20058226448203598, 0.19433553584145524, 0.199410250580364, 0.20344126294775966, 0.2068612017140905, 0.21162204705013898, 0.1800889058784032, 0.20816631310756406, 0.17515232590952257, 0.18749570878568533, 0.20796265267014147, 0.21292897022773882, 0.2138166507642929, 0.15501761561854532, 0.17792781928982004, 0.16665389534440933, 0.1424876772390904, 0.14071283245326016, 0.14377497895477076, 0.15300440015205585, 0.1409052944178184, 0.14403234616649407, 0.9826360179215856, 0.9776751283252836, 0.9517066576240325, 0.9598970967677086, 0.9669740033140016, 0.9834996735781713, 0.9744592153546702, 0.9636775916366866, 0.9899639677101696, 0.31484767806901637, 0.33845190089031896, 0.3356872696337089, 0.3591591165600284, 0.3350289294356862, 0.32724894414633665, 0.32701909044797106, 0.32297075295805355, 0.3391319350884624, 0.6819308976812057, 0.7076366911065672, 0.7408378253272736, 0.21014574343589265, 0.6556562721670238, 0.2725389347662873, 0.680069728029089, 0.7811212785541387, 0.7155288595520604, 0.15983698437422666, 0.18676065811405407, 0.1689556494017852, 0.16758821269291746, 0.15873600521296305, 0.17214213124225952, 0.17561667833750594, 0.17175390081571384, 0.17778569431234814, 0.17099942837649285, 0.20602246161817406, 0.15498891680186644, 0.12624889734159606, 0.1785140337302551, 0.17090164929572638, 0.19954696100495672, 0.16791621350065855, 0.17977791950342725, 0.04292610430802801, 0.02580237367142435, 0.020733992051580552, 0.02022090850509961, 0.014434759070335312, 9.999999999998899e-05, 0.03589082858331416, 0.004114462078301906, 0.06651072638358624, 0.14439292690917316, 0.126256076455442, 0.1087316071927622, 0.11381081768968981, 0.09228178313628055, 0.1318086441266456, 0.17725327775996935, 0.17132423936326746, 0.12531940953847953, 0.013562550129747053, 0.010259245753018842, 0.00040363305073110034, 0.029635786575966105, 0.006232924282652874, 0.003570404789135506, 0.0030455575389499723, 0.010787969469619574, 9.999999999998899e-05, 0.10974674573961452, 0.1459443334915328, 0.14135554425854757, 0.10656263842564728, 0.13593485353571144, 0.12598628200624684, 0.1297334046694063, 0.13080607348018436, 0.12311724176645533, 0.46042036280964505, 0.4571453528109791, 0.449930904112556, 0.47337453234842597, 0.4689411237179949, 0.4865020731363774, 0.4646410085939787, 0.44765862195174677, 0.46082025020768924, 0.12312729295114533, 0.12689160448834502, 0.09724514494559333, 0.11766927095677582, 0.10792096396064466, 0.12921708008297372, 0.11635073557595044, 0.12876397250196003, 0.12012450305971067, 0.1559269528271654, 0.1561864066376445, 0.13814710630451377, 0.15247962767450374, 0.23237330507821286, 0.14157977447641568, 0.1585183117660134, 0.15511344262150217, 0.17306819648093186, 0.3276977958892705, 0.32482435786462915, 0.32984460489996714, 0.32525843867743065, 0.317217573493611, 0.3485437268026611, 0.33316426848061154, 0.3329891703753556, 0.3304702916737612, 0.24785491689505157, 0.24064696720995526, 0.262521855955671, 0.25229147083097836, 0.2518859138736226, 0.2671851776772518, 0.2664708155728229, 0.25698988611044504, 0.2658088550694616, 0.19661138266926814, 0.20775354105185673, 0.1922493456901193, 0.2155156423460034, 0.2332842220041501, 0.23853279419026885, 0.23769380592634692, 0.20816413259436517, 0.20541277182667905, 0.3017611759748562, 0.28603502246931456, 0.296185221526571, 0.25598462116650555, 0.2867047557607091, 0.3099444614385207, 0.3056264529568833, 0.2925464599340558, 0.22001880991688172, 0.6640216448091367, 0.6288400895777901, 0.7880554495992718, 0.665072194376384, 0.679496071068028, 0.7775149227847866, 0.16517981203920262, 0.1809792334990863, 0.21000942066019357, 0.5769136372769338, 0.6168778849265949, 0.20336434869018105, 0.5878623560969161, 0.37161802674882194, 0.20750889487761692, 0.21112088211743774, 0.5218350145690822, 0.20819196200658618, 0.18752117514560473, 0.20717626405850054, 0.17849180699759348, 0.18264688790363326, 0.20033500482954014, 0.19349032158299073, 0.1887973481528925, 0.21501008616242556, 0.2150217902096322, 0.08077742078328976, 0.086151128782337, 0.11013345832767796, 0.08782373046409497, 0.08472226755982537, 0.09077290658545312, 0.08909193985590103, 0.08160759223820191, 0.08028861795649156]}, "mutation_prompt": null}
{"id": "a20baa47-e743-414f-9d8c-33efea547821", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population size for better diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.30  # slightly reduced to balance exploration-exploitation\n        self.dynamic_scale = 0.3  # increased dynamic scale for more aggressive mutation\n        self.chaos_coefficient = 0.85  # slightly reduced to fine-tune chaotic behavior\n        self.learning_rate = 0.2  # increased learning rate for quicker adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Memory-Based Chaotic Exploration and Dynamic Intensification for Optimized Performance.", "configspace": "", "generation": 48, "fitness": 0.3580333851079519, "feedback": "The algorithm EnhancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8416839113427367, 0.8296412171984212, 0.8261830489739947, 0.8290952624153624, 0.8292486598125495, 0.8366459867643468, 0.8341305214830874, 0.8185085920412958, 0.8372938790207034, 0.6718318066627542, 0.6730681804677119, 0.6708733205220987, 0.6780781759248871, 0.6799554625175497, 0.6958104553488449, 0.6783724896061589, 0.6978494021265229, 0.689451008606343, 0.3501135827370552, 0.44862772835549436, 0.34325786033970906, 0.4038051253022652, 0.3562107686817081, 0.4021282150053981, 0.161785002076682, 0.40178954294080993, 0.3802902649489065, 0.15511411030600297, 0.2074011969012085, 0.2826712609946894, 0.19449591174292558, 0.24341668610655887, 0.2096242583096427, 0.24679417248277347, 0.14721567825935722, 0.2234843603497818, 0.9410323550904949, 0.97489557677656, 0.9525932292707764, 0.9453366012654916, 0.9562577924919426, 0.9665369919654538, 0.9329199483535917, 0.9267881540375189, 0.9499620126551991, 0.4885733308849485, 0.4371673595570118, 0.5082549067654258, 0.4710514710563083, 0.4348435841626288, 0.4945274785340166, 0.45763081841088915, 0.4168576626237718, 0.4470228267412807, 0.6978443431288053, 0.6609862525555048, 0.691935070041293, 0.7708640012436306, 0.7499572286777196, 0.6197177648583754, 0.7055977592105328, 0.6784017124058406, 0.6817189712311299, 0.1889015638624153, 0.21234253367803646, 0.1656574737802905, 0.1926093844601352, 0.1976713712126622, 0.19048030690168338, 0.2331835436384686, 0.2095723778657027, 0.19588862593162715, 0.17918665503857334, 0.15864385907584944, 0.1952125936196114, 0.19546718795146711, 0.17955161814911358, 0.3231923462959376, 0.19449826852191032, 0.1802730006666985, 0.17411522903401633, 0.1537487961565388, 0.1128537283687181, 0.15936555791284013, 0.0864015262928175, 0.12330039172748308, 0.1084570087560478, 0.1330725837811948, 0.1078554347330386, 0.13278174874175164, 0.23466938769747636, 0.22945950062107, 0.24507772849370535, 0.2435302703505673, 0.2336029975557563, 0.255358836405967, 0.24290416343484544, 0.2610646232814816, 0.28484476973219075, 0.12619445409232954, 0.05822135642528303, 0.09369290114409923, 0.11213111735684689, 0.07024581935958396, 0.09547776166699062, 0.1745537060567678, 0.13460960513653664, 0.1332571168230141, 0.2235283117210991, 0.20284684796332864, 0.2207856569949036, 0.23997701244181557, 0.21792529213059375, 0.22311211573840117, 0.20916360853092653, 0.19828879198418936, 0.20670223516118136, 0.5950781703877273, 0.6010946193952555, 0.5939037598623469, 0.5832148973486078, 0.5861080819429364, 0.6040823393838552, 0.601189134749227, 0.6012038870121752, 0.5996817513343237, 0.12002245921235333, 0.1133955391628344, 0.09946347309771153, 0.11045595556655119, 0.10459654450494293, 0.10732210635944517, 0.11736855882169916, 0.1051054873188354, 0.11174003882815797, 0.1506000994349641, 0.13054762603997117, 0.1607801376054946, 0.22563714546031932, 0.12254414413248105, 0.1543949176349535, 0.23957408660913793, 0.14529929279640819, 0.1399059250404835, 0.4255720440912032, 0.4025834682614733, 0.4450642908889436, 0.4017878465365019, 0.4569997500528695, 0.4086139466895, 0.48374681388863117, 0.49048595395564254, 0.49535988929787234, 0.260629363138542, 0.28896023272630744, 0.2426960504517549, 0.31142064911641787, 0.2926011175097345, 0.29886595899026247, 0.29322156919299047, 0.3204138412495483, 0.2174588122839919, 0.21030302363387887, 0.19435385800535132, 0.2045925786458671, 0.21586988670291607, 0.20576135853456734, 0.20663848726828926, 0.20699627781570906, 0.22338775332374716, 0.2632903514987689, 0.2825853996903277, 0.3665392628166194, 0.196489294842626, 0.3478269667948768, 0.26829248036396025, 0.2525877548729891, 0.27069595150861825, 0.23278985427099685, 0.40854856256047134, 0.7935284688040702, 0.1823677511011721, 0.17987633134569336, 0.6524662174606908, 0.7001253869296009, 0.18766897644596037, 0.7676624276767172, 0.6857419401663548, 0.68711127889696, 0.20073072341231668, 0.6346157630444667, 0.20646254763391103, 0.257732502693909, 0.1983573439587688, 0.20182515605495077, 0.5988205131304225, 0.6414548346829233, 0.62505517785797, 0.1832627272613121, 0.18538390867242305, 0.19241445972102167, 0.17413030804994867, 0.20662074327524838, 0.18706499715983393, 0.16966899499053112, 0.1965774128301544, 0.1794613106017181, 0.08178959568282318, 0.08399120275032435, 0.08736926020184832, 0.08549956731996278, 0.07450764726398762, 0.08520487638989815, 0.0834619281126816, 0.08655255791120131, 0.0815724481818012]}, "mutation_prompt": null}
{"id": "4238165a-f85e-4e6b-8939-7a7d7f19af02", "solution": "import numpy as np\n\nclass QuantumAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 0.9, self.pop_size)  # refined CR range\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # refined F range\n        self.local_intensification = 0.4  # adjusted probability for local search\n        self.dynamic_scale = 0.3  # adjusted dynamic scale\n        self.chaos_coefficient = 0.85  # adjusted chaos coefficient\n        self.learning_rate = 0.2  # adjusted learning rate\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_perturbation(self, position):\n        direction = np.random.uniform(-1.0, 1.0, self.dim)\n        perturbation = np.tanh(direction) * (np.abs(np.random.normal(size=self.dim)))\n        return position + perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory and Quantum Perturbation\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                    mutant = self.quantum_perturbation(mutant)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumAdaptiveChaoticDE", "description": "Adaptive Differential Evolution with Quantum-Based Chaotic Perturbations and Memory-Augmented Strategy Refinement.", "configspace": "", "generation": 49, "fitness": 0.2984400583251794, "feedback": "The algorithm QuantumAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.7659786317790003, 0.7596796968995342, 0.7426075601625872, 0.7557974814888271, 0.7467871114755676, 0.7447204708269554, 0.7317329495310728, 0.7472358396167498, 0.7522393942180752, 0.5153681777326731, 0.5025577942393056, 0.4708814757655032, 0.506761569489078, 0.4800941189297755, 0.5260145020046172, 0.5108292010215083, 0.4482267781198549, 0.48856640772077764, 0.27694739350667463, 0.2689857877427665, 0.24729597144283966, 0.23235093138785645, 0.22352003528478248, 0.28372961141584285, 0.2556002698663711, 0.24382165157068125, 0.25509777672221634, 0.187881263853797, 0.16480842495542258, 0.1601912947967441, 0.16272660380226156, 0.16537571480205915, 0.19041912777303283, 0.2534046016252536, 0.1713909297267513, 0.203341408160842, 0.9796810823551125, 0.9815485166749973, 0.9780316586708154, 0.9633258310876538, 0.9714451207644436, 0.973747439106317, 0.9652977520067767, 0.9744003917932026, 0.9790643867708093, 0.3207798918109219, 0.3241221945874939, 0.3350671403885346, 0.349951428923195, 0.3467943913248974, 0.33571844517817573, 0.3192971618458126, 0.31113415984385673, 0.30213295042666355, 0.6244696444297565, 0.451127421778719, 0.5811382272984742, 0.6965675274417407, 0.46942667198354204, 0.5830083518931728, 0.5205873752592823, 0.5702858332075077, 0.6705432114411845, 0.17751444811200057, 0.23965754533803707, 0.16067556490944646, 0.16903317965569165, 0.1707970459838598, 0.1587462445709652, 0.1736433978334293, 0.16545037023605913, 0.1688958663575547, 0.10806666683128696, 0.17473988213890157, 0.17569000983270633, 0.16109131938243482, 0.19067377022354248, 0.16819889957711986, 0.21377603287918812, 0.15822612752783516, 0.15069686983600894, 0.04529529818117206, 0.011891113318703406, 0.0002466642635390315, 0.0760034208023046, 0.051701521544890605, 0.028527925629628914, 0.045329238571641506, 0.028813182238316415, 0.0511865071005948, 0.16782171203695362, 0.1457989137874407, 0.0969477036977614, 0.13496363408502143, 0.11786933208288952, 0.14318376548172562, 0.20263920429586513, 0.1758816657225616, 0.13600042139492363, 0.017795497015556383, 0.03670298596496646, 0.04358659917816765, 0.03135522587428263, 0.013509264309997882, 0.06058680918203552, 0.02485518008088272, 0.05778067600988468, 0.048965967255597764, 0.12257790500419907, 0.14072060641026496, 0.135260280159604, 0.1516274196946531, 0.14174612822579002, 0.15907029796582794, 0.11989676132086258, 0.13937689197350067, 0.1119480493037659, 0.5014382057666783, 0.4964663556558202, 0.49809633085629423, 0.48632401358686017, 0.4925970314631576, 0.4782124401484602, 0.506720144653954, 0.4856790450980374, 0.5203885141051969, 0.11317536594106603, 0.10808851806178277, 0.10779969216553487, 0.11045908991147413, 0.1085981771595963, 0.11773827864893283, 0.12045601232922376, 0.12192309747381258, 0.12418891470557569, 0.16623565915285454, 0.13693126516525878, 0.15027076141977336, 0.14928010502930178, 0.13719069074871093, 0.16326975468398197, 0.15098025009357752, 0.16448644079570585, 0.14212673680931331, 0.3193608339211672, 0.33976559794638983, 0.3261537909368998, 0.2987277764140198, 0.34978876207815435, 0.3349239031790884, 0.3971649476989081, 0.38883328667715755, 0.34107949392024206, 0.22942299539937872, 0.24181245930452666, 0.24714511485700885, 0.23555341294460497, 0.24150529949322785, 0.2625809624688119, 0.2450192419857221, 0.2270810350922955, 0.22449264638722188, 0.21332014533103005, 0.2041392141605337, 0.18672813089263596, 0.19674588951494854, 0.20660309573495939, 0.2529173814174055, 0.22253516580588428, 0.20188489886093286, 0.23926430435548096, 0.2577589668260717, 0.24335785044117053, 0.21918049698249908, 0.22438454336534608, 0.25163256611405205, 0.23812614805170074, 0.2214824032710473, 0.21384115735061338, 0.22258780346000628, 0.6884305786706911, 0.18550492330581825, 0.1846093648616416, 0.16269580245511628, 0.6976263184019764, 0.8060559762599412, 0.1669787423442587, 0.6366453614316488, 0.7691318342447965, 0.5160549842929208, 0.20587994077759486, 0.5622288825697134, 0.23978647146089493, 0.3186985990919661, 0.1680578729301404, 0.2112828581055728, 0.5128756367015008, 0.5088152655522886, 0.1902796191707321, 0.20303647179227868, 0.1794148452790858, 0.18092485850409, 0.1738239825432103, 0.18152192997369798, 0.17777625773359518, 0.1774219505342548, 0.19012176208570186, 0.09888338849323497, 0.08712284974074558, 0.09682481915579177, 0.09025881132398317, 0.07546372847650729, 0.08691115713841369, 0.09946350987642216, 0.08960124628355848, 0.09212020426131551]}, "mutation_prompt": null}
{"id": "d1c75e48-0db9-4e60-ae86-70d1af249a4f", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population size\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # adjusted crossover rate\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # adjusted mutation factor\n        self.local_intensification = 0.4  # increased local search probability\n        self.dynamic_scale = 0.3  # tweaked dynamic scale\n        self.chaos_coefficient = 1.2  # enhanced chaos coefficient for better exploration\n        self.learning_rate = 0.1  # adjusted learning rate\n        self.memory = np.zeros(self.dim)\n        self.quantum_influence = 0.2  # added quantum influence factor\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)  # changed to sinusoidal map\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Quantum-inspired local search\n                quantum_effect = self.quantum_influence * (np.random.rand(self.dim) - 0.5)\n                mutant += quantum_effect\n\n                # Enhanced Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumInspiredAdaptiveChaoticDE", "description": "Quantum-Inspired Adaptive Chaotic Differential Evolution with Memory-Enhanced Exploration for Robust Optimization.", "configspace": "", "generation": 50, "fitness": 0.2549660212218238, "feedback": "The algorithm QuantumInspiredAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.5653918146178136, 0.5406251961900781, 0.548316509748269, 0.557525958807389, 0.5411698681221095, 0.5642262172455796, 0.5686429730058651, 0.541288796375734, 0.5710830758513525, 0.21607266735515385, 0.1746840836002742, 0.20478315970658711, 0.19353615610560515, 0.20876786164440586, 0.1873459706987446, 0.19935794049431688, 0.19041552489028857, 0.1993184523888769, 0.1816761116876432, 0.17595214598898878, 0.20227009294124176, 0.16188683855475916, 0.15178533740769362, 0.17447998807826914, 0.1801563687433394, 0.15319230032167175, 0.14306957805534348, 0.14612155078128786, 0.14757508026557642, 0.15876675735480295, 0.13827412228974267, 0.1324456935386692, 0.12970418272449946, 0.13515813880817296, 0.12716655736513638, 0.1489571778344445, 0.998122140599909, 0.9941673819459287, 0.9706704261286265, 0.9913571334397827, 0.9897095809901089, 0.9872232701179623, 0.9913499780962254, 0.9864181936173457, 0.9838875930784559, 0.32353313037820985, 0.2977992583991551, 0.3385274923605077, 0.2933117075492584, 0.27543254846612786, 0.30171692836752984, 0.29523844430765, 0.2613589206857442, 0.29438056941290613, 0.54519944037729, 0.48883612671738175, 0.5514134099004878, 0.4651240875154645, 0.6057662591779558, 0.5160530372464722, 0.4954660369595102, 0.6268216831593381, 0.604916634801206, 0.16325349289611335, 0.16416895257697484, 0.17128011519177921, 0.19210254205796318, 0.17627397208266649, 0.19127079888970988, 0.17565558698039752, 0.17712062598094414, 0.18959124943725147, 0.16851714577949073, 0.19364617712120635, 0.17215971315623213, 0.16270026873616028, 0.17645412362775192, 0.17134171646527663, 0.18368922982217806, 0.14422952464998873, 0.1926162442288022, 0.024453432355754368, 0.023606793613196397, 0.03352898983510799, 0.010360376859228526, 0.003195663293480533, 0.04716128717199486, 0.0324039154327187, 0.10911678842185302, 0.015667017852585507, 0.09405451944606191, 0.12405197223788822, 0.07788431675103658, 0.0788557968357696, 0.09480872598439927, 0.08209161824966738, 0.1239689025901507, 0.09019995685813242, 0.13622041913850225, 0.01204107236424734, 0.02982774553084311, 0.028549854598182045, 0.019944998482007925, 0.015669177425486458, 9.999999999998899e-05, 0.0006167102285234982, 9.999999999998899e-05, 0.00456607401374054, 0.12739091944189784, 0.1200518563327716, 0.11732456657546175, 0.11999968984411591, 0.13687581868314103, 0.13875779268765187, 0.12447064793666829, 0.11511535211517243, 0.13507972501696008, 0.4673438990849581, 0.46377930225643305, 0.47006151285002173, 0.4634044993434786, 0.4946800638452963, 0.5100332916849024, 0.45511985646870623, 0.45692828024040477, 0.4537867257585173, 0.10588244435179495, 0.11934800956692615, 0.0990874011398879, 0.09609262583806544, 0.10014482043084338, 0.10635392028419921, 0.09371678125461436, 0.10467804016155968, 0.11643279020338448, 0.14841519605541076, 0.20905094953528236, 0.1466595563007399, 0.1526861879565149, 0.17234238568638283, 0.14490567799288967, 0.14329723224112312, 0.21546840140726375, 0.1362228743239291, 0.30790047261698816, 0.3053643579336467, 0.31404784944664765, 0.29304929591112505, 0.2561391527826339, 0.2974319428489024, 0.3248060090648992, 0.3335723324789214, 0.3098831160740798, 0.22623523123898148, 0.228280170616318, 0.2195662381403357, 0.23805159551179889, 0.22762130662168967, 0.22271444527882955, 0.22239256761603787, 0.2636408871811058, 0.25095200083628555, 0.18154195383521365, 0.19250899747227956, 0.18949250817639618, 0.18837254480080023, 0.2001401029904043, 0.2098396862903089, 0.19536486878067594, 0.23696048264502256, 0.22777845035779953, 0.2050928384016938, 0.2103794769746138, 0.23966832273191052, 0.24161924931567402, 0.19802505486558497, 0.2488241089203036, 0.20480804474459702, 0.21401384146678692, 0.21071523545306658, 0.2016145057513702, 0.19771065572430113, 0.17826905595372378, 0.6215077366414232, 0.5769425043127521, 0.19542803874898962, 0.3003078856374575, 0.2814143946104688, 0.5904324397880314, 0.20953990429760216, 0.26119700032106574, 0.32807854334398057, 0.24355768385863552, 0.4093677393983045, 0.3187652936968951, 0.20666023963095836, 0.46803373219763467, 0.1179904090431495, 0.18778059592001906, 0.20721385291377659, 0.1776470573524619, 0.1741214552297512, 0.19112836708548275, 0.1848808387784434, 0.18046658690696327, 0.19398817803456836, 0.17555979608894756, 0.0821790277269594, 0.08529812266779557, 0.09752565874444785, 0.07823498576387689, 0.07557936612911598, 0.08512749916187856, 0.08020158202708538, 0.07938638018523347, 0.09763036628294575]}, "mutation_prompt": null}
{"id": "4eab3df9-2b6d-4bc1-9f5f-ed2f746da39b", "solution": "import numpy as np\n\nclass QuantumAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.4  # increased local search probability\n        self.dynamic_scale = 0.3  # refined dynamic scale\n        self.chaos_coefficient = 0.85  # adjusted chaos coefficient for stability\n        self.learning_rate = 0.2  # enhanced learning rate for quicker adaptation\n        self.memory = np.zeros(self.dim)  # maintained memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)  # using sine map for chaos\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Quantum-inspired mutation with refined dynamic scaling\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * np.tanh(np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Quantum Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumAdaptiveChaoticDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Chaotic Memory and Dynamic Mutation for Efficient Global Search.", "configspace": "", "generation": 51, "fitness": 0.30287796460463917, "feedback": "The algorithm QuantumAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.7822231627964142, 0.7760119775551266, 0.7610232547309411, 0.7794213478154727, 0.7793200012828503, 0.7896451466414919, 0.7658671119312723, 0.7811801140602658, 0.7874717413618331, 0.567524382833585, 0.6074923560043284, 0.6003848301095966, 0.5848268802939258, 0.6137880816037851, 0.604538650386341, 0.6059652593247687, 0.5920778945286878, 0.6115660018261744, 0.35440973236966467, 0.3127893838264405, 0.2665989562562874, 0.31926364247225336, 0.2664559704512107, 0.25573912340966576, 0.3629825633892255, 0.3098733963073492, 0.23097867029312913, 0.14179366549458539, 0.14628259759253137, 0.19808594947105684, 0.24717669403750775, 0.2488752006572238, 0.23500461953846985, 0.19568564150537626, 0.15178476407593922, 0.19463781457201057, 0.954207408691465, 0.9428670896599541, 0.9412614497611196, 0.9269281132342866, 0.9450764376178749, 0.9330132124577784, 0.9494416354111243, 0.928726756646209, 0.9597509512435275, 0.35355601766857414, 0.3685695272904892, 0.3351056288058163, 0.32712511913137876, 0.3449808822380963, 0.348890829783041, 0.25751899255507205, 0.37110963658060436, 0.32458005916169286, 0.4526159836590613, 0.47042701494747174, 0.4722989036610393, 0.5526459847870839, 0.6348945686599161, 0.5887734625797238, 0.6313754253434041, 0.5546820735548937, 0.6398742569812323, 0.168159243537636, 0.16024377511683363, 0.16940555676657532, 0.1841961847193485, 0.16611438592018257, 0.21079476050832724, 0.19097541551791342, 0.2130141170808394, 0.17791049748366916, 0.16474945881715852, 0.15935931000927173, 0.17613075091797914, 0.17536968395503405, 0.17944329294354322, 0.14603753987749535, 0.16195308686220378, 0.1587335038356137, 0.15839820260401283, 0.04948991536014413, 0.050834213288645014, 0.036504929616926196, 0.048934361489449074, 0.06133095308293124, 0.02614676807495231, 0.06211916706700704, 0.042143264431124594, 0.02762681913899634, 0.21453784224408823, 0.17119352467760307, 0.15112883565215196, 0.14097957858424703, 0.12971999158036984, 0.14855711925632453, 0.22379222907229424, 0.1866260569070871, 0.18927604920898888, 0.017618369406454115, 0.037264599501840356, 0.0018585265127208928, 0.01299006420705029, 0.03508860531088209, 0.03430845532089111, 0.07001359982593625, 0.06704607876253799, 0.07732359471415917, 0.14376166190329132, 0.13000672043848793, 0.1505164579665199, 0.15931797667059489, 0.17238527080145283, 0.15634309290108972, 0.13708384246146288, 0.12446842279353876, 0.15291782876979287, 0.5371900628560851, 0.5103996223155438, 0.5228521928609391, 0.5265299857978658, 0.5056090399922153, 0.5063109152558269, 0.5232517617298458, 0.5156852228373454, 0.5298897984087845, 0.10846456458266096, 0.09656665568364564, 0.09469387127720474, 0.10168412381103864, 0.09786583898769241, 0.10888049513187581, 0.10684072478587836, 0.10468160745523525, 0.10163287499260953, 0.13735720134677343, 0.14092194398122515, 0.15132503314692491, 0.13466092399458596, 0.169458896633915, 0.1386247524833183, 0.14017760495942744, 0.1573624447642562, 0.15360133066580162, 0.31771919807273985, 0.3215626522947409, 0.33644298444340837, 0.33567914092381723, 0.30473861915337697, 0.32229302017501305, 0.36823616405445414, 0.37500210867785944, 0.3715009633141414, 0.2267642864581938, 0.24483434273345805, 0.22425452166725557, 0.20485669885943725, 0.2028498356249484, 0.24841985332291483, 0.251175790864948, 0.25230538951694315, 0.23384601398037863, 0.2020977007066529, 0.1949971910991226, 0.19179193944146933, 0.18443927425109286, 0.19301237448788944, 0.21066563360816404, 0.2011153308479947, 0.20329661770525065, 0.19200123286516457, 0.2785852283240057, 0.21587726413298947, 0.22467353752522323, 0.4254385738436378, 0.20031567636946723, 0.23294885196977466, 0.25072372397720344, 0.20813345054123789, 0.19361804417238326, 0.4610038493582159, 0.5118078184776517, 0.5877464890245012, 0.6528883816561031, 0.45361994681643525, 0.6315193406591766, 0.18110250057723098, 0.4601611278492689, 0.3884629787747548, 0.3456816890950799, 0.1924961416474995, 0.3194109373708115, 0.36148156880170945, 0.19864513323049116, 0.18848192390125607, 0.39475860974046306, 0.3304412303664094, 0.20537481911568067, 0.19820125195489524, 0.18545225812826105, 0.17654513863680044, 0.19436458408004742, 0.17714722960127305, 0.19489108386195975, 0.18557344765369543, 0.17907412786819676, 0.18361283339650158, 0.07385594954236052, 0.07444470345395637, 0.0872237010316218, 0.08019727006893607, 0.07742026293322801, 0.07116865231489244, 0.07708173203375612, 0.08643023905583302, 0.08385112538343309]}, "mutation_prompt": null}
{"id": "70dfdeab-e973-4d0b-a7c2-0b3f4e4f3e0f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population size for more diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # slightly increased crossover rate\n        self.F = np.random.uniform(0.5, 0.9, self.pop_size)  # slightly increased differential weight\n        self.local_intensification = 0.4  # increased probability for local search\n        self.dynamic_scale = 0.3  # increased dynamic scale for mutation\n        self.chaos_coefficient = 0.85  # adjusted chaos coefficient for exploration\n        self.learning_rate = 0.2  # increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # added memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)  # logistic map as chaotic system\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.55 * self.memory + 0.45 * (trial - self.population[i])  # refined memory update\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution with Temporal Memory and Chaotic Maps for Optimized Global and Local Search Balance.", "configspace": "", "generation": 52, "fitness": 0.3717400038367594, "feedback": "The algorithm EnhancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.26.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8585533510968264, 0.8543479606571563, 0.8660736558897482, 0.8674974397342979, 0.85452655125355, 0.8620200426462246, 0.8616391302933563, 0.8595100437600347, 0.8635893251734853, 0.7286909886920389, 0.7371966379598043, 0.7281009416349483, 0.7275174697807161, 0.7157883436690866, 0.7308809053930164, 0.7219442419100044, 0.7298136710178915, 0.7212020296480774, 0.45048820408303003, 0.4850135105731538, 0.42800391948636607, 0.39445331277979245, 0.37345249150562354, 0.3844032491885735, 0.3790009823472227, 0.2916841261866514, 0.468703545576432, 0.2097852005996449, 0.15429731447588124, 0.24197891949445416, 0.1576998573485533, 0.2461746925042948, 0.2601751768131917, 0.2564325238587264, 0.15506170259626162, 0.3102577878964864, 0.9502620495217549, 0.9796539474797975, 0.9577013536292366, 0.9845827236815994, 0.9727492481118498, 0.9476267294070904, 0.9687747420156292, 0.970683602166419, 0.9546490694120161, 0.5434838178860244, 0.5272326159072029, 0.578650208387044, 0.5575576970197729, 0.540204962294555, 0.5432130868116238, 0.4729415200030883, 0.5281258802200921, 0.5107869383929062, 0.7749071310030935, 0.7308963006943896, 0.22310602996359008, 0.7868083115815139, 0.800700235246382, 0.7749923405969041, 0.75610276913827, 0.7625265069382737, 0.7580137023749751, 0.22767005356779524, 0.23950685391822746, 0.2737031942472391, 0.4422196845818155, 0.2316909922201268, 0.12036077049895666, 0.2587778429235763, 0.20638830773453443, 0.25732389914983644, 0.15394868079401136, 0.2007135821947087, 0.2292956579203782, 0.26955703030425215, 0.23703534051673059, 0.20610777038485517, 0.21363951134281445, 0.3384131582984994, 0.23736904357026856, 0.04432536588850433, 0.09026035641634245, 0.06785140642639831, 0.06494536945976948, 0.14019332176417998, 0.0705531810172011, 0.1544867674495144, 0.16576742992717441, 0.1692334804315364, 0.27056645670975965, 0.24078938641500813, 0.2679699590226291, 0.22380573673251358, 0.2198998627540648, 0.1900930403839457, 0.30665021846174945, 0.27013258456582945, 0.33820484100085135, 0.19726360862748893, 0.056106188194655404, 0.13483372171007701, 0.1109223584483574, 0.2377955157347239, 0.2324168111674738, 0.16682673253062152, 0.10155716402306536, 0.10402677642032465, 0.2195453659911225, 0.23908519311435217, 0.23821076077331726, 0.2666015927087797, 0.27243526193499024, 0.28769225320009395, 0.23414960931542783, 0.2316620568550074, 0.217164361318115, 0.6506501665723277, 0.6431635449598008, 0.6319995676075795, 0.6472927028302737, 0.6336311297396273, 0.6546646797884638, 0.6612583831333394, 0.634540611461245, 0.643498799333269, 0.11180516109214245, 0.11204306778786288, 0.12586534320618137, 0.13863031195630915, 0.10786058400752141, 0.11328298408313986, 0.12173919962992608, 0.11698357916085511, 0.11065295648133833, 0.14627916458232648, 0.1507592589609179, 0.1484289439370985, 0.13535991078432907, 0.15358666246759245, 0.15433591703155858, 0.21162685444680274, 0.14914890375641132, 0.13832922825452987, 0.43578827409331855, 0.4502380188549109, 0.4755270295270776, 0.4232385818271689, 0.47324031668123256, 0.45033148308474336, 0.5202343127467445, 0.5046342367073657, 0.5191946113647931, 0.2635966186635236, 0.2851215265513122, 0.33689851869284226, 0.35867825013476573, 0.3089027039986738, 0.28768117270747573, 0.3407010166675557, 0.2930858361209676, 0.3477455964177618, 0.20653581331310644, 0.20479702449475934, 0.20226903371880234, 0.19367180272635065, 0.20040101710753144, 0.242420672584846, 0.21521019901774918, 0.19983281076063453, 0.20523848266859668, 0.491301495358339, 0.36514092994272596, 0.6064429678473945, 0.4659311495967482, 0.25912194378989484, 0.2303736797304612, 0.4499921242407753, 0.5447245762069751, 0.2468631131379001, 0.19607247705727837, 0.1700833866660343, 0.1863189926901384, 0.1692214611125441, 0.16532172978852233, 0.195809180622879, 0.16668157486523383, 0.7711214381659303, 0.7797172513039942, 0.2069065837076317, 0.2065363046092169, 0.21096928086355415, 0.7090355594372361, 0.16383033363213872, 0.15237315528676354, 0.7211834633825931, 0.12653552515233246, 0.7045112164608847, 0.18997735938479365, 0.19716330876526367, 0.17725037739498617, 0.1879483235432704, 0.17934616856784324, 0.18141567190285113, 0.17781641718401864, 0.18892751423999354, 0.17600206808539132, 0.09073730250782996, 0.08844523727676679, 0.08562837839365711, 0.07967690541703598, 0.10216819726525317, 0.08726966681584325, 0.0929688966780321, 0.08629603513159145, 0.09141128876882143]}, "mutation_prompt": null}
{"id": "a4fda294-e661-4317-9652-933da88542f1", "solution": "import numpy as np\n\nclass ReinforcedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.5  # increased probability for local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale\n        self.chaos_coefficient = 0.95  # adjusted chaos coefficient for broader exploration\n        self.learning_rate = 0.2  # increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ReinforcedAdaptiveChaoticDE", "description": "Reinforced Adaptive Differential Evolution with Chaotic Maps and Memory-driven Strategy for Enhanced Global-Local Balance.", "configspace": "", "generation": 53, "fitness": 0.4097411557684372, "feedback": "The algorithm ReinforcedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8751471060714895, 0.8806222914145448, 0.8787377840330215, 0.876423174176157, 0.8838886592269792, 0.8769079305149305, 0.8741325173063899, 0.8818014651311118, 0.8763737639236368, 0.7719933602532487, 0.7785614479753858, 0.7708656054527676, 0.7765334844419398, 0.7438459884364916, 0.7728695317033597, 0.7610057184427543, 0.7826936473915097, 0.7811593787168667, 0.5848662172520811, 0.46606777667356347, 0.4718504130960166, 0.4619441808362027, 0.14589627258229487, 0.43575193976682025, 0.46128241134368786, 0.1715627751181732, 0.5532038770953396, 0.28531892273668613, 0.16316493850058433, 0.1615319639915126, 0.15725738999399896, 0.16007497340626364, 0.388062007848222, 0.23671165702666375, 0.15606467880758845, 0.1517328566314834, 0.9706253760370969, 0.9487974067770594, 0.9512140674636231, 0.9739107444709844, 0.9509090402633388, 0.9609031275952029, 0.9812799960372344, 0.9376279708200427, 0.9587191911592383, 0.6425979166830453, 0.6422425083671186, 0.6158214645897975, 0.6491534624998179, 0.6056303906899518, 0.6401721585308444, 0.6242987133674396, 0.6088962896276436, 0.6262631866570958, 0.7789203694299213, 0.782402359168746, 0.7908173439671758, 0.8321505462609908, 0.8571312928375285, 0.8193263145465937, 0.7962198029230798, 0.8372314763511568, 0.7933702839400614, 0.43231808809351646, 0.29029628625651926, 0.4357268096314124, 0.26664883393020844, 0.4125394050783838, 0.34762317888029315, 0.243223493197255, 0.22857262170338877, 0.20597060106820286, 0.28372846319323686, 0.2586957731274384, 0.21156858252504984, 0.33141628616792296, 0.3495016922887566, 0.30892998117100035, 0.29309342091495694, 0.2223057056027946, 0.24579875059945933, 0.1439797103147883, 0.17795726181880722, 0.07628393659112243, 0.07449095603109468, 0.14389792139112234, 0.057413909850921874, 0.2436305312881074, 0.20497875247466846, 0.28718601708412395, 0.3383301381773438, 0.3888545392715006, 0.37444685391789134, 0.34887776504600443, 0.3532218125529142, 0.35832688910092225, 0.33235125445815195, 0.37165037771181075, 0.3482855532387643, 0.07673684335885755, 0.05077561382220086, 0.1306698106223958, 0.11086773829899998, 0.17655498159517935, 0.12281353628084324, 0.13384491437632318, 0.20003774290371423, 0.19273655845365578, 0.23996585711462204, 0.25768064935404156, 0.27676366993435464, 0.2656217947962394, 0.3075929180239577, 0.31097733691030316, 0.25327511449999596, 0.20263906119748376, 0.2967807920361748, 0.6964279105399546, 0.6954398977554223, 0.6682200644867683, 0.6749801103918851, 0.6848913474868172, 0.6938405331971733, 0.674752745422722, 0.6797328581498638, 0.6821946217876946, 0.11598033839421129, 0.12448009055727127, 0.11369555767083583, 0.12443524499604885, 0.11425057379759729, 0.128791656104152, 0.10696402094268198, 0.13111887656262566, 0.1918767877608596, 0.14880908194468934, 0.13713232383028717, 0.15808708001911165, 0.19024180756477338, 0.1440314844626397, 0.14713732581035632, 0.16540390320744358, 0.12423247868416076, 0.13861428485718097, 0.451919141910174, 0.6003552692582383, 0.517918089074043, 0.483147070269083, 0.45646043837903405, 0.6059120998834571, 0.5549137480952773, 0.6044553872708909, 0.56983650574787, 0.35676056194089867, 0.31629923997309484, 0.3507305832121984, 0.35212615511652345, 0.3692290954769796, 0.3482871802807824, 0.43955212274568944, 0.37291673745575293, 0.32029859166902075, 0.2350155106444337, 0.20838126507645316, 0.21725278559491235, 0.21299736463457453, 0.19863726398696357, 0.20962869255479777, 0.22083986054930105, 0.20709615292068795, 0.22705703285611112, 0.23434245775206386, 0.29412671186700723, 0.23498526129778474, 0.6946666335128182, 0.21845555754830526, 0.2200597969642537, 0.6739689259860118, 0.2197482617940456, 0.24188263769213048, 0.17573170134802363, 0.20471267199787646, 0.8462492598584422, 0.7503243328088569, 0.16541220192508121, 0.16673164193405665, 0.8581717167591816, 0.17564783886070512, 0.6725183678662922, 0.7850270866666512, 0.7212228025813434, 0.7468669048350614, 0.1659876822299069, 0.1667529706078108, 0.6055035334194059, 0.6635714521096394, 0.6850843285342535, 0.10473643802799992, 0.18641606365141739, 0.1915664521504732, 0.1805148481299731, 0.19538459372477168, 0.17635756100537314, 0.20182392269548421, 0.1916128973259238, 0.2077765840160588, 0.18599410508936287, 0.08666376696111422, 0.09123351752043363, 0.09450320011692315, 0.09080565058046619, 0.08959316993394917, 0.08564171066325033, 0.0765877650784259, 0.08780703492059305, 0.09653267696016354]}, "mutation_prompt": null}
{"id": "0cd6b245-7ce9-4ec8-a355-dc07b9862c47", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)\n        self.local_intensification = 0.4\n        self.dynamic_scale = 0.3\n        self.chaos_coefficient = 0.93\n        self.learning_rate = 0.2\n        self.memory = np.zeros(self.dim)\n\n    def chaotic_map(self, x):\n        return np.mod(self.chaos_coefficient * x + 0.5, 1)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumInspiredAdaptiveChaoticDE", "description": "Quantum-Inspired Adaptively Chaotic Differential Evolution with Reinforced Memory for Accelerated Global Search.", "configspace": "", "generation": 54, "fitness": 0.28620091676744247, "feedback": "The algorithm QuantumInspiredAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.7564476855073127, 0.7535217751909992, 0.7605446159680282, 0.7496354499311831, 0.7434882380927594, 0.7605460881852348, 0.7632236230148917, 0.7457274448639833, 0.7659278554961575, 0.5577904059320773, 0.5603443541701274, 0.5738136361906273, 0.5708385617229293, 0.5702730891631851, 0.5854203681138959, 0.5475342758121267, 0.5913446217746124, 0.5875970229924308, 0.25890903799241494, 0.2091731487594154, 0.23233756361535773, 0.19981287704794426, 0.21152075544078086, 0.24529722565258227, 0.21821071779461354, 0.22389477799837953, 0.26737924952228953, 0.1509832144245321, 0.16853171954455737, 0.13176071037920267, 0.1328213714513855, 0.16595280182096117, 0.15515321865786558, 0.16428709041971046, 0.1539322643588732, 0.18642905248179809, 0.9565685192793397, 0.983576251406586, 0.9407297172568478, 0.9616802594833038, 0.9533425581728777, 0.9461070811849113, 0.9364751191111428, 0.9466244905523993, 0.9473041093442854, 0.31019147947986914, 0.3226978343910707, 0.30877433528132914, 0.32990071568007007, 0.33896478601987257, 0.3396682305140596, 0.29147595392940706, 0.34154720464099286, 0.29037431209243425, 0.5460761054696215, 0.44258352420037517, 0.537015928164847, 0.6346222095841537, 0.5634989701994164, 0.45534634028587884, 0.5194873044592533, 0.5004572935458054, 0.4764773196923625, 0.1659078706669609, 0.16017663349371125, 0.1542671324548357, 0.14222116454031652, 0.12798991461721376, 0.18788734388736816, 0.17406872197737788, 0.1769983002998764, 0.24916104565698938, 0.1529238634817921, 0.187361553854545, 0.15019381560888523, 0.16907474422332902, 0.14791901341031166, 0.15515309705801972, 0.16522791805052928, 0.14879429400786426, 0.14284431289408261, 0.03948984124795274, 0.06070023021472393, 0.03157468348343084, 0.023719649140323207, 0.03248369316511612, 0.043778020039651366, 0.04873884148041907, 0.05184783469241394, 0.061405342294778564, 0.12886542556299063, 0.12881833468541704, 0.15560477371304837, 0.12856335751166947, 0.11885671412921162, 0.12918963312950327, 0.1788158591809179, 0.18935488491612174, 0.19468617365012109, 0.03438067552406576, 0.03565373308300246, 0.02966775592274129, 0.024200665081196893, 0.030730420140613224, 0.04718927240351456, 0.01177087102104557, 0.030433604778575152, 0.04069719567703578, 0.1420400232259199, 0.13310964168935502, 0.14962398584461412, 0.15086078620245202, 0.15868761663371478, 0.1422633374742598, 0.14379465027083593, 0.15111478092860375, 0.13567884411672348, 0.5059308948820357, 0.49003757350648114, 0.5041781432336345, 0.5373962840867454, 0.5076384561584575, 0.48927404609472114, 0.5193544662433176, 0.5036021895127016, 0.5112384693713995, 0.11038071388484261, 0.15562528888896554, 0.113167260528382, 0.09488341018613677, 0.09736227000706021, 0.09748334926038338, 0.09270471571730377, 0.09688657629327158, 0.11140078362790973, 0.16192240280165027, 0.1466639732887084, 0.14646730405259956, 0.1638488501318014, 0.13633016894071148, 0.17038981190553282, 0.14292092970221948, 0.15372827715971393, 0.1524259985983838, 0.3147777552326467, 0.32698004108218215, 0.32478791203392654, 0.29207249734990637, 0.32501445906692117, 0.31437929548651455, 0.35874734046501466, 0.4030891601280884, 0.35845456544165777, 0.24344342330362911, 0.2292081991730549, 0.23241392729903965, 0.23001798074112012, 0.22873720590861546, 0.2219915901428966, 0.23066240042603392, 0.24317597596855212, 0.261635206527562, 0.19023664806700735, 0.18597741410498136, 0.20414984962856064, 0.18933471420449244, 0.17966247312749606, 0.1842101155637511, 0.19287830810004158, 0.18028328651383418, 0.20381483125755362, 0.2003893941328464, 0.24394221194265842, 0.2312501340793619, 0.33005080871868187, 0.20755908368766463, 0.22970767278507653, 0.20857544509806503, 0.24464156289515648, 0.2298680406746455, 0.30351878646053243, 0.5807027446689914, 0.24648763191652856, 0.3392848966427211, 0.4415342233574916, 0.1835196720147636, 0.5212277298675729, 0.4161044074823861, 0.35091598127621826, 0.39877371473818635, 0.2590715833558723, 0.19931855967926526, 0.1646643714904087, 0.15854856042609844, 0.23908293716012508, 0.20804427513611778, 0.48319193908849745, 0.20100722832543627, 0.18151278012851046, 0.19672780161408432, 0.18861505413348867, 0.2011140469836269, 0.17456805702903733, 0.1945903950662563, 0.173992231362327, 0.2002823076193665, 0.18316368535109773, 0.0731807686241982, 0.08134528536459862, 0.08053542027053096, 0.08065857673504029, 0.07585876695762328, 0.07898553260047392, 0.07738366220399984, 0.07826751476283167, 0.0757175981011271]}, "mutation_prompt": null}
{"id": "b1428fd6-7810-4877-86f4-392f68fad510", "solution": "import numpy as np\n\nclass NovelAdaptiveCooperativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.4  # increased probability for local search\n        self.dynamic_scale = 0.3  # adjusted dynamic scale\n        self.cooperative_factor = 0.85  # cooperative factor for hybridization\n        self.learning_rate = 0.2  # increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # added memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return 4 * x * (1 - x)  # logistic map for chaos\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory and Cooperative Hybridization\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (self.cooperative_factor + chaos_value) * mutant + (1.0 - self.cooperative_factor - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "NovelAdaptiveCooperativeDE", "description": "Novel Adaptive Differential Evolution with Dynamic Cooperation and Chaotic Hybridization for Enhanced Global Search and Local Exploitation.", "configspace": "", "generation": 55, "fitness": 0.3213790100173738, "feedback": "The algorithm NovelAdaptiveCooperativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8166980377429619, 0.8145863969388991, 0.8302230572959765, 0.8096401591610499, 0.8087103159902677, 0.7976639179359792, 0.8106670284324182, 0.8038737814560487, 0.8101327288671225, 0.6460253782256618, 0.6539689463655741, 0.6483875163371717, 0.6592154834816288, 0.6681428287800006, 0.6594682374536613, 0.6748663993603203, 0.6611197586901993, 0.6718858888804637, 0.41585236303510353, 0.4290765052547939, 0.4763364291727916, 0.22960823362562244, 0.42073164837363997, 0.4216849092519399, 0.38730066384416784, 0.41218667680398524, 0.37826053960800876, 0.2930828298479248, 0.4020916208051143, 0.294457197526112, 0.2506445796323006, 0.15996447091288424, 0.32401131383773996, 0.3182320747321642, 0.22150083302315426, 0.1534812674532564, 0.970679332161647, 0.9656683360071985, 0.9376406698230195, 0.9584247875791247, 0.95069058251271, 0.9627383179820412, 0.9413976775653125, 0.9437270375029243, 0.9515390503679979, 0.43236015010440465, 0.3758630592067078, 0.4166624589778607, 0.3897447025089118, 0.40694176302791985, 0.39070659714271494, 0.38094880554632815, 0.32281592307191087, 0.4089586835572775, 0.4518676892950979, 0.6466459210704888, 0.5185264607610742, 0.5607318226047314, 0.6767373580495974, 0.6387018571223809, 0.5651204001063186, 0.5537199528058079, 0.6373985235055846, 0.2230327469593839, 0.2471093835695496, 0.22203539017403684, 0.19003092632179752, 0.14617383176033072, 0.18532301422984532, 0.18289681948021985, 0.2503133184255254, 0.22401227760506026, 0.18000831463314915, 0.18900544886538295, 0.14637521826735977, 0.18544713087052067, 0.16996509189824194, 0.20296895427087291, 0.15851886861537023, 0.16696844226153806, 0.15423631140542293, 0.061161768642613246, 0.06730171298182908, 0.08006731162137004, 0.04674806091950012, 0.026699721364227158, 0.04083023113890527, 0.0810513870809978, 0.057750847588768583, 0.08820986822109822, 0.19606057904081975, 0.178161774253229, 0.23371724740801803, 0.16524630653387684, 0.1123398486205619, 0.1943512680148255, 0.18426803137800807, 0.22706492898683028, 0.2478069765209141, 0.035498397834874185, 0.024466134459597777, 0.03236787967410004, 0.05212260534161395, 0.0535630562974404, 0.08308504471364564, 0.09488873069321757, 0.07312017553754524, 0.06395354536903397, 0.16850417637102222, 0.1402139730457157, 0.1620100197042582, 0.16012169383038832, 0.20215865641135, 0.2092591796362676, 0.158420657430846, 0.15192740996578702, 0.15700482976474872, 0.5767703277741565, 0.5014209444618948, 0.5528567259913088, 0.5254586478109415, 0.5507988218055878, 0.5227170024024861, 0.5354964148756179, 0.5420851175213355, 0.540050658231203, 0.11213993696078794, 0.1157186262610036, 0.10253385338538556, 0.10504367221958433, 0.10426527050139034, 0.10237707591200229, 0.08918753729237838, 0.10856005856535389, 0.09206976170328762, 0.1413156053533774, 0.15700913057407284, 0.17132768446049218, 0.14040048593306598, 0.14147614987264168, 0.13847457804715158, 0.15479825486946575, 0.14096462007765964, 0.15635167192117083, 0.3042013386838859, 0.38943199348469937, 0.3617728147544129, 0.3029485411393944, 0.3356973668423334, 0.3676038746227569, 0.3552378123395078, 0.3980518373459009, 0.3802301206076165, 0.21266439155674088, 0.24221894778083164, 0.24846302468302361, 0.24368774403876436, 0.24889171435103052, 0.2615123721128563, 0.26677924170036627, 0.30796368225838466, 0.2505519161649672, 0.22309550488700802, 0.1860646976463397, 0.1799963021171629, 0.19578717993453842, 0.19381042718987052, 0.21109992004730416, 0.2219693987410979, 0.2053823405398717, 0.1889415409295484, 0.3000662259777128, 0.42795468118728086, 0.2524060940145726, 0.30697020494799, 0.3260902678995601, 0.345122723074446, 0.2683098256081137, 0.2057392704067642, 0.2304820993572645, 0.19050430716103472, 0.1684113162479629, 0.5709857240533187, 0.5227196378142793, 0.553795031957621, 0.6032314334427028, 0.5382669870770898, 0.1649531883064146, 0.17548909346269215, 0.15976815799825994, 0.16803145614243709, 0.16611373629172943, 0.36010597284461676, 0.19506341374655245, 0.20494526057541151, 0.5359381498159121, 0.20299795935167897, 0.20847324639286657, 0.17711013721998425, 0.18098630559299622, 0.17575160363929632, 0.18323889128467763, 0.1736418445001957, 0.17475643650255457, 0.1869034411251298, 0.17354508169307759, 0.1816269274630019, 0.08465326538625484, 0.0757816271388978, 0.07585266601226426, 0.07361259015864763, 0.0828994212769385, 0.07700323511965712, 0.08502211451171826, 0.08264524096309345, 0.08749172360838331]}, "mutation_prompt": null}
{"id": "f14b8e61-a837-4d61-a676-4aee8ec59a80", "solution": "import numpy as np\n\nclass AdaptiveQuantumChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # Increased population size for diverse search\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # Enhanced crossover range\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted mutation factor\n        self.local_intensification = 0.4  # Enhanced probability for local search\n        self.dynamic_scale = 0.3  # Increased dynamic scale for mutation\n        self.chaos_coefficient = 0.85  # Adjusted chaos coefficient\n        self.learning_rate = 0.2  # Enhanced learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n        self.quantum_factor = 0.2  # Added quantum factor for superposition\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_superposition(self, position):\n        return position + self.quantum_factor * np.random.uniform(-1, 1, self.dim)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n                mutant = self.quantum_superposition(mutant)  # Quantum inspired mutation\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveQuantumChaoticDE", "description": "Adaptive Quantum-Inspired Chaotic Differential Evolution utilizing Quantum Superposition and Reinforced Dynamic Learning for Enhanced Optimization.", "configspace": "", "generation": 56, "fitness": 0.24302471530857034, "feedback": "The algorithm AdaptiveQuantumChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.4784244588572296, 0.5009224393362013, 0.4803634111505475, 0.5010830124348289, 0.48455133442282394, 0.5005385378779146, 0.476333023555493, 0.4939117755816077, 0.4981530236206486, 0.13613592773217476, 0.1593743569573407, 0.16704575599693816, 0.13900354884971233, 0.11513791619661096, 0.16339306204961723, 0.15658672914759064, 0.1223400684454502, 0.1498362650271614, 0.163315390860172, 0.15060668690667112, 0.1632107285563159, 0.16240943198152813, 0.14245069478715633, 0.15965782794971206, 0.14475223302927864, 0.15138690289928058, 0.15897637875119652, 0.1285413827641263, 0.13621588877361224, 0.12961197006178404, 0.1255359583404021, 0.13074062172617362, 0.13115239512963783, 0.13492957166314423, 0.12957938511791012, 0.13555818374231188, 0.9582098472856713, 0.975498994127452, 0.9647147696156233, 0.9248633972447176, 0.9512965617548322, 0.9545953092835201, 0.9477245415977198, 0.9296150375573453, 0.9427323471075685, 0.2824800948517391, 0.2963394279591901, 0.28600882679435824, 0.2788305895143509, 0.2836333392822816, 0.3050347069640258, 0.27882192986561627, 0.30056284439643743, 0.2926088921849914, 0.3093590782654012, 0.33308007255361904, 0.5329932473951946, 0.3554395328812656, 0.5985700813082097, 0.7941595821997756, 0.3574230135313117, 0.31814512129832084, 0.34564546165274057, 0.15474000070909155, 0.15101859939465945, 0.15795188366965773, 0.17311337974187513, 0.1658801289227727, 0.16679320278769771, 0.17297973681077383, 0.18396586235544798, 0.16207835653328528, 0.11070723354733891, 0.10823252702129071, 0.16984052983798215, 0.17482536515602765, 0.1632238735727013, 0.15481346310879218, 0.1317009562667909, 0.15191889051737795, 0.17019114985240524, 0.026641209123206888, 0.040007586775104076, 0.006744306647562204, 0.01132537209465112, 0.007169474207263882, 0.0014545097126233975, 0.002343017863452923, 0.012291269178465125, 0.0003520339947706841, 0.07783630022273169, 0.09731876752821789, 0.08894775369050545, 0.1239695241196056, 0.05296189222827996, 0.10510539510906514, 0.08815436398045551, 0.11204864914959367, 0.1377747016570976, 9.999999999998899e-05, 9.999999999998899e-05, 0.03495065371153705, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.128494085660955, 0.12468002577609372, 0.09522606481989637, 0.12871242860635235, 0.13300835274804268, 0.1253111513504146, 0.10651656114776631, 0.11027983017371423, 0.10962290849245004, 0.4222336127719133, 0.44572748596094935, 0.42627751142029224, 0.40884030236823776, 0.4325746522946946, 0.42855278386407214, 0.4278943200005997, 0.42413287437966063, 0.4308619784303034, 0.10803582798865552, 0.12465517808848003, 0.1121803721797171, 0.12165153888549662, 0.10976403008682623, 0.12674223594682443, 0.11383915847850168, 0.11984842176124944, 0.10086226514334173, 0.18753975600474004, 0.12978964067318444, 0.15040597184183113, 0.1743766682188852, 0.14586191385411618, 0.12811525930354073, 0.1678291433384147, 0.16391360840669733, 0.15610995927561921, 0.2971430356155811, 0.29331646055576477, 0.29624353464773523, 0.3039477811336496, 0.30064378572183903, 0.28729541570217154, 0.3077251564637691, 0.30481000971525385, 0.2916460619591349, 0.26951784622186636, 0.2323330052702517, 0.22176069796278985, 0.23300737261123483, 0.2414448093204934, 0.2426821366874189, 0.1962611084284832, 0.20377578496503324, 0.24094378554548168, 0.2136602101659727, 0.21803668801299636, 0.19373135501783678, 0.210391011543542, 0.23750182160485367, 0.20653454995932174, 0.20849445663085664, 0.2085278186874635, 0.1980987174856318, 0.21990282435794428, 0.20342303326689593, 0.21561198764190126, 0.20978703660986697, 0.2474757386718457, 0.19866511022184508, 0.2301002693191283, 0.2226401275182911, 0.19614449309792292, 0.6524100689446071, 0.1756823880613414, 0.18312895735743429, 0.5043342223545333, 0.1875381533400624, 0.642194136320571, 0.6129330943361762, 0.17455749049121883, 0.6175368246287036, 0.20814488803238063, 0.4503661345268317, 0.49951366050559176, 0.20610297057196003, 0.20590887007549052, 0.4520618798744722, 0.3247917208245341, 0.21023834554040133, 0.4844620138063066, 0.18537490787326882, 0.1817021255218474, 0.1739671658360309, 0.17732463898705952, 0.19409032191729747, 0.17546492373350486, 0.17488741559165555, 0.20652202549287202, 0.20629860000960454, 0.09395247549543762, 0.09435391789112002, 0.09108076733094239, 0.08153731115370355, 0.08640331272790847, 0.08998053806286366, 0.09811658621602215, 0.09058740595564307, 0.09377047962345098]}, "mutation_prompt": null}
{"id": "a6b6143e-940b-4473-897b-b2b0c9780ab8", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.8, self.pop_size)  # adjusted crossover range\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # refined scaling factor\n        self.local_intensification = 0.4  # probability for local search\n        self.dynamic_scale = 0.3  # varied dynamic scale\n        self.chaos_coefficient = 0.85  # chaos coefficient for diverse exploration\n        self.learning_rate = 0.2  # increased learning rate for rapid adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n        self.quantum_rotation = np.pi / 4  # quantum rotation angle\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_rotation_gate(self, x):\n        return x * np.cos(self.quantum_rotation) + np.sin(self.quantum_rotation)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory and Quantum Effects\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = self.quantum_rotation_gate(mutant)\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # adjust memory update\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveQuantumInspiredChaoticDE", "description": "Adaptive Quantum-Inspired Chaotic Differential Evolution using Quantum Rotation Gates for Efficient Search.", "configspace": "", "generation": 57, "fitness": 0.2983212696169975, "feedback": "The algorithm AdaptiveQuantumInspiredChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.7313846274646343, 0.7347979934760662, 0.7372262742293854, 0.7382072719393723, 0.7029661780925036, 0.7093128506297295, 0.7217537488564612, 0.7052004763796385, 0.6875026032024956, 0.5578995014630024, 0.5293949793663475, 0.5187705108404492, 0.4696745976166642, 0.4166747147574068, 0.47295688099939515, 0.4083530552093688, 0.45543857510722596, 0.4779628535415651, 0.24555619772425308, 0.3209278249275216, 0.32539617465750414, 0.29062631822458973, 0.2576388447423529, 0.21075405462443386, 0.1792608678386487, 0.254241973232221, 0.17236914746067067, 0.2430156298355136, 0.2756814840890327, 0.2791395562023814, 0.21082621978290705, 0.2951217560723378, 0.32757323879212386, 0.19297518444056327, 0.18811409380639665, 0.16134570171069773, 0.9210216392354885, 0.8771204447745744, 0.9742215204450264, 0.9235696610404809, 0.9285500585654496, 0.9648644139724306, 0.9062306517839489, 0.8635492482022752, 0.869886646148617, 0.33548196551082665, 0.3676816157133047, 0.345124263363911, 0.30987335097270574, 0.2615829959055166, 0.2687563776055353, 0.3192162690070356, 0.3122720020157922, 0.31229148879129376, 0.5399902075537314, 0.6560338574917087, 0.6308740060195127, 0.6497097653263064, 0.5543381595161081, 0.6867436675976872, 0.4607955632572043, 0.6511968433825471, 0.5990969664261258, 0.16093516206976022, 0.18926454902434042, 0.2737075110306638, 0.16772399592899578, 0.223047027135717, 0.1813109781953045, 0.21683805813193457, 0.2350447998796642, 0.19451971419462033, 0.23623653914143639, 0.20000647700721952, 0.18332055656024826, 0.16807613968384794, 0.15803996998871594, 0.18101516669682227, 0.20653681698958493, 0.16852950231906783, 0.1800659120604896, 0.027876201402654455, 0.038360493985283406, 0.016985415990873665, 0.028797774196183124, 0.047577459020848756, 0.0207945202226556, 0.09334272752839878, 0.06286819125612941, 0.07204024443833823, 0.12650239902480775, 0.10146787706420113, 0.12760221507841363, 0.09449651301620565, 0.12718821228450417, 0.12479012517040389, 0.19323955495009226, 0.16955816267654555, 0.15221929758413766, 0.00021074638914564403, 0.012939821500896898, 0.0014933282792939373, 0.0434419912015519, 0.04000891867639189, 0.03979597199835838, 0.016725060008899728, 0.0262821431655198, 0.013023319722667126, 0.1086592303324212, 0.11725740188245837, 0.13783057803219145, 0.18727371143451987, 0.15144646464586586, 0.15182591890444275, 0.10447554038079199, 0.10535628528594554, 0.11669931202277839, 0.49693121241425675, 0.48925230477265524, 0.47041549813564343, 0.48588339956918225, 0.509140100583633, 0.5078446773734941, 0.49119607220904915, 0.4725732055112025, 0.4828368566790555, 0.12083147633704616, 0.10175103462474511, 0.11070389636038502, 0.08977315954593579, 0.10103269551887628, 0.09775398375464428, 0.10386613468637751, 0.09740875282549222, 0.10358922905568235, 0.13410607827834886, 0.17100717969169288, 0.1482717678713441, 0.15819867745395566, 0.16282552076239643, 0.1629022699735877, 0.15907601979216524, 0.1806580325558581, 0.15810150852584903, 0.3701005515195267, 0.3328090571850817, 0.3488871525505457, 0.33116685163988635, 0.30150179923079823, 0.3473935610250627, 0.35098702836905016, 0.32160455532868304, 0.33996465738360515, 0.24965882349429502, 0.25845434867868144, 0.22599148583968964, 0.226047301987244, 0.2260654578956628, 0.23428752364691896, 0.22130485964347268, 0.1819551728755231, 0.23115955594845383, 0.2147078516713472, 0.2277193082829777, 0.20591819029120606, 0.21491450166055415, 0.22682830776248064, 0.2271653015375883, 0.20513096843241485, 0.2032157718329911, 0.2304921873030007, 0.21401490028581394, 0.2288236071905334, 0.2298839226056728, 0.21366644605272267, 0.21931273153358255, 0.19201953185542442, 0.2171439079442652, 0.2887074578745561, 0.3726104888804551, 0.1895715120391831, 0.7134414731514476, 0.18660561528973818, 0.17117307613909127, 0.7468901349362941, 0.16831168897604876, 0.18443232220263706, 0.16341582563674895, 0.735402014790184, 0.48765994331785856, 0.6407067470755294, 0.5392503622991802, 0.387393614186895, 0.47126225606288474, 0.47287051199850016, 0.5338538584847468, 0.4323610129184936, 0.48959761673929425, 0.18986932925755517, 0.19318029289451388, 0.17960421273680227, 0.18143620691510154, 0.18715175474264567, 0.21040350836491495, 0.17826185199004796, 0.18546634755090996, 0.19935208448011488, 0.07886751160014027, 0.08788900342159833, 0.08572198306065149, 0.0873614536979116, 0.0855021236187904, 0.08693700822416395, 0.09762118608603765, 0.09264898874842198, 0.09558631577981846]}, "mutation_prompt": null}
{"id": "09a3fd32-e07b-4aa6-a1f5-8a0122b49ddc", "solution": "import numpy as np\n\nclass HybridChaoticMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.4  # increased probability for local search\n        self.dynamic_scale = 0.3  # adjusted dynamic scale\n        self.chaos_coefficient = 0.85  # adjusted chaos coefficient for better exploration\n        self.learning_rate = 0.1  # adjusted learning rate to stabilize adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)  # using sine map for chaos\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridChaoticMemoryDE", "description": "Adaptive Differential Evolution with Hybrid Chaotic Maps and Memory for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 58, "fitness": 0.3484214498244518, "feedback": "The algorithm HybridChaoticMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8270745583619006, 0.8246686975591432, 0.8331334147385046, 0.8284955499906085, 0.8202264268289665, 0.8133773904197388, 0.8306896330527451, 0.830073425435993, 0.826570623776666, 0.6808714183406486, 0.6802815349924554, 0.6910273540023406, 0.6914182255092296, 0.6794278014717328, 0.6812177970267008, 0.6764130582580631, 0.7201029421212883, 0.6916588103414629, 0.5489456949736637, 0.5357139353418209, 0.44592663096789187, 0.5627558451125563, 0.5093659019490303, 0.4116615954248565, 0.4389862319467691, 0.47384739361468764, 0.5689944721479093, 0.39492271821069547, 0.16788328964823107, 0.4600868004522596, 0.16061846231103571, 0.37032981102492535, 0.162128625452857, 0.32478524833548206, 0.3496606626811456, 0.16434278416959802, 0.9728319868645795, 0.9404397009118135, 0.9680453729405745, 0.954519521648814, 0.9484061023705862, 0.9386522104986663, 0.9650896672181322, 0.953134446926465, 0.9547606209305265, 0.4378268493252616, 0.4202315657845477, 0.39583653430556365, 0.4330627040143782, 0.3795654814841526, 0.45457384936709744, 0.40493512547147537, 0.42873884662534123, 0.38087216406692315, 0.5619250214001312, 0.7328458850964268, 0.6124429775317024, 0.66148316599558, 0.6701635498689558, 0.6339147124536868, 0.6189729756528151, 0.6248916141314386, 0.5890681769543791, 0.2715228251870989, 0.1623359998542483, 0.19034696354312697, 0.15344492392781317, 0.20335648596140554, 0.17862613115162784, 0.280888357085639, 0.16406839428625986, 0.2246406882134575, 0.17738359267786696, 0.20722381537948442, 0.20776151682135025, 0.19093665681888017, 0.16626917821098197, 0.18041448873265686, 0.20572309445957893, 0.1884269101243018, 0.2017931778902734, 0.05762420542986324, 0.05069582891722024, 0.07364370244474594, 0.0877073427908659, 0.12551679797576143, 0.049865935810492146, 0.0816843671053602, 0.10868034892144496, 0.13646041273194043, 0.22392647898489149, 0.23025603894421753, 0.21883509765202702, 0.22133094556665367, 0.15288325953870208, 0.1816637630630521, 0.259470764716791, 0.2907183345628995, 0.25927652876144625, 0.03520912227573458, 0.04942921179822912, 0.09469248456286838, 0.1192712417158025, 0.05960831573908143, 0.05204852818911654, 0.11029111844923045, 0.10204469836123664, 0.11305274951231492, 0.1775241816461527, 0.1542835165832912, 0.17923328528530724, 0.18524435034360165, 0.20732197575891997, 0.2276692566585118, 0.16308750036663788, 0.1817717865265397, 0.19752618964270163, 0.5669691667254839, 0.5593041083992101, 0.5750970841499843, 0.5937515835125693, 0.5811010227374231, 0.5456652035005334, 0.6150622317028039, 0.5608452822735637, 0.5672893702844979, 0.10208231641132803, 0.10522524782595077, 0.10103503953521575, 0.09109976182683299, 0.105861915504743, 0.09590246037077266, 0.12104635396116314, 0.13772002578629328, 0.09490676469248083, 0.16988447082200642, 0.14979684271437566, 0.15258534986119032, 0.13913753099485915, 0.1491266852954365, 0.15521598275627735, 0.14254419902294213, 0.13281571310530782, 0.15140819214501022, 0.36419690292779094, 0.3870147760967587, 0.3820633239024621, 0.3967056708540584, 0.36557133209423676, 0.37359897450723145, 0.4347292854483421, 0.4488554269786731, 0.40943970558960097, 0.247080605667219, 0.25453249589684146, 0.2422100999077097, 0.2541489737970736, 0.23997029631721378, 0.22183659284081692, 0.2838452533467495, 0.29201771528309983, 0.24185926531971758, 0.18539511740414305, 0.19218437837314828, 0.1884955341216732, 0.19848273282652285, 0.21340494586670955, 0.22598382327449684, 0.23660759661204134, 0.20179619224393708, 0.19284129772826053, 0.3354830749954726, 0.3347145498815668, 0.21088346000081015, 0.32288434176567116, 0.24949891613012598, 0.5737558362091968, 0.5139333033552858, 0.502746848365113, 0.2843633687202395, 0.1682255117598761, 0.5858078355912227, 0.26898819963223564, 0.5324843748160748, 0.17312679038236656, 0.6255825535925217, 0.6633479279709134, 0.7227358240914279, 0.48302685250861843, 0.1657863842759325, 0.45515873558352304, 0.1954268512897358, 0.33779439531136035, 0.18964610619427547, 0.5193596951753074, 0.45977440738232633, 0.15112610838121676, 0.20555565432739653, 0.18046465132556566, 0.17695488048708352, 0.19241046851941845, 0.18119917965605514, 0.1800108484422117, 0.18294251233633618, 0.19972523357473604, 0.19338407399583157, 0.18519690708406156, 0.08246564720879546, 0.0786393170102907, 0.08706540268113583, 0.08514449236855803, 0.07566011248342441, 0.0752675013716243, 0.09225043741346695, 0.07917825597332506, 0.07287864782174491]}, "mutation_prompt": null}
{"id": "3f54dc27-c991-48c0-9270-2d84071c003a", "solution": "import numpy as np\n\nclass QuantumChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # adjusted population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 0.9, self.pop_size)  # narrowed crossover rate range\n        self.F = np.random.uniform(0.5, 1.0, self.pop_size)  # increased mutation factor range\n        self.local_intensification = 0.4  # increased probability for local search\n        self.dynamic_scale = 0.3  # increased dynamic scale\n        self.chaos_coefficient = 0.95  # increased chaos coefficient\n        self.learning_rate = 0.2  # increased learning rate\n        self.memory = np.zeros((self.pop_size, self.dim))  # individual memory vectors\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_perturbation(self, x):\n        r = np.random.rand(self.dim)\n        return np.multiply(x, np.sin(np.pi * r))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                \n                # Apply quantum perturbation\n                mutant = self.quantum_perturbation(mutant)\n                \n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory[i])\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory[i] = 0.5 * self.memory[i] + 0.5 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumChaoticDE", "description": "Adaptive Memory-Based Quantum Chaotic Differential Evolution with Dynamic Parameter Tuning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 59, "fitness": 0.1692409121106164, "feedback": "The algorithm QuantumChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.11.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.401388208906715, 0.3826184520836097, 0.40829548521475434, 0.2874036595661458, 0.32755873558569215, 0.34794333147908796, 0.38581271133942097, 0.39636633678046485, 0.3002524326421905, 0.028682269941031846, 0.061438702780775345, 0.013263367493829725, 0.14306127401874624, 0.12302867593639055, 0.13314823776238605, 0.06255797508307992, 0.038572268407025656, 0.08266078777880814, 0.09301394638678828, 0.09101926096213064, 0.11158326009560993, 0.10741438008570403, 0.09674765318486112, 0.11464555406823129, 0.11201183884208399, 0.12845435101725344, 0.11500361966847572, 0.08939497834548005, 0.10767777152331215, 0.09307675012728545, 0.09502291113888406, 0.10931079328728355, 0.0990291484221405, 0.10532159566093047, 0.1072860160322674, 0.10286811661344619, 0.11955132701648197, 0.1657511698609856, 0.09953824395534971, 0.11845679344878135, 0.11414969483835868, 0.1188527714542863, 0.15316659179822623, 0.11870370174956901, 0.13639246309691277, 0.14654633391293026, 0.1212802397205116, 0.13160356464388845, 0.16318245988080582, 0.1867976765612056, 0.1725560901732215, 0.19260517619599893, 0.1846458475256597, 0.20420390337482408, 0.1713993959949376, 0.2319974213952748, 0.2619410597806191, 0.23008662786609269, 0.2597802376915984, 0.21186268328238556, 0.21813862730442946, 0.21853733282762144, 0.18877127793112602, 0.20961657719593507, 0.22775145967385513, 0.23033719684360365, 0.1298812705637007, 0.1431651607527945, 0.10257981504317226, 0.16240703192541261, 0.1519183238022337, 0.17193816439677756, 0.21320607813054637, 0.22717479112966965, 0.24293105988416352, 0.20319035302925226, 0.19657187958023015, 0.19692184923603095, 0.24929144773101675, 0.23257658867893538, 0.23508224767522723, 9.999999999998899e-05, 0.0014245876637580812, 9.999999999998899e-05, 0.01389999816253551, 9.999999999998899e-05, 9.999999999998899e-05, 0.007221055625793782, 9.999999999998899e-05, 0.06237063708894253, 0.11076596673429628, 0.12827765017229098, 0.08733883333570336, 0.05563688242445386, 0.08088975212231198, 0.06568411845876287, 0.08332231580273297, 0.11356083966461905, 0.11966408264311723, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06345928236925014, 0.06360730970168138, 0.05774122157721018, 0.06621254414885347, 0.0401355289423172, 0.07456975701897262, 0.05949948488250956, 0.0504204744971366, 0.05338148134233467, 0.3401238006148366, 0.3398691943600166, 0.3460791342910382, 0.3257628944996841, 0.37169439417006656, 0.32363630047362435, 0.3796118393527078, 0.38990491847301023, 0.3818417698547797, 0.049873474929887696, 0.06024459517608394, 0.08105884026503596, 0.1058888507526754, 0.09768440213373908, 0.1109948523500458, 0.08329335755049394, 0.1062910294745969, 0.10159462863925206, 0.1898849402434486, 0.18236589902501166, 0.23487749166478333, 0.17000939610025412, 0.1761887975987424, 0.15187390114907373, 0.13738549041207881, 0.15066050562891264, 0.1470790298238246, 0.2130116792396357, 0.19220312958058317, 0.2350113814398297, 0.28162158695265094, 0.2757355466319267, 0.29266226096024905, 0.21331322208056658, 0.20434179906122762, 0.2359482774878816, 0.19867218980438528, 0.15144203648841015, 0.16826053813213437, 0.2297908549085399, 0.22365424997979522, 0.22180863816936225, 0.17207690227594719, 0.18223569641688786, 0.17747924295551587, 0.25013155058188263, 0.26686091003822543, 0.2245967449336147, 0.23541477128004495, 0.2531133826252854, 0.22553738103479748, 0.2578792532067884, 0.2627828039223308, 0.266277577198232, 0.17519054148313662, 0.17760166203006988, 0.17562469221582944, 0.17695369270020456, 0.1773548152407748, 0.1796896120189485, 0.17579147705687048, 0.18447893079486122, 0.18030930551393487, 0.18559895903093926, 0.1868314684934922, 0.1863095772702542, 0.44092830014646744, 0.40795515008324645, 0.4986973218900649, 0.5159513756781784, 0.41010918156896436, 0.1662875481877336, 0.19763743326589878, 0.3220581734844673, 0.3365188276733353, 0.19654773240218615, 0.2989684578221562, 0.33847889415421717, 0.21844098037041726, 0.21308518837670576, 0.3091642462320068, 0.1911980696296518, 0.19591014417778574, 0.17892723032006796, 0.18891339647986805, 0.18158024203994005, 0.1962836480225586, 0.2076335051063084, 0.178609487152656, 0.17072043125074488, 0.08384751761555653, 0.09004806585438696, 0.06715658008451186, 0.08059060736179924, 0.08585456687026094, 0.07463072510853674, 0.097129049352905, 0.09182465554490904, 0.08451954114435045]}, "mutation_prompt": null}
{"id": "426a2619-f5e4-401a-9f3d-82c237dcef5a", "solution": "import numpy as np\n\nclass HybridAdaptiveStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_search_prob = 0.3  # balanced probability of local search\n        self.global_search_prob = 0.4  # added probability for global search\n        self.learning_rate = 0.2  # faster adaptation speed\n        self.memory = np.zeros(self.dim)  # memory for storing historical direction\n        self.chaos_coefficient = 0.85  # slightly adjusted chaos coefficient\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation strategy selection\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                if np.random.rand() < self.global_search_prob:\n                    mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n                else:\n                    mutant = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n\n                # Chaotic Search with Memory Integration\n                if np.random.rand() < self.local_search_prob:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.3 * self.memory + 0.7 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveStochasticDE", "description": "Hybrid Adaptive Differential Evolution with Stochastic Strategy Selection and Memory-Enhanced Chaotic Search for Balanced Exploration-Exploitation.", "configspace": "", "generation": 60, "fitness": 0.24796180416506555, "feedback": "The algorithm HybridAdaptiveStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.6531865108226032, 0.6551294021276557, 0.6739820292544794, 0.6431545476927258, 0.6467712198298265, 0.6881705126265713, 0.6435189113080861, 0.6487349322777569, 0.6351200595776004, 0.3535970767070771, 0.32867945047416913, 0.39879860803728273, 0.35447155022342924, 0.3419955414145145, 0.3582332998973069, 0.3735156038433085, 0.34988889232381293, 0.33486574928684476, 0.14462638775896708, 0.13664453403537669, 0.1352772764004081, 0.12397284477098369, 0.13616895902282378, 0.1639456630420586, 0.12290603255552401, 0.12527734135548196, 0.14446136530558873, 0.12597736161559003, 0.11161689167995159, 0.1159721592024624, 0.11874648777105612, 0.12191537323201462, 0.12975267439840266, 0.12856020381586064, 0.12690468324158044, 0.11340042233823533, 0.8946281445770042, 0.9185626994277367, 0.8587729844512302, 0.9330558493634299, 0.9048527924153279, 0.9131593158156145, 0.9123255958675782, 0.9650034704195646, 0.9179664186222628, 0.26780516537403265, 0.2557638949434421, 0.24728182762024564, 0.23296102524430773, 0.27779227418631003, 0.2589927934348456, 0.23669639640121654, 0.2509835178662241, 0.2383847583885187, 0.2424421091634933, 0.32511233610884116, 0.2862586344990208, 0.36250770870880933, 0.4828919279966817, 0.42571039032447033, 0.329052632541881, 0.43900047468801795, 0.3513848965661407, 0.13262097971480868, 0.13827864171370585, 0.13855283247511996, 0.14703531144704807, 0.13273133334244125, 0.1577052810655467, 0.13325947503910174, 0.14890267515972067, 0.16141498326089188, 0.1248191758131979, 0.13582506907454628, 0.14928099897765046, 0.16096323495178744, 0.13463543563107827, 0.14777025396029497, 0.1347278300811937, 0.16163938845195536, 0.13664979267978794, 0.008690303336649774, 0.00830734744074657, 0.020366206601398873, 0.01803147568211738, 0.010045804730665853, 0.014100395322392267, 0.030862037740644, 0.005283922283956466, 0.014046535501042512, 0.16980797786079493, 0.13309416591492462, 0.14160834720777615, 0.13432548361672247, 0.11876504842750624, 0.11519793455072835, 0.16287292825325417, 0.1557872117382716, 0.16447363499889145, 0.028703249553779453, 0.018725079210694773, 0.009679089419606823, 9.999999999998899e-05, 0.004664453763741916, 0.012128482787266193, 0.012914734915377424, 0.018708166564583406, 0.007438731942027932, 0.10746196642975536, 0.12458714629998435, 0.11594616178699757, 0.12453667993838413, 0.09735943353556908, 0.1406610074166076, 0.09989642057371761, 0.10535014484538185, 0.10785232243085952, 0.4376717729979569, 0.46092182658456027, 0.4696555413744131, 0.45221832551989627, 0.44832382364963896, 0.460637546515831, 0.4405562013046159, 0.4580440373243867, 0.47635700366394595, 0.10467727785665393, 0.096458689191399, 0.09778398275089129, 0.08428418217392464, 0.09747752699341494, 0.0904143987152749, 0.08922352288881663, 0.09560172208118634, 0.112258241224089, 0.15174335449494014, 0.14923889667832468, 0.13514798578396003, 0.19498900131785324, 0.14954787650586532, 0.14121841951898984, 0.14099196787641888, 0.138694049277723, 0.1297169189979147, 0.2703785301183671, 0.2791878876217193, 0.3150525222518098, 0.281882812278091, 0.2768666644640594, 0.28283817008685497, 0.29775733468243726, 0.2979160871513067, 0.3114067906359934, 0.21763534057218348, 0.18567713733734392, 0.20318058743797385, 0.18918131104442726, 0.20119022175266, 0.20873124093893225, 0.19012655750242113, 0.19161113912506522, 0.22506514837961256, 0.1920183402837643, 0.19787612845440716, 0.18773934876346443, 0.20703039399534529, 0.2097955205784866, 0.2110391810875033, 0.22372377878841954, 0.18598145961738077, 0.1834052304247108, 0.20537187219155362, 0.20299808023366905, 0.2153422101194865, 0.21379401713533563, 0.19309398079475015, 0.1914473014305077, 0.18597285764754257, 0.22573503194596967, 0.2083826293463742, 0.5815838318449169, 0.18154886327435837, 0.17458970097518034, 0.5344107414985338, 0.3650004771140539, 0.5815483550393349, 0.34378224657032896, 0.46350997049666465, 0.40418126097810214, 0.41583268369666115, 0.27856181615309017, 0.4169741726598518, 0.2575415394079933, 0.2663319446142054, 0.27447330504212875, 0.2924541407236604, 0.3458201220218755, 0.3341011644576354, 0.1821886833740224, 0.19132302815871172, 0.19125571329057578, 0.19522018850437595, 0.1862819160591388, 0.17920760181963613, 0.20320219463366185, 0.18759594613824682, 0.18949838190095103, 0.07472409888027343, 0.08276807676867337, 0.07653061591721455, 0.07789923631956919, 0.07177331406649012, 0.07408499235381949, 0.07124458016173651, 0.08835777844733528, 0.07757675706197809]}, "mutation_prompt": null}
{"id": "90f2ce99-6c5f-4fca-84b2-6a3833509fb1", "solution": "import numpy as np\n\nclass QuantumInspiredChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 11 * dim  # slightly increased population size\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.45, 1.0, self.pop_size)  # adjusted crossover rate range\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # adjusted mutation factor range\n        self.local_intensification = 0.40  # adjusted local search probability\n        self.dynamic_scale = 0.3  # adjusted dynamic scale\n        self.chaos_coefficient = 0.92  # adjusted chaos coefficient\n        self.learning_rate = 0.18  # adjusted learning rate\n        self.memory = np.zeros(self.dim)  # temporal learning vector\n        self.diffusion_rate = 0.12  # added for quantum-inspired diffusion\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_diffusion(self, current, best):\n        return current + self.diffusion_rate * np.random.normal(size=self.dim) * (best - current)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and strategy refinement\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory and Quantum Diffusion\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                    mutant = self.quantum_diffusion(mutant, local_best)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumInspiredChaoticDE", "description": "Quantum-Inspired Adaptive Chaotic Differential Evolution with Dynamic Diffusion for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 61, "fitness": 0.386468794014295, "feedback": "The algorithm QuantumInspiredChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8569248482626467, 0.8609016622820993, 0.8652801234393381, 0.8584104134371962, 0.860541770997769, 0.865561174233823, 0.8681827581728907, 0.8681353487498166, 0.8561974102143836, 0.7465643891107212, 0.7481815186267153, 0.7359656446110794, 0.7241651852957123, 0.7234636888375088, 0.7399901967353477, 0.7297022861641596, 0.7542365112361288, 0.7333608222073467, 0.3916331647946869, 0.5160687859888711, 0.5196359743598405, 0.5474555351267425, 0.4760009483511739, 0.443668914122901, 0.5043485305225011, 0.5361516335076586, 0.40405297617722025, 0.17019059568284134, 0.1659256703464954, 0.3129345958235429, 0.2889756177396462, 0.22801779723194882, 0.15760077021756513, 0.3339751816825912, 0.2534465145509035, 0.30912155484930126, 0.9610967823853029, 0.9724539158027052, 0.9879050494043173, 0.9721900820559664, 0.9844949662176314, 0.9531765376655027, 0.9758689578012835, 0.9790849172454734, 0.9540014443985955, 0.5831252474332957, 0.5891608952445332, 0.5646648213101348, 0.5436199183944126, 0.5379559183723623, 0.5666019759504234, 0.5160121846951807, 0.5217372622089667, 0.5303404712883439, 0.7584891813506025, 0.719794001113611, 0.7613575941001209, 0.7903528195765136, 0.8288409355081151, 0.7440238929692576, 0.7278945554026837, 0.7196270122739423, 0.8098479547641042, 0.2853139160243856, 0.12207849086575862, 0.3142410904688905, 0.22364357329239792, 0.2488649344049031, 0.25287954836347537, 0.28918010934622584, 0.32919392875534725, 0.23263379612205404, 0.22798668407898204, 0.12788057701683797, 0.22360994970243342, 0.26119928198378994, 0.2585159440199766, 0.24289830053467332, 0.2594138282380998, 0.29231203498060876, 0.2695702039059745, 0.03659997582488628, 0.06351840474377446, 0.05347753749141704, 0.1020209328311319, 0.08666546736248038, 0.0487731030055214, 0.0653887395184567, 0.1223165032446033, 0.0714324358723305, 0.1626893223509096, 0.1577827661754927, 0.1601316192855209, 0.12721337015379597, 0.16838186725251303, 0.17354046659315425, 0.194078424543088, 0.20389361795792282, 0.1498298831214877, 0.10076591286412206, 0.13055199542819318, 0.07614769800086318, 0.0733333994608385, 0.08787159032599356, 0.06134641557710041, 0.14687428699443628, 0.11084780966760632, 0.12173496921977944, 0.21397085850972342, 0.24925700460735623, 0.21487072821180286, 0.24242617607321137, 0.22961443546645866, 0.22169397447047245, 0.18952348511849038, 0.227434517908209, 0.1783465970423227, 0.6292101122191667, 0.6286130322816157, 0.613684061244538, 0.6035038052694797, 0.6030804270506902, 0.5821656594484306, 0.6180183882752515, 0.6087963641620788, 0.5926427905132989, 0.12809285965560024, 0.1265545407248403, 0.11421377824281898, 0.10839445872459186, 0.11097054059691613, 0.09969607942680447, 0.13757146231360895, 0.11936092904424045, 0.13709593152738275, 0.14723595651402632, 0.15666292317412922, 0.15961285655272717, 0.1561650840993991, 0.17262943662092367, 0.14894721450723625, 0.1354193890240345, 0.13926705940097384, 0.18149182431299637, 0.49381260721360964, 0.5001588225726608, 0.49059738522135654, 0.4817979566932714, 0.49144740789598795, 0.5140696705216993, 0.5440556656571984, 0.5226703656902928, 0.5493833825539356, 0.33186910593164576, 0.31204614849948187, 0.288893824834655, 0.31136748529113645, 0.3348233769514686, 0.3241395100982618, 0.3787369156179998, 0.3413213401227966, 0.2460617621684783, 0.19706530815842316, 0.22699306688753218, 0.18671956321119565, 0.20514751184985391, 0.20519679284827785, 0.1989525224066001, 0.22817327855605962, 0.208530323308589, 0.22955382791624113, 0.5145044305081076, 0.6079662956773162, 0.2501284523214006, 0.24070610861047814, 0.49314729238996813, 0.5530082276820831, 0.46030544942789153, 0.605657353456349, 0.23736608489087152, 0.16249637108286752, 0.558449886516907, 0.8439759668548641, 0.810147981400493, 0.7894704538798584, 0.1960602493042044, 0.8029908950685049, 0.18483261996970501, 0.6944661773979798, 0.16753306547158842, 0.6626886450362512, 0.4056551817820334, 0.16647894711243005, 0.6392626246920405, 0.6852324771140083, 0.4948556062842474, 0.20968956089150492, 0.21205925848939378, 0.1911636039542729, 0.19798698882962362, 0.20545085975650745, 0.1811239233272891, 0.1734908493415438, 0.19149499370879053, 0.19367615633391433, 0.1858567014301804, 0.20843347105195298, 0.0878023742458347, 0.08788489772610286, 0.09352549144299283, 0.09354659909499552, 0.08856697053059648, 0.08338737182721345, 0.08810920826717761, 0.09246320010278819, 0.08702599619131202]}, "mutation_prompt": null}
{"id": "8d58914f-939c-4fba-9cda-d385a213108f", "solution": "import numpy as np\n\nclass ImprovedChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.4  # increased probability for local search\n        self.dynamic_scale = 0.3  # more adaptive dynamic scale\n        self.chaos_coefficient = 0.95  # further exploration through chaos\n        self.learning_rate = 0.2  # faster adaptation\n        self.memory = np.zeros((self.pop_size, self.dim))  # memory for each individual\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_values = np.random.rand(self.pop_size)\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_values[i]) * mutant + (0.5 - chaos_values[i]) * (local_best + self.memory[i])\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory[i] = 0.5 * self.memory[i] + 0.5 * (trial - self.population[i])  \n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_values[i] = self.chaotic_map(chaos_values[i])\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedChaoticDE", "description": "Improved Chaotic Differential Evolution with Enhanced Memory and Dynamic Control for Diverse Exploration and Exploitation.", "configspace": "", "generation": 62, "fitness": 0.38849085106455816, "feedback": "The algorithm ImprovedChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.8720712024256432, 0.8717116985275765, 0.8706053525472999, 0.867722845713304, 0.8626150912844617, 0.8631880057648754, 0.8679196397485626, 0.8685574205092517, 0.8629330191731011, 0.7463189103611179, 0.7317138561053184, 0.7374189368119531, 0.7440087336929905, 0.7454020936195864, 0.7273196890427068, 0.7168325818963448, 0.7324478173176431, 0.7407719940551041, 0.4260440793229914, 0.41172079958077923, 0.3486693250721914, 0.44379318612156826, 0.4156560607042019, 0.44825024474717157, 0.39678238342990735, 0.49782786424856273, 0.15730514298716192, 0.3444882738057692, 0.41967277131387204, 0.314538143721958, 0.16116368324939412, 0.29600921055129326, 0.1619972730020578, 0.24817358333133788, 0.25149835120248343, 0.1621918074278983, 0.9639047442821262, 0.9666824064961534, 0.967625369841915, 0.9531513733078263, 0.9590170630114713, 0.9741163942677015, 0.9505794254256942, 0.9571466977335719, 0.968263391843074, 0.5704830217441423, 0.5797175064266031, 0.5240294236625369, 0.5986980088852163, 0.5872004782385829, 0.5501037857890094, 0.5417483916858942, 0.5167541168671649, 0.5093486153656641, 0.747373612556257, 0.6836005602449085, 0.7534081512479304, 0.7811588524683211, 0.8447396113044532, 0.7759413176221021, 0.7538935390584525, 0.797392923515804, 0.8155466088915753, 0.22175178774249038, 0.20108583061864338, 0.21124852761925705, 0.13096505678164738, 0.12932639526222445, 0.17441988355766302, 0.21511707737352503, 0.21732634781145765, 0.21741523181657985, 0.17790595589805525, 0.23201440252953043, 0.15673001739894843, 0.32637242922578347, 0.27977398974687673, 0.22355707916476708, 0.18602668050528215, 0.20570104925320132, 0.20267172614407547, 0.17943181465785873, 0.06508252458217745, 0.15571989889482662, 0.17319126734521473, 0.12900499579031333, 0.17187383300471137, 0.18772710429947526, 0.13980982559453392, 0.09899531772259484, 0.199996391955944, 0.23785740694855273, 0.2031420593832941, 0.23486165988260554, 0.15639456274285712, 0.21473834115073231, 0.2778483984483988, 0.2382951021832871, 0.20172227324430425, 0.13288009373291787, 0.08551951864482998, 0.03838373911520376, 0.12468392450646193, 0.09846170441641366, 0.07639538470258089, 0.08306217358423362, 0.10214366337052105, 0.08036609060308786, 0.2585417908233216, 0.22182393723551852, 0.22443084840229632, 0.29450973156010896, 0.27823237952123114, 0.29726081530779647, 0.22898037549781047, 0.22924540832818496, 0.2371572861253174, 0.6467153783986723, 0.657963864124278, 0.6420334943809213, 0.6590281046536228, 0.6307822278683892, 0.6372689181770151, 0.6709915937491023, 0.6441311101394396, 0.6302389780569295, 0.1314339870712391, 0.11601220741155027, 0.15774848217925097, 0.12113117591350453, 0.11927464222106132, 0.1329921410735012, 0.11689144123532258, 0.11853792489897619, 0.12692019683808797, 0.14242817850623446, 0.1474304593811917, 0.125367170792284, 0.14548128386114278, 0.14181739631489143, 0.15780039722549355, 0.16729162530296415, 0.15228482960174405, 0.16286020140817614, 0.4768580144935878, 0.46605436087195207, 0.46195418316306636, 0.5204229775537782, 0.4500378985306992, 0.46725725578895305, 0.5441220736972305, 0.5340150773031241, 0.5853445765355453, 0.23675624595044853, 0.31565231937898375, 0.30214097315431476, 0.2586448963329041, 0.21475605565869615, 0.35469452936383983, 0.39318238204786726, 0.38221596382862166, 0.23315695898467437, 0.195873563741633, 0.2110894950580151, 0.21771764725387743, 0.23386335899898836, 0.21681536947981195, 0.2311988610925887, 0.22745206651748773, 0.1983453689557536, 0.2337210892565169, 0.621626014842701, 0.24987455667497582, 0.20052173034311938, 0.5409294649607175, 0.4521992141241482, 0.5652654782412165, 0.23582195315156573, 0.36630439310317653, 0.48823912756854004, 0.18660751709907053, 0.805149673658779, 0.7182893672340298, 0.16170419631103228, 0.1842909743184198, 0.8063025937468439, 0.7539964495675785, 0.7414929342337869, 0.8482305777595719, 0.7672332177625004, 0.2076457694904098, 0.7352491732630821, 0.2081745796536878, 0.3525570926952055, 0.692932637787224, 0.20098784054403618, 0.15511838254919352, 0.7708603124359262, 0.17502577490531945, 0.1717403901573229, 0.1773728256612268, 0.19688025198397907, 0.18516603539267285, 0.18856404603359034, 0.17833240303196674, 0.18648312145725332, 0.18206766368586558, 0.08875000201714389, 0.09492696277928281, 0.09085037873300228, 0.08934559086683891, 0.08709916697267162, 0.08692770327749988, 0.0844829051515198, 0.08623944743796197, 0.08581538753983753]}, "mutation_prompt": null}
{"id": "c3d3527e-7458-473b-8fa4-f18cb41d7dfe", "solution": "import numpy as np\n\nclass AdaptiveMultiNicheDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.8, self.pop_size)\n        self.local_intensification = 0.4\n        self.niche_radius = 0.1\n        self.chaos_coefficient = 0.85\n        self.learning_rate = 0.2\n        self.memory = np.zeros(self.dim)\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def get_niche(self, ind):\n        distances = np.linalg.norm(self.population - self.population[ind], axis=1)\n        return distances < self.niche_radius\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                niche_mask = self.get_niche(i)\n                if np.any(niche_mask):\n                    a, b, c = np.random.choice(np.where(niche_mask)[0], 3, replace=False)\n                \n                dynamic_factor = 1.0 + np.random.normal(0, 0.1)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n                \n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMultiNicheDE", "description": "Adaptive Multi-Niche Differential Evolution with Chaotic Search and Dynamic Memory for Enhanced Global and Local Exploration.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {}, "mutation_prompt": null}
{"id": "922c6330-8932-42d1-bfbe-50a727a3489f", "solution": "import numpy as np\n\nclass AdvancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.40  # adjusted for more local search\n        self.dynamic_scale = 0.30  # modified dynamic scale for more variation\n        self.chaos_coefficient = 0.85  # slightly reduced chaos for balanced exploration\n        self.learning_rate = 0.2  # increased learning rate for quicker adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdvancedAdaptiveChaoticDE", "description": "Advanced Differential Evolution with Dynamic Learning and Adaptive Chaotic Mechanisms for Multifaceted Exploration and Exploitation.", "configspace": "", "generation": 64, "fitness": 0.42339184610625735, "feedback": "The algorithm AdvancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "cd9a63eb-31f7-4069-8ed8-050b76147c97", "metadata": {"aucs": [0.881132556406716, 0.8789662008447705, 0.8867910804819656, 0.8829675107327631, 0.8873929965997328, 0.8860338812055654, 0.872324024503104, 0.8774075223368037, 0.8801740565355927, 0.7810997964204296, 0.7856347055139682, 0.7729674828257116, 0.770600530923933, 0.7778116956827295, 0.769686418940696, 0.7816438244169399, 0.7738385024195799, 0.762864125636891, 0.49856183944046173, 0.4892887347615965, 0.5655875120224818, 0.3786351891212699, 0.47610916118683344, 0.5558067766602386, 0.5719768121580451, 0.46100580659257806, 0.5673765894114655, 0.24588872563041253, 0.2728697455642749, 0.3718678470636716, 0.15041814300691625, 0.33758950507877206, 0.15729867506162432, 0.3379613544586456, 0.14349261932922985, 0.3196964577603961, 0.9605948186837505, 0.9361939717554401, 0.9622138101692125, 0.9755303265978128, 0.9624614579830649, 0.9528255023974296, 0.9776078218247316, 0.9642540286987298, 0.9560973825952683, 0.6356327850475109, 0.639888387630916, 0.5828445169510432, 0.640873877325555, 0.6293156027444573, 0.6485192116395231, 0.6020143248340181, 0.6540659088063764, 0.5551179597746964, 0.7923252129229232, 0.7979765621513777, 0.7754134058369342, 0.7349922753039546, 0.8580785558645964, 0.8368486349320755, 0.7616583521461079, 0.8174253088518263, 0.8221416551732538, 0.28717259739287315, 0.3159231639357448, 0.2333738166197471, 0.1274051655491636, 0.13074457634065262, 0.39357213366454213, 0.35047844269064865, 0.24698156040349528, 0.3064749656375725, 0.12813549881232034, 0.3364046523927334, 0.29059775726703485, 0.2394183726203919, 0.30858098689583247, 0.23083924250069288, 0.2611627949143156, 0.30898895716176844, 0.29101749933172505, 0.2125949879103265, 0.22570763765092572, 0.16580563821304073, 0.18452691578990077, 0.2095338258021221, 0.18518444769373066, 0.16867241111345355, 0.27045056378835364, 0.24287620293247014, 0.3622287743954571, 0.2970667444087145, 0.3681194903155086, 0.3043957315296647, 0.3379788656770012, 0.3352768290106858, 0.3853043725461628, 0.40084633174134976, 0.39340454379878265, 0.08149202397426414, 0.06540139700181402, 0.06291158073008996, 0.16710970592668073, 0.15767819138777017, 0.19067602868965428, 0.07706390360571402, 0.12143783970963273, 0.24763488320654548, 0.2650626418201305, 0.23555079762715236, 0.27028224175219806, 0.27899238665544057, 0.29649733825801183, 0.3231947296025489, 0.2410991603395417, 0.25759854066194954, 0.24428636572005435, 0.7023835833888314, 0.7008110697079522, 0.7129501043043605, 0.6852349920786678, 0.7103091459680535, 0.6958493592943304, 0.6232371344216279, 0.7038197479172752, 0.6846880301609581, 0.12230884528351149, 0.1317039654467539, 0.1269424215762529, 0.12643535572173603, 0.11584585600749797, 0.12385239238608281, 0.12623720709638053, 0.1331501671133698, 0.1258129421160924, 0.15052950183908942, 0.15010611352816272, 0.1323130064397564, 0.13263193966421638, 0.12658053774418476, 0.16714232955104125, 0.14851170285130977, 0.15062291129071637, 0.14456384740077521, 0.46788466297396425, 0.5249972645639744, 0.5316053015920952, 0.5268317427220881, 0.5236558865654686, 0.5189902087130729, 0.5766872642786962, 0.5961304247075065, 0.5757524533196612, 0.2951502368313178, 0.3614404158632837, 0.22700065206240005, 0.20703859746291264, 0.3905491550334411, 0.3938721649779555, 0.39220117383395214, 0.3935059538051331, 0.43297472713095986, 0.21271214349435064, 0.2321718669217574, 0.22628027438658793, 0.2153379133204707, 0.2068206470188415, 0.20805597900261208, 0.2221884828380819, 0.23211278048114803, 0.20092532202172464, 0.21658040070015794, 0.21821209431682287, 0.519351724566014, 0.2113144141247575, 0.5713785691905255, 0.6219937107078999, 0.663826964338033, 0.4940186343657984, 0.4990166915923743, 0.1853838692561396, 0.17340464465266647, 0.18634467588283765, 0.7754950315659244, 0.8527234964786614, 0.9067680208615341, 0.16466899117517642, 0.1781706178426382, 0.7470209543891861, 0.7941915178392891, 0.8071167910280583, 0.6230261606150355, 0.6935771545550957, 0.7565442171763193, 0.7217511633119589, 0.1625612915367659, 0.21265696477521467, 0.7840229537901237, 0.20017311150442552, 0.1875358222521556, 0.1877516956223182, 0.17482649154618812, 0.18114144897673934, 0.20859066715453822, 0.18306278658416442, 0.17771627263210488, 0.17569543254603814, 0.09016431907493239, 0.09172902439353292, 0.0849737142410597, 0.08328673733106717, 0.0895610860021736, 0.08716071799560754, 0.11626109590924094, 0.08904411356874065, 0.09049827426162771]}, "mutation_prompt": null}
{"id": "b147c758-f377-45bf-b1f0-36417f76b1fd", "solution": "import numpy as np\n\nclass EnhancedChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # slightly reduced range for F\n        self.local_intensification = 0.35  # increased focus on broader exploration\n        self.dynamic_scale = 0.25  # refined dynamic scale for variation\n        self.chaos_coefficient = 0.9  # increased chaos for enhanced exploration\n        self.learning_rate = 0.25  # further increased learning rate\n        self.memory = np.zeros(self.dim)\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Selective Intensification using best found solutions\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # more balanced memory update\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedChaoticDE", "description": "Enhanced Chaotic Differential Evolution with Adaptive Learning and Selective Intensification for Robust Global Search.", "configspace": "", "generation": 65, "fitness": 0.3929629560780883, "feedback": "The algorithm EnhancedChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "922c6330-8932-42d1-bfbe-50a727a3489f", "metadata": {"aucs": [0.8589450444555469, 0.8632040916877561, 0.8617981192542582, 0.8697556990491987, 0.8574436061478325, 0.859338194896425, 0.8632654610792381, 0.8602027591097755, 0.8607123321712564, 0.7555391722850792, 0.7409200329235945, 0.7378073307366867, 0.7425608325666221, 0.7557005273730312, 0.7366867198795524, 0.7412122685245044, 0.7468038334150371, 0.7283819994216258, 0.5017059063895566, 0.5098422944021753, 0.4513296679779558, 0.47325049431256516, 0.1686671984709075, 0.4439621433257961, 0.31260125424300556, 0.40304493382732265, 0.44305251516434463, 0.16525532462528358, 0.326927748534636, 0.16170830961188642, 0.2753850435817239, 0.40536429668240803, 0.42537282248726405, 0.3586761779523716, 0.2711858731679223, 0.15920362890655726, 0.9668306009549976, 0.9319760048994503, 0.9397086330572119, 0.9647090734820103, 0.9470763831222466, 0.9397357800619847, 0.9725427115382793, 0.9549194533969252, 0.943371937223887, 0.5757121855362111, 0.6062270411012748, 0.5905381781607332, 0.6405929837097118, 0.5615276442283579, 0.5981609318528585, 0.5591579958005785, 0.5489032497463927, 0.5227060694040957, 0.2236838334233504, 0.7680235603425004, 0.7594801930762305, 0.8044078075938386, 0.7689210462258617, 0.8042435257152847, 0.7108315237421019, 0.768032524039236, 0.7783829953486718, 0.3537264547164102, 0.3333333632434494, 0.23100036506316224, 0.17798839201866545, 0.2769167226970801, 0.25231431745457167, 0.21935806161370774, 0.2179716371809508, 0.21816595110506254, 0.2089971369192395, 0.23071885456943286, 0.20024347754695115, 0.26245121933033033, 0.24442099545795049, 0.20063752993046358, 0.22907301151389625, 0.25617049911141876, 0.22602209094365366, 0.18591122575293717, 0.11815119899521509, 0.11125513636272621, 0.13390694805512626, 0.16797795442274333, 0.15723392661138424, 0.22781014923553145, 0.17743597133880196, 0.14597346391319155, 0.32030347725720165, 0.27024412779752127, 0.31333296408415634, 0.27127430944659214, 0.29944536297524327, 0.26230227013757157, 0.34263033725865266, 0.31908449824952434, 0.317312255094957, 0.0657199491090239, 0.11835714804562103, 0.11485694515618539, 0.07005486590699006, 0.10336902324805575, 0.12523457410198024, 0.07910779617201202, 0.1226324421514089, 0.19529308486831298, 0.24198310253461963, 0.23072266341967418, 0.2229864103691691, 0.2401545552219806, 0.2512138088200626, 0.26280637984022337, 0.19278634626144797, 0.2367953768860821, 0.21159372303759694, 0.6365407701009747, 0.6492998204280875, 0.6230670062031008, 0.6300304621964798, 0.6477205553854125, 0.6616781092344286, 0.6519375369284776, 0.6387992089253203, 0.6160469894948897, 0.10316818278769024, 0.09981092530897917, 0.11656422050385629, 0.12579005236356056, 0.11106391616133604, 0.12446813628409525, 0.12993492339776003, 0.10790087530052228, 0.1047680389709229, 0.12695216720392177, 0.14970142573228784, 0.14357636013055652, 0.16981404404329847, 0.15579462268061728, 0.15517325330990284, 0.13899096230009, 0.14009479952836157, 0.1505811582156139, 0.45841058411328517, 0.4304117916041812, 0.4356016700857097, 0.515181889789389, 0.4966019946278717, 0.4961466791741892, 0.5365438724294196, 0.5076589367868325, 0.5253688412393497, 0.25892683813842177, 0.3316468534906325, 0.3419258043415331, 0.341710842255581, 0.36014929594163714, 0.31389966246032786, 0.3703614980631894, 0.27368404923415024, 0.32242471258172856, 0.20868767164910318, 0.20627800636577331, 0.21526067971945628, 0.2210299360954342, 0.2131064706033633, 0.24333915717199672, 0.21208421418538936, 0.20924425635616217, 0.21328344367877217, 0.41007241592210675, 0.5396196012809511, 0.352502781153212, 0.5587203178726887, 0.473788921881676, 0.22732648639518593, 0.23758294545233305, 0.5750088551630409, 0.4320009739196893, 0.17632462195582443, 0.7280545718042406, 0.18466911970973054, 0.8400983308466509, 0.8107896703049512, 0.7533484539347539, 0.7115129245666342, 0.1741078757300204, 0.3408145520669049, 0.7512311510786849, 0.6869753868111412, 0.6954803482591385, 0.16458328950785994, 0.5947104849435889, 0.20713498728373037, 0.6180470548810346, 0.20409639570776195, 0.20892921192385816, 0.20524421201484355, 0.1818557460195669, 0.19308230545355842, 0.1974869358622161, 0.17665580615623044, 0.17636517229767446, 0.18988366235568943, 0.19148431008983402, 0.1774371009950061, 0.0942534344619611, 0.0813855503823836, 0.0847199849693332, 0.08546443158702532, 0.07536133856481952, 0.0790213538333685, 0.08454411407182671, 0.08005225761668477, 0.08594951249333138]}, "mutation_prompt": null}
{"id": "2560d52e-bf9b-405e-ae03-e78ce29b5cd9", "solution": "import numpy as np\n\nclass QuantumAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # increased population size for more diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # slightly higher crossover rate\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # adjusted scaling factor\n        self.local_intensification = 0.35  # balanced local search\n        self.dynamic_scale = 0.25  # less variation for stability\n        self.chaos_coefficient = 0.9  # higher chaos for enhanced exploration\n        self.learning_rate = 0.25  # further increased learning rate\n        self.memory = np.zeros(self.dim)\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)  # changed map for deeper chaos\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (1 - chaos_value) * mutant + chaos_value * (local_best + self.memory) + np.random.normal(0, 0.1, self.dim)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumAdaptiveChaoticDE", "description": "Hybrid Differential Evolution with Adaptive Chaotic Learning and Quantum-Inspired Mutation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 66, "fitness": 0.30173637140588855, "feedback": "The algorithm QuantumAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "922c6330-8932-42d1-bfbe-50a727a3489f", "metadata": {"aucs": [0.7785937047257624, 0.7741159611032337, 0.7697062924174117, 0.7667368179200428, 0.7501982521797528, 0.7690298320546076, 0.7682241337238442, 0.7756504245114769, 0.7570300237492797, 0.4893583261691671, 0.47029590183046843, 0.45427628407209275, 0.4696518191963589, 0.4287450916922628, 0.4737587130911106, 0.46715037207195786, 0.4857324331475362, 0.47457632701262, 0.25599289892415955, 0.2933191493670788, 0.36317234011423105, 0.27831921750147437, 0.297041534786309, 0.20026480504898514, 0.2491517958737588, 0.2534253507327968, 0.22228237315674493, 0.16581703483254262, 0.21856462221705686, 0.15410942777016257, 0.21989276359162835, 0.22684939977260488, 0.25385660111277, 0.18059725395775128, 0.22494903268118538, 0.1979187872981294, 0.993062755007833, 0.983258482442443, 0.9774794440167117, 0.9899434273337525, 0.964811474192149, 0.9903855067404812, 0.9760640585294605, 0.9846108748196989, 0.9817796356626467, 0.36102544363088895, 0.36105864334752047, 0.33494161393510435, 0.3404775089359633, 0.34118122504732096, 0.39955822737830315, 0.3407130766939668, 0.33152368791282083, 0.33774839957856106, 0.6609746808604716, 0.6294323829352524, 0.6462721221208744, 0.5884187357034533, 0.44839712928069986, 0.5655153470285357, 0.5858385269918116, 0.8011191992686735, 0.6780067828052299, 0.29092945143616145, 0.16742638874195437, 0.1757931007349942, 0.17829525697061477, 0.1804648660605097, 0.17228414394139413, 0.28952755580119915, 0.16747395771082174, 0.1727202855374872, 0.23242775931636084, 0.19733277493776302, 0.183770512610554, 0.1647420387570948, 0.1309658779748466, 0.17870165609413158, 0.21137320528871728, 0.2049066227719708, 0.20750145592976887, 0.04545436485525567, 0.03157965155482656, 0.04426299157362046, 0.043990315416894576, 0.010205549682022141, 0.03139691640303721, 0.028068145141223577, 0.02689426164816544, 0.026389295512219357, 0.14767674033465628, 0.14638852489315557, 0.189199512632239, 0.1445638094474645, 0.16240889703818917, 0.14152285162408484, 0.19373546667468178, 0.14513037850412547, 0.1624080129308182, 0.03930174462934788, 0.041536268290929046, 0.027799997261563347, 0.05540756728357499, 0.08057603357760867, 0.02839621600275155, 0.04885946901407656, 0.03791167000717055, 0.047001680099695076, 0.14713427493975073, 0.15746649957841508, 0.1312507064558187, 0.16059165410839993, 0.1581769761683679, 0.1550885522132498, 0.13479367217540716, 0.14666065542351825, 0.14402133428621477, 0.49903822278912435, 0.49367995715031, 0.5310755269856042, 0.4821249411891366, 0.4832244477259129, 0.5010158611829267, 0.5160359625105857, 0.5062310114589866, 0.5119459876115058, 0.16099845958243442, 0.1303528957369614, 0.1302139050567661, 0.1093111636473506, 0.10758484525347578, 0.13761637795801618, 0.1179671888801247, 0.10704847793320749, 0.10683493060575988, 0.1541211286710169, 0.16557469374180633, 0.17253433204884006, 0.15061172610521367, 0.15784681174834292, 0.1689204128169567, 0.1468240430981188, 0.16599518904784982, 0.1497178042367011, 0.3228332117718261, 0.33391939896987355, 0.32060883536299734, 0.3563029999017251, 0.3407082013572139, 0.35049585544901374, 0.3764954709902777, 0.3739667087900458, 0.3860629673269347, 0.25660226233198846, 0.2601379854671807, 0.21132244353129492, 0.22023007439685105, 0.1818964354418735, 0.26785914163037905, 0.25745939661712114, 0.2660032634767553, 0.254420501409546, 0.23112299390233948, 0.19049104987264787, 0.20456334821317756, 0.2188940569617548, 0.2535567061755656, 0.22097975686219018, 0.1952094512108078, 0.2158127755728465, 0.22014870469524206, 0.23627565888279245, 0.3887691062078259, 0.2674058608581138, 0.354740229956071, 0.38859290102217625, 0.4697174784795526, 0.3096264082105994, 0.20548177597162331, 0.29762645845022384, 0.209182018960675, 0.19366107315455894, 0.1854964371583665, 0.3562972755317977, 0.1953944600785682, 0.8457599387071801, 0.7125302327522254, 0.1692812208436073, 0.17152089177399998, 0.16746601880913126, 0.2097028129392281, 0.16560602273594738, 0.5918407610385921, 0.19865476937732096, 0.5598179072051246, 0.21110729286086494, 0.2098429981287836, 0.16535517842349345, 0.20105625810978944, 0.1787206786555916, 0.199842615908165, 0.17387649513906067, 0.18402454398386336, 0.17494865507519608, 0.18054336031483542, 0.18635027085529188, 0.18840288213627931, 0.07934414059344941, 0.0877376824985393, 0.09010211684012281, 0.08925970951682793, 0.08361141546530182, 0.08587540117492465, 0.09650323156567953, 0.07764756448769061, 0.08606465076250513]}, "mutation_prompt": null}
{"id": "88652a65-7ef0-4666-94e7-66904846bba2", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # adjusted for improved local search\n        self.dynamic_scale = 0.35  # modified dynamic scale for enhanced variation\n        self.chaos_coefficient = 0.9  # slightly increased chaos for better exploration\n        self.learning_rate = 0.25  # increased learning rate for more rapid adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_superposition(self, a, b):\n        alpha = np.random.rand()\n        return alpha * a + (1 - alpha) * b\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation using Quantum Superposition\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.quantum_superposition(self.population[a], self.population[b] + dynamic_factor * self.F[i] * (self.population[c] - self.population[a]))\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # update memory\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumInspiredAdaptiveDE", "description": "Self-Adaptive Quantum-Inspired Differential Evolution with Chaotic and Memory-Enhanced Exploration.", "configspace": "", "generation": 67, "fitness": 0.29570296291505727, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "922c6330-8932-42d1-bfbe-50a727a3489f", "metadata": {"aucs": [0.9398925604312786, 0.932836996798263, 0.9194419306344862, 0.9161854208418724, 0.9068760220223838, 0.9245975010332618, 0.933862515005673, 0.9408248436356302, 0.9277310904148822, 0.42302163199174014, 0.8278233458108598, 0.858185195783937, 0.1943485909063528, 0.8395490436797061, 0.5198880513447066, 0.41089086286034926, 0.19753766129110073, 0.2717461440519563, 0.09654957328939595, 0.12371320754022419, 0.18744607788327516, 0.17851764499312106, 0.11213523550688786, 0.15761501774011155, 0.1612431072952062, 0.16667765708489335, 0.12517076779710423, 0.08999620821829069, 0.13548633855936498, 0.14626826543597815, 0.0827708565613191, 0.1183042235840367, 0.14121777936134516, 0.161518610567432, 0.1120655115833159, 0.07009257363463584, 0.2793281883417079, 0.5282956733090292, 0.9331640931519797, 0.8544543837400662, 0.8665015146626014, 0.30381893503777513, 0.9023909736017595, 0.9021639031608966, 0.28105493219143396, 0.2856363384694882, 0.09297814488258116, 0.3600998224329198, 0.17902107888831065, 0.27799788892553, 0.30248521129223627, 0.2452138985537754, 0.09188426226096236, 0.2197131797457359, 0.9289165182934496, 0.22910746469463839, 0.22924032076798562, 0.2789329635509269, 0.9319473239257337, 0.2802711906340203, 0.15308139676910892, 0.1789747963249151, 0.9066394120074007, 0.15869674316806381, 0.1678120357326166, 0.16573182554833077, 0.14526532122345182, 0.17011341191896523, 0.2441449230989845, 0.16072422109620388, 0.1747228652128877, 0.1945766301647215, 0.14758441298838132, 0.7184693835613449, 0.1524443937946588, 0.1681206469941684, 0.15261416002183137, 0.18849322211619135, 0.19769759777335838, 0.13946877190199425, 0.18532559698147977, 0.04335452646833782, 0.16858333950477788, 0.02324397047093041, 0.05442627628836194, 0.1209724259320275, 0.049230637371374564, 0.09092291523926366, 0.1957857457475054, 0.05863026575548169, 0.18091964976545938, 0.23779914334511343, 0.1448631279341145, 0.11017619108867494, 0.0961082014897775, 0.14119179730985743, 0.18827844893355727, 0.13455740108454828, 0.17895904108135108, 0.14561581815578628, 0.19839494207481578, 0.16748753312110076, 0.08064271859592553, 0.15636403110763553, 0.25286197978545344, 0.20822060433532608, 0.39730934420652997, 0.41180763755741645, 0.09623435077836329, 0.09959292870964731, 0.0658896282058864, 0.0630746707680766, 0.15557179271997434, 0.09136096738715227, 0.12266005294713433, 0.12504819032606884, 0.08943864259193901, 0.6963637762898109, 0.6659043504110234, 0.5659746984077993, 0.44547892841365533, 0.5809102693999675, 0.6287487088308694, 0.5628326281384635, 0.6878729349023479, 0.6364554638612427, 0.0962624065582891, 0.0882567240001354, 0.09785430788546912, 0.18002946103527406, 0.11401266938546162, 0.06296384281728096, 0.17404480623597374, 0.11654365797701272, 0.07994857321195015, 0.41588834174236, 0.5400291405895398, 0.30103523072271365, 0.2184577295219028, 0.2735441171355927, 0.19957865804406116, 0.2330627314176571, 0.439128914195848, 0.2118137686776319, 0.2687092293217924, 0.3132521904730857, 0.23276611220891064, 0.33099731851228664, 0.5163969906016643, 0.3623727156367026, 0.5119814357697854, 0.25940147553031434, 0.23171395300083242, 0.21127193190306082, 0.25789755875877485, 0.13561598959696441, 0.38691516011773175, 0.2116365426468062, 0.33080075308845236, 0.4264573918205722, 0.22747362095124357, 0.22238671440793412, 0.24209882223679047, 0.22231884593804874, 0.21336130891672678, 0.23473853289810998, 0.23535912300099637, 0.22475067958134765, 0.28133136795456115, 0.22555954874990325, 0.25426830124190203, 0.19872379227101433, 0.20968145453945808, 0.23029671172424593, 0.1774609943526504, 0.1938675010495956, 0.18046322418965233, 0.18986785130822614, 0.20371676016992002, 0.18932474812900357, 0.1894676238857238, 0.21198215002178022, 0.18945578669679486, 0.8849250489355536, 0.15343600655951017, 0.17049062681434513, 0.8988381663466434, 0.9393783200040353, 0.10830416899331397, 0.07334927071068409, 0.2118295431436521, 0.9177664743696639, 0.17004789904920303, 0.20961135522295193, 0.1547607270099679, 0.16724226872481884, 0.5295973997892562, 0.38951834062186796, 0.20433156367992156, 0.18998449010619545, 0.1767086377884921, 0.18196695977700417, 0.19671563747955723, 0.17565862883937466, 0.17477140046531636, 0.18517657070166038, 0.18284232290013247, 0.1264758665296517, 0.08806433996514551, 0.07679448132421751, 0.09631226359296907, 0.08330446354544307, 0.12495512326232017, 0.09036787617456898, 0.10387479546013079, 0.13237292247837262]}, "mutation_prompt": null}
{"id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # increased for better local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.80  # reduced chaos for targeted exploration\n        self.learning_rate = 0.25  # slightly increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Differential Evolution employing adaptive chaotic dynamics and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 68, "fitness": 0.4250311458521746, "feedback": "The algorithm EnhancedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "922c6330-8932-42d1-bfbe-50a727a3489f", "metadata": {"aucs": [0.885844366377097, 0.893251115361245, 0.8972060527931089, 0.8862370199260586, 0.8899419696945833, 0.8934101434556114, 0.8891145784596233, 0.893176790920527, 0.8921383437428866, 0.7908884503839353, 0.7925323609943822, 0.7962266922048908, 0.7951374193298719, 0.7962349675540825, 0.789856671595779, 0.7808642210803884, 0.7877038539946122, 0.8009982438061487, 0.4597728765798491, 0.5331695623601422, 0.5875319129040228, 0.4848548150586437, 0.5424181334312224, 0.4255874196403091, 0.5506317248851875, 0.7116049478150337, 0.5600379724953473, 0.14637068062597958, 0.15573177312839703, 0.16321817474292766, 0.16656653046823688, 0.3853248116708011, 0.14633817807756078, 0.16654924631785817, 0.17464541822574642, 0.16541403428126655, 0.9500784453078285, 0.9499276581862532, 0.9684775822293129, 0.9639053018380488, 0.967026283764279, 0.9533851671658863, 0.9776255238394091, 0.9594944567994208, 0.9625797850332346, 0.6405323297325259, 0.6497171331449128, 0.5913842360276641, 0.6762305923690572, 0.6205108749756838, 0.6702563772856432, 0.6145417995022534, 0.6073219713448389, 0.5807073210331255, 0.8514907718920923, 0.7625937107960864, 0.723328799049247, 0.8510691179437444, 0.8791485592494955, 0.8392226998402389, 0.8084071310267568, 0.8244996963239231, 0.8194320344697703, 0.2270228462178826, 0.28601277756514043, 0.2490035918195287, 0.12857792691360215, 0.2697942620172489, 0.13176226905753607, 0.27006954429315566, 0.3832656997488101, 0.3925741818422782, 0.12953304196664972, 0.35743972203873864, 0.20066407187726332, 0.4205216451674755, 0.35349773133011164, 0.5312074755929256, 0.39881291212500425, 0.41255720879828073, 0.27748971238273534, 0.17645285333180638, 0.18407597088485206, 0.2081887694546498, 0.20276838912890272, 0.09296999984497001, 0.21569293477983442, 0.16592924670162357, 0.10265581890721187, 0.23395052301702768, 0.3344883097366925, 0.2530919598370135, 0.394426313201668, 0.34251616370336946, 0.343600253421284, 0.28588169071527114, 0.3942172778177533, 0.41866014151453845, 0.3884614209975441, 0.1792961297839294, 0.08380978420346619, 0.1730460027878502, 0.10256873259507682, 0.13865432857516113, 0.13913735557198248, 0.10478276361387084, 0.10124714874116503, 0.29294674032697854, 0.27972108249633276, 0.2894468127934403, 0.2611271061186744, 0.2661998376599397, 0.3033484264121542, 0.3287746096258175, 0.18151959516343608, 0.20820483730783723, 0.25815827845634687, 0.7091381967336109, 0.7168419115487028, 0.6850666791346431, 0.6917203118374164, 0.6902809960963283, 0.703736360996029, 0.6933698223503248, 0.6787186836331979, 0.7037531432769898, 0.14336553680418163, 0.10941917240113197, 0.1381003095010136, 0.10947948702736665, 0.12806615339567984, 0.135173259654633, 0.12088008496033342, 0.10223475412013938, 0.117947217212651, 0.13647839153996233, 0.14751427954766572, 0.14499596134519566, 0.15212064948915882, 0.14461554968475643, 0.1725991744279063, 0.1649462045529443, 0.14946349198565, 0.14597905408547796, 0.5527451481415977, 0.5191392764212933, 0.5771001896852226, 0.5342623864196353, 0.29024748037964965, 0.5251749330108798, 0.5863937907041095, 0.6557639899076368, 0.6152725951782103, 0.4027852152945405, 0.25741189109039164, 0.39330990897880147, 0.3639320336641815, 0.363085494062936, 0.41948500181937065, 0.37784921458119347, 0.435209175875808, 0.4203735353352508, 0.23387825900082293, 0.21583628574107971, 0.2127607492534036, 0.22885305726562077, 0.2279926993391146, 0.202513390938181, 0.2080073575753738, 0.21888349688940933, 0.22578625764098081, 0.24200307848000058, 0.21948674372792354, 0.5746223039358687, 0.21522358248368867, 0.6397795673207596, 0.21602914381486982, 0.6328081721412744, 0.24532350829608662, 0.20741000703131307, 0.12937230026493685, 0.17810522871851842, 0.8461801215006456, 0.8730807919545472, 0.8847898787641705, 0.9123696698898918, 0.9036474169017142, 0.17813826062345983, 0.16008260006554087, 0.7555940681544919, 0.6742867667162539, 0.7465706470059349, 0.16870039492001365, 0.7391872311972286, 0.16772810829416918, 0.5125087712587058, 0.21228513762755996, 0.8481047620600783, 0.21146073257105313, 0.17503525866774694, 0.1837602084503296, 0.18143874641246183, 0.18825744906494424, 0.19020498150357057, 0.17602006668789327, 0.18821245288420185, 0.18137902324844823, 0.09374001136730226, 0.0962605568066921, 0.08902373299258237, 0.11259029326255554, 0.08487068041967327, 0.10010515756997374, 0.10209344127234166, 0.08409657615135346, 0.09545115551122019]}, "mutation_prompt": null}
{"id": "1524ff89-cda2-4aff-844e-96c6ea1b3d66", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # Slightly larger population for diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)  # Wider crossover range\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)\n        self.local_intensification = 0.5  # Increased for stronger local search\n        self.dynamic_scale = 0.4  # Slightly increased for more exploration\n        self.chaos_coefficient = 0.85  # More chaos for initial exploration\n        self.learning_rate = 0.2  # Slightly reduced learning rate for gradual adaptation\n        self.memory = np.zeros(self.dim)  # Memory vector for stochastic learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def stochastic_opposition(self, vector):\n        return np.random.uniform(self.bounds[0], self.bounds[1]) - vector\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                # Stochastic opposition-based adjustment\n                if np.random.rand() < 0.2:\n                    mutant = self.stochastic_opposition(mutant)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # update memory with balanced weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution exploiting stochastic opposition-based learning and dynamic chaotic intensity for enhanced global optimization.", "configspace": "", "generation": 69, "fitness": 0.3600954713459561, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.8368000202114809, 0.8406923831212685, 0.8326514149210713, 0.8406428372644006, 0.8315746196710376, 0.8372131625159107, 0.8315448742302931, 0.8373573252586269, 0.8421876663341176, 0.6746569975732943, 0.6904063987444264, 0.6723185262034235, 0.6788544397150538, 0.708507116392225, 0.7034513914352268, 0.693889408448813, 0.6857182483127198, 0.6903187274105917, 0.3578716026780827, 0.24480770652122497, 0.3766688915524643, 0.37738199639723435, 0.2876531740791908, 0.29361546842654174, 0.28688597128771876, 0.3072211473728286, 0.25767224240703146, 0.26137733262759255, 0.17960841517213866, 0.15610522976311003, 0.15151224557156961, 0.1563754102163888, 0.1416410633900479, 0.20071011120466276, 0.14100505421850207, 0.13823885977547978, 0.9327108572347023, 0.9570170975613448, 0.9695550015496363, 0.9640685640690124, 0.9593128972827152, 0.9244898430056401, 0.9617560997451823, 0.9572812857510026, 0.9661263926391841, 0.4472367070065575, 0.44488273421499525, 0.427723212410826, 0.47571982633053944, 0.47603956736908637, 0.4741453285393078, 0.42098923326114013, 0.4353624244097064, 0.4510686851198421, 0.6794129694517376, 0.763195354140653, 0.6958726478759365, 0.7786180533732201, 0.7081319654219069, 0.7247842432267391, 0.7028049769483277, 0.7790114621360749, 0.7785253883494361, 0.3225105529597382, 0.257665312309165, 0.18586714842063723, 0.2555107534700075, 0.2788107425250349, 0.16388707794657098, 0.23252130192261566, 0.23249326230550882, 0.2025488277737677, 0.18810573822329002, 0.22747521334377807, 0.27335871089744224, 0.12907075864427298, 0.26734045304163423, 0.23744313538984674, 0.23681158691750226, 0.21030366989707094, 0.2949877140833891, 0.04727471984189746, 0.13160009239948267, 0.040750317683855286, 0.03788838783938786, 0.049073402306027525, 0.11696977728927471, 0.12585674772668498, 0.11203705807822972, 0.10163796770405475, 0.2306743777380863, 0.2878579694891026, 0.23656977511326438, 0.20174406491970165, 0.223462954558184, 0.2683606094905895, 0.26642272435224534, 0.3175441890112066, 0.3068759341336792, 0.046329437797217765, 0.171733782758427, 0.10998920806726309, 0.07076389537146643, 0.08540284046927427, 0.16676298354012942, 0.08435581469786524, 0.11723423075567807, 0.14513342277883368, 0.20960555954865345, 0.20603981066103327, 0.21154284172588345, 0.23841647222893292, 0.21454023697444913, 0.22529502841016735, 0.20778376576115265, 0.19512849027652024, 0.2231020771690484, 0.6132038814467484, 0.6413388155176498, 0.6068165800497491, 0.6056606918655358, 0.611063028160747, 0.5853452866196418, 0.6178595853282418, 0.640279902966475, 0.6212809302180499, 0.11430961649345339, 0.12737428546540086, 0.10906451171373244, 0.11526211847725187, 0.12611395902108413, 0.09876870180099973, 0.11833780012032225, 0.12503389530138065, 0.11258147362986004, 0.13033122934565688, 0.17860014722401507, 0.1472915183968455, 0.1552463395772371, 0.176356067272879, 0.14533617715580893, 0.15198909847068065, 0.14871741112747006, 0.16429218737061024, 0.405974641281308, 0.4221913249754702, 0.389529841208473, 0.45350936241601547, 0.4385583636840652, 0.44912756624105965, 0.4353383605004655, 0.49452131482943595, 0.4821519230309522, 0.22191880551418686, 0.3138130122160945, 0.31381908908174516, 0.319428083889046, 0.2841955291954722, 0.32338821015931496, 0.29710485268826103, 0.3584382501478032, 0.36986563160569585, 0.2005792182828392, 0.2010744056163276, 0.21479832177319913, 0.2047110289208759, 0.19703659759884773, 0.22726329080926544, 0.21636213669256665, 0.2162363787147451, 0.18686701360413394, 0.22365141868992977, 0.22018334903787595, 0.2285247442226922, 0.3242030705587774, 0.406558327798864, 0.21663772072097376, 0.22127526410461096, 0.21100606949532374, 0.22987491630445434, 0.18640163142340682, 0.7298290757795016, 0.7718949552869209, 0.5659103604624957, 0.1950420315316601, 0.7234436370019643, 0.15963744228557986, 0.7210518535367295, 0.7372923521874106, 0.20226405435447925, 0.6295490051953981, 0.6655006020291795, 0.6301915602532455, 0.2043341640907862, 0.16547447573640917, 0.1628975958156036, 0.6985390300467684, 0.6940150054812161, 0.18586276395489265, 0.19641981236099681, 0.19747648868939516, 0.2102455869537132, 0.19005223763853696, 0.16663448870013453, 0.18718284735215163, 0.1908309214566679, 0.1803323048168951, 0.08314897087660211, 0.09242197210995018, 0.0883915292736448, 0.08983454441023042, 0.08499461198223146, 0.08087250991425621, 0.098200032004085, 0.08776931686399425, 0.08965613553221952]}, "mutation_prompt": null}
{"id": "7704af52-1881-4428-8cdf-34a9a6fb63d3", "solution": "import numpy as np\n\nclass AdaptiveStochasticPerturbationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.50  # increased for intensified local search\n        self.dynamic_scale = 0.40  # adjusted dynamic scale for flexible exploration\n        self.chaos_coefficient = 0.85  # tuned chaos for effective exploration\n        self.learning_rate = 0.30  # enhanced learning rate for rapid adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for enhanced temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Perturbation with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # update memory with balanced weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveStochasticPerturbationDE", "description": "Adaptive Differential Evolution leveraging stochastic perturbations and enhanced memory strategies for efficient global optimization.", "configspace": "", "generation": 70, "fitness": 0.4103910368456737, "feedback": "The algorithm AdaptiveStochasticPerturbationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.8791991091564744, 0.885932144874607, 0.8794714909087172, 0.878508950186093, 0.8792679071699239, 0.8773159528550768, 0.8844313329449887, 0.8773243649365369, 0.8887248765118592, 0.7845672362478405, 0.7787899579059032, 0.7862457928247677, 0.7786642052650168, 0.7795362041286441, 0.7686360040374742, 0.756449550753922, 0.7796649142648948, 0.7722126273725773, 0.5732958812893953, 0.48386368137322866, 0.40827600288818944, 0.5337384656026685, 0.5929622441739297, 0.48198697652340805, 0.42128027070194896, 0.4693437306101783, 0.461579761197781, 0.36509156425227185, 0.16523486410181198, 0.1599122773338042, 0.3128321982779505, 0.22830907292391234, 0.37611567529294765, 0.36843988780332926, 0.33446819988142473, 0.23276666471406704, 0.9503640400606195, 0.9618662891357175, 0.9565183818084215, 0.9677653176424177, 0.9534777143823567, 0.966392107501526, 0.9811937110742708, 0.9517232138756057, 0.9702354926253022, 0.6287894553099286, 0.6193601126377315, 0.6443506084775166, 0.6243941366890429, 0.6167040195954981, 0.6276797162317664, 0.5830377030104651, 0.5853560619301943, 0.5641810769861295, 0.8227855754583429, 0.8374344823112109, 0.7748112866926637, 0.8402518915689257, 0.836900849795198, 0.8500852007754508, 0.6380534084064258, 0.7798323768593232, 0.7919568859495194, 0.12276349539168241, 0.3311082116010776, 0.599164739795609, 0.21069493632346004, 0.4059161536544832, 0.2796871905800734, 0.22693407380170494, 0.20044711965430773, 0.18092603116432227, 0.229126058651551, 0.288919766490191, 0.12962719562265668, 0.24707403654649274, 0.33691609379134535, 0.3344436950063929, 0.23583590934276533, 0.13200004272037935, 0.26915555648434353, 0.17292043449963834, 0.2115726969553784, 0.1705629482325025, 0.03195989725390824, 0.2197166184187186, 0.17160883505390867, 0.13164627450353894, 0.16828611581435382, 0.16640010033534258, 0.3054894349324463, 0.24272442632467528, 0.2668980278251105, 0.2809317402743673, 0.32149718932815563, 0.2842490561125546, 0.36291120763597295, 0.33767581656488077, 0.36203381943082236, 0.08240473503527468, 0.07587493641231069, 0.1112729090773249, 0.09954814062488171, 0.1874862634082538, 0.1402497608739368, 0.07189968147009218, 0.13055522026115884, 0.20448135566101544, 0.2378158884699353, 0.2279965940939458, 0.2589121184123686, 0.3023113988077747, 0.2826580498313581, 0.288500243359995, 0.2247010564230577, 0.2954336731311087, 0.21773801297413098, 0.6817664020345507, 0.6765166772606344, 0.6828948502445767, 0.6533449050404394, 0.6445358414809186, 0.6735271366672102, 0.6638208843768068, 0.7047688020990704, 0.6588259580153414, 0.10428961930171698, 0.11051817295339861, 0.11458306228915371, 0.11036634810539914, 0.1594592807892623, 0.12555339132319676, 0.10540488432516282, 0.13214391138183434, 0.12811398336839952, 0.16446614860853803, 0.16338222547654457, 0.18331624778358557, 0.1603007316725492, 0.12196206377432406, 0.14814126760845614, 0.140712079792352, 0.1783539834682315, 0.13912562699679787, 0.5108937173236736, 0.4198990516040635, 0.463198696414047, 0.539363854487346, 0.5083925044233293, 0.5147318116156536, 0.5454924347363865, 0.6141713435784113, 0.5842566816155781, 0.3199517460190564, 0.369955652369372, 0.35149060524644193, 0.34651376756433916, 0.33135656653794965, 0.24790395988946623, 0.3757837232456003, 0.21813655797831755, 0.3602082749594532, 0.22205539607335134, 0.20708517956489625, 0.22668220045158527, 0.20895722769206104, 0.20515599439496268, 0.21336095638117758, 0.22237505830834647, 0.20290184469304395, 0.19884200393505613, 0.23819542327915832, 0.5169830598154255, 0.23523842760044822, 0.39388245625733354, 0.49966759270856187, 0.3135861985107663, 0.41877360564044797, 0.24415696410005217, 0.6860468049703538, 0.1849863739744746, 0.1856102634834037, 0.1868960550182065, 0.8478684259990827, 0.8423675244646771, 0.8702400106286339, 0.1754790778231201, 0.17524817198848197, 0.8357113188190907, 0.7824058236485941, 0.821436870972415, 0.7159361299644647, 0.1660995726324962, 0.20694765992101416, 0.1632100639584544, 0.7659227295717727, 0.4877808522847449, 0.51538375485137, 0.19821350490601208, 0.18264940624275405, 0.18346882637347495, 0.17873628787727214, 0.1841771839997116, 0.1991272537236065, 0.1744910948876972, 0.20230955788366967, 0.1874580289029304, 0.08487370779801673, 0.09463535340215878, 0.08362723393994986, 0.0801353710930014, 0.08692845801220572, 0.08776127624160113, 0.08779587157385371, 0.09645235724706358, 0.09664453180590082]}, "mutation_prompt": null}
{"id": "67a40515-45f0-488e-bcd4-9ba2744b3825", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # increased for better local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.80  # reduced chaos for targeted exploration\n        self.learning_rate = 0.25  # slightly increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Differential Evolution employing adaptive chaotic dynamics and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.885844366377097, 0.893251115361245, 0.8972060527931089, 0.8862370199260586, 0.8899419696945833, 0.8934101434556114, 0.8891145784596233, 0.893176790920527, 0.8921383437428866, 0.7908884503839353, 0.7925323609943822, 0.7962266922048908, 0.7951374193298719, 0.7962349675540825, 0.789856671595779, 0.7808642210803884, 0.7877038539946122, 0.8009982438061487, 0.4597728765798491, 0.5331695623601422, 0.5875319129040228, 0.4848548150586437, 0.5424181334312224, 0.4255874196403091, 0.5506317248851875, 0.7116049478150337, 0.5600379724953473, 0.14637068062597958, 0.15573177312839703, 0.16321817474292766, 0.16656653046823688, 0.3853248116708011, 0.14633817807756078, 0.16654924631785817, 0.17464541822574642, 0.16541403428126655, 0.9500784453078285, 0.9499276581862532, 0.9684775822293129, 0.9639053018380488, 0.967026283764279, 0.9533851671658863, 0.9776255238394091, 0.9594944567994208, 0.9625797850332346, 0.6405323297325259, 0.6497171331449128, 0.5913842360276641, 0.6762305923690572, 0.6205108749756838, 0.6702563772856432, 0.6145417995022534, 0.6073219713448389, 0.5807073210331255, 0.8514907718920923, 0.7625937107960864, 0.723328799049247, 0.8510691179437444, 0.8791485592494955, 0.8392226998402389, 0.8084071310267568, 0.8244996963239231, 0.8194320344697703, 0.2270228462178826, 0.28601277756514043, 0.2490035918195287, 0.12857792691360215, 0.2697942620172489, 0.13176226905753607, 0.27006954429315566, 0.3832656997488101, 0.3925741818422782, 0.12953304196664972, 0.35743972203873864, 0.20066407187726332, 0.4205216451674755, 0.35349773133011164, 0.5312074755929256, 0.39881291212500425, 0.41255720879828073, 0.27748971238273534, 0.17645285333180638, 0.18407597088485206, 0.2081887694546498, 0.20276838912890272, 0.09296999984497001, 0.21569293477983442, 0.16592924670162357, 0.10265581890721187, 0.23395052301702768, 0.3344883097366925, 0.2530919598370135, 0.394426313201668, 0.34251616370336946, 0.343600253421284, 0.28588169071527114, 0.3942172778177533, 0.41866014151453845, 0.3884614209975441, 0.1792961297839294, 0.08380978420346619, 0.1730460027878502, 0.10256873259507682, 0.13865432857516113, 0.13913735557198248, 0.10478276361387084, 0.10124714874116503, 0.29294674032697854, 0.27972108249633276, 0.2894468127934403, 0.2611271061186744, 0.2661998376599397, 0.3033484264121542, 0.3287746096258175, 0.18151959516343608, 0.20820483730783723, 0.25815827845634687, 0.7091381967336109, 0.7168419115487028, 0.6850666791346431, 0.6917203118374164, 0.6902809960963283, 0.703736360996029, 0.6933698223503248, 0.6787186836331979, 0.7037531432769898, 0.14336553680418163, 0.10941917240113197, 0.1381003095010136, 0.10947948702736665, 0.12806615339567984, 0.135173259654633, 0.12088008496033342, 0.10223475412013938, 0.117947217212651, 0.13647839153996233, 0.14751427954766572, 0.14499596134519566, 0.15212064948915882, 0.14461554968475643, 0.1725991744279063, 0.1649462045529443, 0.14946349198565, 0.14597905408547796, 0.5527451481415977, 0.5191392764212933, 0.5771001896852226, 0.5342623864196353, 0.29024748037964965, 0.5251749330108798, 0.5863937907041095, 0.6557639899076368, 0.6152725951782103, 0.4027852152945405, 0.25741189109039164, 0.39330990897880147, 0.3639320336641815, 0.363085494062936, 0.41948500181937065, 0.37784921458119347, 0.435209175875808, 0.4203735353352508, 0.23387825900082293, 0.21583628574107971, 0.2127607492534036, 0.22885305726562077, 0.2279926993391146, 0.202513390938181, 0.2080073575753738, 0.21888349688940933, 0.22578625764098081, 0.24200307848000058, 0.21948674372792354, 0.5746223039358687, 0.21522358248368867, 0.6397795673207596, 0.21602914381486982, 0.6328081721412744, 0.24532350829608662, 0.20741000703131307, 0.12937230026493685, 0.17810522871851842, 0.8461801215006456, 0.8730807919545472, 0.8847898787641705, 0.9123696698898918, 0.9036474169017142, 0.17813826062345983, 0.16008260006554087, 0.7555940681544919, 0.6742867667162539, 0.7465706470059349, 0.16870039492001365, 0.7391872311972286, 0.16772810829416918, 0.5125087712587058, 0.21228513762755996, 0.8481047620600783, 0.21146073257105313, 0.17503525866774694, 0.1837602084503296, 0.18143874641246183, 0.18825744906494424, 0.19020498150357057, 0.17602006668789327, 0.18821245288420185, 0.18137902324844823, 0.09374001136730226, 0.0962605568066921, 0.08902373299258237, 0.11259029326255554, 0.08487068041967327, 0.10010515756997374, 0.10209344127234166, 0.08409657615135346, 0.09545115551122019]}, "mutation_prompt": null}
{"id": "61172444-9e79-489d-b370-acc435f57b73", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # increased for better local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.80  # reduced chaos for targeted exploration\n        self.learning_rate = 0.25  # slightly increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Differential Evolution employing adaptive chaotic dynamics and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.885844366377097, 0.893251115361245, 0.8972060527931089, 0.8862370199260586, 0.8899419696945833, 0.8934101434556114, 0.8891145784596233, 0.893176790920527, 0.8921383437428866, 0.7908884503839353, 0.7925323609943822, 0.7962266922048908, 0.7951374193298719, 0.7962349675540825, 0.789856671595779, 0.7808642210803884, 0.7877038539946122, 0.8009982438061487, 0.4597728765798491, 0.5331695623601422, 0.5875319129040228, 0.4848548150586437, 0.5424181334312224, 0.4255874196403091, 0.5506317248851875, 0.7116049478150337, 0.5600379724953473, 0.14637068062597958, 0.15573177312839703, 0.16321817474292766, 0.16656653046823688, 0.3853248116708011, 0.14633817807756078, 0.16654924631785817, 0.17464541822574642, 0.16541403428126655, 0.9500784453078285, 0.9499276581862532, 0.9684775822293129, 0.9639053018380488, 0.967026283764279, 0.9533851671658863, 0.9776255238394091, 0.9594944567994208, 0.9625797850332346, 0.6405323297325259, 0.6497171331449128, 0.5913842360276641, 0.6762305923690572, 0.6205108749756838, 0.6702563772856432, 0.6145417995022534, 0.6073219713448389, 0.5807073210331255, 0.8514907718920923, 0.7625937107960864, 0.723328799049247, 0.8510691179437444, 0.8791485592494955, 0.8392226998402389, 0.8084071310267568, 0.8244996963239231, 0.8194320344697703, 0.2270228462178826, 0.28601277756514043, 0.2490035918195287, 0.12857792691360215, 0.2697942620172489, 0.13176226905753607, 0.27006954429315566, 0.3832656997488101, 0.3925741818422782, 0.12953304196664972, 0.35743972203873864, 0.20066407187726332, 0.4205216451674755, 0.35349773133011164, 0.5312074755929256, 0.39881291212500425, 0.41255720879828073, 0.27748971238273534, 0.17645285333180638, 0.18407597088485206, 0.2081887694546498, 0.20276838912890272, 0.09296999984497001, 0.21569293477983442, 0.16592924670162357, 0.10265581890721187, 0.23395052301702768, 0.3344883097366925, 0.2530919598370135, 0.394426313201668, 0.34251616370336946, 0.343600253421284, 0.28588169071527114, 0.3942172778177533, 0.41866014151453845, 0.3884614209975441, 0.1792961297839294, 0.08380978420346619, 0.1730460027878502, 0.10256873259507682, 0.13865432857516113, 0.13913735557198248, 0.10478276361387084, 0.10124714874116503, 0.29294674032697854, 0.27972108249633276, 0.2894468127934403, 0.2611271061186744, 0.2661998376599397, 0.3033484264121542, 0.3287746096258175, 0.18151959516343608, 0.20820483730783723, 0.25815827845634687, 0.7091381967336109, 0.7168419115487028, 0.6850666791346431, 0.6917203118374164, 0.6902809960963283, 0.703736360996029, 0.6933698223503248, 0.6787186836331979, 0.7037531432769898, 0.14336553680418163, 0.10941917240113197, 0.1381003095010136, 0.10947948702736665, 0.12806615339567984, 0.135173259654633, 0.12088008496033342, 0.10223475412013938, 0.117947217212651, 0.13647839153996233, 0.14751427954766572, 0.14499596134519566, 0.15212064948915882, 0.14461554968475643, 0.1725991744279063, 0.1649462045529443, 0.14946349198565, 0.14597905408547796, 0.5527451481415977, 0.5191392764212933, 0.5771001896852226, 0.5342623864196353, 0.29024748037964965, 0.5251749330108798, 0.5863937907041095, 0.6557639899076368, 0.6152725951782103, 0.4027852152945405, 0.25741189109039164, 0.39330990897880147, 0.3639320336641815, 0.363085494062936, 0.41948500181937065, 0.37784921458119347, 0.435209175875808, 0.4203735353352508, 0.23387825900082293, 0.21583628574107971, 0.2127607492534036, 0.22885305726562077, 0.2279926993391146, 0.202513390938181, 0.2080073575753738, 0.21888349688940933, 0.22578625764098081, 0.24200307848000058, 0.21948674372792354, 0.5746223039358687, 0.21522358248368867, 0.6397795673207596, 0.21602914381486982, 0.6328081721412744, 0.24532350829608662, 0.20741000703131307, 0.12937230026493685, 0.17810522871851842, 0.8461801215006456, 0.8730807919545472, 0.8847898787641705, 0.9123696698898918, 0.9036474169017142, 0.17813826062345983, 0.16008260006554087, 0.7555940681544919, 0.6742867667162539, 0.7465706470059349, 0.16870039492001365, 0.7391872311972286, 0.16772810829416918, 0.5125087712587058, 0.21228513762755996, 0.8481047620600783, 0.21146073257105313, 0.17503525866774694, 0.1837602084503296, 0.18143874641246183, 0.18825744906494424, 0.19020498150357057, 0.17602006668789327, 0.18821245288420185, 0.18137902324844823, 0.09374001136730226, 0.0962605568066921, 0.08902373299258237, 0.11259029326255554, 0.08487068041967327, 0.10010515756997374, 0.10209344127234166, 0.08409657615135346, 0.09545115551122019]}, "mutation_prompt": null}
{"id": "bec31b93-9acc-40c2-9f4f-64f78480b289", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # increased for better local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.80  # reduced chaos for targeted exploration\n        self.learning_rate = 0.25  # slightly increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Differential Evolution employing adaptive chaotic dynamics and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.885844366377097, 0.893251115361245, 0.8972060527931089, 0.8862370199260586, 0.8899419696945833, 0.8934101434556114, 0.8891145784596233, 0.893176790920527, 0.8921383437428866, 0.7908884503839353, 0.7925323609943822, 0.7962266922048908, 0.7951374193298719, 0.7962349675540825, 0.789856671595779, 0.7808642210803884, 0.7877038539946122, 0.8009982438061487, 0.4597728765798491, 0.5331695623601422, 0.5875319129040228, 0.4848548150586437, 0.5424181334312224, 0.4255874196403091, 0.5506317248851875, 0.7116049478150337, 0.5600379724953473, 0.14637068062597958, 0.15573177312839703, 0.16321817474292766, 0.16656653046823688, 0.3853248116708011, 0.14633817807756078, 0.16654924631785817, 0.17464541822574642, 0.16541403428126655, 0.9500784453078285, 0.9499276581862532, 0.9684775822293129, 0.9639053018380488, 0.967026283764279, 0.9533851671658863, 0.9776255238394091, 0.9594944567994208, 0.9625797850332346, 0.6405323297325259, 0.6497171331449128, 0.5913842360276641, 0.6762305923690572, 0.6205108749756838, 0.6702563772856432, 0.6145417995022534, 0.6073219713448389, 0.5807073210331255, 0.8514907718920923, 0.7625937107960864, 0.723328799049247, 0.8510691179437444, 0.8791485592494955, 0.8392226998402389, 0.8084071310267568, 0.8244996963239231, 0.8194320344697703, 0.2270228462178826, 0.28601277756514043, 0.2490035918195287, 0.12857792691360215, 0.2697942620172489, 0.13176226905753607, 0.27006954429315566, 0.3832656997488101, 0.3925741818422782, 0.12953304196664972, 0.35743972203873864, 0.20066407187726332, 0.4205216451674755, 0.35349773133011164, 0.5312074755929256, 0.39881291212500425, 0.41255720879828073, 0.27748971238273534, 0.17645285333180638, 0.18407597088485206, 0.2081887694546498, 0.20276838912890272, 0.09296999984497001, 0.21569293477983442, 0.16592924670162357, 0.10265581890721187, 0.23395052301702768, 0.3344883097366925, 0.2530919598370135, 0.394426313201668, 0.34251616370336946, 0.343600253421284, 0.28588169071527114, 0.3942172778177533, 0.41866014151453845, 0.3884614209975441, 0.1792961297839294, 0.08380978420346619, 0.1730460027878502, 0.10256873259507682, 0.13865432857516113, 0.13913735557198248, 0.10478276361387084, 0.10124714874116503, 0.29294674032697854, 0.27972108249633276, 0.2894468127934403, 0.2611271061186744, 0.2661998376599397, 0.3033484264121542, 0.3287746096258175, 0.18151959516343608, 0.20820483730783723, 0.25815827845634687, 0.7091381967336109, 0.7168419115487028, 0.6850666791346431, 0.6917203118374164, 0.6902809960963283, 0.703736360996029, 0.6933698223503248, 0.6787186836331979, 0.7037531432769898, 0.14336553680418163, 0.10941917240113197, 0.1381003095010136, 0.10947948702736665, 0.12806615339567984, 0.135173259654633, 0.12088008496033342, 0.10223475412013938, 0.117947217212651, 0.13647839153996233, 0.14751427954766572, 0.14499596134519566, 0.15212064948915882, 0.14461554968475643, 0.1725991744279063, 0.1649462045529443, 0.14946349198565, 0.14597905408547796, 0.5527451481415977, 0.5191392764212933, 0.5771001896852226, 0.5342623864196353, 0.29024748037964965, 0.5251749330108798, 0.5863937907041095, 0.6557639899076368, 0.6152725951782103, 0.4027852152945405, 0.25741189109039164, 0.39330990897880147, 0.3639320336641815, 0.363085494062936, 0.41948500181937065, 0.37784921458119347, 0.435209175875808, 0.4203735353352508, 0.23387825900082293, 0.21583628574107971, 0.2127607492534036, 0.22885305726562077, 0.2279926993391146, 0.202513390938181, 0.2080073575753738, 0.21888349688940933, 0.22578625764098081, 0.24200307848000058, 0.21948674372792354, 0.5746223039358687, 0.21522358248368867, 0.6397795673207596, 0.21602914381486982, 0.6328081721412744, 0.24532350829608662, 0.20741000703131307, 0.12937230026493685, 0.17810522871851842, 0.8461801215006456, 0.8730807919545472, 0.8847898787641705, 0.9123696698898918, 0.9036474169017142, 0.17813826062345983, 0.16008260006554087, 0.7555940681544919, 0.6742867667162539, 0.7465706470059349, 0.16870039492001365, 0.7391872311972286, 0.16772810829416918, 0.5125087712587058, 0.21228513762755996, 0.8481047620600783, 0.21146073257105313, 0.17503525866774694, 0.1837602084503296, 0.18143874641246183, 0.18825744906494424, 0.19020498150357057, 0.17602006668789327, 0.18821245288420185, 0.18137902324844823, 0.09374001136730226, 0.0962605568066921, 0.08902373299258237, 0.11259029326255554, 0.08487068041967327, 0.10010515756997374, 0.10209344127234166, 0.08409657615135346, 0.09545115551122019]}, "mutation_prompt": null}
{"id": "e29f265b-b620-4d1f-b55b-0228b21694c6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # increased for better local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.80  # reduced chaos for targeted exploration\n        self.learning_rate = 0.25  # slightly increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Differential Evolution employing adaptive chaotic dynamics and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.885844366377097, 0.893251115361245, 0.8972060527931089, 0.8862370199260586, 0.8899419696945833, 0.8934101434556114, 0.8891145784596233, 0.893176790920527, 0.8921383437428866, 0.7908884503839353, 0.7925323609943822, 0.7962266922048908, 0.7951374193298719, 0.7962349675540825, 0.789856671595779, 0.7808642210803884, 0.7877038539946122, 0.8009982438061487, 0.4597728765798491, 0.5331695623601422, 0.5875319129040228, 0.4848548150586437, 0.5424181334312224, 0.4255874196403091, 0.5506317248851875, 0.7116049478150337, 0.5600379724953473, 0.14637068062597958, 0.15573177312839703, 0.16321817474292766, 0.16656653046823688, 0.3853248116708011, 0.14633817807756078, 0.16654924631785817, 0.17464541822574642, 0.16541403428126655, 0.9500784453078285, 0.9499276581862532, 0.9684775822293129, 0.9639053018380488, 0.967026283764279, 0.9533851671658863, 0.9776255238394091, 0.9594944567994208, 0.9625797850332346, 0.6405323297325259, 0.6497171331449128, 0.5913842360276641, 0.6762305923690572, 0.6205108749756838, 0.6702563772856432, 0.6145417995022534, 0.6073219713448389, 0.5807073210331255, 0.8514907718920923, 0.7625937107960864, 0.723328799049247, 0.8510691179437444, 0.8791485592494955, 0.8392226998402389, 0.8084071310267568, 0.8244996963239231, 0.8194320344697703, 0.2270228462178826, 0.28601277756514043, 0.2490035918195287, 0.12857792691360215, 0.2697942620172489, 0.13176226905753607, 0.27006954429315566, 0.3832656997488101, 0.3925741818422782, 0.12953304196664972, 0.35743972203873864, 0.20066407187726332, 0.4205216451674755, 0.35349773133011164, 0.5312074755929256, 0.39881291212500425, 0.41255720879828073, 0.27748971238273534, 0.17645285333180638, 0.18407597088485206, 0.2081887694546498, 0.20276838912890272, 0.09296999984497001, 0.21569293477983442, 0.16592924670162357, 0.10265581890721187, 0.23395052301702768, 0.3344883097366925, 0.2530919598370135, 0.394426313201668, 0.34251616370336946, 0.343600253421284, 0.28588169071527114, 0.3942172778177533, 0.41866014151453845, 0.3884614209975441, 0.1792961297839294, 0.08380978420346619, 0.1730460027878502, 0.10256873259507682, 0.13865432857516113, 0.13913735557198248, 0.10478276361387084, 0.10124714874116503, 0.29294674032697854, 0.27972108249633276, 0.2894468127934403, 0.2611271061186744, 0.2661998376599397, 0.3033484264121542, 0.3287746096258175, 0.18151959516343608, 0.20820483730783723, 0.25815827845634687, 0.7091381967336109, 0.7168419115487028, 0.6850666791346431, 0.6917203118374164, 0.6902809960963283, 0.703736360996029, 0.6933698223503248, 0.6787186836331979, 0.7037531432769898, 0.14336553680418163, 0.10941917240113197, 0.1381003095010136, 0.10947948702736665, 0.12806615339567984, 0.135173259654633, 0.12088008496033342, 0.10223475412013938, 0.117947217212651, 0.13647839153996233, 0.14751427954766572, 0.14499596134519566, 0.15212064948915882, 0.14461554968475643, 0.1725991744279063, 0.1649462045529443, 0.14946349198565, 0.14597905408547796, 0.5527451481415977, 0.5191392764212933, 0.5771001896852226, 0.5342623864196353, 0.29024748037964965, 0.5251749330108798, 0.5863937907041095, 0.6557639899076368, 0.6152725951782103, 0.4027852152945405, 0.25741189109039164, 0.39330990897880147, 0.3639320336641815, 0.363085494062936, 0.41948500181937065, 0.37784921458119347, 0.435209175875808, 0.4203735353352508, 0.23387825900082293, 0.21583628574107971, 0.2127607492534036, 0.22885305726562077, 0.2279926993391146, 0.202513390938181, 0.2080073575753738, 0.21888349688940933, 0.22578625764098081, 0.24200307848000058, 0.21948674372792354, 0.5746223039358687, 0.21522358248368867, 0.6397795673207596, 0.21602914381486982, 0.6328081721412744, 0.24532350829608662, 0.20741000703131307, 0.12937230026493685, 0.17810522871851842, 0.8461801215006456, 0.8730807919545472, 0.8847898787641705, 0.9123696698898918, 0.9036474169017142, 0.17813826062345983, 0.16008260006554087, 0.7555940681544919, 0.6742867667162539, 0.7465706470059349, 0.16870039492001365, 0.7391872311972286, 0.16772810829416918, 0.5125087712587058, 0.21228513762755996, 0.8481047620600783, 0.21146073257105313, 0.17503525866774694, 0.1837602084503296, 0.18143874641246183, 0.18825744906494424, 0.19020498150357057, 0.17602006668789327, 0.18821245288420185, 0.18137902324844823, 0.09374001136730226, 0.0962605568066921, 0.08902373299258237, 0.11259029326255554, 0.08487068041967327, 0.10010515756997374, 0.10209344127234166, 0.08409657615135346, 0.09545115551122019]}, "mutation_prompt": null}
{"id": "812a271a-e004-4aa9-9b88-99603eb1e9aa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45  # increased for better local search\n        self.dynamic_scale = 0.35  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.80  # reduced chaos for targeted exploration\n        self.learning_rate = 0.25  # slightly increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Differential Evolution employing adaptive chaotic dynamics and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 69, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.885844366377097, 0.893251115361245, 0.8972060527931089, 0.8862370199260586, 0.8899419696945833, 0.8934101434556114, 0.8891145784596233, 0.893176790920527, 0.8921383437428866, 0.7908884503839353, 0.7925323609943822, 0.7962266922048908, 0.7951374193298719, 0.7962349675540825, 0.789856671595779, 0.7808642210803884, 0.7877038539946122, 0.8009982438061487, 0.4597728765798491, 0.5331695623601422, 0.5875319129040228, 0.4848548150586437, 0.5424181334312224, 0.4255874196403091, 0.5506317248851875, 0.7116049478150337, 0.5600379724953473, 0.14637068062597958, 0.15573177312839703, 0.16321817474292766, 0.16656653046823688, 0.3853248116708011, 0.14633817807756078, 0.16654924631785817, 0.17464541822574642, 0.16541403428126655, 0.9500784453078285, 0.9499276581862532, 0.9684775822293129, 0.9639053018380488, 0.967026283764279, 0.9533851671658863, 0.9776255238394091, 0.9594944567994208, 0.9625797850332346, 0.6405323297325259, 0.6497171331449128, 0.5913842360276641, 0.6762305923690572, 0.6205108749756838, 0.6702563772856432, 0.6145417995022534, 0.6073219713448389, 0.5807073210331255, 0.8514907718920923, 0.7625937107960864, 0.723328799049247, 0.8510691179437444, 0.8791485592494955, 0.8392226998402389, 0.8084071310267568, 0.8244996963239231, 0.8194320344697703, 0.2270228462178826, 0.28601277756514043, 0.2490035918195287, 0.12857792691360215, 0.2697942620172489, 0.13176226905753607, 0.27006954429315566, 0.3832656997488101, 0.3925741818422782, 0.12953304196664972, 0.35743972203873864, 0.20066407187726332, 0.4205216451674755, 0.35349773133011164, 0.5312074755929256, 0.39881291212500425, 0.41255720879828073, 0.27748971238273534, 0.17645285333180638, 0.18407597088485206, 0.2081887694546498, 0.20276838912890272, 0.09296999984497001, 0.21569293477983442, 0.16592924670162357, 0.10265581890721187, 0.23395052301702768, 0.3344883097366925, 0.2530919598370135, 0.394426313201668, 0.34251616370336946, 0.343600253421284, 0.28588169071527114, 0.3942172778177533, 0.41866014151453845, 0.3884614209975441, 0.1792961297839294, 0.08380978420346619, 0.1730460027878502, 0.10256873259507682, 0.13865432857516113, 0.13913735557198248, 0.10478276361387084, 0.10124714874116503, 0.29294674032697854, 0.27972108249633276, 0.2894468127934403, 0.2611271061186744, 0.2661998376599397, 0.3033484264121542, 0.3287746096258175, 0.18151959516343608, 0.20820483730783723, 0.25815827845634687, 0.7091381967336109, 0.7168419115487028, 0.6850666791346431, 0.6917203118374164, 0.6902809960963283, 0.703736360996029, 0.6933698223503248, 0.6787186836331979, 0.7037531432769898, 0.14336553680418163, 0.10941917240113197, 0.1381003095010136, 0.10947948702736665, 0.12806615339567984, 0.135173259654633, 0.12088008496033342, 0.10223475412013938, 0.117947217212651, 0.13647839153996233, 0.14751427954766572, 0.14499596134519566, 0.15212064948915882, 0.14461554968475643, 0.1725991744279063, 0.1649462045529443, 0.14946349198565, 0.14597905408547796, 0.5527451481415977, 0.5191392764212933, 0.5771001896852226, 0.5342623864196353, 0.29024748037964965, 0.5251749330108798, 0.5863937907041095, 0.6557639899076368, 0.6152725951782103, 0.4027852152945405, 0.25741189109039164, 0.39330990897880147, 0.3639320336641815, 0.363085494062936, 0.41948500181937065, 0.37784921458119347, 0.435209175875808, 0.4203735353352508, 0.23387825900082293, 0.21583628574107971, 0.2127607492534036, 0.22885305726562077, 0.2279926993391146, 0.202513390938181, 0.2080073575753738, 0.21888349688940933, 0.22578625764098081, 0.24200307848000058, 0.21948674372792354, 0.5746223039358687, 0.21522358248368867, 0.6397795673207596, 0.21602914381486982, 0.6328081721412744, 0.24532350829608662, 0.20741000703131307, 0.12937230026493685, 0.17810522871851842, 0.8461801215006456, 0.8730807919545472, 0.8847898787641705, 0.9123696698898918, 0.9036474169017142, 0.17813826062345983, 0.16008260006554087, 0.7555940681544919, 0.6742867667162539, 0.7465706470059349, 0.16870039492001365, 0.7391872311972286, 0.16772810829416918, 0.5125087712587058, 0.21228513762755996, 0.8481047620600783, 0.21146073257105313, 0.17503525866774694, 0.1837602084503296, 0.18143874641246183, 0.18825744906494424, 0.19020498150357057, 0.17602006668789327, 0.18821245288420185, 0.18137902324844823, 0.09374001136730226, 0.0962605568066921, 0.08902373299258237, 0.11259029326255554, 0.08487068041967327, 0.10010515756997374, 0.10209344127234166, 0.08409657615135346, 0.09545115551122019]}, "mutation_prompt": null}
{"id": "341885c0-eb09-47f8-b2ef-b1e38a02ee82", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCovarianceDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.50  # slightly increased for better local search\n        self.dynamic_scale = 0.40  # adjusted dynamic scale for more exploration variability\n        self.chaos_coefficient = 0.85  # slightly increased chaos for targeted exploration\n        self.learning_rate = 0.30  # increased learning rate for faster adaptation\n        self.memory = np.zeros(self.dim)  # memory vector for temporal learning\n        self.covariance_matrix = np.eye(self.dim)  # initialize covariance matrix\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n\n                # Integrate Covariance Matrix Adaptation\n                if np.random.rand() < self.local_intensification:\n                    L = np.linalg.cholesky(self.covariance_matrix)\n                    mutant = mutant + np.dot(L, np.random.randn(self.dim))\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # update memory with more weight on the trial\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                    # Update covariance matrix\n                    self.covariance_matrix = (1 - self.learning_rate) * self.covariance_matrix + self.learning_rate * np.outer(trial - self.population[i], trial - self.population[i])\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveCovarianceDE", "description": "Enhanced Differential Evolution with adaptive chaotic dynamics, integrated covariance matrix adaptation, and memory-driven local intensification for robust global optimization.", "configspace": "", "generation": 76, "fitness": 0.4113676220312308, "feedback": "The algorithm EnhancedAdaptiveCovarianceDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.8998399649907487, 0.8888514194662501, 0.8982936155174858, 0.8968734026780301, 0.900191048538057, 0.895411522152319, 0.8981229107382575, 0.8996967019485602, 0.8983022764058188, 0.787969131951402, 0.7896895200991465, 0.7946837583920717, 0.7898817803719607, 0.7957757046336078, 0.8069890883339883, 0.7845902118634643, 0.8004803689281179, 0.7999684424271963, 0.39899069921678476, 0.16791818137700087, 0.5304431004228306, 0.46278146592313574, 0.4819808202667826, 0.4746846493443604, 0.6369847829199129, 0.4957768932585851, 0.3713850436775671, 0.4367744829974406, 0.15433911846441095, 0.4437069375622146, 0.14572826081173784, 0.17355538745554655, 0.24505563479636994, 0.15867033388549756, 0.16534245260178526, 0.16147563069232473, 0.968458544222919, 0.9901038580883613, 0.9843612946549256, 0.9646609357227965, 0.9834839060583631, 0.9874979124380471, 0.98289817959767, 0.981184806097387, 0.9871601864179137, 0.6146330580329068, 0.6393502105934565, 0.6406224899338866, 0.6382759057204226, 0.6969702749791136, 0.6875109227089015, 0.6172523736308266, 0.526377229122925, 0.5848131539914496, 0.807789274136842, 0.7734531834223297, 0.8676606406833279, 0.842409656682577, 0.8767128322420746, 0.8014840276104926, 0.8447171466200231, 0.8305620035412795, 0.8302630232640258, 0.37220560407279724, 0.467760200162187, 0.12464754347956586, 0.22287213865722366, 0.2878838082541335, 0.3741493808386004, 0.30559567519056874, 0.32773759551504356, 0.2737347157959522, 0.2462076697064015, 0.308631757524074, 0.18641859862770183, 0.3035385124647386, 0.32490651972438733, 0.24260012412056375, 0.3505556852163638, 0.5577275003154138, 0.1295983525779839, 0.0550949192808734, 0.1073537553010947, 0.22143316980117556, 0.20762187060872173, 0.11919758921090073, 0.13109635961889543, 0.1998682200754156, 0.23162369874848587, 0.15311091784959585, 0.3127843935307767, 0.36404686050777313, 0.3550335967188999, 0.27060986950483135, 0.28808521501744233, 0.2962081512999366, 0.3306965240191332, 0.34465006308538326, 0.3040203979194841, 0.1972837649261091, 0.24111366978431448, 0.16821167876309084, 0.13067587804981018, 0.1846021095220528, 0.217554006762137, 0.2544557989436004, 0.11726546719321196, 0.1584835200948772, 0.24896701164582014, 0.2757273746298676, 0.2628663497961363, 0.26677868164097995, 0.2931683509335543, 0.3021877051905044, 0.2704690660346125, 0.22012365640176412, 0.20761293731451713, 0.7012385220209304, 0.6986755628513428, 0.7013984223686762, 0.6843529276483096, 0.662530935069166, 0.7014452961365338, 0.6837659138914247, 0.6980951097827539, 0.6688078085862714, 0.13236387728659105, 0.1336572581648754, 0.11256963208412762, 0.1261775378984441, 0.10933606806087826, 0.12570483485955442, 0.12126448988480165, 0.12032669917154382, 0.1338562208349665, 0.14785434272603237, 0.14018273171711282, 0.15637563885326167, 0.18827528062521126, 0.20356669887426515, 0.16700604043195977, 0.1550632942756629, 0.15153714584493339, 0.15616694809286147, 0.5239351121336278, 0.5861002720405364, 0.5573672954558471, 0.581527732398587, 0.512118218317248, 0.5679814770506708, 0.5883484524131175, 0.6347530050863657, 0.5844200598291891, 0.39785706333514237, 0.4059531220928946, 0.3920214247674275, 0.38467512715901653, 0.2630820158239717, 0.3836129115418845, 0.4361329892215837, 0.22706287178981654, 0.3721077370425896, 0.20304669154731414, 0.23280324985346046, 0.2179269186760744, 0.25778080141313, 0.221158929866636, 0.20249388151480419, 0.23549284846840823, 0.21306893483389244, 0.22558519389119447, 0.7487764441081708, 0.21719499402757825, 0.24025013828884534, 0.21098794335176585, 0.24208962682950252, 0.24412305077772645, 0.6101028983232321, 0.6825234715880958, 0.6287206108576053, 0.1869426541282012, 0.18475662113752256, 0.18658091172221247, 0.7785204925218179, 0.8844482355913516, 0.16654079390011667, 0.16041040754811042, 0.1725215490731392, 0.1706872301309017, 0.8123331935357795, 0.21061602866966145, 0.20073268473879702, 0.20763887005026072, 0.12758466144959257, 0.7506627650585038, 0.15406342913141458, 0.7695269789344557, 0.2119487740971242, 0.18856012454521065, 0.19739299716087044, 0.17957273250049588, 0.18605550866181186, 0.18989270548891468, 0.18368175921081575, 0.17775062604276137, 0.18701035039156277, 0.1765207767579552, 0.10689029606216172, 0.0867978860545463, 0.09137269073304088, 0.09508059793007761, 0.09204879777521169, 0.10016676860404439, 0.08477925241114537, 0.090068553926693, 0.09174314201462219]}, "mutation_prompt": null}
{"id": "c65d168b-75fd-417c-bf45-925e1122955f", "solution": "import numpy as np\n\nclass RefinedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # Adjusted population size for computational efficiency\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 1.0, self.pop_size)  # Broadened CR range for diversity\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for fine-tuning\n        self.local_intensification = 0.40  # Tweak local search probability\n        self.dynamic_scale = 0.3  # Slightly reduced dynamic scale for variability\n        self.chaos_coefficient = 0.85  # Adjusted chaos for exploratory robustness\n        self.learning_rate = 0.3  # Enhanced adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Adjusted memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedAdaptiveChaoticDE", "description": "Adaptive Differential Evolution refined with chaotic dynamics and self-adaptive parameters for enhanced exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.4262277905922702, "feedback": "The algorithm RefinedAdaptiveChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "0ce96f16-9ed2-4b65-80bf-dd2be8a18be0", "metadata": {"aucs": [0.9004499658361295, 0.9037177691532142, 0.9006990825922966, 0.9033003127674661, 0.8965284276505566, 0.90466001675214, 0.8948248688515117, 0.9087206585026257, 0.8960889987758538, 0.8122509918969546, 0.8126212481581423, 0.8206675945575976, 0.8060660382203784, 0.8089373082478967, 0.8089989664055821, 0.8041011397407741, 0.820275121416265, 0.8081896236364685, 0.5954431600144128, 0.5493297990481031, 0.521680346566763, 0.4578565825808636, 0.48719930720861726, 0.6924898863286049, 0.17281353393577625, 0.5647057255973811, 0.6100610791832535, 0.1729636221857518, 0.44510789916599003, 0.17066747494432888, 0.5266832811816364, 0.17506155811401003, 0.17616662651418424, 0.16943451775293883, 0.17127671384140863, 0.17387222276209746, 0.9892547449693467, 0.9903129199453897, 0.9654024160837484, 0.9687531539208224, 0.9730347142427258, 0.9731121268446513, 0.9633950199742793, 0.9713556040644434, 0.991355238200015, 0.7088828307793724, 0.7120422034217166, 0.6711409510307149, 0.731341022998004, 0.7067763291262135, 0.6660204082774479, 0.6523369891133161, 0.649795748386383, 0.6692021539897252, 0.825305848174818, 0.8297298700133007, 0.8196015531359409, 0.2764011284134593, 0.8220937242718556, 0.8518759145719309, 0.8626951827937559, 0.8321895792365868, 0.7671933952051416, 0.37595149091765145, 0.37536862249476655, 0.30952468734270855, 0.33911261191983677, 0.13195603381617182, 0.3757175676181752, 0.39330841943777173, 0.13172229642879973, 0.31472966182367257, 0.2454203297584261, 0.2262454891479453, 0.26986795533023267, 0.23897101785711716, 0.38317939826712266, 0.32224683050455605, 0.13089609448605732, 0.1307858815866172, 0.320467137963546, 0.1650739937100929, 0.09395238178829057, 0.16423744578549448, 0.20281350352388172, 0.289271816469332, 0.1210176453472741, 0.2651999561517099, 0.19482358362628394, 0.18267890583306268, 0.29833501393005535, 0.38235205533015615, 0.23007857465003778, 0.31861304434654525, 0.2769599267595788, 0.3267722961582652, 0.42007228637671346, 0.4476877067051519, 0.3543348142670112, 0.04945268965319771, 0.21976162224154439, 0.16376874741485303, 0.13708916990028752, 0.1288092618564226, 0.13326293216985774, 0.07812951235154264, 0.11465163180680304, 0.2838575577861896, 0.3049743378136567, 0.2890342267654922, 0.2820568370335923, 0.3449763054694699, 0.31012380326742106, 0.35659986477413974, 0.19061912594927488, 0.1949678145632513, 0.2833388349003608, 0.7155099112155829, 0.7003914132403044, 0.7434344672967044, 0.7025652577745227, 0.7155175473656236, 0.7164221275459208, 0.6969258848480964, 0.7435012102191672, 0.7506408991984075, 0.10807199869957917, 0.12816607704701533, 0.1522014083156744, 0.1499959126773447, 0.1016141903555896, 0.1138077448983037, 0.12295254833271174, 0.1308256439576022, 0.13755502124306807, 0.1344977300291894, 0.1831548564455907, 0.17783572180829066, 0.1396053425031547, 0.14337021542882344, 0.16445816266582247, 0.14929576096442176, 0.15671888738242523, 0.15379288766824795, 0.6204008553893325, 0.592341833771969, 0.6588770144668081, 0.5890394426485306, 0.551886667469424, 0.6476238532266456, 0.5915805274568917, 0.6672386389673712, 0.6693518914253151, 0.4279764194080795, 0.4310806558341581, 0.3936485001904334, 0.35406995138812813, 0.35214200393449113, 0.38944379213432645, 0.4064692620677165, 0.4955711481054885, 0.44415728931797815, 0.2186781743881313, 0.21834584803618606, 0.21285456726564567, 0.2239722353624728, 0.2102753596111676, 0.21157876865418535, 0.22193267962887075, 0.20031740508655071, 0.23904188218780742, 0.5989084563283555, 0.5866271086444019, 0.4954207045538047, 0.6612231822786638, 0.238149498661002, 0.5474870936266484, 0.5171185034362311, 0.6980470937802188, 0.5916590599907697, 0.1731623210796488, 0.1868760827638586, 0.18716747418501234, 0.19699297171381136, 0.2038108608895015, 0.8363760808506668, 0.1583547887678669, 0.48816197081042967, 0.8349567147386406, 0.7720001795444041, 0.20995445478005048, 0.2111785407165213, 0.16875214812987305, 0.21013921522318135, 0.6839095601161351, 0.7604714051504204, 0.12706276126874239, 0.2103611948492099, 0.17963041217910813, 0.1870330556954044, 0.17186980086419812, 0.18641833978838762, 0.21346144297680103, 0.17551376165075705, 0.1815035293793399, 0.18645544278923576, 0.18251449806175768, 0.09404870053374847, 0.09383888789684702, 0.10052534938324587, 0.09375755110095418, 0.09384844347742871, 0.12103884411933996, 0.09064178465553396, 0.09626635436426245, 0.09004865113409866]}, "mutation_prompt": null}
{"id": "3c850010-ccb7-4bd3-a9e2-5567b58805c6", "solution": "import numpy as np\n\nclass EnhancedQuantumChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)  # Adjusted CR range for exploration\n        self.F = np.random.uniform(0.2, 0.7, self.pop_size)  # Adjusted F range for exploration\n        self.local_intensification = 0.45  # Adjusted local search probability\n        self.dynamic_scale = 0.25  # Reduced dynamic scale for coherent variability\n        self.chaos_coefficient = 0.9  # Enhanced chaos for exploratory dynamics\n        self.learning_rate = 0.35  # Adjusted adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * np.sin(np.pi * x)\n\n    def quantum_perturbation(self, solution):\n        # Introduce a quantum perturbation for exploiting new regions\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(solution + perturbation, *self.bounds)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * chaos_value\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory and Quantum Perturbation\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                    mutant = self.quantum_perturbation(mutant)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # Memory weight balanced\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedQuantumChaoticDE", "description": "Enhanced Quantum-inspired Chaotic Differential Evolution with adaptive parameters and quantum perturbation for improved exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.24555090849614908, "feedback": "The algorithm EnhancedQuantumChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.6928149446342539, 0.6705982678651891, 0.6969353470433757, 0.7101280420096497, 0.6937222250311899, 0.7159261456703829, 0.7192742383313335, 0.6689192892012934, 0.6968996028382002, 0.38179331415914686, 0.3640181826314902, 0.3943858633563757, 0.37737094098473445, 0.36259042428190114, 0.3975593147388514, 0.3835583052994833, 0.3659201093560732, 0.39506319709491977, 0.1723629569554712, 0.17656062990609478, 0.18176530604146457, 0.17239912309554106, 0.149264867891426, 0.18198254918168433, 0.18398843305906165, 0.13074593057633266, 0.18125183451168858, 0.12140284487929187, 0.1353295749583232, 0.1383245223098979, 0.1342991592905569, 0.11883664164551377, 0.13935366263611781, 0.13417055364016506, 0.131073409406131, 0.1433136667759325, 0.954671186962554, 0.9404986461146145, 0.9433309637742471, 0.9387878380765121, 0.9462729579348971, 0.9030887927918065, 0.959679744176591, 0.9748226291759062, 0.9483210244619643, 0.2811365487794776, 0.2676288093592677, 0.2897233290270993, 0.2948126064954195, 0.27082386527280455, 0.2706412450398762, 0.2885131379108309, 0.26636428882587093, 0.2635071636500613, 0.3616033684904463, 0.24977911336831893, 0.2750359494507352, 0.2911099259622312, 0.29658560351086405, 0.5328956343932512, 0.5038742804790517, 0.36677312490090463, 0.5418155759073138, 0.15494229377631596, 0.1478718275075417, 0.15001070021581275, 0.16040714667555767, 0.15838327572334743, 0.1326925719426192, 0.1486009572123872, 0.15404956416843651, 0.1552013549839406, 0.13461434775387426, 0.10714272088344101, 0.10865300471325767, 0.15065155481076598, 0.1667704900303797, 0.13137284292407148, 0.14822967944224785, 0.11640790456849359, 0.1537369923778329, 0.01840700447243837, 0.001947524569515413, 0.011664655243614264, 0.024112659404308068, 0.0014054569284098761, 9.999999999998899e-05, 0.013009365385557303, 0.0037033237272650066, 0.005279269491833105, 0.1072428932736118, 0.09712446430501664, 0.11674369395380746, 0.04475319764114705, 0.08642229442425264, 0.071056660376706, 0.12255758479444501, 0.06839976425345906, 0.12075967726801895, 9.999999999998899e-05, 0.0029240997462475216, 0.003414039997669871, 0.0013727541750490069, 9.999999999998899e-05, 0.0010943332019541785, 9.999999999998899e-05, 0.0025920062237797525, 0.011333094937797217, 0.09872176522070364, 0.11253289348194573, 0.10780097038800485, 0.1217161687511692, 0.14136799829524094, 0.12940404164389552, 0.11155598583191673, 0.11049605746946922, 0.09741021026607721, 0.45458787542064605, 0.4496447698300776, 0.44942301417036434, 0.4622040344610068, 0.44738495006721146, 0.44884291125214426, 0.4732562436887874, 0.44226894932434646, 0.43834382818375683, 0.09962042216275535, 0.10121374422105178, 0.10028021137490417, 0.09095093705413893, 0.0968511134562523, 0.0973178266507857, 0.10250849335335277, 0.09227142791943066, 0.09125332580713352, 0.13564136339367594, 0.13006617853347213, 0.13495844535324508, 0.1723850643802507, 0.1405628047758819, 0.15613375342872082, 0.14625570623776496, 0.13394581059557842, 0.1365223048222971, 0.2835084006009775, 0.2819232268294629, 0.2965036529767916, 0.3131744870996782, 0.28667236160544707, 0.28800802093604505, 0.3153571487431529, 0.32042953885106285, 0.31649864634422464, 0.21177321812623295, 0.1919040021441557, 0.1879374978965006, 0.20468168803904996, 0.18978069254428032, 0.21050626296716912, 0.22854827667415234, 0.23670730589540467, 0.2346647458953358, 0.18577961930849674, 0.18893621376424763, 0.1911943896548991, 0.176081241397415, 0.19825043580572665, 0.19207916347541, 0.1840276461708893, 0.20818409039688568, 0.19822079568166695, 0.19773723666873988, 0.1973835338704918, 0.20034911517558163, 0.20742935064738932, 0.22273363027493798, 0.20864094812419853, 0.20174861343013506, 0.21412790181513797, 0.19737945327393713, 0.34447585478056164, 0.5450043441326338, 0.4950448080620822, 0.16970043560042236, 0.33114326099345126, 0.21982372664114003, 0.24450354816898612, 0.23320962686780844, 0.2687529028623873, 0.1748832411881882, 0.35530500611971483, 0.1911865748871594, 0.3128121018160266, 0.18521082957564117, 0.18626214539284736, 0.19811914651684992, 0.1956661672922717, 0.20303615236523975, 0.18659218814759504, 0.17883465045408098, 0.19352847988493205, 0.19719766289536234, 0.20503831288539465, 0.1841279321350262, 0.17344949311762825, 0.19132261969623565, 0.1809697535349697, 0.07800508868301692, 0.07575010942862825, 0.09205998201278376, 0.08186028972060644, 0.08072858757353063, 0.07640663789924096, 0.07658307472363524, 0.07357715434918521, 0.08080036730248308]}, "mutation_prompt": null}
{"id": "6ebba8a0-aafa-4ac4-8a6e-4291a411debe", "solution": "import numpy as np\n\nclass HybridChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for enhanced diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)  # Adjusted CR range for better adaptation\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)  # Extended F range to explore scalability\n        self.local_intensification = 0.35  # Adjusted probability for local search balance\n        self.dynamic_scale = 0.25  # Reduced scale to stabilize convergence\n        self.chaos_coefficient = 0.9  # Increased chaos coefficient for more robust exploration\n        self.learning_rate = 0.35  # Adjusted learning rate for dynamic adaptation\n        self.memory = np.zeros(self.dim)  # Memory vector for improved learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and hybrid strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory and Feedback\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridChaoticDE", "description": "Hybrid Differential Evolution with Enhanced Chaotic Exploration and Adaptive Feedback Mechanisms.", "configspace": "", "generation": 79, "fitness": 0.39052904296252705, "feedback": "The algorithm HybridChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.8684282070360673, 0.8529127145343175, 0.8661994927934782, 0.8674792543245471, 0.8535357218738033, 0.8647033433821913, 0.8611384757067118, 0.8590902794906043, 0.8684860831334928, 0.7451521516062702, 0.731391094512396, 0.7462599910970451, 0.7439890058082512, 0.7386635866069595, 0.7439087816464247, 0.7288341818343158, 0.7377772180012665, 0.750806982125783, 0.5465227834255697, 0.35622699312798034, 0.5264316935800277, 0.4072664633678582, 0.46151581779006123, 0.35808337683580793, 0.4100701183641199, 0.41960558237356516, 0.5470769869189223, 0.27071185285039023, 0.15716058754318452, 0.22020457059118814, 0.36083415845718014, 0.3597457688650003, 0.157699837533394, 0.32510306157285973, 0.2800687841744758, 0.14811112702370066, 0.9548974347017849, 0.9495175090405038, 0.9545472477679537, 0.9618514571907866, 0.9344493952149113, 0.9556476471786741, 0.9528597648210814, 0.9549933078555001, 0.9566803002411483, 0.596420720550858, 0.5870099282299142, 0.6034438234854467, 0.6116994127092309, 0.580114415902236, 0.5851239060144551, 0.530021883960899, 0.508072095657648, 0.5512213523790255, 0.7912761047979933, 0.720532827509994, 0.6872345107689521, 0.7931986764516707, 0.20808326894855222, 0.21535452087872053, 0.7609085662538855, 0.7681339044014693, 0.7138170824846432, 0.23568842360595277, 0.43213083399963026, 0.2019541458977544, 0.1860866487480266, 0.22297465589705456, 0.18576605730835027, 0.18838924810372903, 0.1992366025923319, 0.2363012065379092, 0.19115875055280107, 0.20864582695076284, 0.16765313988860975, 0.21969864028343355, 0.1907005464986663, 0.24751737054674983, 0.16080773148928762, 0.22443403863483025, 0.3596642427963028, 0.13711012994755944, 0.13766121813517018, 0.14846467435009725, 0.14774849963681957, 0.10658247685543942, 0.09825356074910818, 0.09925378775384874, 0.13847283936615096, 0.12534374657836356, 0.2947175763120229, 0.265531666831592, 0.27766103200497927, 0.20325652427704088, 0.2865142069551162, 0.2919099275631637, 0.2932149473638339, 0.3035878236795754, 0.29835783564102514, 0.11412301470929465, 0.16900658794831436, 0.08586940149254219, 0.10974303266168117, 0.15382937994231083, 0.12558004296561176, 0.14139861587869296, 0.14058484030014984, 0.14550930278187624, 0.2507770571473199, 0.2351984269246642, 0.2470324783326996, 0.22739012583430762, 0.25575659191141553, 0.2321732252424641, 0.19598587329413342, 0.2090948946119272, 0.2031452248783734, 0.6114701266718459, 0.6538516547046271, 0.6249442887449436, 0.6454662521645513, 0.640894701643766, 0.6471738239165601, 0.6218084291991326, 0.6298740606765851, 0.6538192358425797, 0.1383514715817351, 0.10751389141884249, 0.12212067117854863, 0.11458524572290041, 0.13214048199615214, 0.10543209589125546, 0.10241216781896634, 0.11956049359663723, 0.13993853186700111, 0.14068030338918835, 0.13246595805211914, 0.14166575749034127, 0.13553135041489295, 0.14506899415844143, 0.1318413202229387, 0.18676811374128865, 0.14805040922532464, 0.16692459906481982, 0.49315010503666545, 0.4880480436750313, 0.46036051356159946, 0.440579918181186, 0.4595528165272429, 0.43126827838340864, 0.4851327087542875, 0.5369254843677763, 0.5366711995566547, 0.3193145070912219, 0.30491704040175915, 0.3031962690557489, 0.362271387034948, 0.3017068583566963, 0.31944146850336463, 0.36187249215280637, 0.362638848877358, 0.3599661332036136, 0.2086164482502647, 0.2064455201231904, 0.19171638969353844, 0.20375739250153202, 0.2070280627647212, 0.1957638986867395, 0.20867136284888477, 0.21803189460147054, 0.23396628901547523, 0.49004651440336366, 0.4037958252655539, 0.4254475292914237, 0.20131520025017458, 0.2179194943342373, 0.2204867320059234, 0.5675049366078725, 0.2347475615631851, 0.22240354523893768, 0.1721028649611408, 0.8070477068989468, 0.18200703321739475, 0.834231659154406, 0.7294526465422504, 0.8250126053352206, 0.7662107278596384, 0.5858273018814186, 0.7802696487587625, 0.7458142905281333, 0.3599369368977682, 0.6979616443048372, 0.609149684152817, 0.1632307057883925, 0.5996040570236358, 0.6450588669446498, 0.20877961801527845, 0.7109197838370025, 0.19264699212147307, 0.18603719104501037, 0.18838929586005293, 0.1899608672869123, 0.19942436182960888, 0.17910927353300454, 0.18663516380196865, 0.19145803882433388, 0.18264466010800529, 0.08723991715945267, 0.09006881714921733, 0.08632889201188265, 0.08978491989294035, 0.09593689817692197, 0.10066123735999155, 0.09302629527216633, 0.09864953902402518, 0.08566414028532021]}, "mutation_prompt": null}
{"id": "85ee8fbc-b63d-4289-9546-32693be8d12f", "solution": "import numpy as np\n\nclass SelfOrganizingChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.3, 0.9, self.pop_size)  # Extended F range for diverse trials\n        self.local_intensification = 0.35  # Adjusted local search probability for better exploration\n        self.dynamic_scale = 0.25  # Further reduced dynamic scale for fine variability\n        self.chaos_coefficient = 0.90  # Enhanced chaos for increased exploratory diversity\n        self.learning_rate = 0.35  # Increased adaptation speed for quicker convergence\n        self.memory = np.zeros(self.dim)\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.6 + chaos_value) * mutant + (0.4 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.65 * self.memory + 0.35 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SelfOrganizingChaoticDE", "description": "Self-Organizing Adaptive Differential Evolution using chaotic maps and memory-enhanced dynamics for robust global search and local refinement.", "configspace": "", "generation": 80, "fitness": 0.39914317127303073, "feedback": "The algorithm SelfOrganizingChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.8968540790871047, 0.8925725552130509, 0.8909905191972783, 0.8777060941817033, 0.8750464566636855, 0.8839547672012374, 0.885889183608965, 0.8910254883496468, 0.886791309051985, 0.780674071888617, 0.801957006225363, 0.804125020111143, 0.7858313278866838, 0.8049160568136768, 0.7907749488549354, 0.7763853861570529, 0.799151293983092, 0.7914203751506125, 0.5807657780924245, 0.5204510062423655, 0.5698826454246915, 0.4312699655687322, 0.6485561298492797, 0.4779918175191289, 0.4923502106471308, 0.5872719245496061, 0.4990911808518058, 0.1682921832900871, 0.17390334671800678, 0.5020524754194688, 0.47769972086733625, 0.16151120691687815, 0.1517844741986193, 0.4747759333788658, 0.12325962012296243, 0.15394749945598907, 0.9650908185648072, 0.9900748230526135, 0.9628148369810308, 0.9665900740465033, 0.9750630427649044, 0.9669957140174726, 0.9650565420497627, 0.9701930164564831, 0.9714902590759843, 0.5822354265234695, 0.6810154566808817, 0.6478962238011992, 0.6952356994290203, 0.6326474586141053, 0.6447424705105796, 0.6182063139039481, 0.6194467708508462, 0.6086969126610116, 0.6966333851408808, 0.7486888156941595, 0.7541923379622274, 0.8289158074445266, 0.7799965499695545, 0.8550092661643528, 0.7838309712928414, 0.861483891488537, 0.7983499138596015, 0.4503032555375788, 0.2230990907554492, 0.3069873337913923, 0.22708056404650012, 0.12616823212531558, 0.2706092924659367, 0.18198557323401565, 0.13136521173669335, 0.19875358690421008, 0.2767689772727586, 0.23504299166377596, 0.4473812843820584, 0.2579083445762681, 0.22440607872631135, 0.20644915437973077, 0.21222327724119083, 0.16656651207607343, 0.12932107525361258, 0.15561646964349585, 0.15387157566332899, 0.10731636801737221, 0.14883627966572732, 0.10911330342434089, 0.12365533428158837, 0.2001539898548924, 0.21606295435957334, 0.11417831012797286, 0.2622312160050958, 0.2943478186531142, 0.304266127355066, 0.27661628419127837, 0.30555857841667144, 0.29295987574853344, 0.27617499610543106, 0.3769567677890926, 0.3373478753964392, 0.05899639624151154, 0.14941155890604363, 0.13223297308563686, 0.08115002044328068, 0.10302425869364529, 0.18776989031791402, 0.07462532806150379, 0.1719267921504537, 0.09224099258007679, 0.18937706018149547, 0.20541760175792056, 0.24542330316471317, 0.2863769006242176, 0.3059693823340466, 0.28882166362438266, 0.22733099526733724, 0.2275229707017462, 0.21754256439226882, 0.6796718754026719, 0.6931919525239607, 0.6727831856082949, 0.671977527141431, 0.661921714075378, 0.6714399431778684, 0.6553515481786866, 0.6581274099479084, 0.632028732525036, 0.12191610666582786, 0.1297819878150025, 0.12723076622629903, 0.10899181933385804, 0.11123732979450474, 0.11621813767255351, 0.09898695151818848, 0.11629802437840553, 0.11653833278943915, 0.1735378824783591, 0.14910285920717326, 0.13737483995385102, 0.16120009964472426, 0.1573140098272171, 0.14531295837958003, 0.17507861016923054, 0.1365390428866835, 0.16579409640398457, 0.5276522650137613, 0.528117215417904, 0.5103075407982188, 0.49087763468518875, 0.5321477366308989, 0.574201276534553, 0.5886798013071297, 0.5995132454949008, 0.6036539280635681, 0.35758229513529416, 0.38814685967608076, 0.25568270274719207, 0.3453628668532599, 0.3255434025812892, 0.3564304760580589, 0.2168902739314259, 0.3837320809292897, 0.40117037145651613, 0.20945936145533361, 0.2160580610006234, 0.20548742419462251, 0.19470357630829005, 0.20300731734251753, 0.21898098504204078, 0.22280559583817583, 0.21374885348422035, 0.24143998321288684, 0.20903181871271315, 0.23666783047413853, 0.19268013821195107, 0.2268895711158031, 0.6847334800224198, 0.5930936907427113, 0.3823784468125576, 0.5232484596773803, 0.519632647280973, 0.19548011086508554, 0.18463702338896515, 0.8409005702477109, 0.19815554598215968, 0.728206335172789, 0.8243794884242117, 0.7699581251229242, 0.1782201555612415, 0.16440723231719234, 0.7602968201778826, 0.2057913407220714, 0.2042661968937941, 0.16839475080519783, 0.20244712334660242, 0.20337379973318515, 0.11269981441062282, 0.15562773637333338, 0.2085146210788006, 0.1821850268342402, 0.18734091368041594, 0.18349069057375555, 0.199739531691267, 0.20617930065279566, 0.18809101089913616, 0.1965971504188888, 0.18831488156839082, 0.1800713519568906, 0.08458938586545883, 0.0924901743212676, 0.08349210503532445, 0.10441708984874787, 0.09337172091908108, 0.09948070650648422, 0.08892807603404307, 0.08382803154968244, 0.0875136268883967]}, "mutation_prompt": null}
{"id": "82556a32-f2fd-4a05-a42c-8a6393d2186f", "solution": "import numpy as np\n\nclass RefinedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # Adjusted population size for computational efficiency\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 1.0, self.pop_size)  # Broadened CR range for diversity\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for fine-tuning\n        self.local_intensification = 0.40  # Tweak local search probability\n        self.dynamic_scale = 0.3  # Slightly reduced dynamic scale for variability\n        self.chaos_coefficient = 0.85  # Adjusted chaos for exploratory robustness\n        self.learning_rate = 0.3  # Enhanced adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Adjusted memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedAdaptiveChaoticDE", "description": "Adaptive Differential Evolution refined with chaotic dynamics and self-adaptive parameters for enhanced exploration and exploitation balance.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.9004499658361295, 0.9037177691532142, 0.9006990825922966, 0.9033003127674661, 0.8965284276505566, 0.90466001675214, 0.8948248688515117, 0.9087206585026257, 0.8960889987758538, 0.8122509918969546, 0.8126212481581423, 0.8206675945575976, 0.8060660382203784, 0.8089373082478967, 0.8089989664055821, 0.8041011397407741, 0.820275121416265, 0.8081896236364685, 0.5954431600144128, 0.5493297990481031, 0.521680346566763, 0.4578565825808636, 0.48719930720861726, 0.6924898863286049, 0.17281353393577625, 0.5647057255973811, 0.6100610791832535, 0.1729636221857518, 0.44510789916599003, 0.17066747494432888, 0.5266832811816364, 0.17506155811401003, 0.17616662651418424, 0.16943451775293883, 0.17127671384140863, 0.17387222276209746, 0.9892547449693467, 0.9903129199453897, 0.9654024160837484, 0.9687531539208224, 0.9730347142427258, 0.9731121268446513, 0.9633950199742793, 0.9713556040644434, 0.991355238200015, 0.7088828307793724, 0.7120422034217166, 0.6711409510307149, 0.731341022998004, 0.7067763291262135, 0.6660204082774479, 0.6523369891133161, 0.649795748386383, 0.6692021539897252, 0.825305848174818, 0.8297298700133007, 0.8196015531359409, 0.2764011284134593, 0.8220937242718556, 0.8518759145719309, 0.8626951827937559, 0.8321895792365868, 0.7671933952051416, 0.37595149091765145, 0.37536862249476655, 0.30952468734270855, 0.33911261191983677, 0.13195603381617182, 0.3757175676181752, 0.39330841943777173, 0.13172229642879973, 0.31472966182367257, 0.2454203297584261, 0.2262454891479453, 0.26986795533023267, 0.23897101785711716, 0.38317939826712266, 0.32224683050455605, 0.13089609448605732, 0.1307858815866172, 0.320467137963546, 0.1650739937100929, 0.09395238178829057, 0.16423744578549448, 0.20281350352388172, 0.289271816469332, 0.1210176453472741, 0.2651999561517099, 0.19482358362628394, 0.18267890583306268, 0.29833501393005535, 0.38235205533015615, 0.23007857465003778, 0.31861304434654525, 0.2769599267595788, 0.3267722961582652, 0.42007228637671346, 0.4476877067051519, 0.3543348142670112, 0.04945268965319771, 0.21976162224154439, 0.16376874741485303, 0.13708916990028752, 0.1288092618564226, 0.13326293216985774, 0.07812951235154264, 0.11465163180680304, 0.2838575577861896, 0.3049743378136567, 0.2890342267654922, 0.2820568370335923, 0.3449763054694699, 0.31012380326742106, 0.35659986477413974, 0.19061912594927488, 0.1949678145632513, 0.2833388349003608, 0.7155099112155829, 0.7003914132403044, 0.7434344672967044, 0.7025652577745227, 0.7155175473656236, 0.7164221275459208, 0.6969258848480964, 0.7435012102191672, 0.7506408991984075, 0.10807199869957917, 0.12816607704701533, 0.1522014083156744, 0.1499959126773447, 0.1016141903555896, 0.1138077448983037, 0.12295254833271174, 0.1308256439576022, 0.13755502124306807, 0.1344977300291894, 0.1831548564455907, 0.17783572180829066, 0.1396053425031547, 0.14337021542882344, 0.16445816266582247, 0.14929576096442176, 0.15671888738242523, 0.15379288766824795, 0.6204008553893325, 0.592341833771969, 0.6588770144668081, 0.5890394426485306, 0.551886667469424, 0.6476238532266456, 0.5915805274568917, 0.6672386389673712, 0.6693518914253151, 0.4279764194080795, 0.4310806558341581, 0.3936485001904334, 0.35406995138812813, 0.35214200393449113, 0.38944379213432645, 0.4064692620677165, 0.4955711481054885, 0.44415728931797815, 0.2186781743881313, 0.21834584803618606, 0.21285456726564567, 0.2239722353624728, 0.2102753596111676, 0.21157876865418535, 0.22193267962887075, 0.20031740508655071, 0.23904188218780742, 0.5989084563283555, 0.5866271086444019, 0.4954207045538047, 0.6612231822786638, 0.238149498661002, 0.5474870936266484, 0.5171185034362311, 0.6980470937802188, 0.5916590599907697, 0.1731623210796488, 0.1868760827638586, 0.18716747418501234, 0.19699297171381136, 0.2038108608895015, 0.8363760808506668, 0.1583547887678669, 0.48816197081042967, 0.8349567147386406, 0.7720001795444041, 0.20995445478005048, 0.2111785407165213, 0.16875214812987305, 0.21013921522318135, 0.6839095601161351, 0.7604714051504204, 0.12706276126874239, 0.2103611948492099, 0.17963041217910813, 0.1870330556954044, 0.17186980086419812, 0.18641833978838762, 0.21346144297680103, 0.17551376165075705, 0.1815035293793399, 0.18645544278923576, 0.18251449806175768, 0.09404870053374847, 0.09383888789684702, 0.10052534938324587, 0.09375755110095418, 0.09384844347742871, 0.12103884411933996, 0.09064178465553396, 0.09626635436426245, 0.09004865113409866]}, "mutation_prompt": null}
{"id": "54c9d96e-62df-4a97-8ca3-8214771327e4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.2, 0.9, self.pop_size)  # Broadened CR range further for diversity\n        self.F = np.random.uniform(0.2, 0.9, self.pop_size)  # Adjusted F range for better exploration\n        self.local_intensification = 0.35  # Slightly reduced local search probability\n        self.dynamic_scale = 0.4  # Increased dynamic scale for variability\n        self.chaos_coefficient = 0.9  # Enhanced chaos for exploratory robustness\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # Adjusted memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveChaoticDE", "description": "Enhanced Adaptive Differential Evolution using chaotic dynamics with self-adaptive memory and variable scaling for robust search.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedAdaptiveChaoticDE' object has no attribute 'learning_rate'\").", "error": "AttributeError(\"'EnhancedAdaptiveChaoticDE' object has no attribute 'learning_rate'\")", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {}, "mutation_prompt": null}
{"id": "43b7dff5-0666-471d-9b43-e222ca93cf20", "solution": "import numpy as np\n\nclass AdaptiveSelfGuidedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size to improve diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)  # Expanded CR range for flexibility\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)  # Adjusted F range for stability\n        self.local_intensification = 0.35  # Adjusted local search probability for balance\n        self.dynamic_scale = 0.25  # Fine-tuned dynamic scale for controlled variability\n        self.chaos_coefficient = 0.80  # Optimized chaos for exploratory robustness\n        self.learning_rate = 0.25  # Optimized adaptation speed for efficient learning\n        self.memory = np.zeros(self.dim)  # Memory vector for knowledge retention\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # Balanced memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveSelfGuidedDE", "description": "Adaptive Self-Guided Differential Evolution leveraging multi-phase chaotic dynamics and memory-enhanced search for robust optimization.", "configspace": "", "generation": 83, "fitness": 0.4079013553713214, "feedback": "The algorithm AdaptiveSelfGuidedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.8786765159697484, 0.8715600243259332, 0.875202964401289, 0.8746692440890289, 0.8658804723523764, 0.8742663905857693, 0.8813434193338605, 0.8710759481948864, 0.8649891475849806, 0.7551994592275235, 0.7631097890923528, 0.756814188719718, 0.7582858000161607, 0.7601325577463642, 0.7587237170028839, 0.757758422896344, 0.7623361438524155, 0.7633715321046444, 0.5223291203006253, 0.5455936073859888, 0.5009927707796589, 0.4594483486354546, 0.548704985485464, 0.40638330584022586, 0.17489014513019796, 0.5529203313975013, 0.47283224886797737, 0.35929093221483566, 0.29145233332156817, 0.40627430697335865, 0.1677281514806056, 0.16524624776700025, 0.27062808409209715, 0.26956665930291823, 0.3678667241176925, 0.16914456936123656, 0.9582793039162316, 0.9252181570765337, 0.9524873535585153, 0.9596453790906893, 0.942742696531239, 0.956939153179443, 0.9711908748159825, 0.9604188054798892, 0.9688780780791534, 0.5771803268811129, 0.6171808844458917, 0.5885607983289125, 0.6134070752151293, 0.5922772103321736, 0.6248282597111945, 0.536626047836962, 0.5626522024928543, 0.553607668211592, 0.8014789303001081, 0.7995837944983559, 0.8015827336173408, 0.8065596649472794, 0.7104137644331856, 0.8239585366000446, 0.7917929762414432, 0.7544624233996833, 0.7863162359415972, 0.2436919355445486, 0.12936528590832896, 0.236085350923393, 0.4399814822171394, 0.2528756883652995, 0.3623395957043122, 0.235411620007693, 0.2725072721624463, 0.39051288740677825, 0.2690013101677191, 0.34739796114011423, 0.27363443661370335, 0.20779854233077344, 0.12961922064435205, 0.2798982077178288, 0.17465953702660686, 0.28910064585679607, 0.25918841323380415, 0.16676023016309083, 0.17517310104551165, 0.1705143343738713, 0.1390422723205278, 0.1523041471223764, 0.14801029277061972, 0.21127824531939376, 0.14559868537674825, 0.2209469337830967, 0.27196966816389123, 0.32730797966334846, 0.2817772719203685, 0.2401057442671024, 0.2599586341391953, 0.2219473073828544, 0.29154849647952885, 0.3309419130881983, 0.3716389857147845, 0.17183657278608266, 0.06353432498754119, 0.13867137260594498, 0.20315657883865645, 0.1929102102357766, 0.12292832116006558, 0.11060816002253793, 0.12223467834822499, 0.1232931444193277, 0.2615264737984999, 0.23209372443935505, 0.2430158787979254, 0.2734750657167052, 0.25096126490263515, 0.3037124224552592, 0.25463244762386905, 0.23301761471353732, 0.22584436322619983, 0.65348127527899, 0.6309981104813636, 0.6574558862817437, 0.6544890518263731, 0.6260779821322675, 0.613111152508975, 0.6388348016218004, 0.6930425260557957, 0.6395968906541978, 0.14515796205790044, 0.12191991324910156, 0.11597030250433948, 0.11590521465118164, 0.1148422470361764, 0.11225270041063107, 0.12771217794805145, 0.1247224825668165, 0.11833476456006886, 0.14703694838276082, 0.14599439092757216, 0.1444625409571303, 0.13063679178371634, 0.16172115509795626, 0.1479327242327425, 0.1420123902578223, 0.16522557478979127, 0.16175191786861265, 0.4855730480450874, 0.46652340642403334, 0.4660466504552997, 0.48380947897218307, 0.4929175470111743, 0.40528741337871255, 0.5598454638850543, 0.5680976212816269, 0.5673825122285053, 0.346497457230317, 0.35056083465164367, 0.31935063350413606, 0.20988092425675853, 0.24169736303878153, 0.30125882104569646, 0.3488402664368855, 0.38063441876058746, 0.3567216540365399, 0.20845418696787832, 0.21623065488862314, 0.20340423151751796, 0.2237212914121922, 0.21474214729008223, 0.22777604073891233, 0.19863865758326682, 0.2075478125642466, 0.19739709145078066, 0.5988370013952174, 0.24204852978675584, 0.4605358789558852, 0.4736411022481889, 0.23916871479011947, 0.23656960696640017, 0.4417505723227668, 0.5152823863764119, 0.25492216237823173, 0.18322900748003135, 0.20476100800353647, 0.7335698914303125, 0.8572703873761044, 0.8281717469953623, 0.6294948275621306, 0.8433079392733909, 0.14189210609109726, 0.8245230093894949, 0.766521356070881, 0.20652471927292193, 0.7865661885778379, 0.2079699973596819, 0.16574305756496566, 0.7507303758493782, 0.49790591708705756, 0.6402901426160026, 0.6378110822266763, 0.21677600650367845, 0.1970492285385308, 0.1999841967442818, 0.1853581552469955, 0.18688929804813348, 0.18112365758907623, 0.18273632432879672, 0.1809815028284788, 0.1901353242285021, 0.08246801591881081, 0.08929642813193661, 0.09360012451206057, 0.08989163111784948, 0.08040403477521263, 0.0833776789247811, 0.09275627426412192, 0.09231376583776496, 0.08269069178164423]}, "mutation_prompt": null}
{"id": "29e00071-4ebb-4173-a80b-9af9aa198faf", "solution": "import numpy as np\n\nclass RefinedAdaptiveChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # Adjusted population size for computational efficiency\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 1.0, self.pop_size)  # Broadened CR range for diversity\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for fine-tuning\n        self.local_intensification = 0.40  # Tweak local search probability\n        self.dynamic_scale = 0.3  # Slightly reduced dynamic scale for variability\n        self.chaos_coefficient = 0.85  # Adjusted chaos for exploratory robustness\n        self.learning_rate = 0.3  # Enhanced adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with dynamic scaling and refined strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Adjusted memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedAdaptiveChaoticDE", "description": "Adaptive Differential Evolution refined with chaotic dynamics and self-adaptive parameters for enhanced exploration and exploitation balance.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.9004499658361295, 0.9037177691532142, 0.9006990825922966, 0.9033003127674661, 0.8965284276505566, 0.90466001675214, 0.8948248688515117, 0.9087206585026257, 0.8960889987758538, 0.8122509918969546, 0.8126212481581423, 0.8206675945575976, 0.8060660382203784, 0.8089373082478967, 0.8089989664055821, 0.8041011397407741, 0.820275121416265, 0.8081896236364685, 0.5954431600144128, 0.5493297990481031, 0.521680346566763, 0.4578565825808636, 0.48719930720861726, 0.6924898863286049, 0.17281353393577625, 0.5647057255973811, 0.6100610791832535, 0.1729636221857518, 0.44510789916599003, 0.17066747494432888, 0.5266832811816364, 0.17506155811401003, 0.17616662651418424, 0.16943451775293883, 0.17127671384140863, 0.17387222276209746, 0.9892547449693467, 0.9903129199453897, 0.9654024160837484, 0.9687531539208224, 0.9730347142427258, 0.9731121268446513, 0.9633950199742793, 0.9713556040644434, 0.991355238200015, 0.7088828307793724, 0.7120422034217166, 0.6711409510307149, 0.731341022998004, 0.7067763291262135, 0.6660204082774479, 0.6523369891133161, 0.649795748386383, 0.6692021539897252, 0.825305848174818, 0.8297298700133007, 0.8196015531359409, 0.2764011284134593, 0.8220937242718556, 0.8518759145719309, 0.8626951827937559, 0.8321895792365868, 0.7671933952051416, 0.37595149091765145, 0.37536862249476655, 0.30952468734270855, 0.33911261191983677, 0.13195603381617182, 0.3757175676181752, 0.39330841943777173, 0.13172229642879973, 0.31472966182367257, 0.2454203297584261, 0.2262454891479453, 0.26986795533023267, 0.23897101785711716, 0.38317939826712266, 0.32224683050455605, 0.13089609448605732, 0.1307858815866172, 0.320467137963546, 0.1650739937100929, 0.09395238178829057, 0.16423744578549448, 0.20281350352388172, 0.289271816469332, 0.1210176453472741, 0.2651999561517099, 0.19482358362628394, 0.18267890583306268, 0.29833501393005535, 0.38235205533015615, 0.23007857465003778, 0.31861304434654525, 0.2769599267595788, 0.3267722961582652, 0.42007228637671346, 0.4476877067051519, 0.3543348142670112, 0.04945268965319771, 0.21976162224154439, 0.16376874741485303, 0.13708916990028752, 0.1288092618564226, 0.13326293216985774, 0.07812951235154264, 0.11465163180680304, 0.2838575577861896, 0.3049743378136567, 0.2890342267654922, 0.2820568370335923, 0.3449763054694699, 0.31012380326742106, 0.35659986477413974, 0.19061912594927488, 0.1949678145632513, 0.2833388349003608, 0.7155099112155829, 0.7003914132403044, 0.7434344672967044, 0.7025652577745227, 0.7155175473656236, 0.7164221275459208, 0.6969258848480964, 0.7435012102191672, 0.7506408991984075, 0.10807199869957917, 0.12816607704701533, 0.1522014083156744, 0.1499959126773447, 0.1016141903555896, 0.1138077448983037, 0.12295254833271174, 0.1308256439576022, 0.13755502124306807, 0.1344977300291894, 0.1831548564455907, 0.17783572180829066, 0.1396053425031547, 0.14337021542882344, 0.16445816266582247, 0.14929576096442176, 0.15671888738242523, 0.15379288766824795, 0.6204008553893325, 0.592341833771969, 0.6588770144668081, 0.5890394426485306, 0.551886667469424, 0.6476238532266456, 0.5915805274568917, 0.6672386389673712, 0.6693518914253151, 0.4279764194080795, 0.4310806558341581, 0.3936485001904334, 0.35406995138812813, 0.35214200393449113, 0.38944379213432645, 0.4064692620677165, 0.4955711481054885, 0.44415728931797815, 0.2186781743881313, 0.21834584803618606, 0.21285456726564567, 0.2239722353624728, 0.2102753596111676, 0.21157876865418535, 0.22193267962887075, 0.20031740508655071, 0.23904188218780742, 0.5989084563283555, 0.5866271086444019, 0.4954207045538047, 0.6612231822786638, 0.238149498661002, 0.5474870936266484, 0.5171185034362311, 0.6980470937802188, 0.5916590599907697, 0.1731623210796488, 0.1868760827638586, 0.18716747418501234, 0.19699297171381136, 0.2038108608895015, 0.8363760808506668, 0.1583547887678669, 0.48816197081042967, 0.8349567147386406, 0.7720001795444041, 0.20995445478005048, 0.2111785407165213, 0.16875214812987305, 0.21013921522318135, 0.6839095601161351, 0.7604714051504204, 0.12706276126874239, 0.2103611948492099, 0.17963041217910813, 0.1870330556954044, 0.17186980086419812, 0.18641833978838762, 0.21346144297680103, 0.17551376165075705, 0.1815035293793399, 0.18645544278923576, 0.18251449806175768, 0.09404870053374847, 0.09383888789684702, 0.10052534938324587, 0.09375755110095418, 0.09384844347742871, 0.12103884411933996, 0.09064178465553396, 0.09626635436426245, 0.09004865113409866]}, "mutation_prompt": null}
{"id": "4861f80d-5544-43d0-93ce-aad3c191aeca", "solution": "import numpy as np\n\nclass EnhancedChaoticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for broader search\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)  # Narrowed CR range for controlled variation\n        self.F = np.random.uniform(0.2, 0.7, self.pop_size)  # Narrowed F range for precision\n        self.local_intensification = 0.35  # Adjusted local search probability\n        self.dynamic_scale = 0.25  # Further reduced dynamic scale for stability\n        self.chaos_coefficient = 0.9  # Increased chaos for greater exploratory diversity\n        self.learning_rate = 0.35  # Increased adaptation speed for rapid convergence\n        self.memory = np.zeros(self.dim)  # Memory vector for temporal learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def stochastic_perturbation(self, vector):\n        perturbation_strength = np.random.uniform(-0.05, 0.05, self.dim)\n        return vector + perturbation_strength\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n\n                mutant = self.stochastic_perturbation(mutant)\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.5 * self.memory + 0.5 * (trial - self.population[i])  # Optimized memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedChaoticDE", "description": "Enhanced Adaptive Differential Evolution with chaotic dynamics and a novel stochastic perturbation mechanism for improved exploration.", "configspace": "", "generation": 85, "fitness": 0.29184122321092787, "feedback": "The algorithm EnhancedChaoticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.5849149422551161, 0.6118368674685055, 0.5894642881395054, 0.5833857965384384, 0.5838797410404055, 0.579148616244364, 0.5772408242070292, 0.5697735380958027, 0.5929744283895841, 0.255221483109897, 0.24021993872645364, 0.2384104033070099, 0.26310028651437023, 0.2375530584159986, 0.23869669877697142, 0.25291190376265427, 0.23059185700404972, 0.23030628658985453, 0.23900470352453607, 0.2037004563520982, 0.23723025267965736, 0.23074400721413535, 0.21351645372070494, 0.20112781251631073, 0.22564014926492004, 0.2274355929108275, 0.22506913887144708, 0.1611333296523968, 0.16898015663058708, 0.15276244263070315, 0.1478437037690965, 0.16206912172387933, 0.1433294092648072, 0.16316491217271467, 0.13832051199220063, 0.15718780467176763, 0.9649420754976259, 0.9773862604230283, 0.9453194553212627, 0.9769644478912344, 0.968346783855523, 0.9534270331243515, 0.9584220790790825, 0.9703227728130484, 0.9837017090575981, 0.37959994417273024, 0.3775595696609889, 0.35920786603102195, 0.35290643177384373, 0.3727384696954025, 0.36455235829128463, 0.3716826641739577, 0.3548094833341361, 0.37257844688749897, 0.6790581675301799, 0.6778673493229975, 0.7664754465194924, 0.7452746397409022, 0.2099303700915397, 0.7241514006850366, 0.6753320024123959, 0.7168359416826029, 0.6673698334409507, 0.21171076896120755, 0.1744397800065839, 0.17750230519225407, 0.19328813171013093, 0.17091521693157463, 0.21301752479427427, 0.17962099663766096, 0.180442842378441, 0.19008743593812416, 0.19815893625847691, 0.20465977376151367, 0.18753288156934889, 0.20595784601366873, 0.18370303271365152, 0.17602967953716075, 0.19635777419187317, 0.19977511923572822, 0.1941027904335425, 0.032301138815101105, 0.03495214045202921, 0.06103264741753389, 0.0277840843588818, 0.05495487362503004, 0.03339979502732782, 0.07477588331608731, 0.039133768850586836, 0.077056883496332, 0.1263985495295159, 0.13022808538121988, 0.17981578223262118, 0.14325940194420494, 0.06848697609892229, 0.15111093268273557, 0.13899567987082861, 0.18606674468189532, 0.16197184375954565, 0.04277362240112781, 0.005007050512429667, 0.02645616479926516, 0.008663611868161003, 0.0036654295660509817, 0.015899388221622623, 0.014157968237436425, 0.02401438619042906, 0.002173556649697317, 0.138483601458118, 0.13626630695896125, 0.12732416239247413, 0.166868959083039, 0.1377532342239538, 0.1501199670559734, 0.12119326099462724, 0.14011999910988449, 0.14841767081574542, 0.4877839591121046, 0.5029603817047936, 0.5003718823895725, 0.4882379495939966, 0.48662837790025104, 0.49822149487559186, 0.5004196632978128, 0.5052768189133232, 0.5125481324034735, 0.09590519075773318, 0.10860100606107137, 0.11597929208938096, 0.1050258579673451, 0.1015752997466367, 0.12024488894378971, 0.11934439029304067, 0.11555535229472003, 0.11473240330785062, 0.1401053263331169, 0.17658781556754688, 0.17477361066345198, 0.13213817442597187, 0.16412874449546433, 0.14966877279246094, 0.14223891823884294, 0.1614521932619324, 0.14633750028401138, 0.34656212209884274, 0.3489299390096249, 0.34294510994619565, 0.34375027185900564, 0.3369568581771728, 0.33812364736945555, 0.34372495719291174, 0.3461950276037836, 0.348064788712217, 0.22076856537926914, 0.2573133896000035, 0.21377765614149657, 0.2710635118344856, 0.2643376296678017, 0.19785705416240418, 0.2799304003126126, 0.2664444609497244, 0.27079400056151415, 0.22555932221523423, 0.19309269641057947, 0.19802912316019206, 0.1963685167034962, 0.20960375385258256, 0.21254675097894893, 0.21116319096672598, 0.2215766702697063, 0.22434309871952307, 0.2969801789684824, 0.24066957570115455, 0.2888961363648951, 0.3226247799281916, 0.2947295837261421, 0.2868468097975644, 0.3160794027415522, 0.3034189005895166, 0.3230670460699504, 0.1859780099972903, 0.7241203241174833, 0.8552808891383796, 0.1913384487386982, 0.8492561584890541, 0.834388743828901, 0.7359843938131352, 0.7175372829009377, 0.17383212046634455, 0.697153315332864, 0.5967205259957424, 0.20742264302583702, 0.16427488000729462, 0.20119289822621256, 0.614430986551806, 0.2071095605307982, 0.4690362978553281, 0.10496598061690288, 0.21385615539239677, 0.18167457926585162, 0.19483079754646015, 0.18104354012034296, 0.1880129072284562, 0.17996057252960418, 0.17696051955576753, 0.17516489716170613, 0.1867393624054834, 0.08471524792634477, 0.07803271961028824, 0.08647038905394788, 0.09363337425762563, 0.08150233955450681, 0.08779800265726068, 0.0777495419672316, 0.0954882367714538, 0.08102893646130038]}, "mutation_prompt": null}
{"id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for better search space coverage\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)  # Adjusted CR range for enhanced crossover\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)  # Expanded F range for increased explorative potential\n        self.local_intensification = 0.45  # Increased local search probability\n        self.dynamic_scale = 0.35  # Increased dynamic scale for diversity\n        self.chaos_coefficient = 0.9  # Enhanced chaos for greater exploration\n        self.learning_rate = 0.25  # Adjusted adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with chaotic dynamics and adaptive memory for diversified search and convergence acceleration.", "configspace": "", "generation": 86, "fitness": 0.4329665342538733, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "c65d168b-75fd-417c-bf45-925e1122955f", "metadata": {"aucs": [0.9021133573931382, 0.8975468481783885, 0.9021361384439011, 0.9067060164712143, 0.9085431744431548, 0.909520461981997, 0.8959220056225489, 0.903316039245486, 0.9032865893700945, 0.8144288870721867, 0.802685509829284, 0.8042409817241492, 0.8027025286620362, 0.8092983909907241, 0.7968907496616967, 0.8070906774705641, 0.8063846103924521, 0.8101300790135553, 0.4432698829122097, 0.5507211470278504, 0.617728350761525, 0.41310093371067447, 0.5697572188669393, 0.6098484464824864, 0.6153252237910498, 0.5778994281417891, 0.571389829980943, 0.39438398497272475, 0.4256531825676969, 0.15116100246983366, 0.14826992303459008, 0.42961164060371415, 0.13949997580410778, 0.3366002569152984, 0.14232365601027264, 0.1945858312444123, 0.9656464963070306, 0.9616789725327864, 0.978719868500024, 0.965020844250274, 0.9748213127597312, 0.9807769138522578, 0.9854495476596292, 0.9683695209185426, 0.9787988209102115, 0.6652047745380707, 0.5954232275018156, 0.6405684645642125, 0.6425554272226848, 0.6165650939533147, 0.6641081600205736, 0.6045630068194734, 0.5883789269100292, 0.5624640774104561, 0.852966854987266, 0.8250208323905406, 0.779680832511672, 0.7006171169548856, 0.8149395764357189, 0.8566362432256156, 0.8107953701017723, 0.8196921205244158, 0.2390234154456904, 0.32350759341335744, 0.34941399252820515, 0.24831069306496834, 0.12082816783448047, 0.5941173987679019, 0.1332063211528728, 0.33230419022838287, 0.28164566771838906, 0.40697241343356605, 0.30945252011156876, 0.3329430082265955, 0.13164407839949077, 0.4779723353476243, 0.5801558440150398, 0.4282539218307554, 0.3829418300022662, 0.4846288984634922, 0.3159580316954359, 0.12875737894547112, 0.1971015891035096, 0.13929947708687906, 0.22048603100923014, 0.22161969547955318, 0.17603812138339814, 0.22170487275476658, 0.15936372912647345, 0.18944629585568296, 0.26880970164580975, 0.3477983791638798, 0.35728589120584386, 0.33598935918340345, 0.3253006172802839, 0.29832442015984784, 0.41375624374744224, 0.41789063317955966, 0.37000177086082764, 0.055231181890290415, 0.05982708159206718, 0.10986905166095218, 0.09943774634674174, 0.1913687523455858, 0.1906556120405718, 0.20224595465397743, 0.11334530312385072, 0.20869888970542283, 0.23910276388062657, 0.26923585617778334, 0.2714340312637634, 0.31183427170565914, 0.3245539157754559, 0.3079191100570312, 0.3063994397313523, 0.24989172085182476, 0.2787854533824322, 0.7238504745873442, 0.6910667349089095, 0.7281943407216445, 0.7328423395496175, 0.7152174159979607, 0.6783824558996072, 0.6943726916489716, 0.7069960511571479, 0.7162993930165502, 0.1396763372537433, 0.12417948527925693, 0.12070940814191233, 0.37885349093588827, 0.12481204481334918, 0.11530278837169061, 0.13626191487607398, 0.13357081853555464, 0.11865386013795032, 0.17466818634381798, 0.18542138906978656, 0.14860701427913792, 0.15532325655012813, 0.22290099101008554, 0.18606798450225093, 0.15863419766160114, 0.1365675454691826, 0.18229548406959517, 0.5653414479361561, 0.6560877078161711, 0.6753373944251113, 0.5449585889344108, 0.5151481349733835, 0.6033684131633437, 0.6648366301799018, 0.6444834775614469, 0.5702284098929676, 0.3280977480179147, 0.22360268811269712, 0.30027116065392, 0.3646555152449318, 0.3666822597401509, 0.35880192585737425, 0.40110497646965604, 0.365996854810711, 0.21340596369377285, 0.21751907001638904, 0.2201139848571585, 0.19532071467318035, 0.20457807067580502, 0.26344317472333345, 0.20973595497009945, 0.23879804374405478, 0.22448793313083348, 0.1946295637081169, 0.6473386711890985, 0.23169622409080126, 0.22743326894473703, 0.21317986655744248, 0.21308236195752717, 0.6366429618958241, 0.6166444018737764, 0.24550425466160963, 0.23985893282941184, 0.8344983958047756, 0.17343159816884202, 0.18247207281311628, 0.8882313151493724, 0.1624344943148044, 0.9120405604608486, 0.8109454425407837, 0.14194813317104293, 0.8679067199609234, 0.49676957535298016, 0.8478318240631574, 0.21120930255942483, 0.16724636647281477, 0.167597477538585, 0.8622148893326235, 0.15578847951005625, 0.8283201754040345, 0.8446956718894216, 0.1929985780293152, 0.18519903812415173, 0.18212199571158116, 0.18170561309937017, 0.1882838048215807, 0.1852221920581364, 0.17779181529900512, 0.19263165911451074, 0.1738214748703638, 0.08356437573636855, 0.09881645983962262, 0.08746836721507878, 0.09316320706969039, 0.0862494087340474, 0.09190108806483421, 0.09690176516737814, 0.08813923820635605, 0.0814379463306254]}, "mutation_prompt": null}
{"id": "087d01b5-c583-4c25-beec-63ca8039998d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45\n        self.dynamic_scale = 0.35\n        self.chaos_coefficient = 0.9\n        self.learning_rate = 0.25\n        self.memory = np.zeros(self.dim)\n        self.topology_update_frequency = 10  # New: topology update frequency\n        self.elite_fitness = np.inf\n        self.elite_solution = None\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def update_topology(self):\n        indices = np.argsort(self.fitness)\n        elite_count = max(1, int(0.1 * self.pop_size))\n        for i in range(elite_count, self.pop_size):\n            self.population[indices[i]] = self.population[indices[np.random.randint(elite_count)]]\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        gen_count = 0\n        while evaluations < self.budget:\n            if gen_count % self.topology_update_frequency == 0:\n                self.update_topology()\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                    if trial_fitness < self.elite_fitness:\n                        self.elite_fitness = trial_fitness\n                        self.elite_solution = trial\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n            gen_count += 1\n\n        return self.elite_solution, self.elite_fitness", "name": "EnhancedAdaptiveDE", "description": "Modified Enhanced Adaptive DE by incorporating dynamic topology updates and elite preservation for improved exploration and convergence.", "configspace": "", "generation": 87, "fitness": 0.3580615513763938, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.30.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.9213845847784934, 0.9168985427114698, 0.9154228382830177, 0.9112382661023731, 0.9206339006887704, 0.9186703450615088, 0.9118020245720874, 0.9110184556420653, 0.9110953928091732, 0.8460036716723415, 0.8359570076454309, 0.8400759098078912, 0.8251027885386104, 0.8458656396102673, 0.8323267608467577, 0.8168283862242348, 0.8518014802726244, 0.8555518554107635, 0.8153681185360434, 0.789469025449578, 0.16137587049532398, 0.1614375215725402, 0.18892548147108368, 0.1328280692678505, 0.7855029647160603, 0.8090064710899068, 0.15857514474338463, 0.14269638165543785, 0.15312956260782828, 0.12219465273090813, 0.1587263190553464, 0.14159734631550314, 0.12199180135191467, 0.11522037756560966, 0.12794167389797362, 0.1091330880710577, 0.9713864150848721, 0.9674366543165877, 0.9681313699061127, 0.9817293977123572, 0.9813173839681452, 0.9803156652509679, 0.9567850441597494, 0.9892044646211865, 0.9829871458549952, 0.8242906457799241, 0.5712083610265053, 0.5276831827909543, 0.658641793273383, 0.7989007612182257, 0.7908629779107534, 0.7675199139316609, 0.5893305557330374, 0.1802140875936109, 0.36189008666298417, 0.8994834634848662, 0.2224060485388919, 0.28125080532966806, 0.9124022713882419, 0.9160542888379459, 0.17747461806819176, 0.22374438612503345, 0.40020284383605, 0.1290103289647061, 0.21250217633076474, 0.18344042200528998, 0.40950869807241486, 0.17050997768729648, 0.13152260571709762, 0.12673999979705663, 0.19677142206856302, 0.18639064691341656, 0.18699181870083703, 0.20488837420789296, 0.1077708665650271, 0.17919861918809055, 0.2557808064304551, 0.13301792393123757, 0.20726388914473393, 0.2089902980806262, 0.20652018461247645, 0.1885385020660889, 0.13911197543754572, 0.060724158839773, 0.04638547238377522, 9.999999999998899e-05, 0.022736821899918325, 0.05529687125706173, 0.18791946909918555, 0.1008996532561689, 0.20197872361269598, 0.11088254676260256, 0.09285205760811954, 0.10527625085997605, 0.17716560142921134, 0.16604535756095706, 0.17984856967213947, 0.105349550180878, 0.0971912904962473, 0.04907652537802165, 0.1705370697584001, 0.28409745384118756, 0.08654611390292188, 0.11276852487332256, 0.09620870782974611, 0.16284220089014312, 0.14380359977560242, 0.10292572168734315, 0.09208868322852082, 0.14782037273070459, 0.09812211484379074, 0.11896748562949178, 0.27480622939621, 0.12491182059345396, 0.1622469810710101, 0.1509339809153435, 0.14443891010886523, 0.5916538387944585, 0.5306497363692315, 0.6416756274817168, 0.5969368699460089, 0.5878320389326952, 0.6749665372723335, 0.6372242871439397, 0.6569203316035468, 0.6094024502679142, 0.1560550479334175, 0.1433929906586474, 0.14442604221244948, 0.09197213209803634, 0.14221569276289503, 0.11060026200089856, 0.13176566090856434, 0.09138076493630398, 0.14478392738372226, 0.210884913545063, 0.1958942099448735, 0.19449696880662726, 0.1557264349423536, 0.1851529472127923, 0.2814796205091251, 0.3479516220023199, 0.1645005824952439, 0.25890211936813934, 0.6116219317262512, 0.5404161697112035, 0.2578573294813522, 0.3448138259436144, 0.47855344482118645, 0.25995461636876627, 0.41155255164881577, 0.7234790350859738, 0.758704532331912, 0.2590370514566769, 0.3699314082708878, 0.32990800519835173, 0.229731270994172, 0.13970692296376142, 0.32478373958743356, 0.46617581690430576, 0.2918408647240718, 0.4519557256154696, 0.21194610098627975, 0.2402909019165299, 0.18091019897079297, 0.20411772439878084, 0.2578102701861099, 0.2186926797872384, 0.24119776894150569, 0.252978456056692, 0.21137391724891463, 0.18301346595328072, 0.2018734676000291, 0.2285024918783377, 0.1975353617310771, 0.21166509268133882, 0.19954420580064414, 0.20439989571926287, 0.2221129461748178, 0.2081057421518866, 0.15777979802615194, 0.9280417898962999, 0.912330923981969, 0.9370612620238075, 0.17614259488781459, 0.13121795303063444, 0.9176678899312486, 0.1696023248429528, 0.13590834169307964, 0.8160830107641055, 0.21071311248516023, 0.16806721836032468, 0.16896159168791036, 0.21102175238463328, 0.15601092441621256, 0.1678606226590822, 0.15470603449849463, 0.2132764082997053, 0.2167501946907915, 0.21668181135354259, 0.22121570957854864, 0.23564574020178186, 0.197392212592581, 0.19537618787706956, 0.20545556313390445, 0.23005670357960883, 0.23327852906075996, 0.1093576742646113, 0.09925786407893034, 0.1456182996945341, 0.10718344004666192, 0.10412703510198829, 0.1008209330145099, 0.12963927241768802, 0.08560259486879784, 0.10652640835357818]}, "mutation_prompt": null}
{"id": "94da756b-4c87-4b78-8903-e827737bf9a6", "solution": "import numpy as np\n\nclass StochasticLearningDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # Increased population size further for exploration\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 1.0, self.pop_size)  # Broadened CR range\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Narrowed F range for stability\n        self.local_intensification = 0.5  # Increased local search probability\n        self.dynamic_scale = 0.4  # Further increased dynamic scale for diversity\n        self.chaos_coefficient = 0.85  # Adjusted chaos for balance\n        self.learning_rate = 0.3  # Slightly increased adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticLearningDE", "description": "Adaptive DE with stochastic learning and chaos-enhanced diversification for improved exploration-exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.37821018884658913, "feedback": "The algorithm StochasticLearningDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.8797949235741099, 0.874168277569932, 0.8758287546898432, 0.8701784920530644, 0.8767780039763398, 0.8745599042433914, 0.8715892817464347, 0.8774794902545124, 0.8728663997712156, 0.7532843886380197, 0.7330125460802056, 0.749463366538905, 0.7550538808843397, 0.7439330525254781, 0.7543420638660032, 0.7674661222897488, 0.7625626342033092, 0.7502558972310079, 0.4322344210796577, 0.5415231597154729, 0.49059083606471876, 0.30101808548692965, 0.4867040239471597, 0.48166757613824973, 0.5520078874270327, 0.39557168435314627, 0.4163082140754365, 0.22500903453688748, 0.16539388373048913, 0.14520627971052236, 0.1679388875453618, 0.14746321446712285, 0.16260107159534432, 0.3156576404924981, 0.16119389974744625, 0.163490754907474, 0.9601175675311823, 0.9699020852355564, 0.9632345219172559, 0.9687938557982683, 0.9710183715067401, 0.9748512959100991, 0.9802292049944098, 0.9775532189150793, 0.9796377720118429, 0.5900112489079102, 0.5608335293187345, 0.5758863512245991, 0.6054799698136799, 0.5962351519977062, 0.6269505528794106, 0.5133483977259474, 0.539735043785076, 0.446240857828193, 0.7676325348985182, 0.7511616117136931, 0.7765699164273017, 0.6756217817459014, 0.27368159548483173, 0.8571971697555989, 0.8451713517975452, 0.7886033036603379, 0.6929579740953891, 0.2349922453605291, 0.22687459517083464, 0.2669909670203858, 0.1303454809836505, 0.2404952533271243, 0.23510204841017945, 0.23359589264194625, 0.2970660614198004, 0.2880356255607388, 0.2247855564627813, 0.2062107575703408, 0.24515708111995094, 0.1311473374023786, 0.3260585778959949, 0.22503943163022389, 0.25785974274079526, 0.2897259511459124, 0.203538377736165, 0.1524839229490461, 0.14679169274867088, 0.07076049569761211, 0.16056934456841931, 0.18738613246204439, 0.11053789219380838, 0.19068149820096647, 0.1448623240097492, 0.06287409177464376, 0.282432526756621, 0.23785343909831658, 0.305022107742589, 0.23683024135276287, 0.25811108912465, 0.2230073771418969, 0.2815155450201893, 0.32843561317191317, 0.33261789413471665, 0.08484443255179763, 0.1369707284434336, 0.2206128297316815, 0.16842435166648373, 0.09173752634742793, 0.10354862172816626, 0.12022206078297082, 0.12104456494601623, 0.22364202428370483, 0.25330145652331804, 0.2305982304168539, 0.22067424173318095, 0.2884358326406651, 0.28296116595809706, 0.30900778105244675, 0.2463685915636351, 0.22282383863176713, 0.20463863774305613, 0.6624159810456202, 0.6513896546168549, 0.667451516689559, 0.6616328909324087, 0.6717782317378785, 0.6401406275844208, 0.6423121129611994, 0.6589787844635056, 0.6480892643235263, 0.11599023384647367, 0.1303274050747335, 0.11077142253846373, 0.1273554115625264, 0.13827219010362202, 0.1382871830710718, 0.1277216488994738, 0.12835066751631108, 0.10630678940893046, 0.12697769703191153, 0.15661516898772865, 0.1820674142637524, 0.15328419971871554, 0.17217800503460934, 0.1387042929305159, 0.13934185994514614, 0.15495186081156131, 0.14221104624024805, 0.4815868226930743, 0.4835045110763062, 0.493077783823313, 0.5269593080193644, 0.4923324462062689, 0.5151114981273595, 0.576157516409515, 0.5609952018533457, 0.5727871514634204, 0.3401106870741262, 0.3742135572818911, 0.3260918516999832, 0.3503411008589692, 0.35720436889334295, 0.3555765379905834, 0.4073237764328924, 0.38938430398670487, 0.3778253776271149, 0.2079771894708904, 0.20604916232085302, 0.218539286920301, 0.2355333982314367, 0.24076038706080494, 0.23606242548926692, 0.21006468177578907, 0.21526459344271343, 0.2083368040666208, 0.36970107464247115, 0.2971258656784822, 0.6215479808053821, 0.30826537052000846, 0.22247523285784154, 0.2121563884668647, 0.23020887956860647, 0.24101357575688698, 0.21768851614986884, 0.16511504000810928, 0.18630748238061678, 0.20550122007756177, 0.2005261671516928, 0.7052383489724148, 0.1574628802554664, 0.16322656954823755, 0.16045273207225186, 0.751233810488243, 0.16903775993990022, 0.6276779057570708, 0.21010302803817016, 0.6970808819533556, 0.21087127354814195, 0.209363684903208, 0.2125398190855906, 0.7602432943351487, 0.16458833081419055, 0.1864894080029802, 0.1977244829071887, 0.18469149995234735, 0.19284628170822693, 0.1773568472431687, 0.19025186028066376, 0.18119553084957274, 0.20260135607488317, 0.19834949386930367, 0.0845812691497777, 0.0894218490881794, 0.1160279476270667, 0.09597494332556689, 0.07791587864733196, 0.08870900062253584, 0.08326626813020188, 0.08855384513697895, 0.0991092223038027]}, "mutation_prompt": null}
{"id": "1cd21352-cb6e-420b-ba1f-a2e9871c6845", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Retaining population size for broad search scope\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 0.9, self.pop_size)  # Fine-tuned CR range for crossover balance\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for controlled exploration\n        self.opposition_threshold = 0.3  # Probability threshold for opposition learning\n        self.learning_rate = 0.2  # Adjusted learning rate for parameter self-adaptation\n        self.memory = np.zeros(self.dim)\n\n    def chaotic_map(self, x):\n        return 0.9 * x * (1 - x)\n\n    def opposition_based_learning(self, x):\n        return self.bounds[0] + self.bounds[1] - x\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with an adaptive strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.F[i] * (self.population[b] - self.population[c])\n\n                # Opposition-based Local Search\n                if np.random.rand() < self.opposition_threshold:\n                    opposition = self.opposition_based_learning(mutant)\n                    mutant = 0.5 * (mutant + opposition)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "Hybrid Adaptive DE utilizing self-adaptive control parameters and opposition-based learning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 89, "fitness": 0.27761907988442, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.7284058332337583, 0.7155042263746638, 0.7178391948725354, 0.699979251685747, 0.7285345763554327, 0.7078879913093009, 0.704901710872906, 0.7176327733315391, 0.7165443064381933, 0.4865307182257077, 0.46975700652651353, 0.4723941101225321, 0.5251502463229218, 0.5237221868652555, 0.5259922881901197, 0.450246633069873, 0.48327537065599513, 0.4628562743981013, 0.19623105075369573, 0.20315636434951034, 0.21790108120827822, 0.166101399987156, 0.21020933484178428, 0.17582077054792933, 0.17159487501126913, 0.2516638612036167, 0.2044887031212016, 0.15901897025981448, 0.15601469684580938, 0.13593618081847691, 0.168322722952983, 0.16275213053549287, 0.16265889902983222, 0.1462411310724896, 0.17111762419708032, 0.19085669239886927, 0.921818004769177, 0.9369399973434049, 0.9068094415593793, 0.9213452284336655, 0.9413263908253162, 0.8894853621080386, 0.9302856695838313, 0.9192918671711149, 0.9114489719818039, 0.2986247184214671, 0.24392185806612643, 0.22365488962017688, 0.2889521233135316, 0.3468940082381202, 0.2773698445297633, 0.2685771440514234, 0.2595259808149166, 0.26732077643918084, 0.2171830514687898, 0.4678628478649832, 0.2550943230936217, 0.439368262974388, 0.5913961502132535, 0.5588873393620215, 0.38599373230710954, 0.2724256466893221, 0.27931072880890295, 0.24595408914477834, 0.28316641999005854, 0.2536808589153766, 0.17400331066892705, 0.15154932117939302, 0.15716633235095612, 0.1402020113082062, 0.14170678174489826, 0.1937602600189049, 0.22482834291555087, 0.21996106350561917, 0.26489084655381123, 0.20454527806883593, 0.23010587359733814, 0.2170700144338782, 0.3138384287962753, 0.28241833130143545, 0.2522800405337118, 0.022726356519555346, 0.019677828776825113, 0.023910305588989433, 0.011747353138055194, 0.015091804825893118, 0.017486452070182845, 0.06306696080438745, 0.07294292814031911, 0.05785720837963204, 0.16739845707728795, 0.15512583275771596, 0.14940857688328701, 0.1070162610072497, 0.11105148885118687, 0.16047856300829022, 0.12466348600902055, 0.20333104210316255, 0.16490445909480167, 0.02324622283379818, 0.021151482552996592, 0.03983272080870082, 0.002224676756341415, 0.03302120277509912, 0.013725968562429025, 0.023094856500017302, 0.012318916058739138, 0.01359354657785572, 0.10347914624675925, 0.1099344341699916, 0.11656982156782181, 0.13720436815546888, 0.12936659150995222, 0.11107443477772616, 0.1122735385908904, 0.10885361729365672, 0.09961448234479742, 0.47108702914957046, 0.48942512736370813, 0.47805002022870713, 0.49344660297630616, 0.4592366570534808, 0.5215854621644507, 0.4940146927885549, 0.4828215606616323, 0.5200896502297783, 0.0992162055846798, 0.10496474530441902, 0.09833720831350601, 0.09676730908469, 0.10834345022543856, 0.10610229271770222, 0.11193439280834372, 0.10003988576390332, 0.08787702569975087, 0.1557415871256902, 0.16450504699797186, 0.1458062597449914, 0.18089939730813576, 0.15330870384034656, 0.1497253628430837, 0.146868004608813, 0.15768302356096664, 0.1445851495092505, 0.30204041538938875, 0.30673462262740914, 0.2801368294272174, 0.3108952896403392, 0.34400905330653486, 0.3280620386986941, 0.3177669879722783, 0.32104167374847037, 0.32786527488770867, 0.21319009573019498, 0.1990039297466164, 0.20800503379657298, 0.24415119963417087, 0.24682359126747144, 0.2691011262395142, 0.21751676237221496, 0.22355646637168725, 0.2002635012178805, 0.2602151077428243, 0.2601262435987256, 0.26047513249645304, 0.2602151077428243, 0.26013100135177947, 0.2611299287383113, 0.2602151077428243, 0.2601390127550478, 0.2601565935178901, 0.206555049961467, 0.20633347741920616, 0.19630194222109631, 0.2202586536992851, 0.21569610583535892, 0.20840014610415214, 0.2008216602190872, 0.214271704756406, 0.19432709959289818, 0.1834695199819284, 0.1838459745518649, 0.1837015866525863, 0.5624993400061448, 0.5601389563699546, 0.6137200816699856, 0.30910253129904675, 0.5070558315216485, 0.6722832461897978, 0.18983961502751256, 0.32711396925663305, 0.40239961587736206, 0.3430437078980024, 0.23796400419930175, 0.2826026199812708, 0.2883609476561876, 0.34387708055900335, 0.45033118486132995, 0.1803450516712597, 0.1894902009130467, 0.18583794325476732, 0.19096851385812919, 0.1896544696008705, 0.18690305695621878, 0.19580743005880208, 0.19881255664791142, 0.1864602953651091, 0.08302965873309609, 0.0730168697882817, 0.0911287444864809, 0.07160858064455311, 0.08716452237472039, 0.07366265692587182, 0.08280905806724748, 0.07762371535256984, 0.07370474936228422]}, "mutation_prompt": null}
{"id": "e7a7bac9-5422-41f8-ab77-b67480b39001", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for better search space coverage\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)  # Adjusted CR range for enhanced crossover\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)  # Expanded F range for increased explorative potential\n        self.local_intensification = 0.45  # Increased local search probability\n        self.dynamic_scale = 0.35  # Increased dynamic scale for diversity\n        self.chaos_coefficient = 0.9  # Enhanced chaos for greater exploration\n        self.learning_rate = 0.25  # Adjusted adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with chaotic dynamics and adaptive memory for diversified search and convergence acceleration.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.9021133573931382, 0.8975468481783885, 0.9021361384439011, 0.9067060164712143, 0.9085431744431548, 0.909520461981997, 0.8959220056225489, 0.903316039245486, 0.9032865893700945, 0.8144288870721867, 0.802685509829284, 0.8042409817241492, 0.8027025286620362, 0.8092983909907241, 0.7968907496616967, 0.8070906774705641, 0.8063846103924521, 0.8101300790135553, 0.4432698829122097, 0.5507211470278504, 0.617728350761525, 0.41310093371067447, 0.5697572188669393, 0.6098484464824864, 0.6153252237910498, 0.5778994281417891, 0.571389829980943, 0.39438398497272475, 0.4256531825676969, 0.15116100246983366, 0.14826992303459008, 0.42961164060371415, 0.13949997580410778, 0.3366002569152984, 0.14232365601027264, 0.1945858312444123, 0.9656464963070306, 0.9616789725327864, 0.978719868500024, 0.965020844250274, 0.9748213127597312, 0.9807769138522578, 0.9854495476596292, 0.9683695209185426, 0.9787988209102115, 0.6652047745380707, 0.5954232275018156, 0.6405684645642125, 0.6425554272226848, 0.6165650939533147, 0.6641081600205736, 0.6045630068194734, 0.5883789269100292, 0.5624640774104561, 0.852966854987266, 0.8250208323905406, 0.779680832511672, 0.7006171169548856, 0.8149395764357189, 0.8566362432256156, 0.8107953701017723, 0.8196921205244158, 0.2390234154456904, 0.32350759341335744, 0.34941399252820515, 0.24831069306496834, 0.12082816783448047, 0.5941173987679019, 0.1332063211528728, 0.33230419022838287, 0.28164566771838906, 0.40697241343356605, 0.30945252011156876, 0.3329430082265955, 0.13164407839949077, 0.4779723353476243, 0.5801558440150398, 0.4282539218307554, 0.3829418300022662, 0.4846288984634922, 0.3159580316954359, 0.12875737894547112, 0.1971015891035096, 0.13929947708687906, 0.22048603100923014, 0.22161969547955318, 0.17603812138339814, 0.22170487275476658, 0.15936372912647345, 0.18944629585568296, 0.26880970164580975, 0.3477983791638798, 0.35728589120584386, 0.33598935918340345, 0.3253006172802839, 0.29832442015984784, 0.41375624374744224, 0.41789063317955966, 0.37000177086082764, 0.055231181890290415, 0.05982708159206718, 0.10986905166095218, 0.09943774634674174, 0.1913687523455858, 0.1906556120405718, 0.20224595465397743, 0.11334530312385072, 0.20869888970542283, 0.23910276388062657, 0.26923585617778334, 0.2714340312637634, 0.31183427170565914, 0.3245539157754559, 0.3079191100570312, 0.3063994397313523, 0.24989172085182476, 0.2787854533824322, 0.7238504745873442, 0.6910667349089095, 0.7281943407216445, 0.7328423395496175, 0.7152174159979607, 0.6783824558996072, 0.6943726916489716, 0.7069960511571479, 0.7162993930165502, 0.1396763372537433, 0.12417948527925693, 0.12070940814191233, 0.37885349093588827, 0.12481204481334918, 0.11530278837169061, 0.13626191487607398, 0.13357081853555464, 0.11865386013795032, 0.17466818634381798, 0.18542138906978656, 0.14860701427913792, 0.15532325655012813, 0.22290099101008554, 0.18606798450225093, 0.15863419766160114, 0.1365675454691826, 0.18229548406959517, 0.5653414479361561, 0.6560877078161711, 0.6753373944251113, 0.5449585889344108, 0.5151481349733835, 0.6033684131633437, 0.6648366301799018, 0.6444834775614469, 0.5702284098929676, 0.3280977480179147, 0.22360268811269712, 0.30027116065392, 0.3646555152449318, 0.3666822597401509, 0.35880192585737425, 0.40110497646965604, 0.365996854810711, 0.21340596369377285, 0.21751907001638904, 0.2201139848571585, 0.19532071467318035, 0.20457807067580502, 0.26344317472333345, 0.20973595497009945, 0.23879804374405478, 0.22448793313083348, 0.1946295637081169, 0.6473386711890985, 0.23169622409080126, 0.22743326894473703, 0.21317986655744248, 0.21308236195752717, 0.6366429618958241, 0.6166444018737764, 0.24550425466160963, 0.23985893282941184, 0.8344983958047756, 0.17343159816884202, 0.18247207281311628, 0.8882313151493724, 0.1624344943148044, 0.9120405604608486, 0.8109454425407837, 0.14194813317104293, 0.8679067199609234, 0.49676957535298016, 0.8478318240631574, 0.21120930255942483, 0.16724636647281477, 0.167597477538585, 0.8622148893326235, 0.15578847951005625, 0.8283201754040345, 0.8446956718894216, 0.1929985780293152, 0.18519903812415173, 0.18212199571158116, 0.18170561309937017, 0.1882838048215807, 0.1852221920581364, 0.17779181529900512, 0.19263165911451074, 0.1738214748703638, 0.08356437573636855, 0.09881645983962262, 0.08746836721507878, 0.09316320706969039, 0.0862494087340474, 0.09190108806483421, 0.09690176516737814, 0.08813923820635605, 0.0814379463306254]}, "mutation_prompt": null}
{"id": "aef5a00d-e393-4ee0-b6de-40ca57302848", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # Adjusted population size for balanced exploration\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.3, 0.9, self.pop_size)  # Adjusted CR range for balanced exploration-exploitation\n        self.F = np.random.uniform(0.5, 0.8, self.pop_size)  # Adjusted F range for fine-tuned exploration\n        self.local_intensification = 0.5  # Slightly increased local search probability\n        self.dynamic_scale = 0.4  # Increased dynamic scale for diversity\n        self.chaos_coefficient = 0.95  # Enhanced chaos for greater exploration\n        self.learning_rate = 0.2  # Slightly decreased adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.65 * self.memory + 0.35 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with chaotic dynamics, adaptive memory, and mutation strategies for improved diversity and convergence.", "configspace": "", "generation": 91, "fitness": 0.42697570258000067, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.9073982779124934, 0.9107271094135743, 0.9100272077615896, 0.9107494985758959, 0.9096974907555583, 0.9120940109508247, 0.9122501755109746, 0.9098073566060995, 0.9107729288986673, 0.8134336324233848, 0.8296223151940625, 0.8270627075176081, 0.8105525758788003, 0.8323225209930226, 0.8205678033757838, 0.8038824287299583, 0.8344850183470226, 0.8267814253051151, 0.6189267096263485, 0.5853385989073985, 0.63629327025382, 0.6608560347718131, 0.17553675636241917, 0.17381264946248953, 0.6867063800148021, 0.17974301716025798, 0.6204056958235047, 0.1519429122567777, 0.15849050604018122, 0.17650006874739232, 0.5878099706641424, 0.17396751715268133, 0.17295518654752506, 0.12246762908991582, 0.12645738356369873, 0.1801078903418828, 0.962802910326715, 0.968215773913836, 0.971687314737653, 0.9874044106648315, 0.9620478479905824, 0.9722731821451356, 0.9653888163750264, 0.9686338673827173, 0.9724731440338835, 0.7386969623078652, 0.6829239322712511, 0.705088202368779, 0.7131592899483732, 0.7130683363051704, 0.7012643016706325, 0.6725429337633456, 0.6148257398833409, 0.6927942601385245, 0.8556582424154517, 0.22751390021208628, 0.2277311686370066, 0.2758190118676431, 0.9000437330699673, 0.8841158717415933, 0.8667230528640294, 0.23414521745789052, 0.8170231878981247, 0.13251785688578344, 0.32033360918877374, 0.6464116331409937, 0.13350305822802688, 0.22619208301646054, 0.725853547293116, 0.38871731443613766, 0.3548012160079844, 0.39891900707369254, 0.3729310256913042, 0.36801484747560476, 0.5525219236945011, 0.13386003382047273, 0.5024283619387205, 0.3817330485723519, 0.414396986087458, 0.2457081255192961, 0.38998002610576277, 0.2816682412706436, 0.14534341444421428, 0.14570741872259607, 0.3462844161353047, 0.21282197351073917, 0.19313039111569674, 0.24468951412038198, 0.2902334648735313, 0.17950256757400496, 0.4157362435261862, 0.4324256130980342, 0.44532053636019375, 0.4404647770552541, 0.36394113568152686, 0.388892545456486, 0.3351131488785877, 0.4410982927182926, 0.46781629215001197, 0.10214547816906905, 0.23898215848495863, 0.2143030424349689, 0.21575476290522122, 0.1277507556011679, 0.16979257388356472, 0.08639010949482251, 0.24592267778271804, 0.10586444222771296, 0.33323911628492175, 0.2782787057204058, 0.3366329988633222, 0.4071455914898757, 0.36597748453787116, 0.34140741982746026, 0.194451612450789, 0.32395553470632477, 0.3428550908462036, 0.7423226423543201, 0.7450409798374809, 0.7912339849763881, 0.7312305104908341, 0.7549522639725386, 0.7257688622626369, 0.7256061110993561, 0.7485231600170447, 0.7389665701857089, 0.1357538151901614, 0.1424663553094373, 0.23256639007016844, 0.1291468666300991, 0.11579835594183474, 0.12224768049040502, 0.13646028577160818, 0.13815086828755097, 0.15055278140639494, 0.1863912374629777, 0.21529864416169653, 0.1401548435272103, 0.1509880783181743, 0.14054104984082516, 0.24545655708109615, 0.1467564871692273, 0.16966159767275024, 0.16468849032220856, 0.5306249473718156, 0.6460355688283561, 0.5876533720845629, 0.5299361892944598, 0.6131661053633923, 0.6383354428509211, 0.6925886779324095, 0.7270257027742139, 0.7011090971303086, 0.33672317966778953, 0.45997534734783085, 0.44276681655898664, 0.4417607341271339, 0.3820297243206172, 0.46021769355874986, 0.37234764432010325, 0.3099125263765977, 0.271975472744575, 0.21964036634576334, 0.23132948083330562, 0.2286200438497381, 0.22147854337987505, 0.20702608053756766, 0.20858039617044288, 0.2079175375493898, 0.23209816204830636, 0.2044604057819982, 0.24715823175967844, 0.2000820233401478, 0.22042847296592083, 0.24337943879176216, 0.20628946961838568, 0.2463164177741256, 0.6892506240930654, 0.6566221109845316, 0.20969777293315028, 0.1725955239149689, 0.1703622605764804, 0.9000242464703432, 0.8172219239489732, 0.16833160769420352, 0.8159525165687812, 0.16849917782628676, 0.814049230646165, 0.8350275276289983, 0.2089921780777655, 0.16918599149233615, 0.21150579421207272, 0.21054049773650774, 0.16779195075897513, 0.20759272614270363, 0.16694775684031615, 0.15674926353966545, 0.7722498335412717, 0.17893894804579302, 0.1872226832084617, 0.18857942979676623, 0.1794557353372659, 0.21085191412859672, 0.19629566500259754, 0.18118402483847584, 0.17875713943002047, 0.1861556233191115, 0.10295609222224944, 0.09109959084201891, 0.09880539481098116, 0.09245707456868224, 0.08600866033750953, 0.14458383594158963, 0.09024589948275208, 0.09794808330782345, 0.08582014387408565]}, "mutation_prompt": null}
{"id": "88944f87-f9bd-494d-9daa-7a99a3f7a50d", "solution": "import numpy as np\n\nclass StochasticAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 9 * dim  # Slightly reduced population size for faster convergence\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)  # Broadened CR range for crossover exploration\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for enhanced adaptive potential\n        self.local_intensification = 0.5  # Fine-tuned local search probability\n        self.dynamic_scale = 0.4  # Strengthened dynamic scale for exploration\n        self.chaos_coefficient = 0.85  # Slightly reduced chaos for stability\n        self.learning_rate = 0.2  # Refined adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with stochastic adaptation\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Memory Enhancement\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (chaos_value + 0.5) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticAdaptiveDE", "description": "Novel DE variant with stochastic step-size adaptation and memory-assisted chaotic exploration.", "configspace": "", "generation": 92, "fitness": 0.42918580486519686, "feedback": "The algorithm StochasticAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.9062125120434756, 0.8950062306531289, 0.9015196487955086, 0.8981164405707579, 0.89722376632226, 0.8915329122589178, 0.900603584599749, 0.8971717682507859, 0.8940647678002399, 0.8105836063905759, 0.8084656456083553, 0.812154344664078, 0.8104798652412842, 0.8036093468239699, 0.8103981397129854, 0.815954471236751, 0.7961861388189397, 0.803873864648238, 0.5682927664250806, 0.5735894759150786, 0.7010846033913546, 0.5010862807811713, 0.4998891519759684, 0.1757726262813336, 0.6006882679232088, 0.5435547662380862, 0.6360855964764652, 0.4728962501091146, 0.5864219090865214, 0.16679010842034825, 0.1745318949861857, 0.5434598051605608, 0.16971846914590494, 0.17487374784042664, 0.17204317470037767, 0.41697941946736616, 0.9656331983809201, 0.9697153774090168, 0.972158168300028, 0.9551195286451426, 0.9730902214073486, 0.9861794945977077, 0.9756568850719082, 0.9755174227689934, 0.9743414581501758, 0.6605004359205273, 0.6631986895355024, 0.673936174327823, 0.693174102442613, 0.6713773600640012, 0.6649019149402081, 0.6492854313606753, 0.6885943276457995, 0.6520568730825418, 0.8607424495711099, 0.8029324444277627, 0.8029501770957438, 0.28064432672771156, 0.813567779992134, 0.8688166438214404, 0.8765354517736063, 0.8232192872939059, 0.8285608018261914, 0.31089843177169485, 0.3494126810149122, 0.3814542049118832, 0.1307560701518078, 0.2988646082456151, 0.3716366383424362, 0.42992260720685005, 0.29704778166806545, 0.659519794140437, 0.20213941983527128, 0.3215283415669644, 0.3697343964153412, 0.47179724307617243, 0.32773495898764826, 0.37354478350168585, 0.28777473212632454, 0.39991805267516023, 0.2777893406664784, 0.20575685249993714, 0.15224926998488442, 0.17097336848840627, 0.22411158343039483, 0.23855759652012443, 0.17744902522849604, 0.25859191600721, 0.23043311000488353, 0.2675860128053168, 0.4390030961214274, 0.3412676107522584, 0.42615424402690294, 0.3339175096155622, 0.3517982004832988, 0.41127885345417614, 0.4440792524162329, 0.45852457382417455, 0.4116828975471962, 0.09540414770887018, 0.052214883306102466, 0.051848811180502, 0.0999851059529896, 0.16090797864569228, 0.10609988960184347, 0.09124362538401853, 0.11450857622275801, 0.10880931901670943, 0.289867543715585, 0.2588040965176317, 0.2884525179547792, 0.2891006942598152, 0.34021293356292803, 0.33960249385472197, 0.29924666504127484, 0.2823516614555197, 0.21755750552291708, 0.7047511134435619, 0.7189409505481221, 0.7311352499937023, 0.7261285577493406, 0.7234433208237987, 0.737653122391388, 0.712766612586536, 0.7333078849796753, 0.7362775663322682, 0.1476252758563873, 0.13778095341014085, 0.21643291909839235, 0.11596149451318138, 0.09428231569267631, 0.13436719245682505, 0.14277047486506866, 0.1275715757212178, 0.11761533667924029, 0.18044050301582282, 0.16516050876163157, 0.13829470435319857, 0.16880812306231752, 0.16840718206853433, 0.15602482491205594, 0.1481462428109468, 0.18923648640097213, 0.15479765854337713, 0.5373227452269749, 0.5607890543168044, 0.5676579431963038, 0.5593778529862067, 0.6131913089246606, 0.5504488624722612, 0.6506395193469128, 0.6166900563002868, 0.6353233191754946, 0.37967117219702073, 0.3773764825003141, 0.26323686194437645, 0.28121177950181464, 0.44525627398117507, 0.3773400651625449, 0.3291560962218637, 0.4367987177143209, 0.24475582631835668, 0.22070686356263303, 0.21475910120945096, 0.25347530083986136, 0.21421696195697737, 0.19572010412086238, 0.254036835566092, 0.2009334003319535, 0.2040008958541769, 0.22990382773422202, 0.21434512519034388, 0.2213944807134055, 0.21419397047582345, 0.6950023725788832, 0.24162823185377003, 0.6042457942383568, 0.22261645704631272, 0.2346207036952781, 0.2343516475517593, 0.18740533958336414, 0.18774047962624285, 0.19645883465290415, 0.8595855937649337, 0.1863104708328034, 0.8885474634810193, 0.8650402561523887, 0.13719800102474944, 0.8380667392459777, 0.8286321030010676, 0.1684766277571249, 0.7472040229851147, 0.167685449101857, 0.16324416593921376, 0.16749114463727877, 0.7398267452179919, 0.15538054463629192, 0.11286976720435526, 0.18647181912499045, 0.18690825523836552, 0.19170183142597153, 0.1758855590434587, 0.18064273912697915, 0.18884276094782304, 0.1875283971616163, 0.18514598338678678, 0.20335764038242254, 0.11623641093665205, 0.09070167591016964, 0.12351913589400298, 0.08800929018591364, 0.08337029875361512, 0.087234028541461, 0.08933161466658679, 0.08755903126343056, 0.08557016320397448]}, "mutation_prompt": null}
{"id": "cf0363a6-03a6-475e-bff0-d9719ec9c039", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 12 * dim  # Slightly increased population for better diversity\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 0.9, self.pop_size)  # Adjusted CR for more controlled crossover\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for balance of exploration and exploitation\n        self.local_intensification = 0.5  # Enhanced local search probability\n        self.dynamic_scale = 0.3  # Balanced dynamic scale for diversity\n        self.chaos_coefficient = 0.85  # Slightly reduced chaos for solution robustness\n        self.learning_rate = 0.3  # Increased adaptation rate\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.random.choice(np.argsort(self.fitness)[:3])]  # Top 3 selection\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Adjusted memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedAdaptiveDE", "description": "Adaptive DE with stochastic ranking and chaotic search to enhance convergence and solution robustness.", "configspace": "", "generation": 93, "fitness": 0.37973071787057394, "feedback": "The algorithm ImprovedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.8758553253935414, 0.8691443014791724, 0.8637153926373525, 0.8679987098442967, 0.8767056139271137, 0.8645196679948685, 0.8675872613435429, 0.8825068521175319, 0.8779746537277044, 0.7379042386975587, 0.740985577664059, 0.7242640239415751, 0.7417682991548812, 0.7450445802668482, 0.7444807040210701, 0.7397752896793697, 0.7420160063463344, 0.7405953790479466, 0.16555881566547637, 0.5334890677672621, 0.3894623645670482, 0.35326009491113763, 0.5146648423782244, 0.2847972053160347, 0.42407794745717053, 0.48398183048933796, 0.3640378578889393, 0.16182080651683095, 0.14867057572190534, 0.15667616085913283, 0.2163300565374463, 0.15709460208543347, 0.1552043731334437, 0.26180093771018154, 0.1437411899539346, 0.18815555831209818, 0.9537185901820465, 0.9394978335446598, 0.9440710100951524, 0.9534598388653435, 0.9381606773919179, 0.9598263812209773, 0.9579941116709614, 0.9564331542856502, 0.9673072197761445, 0.5667124428708057, 0.5844158826141218, 0.5420608192100922, 0.6093276362344844, 0.5847911868433542, 0.556221564203204, 0.5054101002112684, 0.5091890445015885, 0.5042398531983991, 0.7711101118541284, 0.8315874130256368, 0.7187696857359529, 0.8399403658911362, 0.7781996227994652, 0.753896628118653, 0.8174962446977412, 0.83176682198983, 0.8044691713075596, 0.25182447851708, 0.20405861909152734, 0.20543839231967498, 0.22289092387570997, 0.21708527680673229, 0.20316827909407398, 0.12918926276506937, 0.24904059956472613, 0.21598691407912451, 0.20433834395661665, 0.24017187852786226, 0.21743025586693288, 0.18647438292111107, 0.2238409412502771, 0.23763503099901628, 0.2523006219449805, 0.25960934326970986, 0.19756139735579714, 0.13969901133785811, 0.158520519217495, 0.1231914905647924, 0.16981598237667972, 0.15187374958043343, 0.1533094571042357, 0.1660402656377682, 0.15602747592764465, 0.13084806470260757, 0.2593596478157567, 0.252653790549885, 0.2750715929580009, 0.2826739470661226, 0.2323958166655926, 0.2769782874792722, 0.3005794253473376, 0.3071089403031876, 0.28083593974503396, 0.06993191741013327, 0.17055771221441318, 0.27284269764510194, 0.11812005584115637, 0.06748242949705618, 0.14820726011625118, 0.06926021663923299, 0.07963744070952694, 0.21772925846068414, 0.2442024918044885, 0.25980232084747634, 0.2291616458398955, 0.2762866981788167, 0.271750326972241, 0.2773492587155626, 0.21072121429259905, 0.18670620821585648, 0.24313160021697455, 0.6354740794701925, 0.6314178174648569, 0.6455044116265425, 0.6246184330177961, 0.6505321642975941, 0.6258195400228843, 0.6526426887941741, 0.6405735066336451, 0.6543238530168352, 0.11439971293422935, 0.1171865119281238, 0.0996173890002825, 0.10538548784932555, 0.136208578044694, 0.1145577900746112, 0.11338957788424464, 0.12712308897056623, 0.12587562733441082, 0.14330549359621492, 0.15684478106240862, 0.16117467989941614, 0.16747569911952087, 0.13159670059101902, 0.18484505262176565, 0.1482099614480905, 0.17202427519411267, 0.15027909350309276, 0.5071963799733368, 0.4895567549942407, 0.49791089125977883, 0.4929144383652434, 0.510674630915928, 0.4877308743510108, 0.5615293926881686, 0.5455482225613438, 0.546184922905123, 0.3305706907687953, 0.34624010560822427, 0.3399543915713613, 0.3222136249843598, 0.3555845246706989, 0.3770306646299175, 0.42457455919816356, 0.3360328942596792, 0.40596785296776183, 0.22372062009429716, 0.23245031326492138, 0.20385917979288537, 0.20554433231960545, 0.22080027392625357, 0.21261198525277092, 0.20893148959859353, 0.23881888163746712, 0.24570759238143325, 0.21441261302729586, 0.45185223068802705, 0.3502473342116501, 0.21116031330475415, 0.3419398201796118, 0.2257115894932319, 0.3765375490084585, 0.49640692597214897, 0.2388126358978323, 0.1823709753354792, 0.6682092689055267, 0.18635561906538045, 0.7840548132516516, 0.19421900709368423, 0.19567712300751694, 0.6878499832481058, 0.1453888431498448, 0.5097497975596668, 0.20800247627504465, 0.7307462190419809, 0.789732717771852, 0.7241015342386792, 0.20952969780741282, 0.20932523668794434, 0.2119887387509185, 0.15582434567797376, 0.2104712469874207, 0.18700482152367248, 0.1879381239550656, 0.18678000096668224, 0.17896126783488886, 0.2004491301984611, 0.1983404744003564, 0.18636813846006484, 0.17292643532288454, 0.18918771048448246, 0.09784165436230174, 0.09047267518546054, 0.12023910163178264, 0.08634517389533325, 0.10330985062933395, 0.09104761142769968, 0.08636661809676627, 0.12018514840941752, 0.09347731017893879]}, "mutation_prompt": null}
{"id": "15bb2f67-0363-4d58-9566-916c1fea5b13", "solution": "import numpy as np\n\nclass AdvancedDynamicDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # Adjusted population size for balanced diversification\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.6, 1.0, self.pop_size)  # Refined CR range\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Refined F range for better exploration\n        self.local_intensification = 0.5  # Fine-tuned local search probability\n        self.dynamic_scale = 0.4  # Fine-tuned dynamic scale for diversity\n        self.chaos_coefficient = 0.85  # Adjusted chaos for exploration control\n        self.learning_rate = 0.3  # Refined adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return np.sin(np.pi * x)  # Changed chaotic map for diverse behavior\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = np.random.uniform(0.8, 1.2)  # Modified dynamic factor\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.6 * self.memory + 0.4 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdvancedDynamicDE", "description": "Advanced Dynamic DE with adaptive chaos and self-tuning parameters for balanced exploration-exploitation.", "configspace": "", "generation": 94, "fitness": 0.3767743355143477, "feedback": "The algorithm AdvancedDynamicDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.8524131280574345, 0.8640327454586264, 0.871331637964534, 0.8613217579160473, 0.8641868747520421, 0.8686708456086456, 0.8594638100353842, 0.8722555138619298, 0.8636109111377348, 0.749285524256639, 0.7653814435004747, 0.7467721466452629, 0.7387630474697868, 0.7462140339640377, 0.7532077159230937, 0.7567425933373072, 0.7700312280369608, 0.7599753437398994, 0.4765609139786863, 0.4928172943454677, 0.35841494811578434, 0.3187575632054316, 0.502212625095988, 0.47479946964871034, 0.46653207157262255, 0.40700806582440274, 0.4904872376472931, 0.12395095006474544, 0.1647705535012408, 0.36345236280191007, 0.2730862329791014, 0.1468753285566181, 0.28933368859154296, 0.4125713324890694, 0.350865304111449, 0.324195573604406, 0.9592034288487897, 0.979267383590459, 0.9629675662978228, 0.9500114574833532, 0.9849468938828233, 0.9582437677941046, 0.9548949348669004, 0.9530827296289897, 0.9587992360657285, 0.5911625873775188, 0.6097919139419286, 0.5437870420448057, 0.6049134854449606, 0.575060974320253, 0.5512727411432949, 0.528309181508819, 0.5285607769331113, 0.5453037054454425, 0.5988677399255676, 0.7505856827284955, 0.7114131567232633, 0.7433093072001491, 0.6958419772203793, 0.7940713383205866, 0.6876366558191725, 0.7854716021346924, 0.717063048027097, 0.2832741238890403, 0.21038641070516317, 0.259255542385071, 0.2278299941935742, 0.21780818349049846, 0.18719560268471924, 0.22072271398621812, 0.20871516233590937, 0.21697184592610486, 0.17221011992769686, 0.20856303421379507, 0.213179138984659, 0.18568053222075942, 0.16336263897281955, 0.1691023830311107, 0.2648836140910895, 0.18782231799081073, 0.24830527132315072, 0.07319323445066561, 0.14987157135060092, 0.08480293986655763, 0.1110993382043669, 0.18018523757425142, 0.06260980847987563, 0.16225338510577691, 0.13058878482941505, 0.10491674458964373, 0.21299597241218926, 0.28165162922658415, 0.20151937160101818, 0.22120039203256425, 0.2514724748116489, 0.24913093001424091, 0.2722359862576039, 0.31726884880038264, 0.33124074478451726, 0.04258332963983136, 0.09770565990221125, 0.11439349745475047, 0.08345348966677735, 0.07992341961470029, 0.11921911710011668, 0.09455480562033558, 0.13856257201349143, 0.1506565345441231, 0.20924418415751023, 0.21941156787636673, 0.2659405004495524, 0.25215654102378593, 0.2667597809600737, 0.24985236003172195, 0.19691461910308394, 0.22058552452627278, 0.21241310191534035, 0.6207448060721664, 0.6120509043025392, 0.6210931590809229, 0.6135078381026977, 0.6689719149572582, 0.6174976083414945, 0.6398101660330184, 0.6315829136868857, 0.6219979501558868, 0.10238414642822058, 0.11843335344242911, 0.14374730728510732, 0.11235256620113288, 0.13374400828613675, 0.13187023760171357, 0.08187009383050337, 0.11294735350701579, 0.10557462479169466, 0.13064856876429165, 0.16381795181570724, 0.13900054778376758, 0.1473462988530646, 0.21344980853981577, 0.14635677563022564, 0.16562824556106592, 0.14229368389515018, 0.17360585522971328, 0.44567019260610274, 0.44344432479035834, 0.43721278138410646, 0.44055071486819364, 0.43293688438371714, 0.41871267659083555, 0.5290485786550614, 0.5351726976340716, 0.5050096631598759, 0.25287974944165315, 0.2753638800344417, 0.30620694041702057, 0.2901001110770124, 0.28468453949944306, 0.286082827894945, 0.33534210743150905, 0.38508349303105005, 0.34710404727899224, 0.21110577975360523, 0.20508961915085666, 0.1967206386390209, 0.22086007162822474, 0.21969388495806497, 0.19805634640404068, 0.18869955109111503, 0.20016700490878825, 0.20880130499374583, 0.597083998710747, 0.4811071657566265, 0.20942959098105363, 0.23287597354157186, 0.5465086337072641, 0.46644312480772265, 0.28224697573412805, 0.5484345534079016, 0.21675299120331837, 0.1813106601664053, 0.1760819168138581, 0.7468386246316958, 0.7944642568996868, 0.16358447780653806, 0.6927571310303732, 0.4260311998691012, 0.7979434688777631, 0.17470945410630356, 0.38828792144486557, 0.2000108668076307, 0.20045511620494194, 0.16553261011765008, 0.26236502318863963, 0.20451563381893623, 0.20695922284584545, 0.45197236502912996, 0.6704397431263436, 0.18738050148357122, 0.19577618631895777, 0.17827867968686129, 0.1965972826734973, 0.16951184356851734, 0.20801313851260383, 0.2050119281285836, 0.18685367737092062, 0.1909498787247127, 0.0799623502704675, 0.09107554082767733, 0.08979924934937822, 0.08213929353528115, 0.08961945512837466, 0.09676223546377982, 0.07546782938823549, 0.08711520930281635, 0.09364162798039455]}, "mutation_prompt": null}
{"id": "5a609da5-7271-45c0-b5b5-19e977f4dc46", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.4, 0.9, self.pop_size)  # Adjusted CR range for better balance\n        self.F = np.random.uniform(0.3, 0.8, self.pop_size)  # Adjusted F range for exploration\n        self.local_intensification = 0.45\n        self.dynamic_scale = 0.3  # Adjusted dynamic scale for controlled diversity\n        self.chaos_coefficient = 0.85  # Adjusted chaos for exploration-exploitation balance\n        self.learning_rate = 0.2  # Adjusted adaptation speed\n        self.memory = np.zeros(self.dim)\n        self.opposition_rate = 0.5  # Introduced opposition-based learning rate\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def opposition_based_learning(self, individual):\n        return self.bounds[0] + self.bounds[1] - individual\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.5 + chaos_value) * mutant + (0.5 - chaos_value) * (local_best + self.memory)\n\n                if np.random.rand() < self.opposition_rate:\n                    mutant = self.opposition_based_learning(mutant)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with probabilistic chaos control and dynamic opposition-based learning for robust exploration and exploitation.", "configspace": "", "generation": 95, "fitness": 0.3100630326603923, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.788153002887112, 0.7744371472829632, 0.7802951026328452, 0.7714433633939898, 0.7818168515062414, 0.7609613361739982, 0.7821231275451377, 0.780367588203023, 0.7659031677271384, 0.5909448829557064, 0.5684869321499161, 0.5581984581107564, 0.5840843689162414, 0.6099254673910843, 0.6060889024162497, 0.563370560699539, 0.5405280711171927, 0.5588413980274612, 0.1578984347792075, 0.1305381989294888, 0.14291945836972209, 0.19643841832402908, 0.18398481175133263, 0.17930245239773435, 0.25859490433844434, 0.18135127542646878, 0.2527694780267422, 0.14000759401805007, 0.12215609077299139, 0.11828355929774792, 0.13896178692757344, 0.1285890815210018, 0.12765953199307623, 0.1500844659742414, 0.12365778132639949, 0.14829653275243493, 0.960282082489001, 0.9566056320552224, 0.9436341049217104, 0.9158314191757421, 0.9291491876273348, 0.9216367969628061, 0.9436196347772544, 0.944617889339641, 0.9335056619491964, 0.3132181730771134, 0.3433639233356154, 0.3431413067889245, 0.35533820233055957, 0.3396359955419622, 0.3827893581150844, 0.34638428493200557, 0.34412756854842985, 0.3572204359528699, 0.6290019616059415, 0.6499857009841217, 0.5195159050319286, 0.26473079959099977, 0.5156313980098914, 0.24321602408240128, 0.7112446753800596, 0.6615301801722281, 0.6257344240227796, 0.1855201157014409, 0.25271188899679764, 0.1872871779977089, 0.16401327020569478, 0.17192510177094134, 0.23081900858318471, 0.1724954627949008, 0.1563854615042486, 0.16773551938463205, 0.2990565087988829, 0.19488784622935618, 0.24874341261703692, 0.24063452674787367, 0.2681112523389705, 0.22638091268330995, 0.25758231340132465, 0.2573758192917167, 0.22450222722420043, 0.048831257356818036, 0.038128618709751594, 0.07296962822747632, 0.07691843569945289, 0.06190579342350644, 0.04849423156497146, 0.06128863503987925, 0.08623166462297782, 0.051414266824573174, 0.18915475185736885, 0.17266282060267024, 0.21711083846212442, 0.1789828791798409, 0.16501443746084188, 0.17947354541906457, 0.22641866760748586, 0.19703123297746084, 0.21086195359748394, 0.02329201248056756, 0.043706980999232314, 0.08653289025744193, 0.08398787733641688, 0.08109692519119582, 0.07921076510145286, 0.05364547828230004, 0.07888438270443443, 0.05254196567212166, 0.14285966829803398, 0.1779969671292081, 0.18279266245768333, 0.212737022087497, 0.19285613981362604, 0.2086493608484684, 0.14870249720526885, 0.15025653497284652, 0.14725874313034548, 0.5081678284271587, 0.5677012171563418, 0.5332384657146119, 0.5148920062968992, 0.5290831223017263, 0.5362930514698432, 0.5428489313911926, 0.5751261207743464, 0.5434659691053505, 0.09455046070187767, 0.09952443078781747, 0.0980857078663363, 0.1160297729672004, 0.08678671341618482, 0.10252763424082134, 0.10006917411603733, 0.10601339757471684, 0.09697918631209812, 0.15650873322554948, 0.12634089467006704, 0.1314335192740882, 0.15033624151167313, 0.15500797263698374, 0.1394695448709965, 0.1448990047003763, 0.13293334138355983, 0.15548251086945053, 0.39466682221573723, 0.3288111865251069, 0.3431260974882677, 0.38079896845346306, 0.3445467224652188, 0.32924583756472126, 0.33238269916676855, 0.41527295592424496, 0.3489620480933491, 0.2507396688885615, 0.2425302997428087, 0.26086927264734505, 0.28541926008123975, 0.2863543802203049, 0.2594436320131154, 0.1976809605316252, 0.2698351599189246, 0.2796612194613255, 0.24043160214396597, 0.24654738847891133, 0.22604010262613372, 0.2074422851529324, 0.20240256921404465, 0.20008496606798787, 0.21339912350889667, 0.2019489314295918, 0.21778281360746055, 0.21268597895917363, 0.1969105037935608, 0.20807642450193786, 0.22809006455883296, 0.1957989304159069, 0.19737374742619918, 0.23010225024517095, 0.20613879268240476, 0.20200604222631702, 0.18261779581337834, 0.18130419321863633, 0.18478339573788105, 0.7130366695211834, 0.5808988481205055, 0.6824490711484914, 0.5849427288763551, 0.6016364021983343, 0.6362292628646795, 0.5822482278817371, 0.28857216290428245, 0.5277113264694828, 0.39199338746582757, 0.26281548055788917, 0.43588832608425543, 0.39431377665737055, 0.5621741235143192, 0.48691908320645305, 0.20979724806147793, 0.19805916975314242, 0.1791013650635308, 0.1900643788044124, 0.1975942385942383, 0.17610456238914463, 0.18050681790550538, 0.18437757917188713, 0.18093537018323302, 0.09178612404622777, 0.08469104666675831, 0.10355164910033632, 0.07933211461441192, 0.09818682101760456, 0.08193989240334543, 0.08717631957553185, 0.08135065999667113, 0.08289410111313922]}, "mutation_prompt": null}
{"id": "940ab5e7-4403-4075-aa1a-392c09f53d33", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45\n        self.dynamic_scale = 0.35\n        self.chaos_coefficient = 0.9\n        self.learning_rate = 0.25\n        self.memory = np.zeros(self.dim)\n        self.entangled_states = np.random.rand(self.pop_size, dim) * 0.1\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_mutation(self, individual):\n        return individual + np.random.normal(0, 0.1, self.dim) * self.entangled_states[np.random.randint(self.pop_size)]\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n                mutant = self.quantum_mutation(mutant)\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                    self.entangled_states[i] = 0.5 * self.entangled_states[i] + 0.5 * np.random.rand(self.dim)\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive DE employing quantum-inspired mutation and entanglement for improved exploration and global convergence.", "configspace": "", "generation": 96, "fitness": 0.30636138285238274, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.6240766056425597, 0.6084970161025192, 0.6301473031458107, 0.6141417253950876, 0.6381330496754676, 0.623938663477054, 0.6355968228543499, 0.6234038146708794, 0.656242558699778, 0.26558097453569485, 0.2672875519922395, 0.2745544930763919, 0.2657594414523109, 0.25792701432425225, 0.2607975350968199, 0.30660210977822777, 0.24753450093521434, 0.2938205793038847, 0.2595684281739865, 0.26281648203762387, 0.2548006355573259, 0.26748924798922336, 0.2409369789197, 0.23206810523491261, 0.23082358765741406, 0.17039994615802612, 0.2496218513644205, 0.12295591387518512, 0.15784523277324092, 0.1465128637197426, 0.16180350573197888, 0.16157650369427534, 0.15829581424577277, 0.15429125501300645, 0.2264085961804062, 0.17661803398802023, 0.9709555552364548, 0.9922520306035141, 0.9653542025991528, 0.9767482070655876, 0.9680000337915401, 0.9726186446596807, 0.9837679777148551, 0.9727259911698357, 0.9659375930493083, 0.367906278661028, 0.3934272825683892, 0.40125670235347066, 0.39637030243586013, 0.39738234475014966, 0.4103531079182723, 0.3953642457661124, 0.3871768012817284, 0.373576221950092, 0.8379292263898859, 0.8535679278727935, 0.8033536851184422, 0.7326079671717218, 0.8165282366780253, 0.7790044273434591, 0.8341275977668527, 0.8505153033566317, 0.6745486383005093, 0.2760412210041735, 0.26389394766848906, 0.2794227628089879, 0.2123810931774569, 0.12452688525677058, 0.132540745722879, 0.22498104934838925, 0.20982212916256293, 0.20418288756205782, 0.23306256191287156, 0.22149464098709915, 0.24353944967745755, 0.24460806899877607, 0.23739021447617237, 0.2342328307091477, 0.23296797725867457, 0.24028615181070045, 0.22175625240630825, 0.05701248058049113, 0.10051652221690843, 0.07018322174206437, 0.04176816772253189, 0.10405574652747795, 0.03714517089227287, 0.037745452486611764, 0.07697214718888568, 0.10365103579471502, 0.16062364088673364, 0.10125810717976691, 0.10993337045314111, 0.08510205937298254, 0.11576941505040117, 0.09730020400691741, 0.09996497201957721, 0.0990319572033248, 0.12664205740867074, 0.021759903983901707, 0.06471460056929157, 0.024983232532273747, 0.046694260841900315, 0.051524211547169796, 0.05863356374526507, 0.07952523639755238, 0.08162787430515184, 0.06924661100455942, 0.12158367622056598, 0.16947925660715757, 0.11625280573618546, 0.1801679930966138, 0.12440653308142524, 0.16322386536826672, 0.1547094091317497, 0.10207305283192925, 0.1566447279985378, 0.5398351722273536, 0.48925445156433733, 0.5152443221742413, 0.5344487562106339, 0.5131492292536719, 0.49378231918543536, 0.5231263393963498, 0.5294762304727055, 0.4869546735093476, 0.11606306953815804, 0.1405032810362955, 0.13363547114298036, 0.1235036484242743, 0.11936500530040461, 0.14237013992769676, 0.1403197684579811, 0.10732386583222064, 0.16075923452222285, 0.19662820451507046, 0.15444679899484381, 0.1590433451147959, 0.21719374971796734, 0.1411328108755593, 0.13464462723315918, 0.22194606848460297, 0.16874028736506952, 0.20625880559540666, 0.35298981396467677, 0.3527795731116248, 0.3549983581305398, 0.3644110386190542, 0.36825297232234766, 0.3755315008999003, 0.37092940537974983, 0.3704973467665238, 0.37267885856278227, 0.30469949657011197, 0.2946396283821002, 0.2500195295428692, 0.28880510564932305, 0.252860730079418, 0.2953801381698624, 0.3036479475704196, 0.2887988697265371, 0.31062620378511063, 0.22019322747689474, 0.19196066580502436, 0.2048561048504186, 0.2018475931703696, 0.2044255505924657, 0.1953894726784312, 0.2129466823007209, 0.22059060564075816, 0.19465268914000267, 0.23655978072372763, 0.2041496572884406, 0.31453424043446154, 0.20560174211023408, 0.24677494965639546, 0.20011209391136675, 0.24025716043112, 0.22156920677308367, 0.240389650746884, 0.9089453606007616, 0.8743581505427713, 0.8313386617380916, 0.17616834559367578, 0.1717482646576156, 0.8881362035176569, 0.1596149983847568, 0.5887183858071807, 0.17572463922230763, 0.6262189601893038, 0.7322972717122422, 0.15106534852581333, 0.20965140320782516, 0.1685334937443218, 0.08195999837153956, 0.21145360068414, 0.15485586913707416, 0.6567337368328847, 0.19259244333974102, 0.18807595201654603, 0.1827151790056354, 0.18814898953866166, 0.1860327716284803, 0.1982487327235699, 0.18503670402159633, 0.17559047567240393, 0.21787304322940992, 0.09941989043260513, 0.08854505152404546, 0.08932042288483921, 0.08421142535757298, 0.08342767506925741, 0.08510080348893567, 0.08659027749466963, 0.09265369143951119, 0.09315651801258062]}, "mutation_prompt": null}
{"id": "d5ea0c30-6571-47d7-8acf-998ab23e7e90", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45\n        self.dynamic_scale = 0.35\n        self.chaos_coefficient = 0.9\n        self.learning_rate = 0.25\n        self.memory = np.zeros(self.dim)\n        self.rewards = np.zeros(self.pop_size)  # Initialize reward system\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n                \n                mutant = np.clip(mutant, *self.bounds)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.rewards[i] += 1  # Reward for successful improvements\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n                \n            # Adjust learning rate based on accumulated rewards\n            self.learning_rate = 0.2 + 0.3 * (np.mean(self.rewards) / (1 + np.std(self.rewards)))\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with reinforcement learning for parameter adaptation and controlled exploration-exploitation balance.", "configspace": "", "generation": 97, "fitness": 0.3082116692877762, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.6358875921793858, 0.7276955995097047, 0.6805508246463592, 0.6553497140463751, 0.7253487866691825, 0.5988996108676358, 0.6594686252374833, 0.651610582599052, 0.7067701214332169, 0.373627628663345, 0.41289886114446306, 0.41872739390908054, 0.3456747674743357, 0.47231584177188757, 0.3595758442285788, 0.34778628734837647, 0.31748019454248655, 0.3734184613958794, 0.21072543613112893, 0.17452046837488033, 0.23800796990783413, 0.22005809736316428, 0.15317161011179814, 0.25585614683636215, 0.17192117216193814, 0.14962658414818597, 0.2583305637533396, 0.13899079047198115, 0.14688578584140433, 0.1556057465234304, 0.15255880277943057, 0.13039374977457208, 0.13684160248903066, 0.15992694139597985, 0.11745804385094527, 0.15729674652894865, 0.9599365276224808, 0.964457524268648, 0.9692774015995741, 0.9796650493084036, 0.9761294654878152, 0.9616943571969945, 0.9853844016730092, 0.9691015908566959, 0.9782905409858069, 0.36619677170955456, 0.39864796688445836, 0.3724280542802402, 0.39509847896285455, 0.33816262204376557, 0.3789045687070114, 0.41492722007730276, 0.34953753758332695, 0.3860187316501158, 0.2254751582098432, 0.6812833040764669, 0.7512684862879673, 0.8346169795491032, 0.23113217960736554, 0.8522038697710472, 0.7953639106171819, 0.7927994891942947, 0.38233358772603265, 0.30526990272592336, 0.15978537511343838, 0.17424378267098217, 0.13955022162634634, 0.15435784303393507, 0.21678856713697914, 0.21025636062786035, 0.14942343016571835, 0.2933131596346966, 0.13031371207376996, 0.219621648748082, 0.1618663100152904, 0.17225816518358228, 0.17969101866861203, 0.19870111538287427, 0.1284536418487613, 0.2234360089594406, 0.2024233419249829, 0.05957141324180215, 0.06459896321094216, 9.999999999998899e-05, 0.03014185750463405, 0.030171474970010603, 0.09870014671012928, 0.13694572493561152, 0.011006090415078496, 0.05112447596540115, 0.22058035709931945, 0.18055438045746164, 0.1465759124923285, 0.16272394973166815, 0.16644984350336545, 0.154233847187766, 0.30058838517307684, 0.27895927272652976, 0.23350136050218429, 0.0780418622571959, 0.04879890959418132, 0.028990492609115237, 0.06494617521169566, 0.0056592022654218255, 0.08465443169125098, 0.08068964519116839, 0.06459624740217929, 9.999999999998899e-05, 0.16483228816845008, 0.13769802532565933, 0.19343656621799188, 0.1278373767808123, 0.14566827616659617, 0.2013275625522417, 0.15190174234530374, 0.18055106990835446, 0.1423835863658538, 0.4911560744602633, 0.5191621728350041, 0.4861812463621483, 0.44791710415068975, 0.39902550599954534, 0.5228304956825621, 0.5354972593941423, 0.5126060087831528, 0.523325615597674, 0.12983922741040388, 0.10363168031154146, 0.14471963448989644, 0.13336591025259803, 0.116614019858859, 0.11456251934013495, 0.12114884688641125, 0.11322916990566534, 0.12901849220858985, 0.17106060500556397, 0.14799267116802495, 0.16224301547560738, 0.17779291745906234, 0.15354921056179505, 0.16847576479585624, 0.15229908252485946, 0.1724753829822694, 0.17789122290001558, 0.34135325934821903, 0.304204115966794, 0.28683005448146337, 0.3654614869604931, 0.3397804883035479, 0.3522137568313186, 0.35420285345332436, 0.3486837506314642, 0.3055071271132904, 0.2896194687787167, 0.25086404422118935, 0.2813967913382832, 0.1986141264562047, 0.29896793257890253, 0.29357793849974845, 0.33270439287789155, 0.21545354185543975, 0.26885495836209006, 0.2007792438364524, 0.21347878642824158, 0.20796949903200035, 0.2165155882817814, 0.22325329658281257, 0.20920336247937088, 0.2279639713241126, 0.21469846706577222, 0.22019770989339638, 0.2425130926274438, 0.2263150358147581, 0.21187970533424083, 0.23038128892858567, 0.35037899629050573, 0.2247329801431005, 0.22542892261418168, 0.23248035149988988, 0.24079468166635898, 0.8049640100897631, 0.1734676453195838, 0.18136436960126, 0.8756741383631861, 0.8041869433270725, 0.8936444110523118, 0.6327677673773875, 0.17373263793300375, 0.8546884090674007, 0.6104408001318458, 0.5943828547845607, 0.2098592317886837, 0.16503142543131377, 0.16865438350819273, 0.7764745550230711, 0.15572182387080902, 0.7949996423092951, 0.7315433856702213, 0.18298448983905413, 0.17331967671048265, 0.17999489659040424, 0.18022841771947662, 0.191629629503963, 0.1797645487838032, 0.19682629709752275, 0.167784768863797, 0.1903506276399607, 0.09521896686970666, 0.08907735061184852, 0.08826589955873843, 0.09020106933078809, 0.10191801198635675, 0.08121767824475756, 0.0955661809956424, 0.09128400842631001, 0.09163039456375155]}, "mutation_prompt": null}
{"id": "56347bb3-799f-4004-9213-582dfee4d65d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # Increased population size for better search space coverage\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)  # Adjusted CR range for enhanced crossover\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)  # Expanded F range for increased explorative potential\n        self.local_intensification = 0.45  # Increased local search probability\n        self.dynamic_scale = 0.35  # Increased dynamic scale for diversity\n        self.chaos_coefficient = 0.9  # Enhanced chaos for greater exploration\n        self.learning_rate = 0.25  # Adjusted adaptation speed\n        self.memory = np.zeros(self.dim)  # Memory vector for adaptive learning\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quasi_opposition(self, x):\n        return self.bounds[0] + self.bounds[1] - x\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                # Mutation with enhanced strategy\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                # Chaotic Local Search with Enhanced Memory\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n                \n                # Quasi-oppositional learning\n                if np.random.rand() < 0.5:\n                    mutant = self.quasi_opposition(mutant)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                # Crossover\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                # Selection and Memory Update\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])  # Updated memory weight\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with stochastic quasi-oppositional learning and adaptive dynamic chaos for improved exploration and convergence.", "configspace": "", "generation": 98, "fitness": 0.3179294016178481, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.24.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.7965747129643802, 0.7982149701086377, 0.7873826991516805, 0.7803352923878557, 0.7735332930460778, 0.7894096249736849, 0.7835113173264172, 0.785737669651293, 0.7830197466880654, 0.6035333591524654, 0.5720008703896877, 0.5821164632072482, 0.6020256727470168, 0.5985504109070954, 0.6083490170613108, 0.5850715765608976, 0.5817766319691515, 0.6167106244822838, 0.1474270122421456, 0.25552800171538614, 0.16576921149650226, 0.2939941952332732, 0.13955651987681927, 0.16045913579141657, 0.16338655593640983, 0.1593735608931296, 0.1767599889466619, 0.13401114301412365, 0.12725270316981352, 0.1303358071100139, 0.13604876568986057, 0.14028564054504966, 0.14476169692871976, 0.15111124175834578, 0.12767176370928246, 0.13734453742545882, 0.9400511956910695, 0.9633629533534553, 0.9632720602307727, 0.9732080975807759, 0.9569925029589237, 0.9594325687694258, 0.9641198825292637, 0.9514027340704959, 0.9717675695485408, 0.34407846161057465, 0.38861473902191657, 0.34900822598238923, 0.36515369095121064, 0.39735414259149726, 0.4178270233212412, 0.3270551768534039, 0.3353492892843294, 0.3712171156593509, 0.6690418854397391, 0.3704787464209872, 0.6768842511468159, 0.2041849008222295, 0.5848000180643496, 0.18461263353691926, 0.637116619021562, 0.22810732638938747, 0.5332199513009914, 0.20198761831417544, 0.1877326380195813, 0.3006869796987389, 0.17953845696051507, 0.16421261635140671, 0.1303467726021259, 0.18522545057894135, 0.2060881299200149, 0.19026373616891656, 0.2619109860942411, 0.2947241261756669, 0.26420177028898784, 0.2637049991305809, 0.23028431762148405, 0.2613993147773451, 0.27360371737435285, 0.255975233942733, 0.2446860310178307, 0.09089180038199884, 0.007096896394626628, 0.043349835010046966, 0.030278917945044448, 0.012324723764613577, 0.025851826339506778, 0.0769317039616455, 0.05654438119422778, 0.015316839362842227, 0.16470735310624218, 0.20128618299225987, 0.19763558110335222, 0.14565317403721767, 0.17099672047765468, 0.15930151910755574, 0.23288227740940703, 0.2245630727409934, 0.2168195730091318, 0.11574047536429422, 0.10013249639213684, 0.03450518337199793, 0.10608081812457582, 0.05100402364409673, 0.18344879680279724, 0.057655794673514005, 0.11126502587689358, 0.04858695985797912, 0.1613398399551763, 0.18113273190246304, 0.1585454730303849, 0.2020339027781093, 0.18886296666956082, 0.18186706752823079, 0.16437162922945114, 0.12680398916664892, 0.09546435556723265, 0.54908764215108, 0.5543949882167656, 0.5341374758055857, 0.5388578577961163, 0.5394239223464922, 0.5324508398002912, 0.5202396410958746, 0.5654734826703609, 0.551751616617446, 0.11161615208429976, 0.11561436518806278, 0.08967604158815323, 0.10806977706453613, 0.11333576723021255, 0.10652101640811906, 0.10123581047995578, 0.10304307524513989, 0.09945417973482362, 0.1418681528980682, 0.15439339436414445, 0.15055179291955012, 0.14809542765640193, 0.14334063246636908, 0.15139477289257142, 0.18257634004648393, 0.14119025498277948, 0.1273134448967157, 0.39428932217200585, 0.357798329362661, 0.4100561627845727, 0.3837853036318104, 0.38767551452814986, 0.42308065621444846, 0.4069745535679504, 0.4106721825623404, 0.40327896055813917, 0.26972263893640513, 0.28128012173996975, 0.25364770135874715, 0.2648086298253194, 0.28243888564435715, 0.2695371029405359, 0.22068508722819602, 0.2393292115701996, 0.2557143513329875, 0.23681144628034134, 0.21929947899783542, 0.21903911103218687, 0.23800726311383802, 0.2237591741202024, 0.2202403980193619, 0.2192578945505944, 0.22441849420497784, 0.23224440703390858, 0.20548238206306757, 0.2141529234168995, 0.18864756471370125, 0.20860602565402475, 0.44506519302946035, 0.20920061619863017, 0.21842820819232212, 0.2735378644644685, 0.23205023869667862, 0.6780024504887722, 0.7284680695704722, 0.18592023326962148, 0.7180744476655099, 0.6986855672438026, 0.6931287411748539, 0.2584101903398438, 0.6215815659765167, 0.6720755683567633, 0.6327318560452251, 0.20311162349591605, 0.4604394262513076, 0.3834007666040731, 0.19679589490905924, 0.2696896232171272, 0.6217779128920179, 0.5786073990865328, 0.5106854820082531, 0.19339032377480847, 0.2017894562362471, 0.1859650354245258, 0.17785725844825373, 0.19154601291615114, 0.18056050966556692, 0.17739792863357784, 0.18227359817836597, 0.1782373380027702, 0.09036654896198437, 0.09862614653943425, 0.09069354994602308, 0.08161710889595852, 0.08955205664781729, 0.08586059472274699, 0.08345981820467419, 0.07832563774464163, 0.09102174380744632]}, "mutation_prompt": null}
{"id": "6c1f408b-a65f-4006-8d3c-a053de128d61", "solution": "import numpy as np\n\nclass HybridAdaptiveDEQ:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.CR = np.random.uniform(0.5, 1.0, self.pop_size)\n        self.F = np.random.uniform(0.4, 0.9, self.pop_size)\n        self.local_intensification = 0.45\n        self.dynamic_scale = 0.35\n        self.chaos_coefficient = 0.9\n        self.learning_rate = 0.25\n        self.memory = np.zeros(self.dim)\n        self.quantum_prob = 0.3  # Probability of applying quantum-inspired search\n\n    def chaotic_map(self, x):\n        return self.chaos_coefficient * x * (1 - x)\n\n    def quantum_inspired_update(self, position):\n        return position + np.random.uniform(-0.1, 0.1, self.dim) * (np.log(1.0 / (np.random.rand(self.dim) + 1e-9)))\n\n    def __call__(self, func):\n        evaluations = 0\n        chaos_value = np.random.rand()\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n                indices = np.arange(self.pop_size)\n                indices = indices[indices != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_factor = 1.0 + self.dynamic_scale * (np.random.rand() - 0.5)\n                mutant = self.population[a] + dynamic_factor * self.F[i] * (self.population[b] - self.population[c])\n\n                if np.random.rand() < self.local_intensification:\n                    local_best = self.population[np.argmin(self.fitness)]\n                    mutant = (0.4 + chaos_value) * mutant + (0.6 - chaos_value) * (local_best + self.memory)\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                if np.random.rand() < self.quantum_prob:\n                    mutant = self.quantum_inspired_update(mutant)\n\n                j_rand = np.random.randint(self.dim)\n                trial = np.where((np.random.rand(self.dim) < self.CR[i]) | (np.arange(self.dim) == j_rand), mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                evaluations += 1\n                if trial_fitness < self.fitness[i]:\n                    self.memory = 0.7 * self.memory + 0.3 * (trial - self.population[i])\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.CR[i] = (1 - self.learning_rate) * self.CR[i] + self.learning_rate * np.random.rand()\n                    self.F[i] = (1 - self.learning_rate) * self.F[i] + self.learning_rate * np.random.rand()\n                else:\n                    self.CR[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.CR[i]\n                    self.F[i] = (1 - self.learning_rate) * np.random.rand() + self.learning_rate * self.F[i]\n\n                chaos_value = self.chaotic_map(chaos_value)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDEQ", "description": "Hybrid Adaptive Differential Evolution with Quantum-Inspired Search for enhanced exploration and convergence.", "configspace": "", "generation": 99, "fitness": 0.380892281570668, "feedback": "The algorithm HybridAdaptiveDEQ got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "a8b3abd0-03bb-441b-9c3f-a25dc1272ff3", "metadata": {"aucs": [0.8698817354726955, 0.8820232059172997, 0.8807558426595514, 0.8772413895653155, 0.8816780923677414, 0.886811847740439, 0.8720678698605319, 0.8791744339587513, 0.8833443165501934, 0.7297748563720658, 0.7553819432313013, 0.7600432928138213, 0.7465646584849011, 0.7459637233564929, 0.7421538443456612, 0.74568028562001, 0.7215491311673954, 0.7642701006866353, 0.4857953562168552, 0.5630861080960385, 0.5328985204120276, 0.3620131709763055, 0.6137105582877576, 0.43203475804112645, 0.4189833908476096, 0.4240916536104218, 0.3898168844054899, 0.15380403234454554, 0.4041476371106394, 0.17102255260669408, 0.1734056171722621, 0.30574093158418814, 0.17323686760209056, 0.1174666570650299, 0.29675230650835105, 0.19504303973129067, 0.9713248372598663, 0.9763701367343336, 0.9635894692902761, 0.98288388332232, 0.9878386368199971, 0.9728749927828719, 0.9652647493808493, 0.9876676444908608, 0.9829713927495952, 0.5902237154080439, 0.557221681096334, 0.5594567390238435, 0.6051056729425033, 0.5540377756865312, 0.5455534013032258, 0.531354127720947, 0.5051626677442564, 0.5194273641820069, 0.7880965639927033, 0.8039422610691137, 0.22375607228136096, 0.8344809301004188, 0.8357591168649079, 0.21463106945298627, 0.7387407597859761, 0.8476300263236833, 0.8066236108342465, 0.47486794445315483, 0.29462072875373035, 0.27383254762151343, 0.2794943620220175, 0.28450292002313726, 0.43053393644258164, 0.2810690127005473, 0.3221355731351204, 0.2579234879526333, 0.2283552100324584, 0.22051267297836752, 0.30153504134709475, 0.2890030228733701, 0.31751497481574953, 0.24941637587646215, 0.30775152263428907, 0.27892142957204924, 0.3697904561307348, 0.08987249391041219, 0.11840442091438796, 0.11336706801107432, 0.15896180760387835, 0.047724140790224356, 0.03199794171294923, 0.18504699691445414, 0.08092809549875346, 0.18340662376899453, 0.2585224182492504, 0.27076414526021175, 0.2718592944083822, 0.23752962109024933, 0.21380708400034654, 0.2853671037382305, 0.26686650386952715, 0.2537519275550535, 0.3088732421234236, 0.08590616498994963, 0.17394203683817455, 0.047826635753034696, 0.12257616746627953, 0.18328703614638253, 0.11895760420484025, 0.17384468971445044, 0.06880876256909563, 0.16817576047494054, 0.17394142165634163, 0.21634179091497818, 0.1812344693682304, 0.22331081294348953, 0.2598130061820362, 0.251786124328118, 0.18640972481255969, 0.23520181055754608, 0.2294455066563028, 0.6557760910381546, 0.6282404091672946, 0.6598376085246584, 0.6469108707581843, 0.6211054695298268, 0.6656734958426266, 0.6436166860593064, 0.6674350997024765, 0.6786182750794347, 0.10317998745249446, 0.14141760738692188, 0.13013155396308174, 0.15015835784373743, 0.11899220888040873, 0.09854185754075695, 0.08054982508035813, 0.10768383227605205, 0.11708454656493028, 0.17885765124989617, 0.16475113135130326, 0.17044561630377608, 0.14276195515411894, 0.13820746037276166, 0.15945998074140189, 0.1620518901375837, 0.16061143434412006, 0.15741427125613805, 0.5159672301949628, 0.46246131073768926, 0.4755924266408281, 0.43981368058841164, 0.41880334202376013, 0.37547258012969065, 0.5124166278151392, 0.5226455489899449, 0.5287681336438639, 0.2844501010334052, 0.331051007210899, 0.35643600334894854, 0.36430999678969445, 0.21684875178232854, 0.24278270831476756, 0.39054056419995953, 0.21444447859605476, 0.32382238479875713, 0.23866211996765707, 0.22116137660325952, 0.210629848042448, 0.20366465522064459, 0.24088969262292725, 0.19641705248221875, 0.2075805823814496, 0.20119781287547112, 0.20957330903394367, 0.7348189867868493, 0.5510078943643391, 0.19315463752207174, 0.5598839417127133, 0.22561264085233645, 0.252636391974024, 0.24210953625845444, 0.20292713123864536, 0.6556921946392769, 0.18661835098650048, 0.16480059845042594, 0.8514861966333866, 0.8648624955108742, 0.16912138771359697, 0.8676198738339063, 0.15650745464173033, 0.14143192573305985, 0.17590902922382445, 0.167997365940163, 0.16889457227259408, 0.7574042845630318, 0.12724584297945218, 0.1601141356018252, 0.1666635766870359, 0.15587693142347525, 0.7993289112096773, 0.15665615435161184, 0.18927623805082605, 0.20473230399951836, 0.18667778024424586, 0.1782507994172724, 0.18033940578982477, 0.1905200109438806, 0.19037767887954116, 0.18248514975498797, 0.19023749295739845, 0.09455082417918381, 0.09223719798795738, 0.08985832271991889, 0.09861664816769267, 0.08793399163509363, 0.08842818873092673, 0.09451633115342994, 0.10704159370146771, 0.08531033238016317]}, "mutation_prompt": null}
