{"id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Multi-ensembling metaheuristic combining Differential Evolution and Particle Swarm Optimization with adaptive exploration-exploitation balance.", "configspace": "", "generation": 0, "fitness": 0.29489153754396963, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": null, "metadata": {"aucs": [0.815600596019181, 0.8183295947096153, 0.8158087964491292, 0.7954387800776193, 0.8196719443889423, 0.8069333951675549, 0.7991595328239514, 0.8096982088225466, 0.8161897191541639, 0.6054568617765137, 9.999999999998899e-05, 0.03421546439151679, 0.6497087925441614, 0.6124239874200631, 0.6022196149525951, 0.07158395216786595, 0.6118209441657432, 0.5930661153526676, 0.1375816538821697, 0.13170729289141492, 0.12338873740745238, 0.16849159906276567, 0.3616556998693844, 0.12296673253129176, 0.12646511498191848, 0.11524528114918253, 0.15338571697526238, 0.14336391243010582, 0.15755699191104866, 0.1203684685177534, 0.13693299417670246, 0.10859266438461124, 0.13990731550582347, 0.12842615274426183, 0.15820042980305116, 0.13467075720301003, 0.9540528466408826, 0.9641699567724942, 0.9641606055397473, 0.8995958186284435, 0.962964305497967, 0.9260550867116664, 0.9652170964003364, 0.9539677301153696, 0.9537798738319604, 0.4447084321829964, 0.4064709443405402, 0.41055297546986536, 0.4534630852628879, 0.43141800859915824, 0.3879956483741194, 0.39844389746903863, 0.413742286104121, 0.3930847374798905, 0.2257998409987747, 0.22697737898601023, 0.6681406147128479, 0.275737346666278, 0.7969627389725695, 0.2526374702613301, 0.2358416703878412, 0.7767028694744476, 0.7540445178248961, 0.2063835047407212, 0.1283410305725422, 0.18941335456048236, 0.12367133932457786, 0.12963911216520319, 0.17719134844749296, 0.19314459063381162, 0.19304014920159707, 0.20267285007044233, 0.1311255146586, 0.19628993653165627, 0.20499500795571768, 0.20019322874654222, 0.19722801913554222, 0.2454771655751461, 0.13245118305748615, 0.13870109789307483, 0.25669044575641187, 9.999999999998899e-05, 0.020243397285414022, 0.0036825481637177138, 0.0315006684641832, 0.05317287077397925, 9.999999999998899e-05, 0.03452468278089926, 0.010880582888152635, 9.999999999998899e-05, 0.114651619576982, 0.08254420544501484, 0.08329075044182632, 0.08071233531243083, 0.08038889530439741, 0.134110458350987, 0.05860596427778619, 0.09049807391586384, 0.1097521363904792, 0.1404582212377885, 0.031725236539252855, 0.1582382542735875, 0.09396205781666345, 0.14298627397804697, 0.06464406034277703, 0.13491017894884516, 0.2218603405680415, 0.07327696232355752, 0.10728121713008676, 0.06124122232744289, 0.20037415258770097, 0.06538789279452017, 0.1739632367961964, 0.09736804889473372, 0.054138891643575104, 0.12756538295923214, 0.0792139034583137, 0.5130717581583435, 0.5089600008977764, 0.5408954045845986, 0.5264390797974781, 0.5272255626476637, 0.5461342713771165, 0.5771564803170668, 0.522941831613732, 0.572041851211347, 0.10289103832179403, 0.07475243706619261, 0.09393090630855672, 0.12296783491637964, 0.10966735175722875, 0.17711583359541205, 0.10585652365931453, 0.09507027950529168, 0.09918150146796145, 0.217211113926582, 0.21752936814388202, 0.13875013445273687, 0.1662223736455446, 0.23929420078086705, 0.28606617466213224, 0.2613072796884679, 0.1856490761209546, 0.17604958358647216, 0.4330078917838971, 0.2527620650932738, 0.46516165870639303, 0.2944273644274973, 0.4845600749854667, 0.45500432670959623, 0.47598501541586724, 0.5199571768224053, 0.47678614251838414, 0.29659131401788263, 0.3205574162311835, 0.3348333115186054, 0.33525382516136804, 0.32357365798266136, 0.30696398697675753, 0.2867877008106898, 0.36561553791687695, 0.3032267553659752, 0.23495963884384674, 0.20403475295995765, 0.19402353486214385, 0.19066433303703578, 0.22030184632648342, 0.18813662029770883, 0.19961276959251384, 0.1956439573321812, 0.21170455086041184, 0.18572147000974815, 0.19763612473345393, 0.24322560827897155, 0.1978067073357812, 0.683113497377104, 0.2466445228766625, 0.2150891663487038, 0.22057462452642118, 0.2217392461583767, 0.1858259603781124, 0.14765531276104937, 0.1528888880243754, 0.11475283725168794, 0.19959567411546086, 0.16737409830243155, 0.14191800656330722, 0.16103880379838353, 0.8846745855564793, 0.6960985430493383, 0.46552646759982963, 0.07344009107768812, 0.10452327840878262, 0.6049942765806932, 0.21008620541765177, 0.7538379446863454, 0.21032333316808005, 0.7778882348457072, 0.1869259265641524, 0.191078673016029, 0.18523248805135273, 0.21220535218879522, 0.188500769075987, 0.18935932677258893, 0.17536299514677134, 0.1850734660968748, 0.18937790708988433, 0.08618707459618125, 0.08251398413425215, 0.07482554290253574, 0.08469341982473033, 0.08545416904217795, 0.08018081696610513, 0.09144970416270481, 0.08384200751546234, 0.07867329581522664]}, "mutation_prompt": null}
{"id": "555118f2-4c64-4138-bca8-07aeaf5af48d", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Adaptive Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2 + x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Adjust parameters based on iterations\n            adapt_factor = np.sin(np.pi * eval_count / self.budget)\n            self.w = 0.4 + 0.5 * adapt_factor\n            self.c1 = 1.5 + 0.5 * adapt_factor\n            self.c2 = 1.5 - 0.5 * adapt_factor\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedHybridOptimizer", "description": "Enhanced multi-ensemble approach combining Adaptive Differential Evolution and Particle Swarm Optimization with dynamic parameter adjustments.", "configspace": "", "generation": 1, "fitness": 0.23079145824430067, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.5806220107703577, 0.6170130692482675, 0.6024077751554178, 0.6683074422350108, 0.6384644308321913, 0.6018703746290546, 0.5979772427358883, 0.6080966847420033, 0.6484310153873329, 0.23155262746063332, 0.15854741794141558, 0.18849723894383197, 0.25687299509965955, 0.3186234947215735, 0.29754857619699515, 0.22493090118532078, 0.22878803512620338, 0.2257724683400847, 0.10550033029170247, 0.10604539461164098, 0.10908498828606206, 0.1019647053347118, 0.08433844571926952, 0.12951010489100567, 0.12631350844586886, 0.09306853041434948, 0.13381428503089754, 0.07627625607682242, 0.12138452389385634, 0.09757993716550717, 0.1275856470415938, 0.08968294878635863, 0.07517688608173156, 0.09210630891536586, 0.09308818649739059, 0.09224779798315086, 0.9680743941002283, 0.9543297753224208, 0.9658543560587127, 0.9663834474589222, 0.9713532835009084, 0.9549781372917513, 0.9662234112596007, 0.9687352534279453, 0.9542658511842468, 0.21013428709274284, 0.2864520668529451, 0.2229111930207267, 0.2783211904755749, 0.14605705814596892, 0.2492301444027648, 0.22003058166488132, 0.23185783376578295, 0.32240458139652717, 0.2772526691168651, 0.33538621023720316, 0.2792718277124221, 0.20554728655269205, 0.3497869791031467, 0.36114252727008733, 0.24044561201004067, 0.21490869979576366, 0.22004665979831894, 0.13763305296269757, 0.10832011586897516, 0.31654003048502277, 0.09795610971447644, 0.11610261952201306, 0.17005061279913392, 0.15985770160948576, 0.1710606871873751, 0.2784174305117515, 0.19951168441820677, 0.1503293537066287, 0.2162276860236868, 0.12494213861733883, 0.21001588049287612, 0.17005635257257945, 0.15496588384807108, 0.1560645572080468, 0.18261430449914928, 9.999999999998899e-05, 9.999999999998899e-05, 0.009513364976699967, 0.018893595710183564, 9.999999999998899e-05, 0.006948359620882694, 9.999999999998899e-05, 0.05767832556104224, 9.999999999998899e-05, 0.037658691380551335, 0.02566814356790814, 0.08563885584916786, 0.085895775177947, 0.011167625044766094, 0.012364066614958702, 0.075148049919601, 0.08982450680846665, 0.043513068516214504, 0.03439941656936896, 0.027091855163462575, 0.03325382118959774, 0.06122964048957069, 0.05178592998376408, 0.06962952886010265, 0.07450925053830448, 0.04968755955887705, 0.03279193518872103, 0.0622527265792282, 0.08550676933750367, 0.11888053066305015, 0.00592169507971263, 0.15659166443897066, 0.15004115441182442, 0.07860440604360575, 0.16124479134097824, 0.16575834461244665, 0.42600101911499555, 0.49222311326266377, 0.4724702593031911, 0.4584378227186513, 0.501190336307821, 0.4573206491109456, 0.43905291476318675, 0.4543894563314198, 0.45874843412245114, 0.10762478805495734, 0.07882070971170507, 0.11294605068383767, 0.12134778121133727, 0.09622031938537678, 0.10772947633003094, 0.07630007386429116, 0.07087090927609929, 0.12142065895551035, 0.15223648697261905, 0.1724128058478076, 0.1993822388586729, 0.23690193032393048, 0.20749638214551047, 0.13051360123514189, 0.1593035741142037, 0.2096875603694318, 0.2918624059420325, 0.28255764667502825, 0.2852848854109077, 0.3395073041669968, 0.19495908004300344, 0.2685978518962656, 0.2967362996101669, 0.3073457658714417, 0.33122635778221043, 0.21176182965302937, 0.2377468539281382, 0.18790351013211726, 0.2137590634234524, 0.20298278152673088, 0.18313068148894462, 0.2000339892945291, 0.20940013373519395, 0.2582170126310166, 0.21950593455391454, 0.19779413237351928, 0.1719577183169837, 0.16566139224215604, 0.18260387825646773, 0.16569822434651504, 0.1781402339759408, 0.17344467307870015, 0.1959668326991656, 0.18622139300314033, 0.21447498541865373, 0.2120596924853858, 0.2304753504530177, 0.21080858823974313, 0.1970799198909885, 0.23183809188774762, 0.2049156893074371, 0.2516613518087949, 0.1937561497908621, 0.16633705821762546, 0.14711020231076943, 0.1534302759834416, 0.19947089068425583, 0.199573953878182, 0.16843535193833759, 0.32337608824628017, 0.17540166642240962, 0.7759159904511191, 0.38177753732994824, 0.2088098179035277, 0.11147995062937188, 0.20776368329773376, 0.38959053808509436, 0.1509485815321524, 0.21038857853006498, 0.21121704065892533, 0.549459392363038, 0.1863726500809011, 0.18309390915227408, 0.19040587954380395, 0.1772073686436555, 0.19202308840396498, 0.17695934408191805, 0.18087074576683704, 0.1915240360411351, 0.19093430829560176, 0.0819916456820301, 0.06848435369263495, 0.07553048244071592, 0.0730763245401953, 0.07965858845106655, 0.07303937593406518, 0.06833978395872564, 0.07924047209626262, 0.07285143270204064]}, "mutation_prompt": null}
{"id": "609b02e3-415c-4188-868b-858faa75775c", "solution": "import numpy as np\n\nclass AdaptiveDynamicDifferentialSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w_min = 0.4  # Minimum inertia weight\n        self.w_max = 0.9  # Maximum inertia weight\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n\n        for iteration in range(self.max_iter):\n            w = self.w_max - ((self.w_max - self.w_min) * (iteration / self.max_iter))  # Adaptive inertia weight\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "AdaptiveDynamicDifferentialSwarm", "description": "Adaptive Dynamic Differential Swarm (ADDS): A hybrid algorithm that dynamically adjusts inertia weights and crossover probabilities to balance exploration and exploitation.", "configspace": "", "generation": 2, "fitness": 0.18249621042619477, "feedback": "The algorithm AdaptiveDynamicDifferentialSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.407612632953113, 0.3954392924436958, 0.4205259093850674, 0.41122394069153445, 0.43409537988497227, 0.41073671292570213, 0.4205268523201766, 0.45021097842308255, 0.37683275473235645, 0.11268142989431817, 0.041741100293919975, 0.057995617904256114, 0.10396792402279464, 0.02113897583527069, 0.09492782651852483, 0.09904808426268896, 0.015997278995908526, 0.11102812874659507, 0.07665081766204818, 0.06746171289158587, 0.07140670249515024, 0.07503370034142332, 0.07692329321769598, 0.0757497481128172, 0.06735747671866799, 0.08869363386681273, 0.08360697924314586, 0.07154569590565607, 0.066490628223695, 0.05979404001309174, 0.07916847682419847, 0.061398745329881765, 0.079179592731628, 0.09010318255243888, 0.06492633360538835, 0.07231720531926455, 0.9638722455778906, 0.9660311170275242, 0.9630887146478726, 0.9335318601162393, 0.9639277273916081, 0.9428619730864205, 0.9657436090419688, 0.9643789287459366, 0.9646517992925576, 0.17153125632462762, 0.2055612422075649, 0.1706420728869924, 0.15488685360988697, 0.13892800046870157, 0.16565850534097482, 0.1618553259082981, 0.0862518163597551, 0.1903841349698694, 0.18248643292951183, 0.21060973013477802, 0.22219814359779344, 0.25574769222612037, 0.19267029651830703, 0.2054051636014229, 0.21434087474368768, 0.17459549069238833, 0.20165653382974436, 0.09570162071167909, 0.07530393779841671, 0.09942718743059065, 0.08551752165913296, 0.16505378989099884, 0.12802227444330494, 0.10198909726398919, 0.10062194557704685, 0.10495134449496779, 0.08826468511917862, 0.12882116433889623, 0.11342963445196652, 0.09538298407734458, 0.1425165851939384, 0.1352927414334255, 0.1476432833894904, 0.09728631033846102, 0.11062141246764023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06660619829598013, 0.07460319616146827, 0.06100420992519706, 0.07355376442268913, 0.0661299811419167, 0.11569032400826473, 0.061299791195425835, 0.05045607251365347, 0.05465031188345204, 0.011214580632334603, 0.009636265872943639, 0.008924022600692694, 0.022439882187419102, 0.027323263035561873, 0.0017886968420376403, 0.021020383358302697, 0.02037582969271845, 0.005459183137004553, 0.06449523396203216, 0.06462820724529661, 0.07437915696059028, 0.01936378754429202, 0.07901387700015439, 0.05109466653682104, 0.04590202149965006, 0.06858350519816414, 0.05307389242491867, 0.34575161825551903, 0.32852798032855557, 0.3328905120529727, 0.39200985108048203, 0.3557000476721429, 0.3789707318440856, 0.3500768045398347, 0.34465681563599104, 0.3356588459806339, 0.06353270296343272, 0.07250632819208314, 0.07723407153707962, 0.08059133302359134, 0.0685717364954489, 0.0731252316897919, 0.07550417370640605, 0.06456109420968792, 0.09270350716720399, 0.140085058128669, 0.1442076375872381, 0.14487145172803106, 0.1496369763800558, 0.16367824610499737, 0.13405432986522847, 0.17351101607192954, 0.16823724100222315, 0.1461211455942757, 0.2247939537680106, 0.21217977174224711, 0.23965569370420015, 0.29234032639615837, 0.23821999566571617, 0.2511250096243256, 0.23236906126061507, 0.2628549730710391, 0.23409995888252666, 0.1387625509111502, 0.17157338602113326, 0.1681677882650383, 0.16039932459660522, 0.16295140265241082, 0.17700734905804016, 0.15295821645227226, 0.17729299142054444, 0.17863328901437125, 0.1700725178475021, 0.17166895996433706, 0.19504614342832838, 0.17127923594500094, 0.18579120909392322, 0.1920753468407469, 0.16163329634427592, 0.2071227064881408, 0.1667862865145967, 0.21352607907297472, 0.17427797570365577, 0.17809626463976402, 0.1665535911986149, 0.1768531211314186, 0.1690438153381898, 0.16861425368664718, 0.28123582831451566, 0.1734539101681074, 0.1871315653744543, 0.43639568027851683, 0.15180856777708196, 0.15732065307752907, 0.18772545693037712, 0.18537553795712525, 0.138066697362067, 0.15500703182752384, 0.3530489616954062, 0.2445284128103028, 0.17488452818847144, 0.16961416453188327, 0.3016307586442559, 0.20772188796052704, 0.1935956926807938, 0.31301405181532793, 0.20596812708214052, 0.25691950448920353, 0.18111161046466473, 0.18679855307175486, 0.18279439134718234, 0.19268714915996565, 0.191368500562362, 0.18328307758126738, 0.1784906184101226, 0.16676907779549677, 0.18950168758863462, 0.06907498936245082, 0.06050473805322998, 0.07554622784456655, 0.08249498585571868, 0.06538059186709122, 0.0650123159733641, 0.0741411095680361, 0.0677928181637577, 0.054685503914221445]}, "mutation_prompt": null}
{"id": "27b8a303-84c9-40d9-a222-926be0283612", "solution": "import numpy as np\n\nclass SynergisticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.6  # Differential weight\n        self.CR = 0.85  # Crossover probability\n        self.w = 0.4  # Inertia weight for PSO\n        self.c1 = 1.7  # Personal attraction coefficient\n        self.c2 = 1.3  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step with adaptive mutation\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "SynergisticOptimizer", "description": "A synergistic hybrid algorithm merging Differential Evolution, Particle Swarm Optimization, and Adaptive Local Search for enhanced global exploration and local exploitation.", "configspace": "", "generation": 3, "fitness": 0.2801848398036548, "feedback": "The algorithm SynergisticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.7916872069233984, 0.7803152593516908, 0.7763059260790969, 0.7707199883941145, 0.7814428083321199, 0.7771203476101508, 0.7969169711730859, 0.7672220331288659, 0.7729906103456443, 0.510819686735047, 0.540415007663507, 0.5542171556733502, 0.2430805962563286, 0.5390477199654549, 0.5255925084979982, 0.5143845906150638, 0.523742541165968, 0.5289933261899842, 0.15306272108786667, 0.13478580639992144, 0.1325273197584511, 0.12468868189049886, 0.11621137639470014, 0.11076315227003275, 0.1438973982748174, 0.132831573287713, 0.22370598257940733, 0.11114746021584665, 0.13732009494888675, 0.12256136958997654, 0.10457631532639866, 0.1400319575951947, 0.13115058897679732, 0.1383470982724968, 0.11793342480273006, 0.12361361473883647, 0.9489872176047834, 0.9355960423877235, 0.9319263525095219, 0.9487356875598464, 0.9528817436053596, 0.9493978998700509, 0.9508018399657496, 0.951089322458945, 0.9514062548557941, 0.40753641854081624, 0.40045664643934, 0.3302686886951306, 0.35560400211219845, 0.39005181512638054, 0.3765703617489162, 0.39977576249016356, 0.43939857614992206, 0.40194280096119916, 0.6500216672753973, 0.7291058851379224, 0.523475408684372, 0.20654933924569685, 0.2090283025933034, 0.20367913656443914, 0.5359176313085823, 0.5779820920774257, 0.3692189904804374, 0.18134418852398926, 0.17593798531585303, 0.1571235471169541, 0.09988112501973645, 0.12414991937103514, 0.2202863573312438, 0.18695466264535765, 0.15727776702854623, 0.22311208766532198, 0.12677783609483884, 0.17845016381569945, 0.2931071658470752, 0.12719113616099764, 0.28823657909914513, 0.17996804184267712, 0.20630525783671272, 0.207709545458857, 0.1169245329753521, 0.010123687306104912, 0.05538013743722914, 0.06385769734769786, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01781703440095206, 9.999999999998899e-05, 0.11639125287050811, 0.0342183497352091, 0.08299824437844194, 0.01229146136185677, 0.049491070112997804, 0.10596393617673561, 0.06909209396863347, 0.05619143717224084, 0.08300591948480629, 0.05657299130379956, 0.029256729220327182, 0.03099688861198191, 0.13136742075464303, 0.10190417045049815, 0.10212420638665465, 0.10147397504344824, 0.11199358934423076, 0.13227188130229717, 0.13171479008339793, 0.17487623054318813, 0.16400679868711354, 0.19967204566194574, 0.1825117898088302, 0.1435042492484494, 0.17082832071686627, 0.16309083860252793, 0.08709799127254847, 0.49460205759792275, 0.517318984496411, 0.535750449532989, 0.520459230453033, 0.5137057601460263, 0.49253276097052634, 0.5231960598102833, 0.5212445040931208, 0.49360206294907716, 0.09551636063363766, 0.09393721906594887, 0.11363636690688417, 0.11032484163959122, 0.08917984411440827, 0.12925340107602679, 0.12453794053989009, 0.09395331932166662, 0.09275817923928331, 0.17163605818877437, 0.14052564941864198, 0.27374316517467445, 0.15481611855948862, 0.14783414804073836, 0.2339579706013022, 0.15354616457287962, 0.13455442454651256, 0.16858434580361537, 0.2957648583586555, 0.2684100273460217, 0.43333628841667393, 0.3532607599711477, 0.34813646156642264, 0.4132657662237399, 0.4411726066672529, 0.2759294379059286, 0.4306519015259834, 0.24772843940981903, 0.21648307413623902, 0.2695569993497684, 0.34587506794951584, 0.2935567825185931, 0.193600059221392, 0.3195384358643234, 0.33261586737262316, 0.24437384906739767, 0.21988196343173416, 0.20493743434795686, 0.1905743395988848, 0.21071966016317178, 0.19317051447340639, 0.19565458191460872, 0.2166150649619828, 0.2106341011915892, 0.20639208291978495, 0.1851065693477214, 0.2126476322597901, 0.21143137128079414, 0.2132734098510516, 0.22134844845411383, 0.20317837955541695, 0.20234835609917357, 0.19357656228063858, 0.20794199520900025, 0.12964952646419858, 0.18559305658839298, 0.18623043626179614, 0.8547212442965862, 0.19707905038427875, 0.19157283119839896, 0.14172214524785576, 0.17131387059382797, 0.843758582901056, 0.703363087710321, 0.20918111539038609, 0.31515165781450705, 0.2066842529510058, 0.16389247982210986, 0.4432034806904587, 0.16578474212802197, 0.15424221688046869, 0.1524345871745354, 0.1700764984569172, 0.1849862940267476, 0.1716849305504473, 0.20813670063264444, 0.21359884236844962, 0.19091770683837872, 0.19328522331803033, 0.17351075465458343, 0.18006970272819545, 0.08227551590414883, 0.0911724292086794, 0.07951373650250693, 0.07920858812865916, 0.07226698995447134, 0.08680591528093407, 0.07596051851566588, 0.07578204098761321, 0.072796872422072]}, "mutation_prompt": null}
{"id": "fa769cf4-bf06-4053-92ef-d2a4243d8190", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F = 0.8  # Increased differential weight for stronger mutation\n        self.CR = 0.7  # Reduced crossover probability for exploration\n        self.w_min = 0.3  # Adaptive inertia weight\n        self.w_max = 0.9\n        self.c1 = 2.0  # Increased personal attraction\n        self.c2 = 2.0  # Increased global attraction\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for iter_count in range(self.max_iter):\n            w = self.w_max - (self.w_max - self.w_min) * (iter_count / self.max_iter)\n            \n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedHybridOptimizer", "description": "Enhanced multi-strategy optimizer using Differential Evolution, Particle Swarm Optimization, and Adaptive Strategy Control for robust convergence.", "configspace": "", "generation": 4, "fitness": 0.14986040445355545, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.2766137705851678, 0.2530789748358172, 0.27436634327186316, 0.3166234909668678, 0.3199746663511617, 0.31774837434671477, 0.33228552676856127, 0.3058923483305487, 0.29514851662615604, 0.022987580437800026, 0.013114292659690219, 0.0036824337648256877, 0.010069066618184852, 0.011591587783543966, 0.02817988522166104, 0.0059839196254884985, 0.009357609239037945, 0.02510520056033727, 0.06817491913105389, 0.06066186360273518, 0.0733434279792482, 0.07183462862423295, 0.05631525382821878, 0.06887586857896422, 0.07155795126218767, 0.06646168388339135, 0.07411104850846639, 0.044402908769582417, 0.03782777485591615, 0.04366388521975828, 0.08394617358883627, 0.0649657219464923, 0.046027631053756735, 0.04922241327488375, 0.07125390226042239, 0.05560491877790186, 0.9601443316393656, 0.9700817933691327, 0.9604566387062723, 0.9721023525119838, 0.9603022059390796, 0.9624528777281701, 0.9677566429942256, 0.9705273855282092, 0.9708019586641132, 0.10589463799317622, 0.10432619447829294, 0.11607267296560908, 0.09560809174699847, 0.1372511146199713, 0.12707222682380448, 0.13649009146261526, 0.07382332212391574, 0.12083489158713978, 0.18503877034603766, 0.16532281189870157, 0.15644414192856437, 0.16404589267346892, 0.165369883887867, 0.18057553556028128, 0.13014871994338606, 0.15808359698990848, 0.14959456009766414, 0.06044434127499132, 0.09617086308391887, 0.08997445614179211, 0.07834785137949474, 0.08707324297428609, 0.056730694980772545, 0.07998689171436324, 0.05510649215429819, 0.06815796138581298, 0.02768617350181468, 0.03935905976078646, 0.03814702339114884, 0.0928314609763976, 0.08380011092731876, 0.04793312866800403, 0.019071971196769844, 0.029345257934233038, 0.08210114589124917, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035413850680868775, 0.012301552268415117, 0.042965885578720164, 0.03849185343785633, 0.057374647597735695, 0.05752506415210845, 0.028876436501571123, 0.03631155680781162, 0.0037224385544343264, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018203154482918982, 0.04987099482102808, 0.034679788699386704, 0.034944622191499186, 0.019566421021562252, 0.018935335612203397, 0.03475988064711877, 0.015672951527048062, 0.034730897077972944, 0.25758006114070153, 0.2499405326006301, 0.2625626668619575, 0.31730823758522364, 0.28654679321819865, 0.2952211987256521, 0.30081680284011514, 0.2609165107845539, 0.255517742284892, 0.06272216109683837, 0.06951186348747529, 0.06413728746537983, 0.06100334537413943, 0.0648894101422588, 0.06479962907344128, 0.05395129181418157, 0.06424282175584828, 0.06400234656234594, 0.13658218849037163, 0.1419032836427777, 0.13017723920113766, 0.1615866629883811, 0.14196622068360198, 0.1660650272590728, 0.16688612948976822, 0.1661726656545477, 0.16009630273612185, 0.17544609394050092, 0.20002808681712347, 0.19552151328470457, 0.16640662016420826, 0.162090516486584, 0.1789426506443471, 0.21861524374046248, 0.21856957338221228, 0.1919024184123893, 0.13438933405695785, 0.13939409602200414, 0.14195674219218457, 0.122848243694476, 0.12345603028922747, 0.11933730028557143, 0.17120155332641895, 0.14860475374618165, 0.1585129221806515, 0.1472081661778759, 0.1491987091172845, 0.15474115683842682, 0.15611088734351397, 0.1609690805298245, 0.15332487374994452, 0.15326929442705006, 0.169733583737124, 0.17129557788177896, 0.163813890518811, 0.16784520472947295, 0.16270487072660889, 0.17032069914139614, 0.16157608883942554, 0.1644477070423842, 0.15104968865359536, 0.15686335204743096, 0.15893133579049812, 0.1579841040950707, 0.1690458974847041, 0.1618901215519709, 0.16891270930959168, 0.16682357815708926, 0.17412266934553755, 0.16612121694827187, 0.14935342220329695, 0.14728182097295028, 0.27127271689452215, 0.19278024244879666, 0.14233382309910791, 0.11984538979988157, 0.20476316140139716, 0.14594941718672672, 0.14173289369523223, 0.18230392502347637, 0.22176300320016218, 0.20222343231060402, 0.18163974003705086, 0.18986397548966283, 0.20822652025795796, 0.17662127314264342, 0.17538752642017696, 0.19563153985565207, 0.184817880401546, 0.18701287047867587, 0.06226853095258211, 0.05752014520881932, 0.05151201966185415, 0.05207710503791496, 0.04820749994905049, 0.061201009344690305, 0.053589238789838456, 0.06266371386049707, 0.06227457868756592]}, "mutation_prompt": null}
{"id": "3bd83af8-cad5-4090-a1e3-49cc8d39f12d", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.6  # Adjusted differential weight for better convergence\n        self.CR = 0.8  # Slightly reduced crossover probability for diversity\n        self.w = 0.4 + np.random.rand() * 0.3  # Adaptive inertia weight\n        self.c1 = 2.0  # Increased personal attraction coefficient\n        self.c2 = 1.0  # Decreased global attraction coefficient for exploration\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for iteration in range(self.max_iter):\n            self.F = 0.5 + 0.1 * np.random.rand()  # Adaptive mutation factor\n            self.w = 0.5 + 0.3 * np.cos(2 * np.pi * iteration / self.max_iter)  # Time-varying inertia\n            \n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedHybridOptimizer", "description": "Enhanced hybrid algorithm combining Differential Evolution and Particle Swarm Optimization with adaptive parameter tuning and diversity preservation.", "configspace": "", "generation": 5, "fitness": 0.2568785815671859, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.6411937079083823, 0.6361372580237868, 0.6650802741640157, 0.6405759471044565, 0.6587490014174033, 0.6785717120243989, 0.6691434340804161, 0.6647736112968474, 0.6372728230956046, 0.41929663138538154, 0.39362000372959793, 0.382603401446177, 0.3886496352579436, 0.4080403771163059, 0.35957596379224965, 0.395600602081286, 0.35845794061379954, 0.38935567709064045, 0.12300255149822226, 0.11510602366340827, 0.10649026637349868, 0.11488282853320719, 0.14642438707781236, 0.11662738652457993, 0.1016816647079859, 0.11701158962386193, 0.11651579568807502, 0.09510361322295979, 0.10243198935705244, 0.09795896491021028, 0.11228532657831691, 0.0956537911852865, 0.08653222152027884, 0.09860806772419783, 0.09566386749016309, 0.10711834226187933, 0.9511832995602715, 0.961566271051415, 0.941761368022727, 0.9524390598020726, 0.9425843596207636, 0.9733022745002141, 0.9638921795405836, 0.9660876532587865, 0.9488234581794958, 0.27963350559791156, 0.3236182771373687, 0.25777746598026086, 0.3139820269457778, 0.270549984629585, 0.2975794470793297, 0.3273757436015763, 0.2496459011380232, 0.3003883803393089, 0.2529347304348265, 0.21101091617075352, 0.3097019791100464, 0.5791801297143968, 0.5561741303978429, 0.5403315964162059, 0.46952409774935056, 0.5855507197752827, 0.4720858933740698, 0.14318612656832608, 0.14095468291038393, 0.1400491531781669, 0.15437930383277487, 0.1562192648721673, 0.14307370823092092, 0.15458421237512743, 0.15302794213362791, 0.14369224479609843, 0.1315938784358084, 0.17150048840080567, 0.14706417917958592, 0.13956668686577012, 0.1463399136466884, 0.11298624755353126, 0.14997169839768743, 0.11600708163072981, 0.1765675553362055, 9.999999999998899e-05, 0.004980019226846322, 0.01975161093269384, 0.00026106726382335577, 0.003989816507940835, 0.022976796247500375, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.061418150638502644, 0.0432616844378243, 0.0810455388297483, 0.040697345618312064, 0.11948715673085064, 0.06490803752718999, 0.08310486265639228, 0.08689206809553363, 0.10000240510035163, 0.02204650983648715, 0.10986361381348908, 0.09162844987791541, 0.04344320260622847, 0.04864981216252218, 0.054183871343980505, 0.056614187586709885, 0.057507294760907435, 0.040569712341343656, 0.13846295349116367, 0.1176620560558913, 0.12874265013105402, 0.0542111114261461, 0.0987734236239276, 0.20474102912094772, 0.0708613103992689, 0.1268061873592372, 0.1126685815170575, 0.4372550136416722, 0.4263023376311874, 0.4692494939544618, 0.46927225976734455, 0.46865336001051605, 0.48916591984556157, 0.46096669616288555, 0.4728655706775492, 0.450914672046556, 0.09645657896277515, 0.09344524949831778, 0.08247160429441214, 0.10776287740755941, 0.08710528805196793, 0.07869647004861924, 0.09854398514607565, 0.09116442707611672, 0.1018354242285664, 0.1561901088487182, 0.17557529197236, 0.1580534111456764, 0.263529426823387, 0.16885811677762774, 0.17974784460019033, 0.1538012453699925, 0.14090691732105953, 0.18492203625763026, 0.31197434597074136, 0.32365023646038316, 0.34091208268558937, 0.3341643482109201, 0.28395698258063773, 0.34352792863782433, 0.25384005632564577, 0.3551094239089949, 0.35042772149818413, 0.19846718474582414, 0.2665647909568146, 0.23690667339511284, 0.2662028942719047, 0.20092729708098, 0.24021431850035235, 0.19493260246471722, 0.2198205660655086, 0.20955366972025447, 0.17400047019331888, 0.202441606839865, 0.1776176875319374, 0.2028232681138027, 0.19328909234138103, 0.20258010680344452, 0.17418520307239482, 0.18220009103082246, 0.19326887350851119, 0.18091441317068302, 0.20211860796842007, 0.2073312965029953, 0.18245556097111415, 0.2091167271798503, 0.18514088743706691, 0.32908067921339856, 0.3123442912998614, 0.23014971495240222, 0.4911216855756726, 0.6864646550768467, 0.7569907286522298, 0.19674123678916478, 0.16645971180443153, 0.7031900664666519, 0.16492484264015406, 0.1404395853197522, 0.662452437401305, 0.24007306438047293, 0.3432651137542637, 0.16588348251159513, 0.15329014972745592, 0.37044082150244184, 0.16760062230503847, 0.15377267377602677, 0.5255346997344833, 0.28350076915954014, 0.20367730629537184, 0.19912957857194258, 0.20235158490947047, 0.18236501304533226, 0.18405970526772242, 0.1986900574081426, 0.18216055990205204, 0.19961778891487703, 0.1745096955399038, 0.07637430160372771, 0.07292817570140775, 0.069386314086192, 0.07884937812560189, 0.07056047081937, 0.07650551006252304, 0.0903090581582564, 0.0830658007638514, 0.06730522926830218]}, "mutation_prompt": null}
{"id": "424d1925-c380-438a-bdc2-bb98ac22456f", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Multi-ensembling metaheuristic combining Differential Evolution and Particle Swarm Optimization with adaptive exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.815600596019181, 0.8183295947096153, 0.8158087964491292, 0.7954387800776193, 0.8196719443889423, 0.8069333951675549, 0.7991595328239514, 0.8096982088225466, 0.8161897191541639, 0.6054568617765137, 9.999999999998899e-05, 0.03421546439151679, 0.6497087925441614, 0.6124239874200631, 0.6022196149525951, 0.07158395216786595, 0.6118209441657432, 0.5930661153526676, 0.1375816538821697, 0.13170729289141492, 0.12338873740745238, 0.16849159906276567, 0.3616556998693844, 0.12296673253129176, 0.12646511498191848, 0.11524528114918253, 0.15338571697526238, 0.14336391243010582, 0.15755699191104866, 0.1203684685177534, 0.13693299417670246, 0.10859266438461124, 0.13990731550582347, 0.12842615274426183, 0.15820042980305116, 0.13467075720301003, 0.9540528466408826, 0.9641699567724942, 0.9641606055397473, 0.8995958186284435, 0.962964305497967, 0.9260550867116664, 0.9652170964003364, 0.9539677301153696, 0.9537798738319604, 0.4447084321829964, 0.4064709443405402, 0.41055297546986536, 0.4534630852628879, 0.43141800859915824, 0.3879956483741194, 0.39844389746903863, 0.413742286104121, 0.3930847374798905, 0.2257998409987747, 0.22697737898601023, 0.6681406147128479, 0.275737346666278, 0.7969627389725695, 0.2526374702613301, 0.2358416703878412, 0.7767028694744476, 0.7540445178248961, 0.2063835047407212, 0.1283410305725422, 0.18941335456048236, 0.12367133932457786, 0.12963911216520319, 0.17719134844749296, 0.19314459063381162, 0.19304014920159707, 0.20267285007044233, 0.1311255146586, 0.19628993653165627, 0.20499500795571768, 0.20019322874654222, 0.19722801913554222, 0.2454771655751461, 0.13245118305748615, 0.13870109789307483, 0.25669044575641187, 9.999999999998899e-05, 0.020243397285414022, 0.0036825481637177138, 0.0315006684641832, 0.05317287077397925, 9.999999999998899e-05, 0.03452468278089926, 0.010880582888152635, 9.999999999998899e-05, 0.114651619576982, 0.08254420544501484, 0.08329075044182632, 0.08071233531243083, 0.08038889530439741, 0.134110458350987, 0.05860596427778619, 0.09049807391586384, 0.1097521363904792, 0.1404582212377885, 0.031725236539252855, 0.1582382542735875, 0.09396205781666345, 0.14298627397804697, 0.06464406034277703, 0.13491017894884516, 0.2218603405680415, 0.07327696232355752, 0.10728121713008676, 0.06124122232744289, 0.20037415258770097, 0.06538789279452017, 0.1739632367961964, 0.09736804889473372, 0.054138891643575104, 0.12756538295923214, 0.0792139034583137, 0.5130717581583435, 0.5089600008977764, 0.5408954045845986, 0.5264390797974781, 0.5272255626476637, 0.5461342713771165, 0.5771564803170668, 0.522941831613732, 0.572041851211347, 0.10289103832179403, 0.07475243706619261, 0.09393090630855672, 0.12296783491637964, 0.10966735175722875, 0.17711583359541205, 0.10585652365931453, 0.09507027950529168, 0.09918150146796145, 0.217211113926582, 0.21752936814388202, 0.13875013445273687, 0.1662223736455446, 0.23929420078086705, 0.28606617466213224, 0.2613072796884679, 0.1856490761209546, 0.17604958358647216, 0.4330078917838971, 0.2527620650932738, 0.46516165870639303, 0.2944273644274973, 0.4845600749854667, 0.45500432670959623, 0.47598501541586724, 0.5199571768224053, 0.47678614251838414, 0.29659131401788263, 0.3205574162311835, 0.3348333115186054, 0.33525382516136804, 0.32357365798266136, 0.30696398697675753, 0.2867877008106898, 0.36561553791687695, 0.3032267553659752, 0.23495963884384674, 0.20403475295995765, 0.19402353486214385, 0.19066433303703578, 0.22030184632648342, 0.18813662029770883, 0.19961276959251384, 0.1956439573321812, 0.21170455086041184, 0.18572147000974815, 0.19763612473345393, 0.24322560827897155, 0.1978067073357812, 0.683113497377104, 0.2466445228766625, 0.2150891663487038, 0.22057462452642118, 0.2217392461583767, 0.1858259603781124, 0.14765531276104937, 0.1528888880243754, 0.11475283725168794, 0.19959567411546086, 0.16737409830243155, 0.14191800656330722, 0.16103880379838353, 0.8846745855564793, 0.6960985430493383, 0.46552646759982963, 0.07344009107768812, 0.10452327840878262, 0.6049942765806932, 0.21008620541765177, 0.7538379446863454, 0.21032333316808005, 0.7778882348457072, 0.1869259265641524, 0.191078673016029, 0.18523248805135273, 0.21220535218879522, 0.188500769075987, 0.18935932677258893, 0.17536299514677134, 0.1850734660968748, 0.18937790708988433, 0.08618707459618125, 0.08251398413425215, 0.07482554290253574, 0.08469341982473033, 0.08545416904217795, 0.08018081696610513, 0.09144970416270481, 0.08384200751546234, 0.07867329581522664]}, "mutation_prompt": null}
{"id": "06a825d4-2604-40f3-8491-34d1197f3c93", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Multi-ensembling metaheuristic combining Differential Evolution and Particle Swarm Optimization with adaptive exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.815600596019181, 0.8183295947096153, 0.8158087964491292, 0.7954387800776193, 0.8196719443889423, 0.8069333951675549, 0.7991595328239514, 0.8096982088225466, 0.8161897191541639, 0.6054568617765137, 9.999999999998899e-05, 0.03421546439151679, 0.6497087925441614, 0.6124239874200631, 0.6022196149525951, 0.07158395216786595, 0.6118209441657432, 0.5930661153526676, 0.1375816538821697, 0.13170729289141492, 0.12338873740745238, 0.16849159906276567, 0.3616556998693844, 0.12296673253129176, 0.12646511498191848, 0.11524528114918253, 0.15338571697526238, 0.14336391243010582, 0.15755699191104866, 0.1203684685177534, 0.13693299417670246, 0.10859266438461124, 0.13990731550582347, 0.12842615274426183, 0.15820042980305116, 0.13467075720301003, 0.9540528466408826, 0.9641699567724942, 0.9641606055397473, 0.8995958186284435, 0.962964305497967, 0.9260550867116664, 0.9652170964003364, 0.9539677301153696, 0.9537798738319604, 0.4447084321829964, 0.4064709443405402, 0.41055297546986536, 0.4534630852628879, 0.43141800859915824, 0.3879956483741194, 0.39844389746903863, 0.413742286104121, 0.3930847374798905, 0.2257998409987747, 0.22697737898601023, 0.6681406147128479, 0.275737346666278, 0.7969627389725695, 0.2526374702613301, 0.2358416703878412, 0.7767028694744476, 0.7540445178248961, 0.2063835047407212, 0.1283410305725422, 0.18941335456048236, 0.12367133932457786, 0.12963911216520319, 0.17719134844749296, 0.19314459063381162, 0.19304014920159707, 0.20267285007044233, 0.1311255146586, 0.19628993653165627, 0.20499500795571768, 0.20019322874654222, 0.19722801913554222, 0.2454771655751461, 0.13245118305748615, 0.13870109789307483, 0.25669044575641187, 9.999999999998899e-05, 0.020243397285414022, 0.0036825481637177138, 0.0315006684641832, 0.05317287077397925, 9.999999999998899e-05, 0.03452468278089926, 0.010880582888152635, 9.999999999998899e-05, 0.114651619576982, 0.08254420544501484, 0.08329075044182632, 0.08071233531243083, 0.08038889530439741, 0.134110458350987, 0.05860596427778619, 0.09049807391586384, 0.1097521363904792, 0.1404582212377885, 0.031725236539252855, 0.1582382542735875, 0.09396205781666345, 0.14298627397804697, 0.06464406034277703, 0.13491017894884516, 0.2218603405680415, 0.07327696232355752, 0.10728121713008676, 0.06124122232744289, 0.20037415258770097, 0.06538789279452017, 0.1739632367961964, 0.09736804889473372, 0.054138891643575104, 0.12756538295923214, 0.0792139034583137, 0.5130717581583435, 0.5089600008977764, 0.5408954045845986, 0.5264390797974781, 0.5272255626476637, 0.5461342713771165, 0.5771564803170668, 0.522941831613732, 0.572041851211347, 0.10289103832179403, 0.07475243706619261, 0.09393090630855672, 0.12296783491637964, 0.10966735175722875, 0.17711583359541205, 0.10585652365931453, 0.09507027950529168, 0.09918150146796145, 0.217211113926582, 0.21752936814388202, 0.13875013445273687, 0.1662223736455446, 0.23929420078086705, 0.28606617466213224, 0.2613072796884679, 0.1856490761209546, 0.17604958358647216, 0.4330078917838971, 0.2527620650932738, 0.46516165870639303, 0.2944273644274973, 0.4845600749854667, 0.45500432670959623, 0.47598501541586724, 0.5199571768224053, 0.47678614251838414, 0.29659131401788263, 0.3205574162311835, 0.3348333115186054, 0.33525382516136804, 0.32357365798266136, 0.30696398697675753, 0.2867877008106898, 0.36561553791687695, 0.3032267553659752, 0.23495963884384674, 0.20403475295995765, 0.19402353486214385, 0.19066433303703578, 0.22030184632648342, 0.18813662029770883, 0.19961276959251384, 0.1956439573321812, 0.21170455086041184, 0.18572147000974815, 0.19763612473345393, 0.24322560827897155, 0.1978067073357812, 0.683113497377104, 0.2466445228766625, 0.2150891663487038, 0.22057462452642118, 0.2217392461583767, 0.1858259603781124, 0.14765531276104937, 0.1528888880243754, 0.11475283725168794, 0.19959567411546086, 0.16737409830243155, 0.14191800656330722, 0.16103880379838353, 0.8846745855564793, 0.6960985430493383, 0.46552646759982963, 0.07344009107768812, 0.10452327840878262, 0.6049942765806932, 0.21008620541765177, 0.7538379446863454, 0.21032333316808005, 0.7778882348457072, 0.1869259265641524, 0.191078673016029, 0.18523248805135273, 0.21220535218879522, 0.188500769075987, 0.18935932677258893, 0.17536299514677134, 0.1850734660968748, 0.18937790708988433, 0.08618707459618125, 0.08251398413425215, 0.07482554290253574, 0.08469341982473033, 0.08545416904217795, 0.08018081696610513, 0.09144970416270481, 0.08384200751546234, 0.07867329581522664]}, "mutation_prompt": null}
{"id": "3f728272-02d4-40ce-9f15-feee2e3ae596", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Multi-ensembling metaheuristic combining Differential Evolution and Particle Swarm Optimization with adaptive exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.815600596019181, 0.8183295947096153, 0.8158087964491292, 0.7954387800776193, 0.8196719443889423, 0.8069333951675549, 0.7991595328239514, 0.8096982088225466, 0.8161897191541639, 0.6054568617765137, 9.999999999998899e-05, 0.03421546439151679, 0.6497087925441614, 0.6124239874200631, 0.6022196149525951, 0.07158395216786595, 0.6118209441657432, 0.5930661153526676, 0.1375816538821697, 0.13170729289141492, 0.12338873740745238, 0.16849159906276567, 0.3616556998693844, 0.12296673253129176, 0.12646511498191848, 0.11524528114918253, 0.15338571697526238, 0.14336391243010582, 0.15755699191104866, 0.1203684685177534, 0.13693299417670246, 0.10859266438461124, 0.13990731550582347, 0.12842615274426183, 0.15820042980305116, 0.13467075720301003, 0.9540528466408826, 0.9641699567724942, 0.9641606055397473, 0.8995958186284435, 0.962964305497967, 0.9260550867116664, 0.9652170964003364, 0.9539677301153696, 0.9537798738319604, 0.4447084321829964, 0.4064709443405402, 0.41055297546986536, 0.4534630852628879, 0.43141800859915824, 0.3879956483741194, 0.39844389746903863, 0.413742286104121, 0.3930847374798905, 0.2257998409987747, 0.22697737898601023, 0.6681406147128479, 0.275737346666278, 0.7969627389725695, 0.2526374702613301, 0.2358416703878412, 0.7767028694744476, 0.7540445178248961, 0.2063835047407212, 0.1283410305725422, 0.18941335456048236, 0.12367133932457786, 0.12963911216520319, 0.17719134844749296, 0.19314459063381162, 0.19304014920159707, 0.20267285007044233, 0.1311255146586, 0.19628993653165627, 0.20499500795571768, 0.20019322874654222, 0.19722801913554222, 0.2454771655751461, 0.13245118305748615, 0.13870109789307483, 0.25669044575641187, 9.999999999998899e-05, 0.020243397285414022, 0.0036825481637177138, 0.0315006684641832, 0.05317287077397925, 9.999999999998899e-05, 0.03452468278089926, 0.010880582888152635, 9.999999999998899e-05, 0.114651619576982, 0.08254420544501484, 0.08329075044182632, 0.08071233531243083, 0.08038889530439741, 0.134110458350987, 0.05860596427778619, 0.09049807391586384, 0.1097521363904792, 0.1404582212377885, 0.031725236539252855, 0.1582382542735875, 0.09396205781666345, 0.14298627397804697, 0.06464406034277703, 0.13491017894884516, 0.2218603405680415, 0.07327696232355752, 0.10728121713008676, 0.06124122232744289, 0.20037415258770097, 0.06538789279452017, 0.1739632367961964, 0.09736804889473372, 0.054138891643575104, 0.12756538295923214, 0.0792139034583137, 0.5130717581583435, 0.5089600008977764, 0.5408954045845986, 0.5264390797974781, 0.5272255626476637, 0.5461342713771165, 0.5771564803170668, 0.522941831613732, 0.572041851211347, 0.10289103832179403, 0.07475243706619261, 0.09393090630855672, 0.12296783491637964, 0.10966735175722875, 0.17711583359541205, 0.10585652365931453, 0.09507027950529168, 0.09918150146796145, 0.217211113926582, 0.21752936814388202, 0.13875013445273687, 0.1662223736455446, 0.23929420078086705, 0.28606617466213224, 0.2613072796884679, 0.1856490761209546, 0.17604958358647216, 0.4330078917838971, 0.2527620650932738, 0.46516165870639303, 0.2944273644274973, 0.4845600749854667, 0.45500432670959623, 0.47598501541586724, 0.5199571768224053, 0.47678614251838414, 0.29659131401788263, 0.3205574162311835, 0.3348333115186054, 0.33525382516136804, 0.32357365798266136, 0.30696398697675753, 0.2867877008106898, 0.36561553791687695, 0.3032267553659752, 0.23495963884384674, 0.20403475295995765, 0.19402353486214385, 0.19066433303703578, 0.22030184632648342, 0.18813662029770883, 0.19961276959251384, 0.1956439573321812, 0.21170455086041184, 0.18572147000974815, 0.19763612473345393, 0.24322560827897155, 0.1978067073357812, 0.683113497377104, 0.2466445228766625, 0.2150891663487038, 0.22057462452642118, 0.2217392461583767, 0.1858259603781124, 0.14765531276104937, 0.1528888880243754, 0.11475283725168794, 0.19959567411546086, 0.16737409830243155, 0.14191800656330722, 0.16103880379838353, 0.8846745855564793, 0.6960985430493383, 0.46552646759982963, 0.07344009107768812, 0.10452327840878262, 0.6049942765806932, 0.21008620541765177, 0.7538379446863454, 0.21032333316808005, 0.7778882348457072, 0.1869259265641524, 0.191078673016029, 0.18523248805135273, 0.21220535218879522, 0.188500769075987, 0.18935932677258893, 0.17536299514677134, 0.1850734660968748, 0.18937790708988433, 0.08618707459618125, 0.08251398413425215, 0.07482554290253574, 0.08469341982473033, 0.08545416904217795, 0.08018081696610513, 0.09144970416270481, 0.08384200751546234, 0.07867329581522664]}, "mutation_prompt": null}
{"id": "7e0965b9-bf8f-44d1-92fb-12437a4f222b", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.temperature = 1.0  # Initial temperature for SA\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for iteration in range(self.max_iter):\n            # Adaptive parameter control\n            self.F = 0.5 + 0.5 * (1 - iteration / self.max_iter)\n            self.w = 0.9 - 0.5 * (iteration / self.max_iter)\n            \n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Simulated Annealing step\n            for i in range(self.pop_size):\n                candidate = pop[i] + np.random.uniform(-0.1, 0.1, self.dim)\n                candidate = np.clip(candidate, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                eval_count += 1\n                \n                acceptance_prob = np.exp((fitness[i] - candidate_fitness) / self.temperature)\n                if candidate_fitness < fitness[i] or np.random.rand() < acceptance_prob:\n                    pop[i] = candidate\n                    fitness[i] = candidate_fitness\n                    if candidate_fitness < personal_best_fitness[i]:\n                        personal_best[i] = candidate\n                        personal_best_fitness[i] = candidate_fitness\n                        if candidate_fitness < func(global_best):\n                            global_best = candidate\n\n            # Cooling schedule for simulated annealing\n            self.temperature *= 0.95\n\n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "AdaptiveHybridOptimizer", "description": "Adaptive hybrid algorithm blending Differential Evolution, Particle Swarm Optimization, and Simulated Annealing for dynamic exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.15202317431288825, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.2888863077822065, 0.2696744347192813, 0.3019943232328981, 0.32607675455807794, 0.3059718042609525, 0.3102387338148005, 0.2894319117446603, 0.3378856992303083, 0.279257182371786, 0.006695347314126021, 0.007175411094909712, 0.018442314490455414, 0.0018095313049072415, 9.999999999998899e-05, 9.999999999998899e-05, 0.004396344442611055, 0.0034596812274496624, 9.999999999998899e-05, 0.08936331909145123, 0.06754858479676018, 0.0734421267070331, 0.06143545169534459, 0.07327604397719656, 0.0512645354555048, 0.06705447590817015, 0.08289154274478128, 0.06487431604275407, 0.045576163688643256, 0.03489246021787418, 0.052462685621976424, 0.06154200314437652, 0.054593440654923664, 0.032325663476715616, 0.04980905727309359, 0.046126109977014274, 0.050228526598473766, 0.9178856270600713, 0.9491518570261601, 0.9433363588186808, 0.9717840910190269, 0.9332200257173352, 0.9116017160983985, 0.9529349405878406, 0.9506289591229496, 0.9490836601695447, 0.11072410818342482, 0.12157327138104013, 0.09497607246797257, 0.1054932623849465, 0.13911150801050587, 0.13688439160597976, 0.06418818302951734, 0.13803782652701846, 0.06552211366211103, 0.16557593771228918, 0.16634534975825466, 0.1576433443673776, 0.15732797227183126, 0.156395316897894, 0.1737560517208856, 0.19997268598833617, 0.20767609452529034, 0.1697511263089907, 0.0484417230615809, 0.004699765972928982, 0.06370441160932783, 0.07472277124066873, 0.09715327573656618, 0.07096936869687764, 0.08841546505936204, 0.09425020306279452, 0.08477480115452418, 0.08872154046476322, 0.06069880703368413, 0.07255055184146442, 0.1150317740323995, 0.04180092487966436, 0.10111208890551893, 0.04717755587072903, 0.019009831126844068, 0.051248693450658855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02417751106401489, 0.04283721711366706, 0.05353473402805742, 0.09202432755144396, 0.0228863472677453, 0.014737677525614945, 0.01855813019080288, 0.03709162156307433, 0.047221902294994234, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025764754085571995, 0.012057924214415427, 0.0306202959585129, 0.0270459336269121, 0.04071831312496177, 0.028615233526656958, 0.03590944577291755, 0.03289738449119484, 0.04481280499477658, 0.26671539564102587, 0.26932800848852934, 0.28615038220148326, 0.3160531269667557, 0.255352550834136, 0.2927192613917504, 0.3213511626141763, 0.2741566481040446, 0.3039334835117714, 0.06349674987057552, 0.07579349752512732, 0.059529671037910514, 0.0674630568491128, 0.058129056944258406, 0.061612617188761765, 0.05520032584596157, 0.06483389986117816, 0.05894181160938572, 0.13445846934118166, 0.12419791072312636, 0.13039814111500803, 0.1282875355262193, 0.14908501941522523, 0.1389741059136732, 0.1359222017896936, 0.1525398387801168, 0.13332046612660597, 0.15698953225325218, 0.18659030279482636, 0.19467975567772944, 0.2167002000942544, 0.20552540847096157, 0.21330451079397583, 0.22146940555931982, 0.22076539075802615, 0.18632039560757474, 0.14969370003587412, 0.14233699919415954, 0.15683416515798476, 0.1520781851633104, 0.11207168649046761, 0.1336060517185661, 0.15824572970215467, 0.15489170174921352, 0.143615980249166, 0.1684238629431175, 0.1899017752638248, 0.1704675654229193, 0.18384682296709443, 0.1700846897595788, 0.18199944354324027, 0.20805417466373655, 0.19707220054753294, 0.15686184553186633, 0.15441084076492684, 0.16258550823902118, 0.16607413394710746, 0.1717965057649159, 0.16109743760692363, 0.159381679788703, 0.17836114418915472, 0.16071100734346144, 0.16461045098273897, 0.17100431787985815, 0.15595722182177163, 0.16473294924786697, 0.17222585028565807, 0.1771222757189035, 0.3745763463013041, 0.14924416361357384, 0.14701130472809432, 0.14828357245535995, 0.20961863606291498, 0.17996129947843897, 0.150022940202847, 0.2063787773575384, 0.1365312467983656, 0.2172194105939269, 0.19957010614821424, 0.2193255180987096, 0.22883065726740714, 0.18335468222556395, 0.17908894882158433, 0.16801938016549534, 0.17064068999567839, 0.17903820627357547, 0.1809870493370057, 0.1866029623718789, 0.17113361085058254, 0.19172171413375316, 0.06275982753344944, 0.06380954859907362, 0.05794780589945381, 0.057182418370582466, 0.06044527344234962, 0.06944154427797022, 0.05687659233616271, 0.06221475463737347, 0.05994020961321733]}, "mutation_prompt": null}
{"id": "9ebc94df-1fde-4c6a-9470-b31f7acdfc06", "solution": "import numpy as np\n\nclass HybridMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Reduced population size for faster convergence\n        self.max_iter = budget // self.pop_size\n        self.F_min = 0.3  # Min differential weight\n        self.F_max = 0.8  # Max differential weight\n        self.CR = 0.85  # Crossover probability\n        self.w_min = 0.2  # Min inertia weight\n        self.w_max = 0.8  # Max inertia weight\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.7  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for iter_num in range(self.max_iter):\n            # Adaptive Differential Evolution step\n            F = self.F_min + (self.F_max - self.F_min) * (1 - iter_num / self.max_iter)\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x1, x2, x3 = pop[indices]\n                mutant = x1 + F * (x2 - x3)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Adaptive Particle Swarm Optimization step\n            w = self.w_max - (self.w_max - self.w_min) * (iter_num / self.max_iter)\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridMultiStrategyOptimizer", "description": "A hybrid multi-strategy optimizer combining Adaptive Differential Evolution and Swarm Intelligence techniques to efficiently balance exploration and exploitation for black box optimization tasks.", "configspace": "", "generation": 10, "fitness": 0.2192270511487107, "feedback": "The algorithm HybridMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.6052339657194501, 0.6137605595476427, 0.5755698776485658, 0.62798552200772, 0.6130268341239797, 0.639253551905218, 0.5784107693572513, 0.6623248435495337, 0.6065468307626326, 0.2609979930758666, 0.2593017313221856, 0.03019551197300574, 9.999999999998899e-05, 9.999999999998899e-05, 0.26570458272778663, 0.24395212746780648, 0.20619720712650946, 0.2837098038806999, 0.11190664160389385, 0.10669114431167914, 0.1086450555516878, 0.14332470849508683, 0.12452925180668206, 0.11813495999696677, 0.12505829174777505, 0.1259873690298573, 0.11569235575745462, 0.09201490411451319, 0.0857554802176157, 0.08592422644133313, 0.0958107736006607, 0.10251337797600812, 0.08873644663743485, 0.09615705839316524, 0.1101908242726859, 0.095016837513338, 0.9795887572083178, 0.9811411226200284, 0.9746091821762003, 0.9721321030501217, 0.9796005397448525, 0.9805922638579183, 0.9806054140472973, 0.9713965449606068, 0.9800485808243862, 0.21205766881924526, 0.19485882397062337, 0.21413422590196274, 0.14077663672881158, 0.17545571260513027, 0.22199197157117712, 0.07591774690233966, 0.08441154439982579, 0.1634220431820882, 0.21129895600944726, 0.40061855647225986, 0.3246454420454231, 0.11659919180432698, 0.18737932897970422, 0.180287614112695, 0.24721559997523468, 0.14354102116648793, 0.12518980203395036, 0.14400181949911273, 0.15254513529801517, 0.1318881565452672, 0.09696156656758304, 0.13924978301705526, 0.08096520948025632, 0.1501506411494261, 0.1010627726294131, 0.28236593115630526, 0.12920877638272954, 0.13252036628897734, 0.16092172645819103, 0.13755473282652697, 0.12406431896057524, 0.1373947845854402, 0.11285034601327737, 0.16198702571940926, 0.13535478618065921, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014488825796515892, 9.999999999998899e-05, 0.06266720977730822, 0.01326060481744129, 0.04712092063273543, 0.06301614598022187, 0.00013210625321768976, 9.999999999998899e-05, 0.03797495685016328, 0.07236234815937514, 0.06185466051300992, 0.11489119253508884, 0.07703425148535059, 0.02843248397127296, 0.11116478036316435, 0.04252527605804679, 0.07675652747780437, 0.06305600362214847, 0.12281068779897775, 0.05243647018000697, 0.06703366316010506, 0.1406742490089482, 0.06478438972492973, 0.09131849299691241, 0.03131725646558969, 0.20097329408753928, 0.06762005617630051, 0.06062011977823334, 0.07331475252215391, 0.4012627187152431, 0.42921722460924816, 0.41742338939015133, 0.42791092301390143, 0.20768044672652564, 0.44644470910651446, 0.442670737171873, 0.41287664781216216, 0.41872479596960843, 0.08910410306827876, 0.06930253291013744, 0.08385888469946479, 0.08404062746966268, 0.0782666236427525, 0.10207859512232897, 0.061020640156811745, 0.11109702801810639, 0.08346598345776568, 0.16173374205613322, 0.15049114205417502, 0.15727490575228453, 0.17184351616801707, 0.1945826293600671, 0.1621915485946136, 0.18149127240589846, 0.14926998671873426, 0.16361144811011685, 0.305385380623896, 0.20454775696037497, 0.26572047040538027, 0.24508019205667875, 0.28751494426023105, 0.27431095319770915, 0.302055929284329, 0.35239311140712737, 0.30491298806464706, 0.20187855375991415, 0.1742443509246301, 0.17760140756064013, 0.15795271750749285, 0.14564710019226057, 0.21339491101288155, 0.2268954599096712, 0.22647434332312855, 0.15566767146447213, 0.19351311063926235, 0.17696377892579807, 0.17089688909866274, 0.1880075820714222, 0.18813272852859164, 0.19095836853791837, 0.19702543395569394, 0.18590914342821474, 0.19985359200786001, 0.30828519503821894, 0.1880503765475896, 0.18381143982393822, 0.3503823902519212, 0.22039402805569563, 0.20532888869391708, 0.16579922190215823, 0.20154909074739358, 0.19168099603179656, 0.6158355693749751, 0.5441834875288822, 0.500035400678414, 0.16840111651640033, 0.19541024208879165, 0.19290603750536817, 0.1415986088201645, 0.5691033654250381, 0.5954888226851538, 0.29926686673239566, 0.20525768519338827, 0.14901550947652664, 0.16464864282274339, 0.3158100585565269, 0.29430995146336136, 0.19463285758698246, 0.19180934685063877, 0.3567669428014718, 0.18899822778851083, 0.1804796400210542, 0.18092938383916346, 0.17600863675031175, 0.17401923363981076, 0.19218850110860353, 0.20177709691756662, 0.18400988278157793, 0.18811701813516624, 0.08066348325734596, 0.05825980536632158, 0.07451581224039783, 0.06138750244089419, 0.0724766945140185, 0.07941034210770936, 0.06787073778551334, 0.0659509453542041, 0.061814816915948034]}, "mutation_prompt": null}
{"id": "5ec7542d-8127-4df3-9423-fa30cda79f00", "solution": "import numpy as np\n\nclass ResilientHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Changed population size for better exploration\n        self.max_iter = budget // self.pop_size\n        self.F = 0.6  # Adjusted differential weight for better convergence\n        self.CR = 0.8  # Modified crossover probability to enhance diversity\n        self.w = 0.7  # Increased inertia weight to maintain momentum in PSO\n        self.c1 = 2.0  # Increased personal attraction coefficient for quicker convergence\n        self.c2 = 2.0  # Increased global attraction coefficient for global exploration\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Adjusted velocity range\n\n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step with adaptive mutation\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                adaptive_F = self.F * (1 + np.random.uniform(-0.1, 0.1))  # Adaptive differential weight\n                mutant = x0 + adaptive_F * (x1 - x2) + adaptive_F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Enhanced Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "ResilientHybridOptimizer", "description": "Resilient hybrid optimizer combining improved Differential Evolution with dynamic parameter adaptation and enhanced Particle Swarm Optimization for robust global search.", "configspace": "", "generation": 11, "fitness": 0.1681085861036811, "feedback": "The algorithm ResilientHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.35913696295886444, 0.3253980419056769, 0.4044031596210066, 0.43697542753404894, 0.3490251813000623, 0.38175323820049334, 0.3595706597682876, 0.3884302057291006, 0.36200414889521415, 0.09135905800546351, 0.05382264630776101, 0.03282275053664274, 0.07903613947086285, 0.032593479880395515, 0.01369558047828634, 0.02414719481394112, 0.03243576587551067, 0.05503893074863231, 0.09810840460130343, 0.07942153105931227, 0.07002325681009092, 0.09753815789818421, 0.06126587659072469, 0.09271910739266764, 0.07485812635366018, 0.08148722799330843, 0.10030933669697772, 0.0452058438911348, 0.042799461951218865, 0.06397008894292122, 0.07484096238708993, 0.0869077181652127, 0.058786065803861476, 0.06952276950011693, 0.056270440468274896, 0.06349595405649122, 0.9722769680825201, 0.9585638898554789, 0.9726077669813127, 0.9637808078834104, 0.9457905286431328, 0.9611810411311555, 0.959749305207803, 0.9582956733819006, 0.9586363266290044, 0.14462279259580335, 0.15441109271714792, 0.1413228907689178, 0.13909301941358332, 0.12717965800158892, 0.15492897286841667, 0.1208875855190823, 0.12695146992367112, 0.13410416632685118, 0.17244752288693121, 0.22407950376025687, 0.17886939202019747, 0.18791830616682048, 0.18813830172038515, 0.20400462568799071, 0.14464770864598253, 0.2196193972334476, 0.19086547706234913, 0.1019634629735705, 0.07462759786364082, 0.09913916244788712, 0.08653376606775287, 0.11775868929071676, 0.10486261026616195, 0.1256469583843256, 0.10709993162309017, 0.13045551515072018, 0.08468636248209915, 0.09778424901346205, 0.08939683930618902, 0.09047192404987203, 0.08775822311641768, 0.10228728788482444, 0.11323233692288781, 0.01424160803991692, 0.07907392778216304, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03904962557689018, 0.06255371432651846, 0.047630291983438156, 0.0609061962572216, 0.03685828563130178, 0.044831773755297566, 0.020249449422010346, 0.03821944386163345, 0.026489115984524636, 9.999999999998899e-05, 9.999999999998899e-05, 0.00828127247313204, 0.001903909614622945, 9.999999999998899e-05, 0.0006729238393119452, 9.999999999998899e-05, 9.999999999998899e-05, 0.004968753342367238, 0.04512112509801369, 0.06566489057814162, 0.0839228526941328, 0.06308233958845211, 0.04339363757414416, 0.0616351106198153, 0.04033371169418676, 0.03750018312638037, 0.06354146222748114, 0.34119648519830326, 0.2799703824706039, 0.32220269013592207, 0.3662014874807452, 0.3118004479598736, 0.35415745051493186, 0.33566432372090593, 0.32786068642766175, 0.31021715263552174, 0.0796005377036314, 0.07917008481464327, 0.07280557854170089, 0.08736331777783779, 0.05745162922202085, 0.07767129028546238, 0.05777502999829465, 0.08559207800443258, 0.07320041320059134, 0.13527482620377274, 0.13782339988380432, 0.14819891739332158, 0.13766266535167793, 0.17608712579104102, 0.1411898895911119, 0.1604894768532229, 0.13110594617699334, 0.12368495110451228, 0.23580592636778142, 0.24799351145799986, 0.21948610574101035, 0.21408014163385902, 0.19325044645377942, 0.18791411042880746, 0.21834452039346275, 0.2723305211063326, 0.24467830214936326, 0.14275598100900022, 0.1468271404699859, 0.16616783626620368, 0.14302502893244962, 0.13615354525072765, 0.12627856482203026, 0.1654682829731695, 0.18905200314869186, 0.15237124073657038, 0.16602107297839908, 0.16523470869194878, 0.18511575971240335, 0.16936225743215705, 0.19204099261768015, 0.1704383684857712, 0.18526280569591158, 0.16969992078025953, 0.15804942109646347, 0.16230346195916168, 0.16515769417711545, 0.18851859764263312, 0.1597178324651548, 0.18185195924817799, 0.1829132117318144, 0.17007106655942694, 0.1578160952145785, 0.1620109859003398, 0.3067417647416454, 0.15172937101450046, 0.23150633133503296, 0.18733647522234187, 0.18487203521168605, 0.15376676382241916, 0.14034241153021976, 0.15494122877768857, 0.16849493254638415, 0.21949919574621468, 0.19144241790916572, 0.16394234701002408, 0.16598641840548423, 0.1915906073424406, 0.18133546723106364, 0.18623223528463273, 0.1959846749099009, 0.1502158201649516, 0.19220567147016399, 0.18335493496344624, 0.1773102110556769, 0.21455777197513215, 0.1840992340603841, 0.18391763298794306, 0.1866841583158454, 0.18442555163072283, 0.1908704404023266, 0.07079606561587315, 0.07424893812575795, 0.06468695722057216, 0.056625995875642876, 0.05322834217272343, 0.05659891327680777, 0.05864089399284034, 0.06673867979998926, 0.07213240543165178]}, "mutation_prompt": null}
{"id": "7cf1c970-9bc1-4126-9930-33d682e9124d", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.initial_temp = 1.0  # Initial temperature for SA\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        temperature = self.initial_temp\n\n        for t in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - trial_fitness) / temperature):\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            # Update temperature\n            temperature *= 0.95  # Cooling schedule\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Adaptive hybrid algorithm combining Differential Evolution, Particle Swarm Optimization, and Simulated Annealing with a dynamic cooling schedule to balance exploration and exploitation.", "configspace": "", "generation": 12, "fitness": 0.2705684703619652, "feedback": "The algorithm HybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.48006005141147756, 0.5038848447324256, 0.4461705392325772, 0.457157794324764, 0.5001259752759352, 0.4916057786797642, 0.4939449461432003, 0.45191980583378244, 0.46982729472568063, 0.40567568655470976, 0.3711003119943378, 0.3638891991520692, 0.36012045734620923, 0.3768520260209671, 0.3908901982707377, 0.3764298816403058, 0.38177582794180087, 0.36932300578611865, 0.14563720036228356, 0.1305348155917716, 0.16175959007123764, 0.14731677656170994, 0.17182409281160704, 0.14251659316776455, 0.14216592968912156, 0.14100318132190692, 0.15220540605198507, 0.11428299191481417, 0.11992424566608684, 0.11868740859505034, 0.128731314752355, 0.09400442093234362, 0.08571750819803836, 0.12465844827747863, 0.12586925443232377, 0.12527543682153597, 0.9517859387168467, 0.9191936639668918, 0.9660132437062511, 0.9288847680743957, 0.9543849741916055, 0.9547116814149657, 0.954965885390581, 0.9759963892224424, 0.962641079780824, 0.40304311146602534, 0.39382339668641775, 0.36154382857076894, 0.40892421407125146, 0.3585184795255435, 0.371350275859897, 0.3650737286477004, 0.36814739749334335, 0.41091910037693746, 0.6089732002548653, 0.6881214663402633, 0.22503730333659655, 0.7147248522091187, 0.7392975097385173, 0.2059088613429202, 0.6107150591074233, 0.5167446656249239, 0.7378412891832165, 0.19428012667697658, 0.20265877558872192, 0.20801758376172874, 0.10614647912799724, 0.21931116174342757, 0.1748980968306174, 0.20325532705652394, 0.21674079576402105, 0.22039725244330044, 0.24326135650058966, 0.12680239495152523, 0.21654605026019713, 0.23337386183595632, 0.23541564501207846, 0.2612435355245377, 0.1306482260279569, 0.2217182510382577, 0.2391922247075794, 0.009354548344513214, 0.06852909209631852, 0.042742813948079106, 0.0001827310105975144, 9.999999999998899e-05, 9.999999999998899e-05, 0.04896150150968692, 0.02969632323601712, 0.04182066136083973, 0.09453851615563602, 0.10735331031311668, 0.11902163422936318, 0.0723642093769038, 0.05654331745624819, 0.018700189208443185, 0.05849773210354503, 0.08077678233220464, 0.07272156701763466, 0.09765171030858377, 0.0314251205019731, 0.07539024419825746, 0.06648298563808752, 0.06976435887905807, 0.2543688777465878, 0.32559880457951085, 0.06332714971129882, 0.18384704447675282, 0.06149761217371519, 0.041148498806125255, 0.17715752095485315, 0.18730075230178977, 0.11384707758580093, 0.06615203942132863, 0.10387976918985498, 0.10212813998054193, 0.05538631878235212, 0.39352506308223834, 0.4314002394700479, 0.4245229116726793, 0.4199237295281779, 0.42135883451758327, 0.4429503595903238, 0.41589386004816054, 0.4348154963812052, 0.4219325372670192, 0.1281882097565218, 0.09813711922139723, 0.09011378411212467, 0.3168659903251789, 0.12057801607209839, 0.12011627520108137, 0.1378791283095281, 0.13862413756682168, 0.1061178651836634, 0.14045456892082142, 0.20087924745452912, 0.17256734938319096, 0.19512410799153124, 0.18488210910760328, 0.25437648287947834, 0.288669898542671, 0.16241041446943294, 0.22247494738714535, 0.3466678130535852, 0.3378314456444931, 0.3484650728567711, 0.33634134649552805, 0.34290018855821347, 0.3336069170030046, 0.3385388149762949, 0.3460460140814229, 0.3698785760639435, 0.2371399425631624, 0.21864506563354913, 0.2808777478751807, 0.29674504177140737, 0.25165168906172286, 0.3039550636956124, 0.2749940078435992, 0.30460252857650116, 0.33852458504033356, 0.2079757332593828, 0.19838242475207313, 0.20739829254760744, 0.2029677349111545, 0.19793496125482224, 0.19493884808400075, 0.21962887793476715, 0.20316851697389726, 0.2197280827842102, 0.23383540356712385, 0.2080769394248324, 0.21153605745543347, 0.22959612710303212, 0.4348417425507213, 0.2400203383764673, 0.21243389606893104, 0.23352613364068986, 0.22036499756132466, 0.12907821330757396, 0.14763686207221638, 0.1532669234674502, 0.6090308126021631, 0.1989331143527091, 0.19765602191558151, 0.141300064732797, 0.1624885429417149, 0.16710191568079968, 0.6750608661837717, 0.2094502626768957, 0.5235665247968153, 0.20873702618674295, 0.14685038438220566, 0.15248103362429044, 0.6064008023332816, 0.5753472054686545, 0.6250837726581021, 0.1983287661013634, 0.1925720070238981, 0.1838675742233824, 0.18643151143983927, 0.2172488683014524, 0.19125991068430415, 0.1950055377564769, 0.17699013852725143, 0.1949158317555011, 0.10045168080549738, 0.0776288276578585, 0.07181519500616018, 0.08491179920209246, 0.08043000814522916, 0.07559635422720967, 0.08432838853832758, 0.08181131736106584, 0.07875617518232358]}, "mutation_prompt": null}
{"id": "f2956b61-7438-4910-a9f2-dd8d5c67732a", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Multi-ensembling metaheuristic combining Differential Evolution and Particle Swarm Optimization with adaptive exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.815600596019181, 0.8183295947096153, 0.8158087964491292, 0.7954387800776193, 0.8196719443889423, 0.8069333951675549, 0.7991595328239514, 0.8096982088225466, 0.8161897191541639, 0.6054568617765137, 9.999999999998899e-05, 0.03421546439151679, 0.6497087925441614, 0.6124239874200631, 0.6022196149525951, 0.07158395216786595, 0.6118209441657432, 0.5930661153526676, 0.1375816538821697, 0.13170729289141492, 0.12338873740745238, 0.16849159906276567, 0.3616556998693844, 0.12296673253129176, 0.12646511498191848, 0.11524528114918253, 0.15338571697526238, 0.14336391243010582, 0.15755699191104866, 0.1203684685177534, 0.13693299417670246, 0.10859266438461124, 0.13990731550582347, 0.12842615274426183, 0.15820042980305116, 0.13467075720301003, 0.9540528466408826, 0.9641699567724942, 0.9641606055397473, 0.8995958186284435, 0.962964305497967, 0.9260550867116664, 0.9652170964003364, 0.9539677301153696, 0.9537798738319604, 0.4447084321829964, 0.4064709443405402, 0.41055297546986536, 0.4534630852628879, 0.43141800859915824, 0.3879956483741194, 0.39844389746903863, 0.413742286104121, 0.3930847374798905, 0.2257998409987747, 0.22697737898601023, 0.6681406147128479, 0.275737346666278, 0.7969627389725695, 0.2526374702613301, 0.2358416703878412, 0.7767028694744476, 0.7540445178248961, 0.2063835047407212, 0.1283410305725422, 0.18941335456048236, 0.12367133932457786, 0.12963911216520319, 0.17719134844749296, 0.19314459063381162, 0.19304014920159707, 0.20267285007044233, 0.1311255146586, 0.19628993653165627, 0.20499500795571768, 0.20019322874654222, 0.19722801913554222, 0.2454771655751461, 0.13245118305748615, 0.13870109789307483, 0.25669044575641187, 9.999999999998899e-05, 0.020243397285414022, 0.0036825481637177138, 0.0315006684641832, 0.05317287077397925, 9.999999999998899e-05, 0.03452468278089926, 0.010880582888152635, 9.999999999998899e-05, 0.114651619576982, 0.08254420544501484, 0.08329075044182632, 0.08071233531243083, 0.08038889530439741, 0.134110458350987, 0.05860596427778619, 0.09049807391586384, 0.1097521363904792, 0.1404582212377885, 0.031725236539252855, 0.1582382542735875, 0.09396205781666345, 0.14298627397804697, 0.06464406034277703, 0.13491017894884516, 0.2218603405680415, 0.07327696232355752, 0.10728121713008676, 0.06124122232744289, 0.20037415258770097, 0.06538789279452017, 0.1739632367961964, 0.09736804889473372, 0.054138891643575104, 0.12756538295923214, 0.0792139034583137, 0.5130717581583435, 0.5089600008977764, 0.5408954045845986, 0.5264390797974781, 0.5272255626476637, 0.5461342713771165, 0.5771564803170668, 0.522941831613732, 0.572041851211347, 0.10289103832179403, 0.07475243706619261, 0.09393090630855672, 0.12296783491637964, 0.10966735175722875, 0.17711583359541205, 0.10585652365931453, 0.09507027950529168, 0.09918150146796145, 0.217211113926582, 0.21752936814388202, 0.13875013445273687, 0.1662223736455446, 0.23929420078086705, 0.28606617466213224, 0.2613072796884679, 0.1856490761209546, 0.17604958358647216, 0.4330078917838971, 0.2527620650932738, 0.46516165870639303, 0.2944273644274973, 0.4845600749854667, 0.45500432670959623, 0.47598501541586724, 0.5199571768224053, 0.47678614251838414, 0.29659131401788263, 0.3205574162311835, 0.3348333115186054, 0.33525382516136804, 0.32357365798266136, 0.30696398697675753, 0.2867877008106898, 0.36561553791687695, 0.3032267553659752, 0.23495963884384674, 0.20403475295995765, 0.19402353486214385, 0.19066433303703578, 0.22030184632648342, 0.18813662029770883, 0.19961276959251384, 0.1956439573321812, 0.21170455086041184, 0.18572147000974815, 0.19763612473345393, 0.24322560827897155, 0.1978067073357812, 0.683113497377104, 0.2466445228766625, 0.2150891663487038, 0.22057462452642118, 0.2217392461583767, 0.1858259603781124, 0.14765531276104937, 0.1528888880243754, 0.11475283725168794, 0.19959567411546086, 0.16737409830243155, 0.14191800656330722, 0.16103880379838353, 0.8846745855564793, 0.6960985430493383, 0.46552646759982963, 0.07344009107768812, 0.10452327840878262, 0.6049942765806932, 0.21008620541765177, 0.7538379446863454, 0.21032333316808005, 0.7778882348457072, 0.1869259265641524, 0.191078673016029, 0.18523248805135273, 0.21220535218879522, 0.188500769075987, 0.18935932677258893, 0.17536299514677134, 0.1850734660968748, 0.18937790708988433, 0.08618707459618125, 0.08251398413425215, 0.07482554290253574, 0.08469341982473033, 0.08545416904217795, 0.08018081696610513, 0.09144970416270481, 0.08384200751546234, 0.07867329581522664]}, "mutation_prompt": null}
{"id": "ab1cf7e4-d4c4-46b5-b96c-adf105296bf8", "solution": "import numpy as np\n\nclass HybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.5  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for _ in range(self.max_iter):\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridOptimizer", "description": "Multi-ensembling metaheuristic combining Differential Evolution and Particle Swarm Optimization with adaptive exploration-exploitation balance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.815600596019181, 0.8183295947096153, 0.8158087964491292, 0.7954387800776193, 0.8196719443889423, 0.8069333951675549, 0.7991595328239514, 0.8096982088225466, 0.8161897191541639, 0.6054568617765137, 9.999999999998899e-05, 0.03421546439151679, 0.6497087925441614, 0.6124239874200631, 0.6022196149525951, 0.07158395216786595, 0.6118209441657432, 0.5930661153526676, 0.1375816538821697, 0.13170729289141492, 0.12338873740745238, 0.16849159906276567, 0.3616556998693844, 0.12296673253129176, 0.12646511498191848, 0.11524528114918253, 0.15338571697526238, 0.14336391243010582, 0.15755699191104866, 0.1203684685177534, 0.13693299417670246, 0.10859266438461124, 0.13990731550582347, 0.12842615274426183, 0.15820042980305116, 0.13467075720301003, 0.9540528466408826, 0.9641699567724942, 0.9641606055397473, 0.8995958186284435, 0.962964305497967, 0.9260550867116664, 0.9652170964003364, 0.9539677301153696, 0.9537798738319604, 0.4447084321829964, 0.4064709443405402, 0.41055297546986536, 0.4534630852628879, 0.43141800859915824, 0.3879956483741194, 0.39844389746903863, 0.413742286104121, 0.3930847374798905, 0.2257998409987747, 0.22697737898601023, 0.6681406147128479, 0.275737346666278, 0.7969627389725695, 0.2526374702613301, 0.2358416703878412, 0.7767028694744476, 0.7540445178248961, 0.2063835047407212, 0.1283410305725422, 0.18941335456048236, 0.12367133932457786, 0.12963911216520319, 0.17719134844749296, 0.19314459063381162, 0.19304014920159707, 0.20267285007044233, 0.1311255146586, 0.19628993653165627, 0.20499500795571768, 0.20019322874654222, 0.19722801913554222, 0.2454771655751461, 0.13245118305748615, 0.13870109789307483, 0.25669044575641187, 9.999999999998899e-05, 0.020243397285414022, 0.0036825481637177138, 0.0315006684641832, 0.05317287077397925, 9.999999999998899e-05, 0.03452468278089926, 0.010880582888152635, 9.999999999998899e-05, 0.114651619576982, 0.08254420544501484, 0.08329075044182632, 0.08071233531243083, 0.08038889530439741, 0.134110458350987, 0.05860596427778619, 0.09049807391586384, 0.1097521363904792, 0.1404582212377885, 0.031725236539252855, 0.1582382542735875, 0.09396205781666345, 0.14298627397804697, 0.06464406034277703, 0.13491017894884516, 0.2218603405680415, 0.07327696232355752, 0.10728121713008676, 0.06124122232744289, 0.20037415258770097, 0.06538789279452017, 0.1739632367961964, 0.09736804889473372, 0.054138891643575104, 0.12756538295923214, 0.0792139034583137, 0.5130717581583435, 0.5089600008977764, 0.5408954045845986, 0.5264390797974781, 0.5272255626476637, 0.5461342713771165, 0.5771564803170668, 0.522941831613732, 0.572041851211347, 0.10289103832179403, 0.07475243706619261, 0.09393090630855672, 0.12296783491637964, 0.10966735175722875, 0.17711583359541205, 0.10585652365931453, 0.09507027950529168, 0.09918150146796145, 0.217211113926582, 0.21752936814388202, 0.13875013445273687, 0.1662223736455446, 0.23929420078086705, 0.28606617466213224, 0.2613072796884679, 0.1856490761209546, 0.17604958358647216, 0.4330078917838971, 0.2527620650932738, 0.46516165870639303, 0.2944273644274973, 0.4845600749854667, 0.45500432670959623, 0.47598501541586724, 0.5199571768224053, 0.47678614251838414, 0.29659131401788263, 0.3205574162311835, 0.3348333115186054, 0.33525382516136804, 0.32357365798266136, 0.30696398697675753, 0.2867877008106898, 0.36561553791687695, 0.3032267553659752, 0.23495963884384674, 0.20403475295995765, 0.19402353486214385, 0.19066433303703578, 0.22030184632648342, 0.18813662029770883, 0.19961276959251384, 0.1956439573321812, 0.21170455086041184, 0.18572147000974815, 0.19763612473345393, 0.24322560827897155, 0.1978067073357812, 0.683113497377104, 0.2466445228766625, 0.2150891663487038, 0.22057462452642118, 0.2217392461583767, 0.1858259603781124, 0.14765531276104937, 0.1528888880243754, 0.11475283725168794, 0.19959567411546086, 0.16737409830243155, 0.14191800656330722, 0.16103880379838353, 0.8846745855564793, 0.6960985430493383, 0.46552646759982963, 0.07344009107768812, 0.10452327840878262, 0.6049942765806932, 0.21008620541765177, 0.7538379446863454, 0.21032333316808005, 0.7778882348457072, 0.1869259265641524, 0.191078673016029, 0.18523248805135273, 0.21220535218879522, 0.188500769075987, 0.18935932677258893, 0.17536299514677134, 0.1850734660968748, 0.18937790708988433, 0.08618707459618125, 0.08251398413425215, 0.07482554290253574, 0.08469341982473033, 0.08545416904217795, 0.08018081696610513, 0.09144970416270481, 0.08384200751546234, 0.07867329581522664]}, "mutation_prompt": null}
{"id": "b90b0001-0234-46a1-a359-ca444ffd7610", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F = 0.5  # Differential weight\n        self.CR = 0.9  # Crossover probability\n        self.w = 0.7  # Inertia weight for PSO\n        self.c1 = 1.2  # Personal attraction coefficient\n        self.c2 = 1.7  # Global attraction coefficient\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for iteration in range(self.max_iter):\n            # Adaptive Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + self.F * (x1 - x2) + self.F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Adaptive Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedHybridOptimizer", "description": "Enhanced hybrid optimization incorporating adaptive mutation and swarm intelligence dynamics for improved convergence.", "configspace": "", "generation": 15, "fitness": 0.2332603173338699, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.6503299169894586, 0.6359764332939752, 0.6097134233632653, 0.6294927875487828, 0.6251224011560181, 0.6316926924434241, 0.6304474991961617, 0.620575292220725, 0.6185319222368513, 0.2452208438622977, 0.2400951015806383, 9.999999999998899e-05, 0.05505594962807703, 0.23728617523058348, 0.26112140488504965, 0.04801190480420536, 0.29548581888588765, 0.26081727581177616, 0.12086372300171222, 0.10186760668190231, 0.1250506259280444, 0.11405751739589909, 0.12356978701254051, 0.07522190749571822, 0.09342327491592606, 0.10696132649399992, 0.11026400862213104, 0.12044772667476122, 0.0761890121260671, 0.0756234528956442, 0.10797285190320838, 0.10311442141449312, 0.09864541901399893, 0.11084417464411545, 0.08976446320226261, 0.1096676158419092, 0.9636273056050246, 0.9640947599150638, 0.9685630311605266, 0.9549410684629789, 0.9652505053037711, 0.9430190740642779, 0.9656235349026763, 0.9544090553259161, 0.9639038295045183, 0.23828287536429493, 0.23691615126494692, 0.24695167356984016, 0.2512127329181214, 0.31209113409771105, 0.23135048178212114, 0.2253388933585786, 0.2500153656344819, 0.2532065502877564, 0.2977765768920898, 0.2567755854920323, 0.2081959132570227, 0.2422329765654394, 0.4010482449256356, 0.23667357046546267, 0.5086137478926641, 0.3352101399281284, 0.2992800060469838, 0.15045004547399654, 0.16303241553358183, 0.17409758549423382, 0.16103280385464824, 0.1501376915807141, 0.17426866047726075, 0.1654307795699218, 0.1635924237988664, 0.16658958361769893, 0.1844140116314653, 0.20815457841450236, 0.12690821636282323, 0.17249676199715247, 0.17383792474840631, 0.16374617084877185, 0.12656001329177835, 0.1889788642226533, 0.14569416303463023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01369824436595024, 9.999999999998899e-05, 9.999999999998899e-05, 0.04646234881868072, 9.999999999998899e-05, 9.999999999998899e-05, 0.039030847272832014, 0.09006325245428393, 0.11332523214972734, 0.08789921647540888, 0.021918601955321915, 0.12683593796931858, 0.04626713866747045, 0.06595808253343471, 0.04228173231362653, 0.019614700652587636, 0.01708955778303134, 0.09581610666267515, 0.04299115973140377, 0.059847690182695645, 0.048053413875265294, 0.06357742378665387, 0.06786262675500276, 0.046382548792633815, 0.09483665579945677, 0.15106956139447214, 0.1502832606701704, 0.07002501097701264, 0.15073186361571767, 0.055875410078755516, 0.07967845185592082, 0.05123058816137471, 0.07363767353789574, 0.42639670889664816, 0.4803086251146935, 0.4392006952926627, 0.4619845685752959, 0.4756102965793132, 0.44600578893957077, 0.43524594865634936, 0.4266250503798793, 0.46209054630591784, 0.10594220051183378, 0.07622067882573957, 0.1011630312492241, 0.09659225029511531, 0.08482068471021897, 0.09631095831914904, 0.07639396354316419, 0.08685134397544081, 0.09418951478296678, 0.1672985664577018, 0.31456406754156807, 0.3164120805574364, 0.2749956120053959, 0.23011100639727866, 0.16882956960888895, 0.3074907755224634, 0.1676132278144562, 0.20264468221369447, 0.3058050142209363, 0.3281745614677608, 0.3082178472375591, 0.3223972892498732, 0.3109398411736328, 0.25890394403468187, 0.31911762758049567, 0.3117449465229881, 0.2614419612315898, 0.19604836187670116, 0.17821113295963897, 0.20995518874907593, 0.2242709249110304, 0.21897173980850237, 0.23906795825220128, 0.24501408970838434, 0.23512091908193766, 0.23472654638547064, 0.1846844056808845, 0.1763708394022807, 0.18790404933196347, 0.21129881061655897, 0.19358051138151522, 0.19723077964928626, 0.18142188545127824, 0.18551057378648206, 0.18607870006934346, 0.1724949209724035, 0.2129725699987135, 0.2123874913713265, 0.1996579272353982, 0.20022813265076334, 0.21491859262251456, 0.18495335518598943, 0.1972997126861593, 0.18271470808902646, 0.17168403013150035, 0.14664266330163378, 0.15260026279743688, 0.1675554855653525, 0.19576895402100403, 0.19414074910691714, 0.13909647777803824, 0.15841210800561134, 0.7991649718864661, 0.3639299628446, 0.328735854084537, 0.20164439749962648, 0.311578551870334, 0.16522271442943404, 0.20604938337884604, 0.4776158735141828, 0.20278991962488335, 0.589353575123793, 0.18699177862550298, 0.18692386307413833, 0.1733393518302555, 0.1787226990527384, 0.1702663662794094, 0.17503912029702118, 0.20293745154785792, 0.1827979328113506, 0.20451658054070032, 0.07851705776472118, 0.0697421468941275, 0.0896427019773528, 0.08225716089521118, 0.0793039709425557, 0.08124517652311092, 0.06087180195270503, 0.073675914679326, 0.09800365412574141]}, "mutation_prompt": null}
{"id": "c03e05a0-388e-4a7f-947b-91f92fd64a66", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Base differential weight\n        self.CR_base = 0.9  # Base crossover probability\n        self.w_base = 0.5  # Base inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.F_decay = 0.98  # Decay factor for differential weight\n        self.CR_growth = 1.02  # Growth factor for crossover probability\n\n    def __call__(self, func):\n        # Initialize population and velocity\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        # Evaluate initial population\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            # Adapt parameters over iterations\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            # Differential Evolution step\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            # Particle Swarm Optimization step\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Evaluate the new population\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            # Update personal and global bests\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedHybridOptimizer", "description": "Enhanced hybrid metaheuristic leveraging adaptive parameters in Differential Evolution and Particle Swarm Optimization for improved convergence.", "configspace": "", "generation": 16, "fitness": 0.29977229384838033, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "8649665b-d4de-4606-a935-2da6ed2feb5f", "metadata": {"aucs": [0.8231693428976063, 0.8177095948474176, 0.8346275875336231, 0.8090032324660038, 0.8219981574501286, 0.832908345797153, 0.8253695797570184, 0.825447532948703, 0.8263955086905241, 0.6128498111219118, 9.999999999998899e-05, 0.08047057863617779, 0.6208530873275744, 0.6337645477437384, 0.6699293706705562, 0.6216253150860165, 0.01704945525974433, 0.11930425487114904, 0.1420438801916244, 0.1123400464073635, 0.07098132301233673, 0.12663590914042666, 0.12507586806114412, 0.1677170905888945, 0.1343583051130567, 0.1366451012586647, 0.12321795913658573, 0.12133791857134857, 0.11673660556360776, 0.11307432088521763, 0.10904885510011286, 0.10627326509587731, 0.08250164486992195, 0.1265616957007505, 0.10768645106054953, 0.10391965567338612, 0.9540950352171346, 0.9641223022897251, 0.9623224102327995, 0.8768164339440855, 0.962642908937402, 0.9207660511123985, 0.9654159150813909, 0.9537396435588628, 0.9530824755472581, 0.5699410481855816, 0.5840984776610216, 0.5363065875177291, 0.526750087046697, 0.54391895663056, 0.5639245116848899, 0.5171749393514934, 0.47755063653839, 0.5382348913009871, 0.22732972259911843, 0.22734303331359096, 0.7447863753002317, 0.27835810694310914, 0.742967399308057, 0.1914558747711559, 0.24521562191372992, 0.23059163160671037, 0.8549841519261355, 0.15640770659168735, 0.14933519612847246, 0.19182089922162382, 0.12692235691692955, 0.13037689155129117, 0.1859607784982641, 0.15657020783103404, 0.18007380519402372, 0.2138070566342588, 0.2000105354825732, 0.13122151920540404, 0.166929758246667, 0.15879848155918552, 0.13792089414814435, 0.18988162617700088, 0.13111063839277215, 0.15262462978379188, 0.1291271725209333, 9.999999999998899e-05, 0.0317332988472786, 0.08862181322237972, 0.040966843698792, 0.05417433602428279, 9.999999999998899e-05, 0.03333632502335382, 0.028343807411708832, 9.999999999998899e-05, 0.0679977502135547, 0.1158408165042698, 0.09021962063219269, 0.07458699774473643, 0.05460852498978874, 0.15408890392821373, 0.10295056228201904, 0.07057751503880938, 0.11721049333895972, 0.09866802688607912, 0.032694244523691296, 0.13991640027649377, 0.18277446176482126, 0.08415068942194304, 0.0870240878189874, 0.09827369427954913, 0.10111387534565042, 0.06794930278998779, 0.16554091391396397, 0.033431209083584656, 0.1402517380884487, 0.08218879239951382, 0.21545961376848977, 0.12977841154102976, 0.07935977924230142, 0.1251569800443516, 0.134141412948257, 0.5913584312791369, 0.5613438793191383, 0.5876298181041115, 0.5683054230915178, 0.5778734795577496, 0.5624273203013108, 0.5497850428387558, 0.5752665253277223, 0.574867435601961, 0.15117405619942892, 0.08017656369821269, 0.10177574397994826, 0.10732165871604815, 0.12692544592851973, 0.12006020329885525, 0.08934768381321356, 0.11860800689802709, 0.1346141011343156, 0.19743528782659658, 0.15493841594133906, 0.18187398750332207, 0.2521682942811758, 0.5377380070716763, 0.223219475377749, 0.3732699083820846, 0.24911262714486893, 0.34989711938732493, 0.48222440749754003, 0.3071334408430958, 0.5219846843069812, 0.3514042491842777, 0.356941423395186, 0.5304439436562279, 0.3424986341356381, 0.5427159676894053, 0.49566678910323303, 0.3128663958874639, 0.2646986126070695, 0.3230682478654028, 0.28556017128860123, 0.429059679530554, 0.2608525900063374, 0.3907487135624339, 0.29702318388820104, 0.2611912365609663, 0.19052020383854218, 0.22098409478424053, 0.21166984584967263, 0.20477806012188549, 0.21254983130164162, 0.20847573465295366, 0.21122760555458653, 0.20044358438938592, 0.22091652824147734, 0.2167496217599303, 0.20431245219180783, 0.19624828033213948, 0.19126488933226948, 0.19335147774406303, 0.24694358985679143, 0.20955982963656672, 0.2140811280156255, 0.23228897987700958, 0.18601028509839201, 0.14785056772714378, 0.15291835285428168, 0.8371066352948312, 0.19996290294911856, 0.16769131420635874, 0.7414768530067324, 0.16168685244675363, 0.8851200141729956, 0.737245517499734, 0.22868185420755938, 0.07341218737608401, 0.20547005213406377, 0.16652866322853188, 0.21004568771805154, 0.858611316643181, 0.21039424765543469, 0.8310132538180997, 0.18183153231916982, 0.18088188843975905, 0.19462014159380736, 0.1955710601843963, 0.18981188273269423, 0.19054648442932753, 0.1761078010016266, 0.19424221216487536, 0.17902416438151725, 0.08757245652695345, 0.0875660412108753, 0.08621837990552561, 0.07408557174783637, 0.0877960633980065, 0.08565564777245038, 0.10197915073567132, 0.08326517721989257, 0.08685338177741375]}, "mutation_prompt": null}
{"id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 17, "fitness": 0.3049099570695631, "feedback": "The algorithm QuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "c03e05a0-388e-4a7f-947b-91f92fd64a66", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "ace8ff03-f9cd-4d19-a370-23380464895f", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "1d14ff8b-ff97-4701-97da-02edfe1e041a", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight for exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 2.0  # Enhanced personal attraction coefficient\n        self.c2 = 2.0  # Enhanced global attraction coefficient\n        self.random_factor = 0.3  # Added randomness factor for mutation\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (1 - t / self.max_iter)\n            CR = self.CR_base\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                random_vector = np.random.uniform(-self.random_factor, self.random_factor, self.dim)\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0) + random_vector\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Fusion of Quantum-inspired Differential Evolution and Particle Swarm Optimization with adaptive randomness and learning mechanisms for enhanced exploration and convergence.", "configspace": "", "generation": 19, "fitness": 0.25974441654463537, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7440860598372483, 0.731233926506898, 0.7136675139250448, 0.7417115432731491, 0.760875179053389, 0.7286807795841673, 0.6913880331138795, 0.7429423558677597, 0.787582363351152, 0.4866595941097165, 0.5282460817005161, 0.49589133051585355, 0.4400022959297205, 0.4992051063398524, 0.5027051039119117, 0.4671629221212974, 0.5497324286870855, 0.4501124520038917, 0.10964083482434905, 0.08096937583804775, 0.13129367668129543, 0.10567755073499852, 0.1376572655065409, 0.13026214812005255, 0.09958062204181606, 0.10426111811516525, 0.09198005313580304, 0.09652327054770993, 0.09670021322140876, 0.1319981356670762, 0.1278915608676825, 0.08662560895553995, 0.10333275091469352, 0.1364328785596095, 0.09249948483224979, 0.09021730882109202, 0.978541213203573, 0.9805260087120845, 0.9723571596872628, 0.947758735876553, 0.9636432876488784, 0.9700405915599746, 0.9717832466944254, 0.9724850584385069, 0.9717040640749477, 0.24505026593749346, 0.25563943411724344, 0.23254220854591146, 0.22991631125288825, 0.2331761767541788, 0.24061850515447225, 0.23448446969206083, 0.22754712280020317, 0.2448578094435797, 0.22683122335245642, 0.2617948447022488, 0.2579228070018229, 0.274227651885113, 0.33769935497202985, 0.2911285931628157, 0.19351184176677316, 0.5604442078660263, 0.2815066123604312, 0.1490133988749598, 0.1752837120937225, 0.16450750978815265, 0.15176600482219804, 0.15656705283927785, 0.13462928621168246, 0.1449770706040714, 0.1571369003831793, 0.14483327872394836, 0.14454497971797742, 0.12380705648329371, 0.17580007514913798, 0.18555767823185565, 0.13977558767299803, 0.16388253729239, 0.15327252840968464, 0.1694624591582593, 0.30028723054051043, 0.0008042360140040339, 9.999999999998899e-05, 9.999999999998899e-05, 0.004439374308443433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04975142051171155, 0.05980400359136806, 0.041446222269820976, 0.09562731515091294, 0.09544558822989513, 0.0891136822575731, 0.02614717115537679, 0.05618350285854634, 0.05201224308365959, 0.06118187792941021, 0.027155416601695515, 0.13664411357600748, 0.12275489994974687, 0.1520952470900775, 0.07769729861102892, 0.07379960194724267, 0.0899334150694967, 0.09030732515727413, 0.06184136578908617, 0.03382868095389169, 0.16844776578434684, 0.08323648570561182, 0.17777864527247433, 0.1788484620178188, 0.1187160817794094, 0.07830383906593053, 0.0874462450114768, 0.07983350426522562, 0.4951327059939171, 0.43562229699400146, 0.4813927273474853, 0.48780549478161583, 0.5202397918775712, 0.48081000234009696, 0.4426579123691087, 0.4646642641361748, 0.44092463564596096, 0.09736375522686358, 0.0790244816307708, 0.08618469213133106, 0.08367350924948147, 0.07105789139966423, 0.09343255545143858, 0.07666377396320656, 0.0900706605132624, 0.09105034069995077, 0.1594196621537769, 0.22922182376838807, 0.16169745324737783, 0.15877464172926814, 0.1588783068783579, 0.15025977403560176, 0.1754349291100179, 0.16782068826903707, 0.23753160689118868, 0.2604804704891662, 0.34439186833780655, 0.27458004956891746, 0.2481248223634437, 0.33604425296825846, 0.29748718224789494, 0.23184574200779806, 0.34769554153083526, 0.28011627700770914, 0.24134435448942393, 0.24587815073886188, 0.2141675556612166, 0.26256006125058806, 0.2144310128872584, 0.21376243875194567, 0.1991157228372069, 0.21551956265881533, 0.2507747125423079, 0.17119634896978497, 0.1647901772750796, 0.18744986667974228, 0.18992708686574655, 0.19390279363899776, 0.20811248148408046, 0.2042517976464684, 0.17728431608818007, 0.2133109317846219, 0.17250427833253668, 0.21711014806317308, 0.17759044138169033, 0.2020916107740196, 0.1852300715373627, 0.20457298811539626, 0.1864360551917451, 0.23552881901205158, 0.18844536731954176, 0.18363556448538076, 0.17238271532578764, 0.1527702545960894, 0.7749091000119083, 0.7622797698619977, 0.7706851482984782, 0.5940314652841896, 0.6913156064112154, 0.506671547664582, 0.3659574377307643, 0.2072377889331135, 0.3347939966570822, 0.3656371856319156, 0.20922046968733332, 0.2089881167928409, 0.10442415671814886, 0.3036482896953894, 0.28804380563776866, 0.17409799508111812, 0.1835590529091542, 0.1832023070925698, 0.1777688502265986, 0.18795596286406613, 0.20958503499048553, 0.18293664163089884, 0.2014667408739922, 0.18338199038415826, 0.07117657247693565, 0.06718437342161088, 0.08104601202983797, 0.07795569530306035, 0.07932332171747458, 0.06584628760239208, 0.08123291267237998, 0.07491836196465662, 0.07116059275379227]}, "mutation_prompt": null}
{"id": "6068f1d7-c68b-4c67-b84f-6afa7c2c313d", "solution": "import numpy as np\n\nclass QuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.4  # Adjusted personal attraction coefficient\n        self.c2 = 1.6  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.03  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.6 + 0.4 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumSwarmOptimizer", "description": "Strategic Evolutionary Swarm Optimization integrating Adaptive Quantum Dynamics for enhanced exploration and exploitation balance.", "configspace": "", "generation": 20, "fitness": 0.2931121343469527, "feedback": "The algorithm QuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8270350588848561, 0.8102325996190439, 0.8166463627632738, 0.812750707092326, 0.8200748122325038, 0.8093352455543427, 0.8249145616054239, 0.8292331786341853, 0.8163638723830017, 0.6476087132981037, 0.14998314378873623, 0.6238646928804737, 0.5940578828936313, 0.5996573615441112, 0.6494357313456396, 0.5760111536972247, 0.6395349585208268, 0.5671743874549078, 0.09230374887581516, 0.1759123775408773, 0.13061345374185018, 0.13097258458148664, 0.13728541519544946, 0.09036292523228973, 0.12261222739372313, 0.09204804355085727, 0.14556741881510138, 0.12370227864538208, 0.1301667980970289, 0.11851042224720498, 0.0985231556105628, 0.10445590488173062, 0.13519991789563535, 0.13873779045925316, 0.1349008045244564, 0.09755586004411343, 0.95449324962808, 0.9540951171741425, 0.9632828029708236, 0.9329145908483373, 0.9670161818660082, 0.9327649661557352, 0.9648475487688581, 0.9655421653572402, 0.9666943433650225, 0.5828599618050614, 0.5639640671763014, 0.1750262347059135, 0.15193535959319326, 0.5530135072648759, 0.5639096397782087, 0.04241463024733638, 0.5057116034773474, 0.588312987399793, 0.17190608097948534, 0.17078293244764353, 0.2264553274836505, 0.20707835173280065, 0.7567295898947249, 0.18937197628310087, 0.38190467903376635, 0.7657154689510884, 0.23400925664008942, 0.19047426260360134, 0.12261295697267982, 0.1720969069719882, 0.11145400069347433, 0.12782970065308652, 0.12924969740332148, 0.1804003247410626, 0.17064558235905491, 0.12478896750327784, 0.22817617306423776, 0.1546449479051606, 0.11904363628984971, 0.1717353946686051, 0.11650093832043806, 0.22310264288263748, 0.14075111404434504, 0.09965785907585034, 0.19872291704202438, 0.0008696595227882797, 0.006464662772447394, 0.007965505304870946, 9.999999999998899e-05, 0.020857611976967005, 9.999999999998899e-05, 0.03358421628519137, 9.999999999998899e-05, 0.049188206893496345, 0.11136260369292683, 0.17448941268334894, 0.1123310333458245, 0.16204294047793721, 0.10164746599008212, 0.061422994516936114, 0.037937848132140406, 0.07962284476017545, 0.0776537423654532, 0.1540130504608569, 9.999999999998899e-05, 0.2717645260913726, 0.11424426791552522, 0.10652738192412381, 0.08576377313005723, 0.29754475628057675, 0.13171428556668052, 0.12448385103942405, 0.07603631237098285, 0.25908672296952806, 0.04276421181603507, 0.043696264835360266, 0.06969567767719076, 0.006514908093610439, 0.18958520321470496, 0.08601677669688257, 0.08024983668950247, 0.5153210879143226, 0.538277492103272, 0.5911989184217757, 0.5747014408839324, 0.5556155106500711, 0.5550462611139894, 0.6144242515396219, 0.5639198040155566, 0.550795421182352, 0.13244469465057795, 0.07411798589411556, 0.14811779990991403, 0.11471438805195378, 0.1277788601093105, 0.11126321470791212, 0.15319759797347854, 0.13366704116570471, 0.11312371587971681, 0.36169758198122326, 0.18619511292982938, 0.23051818555662695, 0.27008705460953597, 0.26142174152893016, 0.2338578965431558, 0.1787528988745427, 0.25080128675280444, 0.21973062221073647, 0.4503944806374205, 0.23483346492458246, 0.4261645243457902, 0.37859125153183515, 0.3313216057565609, 0.4675101610663225, 0.5301016613410099, 0.31007377898574817, 0.4447858107071593, 0.2615905913826767, 0.2177880309718112, 0.29743564684590906, 0.18637871671645256, 0.24217755793134788, 0.2619733994097324, 0.30641473961544075, 0.3572026129421755, 0.2702055981230088, 0.20680311841220578, 0.23275127453802846, 0.2051652403648263, 0.24126830715917447, 0.18303225321782213, 0.21916922592548638, 0.2003111529916437, 0.21895501678627172, 0.22676956410929905, 0.20300463206283792, 0.6824079198268642, 0.20219500017643655, 0.19114444284203524, 0.2215196592606158, 0.2477751447819534, 0.1868727303863097, 0.19699103698867926, 0.2143747249614607, 0.16571239712368568, 0.15706758018423173, 0.151905965322096, 0.8718260029329896, 0.1996325940087036, 0.8788265006064315, 0.14208853645163322, 0.1622633311856887, 0.8751880514827257, 0.3867972713212876, 0.2088486630198262, 0.12534845910549797, 0.6731370711552572, 0.15336935637714555, 0.1682785178982491, 0.10447288685529887, 0.750563163896592, 0.09352095463558852, 0.19153333216394186, 0.18310628023188613, 0.17711847416070792, 0.17949337941257293, 0.18499931722272644, 0.19030436020590347, 0.1896215087222597, 0.17640861797435015, 0.1835732058844639, 0.08333873610185072, 0.08863186135860557, 0.07996169625331351, 0.08894076988266497, 0.09032710627502405, 0.08234744883597234, 0.08047204041044609, 0.08611274796583146, 0.08531213589268316]}, "mutation_prompt": null}
{"id": "81160648-f35e-4985-80dd-3f0124258934", "solution": "import numpy as np\n\nclass QuantumAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.03  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumAdaptiveOptimizer", "description": "Hybrid Quantum-inspired Metaheuristic blending Adaptive Differential Evolution and Particle Swarm for enhanced exploration and exploitation balance.", "configspace": "", "generation": 21, "fitness": 0.29798480520689274, "feedback": "The algorithm QuantumAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8082352635991976, 0.7945223928766574, 0.7874969901127719, 0.7991628962210837, 0.8037933768367278, 0.8008857313053469, 0.7951942352319438, 0.7962431152879524, 0.7970338497676621, 0.5690800788252407, 0.5238550409250329, 0.5778954570625784, 0.5862786575499144, 0.5815547346990252, 0.6053911076828076, 0.544110367620717, 0.6000764919930994, 0.05280087616586393, 0.09673821960451168, 0.14227437951363497, 0.15035039140811646, 0.1422672459710964, 0.15200405905424863, 0.07194521147873367, 0.12498369822569222, 0.4915971438970136, 0.17258052269559798, 0.10758304450283773, 0.11391485929773904, 0.1077993250239282, 0.11881863283870275, 0.12052223273655904, 0.10697985899896689, 0.12311239861024748, 0.10502037419219179, 0.10111094786650898, 0.9574121197206361, 0.9435721516087421, 0.9550851294877261, 0.9703367956690062, 0.9561302485722407, 0.9288681360871734, 0.9718096603372568, 0.9588276709955386, 0.9576576812283171, 0.5261932006639094, 0.46150743534829375, 0.5053449015222711, 0.4820775560207098, 0.5530348168535106, 0.16217218718365312, 0.4957511245931021, 0.50263542411347, 0.5192364023971641, 0.2243298488658213, 0.3734713274396919, 0.7972968974777015, 0.36903719723077844, 0.8272066533034423, 0.78138197109248, 0.329151161712383, 0.2193125017365234, 0.23108826978082875, 0.1841065915651785, 0.13436332162849596, 0.17864879432552694, 0.1772693779254385, 0.1252570643434765, 0.16295603502133238, 0.1510303905562047, 0.15123120987500938, 0.17645329398703047, 0.125413394996297, 0.12437719926825797, 0.10485828532289143, 0.24108765395002907, 0.1743403203413253, 0.15401936297283358, 0.15761966088556234, 0.21157932005003455, 0.15627153157383766, 0.004962562568601281, 0.006296957931555935, 0.04868486184818288, 0.0002497429470329493, 9.999999999998899e-05, 9.999999999998899e-05, 0.007996426589382044, 0.0065550214776407545, 9.999999999998899e-05, 0.10680283246541389, 0.07014809411565348, 0.05294602343291466, 0.13740486685525377, 0.04260833579649348, 0.07060536272015927, 0.1154826989303891, 0.12288250261806866, 0.05506669352873084, 0.10105631451708619, 0.03116279162490132, 0.1246905213000753, 0.1548867263503222, 0.06948310628069321, 0.16981358653836165, 0.08769689909232714, 0.13885045126161044, 0.3863615316140112, 0.16701303189267092, 0.08011520476542577, 0.08706154493609608, 0.12504648399750407, 0.1574411043845767, 0.24739383986994756, 0.19031763005616198, 0.19726536353207635, 0.07712937869240977, 0.5038169326132733, 0.5087651693574406, 0.5201122450322996, 0.5330983989182392, 0.5605586384522635, 0.5245832201101852, 0.5964016658305189, 0.5438804248683233, 0.5491028189675553, 0.08895677457406725, 0.10690201974593072, 0.11751078588492969, 0.2903974222452185, 0.10091164510718043, 0.11957971836200121, 0.4852889839943477, 0.36100660333289347, 0.1072064755345371, 0.22680562630885315, 0.3879981210796173, 0.18851637675294775, 0.21116086050478544, 0.2900246472698673, 0.18816039762754233, 0.1924110438265758, 0.2562073511811773, 0.2764512964343474, 0.40116884278461884, 0.35603877225069713, 0.472804033309725, 0.42345886924950105, 0.2109662640269243, 0.40388803477211466, 0.4386705667476605, 0.28574333439983624, 0.3749174794245903, 0.2843363115424792, 0.37864642242763524, 0.24102276511578258, 0.22400306350171317, 0.3929903362332068, 0.29416147495819756, 0.2372009961589978, 0.29624044168517016, 0.31833430910632055, 0.19887488097624706, 0.19975337305648655, 0.19666742833726147, 0.22707147502046854, 0.2048839221958968, 0.23293506693245314, 0.1946712187165518, 0.20449435700962937, 0.19441681385215914, 0.18768536009620007, 0.19765158022940288, 0.23947996163852492, 0.20348656507958163, 0.21716231547627762, 0.19254551802426256, 0.19477242237929349, 0.236261725157064, 0.2172972099674655, 0.1769022414231447, 0.8454016593095903, 0.16967807144653946, 0.1666421058379317, 0.19827484684276453, 0.14678457929108646, 0.14093102731582785, 0.17673915021565478, 0.8558337924713985, 0.7460402237877555, 0.21070624290325646, 0.48222434734517083, 0.1267960696785776, 0.20843753998755543, 0.1534670347583178, 0.11212963831934486, 0.6374306535057375, 0.09439288974348548, 0.17750760891992634, 0.1830168587277743, 0.18482410921776704, 0.1786846334953328, 0.1914458748177783, 0.19945579660959678, 0.1809459095135698, 0.18217353394813662, 0.18530396971892715, 0.0892336736879924, 0.08555958174283063, 0.08132824451275611, 0.08568585083540581, 0.08514841721734101, 0.07821929540195582, 0.08984887690332655, 0.08938221338250807, 0.09181920225263673]}, "mutation_prompt": null}
{"id": "28ec4832-486e-44c2-9914-e7b4acccc864", "solution": "import numpy as np\n\nclass QuantumDifferentialSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Modified personal attraction coefficient\n        self.c2 = 1.5  # Modified global attraction coefficient\n        self.F_decay = 0.9  # Decay factor for differential weight\n        self.CR_growth = 1.1  # Growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumDifferentialSwarmOptimizer", "description": "Hybrid Quantum Differential Swarm Optimizer with Adaptive Parameters for Enhanced Flexibility and Convergence.", "configspace": "", "generation": 22, "fitness": 0.26328076810858186, "feedback": "The algorithm QuantumDifferentialSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7422824394644908, 0.7354592707340425, 0.7473262476766162, 0.7528906698995668, 0.7189884583815545, 0.7429866024445291, 0.7383611668629408, 0.7286479961788528, 0.7125433860614451, 0.4290616122180346, 0.4328689751888325, 0.47278621971443935, 0.4550851138671155, 0.48699420115321657, 0.10029356204184425, 0.0769069225070329, 0.4473437074477753, 0.4485849547007581, 0.10241887002425121, 0.12495711275026156, 0.12986425993243234, 0.1276424333351318, 0.15292293872506857, 0.0701612279002346, 0.10523791593607745, 0.12576111159830017, 0.12282593342522619, 0.09587946642062584, 0.1396878315958887, 0.1182076424559435, 0.1431272198125806, 0.13706879945202566, 0.1149216066873876, 0.11875923357487483, 0.1220693894046817, 0.11443950096352073, 0.9550975284937517, 0.9657187101052394, 0.9758934588201497, 0.9649799844685577, 0.9428459271813107, 0.9661386037118765, 0.9660027764393337, 0.9720270658940521, 0.961698679773085, 0.37295834779661197, 0.40867428663343075, 0.10234652045838466, 0.40259349536778455, 0.429239478674867, 0.30869448079009876, 0.40909530483542667, 0.4168701998373746, 0.4051430783266071, 0.22165080353858901, 0.7815062435066256, 0.5998537044756576, 0.7600405326952612, 0.2042765788982992, 0.18828008750519576, 0.35151480660234014, 0.6854140660466086, 0.23275874892563297, 0.15420309874065097, 0.17225192043546755, 0.16163654638269054, 0.16499237408505563, 0.1513275595327772, 0.1651845933347117, 0.16935044650909326, 0.1090547946615752, 0.23491043078873775, 0.1896155243562988, 0.10686533268105336, 0.21470538181670884, 0.122311992659064, 0.16268070982916072, 0.13426903079738572, 0.11789584159495958, 0.18354286946296927, 0.25277245679564586, 0.02462270862182414, 0.016210371058160145, 0.027675197495556136, 9.999999999998899e-05, 0.014764356097893172, 9.999999999998899e-05, 0.01748526964468744, 0.016561330677017927, 9.999999999998899e-05, 0.07212558064579522, 0.08385239548116297, 0.1105371170513696, 0.09182119577424874, 0.06078559244677362, 0.011565489100545556, 0.06046802189475553, 0.07585881810511441, 0.045847375684374136, 9.999999999998899e-05, 0.030717437382687618, 0.036569682664277625, 0.15382337054465278, 0.07072641781072764, 0.08632687761329949, 0.07793647519686675, 0.07339685883253166, 0.07473474226164911, 0.09621280388024989, 0.11873367171064597, 0.22846444509958252, 0.07586937370063984, 0.06717018918994311, 0.0909809981186388, 0.1871982983872852, 0.05288103886924711, 0.16694935153622714, 0.47311408690425416, 0.5339680947153307, 0.5046339967876057, 0.5171650214004364, 0.5191282054658233, 0.5190013091168321, 0.5275798441574717, 0.4935575723564498, 0.5164321481449162, 0.09042065083834327, 0.12165561269932701, 0.07715225149143679, 0.12747149051192797, 0.08870766291248744, 0.09869164462339963, 0.11719285549477587, 0.1002595772084407, 0.10521949902300909, 0.1651425826307562, 0.16858412135530798, 0.15190846930805857, 0.2028513700344663, 0.19587972990652758, 0.2810830964119442, 0.23004613917914318, 0.25433819014322634, 0.23557163131499326, 0.3285092672421358, 0.31546358187064494, 0.2970734686677666, 0.22611306152685118, 0.3489345399966207, 0.35189363511160276, 0.3163856897045434, 0.42916957021102775, 0.17227390977390933, 0.19983838311121171, 0.22346096207803634, 0.24645939870802513, 0.2713832441661844, 0.2755886596252868, 0.22247245257454829, 0.20108518434752742, 0.2735275700282508, 0.2869870062955985, 0.21533614762172204, 0.2134896119993972, 0.19825984501706106, 0.2051901346202929, 0.1893700094183851, 0.21275881892824555, 0.19849025288112454, 0.20022281744647785, 0.19986008810011113, 0.19958435196007662, 0.1891320119882277, 0.2013201989130773, 0.2178210668389443, 0.19829496014069314, 0.19080844956824916, 0.21531279050069885, 0.20725974695118843, 0.1903870771032894, 0.1299051820691186, 0.18243437811293328, 0.8064265303598597, 0.2020888859057295, 0.1960845930400208, 0.12202595223009594, 0.14117153675196947, 0.15463963433163286, 0.7420592625775273, 0.6439710632025966, 0.584269477253178, 0.19923219552749427, 0.1673155255818921, 0.12608238200730115, 0.16551594388262914, 0.1647085957581872, 0.12630925199869159, 0.10421446359555953, 0.18532101350168373, 0.1885140478459858, 0.1819757674416802, 0.18841754518526543, 0.18873338744525914, 0.19010804747436738, 0.1840017127845367, 0.18028637751378318, 0.1774972931354667, 0.07283542171098345, 0.06992624696237748, 0.08304340466894433, 0.08721944139557414, 0.08008399390264553, 0.08706161466556628, 0.07841056486101083, 0.07676326261135324, 0.09019583760486694]}, "mutation_prompt": null}
{"id": "e45ac666-31e9-4a4e-8a08-5853c6ff5f5e", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizerEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Slightly increased crossover probability\n        self.w_base = 0.3  # Adjusted inertia weight for PSO\n        self.c1 = 2.0  # Further increased personal attraction coefficient\n        self.c2 = 1.5  # Slightly decreased global attraction coefficient\n        self.F_decay = 0.9  # Increased decay factor for differential weight\n        self.CR_growth = 1.02  # Reduced growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            diversity = np.std(pop, axis=0)\n            diversity_factor = np.clip(1.0 + 0.1 * (diversity.mean() / (self.upper_bound - self.lower_bound)), 0.5, 1.5)\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4) * diversity_factor\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizerEnhanced", "description": "Enhanced QuantumCooperativeOptimizer utilizing dynamic parameter adaptation and diversity control for improved exploration-exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.27764513086058795, "feedback": "The algorithm QuantumCooperativeOptimizerEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8795985586292558, 0.8690195079055287, 0.8721673629361683, 0.8815775342890061, 0.8685897972240162, 0.8677686017119409, 0.8554680693018419, 0.8799105214691848, 0.8734108191951789, 0.13354318716998537, 0.04471192323622142, 0.7634405008383128, 0.7324729973086406, 0.6875910673470536, 9.999999999998899e-05, 0.06904364420937215, 0.7610224776647243, 0.05105858570730215, 0.1620199100369316, 0.12201891608502724, 0.14781721809573733, 0.15335645235788253, 0.12546108267574851, 0.1537134398438137, 0.13201739826953485, 0.14158398268906802, 0.13865351843385343, 0.10625884170720801, 0.10702557349882824, 0.10200549384474411, 0.08763326771735935, 0.1115328379742494, 0.14602506259864945, 0.11211927893670781, 0.09502165690744113, 0.08413425279742348, 0.9681142732785819, 0.9422517937703629, 0.9648772519277306, 0.9660808253134869, 0.9671397069616926, 0.9578524043930572, 0.9662388464448587, 0.9756765157117644, 0.950263480718168, 0.43407525052322493, 0.603940236073915, 0.40937998504845075, 0.5939991489719232, 0.47044038576871594, 0.6484487191045444, 0.5440800275778603, 0.5216105803567166, 0.48232056110663124, 0.22730690387712416, 0.226380463902767, 0.6611217873560682, 0.22005173176677295, 0.3502973834102394, 0.2760265162349903, 0.12748093387300963, 0.2303461783396985, 0.2362963782269314, 0.18656449338145387, 0.11500692119771316, 0.2042156222960242, 0.09927937092589456, 0.11215848562114439, 0.13146734997115894, 0.2926407076861417, 0.16309507267044188, 0.168339363388474, 0.1773433632656104, 0.1292819449854271, 0.12968155370496537, 0.1304104574976953, 0.19778892513051727, 0.12795858631602108, 0.13708586555531233, 0.13013496763555155, 0.20148276327406078, 0.054011785760486375, 9.999999999998899e-05, 0.011253739324079803, 0.0005767394464278874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026873358490978938, 0.09198132953144145, 0.07162582102155735, 0.0814405922811029, 0.09870501214590055, 0.17317271057283656, 0.029430574513177654, 0.07792334196732931, 0.1309995079103402, 0.08113569896751871, 0.04811871835353376, 0.0665945274335934, 0.20184804552686142, 0.08920485650480858, 0.07356659624943718, 0.11675615822476793, 0.0989970427300414, 0.07333589696903509, 0.12510050829591068, 0.09974928773870284, 0.12940847903222275, 0.1977359050439611, 0.026112196280154598, 0.09184860314125176, 0.10316782648105505, 0.08273224959498515, 0.056360586130690504, 0.11551604367505475, 0.5366136715011793, 0.5205847159718551, 0.5379789328380025, 0.478453041066776, 0.5382037865933039, 0.5960105451416277, 0.5121420637413541, 0.5892932003796149, 0.5663927776477071, 0.07174814092294457, 0.1302017005196121, 0.13615827405906678, 0.1494610476368733, 0.11934658929666708, 0.09908447483024374, 0.129500711785708, 0.12350349268705962, 0.08618983452625051, 0.18650365024622484, 0.1910175001676766, 0.1713960055181316, 0.24945468333345133, 0.25849324333893997, 0.22142376267441555, 0.2201246093251531, 0.20256002894076341, 0.17501645486945616, 0.38917243169530125, 0.23576759945622916, 0.4153508348093746, 0.21941578694879793, 0.2758434881100912, 0.24196995538869204, 0.41759761525522066, 0.5254462708640812, 0.333277249756444, 0.25771832926264737, 0.3108611843078386, 0.303376656906277, 0.20186491548326813, 0.22222055138329055, 0.23083451611582406, 0.30448624812490865, 0.3024429315587469, 0.3840890882420742, 0.21352488120107904, 0.19092530387600504, 0.1760250461692543, 0.2210253739217437, 0.24477874300778701, 0.19274474829940247, 0.21071384164329388, 0.22187893950309867, 0.2107882022885046, 0.1929219366834254, 0.21837486741663348, 0.18236536471755382, 0.19770965645572647, 0.18857409272885595, 0.19284255935804528, 0.1980472023618668, 0.6587196272552837, 0.24223614138068683, 0.1672687436112219, 0.18505401296047974, 0.15270005215616622, 0.19968625588643552, 0.19995763767190644, 0.16881942199107325, 0.14166841274224773, 0.17796667556241264, 0.7464299277822327, 0.40894773610617974, 0.21002194196710955, 0.3743547851675638, 0.20669644158043954, 0.49120389540551246, 0.1532260882610602, 0.2110720470021601, 0.21210057355309753, 0.8233974341108686, 0.18152478202865785, 0.19272144094658927, 0.17869117043599458, 0.18685631829848248, 0.17130232979502868, 0.19201293208670456, 0.180062524333922, 0.18159572767699306, 0.19715437391501445, 0.09795924096057274, 0.08154338625316648, 0.08769671739522633, 0.07767974779768061, 0.0729648365776786, 0.07808568103317826, 0.08631437510158735, 0.07848517430131763, 0.09462513743753953]}, "mutation_prompt": null}
{"id": "c6cd4a2c-35ea-4e99-8156-f205ba30aa12", "solution": "import numpy as np\n\nclass HybridQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.75  # Adjusted differential weight for better exploration\n        self.CR_base = 0.85  # Adjusted crossover probability for increased diversity\n        self.w_base = 0.5  # Adjusted inertia weight for PSO for dynamic adjustments\n        self.c1 = 1.5  # Balanced personal attraction coefficient\n        self.c2 = 1.5  # Balanced global attraction coefficient\n        self.F_decay = 0.92  # Modified decay factor for differential weight\n        self.CR_growth = 1.07  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.4 + 0.6 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2 + x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumOptimizer", "description": "Hybrid Quantum-Inspired Differential Evolution utilizing Adaptive Inertia and Dynamic Mutation for enhanced global search capability.", "configspace": "", "generation": 24, "fitness": 0.27269081395737704, "feedback": "The algorithm HybridQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8293510789983483, 0.8335199145427423, 0.8369326796974138, 0.839606733434602, 0.8426035685480847, 0.8472059455596269, 0.8414481988612151, 0.8418342319653777, 0.8448744769922858, 0.05189048202965152, 0.04048208942026432, 0.09378882292307933, 0.6878908215819812, 0.04413571559701979, 9.999999999998899e-05, 0.1235897167143084, 0.6758452140194169, 9.999999999998899e-05, 0.16572760420450983, 0.10541572121692422, 0.1167358197933358, 0.1301057742664663, 0.13917874567451638, 0.12517158927836503, 0.10045589539401012, 0.1052624896250014, 0.10670022565629333, 0.07091190282423065, 0.0490356162001262, 0.13382525977880655, 0.11047342372752678, 0.10248412443716948, 0.1434364884333409, 0.1296468174597779, 0.10156513536630751, 0.1061806552949256, 0.9837229818385254, 0.9774461635571404, 0.9731300421177103, 0.9797822625297583, 0.955968768777784, 0.9734368657229107, 0.9736842760677312, 0.972651247571226, 0.9750898563058873, 0.6369670397945366, 0.5080339356464878, 0.05752385680333427, 0.5876968621976792, 0.6307104686369709, 0.46788834234086496, 0.5309751797124216, 0.5684191208677474, 0.12546300572369562, 0.21910918353716202, 0.2249280862451889, 0.22626615634617242, 0.22011011977127481, 0.21127898791715494, 0.21023557981103158, 0.2188909366864611, 0.36253786158402346, 0.24010373023165965, 0.18464254613829967, 0.18520835800763158, 0.16540802420956735, 0.09916370905400362, 0.12511477477611554, 0.16784803411158633, 0.1770679573721794, 0.16331887570909898, 0.15791679264399738, 0.12007722033610657, 0.12032939029731005, 0.20073135726977442, 0.1952270877047143, 0.19910017571988703, 0.19755177632567855, 0.20597676175774904, 9.999999999998899e-05, 0.12042838575782522, 9.999999999998899e-05, 0.07228478342695599, 9.999999999998899e-05, 0.0007395207902077816, 0.00012880529289305276, 0.006740499166460356, 0.0045573617554804935, 9.999999999998899e-05, 0.04192810148524406, 0.0939068249370899, 0.07534852143641313, 0.06646955505425611, 0.06588236173749407, 0.02214691483479725, 0.029607552678484028, 0.0547232735194102, 0.043621053872863524, 0.05044789368421321, 0.04620342068216321, 0.20842547400779354, 0.19648413259436515, 0.07450613619570667, 0.121103365069963, 0.17632170688526616, 0.09456893108970776, 0.11320042109408313, 0.16743450964129825, 0.1637519355563265, 0.3841275948782875, 0.11035062333018486, 0.14193210861934802, 0.1341915962750101, 0.0830289706055477, 0.20928327692731008, 0.05466916681069178, 0.0820566659557258, 0.5379029614626734, 0.5463132732027863, 0.5585580272829171, 0.5584806388580367, 0.5320380187997735, 0.5796231588520722, 0.571567687626534, 0.5472233282255743, 0.5764715538050564, 0.1317235039264517, 0.10508174801380465, 0.11298476666847113, 0.12043881857257055, 0.1477218885949234, 0.1367930076014825, 0.13002471163579543, 0.11251474236155423, 0.10837650441739055, 0.43682138065879783, 0.15184263822975774, 0.19894127698648434, 0.22969400065837542, 0.3296993316828918, 0.15766771838718574, 0.22721323914142078, 0.17312420887838798, 0.2300934723808734, 0.4136684672286107, 0.2981166713114318, 0.3466650311163547, 0.525172669409237, 0.3120507100504878, 0.48250524470522427, 0.45175149422354, 0.4077422073556993, 0.5287390373605418, 0.18134810846804605, 0.24633441541105372, 0.30674221141006996, 0.2062275054955307, 0.24419150660429423, 0.2927526270155715, 0.4329537490909696, 0.2395705370954625, 0.21786758456210809, 0.2445288662279077, 0.21124241625188556, 0.19765292794042555, 0.24557733508674728, 0.18845245763841745, 0.2346278596214736, 0.22404531194329824, 0.20103272358926016, 0.23393765777071485, 0.6429331925694814, 0.21643937280430037, 0.19406063327791556, 0.6167529078877041, 0.19010638053813023, 0.1937235675785982, 0.18138650146623936, 0.21903802434104935, 0.19586046648873767, 0.15332589617725356, 0.16487616639238745, 0.1529879068144634, 0.8997768496927993, 0.19916949658784222, 0.17016710845837535, 0.8803010478689397, 0.1692170325042811, 0.16683204463097012, 0.5209629212670506, 0.21041347605714023, 0.15559020825735237, 0.47426180870062673, 0.16756379261307452, 0.15155294259282304, 0.20978632192414592, 0.11308190119997397, 0.15524890004257508, 0.18229057980664287, 0.19223067575630892, 0.17774620153247178, 0.1968821007552719, 0.18408512700258817, 0.1777149327743648, 0.2080728404586908, 0.18331990738659865, 0.18480429353731476, 0.08438574962533385, 0.07956531763380803, 0.10785943870426129, 0.08152373869092278, 0.0912154201094505, 0.0800974359936788, 0.09111072700639833, 0.08017774135376765, 0.08303559209277733]}, "mutation_prompt": null}
{"id": "1553e88a-eaf2-47c1-ba9a-e82a2080de2b", "solution": "import numpy as np\n\nclass QuantumEnhancedEvolutionarySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Modified differential weight\n        self.CR_base = 0.7  # Altered crossover probability\n        self.w_base = 0.5  # Updated inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Altered decay factor for differential weight\n        self.CR_growth = 1.03  # Modified growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * np.exp(-t / self.max_iter)\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumEnhancedEvolutionarySearch", "description": "Hybrid Quantum-Enhanced Evolutionary and Local Search Algorithm for Efficient Global Exploration and Local Exploitation.", "configspace": "", "generation": 25, "fitness": 0.28408206277852566, "feedback": "The algorithm QuantumEnhancedEvolutionarySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8124950075641184, 0.8019017824913944, 0.8056738636281213, 0.8077726719799452, 0.8109698088401454, 0.8123272717066556, 0.8086573039264011, 0.815099676508731, 0.8011022933924817, 0.0821096479512664, 0.5845960099278948, 0.5713967790957101, 0.5042290434302114, 0.5897057203579863, 0.5964274812464125, 0.04265767576134494, 0.6054191064265404, 0.08581583338908805, 0.1058697935336651, 0.1693956273955528, 0.17580414309936332, 0.1618576772543735, 0.08855233028923104, 0.12418423184420846, 0.13090598452760327, 0.1207716632252035, 0.14344479777749963, 0.07986339292329359, 0.08834384303997211, 0.10737707913588745, 0.09953378801973067, 0.1069075734127164, 0.08678244035138338, 0.10634528014647981, 0.1202757074294255, 0.14703285850886827, 0.9462299241179167, 0.9276558950853753, 0.957000546174234, 0.9696775688302547, 0.9435401536046671, 0.9322763717246261, 0.9607691727317685, 0.9595189738117377, 0.9585049207044707, 0.5557346027161605, 0.5488362344517606, 0.5049010397704591, 0.5657133954381128, 0.5513897445261493, 0.20601185699754843, 0.5831172523581916, 0.1762559185002721, 0.12070461747022054, 0.16954888807074253, 0.37058937135170533, 0.23382354245070236, 0.21188880436701307, 0.2077359802649147, 0.8338791349441665, 0.36760036747016156, 0.810732060029419, 0.6908588045304167, 0.18301446220551876, 0.14713656431100552, 0.19249570873429378, 0.19422391408577055, 0.16060171229699594, 0.16412231945018108, 0.12276635580954531, 0.2785955235131097, 0.19050551331670873, 0.12548418163743014, 0.12577360116079472, 0.10009878922689297, 0.15135411065242677, 0.2867684041529944, 0.19412708331053374, 0.20084820585974295, 0.17453509680638324, 0.14150742933337135, 0.05221652911426955, 0.07325324643484987, 0.08642768282499924, 0.05402102034077794, 0.013968386102532149, 0.0009483692517496811, 0.0005863687486722391, 9.999999999998899e-05, 9.999999999998899e-05, 0.0952642892923552, 0.10733454204820958, 0.15171662327905056, 0.12496598405875414, 0.08892215853777596, 0.10973881175606115, 0.06901288973684916, 0.11880861806250909, 0.07116011708317005, 0.03207688254486851, 0.05465459556516994, 0.18273762324371845, 0.07236943455250344, 0.0818280801718071, 0.08704980313006494, 0.08777068195337268, 0.11745922557699884, 0.13161015633161655, 0.23176042134916575, 0.16283842229387213, 0.08585725191724192, 0.1688689676677968, 0.19685868650590033, 0.11755140574782708, 0.06262437621080463, 0.18721758618580975, 0.1136119570230869, 0.5389057257348652, 0.5095643852667809, 0.5700831373647433, 0.5772630596807216, 0.5111969510798202, 0.5203336512272643, 0.5346089045485491, 0.5512951249653117, 0.5164465014663535, 0.10454690850010806, 0.1322277687775424, 0.09862293196199157, 0.12046041747792502, 0.13633018011254006, 0.14295372682879393, 0.08384951261037843, 0.10811304583677517, 0.08746223524370889, 0.310761326468335, 0.19245420127287793, 0.18561381272681277, 0.41494005169704185, 0.16806971314924835, 0.18186549361336424, 0.26107233026850507, 0.3295908696959331, 0.27779778976206304, 0.44489281077429355, 0.2501942968630677, 0.3894393757136094, 0.3981279054705077, 0.4378906881972072, 0.38571479874595116, 0.45031678934124797, 0.44118142631360646, 0.31902502468126026, 0.23929054112570924, 0.19985654574552347, 0.25112713827877364, 0.20534195857309134, 0.23965879375194743, 0.2369670034818443, 0.3493109069032605, 0.37105799613405566, 0.19948170780809826, 0.1964397330633726, 0.18606539287854462, 0.21091755137875778, 0.2072983556868182, 0.19660168760330066, 0.1906022006856095, 0.22545315024964208, 0.1989570938416405, 0.192318654855816, 0.18122541215803745, 0.2010526152512332, 0.21275368109220338, 0.20352347107434254, 0.2056496610733859, 0.1929678111546782, 0.18153621944005394, 0.2425285288097352, 0.21560223847176907, 0.15728139953485565, 0.1669695136059639, 0.16879055151308164, 0.19677697649106574, 0.19898087166842082, 0.7559781353038254, 0.14129577389797865, 0.16283802062860686, 0.8717466081760036, 0.5517372527600526, 0.20923271789910547, 0.07327062722179056, 0.12616059372611232, 0.16677268951381796, 0.1678746552029603, 0.10399488436148274, 0.33520069209044745, 0.8125266034866432, 0.18244202999858228, 0.21186967273699264, 0.19069516916879037, 0.1841372347947139, 0.19330907272837994, 0.1785161568541942, 0.20268940858007245, 0.17349404023785975, 0.18609306851880048, 0.09908712173232581, 0.0983965370831793, 0.08321209728142964, 0.07897611112918135, 0.0812528154205494, 0.08108205740509089, 0.0848023405577385, 0.09171069310186775, 0.08238193919924774]}, "mutation_prompt": null}
{"id": "10802f21-5d4d-4f77-8a04-6709491f87fc", "solution": "import numpy as np\n\nclass HybridStochasticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.65  # Adjusted differential weight for more exploration\n        self.CR_base = 0.85  # Adjusted crossover probability for better diversity\n        self.w_base = 0.45  # Increased inertia weight for PSO\n        self.c1 = 1.8  # Further increased personal attraction coefficient\n        self.c2 = 1.9  # Further increased global attraction coefficient\n        self.F_decay = 0.9  # Stronger decay factor for differential weight\n        self.CR_growth = 1.1  # Increased growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.sin((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2 + x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridStochasticOptimizer", "description": "Hybrid Stochastic Optimizer blending Dynamic Quantum-Inspired Swarms and Adaptive Differential Evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.27525003165671996, "feedback": "The algorithm HybridStochasticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8306841075358953, 0.8365588110825821, 0.8313157574774909, 0.8584681884985866, 0.8301968662036825, 0.8265238024194022, 0.8423438755413792, 0.8422332407224504, 0.8285462127780701, 0.04078788273599965, 0.07333122625305966, 0.5696709497129996, 0.5811107542721662, 0.07120754934569284, 0.6566166882984273, 0.053543682143071814, 0.6813106307107177, 0.04831148660993878, 0.1468192889209302, 0.4565545545172782, 0.10030732338728632, 0.11372210303882035, 0.13631669614688835, 0.13268888949218383, 0.14923645676413855, 0.10738626296061426, 0.08442983802264736, 0.09071522385980046, 0.14806947647539725, 0.1265507299039409, 0.11527541981662748, 0.11561087117517399, 0.10319981333556627, 0.14576410441263776, 0.10156740813248033, 0.11732031595988446, 0.970918518620429, 0.9485155533446156, 0.9726033700123445, 0.9745514961248097, 0.9601713361296677, 0.9582192263358355, 0.9683867151098239, 0.9672070849759589, 0.9709816973692974, 0.38823265081097313, 0.4354781101674702, 0.4185645472135674, 0.3282667923179985, 0.48472685966869566, 0.4012040146478515, 0.375369002255757, 0.3978032913748454, 0.39419409233305747, 0.786954541204934, 0.4257439718452197, 0.3231340298714801, 0.2091564667922764, 0.1905048649078629, 0.19119951391305323, 0.2311091702139425, 0.22903708192627759, 0.7201772968272571, 0.16390266522031105, 0.13156610982357597, 0.12063669043460357, 0.14812648836830178, 0.18192059154835882, 0.1224930992454536, 0.18519233115786116, 0.1658098724803092, 0.14624508654032575, 0.16751106767877955, 0.14295868180221483, 0.1231274833288617, 0.12919854909310402, 0.14179568964963052, 0.14194861390151203, 0.13773249208596172, 0.17836266379157262, 0.22211695511995666, 9.999999999998899e-05, 0.006976407323501688, 0.02455301422768663, 0.0009524034640320256, 0.015178264026559973, 9.999999999998899e-05, 0.0007614230307780856, 0.000104006038179838, 0.003712343477448976, 0.03677018205688165, 0.12770159216300292, 0.06381536048480285, 0.044032730462682745, 0.061720941991474154, 0.08194233554389052, 0.07537486755536704, 0.06477520042858065, 0.06306396973156936, 0.09179350212175341, 0.08428458551853746, 0.04699294414740218, 0.14203395346623715, 0.15405412779265226, 0.07486290448626565, 0.16005549102561378, 0.16487825649862298, 0.09302857368276651, 0.19193403923863606, 0.054797930958254026, 0.13311504025903997, 0.2287717346108381, 0.12105479285853815, 0.28630907464471345, 0.1061944645590478, 0.17519531818685152, 0.08143192527323173, 0.6156509431825875, 0.572790905690188, 0.5234011063760236, 0.49288158484774547, 0.5750967865880273, 0.5111764892460511, 0.5818551117824138, 0.5316969868615062, 0.5492680494638658, 0.10381973271135325, 0.11327674562399426, 0.10433767398832183, 0.12163188687661075, 0.09105014240626619, 0.12023965947869708, 0.11101951833193202, 0.07808755098410913, 0.0768557745484042, 0.22643450487661798, 0.2571453165442621, 0.16491353905845552, 0.1837745097376926, 0.1714705178419006, 0.2538333157337632, 0.24745568034739196, 0.18624601197558643, 0.2147222852661721, 0.3599483427494653, 0.47408723599302727, 0.3222213210267787, 0.3736224097072329, 0.4603029405919067, 0.32881664883793604, 0.45807892482642687, 0.44072517331470096, 0.4766434885653166, 0.19643593475350685, 0.22541551762172451, 0.2815359893512819, 0.30606119288532896, 0.23547609475211095, 0.2405352154621171, 0.25562651464698316, 0.24837589182122866, 0.29801735007171226, 0.20088419727240403, 0.19256601420014474, 0.19300512884138277, 0.20986817469272623, 0.18526437615927338, 0.20218109636438952, 0.18005842154572216, 0.18095354061213398, 0.19632656480023047, 0.21832643899064852, 0.6257956120910835, 0.21608635282182642, 0.24256173102728862, 0.21653118799639337, 0.18425879340001305, 0.20167549990727418, 0.19239872225004195, 0.1795344609783317, 0.8471789763442068, 0.1874064971456253, 0.18220704563204582, 0.813490338146162, 0.1993365728512504, 0.16437100755605183, 0.14216775569746165, 0.1951730113153214, 0.17118828393294916, 0.7921611993839661, 0.21055581108876753, 0.2080452413879339, 0.20334302947296334, 0.11247580901760845, 0.15295563964062675, 0.10442626848892556, 0.2110054544077159, 0.11250344032664938, 0.19100622584545834, 0.1826185960711989, 0.18218159333114903, 0.18837652749351386, 0.1909168887624202, 0.19830564317184085, 0.17441883666602442, 0.2026620054735202, 0.17528219922546073, 0.08607612129684727, 0.074592626165635, 0.08459028814135394, 0.07318131342769119, 0.08719124159058389, 0.08342839934149693, 0.08325487293480871, 0.09130266073680382, 0.084517967454101]}, "mutation_prompt": null}
{"id": "15aa9e18-0adb-4c66-ac3c-7ea1f192ef2a", "solution": "import numpy as np\n\nclass QuantumAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slightly increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly increased differential weight\n        self.CR_base = 0.9  # Increased crossover probability\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Adjusted decay factor for differential weight\n        self.CR_growth = 1.02  # Slightly modified growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumAdaptiveOptimizer", "description": "Hybrid Strategy using Quantum-inspired Differential Evolution and Adaptive Velocity Control for enhanced exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.3047832160418376, "feedback": "The algorithm QuantumAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7981801689357118, 0.796661360356758, 0.7878192901122874, 0.8130964516969653, 0.7926374619911408, 0.8049812679080428, 0.7912596307719482, 0.7976969275366608, 0.7994670284945936, 0.5620129687972905, 0.5343764994778305, 0.571297716453162, 0.06252791115071199, 0.5107323643682092, 0.5936050617928313, 0.5864995383405256, 0.5778071200800812, 0.6051081411155785, 0.13839977471465625, 0.1386577613110359, 0.10850469143288866, 0.11558133303430407, 0.1681176908683465, 0.13300247750248928, 0.10833107274417109, 0.4324740000053745, 0.12098036373460674, 0.10580981633458764, 0.1329741313598113, 0.10539870304796572, 0.09644325741030246, 0.11282323310650266, 0.09531724664651864, 0.10881351024888497, 0.1055878664814367, 0.11300405382125522, 0.9592150493564999, 0.9431320994718325, 0.9563250920263038, 0.9478801776838544, 0.9605625144434206, 0.9190582241997045, 0.9726494372094676, 0.9583555553659012, 0.9567317344318914, 0.4714403432384414, 0.46566673663323244, 0.537322957886567, 0.4523789354446681, 0.5184587959383353, 0.5166646150853692, 0.49118892523306024, 0.5048292758396471, 0.5133593708402298, 0.17036869743240446, 0.7688040939773506, 0.6631397943454849, 0.21755950272391378, 0.8272396654105425, 0.1579469103783243, 0.8199996178532067, 0.7666873708230395, 0.7545378031377483, 0.16736981483525837, 0.1566753206802236, 0.15726860637951245, 0.12704960469815574, 0.12580275056729484, 0.1495538866306515, 0.15720534280607312, 0.2906146077155749, 0.19555658675479315, 0.19384063964810883, 0.22475336779081556, 0.11344616673136332, 0.24239397099384508, 0.20282929446295261, 0.16339120656540218, 0.21960989529608843, 0.19610854812675116, 0.20834636817907992, 0.12086560148869907, 0.002205684766613203, 0.00995644834444187, 0.025503350702103855, 9.999999999998899e-05, 9.999999999998899e-05, 0.11912506831951941, 0.04284736210239504, 0.010685322365548533, 0.061838872875354944, 0.06433140568994455, 0.138249979793302, 0.13694054670954048, 0.04356242856186854, 0.051813663620255856, 0.09410025655099075, 0.0740465638618818, 0.09993625576083409, 0.047288964185017046, 0.03415456330360356, 0.15369013534901532, 0.08867530347477837, 0.06952747984857399, 0.12255268885839055, 0.06347658900549336, 0.09541091771416854, 0.08758781756923639, 0.1379318508300108, 0.1284766390062263, 0.12608062939866627, 0.269922785354091, 0.32250843116492967, 0.16671540072219904, 0.0569524023874759, 0.126919099375014, 0.12737886920427588, 0.5301662894509123, 0.5282614325980555, 0.527955094589648, 0.5506886884492357, 0.5480285383710716, 0.5042417535927491, 0.5752684962097616, 0.5527956233522815, 0.5413968667421849, 0.15475214502644263, 0.08060300927998909, 0.11362374706577627, 0.13682447954199306, 0.07633509334817645, 0.11960011006567506, 0.10040494438424452, 0.16124538023501012, 0.14353846634999268, 0.2467533682120604, 0.1989624427707457, 0.2502873590081961, 0.30361442797602545, 0.3032670433116552, 0.16749328237520245, 0.34005872562619754, 0.19416720498629847, 0.1473146842928823, 0.43402404897671876, 0.46645296800131586, 0.47464655464022065, 0.36702203644480613, 0.34331216759961003, 0.499136141302021, 0.43675460728214033, 0.4705296148590413, 0.44496151434552245, 0.2990211462460155, 0.23937149958660897, 0.27080268447233435, 0.2351720808779736, 0.371499110040851, 0.2149821011396179, 0.23359616470483502, 0.26444331802344845, 0.21818082893146695, 0.21890262720559062, 0.23266465996636765, 0.202879851909759, 0.18476434620103377, 0.20036154922090188, 0.21172230668193248, 0.23289279825691134, 0.2188882126156676, 0.20183455685353047, 0.19207463972199978, 0.19223847223769008, 0.18448265660941265, 0.20009060735421158, 0.24196235473534378, 0.19072034069361055, 0.24044355847812982, 0.586412093667428, 0.1836206873219317, 0.19862428568955381, 0.798811281683022, 0.16970862111815244, 0.84046139252913, 0.19958849949735535, 0.15687491062394587, 0.14154251931531558, 0.15932331932374622, 0.8792090641901198, 0.744911462650405, 0.20822316941420183, 0.07334360962841069, 0.12545108699472052, 0.20847924886014646, 0.15325179073853157, 0.10419866089937846, 0.10338783507342975, 0.58145323689827, 0.19080498267692791, 0.1921757011583628, 0.1857647609983275, 0.21743020831286897, 0.20667060704613005, 0.18170335487275702, 0.1863314429854308, 0.1820835653996813, 0.17802842443222688, 0.08940257609787605, 0.07370772069465403, 0.0857700332890976, 0.08214075439217106, 0.07742937780191694, 0.08636766974115895, 0.08092949498227042, 0.0822426947468019, 0.07806714913965773]}, "mutation_prompt": null}
{"id": "474a4ed1-3262-4518-836d-c4f633300e2f", "solution": "import numpy as np\n\nclass QuantumAdaptiveNeighborhoodOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.adaptivity = 0.1  # Learning rate for adaptivity\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            learning_rate = self.adaptivity * np.exp(-t / self.max_iter)\n            neighbor_influence = np.mean(pop, axis=0)\n            adaptive_F = self.F_base + learning_rate\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + adaptive_F * (x1 - x2) + adaptive_F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR_base\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (self.w_base * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop) + \n                        neighbor_influence * learning_rate)\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumAdaptiveNeighborhoodOptimizer", "description": "Hybrid Quantum-inspired Evolution with Adaptive Learning Rate and Neighborhood Influence for Enhanced Convergence.", "configspace": "", "generation": 28, "fitness": 0.18672534726990425, "feedback": "The algorithm QuantumAdaptiveNeighborhoodOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.4015552020770228, 0.3947059247783157, 0.4668687361520286, 0.305519010010729, 0.34628103910715513, 0.2681442554213115, 0.35491914308246497, 0.3456807084608138, 0.3638774673893138, 9.999999999998899e-05, 0.00656425968396801, 0.0011847589231225308, 9.999999999998899e-05, 0.011061594996917501, 0.026880173043876132, 9.999999999998899e-05, 0.0004589572710453904, 0.0008188132045761076, 0.08783322052928155, 0.09707831792212074, 0.0940493008991018, 0.08883252090543425, 0.08203688943813736, 0.09273849938756795, 0.09850193943390295, 0.0882263946288655, 0.08110419213236797, 0.07488085554783375, 0.08690010143976601, 0.09718726729341465, 0.09374993949293697, 0.07671248805331454, 0.09217688909196475, 0.08252894068399785, 0.08190206003863354, 0.08954444031886455, 0.9589187262236964, 0.9300464116605216, 0.9563423857157675, 0.9539869898507448, 0.9582219231246255, 0.9320035521521733, 0.9718906413119259, 0.9472584710721237, 0.9454764859876934, 0.21907402894265404, 0.18934648945919852, 0.19727829507365302, 0.21191336756943857, 0.21683216144870043, 0.22453433146303792, 0.19292014464797913, 0.08695625434221532, 0.21903927771675813, 0.22218174654350487, 0.22281815240945102, 0.340525174251027, 0.1899722601461067, 0.19040129278348727, 0.15506686070625053, 0.24400061012593988, 0.12905515687614677, 0.2533497297761751, 0.08990452204389254, 0.12382637322960366, 0.12631932848446192, 0.0978605165610732, 0.11514913540598393, 0.10492360787197685, 0.11455824744066556, 0.11667035110746515, 0.14075871993227318, 0.12443407153682018, 0.1402285827968952, 0.15833637903938635, 0.15920493240651246, 0.19413578393376907, 0.1900672574721538, 0.12508015712966514, 0.12249054493789502, 0.1610848356917235, 9.999999999998899e-05, 0.006881056906333116, 0.008334791920156515, 0.043122429323197875, 9.999999999998899e-05, 9.999999999998899e-05, 0.02403400589301241, 9.999999999998899e-05, 9.999999999998899e-05, 0.10326889262818151, 0.1319892047898591, 0.0754339389657478, 0.06842593016216325, 0.0734069731630469, 0.013552807295593938, 0.032843055695829015, 0.04990313350749476, 0.05327485119288233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04167220721218223, 0.00922013388351317, 0.0658540739365524, 0.057009543294377574, 0.07210759310986359, 0.06350965677033038, 0.058100965980789065, 0.04820159870342866, 0.05319485361491316, 0.35915376631776996, 0.3541296696018901, 0.33639339009975466, 0.3149643553007829, 0.32029388107937395, 0.3159418320850875, 0.3637252862767133, 0.37629898627885927, 0.35794733771778364, 0.051021985683815, 0.060497396485430954, 0.06661689421924799, 0.0820297291596993, 0.08370652968675807, 0.08346172713284072, 0.09085092698624087, 0.0794170260700714, 0.12363691380739128, 0.14706443727530272, 0.14528137477663128, 0.141134989773961, 0.15472010530332625, 0.15017090169153435, 0.16536580432124937, 0.16618834839474295, 0.17163987940746173, 0.16240920428128447, 0.20993332895385763, 0.18996066789912125, 0.21189030295564848, 0.29804944809491585, 0.23670777420242228, 0.2602194803149126, 0.24184305857708488, 0.23220632106268857, 0.226247792350441, 0.1839619111290146, 0.18666278665349778, 0.17540949526288951, 0.16424195224702998, 0.16764978773016337, 0.18213473516379408, 0.1785696359325939, 0.18985218529018044, 0.1479781083388807, 0.20265062993184024, 0.2080311338405011, 0.19991338753617405, 0.21481147745459417, 0.21242988612927727, 0.20099998483058112, 0.2087391710841614, 0.20503416077702674, 0.18454630452040788, 0.18591050499192774, 0.1885219809127474, 0.18717499920552805, 0.22244328550169834, 0.20881741852723223, 0.1877385764731505, 0.1968318114871066, 0.1905145774716187, 0.1725968625847044, 0.18489991288343677, 0.470808700310949, 0.1667367636730963, 0.16816791860667712, 0.1939455657988043, 0.1627100333483349, 0.5103063569269375, 0.15350318279479203, 0.5471887776646578, 0.4966751363168608, 0.16908002612821005, 0.31028101359959614, 0.1988324121993249, 0.2029445265117884, 0.2015517194591555, 0.1025356309318538, 0.10262953393338681, 0.4374251001802695, 0.19233444090122054, 0.1775049906390226, 0.19269033499525157, 0.1724960225679757, 0.18931652506912056, 0.1800592347085882, 0.18062491442963124, 0.18038402558574995, 0.1760460896745082, 0.09512466530152519, 0.07121704973388043, 0.06987305519163078, 0.08110221258488015, 0.07816259135938541, 0.07961704808039793, 0.08308511532873253, 0.08816861739036574, 0.07936789366206853]}, "mutation_prompt": null}
{"id": "d4704268-36fd-422e-988e-121aa11dd7ea", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "f7c5c659-7f56-4bfc-82d2-ff78809cf2b8", "solution": "import numpy as np\n\nclass MultiStrategyAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 2.0  # Global attraction coefficient\n        self.F_decay = 0.9  # Decay factor for differential weight\n        self.CR_growth = 1.03  # Growth factor for crossover probability\n        self.mutation_rate = 0.1  # Gaussian mutation rate\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            # Introduce Gaussian mutation occasionally\n            if np.random.rand() < self.mutation_rate:\n                mutation = np.random.normal(0, 0.1, pop.shape)\n                pop = np.clip(pop + mutation, self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "MultiStrategyAdaptiveOptimizer", "description": "Multi-Strategy Adaptive Exploration leveraging Differential Evolution, PSO, and Gaussian Mutation for enhanced exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.23820023440875795, "feedback": "The algorithm MultiStrategyAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6003660861452589, 0.585842618075953, 0.6423839525891577, 0.6528664087758093, 0.597190625851832, 0.5885675330472013, 0.5928512762650091, 0.6010249870474766, 0.6037008814450217, 0.24876366253659643, 0.1949635179038811, 0.22485555403084978, 0.20679111562057373, 0.17343492327378884, 0.058481403462345094, 0.24837862559088986, 0.1791665037464314, 0.029182674089678895, 0.11304894553037648, 0.09806208769306846, 0.08662217841505804, 0.11594802232844137, 0.10854864903834371, 0.1303839383554083, 0.12932452379881654, 0.1158184372193567, 0.15578956911834685, 0.10985781729388966, 0.12286154931531323, 0.12500425717437869, 0.09709825512500325, 0.14117568715518536, 0.10136244265946193, 0.11843092498015162, 0.10607116175445064, 0.10876316338320102, 0.9597721593456671, 0.918650755302246, 0.9577758390143215, 0.9608136143467229, 0.9423758925117981, 0.9549113759081955, 0.9733288711016367, 0.9733192897499127, 0.9584209718808501, 0.3096080611557378, 0.3094393541849345, 0.2984658917296693, 0.2994687422459257, 0.31031972239344796, 0.3189897024085031, 0.31293203753874943, 0.3375766184074329, 0.32511576240987616, 0.6065995177360766, 0.22035932280369852, 0.5256586353504293, 0.20822396903359208, 0.20470130512542817, 0.20686407510588467, 0.7981481385854002, 0.5192966637045526, 0.35881752328916017, 0.24668681077712018, 0.19739007225411698, 0.09555114895523098, 0.12358605574751602, 0.2606656139728093, 0.0929904158469822, 0.15536343896691562, 0.143536700841299, 0.1829076729177247, 0.15083916482113313, 0.18392691371624093, 0.10494291195198024, 0.17940397262700658, 0.18667829680993442, 0.18538844738336901, 0.19349145211538854, 0.20865189781026072, 0.28868997900579674, 9.999999999998899e-05, 0.05166590570781082, 0.042871331052456885, 0.0055182663808598376, 0.0010234882225573783, 9.999999999998899e-05, 0.05643944929475497, 9.999999999998899e-05, 0.007978438514845587, 0.033638422676651514, 0.04677787610587325, 0.10879459056532359, 0.07762395507208364, 0.03177671426163364, 0.053552951368568746, 0.04205357418371547, 0.03947063668711581, 0.07670146863422511, 0.09127488037930376, 0.026014907586054847, 0.04455363777905008, 0.08676752534841603, 0.04164227069278681, 0.06817058531820153, 0.04721083080478916, 0.06767923898471329, 0.06459645101869771, 0.12729936357431593, 0.11175486812736779, 0.14165009954301733, 0.010113373440610474, 0.07925177333866917, 0.1437752969781677, 0.10319067335814636, 0.131504196117328, 0.11827746438361597, 0.4662844245672155, 0.45442576957957104, 0.5075396674767607, 0.44788295347940654, 0.4564130602066877, 0.43313812589985556, 0.48237443906989996, 0.45109306541460825, 0.48739364129270646, 0.11230789618463621, 0.09646033668386933, 0.11205958925572956, 0.08357182141847641, 0.07741226606836882, 0.10045433734953224, 0.09846670448576156, 0.11398205742688094, 0.10402491164934513, 0.15238900404939426, 0.2269720613715971, 0.13508727740551274, 0.182327987997429, 0.13271128374193464, 0.2297930085200368, 0.18381192494864507, 0.19714303294551727, 0.26690549666796204, 0.3399613367970853, 0.27631454246013143, 0.30223564007263737, 0.3262423134024377, 0.3399411799599753, 0.27979349365668316, 0.357017811522788, 0.3610434704379262, 0.32020562451441814, 0.2107195607841419, 0.27523166990846726, 0.24580183998159533, 0.23554944573122516, 0.24388512030245713, 0.2761942038809071, 0.22208026618445187, 0.24632491408164814, 0.26993496196837274, 0.22374201570223184, 0.2029371505386307, 0.19003752544320118, 0.1972046627037397, 0.19113176287534395, 0.19593737405530764, 0.19455143711995393, 0.20001010815797304, 0.1936658335861785, 0.1942653154282612, 0.20554912383691692, 0.19349501009719738, 0.22668271769273285, 0.23676817779769888, 0.18552930264188117, 0.19626053827090717, 0.19946204566954606, 0.1975361011086625, 0.1970568739231977, 0.16062786105523064, 0.16926405840981973, 0.16985506448993415, 0.19822304709069305, 0.15643427547694277, 0.14081800736481276, 0.1630516271645842, 0.7898634556166026, 0.5606376416310438, 0.2093848092117444, 0.18963139515017957, 0.1260326088181124, 0.20656591504158583, 0.153053751117178, 0.10365780989873552, 0.2035964411266057, 0.09376143261032088, 0.17763576073001497, 0.177788010431433, 0.18598503449618764, 0.1803744014234746, 0.18081000522331792, 0.1906929206563046, 0.19059139650517787, 0.1795163897150267, 0.16803404650191422, 0.08445500609652878, 0.08060852468624868, 0.08249634733594047, 0.07225598680990952, 0.08618408278606293, 0.08483207768025591, 0.08824795838564692, 0.08158221496301143, 0.07743140490847922]}, "mutation_prompt": null}
{"id": "aa8a4b3e-e081-453e-9fcf-e61da3f75329", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Tuned differential weight\n        self.CR_base = 0.9  # Tuned crossover probability\n        self.w_base = 0.5  # Tuned inertia weight for PSO\n        self.c1 = 1.8  # Adjusted personal attraction coefficient\n        self.c2 = 1.8  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Changed decay factor for differential weight\n        self.CR_growth = 1.1  # Modified growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Adjusted velocity initialization\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.4 + 0.6 * np.cos((t / self.max_iter) * np.pi))  # Different weighting scheme\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)  # Increased number of random samples\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)  # Diversified mutation strategy\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Enhanced Quantum-Cooperative Optimization with Adaptive Diversity Control and Convergence Boosters for consistent performance across varied landscapes.", "configspace": "", "generation": 31, "fitness": 0.2505526877262238, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6887670122079788, 0.7081115338029691, 0.6920401024806444, 0.7290218476235668, 0.7165728368161455, 0.7192708730952045, 0.7505756687254079, 0.7499881819869465, 0.7180367362958648, 0.46249324309676987, 0.06570015152285158, 0.03639675853926494, 0.4693098893287586, 0.058459800726458844, 0.47379431709345843, 0.016222860112622195, 0.05042079943786648, 0.4473036567844425, 0.10613853954301433, 0.10752090684361337, 0.10010643416188492, 0.11384252532936412, 0.09410201556926423, 0.11946215762388657, 0.1035219939852644, 0.1393314966261483, 0.09749266566296977, 0.14642234887992722, 0.09415598458695118, 0.08427713908333012, 0.09477925269574428, 0.1146998705285438, 0.11669261137557918, 0.09404141809042155, 0.15012506365788925, 0.09827304575335072, 0.9716007097855234, 0.9485923667073336, 0.9738362033531498, 0.9751995054151354, 0.9486329899751548, 0.9448045407192222, 0.9675714739438038, 0.9877422701790131, 0.9717810826493136, 0.32966500051044156, 0.3259782007280003, 0.27735354641615595, 0.15247362614733595, 0.36871362319885825, 0.2625450191179872, 0.30167012154054473, 0.34299391244577315, 0.34629096616373467, 0.21959387295611, 0.27421283678600405, 0.3070608119178888, 0.26874149257176605, 0.19047111200961986, 0.20866048252855818, 0.5563897325608335, 0.1330639734982757, 0.6725011549544825, 0.1813410264930847, 0.15697329023124218, 0.1427398090563784, 0.12195385221205901, 0.19150418262281932, 0.17338067415519798, 0.17545045320185293, 0.18950931758331613, 0.15115014539079452, 0.1572135124517745, 0.12957518162116066, 0.13904774840716017, 0.15715254630844389, 0.2583277304746743, 0.17225980018991016, 0.1083036133260461, 0.1842675075759982, 0.08755193928528371, 0.012926071563144625, 0.017164726794488105, 9.999999999998899e-05, 0.02485482129635963, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0032964019325286698, 0.04177012172366579, 0.06630160662687723, 0.07203424033569428, 0.07057080232243229, 0.11309638052318938, 0.01639223276682511, 0.05424460979512913, 0.09477367457149921, 0.043970028682040696, 0.1504850357295705, 0.035582441504587004, 0.09813582231074247, 0.07191186145948925, 0.17305924566936615, 0.05920828098786968, 0.08102208345993711, 0.06675959351392435, 0.0707637468553095, 0.233802444801525, 0.14408237737684648, 0.05744298237585421, 0.23303193795875932, 0.1068612329249865, 0.07245998259786013, 0.11073454607255806, 0.05402916041596273, 0.1939844617425046, 0.4935392286061365, 0.49004649138811307, 0.5251419427404064, 0.5097252979167551, 0.5097866403806091, 0.4982659994435914, 0.5084749409375975, 0.47262060267742523, 0.4968292129166251, 0.11681838286642854, 0.11272001342645965, 0.1093239790957341, 0.08475852007212215, 0.12572396964829347, 0.07873197628571449, 0.09021246140629735, 0.09652003838130097, 0.08587497381852571, 0.16097328139103972, 0.18027849930656525, 0.1583523404535674, 0.2007244811108253, 0.2758627941840809, 0.3176227738046218, 0.1527010284760787, 0.21121306349940638, 0.20728267367697706, 0.34900152639853244, 0.44625279711808785, 0.40125073031379366, 0.32581744121016765, 0.40731487116709264, 0.19808607201462514, 0.38105830043636957, 0.2724181456203987, 0.34751765479656305, 0.1751005171291543, 0.21341253302098406, 0.27306945311693687, 0.2612821226008716, 0.17855951747807652, 0.20800357879003006, 0.32004182393048775, 0.2555539666957658, 0.2372301100710824, 0.19199278324346858, 0.200423475570493, 0.16824688017881784, 0.21187103725844847, 0.19822655982556703, 0.18125045122351024, 0.18807676138288, 0.20757664596350278, 0.20124329022768062, 0.20671766067171837, 0.23397467469653144, 0.20964938478970863, 0.22730747163425058, 0.21620351388061188, 0.19588724086915787, 0.18253987059966692, 0.20185964793940447, 0.17541419537540548, 0.7885586010270497, 0.18670482849764292, 0.14571062793229705, 0.16457792381689973, 0.19748520297577254, 0.19816583782253316, 0.14055306571824933, 0.1598575938979604, 0.16906947028292796, 0.5337870965183463, 0.34357806270133273, 0.20638109815357286, 0.5975151806576696, 0.16519078083493455, 0.26680771233947453, 0.2082103671953227, 0.20152506097157663, 0.6530997123901483, 0.17573259202993652, 0.18479126396844914, 0.17582635173561034, 0.1954078801611614, 0.17111770735915144, 0.17692487275845847, 0.20773159477024516, 0.18430425590153976, 0.19158074347207998, 0.07232204392134367, 0.0730413192626771, 0.08761177018035937, 0.08828438299260633, 0.07377569917971727, 0.07490955241487662, 0.09191773048285545, 0.07950104560171445, 0.0896955480535988]}, "mutation_prompt": null}
{"id": "adf01aef-aa7e-4f4f-a2c7-21bad63cc06d", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "8af333d4-56cb-4feb-a5ca-b5efc36cc9d0", "solution": "import numpy as np\n\nclass EnhancedQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 2.0  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumOptimizer", "description": "Synergistic Quantum-inspired Differential Evolution with Adaptive Learning and Dynamic Attraction for enhanced exploration-exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.2561103994457924, "feedback": "The algorithm EnhancedQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7222870051648884, 0.7180302797545983, 0.6947408809660967, 0.7169568746631283, 0.7332664528724471, 0.729912235076867, 0.6848524632137787, 0.7351372568558752, 0.7143441371331005, 0.03667203595259505, 0.4946029915597202, 0.4804348724111044, 0.04056876106833185, 0.45304757240070404, 0.45193000705661857, 0.48599473377283353, 0.42780639556534705, 0.39189312992606073, 0.10961899763685978, 0.1112190653130174, 0.13733486804024309, 0.14378367293966843, 0.10937989510150525, 0.06357223388798738, 0.12030185653925274, 0.14358991233196228, 0.11478259827968718, 0.09338181579918037, 0.0951027404693856, 0.1228159536233463, 0.1614212709257774, 0.09266787885255978, 0.1315083343504162, 0.10418031776856373, 0.11216894760679663, 0.08930153614642389, 0.9582891330910989, 0.9495076664600789, 0.9722143296112035, 0.9739062728722626, 0.9707636599216073, 0.9594503112471359, 0.9694143319705734, 0.9726537689778108, 0.970892541410257, 0.36000357844687136, 0.3345875570923018, 0.3485755832583902, 0.35578525617566115, 0.34398231219045305, 0.30871928208821886, 0.3551836740709218, 0.3488200565629742, 0.3857157240780138, 0.2216891099264351, 0.21645505795519626, 0.6003542319480395, 0.6047403792541588, 0.32415838258084073, 0.18969761502771776, 0.2194399326394728, 0.221208812760748, 0.3548646024297408, 0.17397864185242107, 0.15339178096145045, 0.10195896422277406, 0.1662482569807482, 0.12011302133881796, 0.12398492232122882, 0.177970919399702, 0.21602170328956616, 0.19428873185768702, 0.142431562822247, 0.1461054534939361, 0.22096276051283725, 0.18273983238887748, 0.11953967573195745, 0.2723110596961352, 0.11819118393390726, 0.12267707424376617, 0.20649066639128721, 9.999999999998899e-05, 9.999999999998899e-05, 0.03727667265161305, 0.0004859661159778428, 0.00228126820108443, 9.999999999998899e-05, 0.00033480375831673737, 0.019910917560051367, 0.014964059939736929, 0.08340428055005245, 0.027714728080167172, 0.07837849213939208, 0.16798280635253704, 0.05013687811332368, 0.03445340062972724, 0.025705659818326065, 0.07067106139374468, 0.041692833355338355, 0.05658205035581554, 0.04262250630050224, 0.026362407258698317, 0.11777342059688767, 0.10492399812660336, 0.05886961295907933, 0.19985105446657747, 0.07321663554910884, 0.1889251845494615, 0.11437833349594762, 0.03724211231193808, 0.23576542143781376, 0.07825928254613734, 0.2140309567934161, 0.1360954978676847, 0.07342876736249071, 0.10503176778922174, 0.0791417642185257, 0.4856353065038611, 0.5185261869845734, 0.4907952698617578, 0.473843632365301, 0.4895355084020987, 0.5060724373786718, 0.5214061488428652, 0.48365650334297405, 0.4661488664230862, 0.12630448284994034, 0.0675072704262688, 0.09568055267581455, 0.07847600537875765, 0.09106924680607731, 0.09856969776675395, 0.12819492354694428, 0.07680076152153559, 0.09658550789073761, 0.1768737977671362, 0.23681554498101431, 0.22311271544595268, 0.16495881128924428, 0.3155214123613359, 0.17198604202376777, 0.22483279719320437, 0.24698308159983662, 0.18013068603739046, 0.2580918689907469, 0.4292524195856908, 0.30994400962720814, 0.2086408537034975, 0.3129413987338282, 0.3604741783178722, 0.2701498319796809, 0.3676402057951098, 0.4144785678007028, 0.12360564002393437, 0.2164006899426526, 0.20670521753594828, 0.20586482436225872, 0.2924981103184726, 0.18935624044614618, 0.2991272833748976, 0.17505967225065555, 0.15826843630351595, 0.20859330888695649, 0.22822282079092393, 0.18907179441612543, 0.19071664204680805, 0.18899892477725921, 0.19651074077681063, 0.18880334015826084, 0.20176947037011228, 0.2142453670189708, 0.20315098398342246, 0.19382948911786502, 0.21961185424917207, 0.21632829772427098, 0.18198956788607723, 0.19520282582757853, 0.2241159367950588, 0.20807139016881637, 0.20672886742514263, 0.16533290423606306, 0.1846453667834137, 0.16525945753260052, 0.7950929181027603, 0.19835382716074024, 0.16372961929678276, 0.1407271275175872, 0.7441852369879394, 0.17117909200703074, 0.5705579567164429, 0.20567102270457105, 0.43207976796880565, 0.4923882174446176, 0.11199562831516818, 0.12529071507129264, 0.10436391069404183, 0.1961502020163327, 0.11179252190054156, 0.18189588769476972, 0.19556577843189848, 0.17973227408376347, 0.18060144961461355, 0.20615896739576822, 0.2077819204712228, 0.18117415225162237, 0.16937994889502084, 0.19165486042357205, 0.1046431435059616, 0.0759269543598271, 0.07108598428555246, 0.07640768607209447, 0.06893165988016392, 0.08307064785707174, 0.09252933537475216, 0.06853680820453878, 0.0982051006932988]}, "mutation_prompt": null}
{"id": "13649abb-9dff-49cb-ad99-3d6124772d56", "solution": "import numpy as np\n\nclass QuantumRLHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7\n        self.CR_base = 0.9\n        self.w_base = 0.5\n        self.c1 = 1.8\n        self.c2 = 1.6\n        self.F_decay = 0.9\n        self.CR_growth = 1.1\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi / 2))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumRLHybridOptimizer", "description": "Quantum-Inspired Hybridization blending Adaptive DE and PSO with Reinforcement Learning for enhanced exploration-exploitation trade-off.", "configspace": "", "generation": 34, "fitness": 0.2808338064195557, "feedback": "The algorithm QuantumRLHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7794519429812464, 0.7780636762113091, 0.7522356026178214, 0.7815992050085978, 0.7707958676563818, 0.7709423238215191, 0.7722650812717297, 0.7734196004722335, 0.7663547603315014, 0.4766212232259879, 0.49070170323489315, 0.5313974921805324, 0.14005302711320078, 0.5355391621457715, 0.5291775175259962, 0.5078130504502938, 0.5396998070414538, 0.09577428487987194, 0.09552275977912938, 0.15188193242798242, 0.32314602962926053, 0.09944730766483212, 0.14303138485946676, 0.10086758808524376, 0.11345056338899906, 0.1095317847068411, 0.422185324802028, 0.13037620470228561, 0.1315617804628375, 0.11386300874583499, 0.13933161304646724, 0.126017956633515, 0.13407512440827452, 0.10643567027014955, 0.13786018186404891, 0.08669541253366675, 0.9595672019599961, 0.944566690241626, 0.9545933795656115, 0.9489543173957452, 0.9607436872149453, 0.9420374304219846, 0.9723953344707329, 0.9610701305587512, 0.9557415553818412, 0.3745688648356672, 0.37434330529415305, 0.4229280308587635, 0.3614521524294452, 0.3371187605740802, 0.4172128088510292, 0.3558872353448779, 0.36585272468392216, 0.4316614841947677, 0.6928059813457894, 0.22001639731519285, 0.6763050013252392, 0.69299654332921, 0.2684481938020581, 0.257184422080306, 0.7560149690132774, 0.459040733225633, 0.7098751074919153, 0.1857016247545733, 0.17388456884868486, 0.1380924131429614, 0.12388556161669517, 0.12173795058883874, 0.16329393917742996, 0.17287399234580392, 0.18158431500563965, 0.164874719909881, 0.15736353240497936, 0.20451256803874085, 0.09301478138754338, 0.15060103980182216, 0.1969272036947679, 0.16517968256638882, 0.23649932029669685, 0.1811473233681199, 0.1828231712375944, 0.06057769930906942, 9.999999999998899e-05, 0.015010731692035373, 0.0019122679729250969, 9.999999999998899e-05, 0.00010655066897957699, 9.999999999998899e-05, 0.06734511136272303, 9.999999999998899e-05, 0.09779983627950228, 0.064267185001181, 0.09982352318747634, 0.10452833379295368, 0.045957561667637314, 0.0540604974754848, 0.1239018025059162, 0.08131535118442712, 0.08431326663915328, 0.06368535303368661, 0.06668910526599525, 0.17935281911487966, 0.17107669080970722, 0.06179203409322076, 0.20621888052957615, 0.06470299819714986, 0.05751182570743185, 0.08104706781828086, 0.11638490062167262, 0.2424889119338305, 0.1360844415900987, 0.16181914183604362, 0.13577015567560324, 0.1877295874211552, 0.11954293807281069, 0.07758250155496893, 0.11937158578449614, 0.4767207027637146, 0.4967728762037752, 0.5174080295469388, 0.5258465212494188, 0.5211724810345566, 0.5170780315980776, 0.5168532204388432, 0.5154653363064188, 0.4966883603707054, 0.10930368144788716, 0.11277376252867177, 0.0841489630732829, 0.13858784319019446, 0.10351258052795898, 0.11065991419409216, 0.13316447547752008, 0.12243192698159688, 0.1255673504975341, 0.26862067481340235, 0.13754233861795584, 0.16485432020339996, 0.1981685554760687, 0.38540429140511834, 0.25815654643616626, 0.182827858758565, 0.1391783218033712, 0.13381809251238952, 0.3803440299666222, 0.35591700109217594, 0.31184488755574546, 0.2882749032338936, 0.32156023563214997, 0.31503300959648983, 0.3810755026456284, 0.290397328073265, 0.3008024123372547, 0.17143399195308306, 0.2652131173454493, 0.1747221405612549, 0.23399010183740343, 0.2204071565459289, 0.2586347295014305, 0.23474113036192223, 0.24249542631652388, 0.34742838502398765, 0.20017439679792493, 0.1954394521149958, 0.18976856597372316, 0.20071377570865312, 0.19216283734868078, 0.20409633032010044, 0.19531467986027917, 0.20716221201056984, 0.2092967981308106, 0.19584372348187107, 0.19045636853687642, 0.23148966589101228, 0.19858853159207457, 0.2189310763735638, 0.2021812424613626, 0.3556964552732419, 0.24184670025626753, 0.22231139244104292, 0.196140120657051, 0.20739164119082942, 0.16986158601538914, 0.8427247511425775, 0.19861653998234619, 0.1556923753943833, 0.8079715924874447, 0.1626577417436229, 0.86262862817796, 0.5939391752096268, 0.2082538439629329, 0.20201258431915148, 0.12690364580928903, 0.20888515920792683, 0.15427745677444016, 0.10393740464853218, 0.10348082560965866, 0.09415167463926577, 0.19871685437313746, 0.1818462572117191, 0.182857498265261, 0.2156227012887263, 0.20071303340899682, 0.17957590315961025, 0.17819917662991125, 0.19337911796471807, 0.19335152524744859, 0.07965632562553748, 0.0837219197499739, 0.08807819849795928, 0.0757741829774653, 0.07542856103862783, 0.07727118497173724, 0.08512860549152446, 0.0841959106485991, 0.07380396611476625]}, "mutation_prompt": null}
{"id": "9f948ebf-898d-4c3a-b5ed-f3ca762f2d55", "solution": "import numpy as np\n\nclass HarmonyEnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.65  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)  # Modified selection\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HarmonyEnhancedQuantumCooperativeOptimizer", "description": "Harmony-Enhanced Quantum-Cooperative Optimizer: Integrates Harmony Search principles into Quantum-inspired Differential Evolution and Particle Swarm Optimization for enhanced exploration and exploitation balance.", "configspace": "", "generation": 35, "fitness": 0.2768901626997095, "feedback": "The algorithm HarmonyEnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7698698398441959, 0.7912575011795177, 0.7608196769668183, 0.7852345361951782, 0.7847831496897351, 0.789585627934529, 0.7873295823144318, 0.7720647466205834, 0.781434936219511, 9.999999999998899e-05, 0.08962650988947629, 0.5590440678546256, 0.5264584037087937, 0.5911388508414239, 0.5516389467752737, 0.04655300459530698, 0.5665190069680173, 0.5390749330914186, 0.13118728586885753, 0.14151126081075216, 0.09509500785905967, 0.1574346456822534, 0.1293483801263524, 0.13071537428112656, 0.12017422907086928, 0.1064462982551142, 0.10140860094777049, 0.09701051522929305, 0.08695973748247632, 0.1347764265128366, 0.12465343151140407, 0.11935002396931416, 0.13400383672127647, 0.11174485221209618, 0.14054958754718283, 0.14386176823355168, 0.9574874838586542, 0.9480117333796063, 0.9721278865127154, 0.9741887574053119, 0.9592589719712682, 0.9561038758177007, 0.9598969504702716, 0.9568439778356419, 0.9710149194804568, 0.4487780169931612, 0.46695895267004617, 0.46875149268307337, 0.48209874094444727, 0.3906120582710171, 0.41710925506776975, 0.4790202620000209, 0.4674395456255799, 0.4654796512002689, 0.5828563260368927, 0.20985918317826147, 0.22116122641238767, 0.6949979695279012, 0.2675834315553183, 0.21565252553960013, 0.2142179729133019, 0.36877469808557717, 0.7186216994111001, 0.12841584300199482, 0.1532233044715362, 0.17804589690705164, 0.1272886962303763, 0.19909190030011104, 0.14689322077387623, 0.18923714588193996, 0.17224942698782686, 0.11054603637317195, 0.19251659513331965, 0.15999147892349086, 0.17470172518620875, 0.17386022816005176, 0.15849549104266314, 0.17194663394122234, 0.15037768789253547, 0.21442834394182553, 0.2072933122879278, 0.03204657105339048, 0.12245820569828758, 0.06519005519624299, 0.030949228374580917, 9.999999999998899e-05, 9.999999999998899e-05, 0.0521560322136394, 0.019245023463837607, 0.0007270358317231773, 0.03284714705492975, 0.05329158868890227, 0.11206701673441333, 0.018597184699260416, 0.14662706833830308, 0.023575686040924082, 0.07542016389402484, 0.07509780531375088, 0.08870361712605246, 0.03138058326701121, 0.029917623739113886, 0.07803399401361943, 0.1255958146603785, 0.0787495877889991, 0.06288490030525085, 0.08640561890195164, 0.06173895024652487, 0.15124430062609118, 0.04153574121520287, 0.09409556367427085, 0.24121358316582275, 0.12014510474353302, 0.09631674396694401, 0.08384161353241415, 0.0785372347590424, 0.10552849088074567, 0.16211719060242247, 0.4979402598963052, 0.54661534613725, 0.5079689101442826, 0.4884211416624059, 0.5354562933817464, 0.4792468821430377, 0.5715843995473333, 0.5089600904204908, 0.5106136043836467, 0.12849107714722796, 0.10362518154151279, 0.09786270910291839, 0.09643179404387081, 0.1288243526334294, 0.10905766111303128, 0.10275469187854147, 0.10810694092117823, 0.11563085098487902, 0.14015488079834593, 0.2361987953307807, 0.16989111673697066, 0.1873532520915112, 0.29197146124329687, 0.2545267524217556, 0.27443088725638853, 0.1517201162428068, 0.16818759556091412, 0.30916729514295926, 0.30951110511090696, 0.4215225566694121, 0.28000853929115843, 0.38548744793508327, 0.36577768158088597, 0.38609649405118385, 0.3948775696422211, 0.3438178557763969, 0.2263557660372183, 0.23179050403271573, 0.25696775465306576, 0.29869497416978386, 0.22826285285040182, 0.18579368253285755, 0.2542377562247611, 0.2778319954574685, 0.21279413066141817, 0.18981274672113702, 0.18815053899479073, 0.20159807204546998, 0.21111364838301028, 0.19032259218993097, 0.20101391427079607, 0.2231993848867534, 0.18841261542421273, 0.19490189299300809, 0.23681292877988858, 0.21635423944526866, 0.19422880406438392, 0.19321235228464406, 0.19368552535050376, 0.2373971418283104, 0.6198783527297034, 0.1856296941412906, 0.18048090224448532, 0.8016563865984311, 0.7879488562464052, 0.16675967538482073, 0.8172364765766826, 0.19853746125766358, 0.14620860200149177, 0.14155761852787074, 0.19390986852557224, 0.17237786549141332, 0.7534220951356605, 0.20877114970880317, 0.20622627530700377, 0.5563320821598234, 0.11238734729865718, 0.15044485295267296, 0.1041682623563922, 0.209546359846293, 0.11227079992267841, 0.1908564078251842, 0.18692383873774066, 0.18036370613236197, 0.1992418972635548, 0.19916183557193246, 0.16866657527186812, 0.18043308038746642, 0.18980349277832043, 0.18012662265957247, 0.08927746682951598, 0.07494064855134785, 0.08659711411028925, 0.07949860371341833, 0.08786355203542484, 0.08575736367862608, 0.07622543525626757, 0.08466936084146415, 0.08012056772470855]}, "mutation_prompt": null}
{"id": "75409f27-e094-4643-be59-ffda6894f5dd", "solution": "import numpy as np\n\nclass QuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Increased differential weight\n        self.CR_base = 0.85  # Increased crossover probability\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.9  # Increased global attraction coefficient\n        self.F_decay = 0.92  # More aggressive decay factor for differential weight\n        self.CR_growth = 1.02  # Slightly adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumHybridOptimizer", "description": "Quantum-inspired Hybrid Optimization with Adaptive Strategies leveraging Differential Evolution and Particle Swarm Optimization for enhanced search dynamics and convergence.", "configspace": "", "generation": 36, "fitness": 0.26447965972520393, "feedback": "The algorithm QuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7639585103700965, 0.7586800730747112, 0.7270582731082864, 0.7395993612124828, 0.7350585415772358, 0.7653320903050529, 0.7414760347652785, 0.7365021419055655, 0.7558180666783126, 0.49094495236822655, 0.03175712336188752, 0.0682525033189324, 0.44504419841850673, 0.530959454108531, 0.5226736697951049, 0.04868181254550075, 0.44450452230546666, 0.5266519149984024, 0.10921169636294525, 0.12620700002476337, 0.10857022538957795, 0.12712232164265258, 0.14759746352693015, 0.12765179160054863, 0.109675004750998, 0.1041468940851984, 0.12264884691315148, 0.11411282308690007, 0.10163625256808317, 0.13530238537465133, 0.1109286497044355, 0.10615073314145174, 0.12380341131724582, 0.09984835259122538, 0.10528305390192838, 0.10243802865664875, 0.958817771048236, 0.930573761509736, 0.9589069929931506, 0.9727496805508805, 0.945066133252814, 0.9435379008443177, 0.9724980615993115, 0.9614872293040093, 0.9574518707407855, 0.37856717393966743, 0.43952317871125934, 0.38777775070420006, 0.3284790270644796, 0.42212935156370657, 0.38770677730844916, 0.3844261906076373, 0.3781191393930966, 0.439826395383898, 0.7477538503502914, 0.36139336607117956, 0.22067878776185046, 0.3550437114784495, 0.33882935603607234, 0.15861344025898594, 0.23201540801575538, 0.2278411421223705, 0.23161683881696993, 0.20851327764192074, 0.1842872447971048, 0.2103912568092866, 0.2498403521956044, 0.17861752731489866, 0.12095168540157064, 0.1799825019851653, 0.2227461448166712, 0.1653395173841038, 0.12084119171336827, 0.2176672049220013, 0.16609827399154986, 0.12815613176545615, 0.19552836980658728, 0.108876695382083, 0.23652062188597078, 0.2310595538340996, 0.21219372114842117, 0.049520296784263174, 0.022156575590158933, 0.026769142257784928, 0.02369986675234681, 0.010595613018112848, 0.010922861827618147, 0.07615442474517808, 0.01900850885328287, 9.999999999998899e-05, 0.0856316074303981, 0.059949995680031676, 0.03449187130495923, 0.09238622549395836, 0.04232359238893624, 0.06711630182458217, 0.07286603965308636, 0.08114753510755213, 0.025388705199087203, 0.14040785755326246, 0.08848886240581266, 0.04187673478174969, 0.07359078225760018, 0.060494402294303695, 0.07869313085952456, 0.058756230567556855, 0.18041595485603246, 0.07935230006341465, 0.13304989173904924, 0.16402600601334927, 0.10049839144532957, 0.14544325475328246, 0.10744843423025086, 0.19718375645565522, 0.11216545633243025, 0.07234424565935316, 0.18904404729371826, 0.5399885361107395, 0.5120833045332851, 0.5279645715875869, 0.5394183790831455, 0.5205095021374149, 0.4836491729388105, 0.5144864234322915, 0.49709941733424456, 0.5526951349523221, 0.1158925129386511, 0.08042261083999891, 0.11843399394107745, 0.08898790093861553, 0.11839348608148503, 0.10732265402190222, 0.11536578611601067, 0.0946568870655472, 0.11665910470558793, 0.2092787928313562, 0.20192058120891965, 0.24091241897275995, 0.18479171025027785, 0.1876377174911269, 0.30511709204704607, 0.2030380631715235, 0.2386215020094049, 0.1709645247331273, 0.32294020439283055, 0.31971649354662035, 0.4309949492833275, 0.40286996793722085, 0.20104255515725122, 0.4148357727505797, 0.44736417157314734, 0.41346902746470016, 0.4164655799781666, 0.2562410879824448, 0.1963256653907255, 0.24078686306935926, 0.2343421908585558, 0.2648932846186276, 0.28475151562530254, 0.2807529721055726, 0.27598784673813903, 0.19586366411511458, 0.18577068874321867, 0.20625681974521615, 0.19909249453167854, 0.1938088067381547, 0.20192965273326835, 0.20040421234255523, 0.1870132068944964, 0.1977989648934777, 0.20481014170720402, 0.18271367360745094, 0.18817562646668218, 0.21408234465355258, 0.23882729647034906, 0.20771058380948915, 0.21301457656723044, 0.20387979490329156, 0.20248948485266882, 0.19279526611954678, 0.16457297999434728, 0.20455410220863313, 0.16989313464196076, 0.8256412050548669, 0.19808212987272822, 0.14567428023002704, 0.141100721460933, 0.1752810720622745, 0.8281463268801205, 0.6335135061240039, 0.21124898188056107, 0.19244125912438825, 0.12637166230177976, 0.20602694697417734, 0.16245925317201182, 0.11166242941774052, 0.20416320067570815, 0.09389760466531116, 0.17524791347958346, 0.20170408386975025, 0.1879056803576863, 0.197067525291177, 0.17959618245227282, 0.1837535793195083, 0.19054390568384616, 0.17973776124689045, 0.20173138906805943, 0.07506745430055128, 0.08157494643452845, 0.0827462844770771, 0.07556721055268134, 0.08655196743298277, 0.07942845844300062, 0.08477697727820832, 0.07983903579950236, 0.08566747601634561]}, "mutation_prompt": null}
{"id": "85989904-3afa-4b8a-b74c-132e2bd26776", "solution": "import numpy as np\n\nclass HybridAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Further decay factor for differential weight\n        self.CR_growth = 1.03  # Slight growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = pop[indices]\n                mutant = x0 + F * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridAdaptiveOptimizer", "description": "Hybrid Adaptive Optimizer combining Quantum-inspired Differential Evolution and a Fuzzy-Controlled Particle Swarm for improved convergence and adaptability.", "configspace": "", "generation": 37, "fitness": 0.27712853266423637, "feedback": "The algorithm HybridAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7809491643852029, 0.7740639254288058, 0.798381603332585, 0.7819899772703476, 0.7874415570276667, 0.7865363189474596, 0.7778594408913406, 0.7923035082142855, 0.7770949361257237, 0.18124687219367297, 0.5630266665265524, 0.569136768658582, 0.5542149601039478, 0.5592958351603905, 0.5816776617278495, 0.16701457216737836, 0.4407344863507957, 0.5390846857456275, 0.14207155055152032, 0.1383937400804689, 0.07293701566286614, 0.11664252273186937, 0.09257657175991352, 0.1301345658050801, 0.11365120058440392, 0.14118868601148604, 0.13161381993926136, 0.10843975805039752, 0.10256251625662749, 0.12044868333081327, 0.10976241707751866, 0.13172399014460134, 0.10162506178280895, 0.12028566378799499, 0.10493719675302127, 0.126783617627109, 0.9590592099228394, 0.9472717496408706, 0.9720146606703584, 0.9587425843134458, 0.9593320790821865, 0.9590341967590993, 0.9592838747083184, 0.9476330823214892, 0.9587463890873021, 0.5594673695163224, 0.5066054608535422, 0.5098373870965545, 0.43197774161634916, 0.5021092365702827, 0.5021353951254297, 0.4714421530861126, 0.08749722809109173, 0.12294260038331428, 0.3665343358438624, 0.31412563257359605, 0.22412720868955638, 0.27029877301336724, 0.2134577154839794, 0.2074467840688632, 0.7257788472796205, 0.22950293306346126, 0.5755018203031899, 0.18117609808795354, 0.3231550907381332, 0.44404387281649293, 0.12432922399249202, 0.12628740219440682, 0.14603713761857184, 0.15030348219165846, 0.15233345598830206, 0.14372245348451362, 0.14720835605886418, 0.13724821609099513, 0.23271591358624277, 0.4140025208515963, 0.12742663407207488, 0.12549111016424974, 0.20795317975788552, 0.18194208456194005, 0.18282602137441228, 9.999999999998899e-05, 0.034949180515086664, 0.024943841607086847, 0.03485347063115929, 0.022575254755491603, 9.999999999998899e-05, 0.01983440097836031, 9.999999999998899e-05, 9.999999999998899e-05, 0.07984554748992012, 0.03666867127486806, 0.0791193704943518, 0.091748304399349, 0.09898853411270647, 0.030732107790001795, 0.10701458790052842, 0.061020712684905276, 0.04267851915363208, 0.0630690374119498, 0.031251408739244146, 0.05138737892491829, 0.15247020161435443, 0.08404132170967837, 0.06431729103351191, 0.08661692866494008, 0.1148866760750128, 0.11855824180456342, 0.16632191275263253, 0.040899986963799706, 0.10396616475682463, 0.1761531984832604, 0.05215650834211716, 0.10833373827126203, 0.07609505851865794, 0.053484361330135344, 0.2993984351127148, 0.5581204625918186, 0.4957943099872587, 0.5423881103198388, 0.554483874329377, 0.5251184522429999, 0.5107802034211189, 0.5123307187842119, 0.5385054091658537, 0.5473832182330172, 0.13560254131230232, 0.12223741671018029, 0.09024290328792273, 0.09258372822741456, 0.09189508635215282, 0.1308154485167613, 0.12519109470324075, 0.11204322034814773, 0.10493031879798997, 0.29370895806683806, 0.17855194383538764, 0.1548880648161769, 0.3303268868784479, 0.35956162915272927, 0.2707978097350878, 0.1712518682999029, 0.15199157308992906, 0.17263249096401434, 0.3383744523558734, 0.4335463591377695, 0.43625723393976046, 0.4616356850267439, 0.3629603663827886, 0.372900416826326, 0.2761570269194634, 0.46973112026841535, 0.34680904794093936, 0.23744833361617612, 0.32370302387756733, 0.19468419659657454, 0.2550472153607932, 0.3523318722299623, 0.21382897755872776, 0.316774242591344, 0.26730329059181457, 0.20486240509008358, 0.22712184856412343, 0.18719918647260658, 0.19066475958001894, 0.20212879366874192, 0.1820709868257423, 0.19769000101139056, 0.20543201410107093, 0.24741436572430953, 0.219785293481767, 0.18460781103478796, 0.19714034793459034, 0.19070153211422436, 0.21672926760756128, 0.24365637947496765, 0.23073760707165425, 0.23755845046149604, 0.21715354485489913, 0.18465599377161612, 0.8579878190120425, 0.1863043800820916, 0.18417350935808785, 0.8619360510056593, 0.1988370456421198, 0.19894307784423115, 0.14143609822085923, 0.16155758044242885, 0.1713819348783704, 0.6067324329420345, 0.20932951744991457, 0.07328008454472312, 0.11106274457533416, 0.1268798432642959, 0.22238847541465356, 0.33152394021920306, 0.15262798249284337, 0.1685245462905346, 0.19892039554584406, 0.17998594828081282, 0.17692485677194913, 0.1768658031904391, 0.1981690007846384, 0.22144076436329452, 0.1794694162987398, 0.1814019987483214, 0.20716534431428668, 0.09008307399415894, 0.09441941760455264, 0.07552663862886677, 0.07832227456926555, 0.07618731470108997, 0.09041552283192855, 0.07794314546543468, 0.08623447236166071, 0.08769883581533888]}, "mutation_prompt": null}
{"id": "3a9c6fd3-8ba2-47a3-b944-0e53ac998f65", "solution": "import numpy as np\n\nclass QuantumAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slight increase in population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.9  # Increase differential weight for diversity\n        self.CR_base = 0.7  # Decrease crossover probability for stability\n        self.w_base = 0.3  # Lower inertia weight to encourage exploration\n        self.c1 = 2.0  # Further increase personal attraction coefficient\n        self.c2 = 2.0  # Further increase global attraction coefficient\n        self.F_decay = 0.90  # Faster decay for differential weight\n        self.CR_growth = 1.02  # Slightly slower growth for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumAdaptiveOptimizer", "description": "Quantum-Inspired Adaptive Algorithm combining Differential Evolution and Particle Swarm with dynamic parameter tuning for efficient global exploration.", "configspace": "", "generation": 38, "fitness": 0.2835360013743506, "feedback": "The algorithm QuantumAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8137444025843397, 0.8050455728186654, 0.7988974679555393, 0.8149774214989217, 0.8218476729826543, 0.8062502304872803, 0.8127534582699882, 0.8206151951212807, 0.8039011239957703, 0.5305376945152369, 0.6229343536827374, 0.6715309735799448, 0.6464772335334065, 0.6481122983522378, 0.5520277367475032, 0.5885627191694149, 0.6362175223548684, 0.017722689747542653, 0.13214464972381101, 0.11686830826193928, 0.1522987310577757, 0.1433608708922981, 0.10252613260739707, 0.12971644588505482, 0.13135002812956464, 0.10853476143195062, 0.11143192213371, 0.13633794225076912, 0.10244690090027764, 0.1502511509939748, 0.11239998220204706, 0.09720155883119219, 0.10074422573509523, 0.10026759238807248, 0.09405971251138112, 0.10623424708325369, 0.9671077892137423, 0.960840441086786, 0.9476150950812736, 0.9719536121470628, 0.9598929506558899, 0.9593818894625397, 0.9602489096833144, 0.9621383777978434, 0.9728860859078549, 0.35798920501395437, 0.3874096742828781, 0.3155403492671677, 0.3822674521419096, 0.4301625883821871, 0.4068886868597624, 0.4058364361311009, 0.34363371588224645, 0.38794040057218293, 0.22495213785473556, 0.21115306052484273, 0.7280819396978704, 0.26902867745683967, 0.258117976975587, 0.34037068814505345, 0.37668085236356896, 0.17649927838416735, 0.6587155905612467, 0.1613821360694594, 0.11286678640794812, 0.3280974172957618, 0.1422035914900609, 0.17097143267225967, 0.1470345420646001, 0.1861719276789232, 0.15605335858617286, 0.16036310762691697, 0.1267766918325144, 0.13706006624472955, 0.15476446240443598, 0.14858982494787631, 0.1474799989690878, 0.21744576527998105, 0.12614912819644963, 0.20202727893687422, 0.12613466528781703, 0.029632335396644005, 0.010390450347667501, 0.05716227002531582, 0.0003398286252220828, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04325454927601602, 0.06236986766709396, 0.04898357296578704, 0.05337401746534709, 0.04441468689017425, 0.07207657242706067, 0.03139243746732323, 0.06027370363693518, 0.034771973072042384, 0.0494543880693229, 0.03237045975868291, 9.999999999998899e-05, 0.12479694359519233, 0.09125409007586771, 0.09850936065743787, 0.10967033515209279, 0.12754599162724078, 0.14451957116120762, 0.09496056161597877, 0.14539889827718266, 0.015358389484514734, 0.08369822160170148, 0.08791123727802552, 0.04592720380241899, 0.05583581530093984, 0.1120978732033131, 0.07921133736773556, 0.08101750528163665, 0.5701536841658126, 0.6263847502142283, 0.49349698580325174, 0.5385000748097211, 0.5105265461143855, 0.5075573580892707, 0.5191717352106284, 0.5144249842222061, 0.5685501486732346, 0.10068245868963799, 0.08229361199701091, 0.0902538248235969, 0.09041287733346604, 0.10069976578444007, 0.1175143668413684, 0.0906527658108065, 0.09677118841132837, 0.11744851104095777, 0.22984248343878955, 0.331188417519082, 0.1776409120214516, 0.17978067141138487, 0.3462758903342398, 0.3602264592029426, 0.47370574024291623, 0.1665030814229873, 0.18488087824043276, 0.3734429232880029, 0.3798461799435793, 0.3467671469358379, 0.32689918975471044, 0.4079884151354165, 0.3987652175570632, 0.2807732625279533, 0.48762248654759965, 0.4475105548191063, 0.2969421579958751, 0.2057942783083565, 0.2570661826486915, 0.23064316057274814, 0.24820768972271656, 0.2758330454552246, 0.2589873635996026, 0.2699809966382031, 0.20775631217525514, 0.2105774789490421, 0.1835075452102266, 0.19834012662500067, 0.18716364693840049, 0.1862726676794032, 0.18845007552832294, 0.19427554002237035, 0.1911301771048346, 0.21802642046927412, 0.20222129985683102, 0.20125293838464753, 0.21654978632297317, 0.22711059407549683, 0.6071599372185043, 0.18352944353591205, 0.20914393487112726, 0.19051772195699856, 0.24390993265177863, 0.15764546999896922, 0.8508329546020511, 0.16518897833028445, 0.8457488760577094, 0.19923772373891213, 0.16914868827936191, 0.7845207905426416, 0.1632804349381175, 0.1414085969820158, 0.4965427818376611, 0.2090682949596483, 0.20869414669855968, 0.20492511621906584, 0.16585935652203843, 0.6505338351455104, 0.35413086267546634, 0.20869445536650832, 0.2071540969179826, 0.1846139972342935, 0.18584769851341587, 0.19164214708671534, 0.1881386377423575, 0.18591254336980279, 0.18270843838037787, 0.1820430951658446, 0.1829673128099113, 0.1932083979075926, 0.07482824774932217, 0.09019511212329112, 0.08715931543717148, 0.08361321352671947, 0.09175923269214492, 0.07599954445415824, 0.0648220238159185, 0.06910330764806782, 0.07738114597795853]}, "mutation_prompt": null}
{"id": "d951bb8f-8e1b-421d-b21f-bd89b282becb", "solution": "import numpy as np\n\nclass EnhancedQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_min = 0.4\n        self.F_max = 0.9\n        self.CR_min = 0.5\n        self.CR_max = 0.9\n        self.w_min = 0.3\n        self.w_max = 0.7\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.mutation_factor = 0.2\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_min + (self.F_max - self.F_min) * (1 - (t / self.max_iter))\n            CR = self.CR_min + (self.CR_max - self.CR_min) * (t / self.max_iter)\n            w = self.w_min + (self.w_max - self.w_min) * np.cos((t / self.max_iter) * np.pi / 2)\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + self.mutation_factor * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumPSO", "description": "Dynamic Parameter Adaptation combining Quantum-inspired Differential Evolution with Particle Swarm Optimization for enhanced exploratory capabilities.", "configspace": "", "generation": 39, "fitness": 0.22072672268471696, "feedback": "The algorithm EnhancedQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6086330364920449, 0.5885475516174627, 0.5900374950739065, 0.5915359459165902, 0.626836891238395, 0.5974805248931696, 0.6103610411630234, 0.6149940722704494, 0.6029228395364785, 0.1883391952137493, 0.23974720809680916, 0.15904845571109216, 0.25414599503703916, 0.2279453086741261, 0.047396878233828876, 0.24772453856362642, 0.21597965742621694, 0.21393516853744332, 0.11446492319860757, 0.09028941988326755, 0.09909804605421346, 0.09857989928847799, 0.1502193863841509, 0.099720862101768, 0.12434218430241994, 0.09216092415970656, 0.09569310040520174, 0.09597728580091935, 0.13868064965051086, 0.10682223505117328, 0.10047267753347566, 0.09799228928961967, 0.09626394348441969, 0.09245476102512762, 0.10847385424352052, 0.10020506446468458, 0.9592437910587697, 0.9693533161742719, 0.9582212015116057, 0.9492040449284028, 0.9563548700760044, 0.9616820645442402, 0.9695258405271004, 0.9592539979076956, 0.9595417440673861, 0.25487545339578555, 0.22182952075288298, 0.27957265770244555, 0.18782095445531866, 0.25715453911801, 0.2348131794235938, 0.19636375468941536, 0.2830403615147816, 0.24938030950895895, 0.48561445053894936, 0.34741279513288015, 0.25393977732803275, 0.34772048460768556, 0.6554382103376282, 0.190464488287017, 0.24998584819667757, 0.19393333433176274, 0.1890891662484212, 0.15514436852634428, 0.10803489567070534, 0.1347108718905633, 0.08630587318948835, 0.09781197689515375, 0.1325075264840314, 0.1528582432930411, 0.14417847842063458, 0.14891814421950111, 0.1446552822554208, 0.10207516021302732, 0.19093557193327693, 0.14957486232261163, 0.1448432424227425, 0.12365402469797304, 0.15955408477114763, 0.13956084560348336, 0.12170483658357423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052311520163578096, 0.06429469139573352, 0.07742525198252026, 0.07182092902558435, 0.056153865878532105, 0.015509765209575144, 0.04003240637775074, 0.07593255915457575, 0.06684570890397157, 0.10430388338213725, 0.021464559707127906, 0.080660551491057, 0.10657565605223951, 0.05241000883703695, 0.03890632025281171, 0.05669693352399385, 0.052463493876570455, 0.043952285178828654, 0.1414138348191296, 0.0500023313518142, 0.084871799196366, 0.09850852094213747, 0.0354768290818287, 0.11049176075331357, 0.07027074069675687, 0.04936903436340656, 0.06833829326042395, 0.42820235661215444, 0.4230036103507687, 0.44672408170679834, 0.45566708991866967, 0.4408318081378375, 0.4255017181125933, 0.4356925135693217, 0.4472663897300102, 0.452275581825465, 0.07133297704402775, 0.1017856546330349, 0.09307536802488225, 0.07900552854924847, 0.08854806354326916, 0.09362975451612743, 0.09955764053252913, 0.08629593160019833, 0.1115917649850593, 0.19258535017950895, 0.15853090719638618, 0.15153968093734915, 0.15114058513203454, 0.18300823256657583, 0.13353614762545563, 0.14996176145148732, 0.219640816041611, 0.15343717247828603, 0.3093300665226191, 0.23461682427380093, 0.330474534194902, 0.32279170069972274, 0.2984582156391514, 0.25983943045129654, 0.3328690469876562, 0.3188318927296636, 0.29718384040472834, 0.2396463348623743, 0.16405723150396656, 0.2570362859783636, 0.24603869680814727, 0.1996499395302398, 0.20292455663286846, 0.22151009111446418, 0.273666374916411, 0.23670078366439284, 0.16319522131667596, 0.1851076633054024, 0.1900573081115211, 0.18322889209099424, 0.19324617862034177, 0.20456323700491819, 0.20091285112301083, 0.18439480051027157, 0.1921968283775748, 0.1856936892825265, 0.2428180025224569, 0.2951913362672999, 0.24468852882256908, 0.18760041561946705, 0.2152522924603446, 0.21705530517507654, 0.19378537223454928, 0.1953343876778456, 0.14492035583192042, 0.1845196617651107, 0.18578570396443528, 0.18565326065376564, 0.197686473819374, 0.1301176993551415, 0.14025103956827822, 0.1580593262033959, 0.1540110692781067, 0.296606114934849, 0.2028808810056395, 0.1949007788208803, 0.20960373127027976, 0.33548916209931867, 0.14788450323944669, 0.10396863991628325, 0.20426855032480007, 0.3068791580983885, 0.20323545351251326, 0.19575919713307832, 0.19809186433005166, 0.1835878062228129, 0.18793222878726568, 0.18799223796659625, 0.1902974116989078, 0.17496357999222234, 0.18014422695485233, 0.07342682469967243, 0.07953652926120103, 0.06497794559883441, 0.11189789893714697, 0.0772128654330958, 0.07556293510628298, 0.0845917360984999, 0.07744576857779573, 0.08072754436635665]}, "mutation_prompt": null}
{"id": "6b788c54-8adb-4f97-ae7f-4d5012ad8d70", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.90  # Modified decay factor for differential weight\n        self.CR_growth = 1.10  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.7 + 0.3 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - global_best)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Integrative Hybrid Optimization combining Adaptive Quantum-inspired Strategies with Enhanced Local Search for efficient convergence.", "configspace": "", "generation": 40, "fitness": 0.278910075739733, "feedback": "The algorithm QuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.767441818091052, 0.7743614348606104, 0.7736406456849227, 0.7818662924677621, 0.77541252212842, 0.7635920803686713, 0.7661731401091592, 0.8030906345986426, 0.7654164186903762, 0.5635416039858133, 0.5875124237945442, 0.5586147775856659, 0.4416391115716527, 0.5576853251533371, 0.5908182049429919, 0.553498232464746, 0.5600689567895114, 0.5116322446307991, 0.11824179797337875, 0.11868041891822634, 0.14567929798039114, 0.12431184777373872, 0.10963668007716876, 0.16251473687009532, 0.09161396461677285, 0.12872331033872175, 0.11139312091282116, 0.13130222619377818, 0.10953282188329705, 0.155042641947148, 0.10033656845856365, 0.08130426597395868, 0.12758421269153186, 0.08928333278085587, 0.12710749335076688, 0.10726906681282089, 0.9484352833624624, 0.9357255144701317, 0.9490785695259736, 0.9243048927627723, 0.9604083690275826, 0.931802800757966, 0.957986022269679, 0.961370876643804, 0.9577688566044134, 0.45755696338835805, 0.4999270801000274, 0.4617749346736997, 0.45525333499795406, 0.4723750118679304, 0.4560316025975065, 0.4865745387561232, 0.45100310466931726, 0.48714342221417906, 0.21790441224433632, 0.223744731106572, 0.22423199137605054, 0.20819860273643165, 0.21019212680691712, 0.2588487438888709, 0.2223656032007747, 0.7589735774304118, 0.7560431074739922, 0.14491467938579083, 0.1758559077261974, 0.1275537340577293, 0.11268662434865762, 0.1616536516592365, 0.16172474679394622, 0.15727580086648252, 0.2472799507482918, 0.1655332922846655, 0.17834611615652107, 0.09141249969618692, 0.19853358343741134, 0.17054344593954085, 0.2076276281657935, 0.1874363144979545, 0.14122900442303032, 0.12879459505960345, 0.10399546789514602, 9.999999999998899e-05, 0.051220923391228856, 0.05218099597702841, 0.03810128005797908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0760586078696982, 0.09137377665884927, 0.08248840274104918, 0.09151268015036862, 0.010929325766421472, 0.07499607289107169, 0.06622969207136031, 0.06710385480935888, 0.08169912803204948, 0.030088736068078492, 0.09221423147115637, 0.03337839516141361, 0.1165263386025217, 0.3306453758574456, 0.07840520723868416, 0.08739200999150998, 0.13620077159030608, 0.08332498779007214, 0.176152000872423, 0.08612921658446215, 0.15168682877458306, 0.24456608815116054, 0.1526574890477257, 0.14367483251211488, 0.23016898650658835, 0.05206245164998635, 0.11237661959706091, 0.5098119680785573, 0.5044441681251022, 0.5021006959500217, 0.526075315062299, 0.5177541270596262, 0.527270493328845, 0.5155532934686289, 0.5707830431320695, 0.5718971579161347, 0.10943497530685131, 0.0912993130906048, 0.12149592499564255, 0.11665205716310834, 0.1220823255195208, 0.17067596330406032, 0.10545858315117274, 0.12604714206683498, 0.12499932558076798, 0.21533435822579716, 0.29017154375455934, 0.1863954625126909, 0.2277961135939336, 0.2533765580848323, 0.18217542191865677, 0.26666004228678886, 0.18526763562563242, 0.17259893885397215, 0.4279964979131491, 0.24269547751223497, 0.4279667840535303, 0.3985145172067398, 0.4609959463075112, 0.4703046539302014, 0.49302400013940884, 0.4265648665775157, 0.2631164324567995, 0.3315487830993433, 0.2376428864650526, 0.20928269084535045, 0.2927946055804225, 0.25076933018732717, 0.28960763784584886, 0.3013609972779343, 0.35532503612207567, 0.20477654937709944, 0.19547508761634014, 0.18989484143639523, 0.20621187732771584, 0.2077908224579379, 0.17892255376251942, 0.19940612942521585, 0.22218180620731953, 0.19042199760865763, 0.2157239451581967, 0.21462564458640787, 0.23696051765483483, 0.2032158219043565, 0.196172367953641, 0.21724415091640636, 0.23085545978657462, 0.20008109957186004, 0.20432695085575792, 0.2322873502752003, 0.16866090386077937, 0.18413072384860008, 0.18291987857123382, 0.16704056598175443, 0.19898894048792937, 0.19653575112878086, 0.1408765460548853, 0.16230712510972478, 0.8218793609000958, 0.6659748552029942, 0.2106722161396558, 0.20755107265271366, 0.10833880560394793, 0.2102649708083386, 0.20315600728686656, 0.16208043647466674, 0.10409104426410942, 0.16566933765432545, 0.18894113615270935, 0.19468228772882368, 0.18305325384353655, 0.21510069774142893, 0.1908263527414943, 0.19196455165753745, 0.19105148948763984, 0.18716152788225549, 0.1860803939029514, 0.0762682997511156, 0.08384015606030881, 0.08622952950432572, 0.0893350896066073, 0.08358323131182022, 0.08322027979356172, 0.082984876969735, 0.08567553779751302, 0.08861096180506922]}, "mutation_prompt": null}
{"id": "ce2060aa-3ed0-453f-869f-f35f032ab251", "solution": "import numpy as np\n\nclass QuantumEnhancedOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim  # Increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 2.0  # Enhanced personal attraction coefficient\n        self.c2 = 1.5  # Increased global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.3 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < np.min(fitness):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < np.min(personal_best_fitness):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumEnhancedOptimizer", "description": "Quantum-Enhanced Adaptive Hybrid Optimizer integrating Quantum-inspired Evolutionary Strategies and Adaptive Particle Swarm for versatile search dynamics.", "configspace": "", "generation": 41, "fitness": 0.12682260731886374, "feedback": "The algorithm QuantumEnhancedOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.10.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.2419564496847766, 0.24467165600069063, 0.24555100478546088, 0.2272154523223039, 0.29241351918935765, 0.29112171353749505, 0.20759423059524995, 0.21692133006703163, 0.27827334466307196, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005963939587760203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07426593833104345, 0.08020404987395247, 0.06354607739378149, 0.058251332879212914, 0.06490629432346906, 0.07430643873245846, 0.085911480964456, 0.1153528886410835, 0.08270400485623008, 0.05111300889315207, 0.06216836949118443, 0.048070854150258135, 0.07375424311668244, 0.05610576509252119, 0.049270939788414014, 0.10416678383822786, 0.05133237757717035, 0.047216325275766025, 0.16741797526054725, 0.2715769574301721, 0.1564990728168707, 0.1293907440288138, 0.1273890778176079, 0.9439953520851853, 0.1896073925005125, 0.16181157154857306, 0.13111498370375307, 0.16590403112125818, 0.09487695256317219, 0.04443603815088337, 0.07989732925651549, 0.15715818070669918, 0.13674132303812492, 0.09383212445051392, 0.13215036134284763, 0.12609600896728423, 0.214132552463419, 0.25220135560725354, 0.20357484387830782, 0.24265456188959234, 0.23163077994875092, 0.16720883663487474, 0.11364771565724896, 0.16664458150267913, 0.18358588752665417, 0.07823633075222136, 0.09122647025020592, 0.022338933712487186, 0.03945415759892146, 0.05281832713198242, 0.12803484467413906, 0.07014815743502933, 0.05513841267399733, 0.09966815933534656, 0.07534809345679772, 0.08410123204126685, 0.06420425005269104, 0.06897484311563462, 0.0749179082558118, 0.10395505306240516, 0.07360735383427186, 0.0548599954754051, 0.05678428222293663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006726369141851762, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07195390996564399, 0.04096474008894313, 0.07929473977082857, 0.06497372463881679, 0.06399901750755066, 0.02323671578158515, 0.02652272842123371, 0.06354832763535856, 0.04127781107327866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026448954882675624, 0.02257180162901018, 0.03525748462029554, 0.013467080927987318, 0.05042116858895518, 0.007986385194501011, 0.03328298648941963, 0.012568664909236915, 0.04849809452291354, 0.26097313918564014, 0.2625755749137131, 0.2981026479054145, 0.1998207492661057, 0.23312150659999975, 0.22506016766527825, 0.34990588138004497, 0.2464976694768104, 0.22327638973182962, 0.05057864429799808, 0.04891591406490592, 0.06909675096832057, 0.08799866375490362, 0.06672896954680585, 0.07828514579234291, 0.054868271148083125, 0.08726336338730345, 0.08102926554753753, 0.14031934388906353, 0.17384844731686333, 0.1608244753310366, 0.15989819924127058, 0.17884267558065348, 0.16580894752528652, 0.18748126392885067, 0.15425812790926885, 0.13411680028515405, 0.17369676585617677, 0.16579631887255852, 0.23265431956362792, 0.19662639103051582, 0.20580988830109825, 0.1697406795918489, 0.21366392656602273, 0.246489632266909, 0.19635953347466595, 0.15570409548939712, 0.10757581508741099, 0.18002419829116045, 0.14214276669570503, 0.12747942359008813, 0.15231358734633504, 0.17858461522464042, 0.16987031087875326, 0.1389150757239267, 0.20558806172451283, 0.21138595355288603, 0.18632715223509322, 0.20707450746779854, 0.19258408125966953, 0.18095391838424535, 0.20766771979480791, 0.20594000700656667, 0.18267585589724822, 0.16681749093318576, 0.16987287020989605, 0.16376424400253886, 0.1897930152828049, 0.17989654196904936, 0.16679341933586078, 0.17485696759038472, 0.17969618429831646, 0.14567829512800634, 0.12616529438565172, 0.17845199925958255, 0.2926273628647499, 0.14936773086272037, 0.18691398917759539, 0.16449589715007296, 0.16914318981861998, 0.16382585912222491, 0.3265189150583294, 0.3422020737550858, 0.18201752211358357, 0.19939461724799912, 0.17534580311171266, 0.2238320000507925, 0.12322751669465393, 0.1613724167976468, 0.11563968569086991, 0.2723448995249641, 0.17286184898120738, 0.18829898320288663, 0.18751520334789495, 0.1896144881905828, 0.1911575307016279, 0.20327734248913631, 0.22567631041261715, 0.18303291550813106, 0.20971955585123359, 0.07667145665667285, 0.06878587761057209, 0.06810987129169155, 0.060071986262600685, 0.08576111411680232, 0.07011556437857669, 0.05085913011430676, 0.07085919292991572, 0.08532722638271262]}, "mutation_prompt": null}
{"id": "b10ee846-7d7d-4a94-b9bd-fb37df27ade1", "solution": "import numpy as np\n\nclass HybridQuantumEvolutionarySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight for better exploration\n        self.CR_base = 0.85  # Adjusted crossover probability for better diversity\n        self.w_base = 0.5  # Adjusted inertia weight for better balance\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.8  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n            \n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumEvolutionarySearch", "description": "Hybrid Quantum Evolutionary Search combining dynamic parameter adjustment and intelligent mutation strategies for enhanced global exploration and local exploitation.", "configspace": "", "generation": 42, "fitness": 0.27254536186987977, "feedback": "The algorithm HybridQuantumEvolutionarySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.776958111769092, 0.7652050218982225, 0.7421658051713735, 0.7890611861583332, 0.7839069196560318, 0.7687605968548298, 0.7520700635890758, 0.7627909798822099, 0.7868218950608727, 0.0962805078987814, 0.2247779268554333, 0.0689684448557939, 0.059244131039564496, 0.5541426015149213, 0.517627960752397, 0.40048380727254507, 0.5265606781671511, 0.5459661828372433, 0.11723904031903876, 0.13927158175600218, 0.1067988311232837, 0.07010103680079227, 0.10306242723112724, 0.09991421088371921, 0.11727788783549054, 0.10741330633839008, 0.11358954793282938, 0.14459187640982563, 0.10119864689321456, 0.1110355555153425, 0.1007239875572159, 0.08435607026776759, 0.09179613783524432, 0.12479449506543205, 0.1032139679704307, 0.09143002875072781, 0.9574195338716944, 0.9041064978892775, 0.967006731247547, 0.9727122977443801, 0.9606354559998502, 0.9506943946328523, 0.9716511229844441, 0.9608899265416777, 0.9563260966432263, 0.4238339829821669, 0.4295394723790267, 0.4477204149824797, 0.41860533318777027, 0.364551487389031, 0.4302437480552076, 0.4523250431517116, 0.4024244650311313, 0.39356632117270374, 0.7822345349019164, 0.7513708475707314, 0.34397373744330584, 0.19258359025565308, 0.24535700428519103, 0.6256880264973481, 0.17399298186228096, 0.3208366013053615, 0.3585839789002563, 0.3062675297934997, 0.1689174798977976, 0.1635216104713091, 0.16107862279782326, 0.27648604938438226, 0.16506548678780253, 0.2093876183047899, 0.272394590033735, 0.1710092285619066, 0.12549218862956313, 0.20509520732832165, 0.10378616535800333, 0.12883273300208997, 0.14060509234543295, 0.11374089630659023, 0.21761970441105583, 0.21334484793904718, 0.11419358800883617, 0.00011468246295698314, 0.013368552408097645, 0.0031417468134270488, 0.0025293110816739794, 0.003361735669583088, 9.999999999998899e-05, 0.009964605803123416, 9.999999999998899e-05, 9.999999999998899e-05, 0.07996068969213666, 0.0730219230907444, 0.09747088483001731, 0.1336367586718743, 0.04701964586940943, 0.010624606032459072, 0.08702882489665986, 0.08341384491234771, 0.047688466561210396, 0.10322653846202468, 0.05826433697857558, 0.06499673470882228, 0.22272186749078238, 0.05462754376151957, 0.07800168258964879, 0.13177959627115943, 0.1731372552913636, 0.09107207467251466, 0.15223415287480946, 0.07727832976979676, 0.15079724258315397, 0.09979470235523091, 0.11349762970379029, 0.12956303183633477, 0.12970991769826012, 0.21162232247428525, 0.10752799537906954, 0.5164536526946859, 0.49160445247217144, 0.4974967677759985, 0.5182845301461176, 0.5177824363292125, 0.5299730603601858, 0.5104026487791227, 0.5176306898046337, 0.48910869095957543, 0.14354215774872559, 0.11728833494868574, 0.08072446396470945, 0.12991983017438868, 0.08870200061101152, 0.09701067496523885, 0.09134236289074937, 0.11743870759107722, 0.11587941558334747, 0.297699091719114, 0.20028524817440507, 0.16575581520758265, 0.1761326598537244, 0.23652407066851888, 0.24557576755739496, 0.29969108798689603, 0.27041820401343475, 0.2550084471787961, 0.38610227362494487, 0.449257045820995, 0.384052231333585, 0.3510888324089406, 0.21165177898567322, 0.36036728736987667, 0.369586759867507, 0.3840432089844418, 0.31098379571727586, 0.23730741753961104, 0.14662119486838487, 0.23220352101465047, 0.2439430033404284, 0.2360431134058253, 0.27799048645708535, 0.32656088701467545, 0.3130471981410017, 0.21567143602866157, 0.2056209407660673, 0.19655419526571993, 0.18866770630457885, 0.2018758731610486, 0.2063116515044734, 0.19052465268457086, 0.2052589972041804, 0.20106927825447185, 0.20640543379888654, 0.19989217704389883, 0.20691196220288244, 0.23872223145367566, 0.4648976115551483, 0.1940079308742465, 0.2035599127226222, 0.1831170760332761, 0.23137687700654908, 0.2086749315055153, 0.16474809420202385, 0.1637265140094707, 0.16915733012339407, 0.8079560808515341, 0.19835417365431207, 0.14554457514620023, 0.1416798301009039, 0.19714778975461766, 0.8555987152183883, 0.7866205587731452, 0.2104684845826379, 0.07333835269579869, 0.12733837497230927, 0.20791489645802574, 0.15322214840086312, 0.111682642211554, 0.7070523759464604, 0.09417776931376398, 0.1896203214612251, 0.20402750633224775, 0.18048216271628859, 0.18791692750459277, 0.17452760864045636, 0.17562110688291865, 0.18310071212849643, 0.17445533279274772, 0.16924531062901282, 0.07995781082479936, 0.0788159787469036, 0.08315457268590432, 0.08075417659093687, 0.07962407121775472, 0.0843205115533352, 0.07844924282070986, 0.08082641657811995, 0.0737105462604759]}, "mutation_prompt": null}
{"id": "dea2c186-dae9-490b-a219-ea0b9dda2311", "solution": "import numpy as np\n\nclass QuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.8  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** (t / 2))  # Smoothed decay\n            CR = min(self.CR_base * (self.CR_growth ** (t / 2)), 1.0)  # Smoothed growth\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi / 2))  # Modified inertia oscillation\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumHybridOptimizer", "description": "Hybridized Quantum Evolutionary and Swarm Intelligence Strategy with Dynamic Adaptation for Optimized Convergence.", "configspace": "", "generation": 43, "fitness": 0.28487486422960345, "feedback": "The algorithm QuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7622908330418197, 0.7961845342835633, 0.7632169925050203, 0.7856890919460896, 0.7751463354063668, 0.7706742471853837, 0.7686653232217487, 0.7338813225094102, 0.7733497970245938, 0.5144501766088411, 0.459829602131292, 0.06501439524529429, 0.4999741334824004, 0.5245007585979187, 0.3714144994056253, 0.058320003300354584, 0.05325918402939933, 0.2622238977915756, 0.1687940440949609, 0.11583119993206781, 0.1170818289858786, 0.09972492273157729, 0.1139116260408759, 0.11015569294325633, 0.1342301507315411, 0.15180653081196682, 0.12235248180094971, 0.10919759459819756, 0.10161125307432306, 0.14785750776573292, 0.13574153125677713, 0.10462528889642819, 0.11366786771269677, 0.12249382998490765, 0.10340982622067585, 0.10833018272106909, 0.9572597279506582, 0.9171435419264778, 0.9436460120606442, 0.9673086223760231, 0.9602208877173429, 0.9322985188454096, 0.9590455901136627, 0.9606510522760433, 0.9569470461972474, 0.3797937098979567, 0.4042829955440502, 0.40879908084503913, 0.3086668304363761, 0.3985472804328225, 0.43892114431508467, 0.3914852932938364, 0.3989126709169739, 0.3718689396177327, 0.7150313560083092, 0.22302465062803167, 0.6531915792798446, 0.20985587940448458, 0.6037502891538691, 0.6585454418090824, 0.7103754624713725, 0.7639932733755472, 0.6686160440454652, 0.1972589208852542, 0.2253571593213034, 0.12847172289009268, 0.17528027695983894, 0.18424062772839167, 0.11257019589716133, 0.1817487846145872, 0.21267727542631276, 0.15572712988080128, 0.20042401692958223, 0.21681471750596715, 0.21705033511602934, 0.12651885697463072, 0.22434838220269782, 0.24954089573308413, 0.21327900572598002, 0.11992192082415365, 0.23640298877293076, 9.999999999998899e-05, 9.999999999998899e-05, 0.04623928279058931, 0.036765000914411594, 0.0014880188201572553, 9.999999999998899e-05, 0.006440958098256289, 9.999999999998899e-05, 0.08634950733665336, 0.09523742124617507, 0.0994608373360798, 0.0808410238334798, 0.09648696702727488, 0.1096973323565964, 0.049685758871507835, 0.07669334933092853, 0.07896641426333095, 0.1730980241412644, 0.08538481035877521, 0.0327432344217643, 0.127959948330586, 0.10352012364054519, 0.13957163505118642, 0.1584230215284499, 0.17182009861489445, 0.08374881231505094, 0.08054284439656167, 0.14078577366605072, 0.21457768511048458, 0.18048610336281123, 0.1646995962130159, 0.2818444759548244, 0.0862835132113089, 0.0774348735232041, 0.11465244752502546, 0.21611495045218287, 0.5009213524916181, 0.5218957560456858, 0.5309823407331999, 0.5332834043488713, 0.5319822231272571, 0.5181879278500411, 0.5157398180250361, 0.5171510450202086, 0.5402833317692404, 0.08216369726374506, 0.07034296372392368, 0.09698477684895279, 0.11007804291144008, 0.07128108529823107, 0.12012805044746344, 0.14586625491772143, 0.11994313883384689, 0.1068231893085334, 0.3017421912215513, 0.16381319317346266, 0.1692964539066365, 0.17694238052720213, 0.22345991087048522, 0.18482829430931746, 0.20369647605302044, 0.23566679966916593, 0.24873719689174378, 0.39983895434054395, 0.3450076857177562, 0.35396124735498047, 0.29131606242362873, 0.3176967320937225, 0.3812027877940741, 0.41590824442737917, 0.4413299114083866, 0.45038780745533047, 0.18260500231908572, 0.16674423494516666, 0.3566378493754929, 0.2621423307287747, 0.2896691363040591, 0.19527317647391884, 0.2406845077893247, 0.33852010444669156, 0.2877006517912899, 0.1769792294164798, 0.1984647302527648, 0.18633081630225212, 0.20637968685551233, 0.21042235980348956, 0.1875144734848735, 0.20985347240569185, 0.19762197889803046, 0.18858516903472677, 0.2257669140741495, 0.2399573096853974, 0.21678016240104048, 0.17897309634887404, 0.2406152797338723, 0.2017634994280727, 0.199645890070267, 0.18526915684361533, 0.2094022055372715, 0.18577063638196734, 0.8358703108894476, 0.16813205398547326, 0.8428885685279537, 0.19847565113256493, 0.19130156812695254, 0.14111276356782743, 0.1725034705079399, 0.14140472089092948, 0.7311485090847822, 0.21200962139025892, 0.20778302760444767, 0.20328832949810138, 0.14176787721448159, 0.2083486276659383, 0.16353901430314832, 0.6543210619045978, 0.7301559304294747, 0.174714828616938, 0.1832294963875315, 0.18079214234690189, 0.19317395138754268, 0.18510546907082714, 0.1825724708844213, 0.1901252897016209, 0.19595535259330055, 0.1739779958263694, 0.09497684002430218, 0.07529494491080369, 0.08206049817846073, 0.08936235983086716, 0.08439428017734751, 0.0922703953490398, 0.0806527685912608, 0.07334106397560247, 0.09480716288913793]}, "mutation_prompt": null}
{"id": "95d8b115-9ea3-4ca6-8c04-4c6cd26c9fcb", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.3  # Adjusted inertia weight for PSO\n        self.c1 = 2.0  # Enhanced personal attraction coefficient for faster convergence\n        self.c2 = 2.0  # Enhanced global attraction coefficient for better exploitation\n        self.F_decay = 0.92  # Modified decay factor for differential weight\n        self.CR_growth = 1.07  # Increased growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial += np.random.normal(0, 0.1, self.dim) * np.exp(-t / self.max_iter)  # Adaptive Gaussian Mutation\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            orbit = np.random.normal(0, 1, (self.pop_size, self.dim)) * np.abs(global_best - pop)  # Stochastic Orbit\n            pop = np.clip(pop + velocity + orbit, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Enhanced QuantumCooperativeOptimizer using Stochastic Orbit and Adaptive Gaussian Mutation for improved global exploration and local convergence.", "configspace": "", "generation": 44, "fitness": 0.19446028546607916, "feedback": "The algorithm QuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.4211647616195281, 0.45475514987064247, 0.47166974892284086, 0.44199922453460927, 0.42535848438086143, 0.450249389559935, 0.47539645807030795, 0.4534752286868621, 0.4660066198218885, 0.16713708701508545, 0.0652709923121052, 0.15087805106943997, 0.1247788665322036, 0.060028907146325916, 0.10025772838156555, 0.1183052669362078, 0.18037409692967699, 0.04292871161116851, 0.08568376142866929, 0.07724468094561321, 0.0845193946363848, 0.10616731427722992, 0.0807356341823019, 0.1116724248136226, 0.09093984263750621, 0.07005351351469469, 0.07670160166011997, 0.06841108647655458, 0.07103451263649818, 0.05916505451304477, 0.09149125321460283, 0.09530764240319256, 0.0749803305677702, 0.07915861566244276, 0.0656737678709296, 0.07656482477111348, 0.9744224777681731, 0.9763553314114087, 0.9754781106919271, 0.9768397169651125, 0.9667696198168666, 0.9763451510290814, 0.9767949518971872, 0.9760367806520911, 0.9666698372304529, 0.1666205097868002, 0.18096226970246276, 0.20751090938903127, 0.21580254592643466, 0.16116139351586367, 0.1682795361859435, 0.16897225236115332, 0.16510687424766235, 0.16698078982028997, 0.21791894727351935, 0.1938676721970184, 0.2090607671417123, 0.25274531972054437, 0.29683941460340413, 0.27711948775239537, 0.20576023048623182, 0.28826488575661546, 0.2250494959539927, 0.1251426583466244, 0.1169511763905583, 0.13950674783287087, 0.16584059005309593, 0.1386357237014847, 0.11496875206481583, 0.12943623228500145, 0.12957510119556792, 0.1169822627795909, 0.1330341585380509, 0.10815178922596203, 0.09237686588771521, 0.14437223484528272, 0.14817762568456505, 0.1301560002888047, 0.1282223674451377, 0.12517094038707788, 0.15002954507182897, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008314668883829812, 9.999999999998899e-05, 0.010127970370929829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027934958915179275, 0.03377315898951416, 0.0734440000327179, 0.08383494492719368, 0.03976924533776127, 0.0045915262362179465, 0.03059080544985393, 0.043374124404371495, 0.05608258845759717, 0.0002450640611801891, 0.009772176010224176, 9.999999999998899e-05, 0.0027285185987824256, 0.007877358645358212, 0.02070067866709302, 0.03079307914268281, 9.999999999998899e-05, 9.999999999998899e-05, 0.08260586841511486, 0.06454901191562912, 0.06413960987653378, 0.032372477550492995, 0.07183190058340094, 0.04569688863177057, 0.05398569909800577, 0.0935418379708719, 0.07559485961814005, 0.3847281053680104, 0.39554752124410075, 0.36705771932996656, 0.37788677286455397, 0.39221239602815194, 0.3821023165064088, 0.4061320083775707, 0.3912464317324533, 0.3645708418913911, 0.07067709856705806, 0.09207973392293156, 0.08130785588093825, 0.06893410405921863, 0.0746111215551819, 0.07196143088534845, 0.08298121880917331, 0.06306809764969967, 0.0863947819882449, 0.2037792160438472, 0.23531172538916967, 0.1461706142675474, 0.17628198011339014, 0.15973167764460816, 0.16438500029728798, 0.18733946780978505, 0.16787865842253835, 0.15267841317024977, 0.24686571697407056, 0.25577783286436273, 0.26432104198113926, 0.2124358528526965, 0.2793612330638706, 0.2919951699118215, 0.26459972846086977, 0.27346551729292434, 0.2891029501652289, 0.12497320256942024, 0.15206504198510806, 0.21192601381325338, 0.14089303796559294, 0.15502622373560027, 0.16026358900630078, 0.21333520345284496, 0.21037454794513322, 0.1998639019018298, 0.16511654712989743, 0.2177376075504368, 0.1549536712978946, 0.1903226330301604, 0.1808408512819366, 0.17958573384866827, 0.1836285447560525, 0.19684271042733226, 0.1600095445628693, 0.16162731654333362, 0.17801068306786272, 0.18143091035008063, 0.16514656072780765, 0.19347039239855235, 0.1622676814727858, 0.17260133319867965, 0.17632869655072536, 0.16485024104716317, 0.476135694405573, 0.20117488226276026, 0.18366208753465396, 0.561263122579966, 0.18865098070776742, 0.16526326085497145, 0.18227218477056362, 0.17039753577419092, 0.5092622546306894, 0.2221864766976579, 0.20347742932644164, 0.20172294247094025, 0.2013910876431444, 0.1424432573807637, 0.15916241755154115, 0.21092760738827232, 0.2085987148539148, 0.19446852124456004, 0.19422121533811965, 0.18770948189822068, 0.18689256714378388, 0.18630086068877705, 0.17750426254856844, 0.19035555477626764, 0.17897261841686996, 0.19252284842082112, 0.18247845297195897, 0.06395557652667572, 0.07167792612282842, 0.07078572145387974, 0.05931219270058441, 0.06989636118534837, 0.06236056631818898, 0.06136466876979152, 0.07008246302105559, 0.06829818957389577]}, "mutation_prompt": null}
{"id": "b96e8d45-a2be-4893-90d6-390dd5567e0f", "solution": "import numpy as np\n\nclass EnhancedQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Modified differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 1.4  # Adjusted personal attraction coefficient\n        self.c2 = 1.9  # Adjusted global attraction coefficient\n        self.F_decay = 0.92  # Modified decay factor for differential weight\n        self.CR_growth = 1.03  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.3 + 0.7 * np.cos((t / self.max_iter) * np.pi / 2))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumOptimizer", "description": "Enhanced Quantum-inspired Differential Evolution with Strategic Crossover and Adaptive Inertia for improved convergence in black box optimization.", "configspace": "", "generation": 45, "fitness": 0.2707783274490144, "feedback": "The algorithm EnhancedQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7436096167656987, 0.7601846892595552, 0.7489333087679952, 0.7545451146430971, 0.7534134929169599, 0.7653329068506757, 0.7604810160317366, 0.759129552297613, 0.7393650988184919, 0.19100339019136792, 0.413702771957708, 0.5140986997499859, 0.05621766735409206, 0.528267874638272, 0.5228100812484346, 0.5009976645688105, 0.5304696224981806, 0.0420335880476469, 0.11501900555942557, 0.134033105691182, 0.10303132318185781, 0.15922064653809653, 0.11624838635895707, 0.10185366740045576, 0.13050636071764277, 0.1155142841386434, 0.14604407907276395, 0.10893708937356061, 0.09438453930971924, 0.15309467297349677, 0.12475272632113865, 0.09811328640778316, 0.10894879024421733, 0.11974530808479522, 0.13481683383227305, 0.10022300663827444, 0.9590378891006405, 0.9218423752391609, 0.9568024656118443, 0.9723233494686405, 0.9472435619606846, 0.9431719004148199, 0.9722172446147238, 0.9619114976143184, 0.9589429553573429, 0.4094456687926269, 0.42962878702270213, 0.4170693364921856, 0.39351601254166124, 0.40728219893592565, 0.4209465619529458, 0.3927976608870808, 0.3718443358771637, 0.3797958234439722, 0.3361802349964822, 0.7201632077789151, 0.3575186803723778, 0.210338149770936, 0.2054513755470665, 0.15883811368332268, 0.17290993331059157, 0.35086942417476474, 0.22944001981111362, 0.23845036465764857, 0.12547968795304898, 0.1597184334552334, 0.1759759126909869, 0.16882502660810805, 0.13295255787659876, 0.18102171412062185, 0.1830530898986965, 0.12297396805988337, 0.12504886116351555, 0.16924925411770142, 0.09351970634172391, 0.4160078676596418, 0.17859767293778406, 0.15022383246716853, 0.12413353988459208, 0.1924789960908626, 0.23806468043824813, 0.05678037696150129, 0.04096050420911268, 0.039803711112255225, 9.999999999998899e-05, 0.07487830373633553, 9.999999999998899e-05, 0.1269213629220456, 9.999999999998899e-05, 9.999999999998899e-05, 0.1032707690175737, 0.09737787078584026, 0.042148676664726215, 0.09588096718691708, 0.07459973876338388, 0.09320631607661545, 0.05781968385787628, 0.08365550852972359, 0.02787412778321663, 0.12328217233271066, 0.034906618821849755, 0.057613026545783264, 0.09979638736569219, 0.0657302763318538, 0.12832229561343833, 0.0927225889330755, 0.13809168131028038, 0.08071033097878566, 0.1840500496441727, 0.09859883740928066, 0.17163771815875428, 0.18441852315228646, 0.14953922969322142, 0.2192328364866316, 0.18564727909620393, 0.22887298405059908, 0.07657280131705935, 0.5485147857910779, 0.5094825289960261, 0.5137325356660731, 0.5183520813350568, 0.5145062318473932, 0.49209748599402403, 0.5066802858438127, 0.52974109594777, 0.5532626112936039, 0.11079166113186656, 0.10649419963593432, 0.07650374854109054, 0.09124041143423967, 0.10408540966625335, 0.09739809891601159, 0.11946162395497939, 0.1369196712030062, 0.11904146779699809, 0.4343754781292808, 0.31445030000174123, 0.17282632417464938, 0.21835871484256786, 0.3501901625104088, 0.15654979598832708, 0.146455076992973, 0.27583166914458246, 0.18975445218583487, 0.3626938671157248, 0.40238572412199314, 0.36776824510616435, 0.3956692324163832, 0.2047556282545815, 0.27395297991515166, 0.2775143467030685, 0.452822912200456, 0.46585109988261897, 0.13346145103928342, 0.2326976180535515, 0.21918525173701087, 0.2673794911592543, 0.27157068059735523, 0.30339331124708435, 0.34051663784131536, 0.3645506002641329, 0.19877157475584295, 0.22994229461634963, 0.19580352446227178, 0.2043133231072617, 0.20466977354147975, 0.19746148975276345, 0.18674810670974262, 0.19500975751858118, 0.20082992958298496, 0.19697557515783493, 0.20793638419481497, 0.20219578508325875, 0.19035849400629345, 0.1984763662554876, 0.1910318519943619, 0.19797291418742513, 0.19720117591962494, 0.20614789541588163, 0.20954348213347052, 0.16465337925211532, 0.18389124198595186, 0.16959235467601652, 0.8264849503846152, 0.19801966114881275, 0.16579630556414582, 0.14145869297020985, 0.19556375913445578, 0.8176545312038715, 0.646013635713161, 0.21044668371847153, 0.1953873949716035, 0.1273094452149679, 0.20818958603186588, 0.15355401511075584, 0.11172730507703743, 0.6961672813302003, 0.09393217725876346, 0.18762463605086455, 0.18544756955396435, 0.17541079906308843, 0.1824930833027798, 0.19452074097731664, 0.18841712892460394, 0.17644533103856086, 0.1927357269625013, 0.17331364383124115, 0.08020230612130486, 0.08216337056718526, 0.09001404139748137, 0.09295883970419672, 0.08318607085289897, 0.08023511215417489, 0.07918528741540809, 0.08276415359541078, 0.08279104721519104]}, "mutation_prompt": null}
{"id": "cca4237f-d5e6-46ba-b823-4ed34f5e08c3", "solution": "import numpy as np\n\nclass AdaptiveEnsembleOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.75\n        self.CR_base = 0.85\n        self.w_base = 0.5\n        self.c1 = 1.5\n        self.c2 = 1.5\n        self.F_decay = 0.9\n        self.CR_growth = 1.02\n        self.temperature = 1.0\n        self.cooling_rate = 0.995\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n            self.temperature *= self.cooling_rate\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i] or np.exp((fitness[i] - trial_fitness) / self.temperature) > np.random.rand():\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "AdaptiveEnsembleOptimizer", "description": "An Adaptive Ensemble Optimizer combining Differential Evolution, Particle Swarm Optimization, and a Simulated Annealing-inspired approach for enhanced exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.2510042128427577, "feedback": "The algorithm AdaptiveEnsembleOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.43888941386687585, 0.4413000366813121, 0.43462900647624114, 0.4252097795876536, 0.4389167758075142, 0.4554707815589347, 0.39433901765547086, 0.4068113311739624, 0.44707929789730727, 0.34784414270578823, 0.35630608390894014, 0.30698192704974114, 0.3516105295409443, 0.2733027342818919, 0.32675427699882265, 9.999999999998899e-05, 0.013977681451478596, 0.3306618678818857, 0.09349277791219868, 0.11204302606478467, 0.11429885513068494, 0.1060802220189091, 0.12153256735723539, 0.12235326522041234, 0.13548529489308936, 0.1695708580756724, 0.10614144511529977, 0.11361427219793696, 0.144634977206749, 0.12631063095849293, 0.10330728598757344, 0.1062633449309669, 0.11077076179069478, 0.10971605320401234, 0.11799219366437097, 0.14916475854370548, 0.972779009390032, 0.9738631412705838, 0.9742775899048652, 0.9784361883866023, 0.9639436341691054, 0.9718192200201747, 0.9735808546327117, 0.968957331093629, 0.9821092544062653, 0.453391154974624, 0.4854722809368045, 0.36314867004756024, 0.4454170012480053, 0.4416898843756216, 0.4552862173221113, 0.4535665083780115, 0.41938559685515586, 0.3817379037237124, 0.22742184498093765, 0.7565636518514851, 0.2088123876994209, 0.45203746800874556, 0.11682542299245469, 0.2136405465345661, 0.2034761383312519, 0.6030082651104451, 0.5742154795684735, 0.21666393695131647, 0.21810215637761077, 0.19756984806507905, 0.12541243610358, 0.1940865427072772, 0.20181115071262035, 0.1288472231504948, 0.30549127843048784, 0.20086649164543124, 0.22798417737478394, 0.09489587120231047, 0.12345598204462549, 0.186280626512063, 0.11014895149829085, 0.21183350639067, 0.23295445856881947, 0.12723335732901853, 0.21386034485462702, 0.00524277909711468, 0.005396710288664841, 9.999999999998899e-05, 0.011016242428031231, 0.04965133178828596, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0865820879065774, 0.04918542685959204, 0.037749983132775, 0.06633420544362012, 0.10251654104147478, 0.056607832225889276, 0.07046113772893858, 0.07443845405952265, 0.10214329859949178, 0.1106987832726285, 0.05806215227788181, 0.08815103287823345, 0.30538524123371946, 0.0862857710200362, 0.1039889828432331, 0.09099019235428785, 0.10362098455022495, 0.1107238022742707, 0.10296492600960394, 0.0384701948090842, 0.2500774640961757, 0.09741423041910402, 0.054837882278566896, 0.04496373354173333, 0.05812716949562213, 0.08833602870793689, 0.18233239322584427, 0.406668704498787, 0.37898997102998633, 0.397887360295185, 0.40662459999106626, 0.392498748601107, 0.404637771757251, 0.386286929089517, 0.38111928833440545, 0.4061459058837569, 0.10634258748075731, 0.11791527268939439, 0.16448544887014083, 0.13703097512923956, 0.11007404102745622, 0.13592935534447037, 0.11032568926236075, 0.12280243314889538, 0.13728991370545696, 0.22346494588637855, 0.2824674340152724, 0.2619211263745065, 0.22071481615170252, 0.20271814571487734, 0.16407517962045037, 0.21433052202271408, 0.2198590993284859, 0.14386313635139525, 0.2665243379653456, 0.30612341750346594, 0.27759541032579005, 0.313141869503088, 0.3157693558884136, 0.3004015287839815, 0.3038573706748352, 0.317404004685491, 0.30890455243428505, 0.14466887130494654, 0.25326047306768595, 0.2666808040659102, 0.2612494449745244, 0.28670638681187266, 0.24422519065338233, 0.24887229071090033, 0.24413224621639307, 0.22729796282766968, 0.23609093667161396, 0.16212122773358117, 0.2011799315199091, 0.20246358175150392, 0.19970952739847436, 0.2192223258892233, 0.1876402916552049, 0.19115313875897644, 0.2053045758437464, 0.40669036834374817, 0.2413306780851011, 0.20664733843904493, 0.21432366687255922, 0.20229002217977088, 0.21175974309490553, 0.18624555602583204, 0.42521081251976633, 0.2405895627237261, 0.17230383434371466, 0.1679991178746788, 0.15336817187233687, 0.6008583632209685, 0.19965139118097652, 0.1970930136964688, 0.5637258876439071, 0.16819749339313206, 0.6952321870656155, 0.5870845590314399, 0.2109631778649863, 0.48711981435450735, 0.5885254933796036, 0.16762803026586348, 0.16616489844072235, 0.2121467656762902, 0.1565943792223219, 0.20886944178796896, 0.16997666740702821, 0.17845912543317877, 0.20866883265664782, 0.19190081702047057, 0.18014595997218985, 0.1825889942013652, 0.19053689561736886, 0.19973325799350183, 0.21549067708657788, 0.08001204653699623, 0.09420318715667686, 0.08999965184153202, 0.07543658541180498, 0.07738758910890209, 0.09316156862975711, 0.07790457097815884, 0.08483526778724026, 0.0811087965528926]}, "mutation_prompt": null}
{"id": "72118f2a-09b4-4cac-9cf3-4e84caaf14cb", "solution": "import numpy as np\n\nclass HybridQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 2.0  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.4 + 0.6 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x1)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumOptimizer", "description": "Hybrid Quantum-Inspired Optimization blending Adaptive Differential Evolution and Swarm Intelligence for robust and efficient convergence.", "configspace": "", "generation": 47, "fitness": 0.2617839046559646, "feedback": "The algorithm HybridQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8110014525565142, 0.7796046916922433, 0.7838781964178065, 0.7931739682535258, 0.7797141462964381, 0.7656512970485929, 0.18184117811198053, 0.795391648407405, 0.8170892677740413, 0.6028878622684322, 0.6430612454792175, 0.651520952435889, 9.999999999998899e-05, 9.999999999998899e-05, 0.6240189933509792, 9.999999999998899e-05, 0.6499248912931272, 0.0028654673656465235, 0.10472068690384218, 0.48243436384113625, 0.14680146794955384, 0.10447139167403618, 0.1256493038404748, 0.08912846453971746, 0.10136289684196742, 0.14726102371466654, 0.15808203619907524, 0.08284419047507252, 0.046065450595975, 0.08879288723727274, 0.15012265099153088, 0.09422421189695074, 0.06969460054355536, 0.09359462227020088, 0.08743275487394564, 0.11977624814202792, 0.979591735616658, 0.9808955289087166, 0.9809659998329106, 0.9782147857063341, 0.9634141689528686, 0.97824293085338, 0.9725820655912184, 0.9632852397177334, 0.9635110472201518, 0.48833819902235964, 0.4978365384691261, 0.5155671625947844, 0.48867439793903955, 0.47889840758061364, 0.5506192996873284, 0.42740961331640215, 0.5309511546755534, 0.5630239081572833, 0.344861517025856, 0.22546669961798438, 0.16975286013774182, 0.19303179035458695, 0.15907015211462094, 0.14188524200101493, 0.21445284579947732, 0.1328695793527146, 0.22835177342469215, 0.12982270705439625, 0.1695019794005238, 0.17872878953771887, 0.10008943308075946, 0.18759693911006647, 0.16619699133933952, 0.1815466612137151, 0.12419283731573738, 0.19113219007209326, 0.18233330032736328, 9.999999999998899e-05, 0.28414993502038355, 0.20779857153234216, 0.130176415468799, 0.12394595963061528, 0.1705919094629086, 9.999999999998899e-05, 0.20393771302737573, 0.03933359991416141, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003115156991420065, 0.038652042076678494, 0.049134218830535814, 0.0942900164286371, 0.08971800371218475, 0.011626041266028175, 0.0024079333215583087, 0.06444311091601373, 0.0569696864184952, 0.04023146141298861, 0.08415969376743282, 0.04511701307060556, 0.07971257957108213, 0.13372555734293512, 0.08549647217102574, 0.06897102608168282, 0.1775227340296438, 0.09806594596090268, 0.08738882163297079, 0.10066132115661675, 0.04197960555507274, 0.16438267740331214, 0.0060387844803362345, 0.10359104418402398, 0.18608269227566476, 0.07797367407662292, 0.14052519045931566, 0.08815473648926786, 0.5374663087379701, 0.5247049276619025, 0.5921289579927758, 0.5360577682664698, 0.532427683083414, 0.5153910047394916, 0.5002578988753029, 0.5187942833940304, 0.5198989088920796, 0.15107408146174184, 0.06482647471416658, 0.09053823221134827, 0.12108381601151175, 0.08675950170216273, 0.12669342545248363, 0.08546139516370677, 0.12849448568736754, 0.07880189179359842, 0.32201828239612695, 0.25304501249041245, 0.15300353064610994, 0.2717881121153293, 0.2878903466839865, 0.15325858585059327, 0.16203214551731393, 0.20381743378162087, 0.1269158446817208, 0.3782222473019955, 0.3010091658189541, 0.2686253256129326, 0.3008780555619067, 0.2162497358640577, 0.35451291549558617, 0.4274345620361494, 0.3383230953105124, 0.5446173016151663, 0.18382190830577094, 0.1784923911605092, 0.20827780138816632, 0.13024289687695745, 0.22775023775697223, 0.13007198944893572, 0.23792702710462477, 0.24395658298981926, 0.2945085400936943, 0.17989502693830384, 0.19587949564888552, 0.1770306331570256, 0.20528035090240204, 0.1919460821681781, 0.18776763940183283, 0.2031403394620409, 0.22680820955890868, 0.2055227480092896, 0.21396697143904253, 0.20740859628900932, 0.19924959702537237, 0.21956045939471647, 0.19850923005481003, 0.2168881065865801, 0.20403972422676842, 0.19230868094840803, 0.1910341593100353, 0.261451570173182, 0.16618645509614105, 0.21046954943358487, 0.8686937920527549, 0.1987660126309151, 0.8657961018080294, 0.1412921193684451, 0.16857558649172166, 0.8592163145072336, 0.5994782422913421, 0.16640428708485766, 0.1565450791133408, 0.48230566860240187, 0.16726703878385074, 0.15344127705408095, 0.10521170193428075, 0.10464082908563577, 0.19836903990023746, 0.18050714536923695, 0.1830314079460179, 0.18163773122413407, 0.18383948620752477, 0.19130817206457784, 0.17936047398605148, 0.17651173115022045, 0.18647674067198594, 0.19064331604935192, 0.11045957517828242, 0.08099091610684572, 0.08161420523540386, 0.0825090258307084, 0.07439565282106964, 0.07212273847615158, 0.06756480783862684, 0.06806572382515075, 0.07892703277285928]}, "mutation_prompt": null}
{"id": "09a6692e-346a-46bc-b0a5-0cdb8132c92d", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly higher differential weight\n        self.CR_base = 0.9  # Higher crossover probability for exploration\n        self.w_min = 0.2  # Dynamic inertia starting point\n        self.w_max = 0.9  # Dynamic inertia higher bound\n        self.c1 = 2.0  # Further increased personal attraction coefficient\n        self.c2 = 2.0  # Further increased global attraction coefficient\n        self.F_decay = 0.9  # More aggressive decay factor\n        self.CR_growth = 1.02  # Slightly adjusted growth factor\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.zeros((self.pop_size, self.dim))  # Start with zero velocity for control\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_max - ((self.w_max - self.w_min) * t / self.max_iter)  # Dynamic inertia weight\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Enhanced Adaptive Strategy combining Quantum-inspired Differential Evolution with Dynamic Particle Swarm Optimization for efficient convergence across diverse functions.", "configspace": "", "generation": 48, "fitness": 0.14801962688008255, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.263639806314932, 0.29210611946822407, 0.2810636542642906, 0.3369016460516493, 0.3542065427579937, 0.30579488808866295, 0.2666376741713833, 0.26595798388425185, 0.3117192000963115, 0.0069966372740369875, 0.00574248854271231, 9.999999999998899e-05, 9.999999999998899e-05, 0.009647520861588377, 0.021567525268729182, 0.0013724161918550193, 9.999999999998899e-05, 9.999999999998899e-05, 0.0790463396840736, 0.06312348933575851, 0.05374115519909717, 0.08306265695302828, 0.06345293040916711, 0.0730797368191567, 0.06399038970126947, 0.06908106784329737, 0.07877225504782459, 0.056552052762184224, 0.04751652588474553, 0.04118871501937027, 0.07175142909418208, 0.04929454299274039, 0.04106152506103122, 0.0493688143567339, 0.051886409686383694, 0.053972629030865416, 0.9655625374505505, 0.9653049637178158, 0.9662647488943857, 0.9685172743414403, 0.9663427533145823, 0.9652658131064199, 0.9508490138619574, 0.9672165830707623, 0.9653404072225346, 0.11244871556933578, 0.10176413865054368, 0.07751549793996748, 0.10624058042141782, 0.14102610816799677, 0.13919961538921866, 0.08039341109185916, 0.11101565485734954, 0.1062820052215715, 0.16167271599544797, 0.15962371594484992, 0.19415616367079147, 0.1829254722907525, 0.17094004993163558, 0.16401398592379823, 0.16096643342796946, 0.17686124462112673, 0.17675873060376657, 0.03285111256234119, 0.08776301505036876, 0.048112762771893025, 0.02452571675159687, 0.04708696141379465, 0.06875091314141935, 0.02987185212813659, 0.05717834333010252, 0.06280938282732895, 0.023089492963392355, 0.040988922251145254, 0.04549684820935529, 0.05151631353923225, 0.05763862074630943, 0.05202219393088903, 0.07310816860752334, 0.025881255157398808, 0.03454310245085812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012161257273151427, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0655716320004398, 0.033161623161672704, 0.052806547278039795, 0.04688734084557078, 0.07369327967390926, 0.07057614761015718, 0.03910125735450076, 0.019923978556372846, 0.030776797593268346, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015818251210268919, 9.999999999998899e-05, 9.999999999998899e-05, 0.013416433752347245, 0.0013618729899730342, 0.003341681839468924, 0.011723321735439995, 0.025544056060900044, 0.024773405618337296, 0.03571931982674392, 0.03760110034864772, 0.024686345736262938, 0.2548617528426518, 0.23928863539494227, 0.24732700760720705, 0.2881430339019764, 0.275774624430442, 0.2574904790713375, 0.2491746018638763, 0.24849783559036387, 0.2645431615355207, 0.07186514030263802, 0.0631113485126007, 0.06995350050109972, 0.06019183510289927, 0.06709533957935288, 0.06652552342477192, 0.06374207618706607, 0.06372802948208978, 0.06231111602979511, 0.13765103299279868, 0.16543447545219625, 0.1267163993597673, 0.14958064338974908, 0.14983459445576153, 0.17239724366257192, 0.16202451221990688, 0.1367521554655564, 0.1559399081908146, 0.1905115861668032, 0.14814098197740788, 0.18894891407644887, 0.17089852666459704, 0.19627101990223117, 0.17652556033073474, 0.1879065660439554, 0.22099920477369972, 0.19383148017663177, 0.13614235232072447, 0.13164708539579728, 0.13941266847390632, 0.12721541947503434, 0.14558985236902278, 0.10549486394777452, 0.13795496897265724, 0.15268425115630413, 0.138548247995941, 0.15945650066618022, 0.1593922156382649, 0.14299189326099915, 0.14910145469220482, 0.17510846439072025, 0.15910926774329948, 0.15571990767496502, 0.14996902435127157, 0.17446867046644943, 0.1588377744526508, 0.1649077274311872, 0.16810121153860436, 0.15117138624577764, 0.16620674822053227, 0.15661503995065917, 0.17226729416975817, 0.1621429447648277, 0.1728613145914587, 0.18256322888324772, 0.16754939759956, 0.1542846139554409, 0.14884601945670461, 0.17326127230652766, 0.16667493103973097, 0.17865089344277507, 0.155927267112417, 0.16205059500326957, 0.1498102222142632, 0.17005731055413176, 0.1526616342071484, 0.20059164126388818, 0.2395590524820187, 0.10947024951275541, 0.19768378149716737, 0.280455973415331, 0.19130449437063723, 0.17342694440791895, 0.20024605177139265, 0.1900998889810629, 0.17371966058034782, 0.18021845707598516, 0.18079978434330057, 0.18368986968627554, 0.20179260114313557, 0.1915142061514471, 0.06198382757050569, 0.05900448589224361, 0.05908257302544173, 0.05126911655628197, 0.06235793237067844, 0.07483983403416061, 0.0540120848690111, 0.07587140124226954, 0.052390406033426595]}, "mutation_prompt": null}
{"id": "4f067fb6-2a37-46e0-bf75-2deb33d2ff65", "solution": "import numpy as np\n\nclass DynamicSynergyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Reduced population size for faster convergence\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly increased differential weight\n        self.CR_base = 0.9  # Increased crossover probability\n        self.w_base = 0.5  # Higher inertia weight for initial exploration\n        self.c1 = 1.5  # Balanced personal attraction coefficient\n        self.c2 = 2.0  # Increased global attraction coefficient\n        self.F_decay = 0.92  # Faster decay factor for differential weight\n        self.CR_growth = 1.03  # Moderate growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            dynamic_f = np.sin(t / self.max_iter * np.pi) * 0.5 + 0.5\n            F = self.F_base * (self.F_decay ** t) * dynamic_f\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (1.2 - dynamic_f)\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "DynamicSynergyOptimizer", "description": "Dynamic Synergy Optimizer integrates adaptive inertia and crossover mechanisms with targeted mutation for improved solution exploration and exploitation.", "configspace": "", "generation": 49, "fitness": 0.2726469940138718, "feedback": "The algorithm DynamicSynergyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8587391735450363, 0.8716653983953198, 0.88127124528429, 0.8639055719388509, 0.8627044085417424, 0.2938807369235915, 0.8556206935084326, 0.8644040482418117, 0.8709726513764087, 0.7254992589258397, 0.73917101495273, 0.07721120457661867, 0.7273386878605539, 0.06941563841394616, 9.999999999998899e-05, 0.7563851124575955, 0.02818935214480045, 0.09792215677419502, 0.12688372691068595, 0.11137931413484004, 0.1237343132262071, 0.1551526612349028, 0.1104461641543314, 0.15306750561977278, 0.11914952620509778, 0.1272852405528534, 0.13416691317513285, 0.11153018147533766, 0.11147807593487447, 0.12310342763741011, 0.10628127235782336, 0.06123150201055849, 0.11785967083352511, 0.12584862433129895, 0.11080128701203573, 0.15305964557759055, 0.9806250424167111, 0.9785150217102428, 0.9786210843214177, 0.9629408686774659, 0.9608692808317809, 0.9795480685396317, 0.971379275080872, 0.9540671566772922, 0.9628313143869548, 0.6551658512597867, 0.5323881971935862, 0.6203379469714752, 0.5628649586498966, 0.46781947483940456, 0.5749429293583918, 0.6069567939911317, 0.5479947995667311, 0.12940778532744612, 0.22654620832234673, 0.3390264647125396, 0.1704720862070641, 0.27575487549142563, 0.21105202608677098, 0.20531988142560542, 0.1493250765452252, 0.24163052619834513, 0.1363550238139093, 0.3959959594797524, 0.2591918127358215, 0.09687294656533652, 0.1454618454607407, 0.14902511540071606, 0.12642571147915038, 0.15904241201978642, 0.1264387188893985, 0.1634391697951716, 0.3938313536977094, 0.13285353022293334, 0.17108640925591045, 0.15991548858532245, 0.14946619376711257, 0.23761192257832797, 0.155894062771179, 9.999999999998899e-05, 0.3798070347488016, 0.05144257344175407, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09103610471450452, 0.07415108961897099, 0.043150600394228245, 0.08088831276478214, 0.02010465265783823, 0.06782433580338043, 0.06024584610757833, 0.10034182192596841, 0.014914589371920028, 0.13950634629322756, 0.040668833529136306, 0.09572164598710753, 0.23372230604405175, 0.19442396612063562, 0.140704000595555, 0.09837543769056245, 0.15909601982557287, 0.07308397283694645, 0.32485217966855073, 0.0849854387371004, 0.10582600822729349, 0.110323280737467, 0.14139137449820993, 0.21105236515880932, 0.009478562897241138, 0.06604883691625951, 0.082304735720648, 0.5433837089364768, 0.5192701168240645, 0.5790650563698152, 0.530898241287941, 0.5493406486531476, 0.5288124566735128, 0.5583677728999714, 0.5528659389968675, 0.5762800774025221, 0.08246890260096496, 0.08362225131080736, 0.07783190671713092, 0.14044249322683244, 0.14984049158829038, 0.10089714118663029, 0.10697344275653176, 0.09935868612242882, 0.09172218499991647, 0.18460602310610452, 0.1551906732392545, 0.17939504522650473, 0.2675880608513448, 0.1459667425176262, 0.1562510329897039, 0.25779341275037615, 0.2087901608022471, 0.2265912012455794, 0.4178720321700292, 0.13603098555857485, 0.2585708407891628, 0.2993240508320999, 0.4996295868718228, 0.4475140689227731, 0.4638060426674726, 0.44536105091025413, 0.3552745797538801, 0.21678540635312393, 0.2928274886486737, 0.2352447805063127, 0.219892483617266, 0.190130938324518, 0.27527361896094305, 0.28877811816923116, 0.2687625877386831, 0.2839834974867754, 0.2072555009568664, 0.16948956238149204, 0.21237862172430044, 0.188464640898084, 0.15579925220286117, 0.21041284787986736, 0.21691261452107247, 0.1920501504389468, 0.20669518781459129, 0.2046925396540531, 0.18476292805132977, 0.19387145031156494, 0.19907770358586907, 0.20597475855030978, 0.22105751394725115, 0.20357343912866344, 0.20492842775430198, 0.7738049578586943, 0.15498846964741808, 0.11231410545519027, 0.20032044081533518, 0.8836800764960964, 0.20057163249897547, 0.16576811866548347, 0.14206672194485326, 0.1698632611454639, 0.21145736200796794, 0.5900818469194467, 0.21044847543508227, 0.20017743529097543, 0.210058919915874, 0.3429629573289933, 0.15129617271651163, 0.3253506201455594, 0.12773049071508735, 0.30273852107083943, 0.18470156528610338, 0.20385346698910767, 0.17808668130773808, 0.186335742072682, 0.19145618971722234, 0.17961879254415603, 0.17749319491412296, 0.20221193546443395, 0.1814160853204857, 0.08099117617237794, 0.09163509072115794, 0.08165141950509247, 0.09185143376000904, 0.09308449845107025, 0.08939549000247626, 0.08684587941926059, 0.07954707848151465, 0.08128288083987478]}, "mutation_prompt": null}
{"id": "b5eef7e9-55d7-49e1-9aaa-ad30c89fb57a", "solution": "import numpy as np\n\nclass QuantumGeneticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Differential weight\n        self.CR_base = 0.9  # Crossover probability\n        self.w_base = 0.5  # Inertia weight\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.F_decay = 0.90  # Decay factor for differential weight\n        self.CR_growth = 1.02  # Growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 0.9)\n            w = self.w_base * (0.6 + 0.4 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumGeneticSwarmOptimizer", "description": "Hybrid Quantum Genetic Swarm Optimization combining Quantum-inspired Genetic Algorithm and Swarm Intelligence for enhanced exploration and exploitation balance.", "configspace": "", "generation": 50, "fitness": 0.30034692297642596, "feedback": "The algorithm QuantumGeneticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8630860873542021, 0.8664175604793617, 0.8548715830521776, 0.8569283744080549, 0.8601502567241124, 0.8587126295068693, 0.8516087217098072, 0.8564998611085298, 0.8653506566525137, 0.6194354972620941, 0.1353387498026417, 0.21274791239642887, 0.690387826348468, 0.7097734971727427, 0.684619311695059, 0.6848726215877943, 0.29932847095987347, 9.999999999998899e-05, 0.11422284542561756, 0.12929782417548008, 0.11563447249269443, 0.10804285938594871, 0.14893821559173337, 0.17753074958062864, 0.09833721239310089, 0.18347706206731929, 0.13713129246095013, 0.11947478612913653, 0.1274300410043736, 0.12483166436048054, 0.10830686581997395, 0.11268939546312517, 0.09969276167474073, 0.11874545566849082, 0.11248930419217051, 0.1534774267664445, 0.9725147270267185, 0.9706323387179472, 0.9691264903122891, 0.9718788323988723, 0.9538463580196339, 0.9699779756138409, 0.9551339408182897, 0.9513902005514941, 0.9544913229199135, 0.6245185937332189, 0.6605355491592949, 0.690406724801857, 0.6461100622916798, 0.631340253058943, 0.6615955752932289, 0.5592642733691117, 0.6384539134803562, 0.6934790650814392, 0.22850118205925762, 0.38493139838247925, 0.2266789734881729, 0.2138333256910212, 0.3554201296612538, 0.3395734166955803, 0.23652688923280896, 0.15070063036935066, 0.8793631666334869, 0.30229274770333736, 0.16082862259249253, 0.13484370146349978, 0.1619103901410337, 0.27844363132063876, 0.18317036867147585, 0.1289481855195349, 0.27824390165685586, 0.170028987403109, 0.20636846535203945, 0.1812706796896718, 0.16975746686898963, 0.16343901238951586, 0.15202940289894307, 0.16396402227821805, 0.17685262168826943, 0.12541207750216432, 0.18769623355356257, 0.06993162157765676, 9.999999999998899e-05, 0.006995336289909004, 0.05886433622326004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10676955058996096, 0.05212066398038773, 0.253291711192118, 0.05308271703263345, 0.035282341982011745, 0.07594645547989132, 0.06479300567757551, 0.11467945680212566, 0.07099200947047246, 0.03503638745158244, 0.04809490724051502, 0.053379317110797686, 0.0753280617003882, 0.10060757881101434, 0.35392550219317087, 0.09348303654635837, 0.17629770507845677, 0.16516127189604957, 0.24621077736375996, 0.010150631081128791, 0.1529702004275023, 0.13262663487265813, 0.09718825675258791, 0.03775040181344069, 0.19706879655822263, 0.056526154085881575, 0.08274281722182952, 0.5731370503529223, 0.5355026535978303, 0.5447994020861389, 0.5632759377702597, 0.5702527435718909, 0.6140568281026391, 0.5802983515226148, 0.5555786144861179, 0.595062086882119, 0.07949191219157259, 0.09141615069981213, 0.08467447214727586, 0.09642816957611189, 0.10655595315085431, 0.11221436322943923, 0.09343757305123868, 0.1129004396272063, 0.13646840928634774, 0.19596970800110136, 0.22720362540680494, 0.22625761009385037, 0.27057435732000745, 0.2641274709973195, 0.1956062481839661, 0.3396348549960253, 0.320809136972784, 0.17248243818444353, 0.16258488650784586, 0.37248295647194596, 0.4458850015306862, 0.38541745250120685, 0.3786250460159526, 0.38190051648431844, 0.39436487080065763, 0.537851790740419, 0.5199868117089886, 0.256847546323567, 0.22491158440208758, 0.18405059973282178, 0.23154351028785536, 0.3549715207680674, 0.3072590221428495, 0.2861060976828974, 0.35750062173694686, 0.26156988497952594, 0.21500274803929809, 0.21713612957843154, 0.19359877900970834, 0.21684099479783425, 0.17254541990519667, 0.2342001972515534, 0.28470263757068914, 0.21311920956165387, 0.20588270859359625, 0.22262041140341704, 0.20925158275266387, 0.1861672965446901, 0.20631172850024204, 0.218513012413167, 0.19666870707914408, 0.20665043697642804, 0.733230621549325, 0.19909802097042206, 0.16542777985865253, 0.12591019514016466, 0.14745500257467625, 0.9098826851955665, 0.20022245448789255, 0.14792290305614675, 0.14223283701177936, 0.8926442393299611, 0.8618774529088605, 0.7675417939161784, 0.21115780631142345, 0.07295982973658288, 0.343900752022984, 0.209696690927495, 0.15225031295679747, 0.10473612909750751, 0.16809596121848758, 0.16771901052631366, 0.18116370620027744, 0.18768395067479937, 0.18486208603073928, 0.189064788464665, 0.20471405142575227, 0.18957932807753464, 0.1797205620078357, 0.17677594825022247, 0.18858684495626543, 0.08196829814915196, 0.08249312436998135, 0.09928591071471238, 0.08370019580766053, 0.08937742948254801, 0.07862944320469001, 0.1037667972254741, 0.11961548949163481, 0.07509332236041666]}, "mutation_prompt": null}
{"id": "bad5e745-4992-4501-b2cb-03f232c9ee8d", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Modified differential weight\n        self.CR_base = 0.85  # Modified crossover probability\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 1.8  # Enhanced personal attraction coefficient\n        self.c2 = 1.6  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Adjusted decay factor for differential weight\n        self.CR_growth = 1.1  # Enhanced growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.3 + 0.7 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2 + x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Enhanced Quantum-Inspired Cooperative Algorithm leveraging Dynamic Population Strategies and Adaptive Evolutionary Operators for improved search efficiency.", "configspace": "", "generation": 51, "fitness": 0.26155443359402425, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7397125931136771, 0.7780084011390062, 0.7287155473347369, 0.7576292826843005, 0.7646619555146086, 0.7691408584741839, 0.7376734926127638, 0.7619073541855456, 0.7520146273742039, 0.03554608636274803, 0.06621827120947932, 0.0420392692908379, 0.06013332702786667, 0.512096081344241, 0.5083476112275591, 0.46082315523946515, 0.5388311845244524, 0.496293250263084, 0.14152449801751177, 0.10778045598595964, 0.10031814660309368, 0.11279470328106145, 0.1375129909231506, 0.1135280873848371, 0.10926306456226598, 0.14589381964641757, 0.11255319872544711, 0.10523211240200814, 0.12062761625061502, 0.3664147710410227, 0.14206564637738106, 0.11833261303446929, 0.07754096226030849, 0.09602115410604162, 0.09415228254066155, 0.11523664887787854, 0.9709149717298737, 0.9484423717928798, 0.9727689570179325, 0.9742656817412649, 0.959840543495003, 0.9580040165388011, 0.9603791168125176, 0.9616055731377707, 0.9714479551225891, 0.3173109264252283, 0.3907066896761573, 0.40218191915879276, 0.3722442712041031, 0.38340283813986664, 0.30230392783816284, 0.3699972261010508, 0.3821583280685902, 0.380581438242368, 0.3455009519071637, 0.3411048135963801, 0.20865726488520564, 0.2176784528266128, 0.2574951026623913, 0.26675066092282285, 0.6950073484579289, 0.3317145552113935, 0.6047478957767717, 0.1690376342245703, 0.15946974638443467, 0.17627386880827778, 0.11145571919757713, 0.12297418992418185, 0.15291014710058648, 0.17782606125944944, 0.11127235250602585, 0.22626629712592516, 0.18631926295915857, 0.1962923119727572, 0.2213211785860708, 0.16245686176143104, 0.17180826428433138, 0.1221116793542738, 0.1311040832672299, 0.19290704146197934, 0.1834345181162943, 0.0037496911163430457, 9.999999999998899e-05, 0.039286648092871856, 9.999999999998899e-05, 9.999999999998899e-05, 0.034224492535937845, 0.004643320388042604, 9.999999999998899e-05, 9.999999999998899e-05, 0.03921073332194469, 0.05621197642119491, 0.03746202313270697, 0.08091421501319351, 0.09193712636710238, 0.020806911646295667, 0.06643185883104508, 0.09994726321800773, 0.04736205148505046, 0.07883760775943938, 0.0738402118214403, 0.25364852557255413, 0.09390038392899025, 0.07458589299696272, 0.06405224218640282, 0.08241858658694201, 0.08097515787623111, 0.188264222499125, 0.10580794688861783, 0.13063352736649958, 0.20061736417097353, 0.1704113759367425, 0.14899825939635558, 0.09187619056696328, 0.07373495398205265, 0.08514904131761525, 0.16185051608072643, 0.5017545987950269, 0.4711751629076474, 0.5051561653391232, 0.4757735326212442, 0.5177834902616661, 0.49924024907345943, 0.526110148154721, 0.4977112033531349, 0.5351289724528576, 0.10845503277952318, 0.08752541037773276, 0.1154261277467622, 0.09157911858105072, 0.08393912376177559, 0.08791540213462135, 0.11493629401716365, 0.09173829981053694, 0.09084341502255777, 0.22032275803430823, 0.21448807114281632, 0.17807070011318304, 0.20468048572049513, 0.1763120959889688, 0.142908871758048, 0.18237585457397631, 0.17965297013958625, 0.19068342080433653, 0.30440959362490516, 0.39050954559443596, 0.4311481646001425, 0.41420221517363176, 0.2973227384987711, 0.21656834534789948, 0.4335346645144367, 0.40422889172437604, 0.39330999375494247, 0.1727009010238233, 0.20505382666103222, 0.21958394504750978, 0.2216082292784518, 0.18171495198657361, 0.2281869173498119, 0.34870942920692927, 0.2805815960485575, 0.19389023041409081, 0.20522496311726413, 0.21339780809304543, 0.1893108904760571, 0.23263076055885845, 0.22553716023478387, 0.19831973980948903, 0.19935764488339347, 0.2501785709839185, 0.19169127064266955, 0.18986136104052243, 0.20379543393384514, 0.1877891457613593, 0.2048354984436499, 0.21800734553060863, 0.18490558153198422, 0.20472396528980674, 0.21423150968041405, 0.2074119641716492, 0.815477215399261, 0.1856486123437182, 0.20755508068649475, 0.8078499419746552, 0.1988042427293052, 0.14599993789904675, 0.14157335335872212, 0.6571379042430585, 0.1715878662761806, 0.3533771967462278, 0.20816348033511745, 0.20631363923378898, 0.38538143209816966, 0.11178687927551723, 0.14804370779853837, 0.10397072975345856, 0.21009036901425937, 0.1123151599585761, 0.1820513857203383, 0.17975406377702474, 0.18398642552559918, 0.1720812555180613, 0.20399429746974718, 0.1761425435755133, 0.18925993205530323, 0.17979760264885858, 0.17893267972981264, 0.08085160756964338, 0.076147329919934, 0.06822766247647793, 0.07964988482069002, 0.08218427698492436, 0.07964804058642405, 0.0779291023630081, 0.07997371453218671, 0.07257687618018993]}, "mutation_prompt": null}
{"id": "82dacf99-40ca-49d3-ab8a-bc4b9ac2cb15", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Adjusted initial velocity\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.sin((t / self.max_iter) * np.pi))  # Modified inertia weight adaptation\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Hybrid Metaheuristic Integrating Adaptive Differential Evolution with Dynamic Velocity Particle Swarm Optimization for Enhanced Convergence.", "configspace": "", "generation": 52, "fitness": 0.24042486886452405, "feedback": "The algorithm QuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.9050389181667131, 0.7459925120737056, 0.914072563217425, 0.9062547834757199, 0.2602217393944398, 0.9067258060536286, 0.896857981791118, 0.9069302600269804, 0.49436653380450557, 0.11959896722861263, 0.23477054922425677, 9.999999999998899e-05, 0.025441162279258744, 0.049262946819501274, 9.999999999998899e-05, 0.061840796269024945, 9.999999999998899e-05, 9.999999999998899e-05, 0.1450738472093479, 0.12451473477005237, 0.13060212581598063, 0.18748857532429197, 0.1432839133620728, 0.1334557679648951, 0.1004851488846833, 0.13035215159600666, 0.100025537748902, 0.14534554290811974, 0.1268505020382309, 0.10446942416239813, 0.7726142265027905, 0.10430280363230338, 0.09875978771214922, 0.061208485634379084, 0.12228765855921775, 0.063324566688861, 0.9731924474355795, 0.9717553122166903, 0.9549066378379795, 0.9554088655610296, 0.9463144321153828, 0.9648161122386507, 0.9566306431146614, 0.1536622977115517, 0.9404461468007117, 0.5580221471410697, 0.09509811874279239, 0.14022304041748157, 0.36528844817510653, 0.26350992475158297, 0.17579575203292153, 0.06265943020287035, 0.1719101246563921, 0.18733782399449483, 0.39896895059325266, 0.21326481181934775, 0.22801282482829244, 0.28126310532119325, 0.16079549751575128, 0.2724666037402699, 0.1304727511367444, 0.20220548755131418, 0.23454406873885003, 0.18609740760922988, 0.12740492846698748, 0.19061869621576677, 0.1420986884422366, 0.12061366591663392, 0.2752121803743862, 0.12737318464778546, 0.13173547205429315, 0.1621939804198108, 0.13086231442251461, 0.13076096267057624, 0.13247384471405166, 0.15571856124372774, 0.15779752977610173, 0.1394673074359586, 0.1332216495029208, 9.999999999998899e-05, 0.1326736239589178, 9.999999999998899e-05, 9.999999999998899e-05, 0.1589153348628497, 9.999999999998899e-05, 9.999999999998899e-05, 0.019321556288193875, 0.0029449136849163393, 9.999999999998899e-05, 9.999999999998899e-05, 0.05259221149951987, 0.06998922592873513, 0.12511075104024727, 0.05444307118680958, 0.06050025197141873, 0.04225863253737061, 0.07689810033716293, 0.13979452623823674, 0.1535914764383307, 0.10596377766344578, 0.06334450251907564, 0.0711970099181517, 0.10242244378119125, 0.2211651524158249, 0.10462165736293905, 0.200744572865465, 0.08448189622447155, 0.2415561773633924, 0.16859646102126735, 0.030956173596849323, 0.09858563978024981, 0.05196259552353055, 0.08896443099270057, 0.13088695744583112, 0.18840884570111882, 0.0829174752067674, 0.08697024621851723, 0.5514320135595447, 0.5847794368556978, 0.422126691167268, 0.6012391092000635, 0.46322633961720117, 0.4945825319449355, 0.5391841099106554, 0.4532855167803226, 0.4398204127253852, 0.12808882401568877, 0.08006140764781433, 0.09632207593422226, 0.1076138742569136, 0.07725177615245116, 0.14592865849659042, 0.13403512912520854, 0.08886949868055694, 0.07611788362722127, 0.20670983966972423, 0.22388615200057382, 0.20333930005013312, 0.27686746755381997, 0.26125144740230666, 0.18446170041454013, 0.2676079189276489, 0.24195071730633966, 0.2266644550441148, 0.30187165094955204, 0.22032869977325675, 0.33283842018299514, 0.3633122571652022, 0.36149130255294326, 0.3185885780796286, 0.3361276441394656, 0.377757880694927, 0.36622407930555845, 0.2578173476601773, 0.20204180265679128, 0.18000056796667563, 0.17424315391681433, 0.24904284039634494, 0.19430666034582078, 0.24790504488065312, 0.27344024422941604, 0.23969780201497504, 0.19920655853785552, 0.188927676694449, 0.20410753962111972, 0.23828021030718005, 0.21884553835294518, 0.21596584576996936, 0.22902513023951476, 0.20008292468332178, 0.18429297284261525, 0.21147975903053662, 0.2263388084417517, 0.20873851596681237, 0.22805329853286638, 0.2081191443161753, 0.21609215782444857, 0.19074781579252553, 0.19815467927745445, 0.18824249088844736, 0.16607200460256533, 0.1233588901546473, 0.14765479631598155, 0.9222299194551694, 0.20132510358193745, 0.1720734987685737, 0.1425218228387819, 0.16955560797197544, 0.9376806457670976, 0.6658292676428537, 0.212152277789742, 0.4582153191791619, 0.21122165792033798, 0.1676395086675011, 0.16761253969020784, 0.10476645011987007, 0.16769743792781044, 0.10501145055535455, 0.18687855617684213, 0.18049468922799372, 0.18507053033172116, 0.18710095193685972, 0.19331148033740164, 0.18389432772564318, 0.18548589765150503, 0.18666464256082027, 0.18083743355740234, 0.11394282223427321, 0.09352709114950508, 0.06775960923438928, 0.0870165151118093, 0.09187957566205973, 0.10106187519084542, 0.08873514716472541, 0.10616888056059359, 0.10255992565708605]}, "mutation_prompt": null}
{"id": "d3862f59-749e-47bb-9f28-d625bc10059d", "solution": "import numpy as np\n\nclass HybridQuantumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Base differential weight for DE\n        self.CR_base = 0.9  # Base crossover probability\n        self.w_base = 0.5  # Base inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.F_decay = 0.97  # Decay factor for differential weight\n        self.CR_growth = 1.03  # Growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumEvolution", "description": "Hybrid Quantum-inspired Evolutionary Algorithm with Dynamic Neighborhood Learning for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 53, "fitness": 0.28766325110449, "feedback": "The algorithm HybridQuantumEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7638507745522303, 0.7714875108293604, 0.7765659278627668, 0.7880796258918937, 0.773523592913294, 0.7868509480734773, 0.7750840006824324, 0.7604509630203419, 0.7649979572494873, 0.5209965260704411, 0.5607620450042928, 0.542111461542625, 0.05423512642052519, 0.5637679663630393, 0.5795429794910676, 0.5932422765333855, 0.5690629819818387, 0.050855080505901595, 0.10254669908943137, 0.10880744576761625, 0.12804182034718103, 0.1462385565378318, 0.1185497997834365, 0.1398277621703905, 0.10471773974359588, 0.1719802864232326, 0.1060980643880377, 0.09565545986667878, 0.13036162086009717, 0.12320813092356508, 0.10645407884931246, 0.09409211661448857, 0.13439398384698575, 0.14024470411105705, 0.12499257630087501, 0.10504459518848597, 0.9456143801242212, 0.9570644164364948, 0.9720240403724231, 0.9721071747368929, 0.9517779667007942, 0.9548120811578451, 0.9688470479468186, 0.9761909782204444, 0.9668832878983016, 0.375297801458795, 0.3875558706211589, 0.44935830864520143, 0.41505337829267774, 0.42258382827714436, 0.45023433355215525, 0.40470356295488796, 0.4071707654637121, 0.4338946774552094, 0.21182134602300118, 0.6941339825630144, 0.6718807437141993, 0.20644261057736069, 0.2618544824903677, 0.20651979291521516, 0.6777332498854847, 0.7069431245997377, 0.7322623179389831, 0.35884097972484363, 0.1748086666843146, 0.10383129414488157, 0.12475790089177408, 0.12464170677896269, 0.12379251371051958, 0.1764473773134656, 0.18320660642839148, 0.1811720601628375, 0.21131436353697441, 0.1592816666857514, 0.2534609852648656, 0.14695492799094734, 0.1414425752219457, 0.16392802834667541, 0.17804602474686637, 0.1198963155144338, 0.20435864041615226, 9.999999999998899e-05, 0.03125215364434353, 0.0449314169754782, 0.03727517584373852, 0.012368170986878035, 9.999999999998899e-05, 0.0024978101798902586, 0.10452701389641894, 9.999999999998899e-05, 0.06402528867539092, 0.06955490507289763, 0.1059381217391272, 0.08280248469888651, 0.09065537946429336, 0.03249373243066633, 0.08883261371166062, 0.0734690777456457, 0.09144542159719127, 0.02910367181660134, 0.029553330812553735, 0.11589622149631773, 0.11556686835350427, 0.12135189109300937, 0.06465677926448221, 0.08274031635087653, 0.07946305502696871, 0.24608504502022965, 0.20208180022233924, 0.10896683651981498, 0.07666992627548586, 0.11089861994353001, 0.09863397226369941, 0.07758485534666237, 0.07558415956966003, 0.06014516091542721, 0.16133751513171068, 0.5103361977432057, 0.4859860200278896, 0.5127378627164274, 0.508620551395648, 0.5327116039288222, 0.5356359723246578, 0.562191298202219, 0.5203894497079284, 0.5747826290343083, 0.10944709546526721, 0.12903610123329723, 0.11179600917604382, 0.10152525701896009, 0.09869675916954457, 0.11313699647962172, 0.0950306966822031, 0.12567906288936503, 0.09332313595857955, 0.13812844934158797, 0.14704109230811535, 0.15373340516004697, 0.17374788025581422, 0.18650196237284522, 0.21088681198032078, 0.2010726358264736, 0.16456411456288533, 0.244811500253452, 0.4010178630894511, 0.4295735837631167, 0.3929761032976893, 0.4508953449252977, 0.46954277006195844, 0.4013407491837361, 0.43057488207371375, 0.4262769398971362, 0.23362800718728993, 0.24644456097743883, 0.3252820673459369, 0.25785570320972284, 0.19145748366531323, 0.18519677509414556, 0.20913282539325218, 0.229480195520409, 0.26525543905159854, 0.3211765485425587, 0.197641784600193, 0.21278463625013944, 0.18194828281991116, 0.2035705624863886, 0.21813333077803532, 0.19589457160759205, 0.19826358461003513, 0.19688160528850907, 0.1985222285206365, 0.20732260555724014, 0.20422986968914492, 0.225837517703379, 0.19304415130268027, 0.20673386498838708, 0.19108806992065663, 0.20466331737589283, 0.192606289277227, 0.1868373082382183, 0.15409702413765025, 0.18354670960003372, 0.18378999784523464, 0.17737516368409723, 0.19903441443435177, 0.8600006901590045, 0.7790879476307853, 0.7702612262760754, 0.17063087628150164, 0.7974023733194681, 0.20398686697856516, 0.5591316605581216, 0.20580248899147036, 0.11245954259934954, 0.5027882098925662, 0.20674048096758402, 0.2100398079290986, 0.7383828567187036, 0.17223360751597971, 0.19521583673938336, 0.19293104765860003, 0.2042522509854442, 0.1833774114643637, 0.18932896566454915, 0.18672819876223, 0.17127885700455203, 0.176072157705932, 0.07983231515689115, 0.08073433964268406, 0.08370173848710072, 0.08124121653243965, 0.0756526834100123, 0.08922212525541307, 0.07892030622458335, 0.07954812383699705, 0.09941058153623161]}, "mutation_prompt": null}
{"id": "aa8187c1-0bc9-4041-84ed-424ed830dd79", "solution": "import numpy as np\n\nclass QuantumEnhancedOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slightly increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Refined differential weight for better exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity\n        self.w_base = 0.5  # Increased inertia weight for enhanced exploration\n        self.c1 = 2.0  # Higher attraction to personal best\n        self.c2 = 2.0  # Higher attraction to global best\n        self.F_decay = 0.90  # Faster decay for differential weight\n        self.CR_growth = 1.07  # Faster growth for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.zeros((self.pop_size, self.dim))  # Initializing velocity to zero\n\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n\n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base - (t / self.max_iter) * (self.w_base - 0.3)  # Dynamic inertia weight adjustment\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumEnhancedOptimizer", "description": "Quantum-Enhanced Adaptive Strategy incorporating multi-agent cooperation and dynamic parameter tuning for effective exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.2460026097937772, "feedback": "The algorithm QuantumEnhancedOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6796486254487459, 0.663189394833742, 0.6747923061721901, 0.6911765120697269, 0.706828516057618, 0.7091053913830938, 0.724254202739632, 0.6912206161358814, 0.6984580452371497, 0.036717741921934444, 0.03476748176776123, 0.3452662783687449, 0.3747479956597193, 0.40011382126266304, 0.2692303994784132, 0.375942820427715, 0.38904342688875937, 0.024176559393771613, 0.09092616060399905, 0.11990684717334466, 0.12785966694582862, 0.1364934779503263, 0.10025889154080558, 0.13654940597715903, 0.11129339312263786, 0.13951606121903626, 0.12278098489325273, 0.10352624484579442, 0.08520129214076111, 0.150334172423505, 0.11539039165425968, 0.08835143502994047, 0.13536465965106548, 0.1039176151523381, 0.08809016398157088, 0.11965938233770435, 0.9580100341990787, 0.944308620071146, 0.9704345708775346, 0.9416377306459294, 0.9566030556683568, 0.9707045385740868, 0.9542408466481666, 0.9701080132377827, 0.944165819637164, 0.3364274358771011, 0.2640272804470064, 0.30723294925059585, 0.3115117414782883, 0.2675145286560684, 0.22555343237795378, 0.30990716476157354, 0.27888590686413617, 0.27395792026199584, 0.4141099328329363, 0.37974820304926704, 0.30296413740564776, 0.38029244522029026, 0.21515354943683607, 0.24719570909940303, 0.4028446783611346, 0.2265804278568867, 0.4278198220387982, 0.1548316383591276, 0.11387780948469883, 0.11716479323195417, 0.16101186910279408, 0.12106603048463827, 0.10251339206518095, 0.16466525615739425, 0.1760756195888329, 0.17816393132341546, 0.180249873996434, 0.15905272588221253, 0.2318241721056441, 0.20833014993930432, 0.16591687489602913, 0.16095834298635747, 0.17001815114700747, 0.12392424824519133, 0.1834607358231659, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009844948283205257, 9.999999999998899e-05, 0.00010234723577251525, 9.999999999998899e-05, 0.007591205495059872, 0.009326160937054184, 0.08737570539280459, 0.05914193002376977, 0.039542977391978984, 0.06361945711770112, 0.08702810871993183, 0.05944776776128857, 0.06622919817094008, 0.05628007836618454, 0.06019055378765026, 0.03650185694875985, 0.024517904047427708, 0.12002787298556283, 0.1005793555499469, 0.05195889511502516, 0.09415128205313283, 0.054800234696719796, 0.0499818413948766, 0.08154517442459386, 0.10150729518785795, 0.09082033359284891, 0.1644135192536712, 0.20494911796638304, 0.11110854601674713, 0.14096870683348062, 0.07565846714908364, 0.05742935256011328, 0.07686823413967436, 0.4706646700609698, 0.44980051512326524, 0.4844161788383168, 0.4963285655142635, 0.4694377338543658, 0.48270621784731194, 0.4453552055614197, 0.4496028017283231, 0.471479786756718, 0.08601631075413063, 0.09728122323105803, 0.07801742172318249, 0.0828273371276309, 0.11334334050409656, 0.11736856497645276, 0.09753824482806228, 0.12728804079322764, 0.11589161224525646, 0.22658920734960852, 0.19977707508096454, 0.1614628348240813, 0.17418932831096878, 0.18386164541820293, 0.21169507481167016, 0.15361509945564578, 0.17389971564889495, 0.1510581312876471, 0.28951648502961047, 0.3274181092983077, 0.30040461081318837, 0.32668155906210383, 0.322002298994833, 0.2928953992946547, 0.34470995758362155, 0.2923510431629692, 0.36530922149284084, 0.27255308580130555, 0.1890695569475611, 0.22339788660178284, 0.2653878452027648, 0.17642926540603043, 0.20820569042326564, 0.23283416714703598, 0.2665100941952764, 0.23217380353771, 0.20315748029088554, 0.1876137703087054, 0.18973319284615142, 0.20020080209989566, 0.18461653760531904, 0.22527729416772635, 0.21010353946305838, 0.1779580433106488, 0.1970100419918599, 0.19828921890258966, 0.1814684317381252, 0.18657309305192415, 0.20397478200735264, 0.20121451151067626, 0.21270079298106415, 0.19915095179957876, 0.20163551628343834, 0.18356229252363532, 0.7278133253296484, 0.1860601356708752, 0.1867685559150306, 0.8174245810040581, 0.19669560080848136, 0.14618198120190606, 0.1416930221124728, 0.15709965314843555, 0.17332567364165474, 0.3193662846420817, 0.20719370502399914, 0.40533113104466745, 0.3882168869546383, 0.10791371064863742, 0.1462395226032639, 0.6791590153286361, 0.2067148707259524, 0.4993802523839298, 0.2016330892246636, 0.1809837872536425, 0.17768472602166363, 0.18377016915036426, 0.2058134021276402, 0.18252996523323672, 0.16931629651328717, 0.17874151998279808, 0.21079365953190987, 0.07375509596055185, 0.062223260638021194, 0.08313825279096032, 0.0615685984233183, 0.06558369446223677, 0.07956397886982325, 0.07766933609383975, 0.07828906992288209, 0.07303118184393131]}, "mutation_prompt": null}
{"id": "51eaa17b-49c8-4c84-b428-61e4a2b7410c", "solution": "import numpy as np\n\nclass HierarchicalQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7\n        self.CR_base = 0.9\n        self.w_base = 0.5\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.F_decay = 0.9\n        self.CR_growth = 1.02\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-2, 2, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        brightness = 1.0 / (1.0 + fitness)  # Firefly brightness\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            for i in range(self.pop_size):\n                for j in range(self.pop_size):\n                    if brightness[i] < brightness[j]:\n                        beta = 1 / (1 + np.linalg.norm(pop[i] - pop[j]))\n                        pop[i] += beta * (pop[j] - pop[i])\n                        pop[i] = np.clip(pop[i], self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HierarchicalQuantumOptimizer", "description": "Hierarchical Adaptive Strategy Integrating Quantum-inspired Differential Evolution with Particle Swarm and Firefly Algorithms for Enhanced Global Search.", "configspace": "", "generation": 55, "fitness": 0.16494934749503096, "feedback": "The algorithm HierarchicalQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.5149463754569346, 0.38216425311324065, 0.27896995590798834, 0.29633675270809057, 0.44014251361740164, 0.2930348165674671, 0.2887945366349911, 0.2920192035854724, 0.2651940830727274, 9.999999999998899e-05, 0.028052518665001247, 9.999999999998899e-05, 9.999999999998899e-05, 0.10934237999844154, 9.999999999998899e-05, 0.02470649938788172, 9.999999999998899e-05, 9.999999999998899e-05, 0.09433660341051686, 0.04660957642208052, 0.07237378918329018, 0.05341257595967219, 0.10755580727786018, 0.059933101263283106, 0.09777622949054143, 0.14646497583805518, 0.09004815193799443, 0.09221713630447137, 0.07515387269580498, 0.10735477062355081, 0.10268409181202842, 0.09495136705321527, 0.090260966184598, 0.1171573026554219, 0.09028096903757665, 0.08607121371448134, 0.882805673835545, 0.06806459830282419, 0.9488304080500592, 0.9734673440966823, 0.192575410244608, 0.09764097911424308, 0.9582928111700598, 0.9877422701790131, 0.9448877878107236, 0.25922581250098087, 0.1445866884733923, 0.09000288209655916, 0.1220709274208901, 0.16415451062047848, 0.15253851311807043, 9.999999999998899e-05, 0.0865623017347974, 0.11199701238679194, 0.21969842696556874, 0.2258858684458691, 0.16567348901051993, 0.22065599759972143, 0.25699087193250103, 0.1762873154868323, 0.14587865336619432, 0.1437172985303583, 0.16534452326588167, 0.05432401361988848, 0.12288301762928056, 0.037650821709016236, 0.1225903263474829, 0.08685826502209837, 9.999999999998899e-05, 0.1037280856574544, 0.09365044010871915, 0.14132153994681573, 0.2628487872265082, 0.10254027958162859, 0.08237986852253742, 0.156083009152987, 9.999999999998899e-05, 0.11344504376647124, 0.1685393174822326, 9.999999999998899e-05, 0.11648380152024196, 0.01567751463621514, 0.005061690491559245, 0.0497866581024875, 0.018479468623519235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007661734552306565, 0.06298790748873384, 0.12238493439466802, 0.09996044645932312, 0.1023856519845574, 0.017086325790184098, 0.051853225589042595, 0.0162594189213765, 0.058824562720336315, 9.999999999998899e-05, 0.0003952061023486664, 0.12940228152328892, 0.02309648585181845, 9.999999999998899e-05, 9.999999999998899e-05, 0.04169268638980317, 9.999999999998899e-05, 9.999999999998899e-05, 0.04894927800682103, 0.037300026807664644, 0.0153523864942543, 0.06448502751919694, 0.045841712363131726, 0.01794885169067495, 0.03329466484912047, 9.999999999998899e-05, 0.0919172587130963, 0.34862548236356194, 0.42276928147937454, 0.3077697433084632, 0.26946848026103276, 0.43454291989507887, 0.284687805705906, 0.36773737988434707, 0.36059962177972116, 0.29710510602253426, 0.0826471178948639, 0.05917415159558881, 0.08202336383256714, 0.07037502752774383, 0.07634917031554544, 0.09863411358221452, 0.13800625145774792, 0.05885302841510531, 0.08965705540373492, 0.21916905219892202, 0.17975105703935512, 0.20362859566409008, 0.13812251811196297, 0.18141666842332094, 0.24457094153878112, 0.20531312149083691, 0.17480646659235588, 0.29874394961628836, 0.1680594013978618, 0.27680860659459117, 0.32007249762279966, 0.2202668931569125, 0.21292239535670188, 0.27412794721802325, 0.2634121150655687, 0.2569765381708843, 0.21125044974171825, 0.14010590897986763, 0.17323392301859963, 0.1596177069347252, 0.1809574766172516, 0.13351722196408977, 0.2420739980393617, 0.2349993132178103, 0.21508120097127825, 0.1873064684600999, 0.20451444683587694, 0.21069150625419975, 0.1503124319302831, 0.21422468684581375, 0.17969841024677846, 0.18150789399996536, 0.21802281731924344, 0.22587515919773526, 0.20227410066294738, 0.21646987233374826, 0.1707169956743897, 0.19011637619049004, 0.17729750195097438, 0.17694557441982595, 0.18158466827411857, 0.16910122398153582, 0.19011009154906988, 0.22035083900091568, 0.416271397367763, 0.18655504936554446, 0.14768372386195172, 0.1467098555373737, 0.20027689780765334, 0.1976724866308387, 0.13935671894999013, 0.15754472581319756, 0.17099101016988838, 0.30930358311792683, 0.18004997955397417, 0.0734731341082212, 0.10381528797750439, 0.1110424866006835, 0.24464097040969945, 0.10464146684673326, 0.20956331108678528, 0.42348247170387476, 0.19310591894286266, 0.18845156413606523, 0.17761249043001648, 0.18066939742770605, 0.17945762672101973, 0.19964157532596316, 0.1933546828980346, 0.18130162747288792, 0.18624716525755647, 0.07489374965376538, 0.07146753860634159, 0.07749844067740919, 0.051667678850958465, 0.09596624020449673, 0.08077047180901775, 0.0921882648500485, 0.08337615496035145, 0.0637249944973457]}, "mutation_prompt": null}
{"id": "ae83bbae-6dc9-4790-a4d3-b6ddc5a3b611", "solution": "import numpy as np\n\nclass EnhancedQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly increased differential weight\n        self.CR_base = 0.9  # Increased crossover probability\n        self.w_base = 0.3  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Further increased personal attraction coefficient\n        self.c2 = 1.8  # Modestly increased global attraction coefficient\n        self.F_decay = 0.9  # Increased decay factor for differential weight\n        self.CR_growth = 1.1  # Further adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.3 + 0.7 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2 + x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity +\n                        self.c1 * r1 * (personal_best - pop) +\n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumOptimizer", "description": "Enhanced Quantum-Cooperative Strategy utilizing Adaptive Differential Weighting and Stochastic Local Search for improved convergence.", "configspace": "", "generation": 56, "fitness": 0.2840491725144236, "feedback": "The algorithm EnhancedQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8646194715400219, 0.8551316641439723, 0.8749826342161133, 0.8562296910848595, 0.8722554411406366, 0.8583149068193361, 0.873377704198506, 0.8523736977079123, 0.8598788550397592, 0.14336900843961664, 0.09111758923545454, 0.0753229682075709, 0.2880155925909138, 0.7501095191950622, 0.7516492686339221, 0.7120210228359074, 9.999999999998899e-05, 0.5585418111118237, 0.09002295883395617, 0.1473226957260313, 0.0975222459322529, 0.07423919597446327, 0.14992069978789446, 0.14503878135281123, 0.0928620858227801, 0.09891487835241697, 0.6628089218413185, 0.07411794932029903, 0.14664108182997193, 0.12254113498610708, 0.10601650179951416, 0.1145294663942995, 0.10786480265203646, 0.10253211229026549, 0.11275709754043906, 0.12078000365394725, 0.9547294679344133, 0.9614096146906865, 0.9630814115681423, 0.9550661098359767, 0.9649015964636523, 0.9433656991278417, 0.9654588769893514, 0.9538095664707967, 0.9677112757172464, 0.38599230154427433, 0.5435859856379996, 0.07055719044470676, 0.3935406018356352, 0.5956596306409505, 0.43315222396931563, 0.03183490257024313, 0.08966758989796653, 0.5074123608405967, 0.22608496869482098, 0.2103420839634199, 0.2219286631769085, 0.3797411743012854, 0.19037508990550334, 0.1573867258660554, 0.754260402271445, 0.23870357069537929, 0.5195659337605343, 0.12536110365647712, 0.10199369518931267, 0.14278355477918792, 0.0985396284759521, 0.14072900237147712, 0.12839043581192144, 0.17192984059273564, 0.14787646840399882, 0.18266696946750038, 0.28191274480866646, 0.11656396507275624, 0.1505892944590076, 0.1503465775231796, 0.11908772577612048, 0.13500719226656022, 0.2098317042383363, 0.10559262206140752, 0.19111454010516205, 0.03333914724640763, 9.999999999998899e-05, 9.999999999998899e-05, 0.04547154333731995, 9.999999999998899e-05, 9.999999999998899e-05, 0.09774429227088899, 0.0019003890561891668, 0.008293264990431037, 0.03837867489830782, 0.13632019457269084, 0.07124345626738249, 0.11037222772814093, 0.03203179053137828, 0.027471875388216715, 0.10821479257803368, 0.10264637721336733, 0.06189913698290761, 0.0691755177285539, 0.22062447999006418, 0.15483620763314543, 0.14249040085585207, 0.3165811730907886, 0.09471010426414728, 0.22073519721298185, 0.11987410122355957, 0.09986567825641302, 0.04891133272410897, 0.25717178903104965, 0.05003897145035008, 0.08769426439808503, 0.13100012142627548, 0.11750928500890845, 0.09869298831580076, 0.25411715147855696, 0.08169191861029557, 0.5170218151920365, 0.5201369402686221, 0.5605150372264284, 0.5725494917157179, 0.4923633300040361, 0.5753233543959562, 0.6199520520354663, 0.5452267117039656, 0.5229755881345979, 0.10367968884563672, 0.11762529013116052, 0.1482661608057806, 0.15452407400919854, 0.11539378478229123, 0.13293505467097422, 0.11270168384499124, 0.10645735003219148, 0.10417647997051316, 0.27766137352790987, 0.2520478633970853, 0.25811491081638516, 0.22984137789543746, 0.3400009257813945, 0.17937709459750573, 0.2264276584434347, 0.24291163215637523, 0.28547107353418355, 0.5342143912686694, 0.4337308463702839, 0.29285465905423513, 0.28714419932669333, 0.5008129407599984, 0.39134861455981373, 0.5459074339666661, 0.38971054484432965, 0.4264779758650439, 0.2868848476280589, 0.23736498730035227, 0.2402455533032648, 0.28562618257788286, 0.26363844131738234, 0.32214170088983185, 0.26901284441484585, 0.25350237869944325, 0.2376367408309158, 0.21014478742691522, 0.21128003084196512, 0.21826114127861107, 0.19951309602544154, 0.20310241350849267, 0.22976152095302238, 0.22084808102900355, 0.23705447065545315, 0.2160727286666082, 0.19965703125143874, 0.20183572062464405, 0.19020575114957716, 0.20686185908910837, 0.1979238524357665, 0.19595453216544312, 0.1890537468784721, 0.19384678040047842, 0.1870855061711162, 0.16382441494562028, 0.7830916265179362, 0.14716514229424593, 0.8938596040564026, 0.19817656086207625, 0.8833912536106249, 0.14212138790101703, 0.16179585118017514, 0.8980239983810393, 0.4499358920529849, 0.21097546595939032, 0.07225043147707888, 0.20662720266243084, 0.12527718915662767, 0.16868933023371246, 0.3378405222463122, 0.28129749287924966, 0.09356518447885542, 0.1839737906937018, 0.19392345337833372, 0.19105434757586304, 0.20299872469594737, 0.18875571799042945, 0.1792012020021473, 0.17881272052522457, 0.2080706911058371, 0.18015247274420076, 0.09660719786100869, 0.08800487651028543, 0.09322991147254267, 0.08641721996259855, 0.07529844739616243, 0.08584466628400222, 0.08136965906955196, 0.0910490355186987, 0.08661905611693677]}, "mutation_prompt": null}
{"id": "483483d9-daaf-4d06-95a7-07952949f186", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizerV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly increased differential weight\n        self.CR_base = 0.85  # Increased crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.8  # Slightly increased personal attraction coefficient\n        self.c2 = 1.6  # Slightly decreased global attraction coefficient\n        self.F_decay = 0.9  # Adjusted decay factor for differential weight\n        self.CR_growth = 1.1  # Increased growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2)\n                mutant_pos = x0 + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                mutant_pos = np.clip(mutant_pos, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizerV2", "description": "Hybrid Quantum Particle Swarm and Differential Evolution with Dynamic Strategy Adaptation for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 57, "fitness": 0.27026113718869715, "feedback": "The algorithm QuantumCooperativeOptimizerV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8016623730042065, 0.7926168722602118, 0.7764847306005759, 0.18977875921226595, 0.8045686048448218, 0.8082578756346313, 0.8131516846361188, 0.779800716914796, 0.7803245250947388, 0.5606482711706203, 0.5991503796979063, 0.5607661559331223, 0.5560740503359023, 0.5959147826664983, 0.599728922338657, 0.056616177989775696, 0.08377591539240625, 0.5405667862839967, 0.0945399800088852, 0.1457601919807643, 0.12614345407731253, 0.13646867120833106, 0.1548431337804792, 0.433125844072763, 0.11818677362720886, 0.11377210111157454, 0.13734735915509177, 0.11980530243291376, 0.09112031045802227, 0.0927561494976642, 0.10306094319369918, 0.14970543509252277, 0.08615243408176898, 0.09946709713371404, 0.14727813931916878, 0.12105845606229426, 0.9648454252414922, 0.9743861525698007, 0.9635068924418018, 0.9648859148462849, 0.9555239758703807, 0.9306861592884643, 0.9662548662929049, 0.9764562608318011, 0.9742165180128664, 0.434796259669744, 0.43478770770023323, 0.42680482119383534, 0.4051097064359803, 0.4151392734936694, 0.41046796917118433, 0.485833893953715, 0.4873601639676408, 0.48719281002666937, 0.22171622962521165, 0.3396072642241714, 0.16730338786255816, 0.21057123192114102, 0.250272533992143, 0.20224980634062772, 0.22681635524222854, 0.36248564980938003, 0.24000754884708098, 0.18561178955660873, 0.17505512925304778, 0.10079901806551184, 0.11774558187421591, 0.2120969929911447, 0.10682723511753078, 0.19601520275495865, 0.16801950677889077, 0.19464926930519755, 0.1921292208586335, 0.14733502888284966, 0.12404262822098522, 0.21089533248261416, 0.15435339524554093, 0.12765731026236082, 0.20821574103158702, 0.19453892999590272, 0.13406745234030826, 0.0014685364037763105, 0.002300044104167842, 0.024040898096492458, 0.031536765821067236, 0.005681497242026823, 0.007145258673651234, 9.999999999998899e-05, 0.002649851892126742, 0.005833095618935968, 0.061870230847377417, 0.07648350357994316, 0.08237048149348303, 0.11044754538571355, 0.037807679982567066, 0.046843261145096404, 0.09788450935165915, 0.06114255784325229, 0.08592595425556304, 0.031889470838574185, 0.03048172477062383, 0.044389687251209176, 0.06577889781819557, 0.08249878436870517, 0.07857372946760166, 0.2511269247373745, 0.08173372033790038, 0.2236105932449569, 0.12072766405714375, 0.08160831755785625, 0.11772423332323945, 0.057604657460632036, 0.13028604781078956, 0.09311404128821688, 0.08527536521907186, 0.07837339411362554, 0.16260353823247464, 0.5130509754408368, 0.5009458692863302, 0.5868178607672747, 0.5055786498721122, 0.5110184572903018, 0.5301624055156788, 0.5065664693451062, 0.5133210111973174, 0.49483569072768707, 0.10595077506905326, 0.09047560245531727, 0.10284496083715078, 0.10520009435260469, 0.08188925962127358, 0.11007853506320009, 0.11667948541999518, 0.11714877593635664, 0.1131632349703603, 0.16367478345876807, 0.4509265625882197, 0.1890860476019992, 0.20194102060563013, 0.14910592710962467, 0.22680922733428732, 0.15612200836613033, 0.14713239596945005, 0.18996790469424674, 0.1654428268021616, 0.2357864180448278, 0.2767244038621697, 0.43442992132247027, 0.21975301748201936, 0.2693792653269659, 0.3857860815744508, 0.40564251786753625, 0.3883610046838911, 0.34892077487437223, 0.2795827956476189, 0.2293329002995279, 0.19491687018056691, 0.14351627437808734, 0.19120917605546606, 0.24673434752908185, 0.3096037974925975, 0.2813079685038592, 0.20506699280415974, 0.2249884852104025, 0.19566468637713674, 0.19402947737208165, 0.20321394925582048, 0.19389292466649644, 0.18942690291667208, 0.19829017533550364, 0.2041437945129858, 0.24210833823562838, 0.6066263745295223, 0.23757718401466776, 0.18161374683405995, 0.5718852800139408, 0.21402443929414683, 0.2067640858846307, 0.18834523876657816, 0.19894735737139324, 0.1845863090374067, 0.18543902756553954, 0.16204407306626145, 0.15771256714014448, 0.1986550388259506, 0.8153242052261725, 0.14165362872760912, 0.16213796247067114, 0.8312921108335176, 0.7660512449558724, 0.2063923462596048, 0.36348430166949663, 0.42147761084114765, 0.16523052221859358, 0.14992608179060884, 0.16241499978116503, 0.21188161256336357, 0.2077099781745554, 0.17371051285305017, 0.18042586413500572, 0.18650279004342218, 0.19811292291066185, 0.18832387204709378, 0.1976049688031407, 0.17973779912788845, 0.1850613969780377, 0.18971327566809637, 0.07127750962840473, 0.07566249458790497, 0.08546737103812374, 0.08751809672917532, 0.07639168242527161, 0.08882074927850103, 0.07236747826338474, 0.07616347569590998, 0.06784459734659953]}, "mutation_prompt": null}
{"id": "d0829991-4e32-47da-bfec-0ba3d4cb5807", "solution": "import numpy as np\n\nclass QuantumGuidedOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 2.0  # Increased personal attraction coefficient\n        self.c2 = 1.5  # Reduced global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumGuidedOptimizer", "description": "Hybrid Quantum-Guided Differential Particle Swarm Optimizer with Adaptive Parameters for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 58, "fitness": 0.2989739484884324, "feedback": "The algorithm QuantumGuidedOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8664147110671423, 0.8321020909694469, 0.8522084817688476, 0.8330742685130275, 0.8316413392567259, 0.8365937059533297, 0.843583288308212, 0.8565723394331104, 0.8346221673120597, 0.6617238746816629, 0.17065938321022966, 0.6712575073478819, 0.7034054737861317, 0.677783562716093, 0.21073578811354765, 0.6413560353305741, 0.6624374930127632, 9.999999999998899e-05, 0.1188020812144912, 0.09513757966711078, 0.1343569635745554, 0.13987735238931687, 0.17718746049769585, 0.11168085958405705, 0.1652542238044471, 0.13890963276873025, 0.14162966668109656, 0.12341400844808792, 0.14550970879503544, 0.32280789744135974, 0.11292508917587407, 0.1337971115048846, 0.102841539742211, 0.12555190709970754, 0.11141483274870656, 0.1335974391798591, 0.9716333959901756, 0.9714827797053136, 0.9627914429412855, 0.971880829592597, 0.9533819337149029, 0.9642070965556426, 0.9545874380411997, 0.9528271186753504, 0.9539284419940434, 0.53879619347838, 0.5539600499046883, 0.5317931795986901, 0.5982245846004979, 0.561940286451299, 0.5850878525184929, 0.5611359287868252, 0.5153265059659535, 0.4668968198331731, 0.7954083707619378, 0.23430608396278008, 0.6915654023315878, 0.21244102631474782, 0.2738733872678897, 0.36953282914062824, 0.22157181809394055, 0.14937671968306165, 0.7144004812926463, 0.42101445213077504, 0.1758424136859712, 0.1543295470059185, 0.16339756070208844, 0.16338345599138826, 0.17335954246477525, 0.12953427352720026, 0.2038133094568968, 0.16365724453227648, 0.12915243600261495, 0.237859279618729, 0.14518612213489157, 0.19948561830791633, 0.18807991981209604, 0.20636291753794245, 0.18132202820118914, 0.1525380590504235, 0.19767289810056476, 9.999999999998899e-05, 9.999999999998899e-05, 0.03436190803654504, 0.00038163339170316224, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014567870943941186, 0.05514966484385275, 0.07716480868834175, 0.030907032290430125, 0.13194561958616158, 0.04497085814616608, 0.06062863433230781, 0.03089504019105338, 0.07001458368144742, 0.10911238215591712, 0.09487335734935276, 0.07405063710829929, 0.04655130515594852, 0.04613743796727099, 0.0761306793349511, 0.07332898055583992, 0.23088814151241555, 0.09144800649010554, 0.22108150559454598, 0.1597866247525369, 0.2591555140820877, 0.1967679366198648, 0.05740609349327164, 0.15447228058497353, 0.08778082665386178, 0.049961243887598594, 0.1918048648038123, 0.09285865635629764, 0.08577014375968595, 0.5566388651121623, 0.5152309876155003, 0.5874724374023362, 0.5791017922163972, 0.5269151784015927, 0.533544449058524, 0.5401704444521432, 0.5376670360490157, 0.5482674232447331, 0.14827304639382766, 0.10419294355781061, 0.09297692583274098, 0.10935252652296656, 0.1486531747435682, 0.48136225419161827, 0.05775246449844762, 0.13871402365598662, 0.12583400019410584, 0.1929799279448916, 0.2338767354510296, 0.36749709811756015, 0.16375710029721902, 0.26531354861010836, 0.19586426533021362, 0.2185705885449838, 0.2526213308976136, 0.19192020968506596, 0.28387970017781217, 0.3459298393014033, 0.43413605721130266, 0.4341987915859362, 0.34318760537115833, 0.32346821238650114, 0.4965623129336333, 0.5871772919027618, 0.4973128558990797, 0.21363972319086355, 0.26715072042872645, 0.14774648227458342, 0.21524277894892752, 0.36418211918603305, 0.3775230538875468, 0.35958356347397136, 0.363002344450041, 0.2950278487972968, 0.21458333841909516, 0.23245444482716726, 0.25062350581351656, 0.24437464406862364, 0.20459479253425683, 0.21079952107060018, 0.19873499247453763, 0.22010789471324033, 0.1944251577077314, 0.20651946789077413, 0.20770895547436863, 0.23433658460278306, 0.2169511673371377, 0.1970249802612949, 0.23545003566817846, 0.2026208815097983, 0.21545706881729088, 0.17693250970592622, 0.16544984364145188, 0.125710140367297, 0.14788379174365873, 0.8979454331717482, 0.1998967643987748, 0.16908905439461652, 0.14200205116468645, 0.887463446407917, 0.167129734287919, 0.6774854521023941, 0.20993232862171884, 0.07307232577421241, 0.7689476183152999, 0.2096077476873034, 0.15289606357715202, 0.10448354802085902, 0.16772510124204631, 0.16845819479549484, 0.17436132329922205, 0.19129780080705983, 0.18078283511468907, 0.1836845609999923, 0.19168703265391662, 0.19479318798465417, 0.17873398704320353, 0.17794350961578076, 0.18835150703757086, 0.0855889883913793, 0.08849463190064089, 0.06997219992007708, 0.08085190328106706, 0.10079165533346657, 0.07735388573479285, 0.08787759862551281, 0.10090207994157285, 0.0854943947157446]}, "mutation_prompt": null}
{"id": "92bd632d-29a2-4d1c-bd2a-d55503e6fe70", "solution": "import numpy as np\n\nclass SynergisticEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Fine-tuned differential weight\n        self.CR_base = 0.85  # Fine-tuned crossover probability\n        self.w_base = 0.5  # Fine-tuned inertia weight for PSO\n        self.c1 = 1.5  # Fine-tuned personal attraction coefficient\n        self.c2 = 1.8  # Fine-tuned global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "SynergisticEvolutionaryOptimizer", "description": "Synergistic Evolutionary Algorithm that integrates multi-dimensional learning and adaptive strategies for improved convergence.", "configspace": "", "generation": 59, "fitness": 0.2705702480955698, "feedback": "The algorithm SynergisticEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7552221492466481, 0.7724879935092148, 0.7601218508196702, 0.7750618916044638, 0.7811125339619318, 0.7715104283114083, 0.7624258470502232, 0.7610640144292549, 0.7513901800387326, 0.09335600304825531, 0.33868688716512807, 0.5479118611793561, 9.999999999998899e-05, 0.5419988269176319, 0.5120460087976064, 0.041870475544693586, 0.45748232160000946, 0.47853385175959484, 0.16205313206059013, 0.13574883994420228, 0.14798822852020588, 0.13370658811516756, 0.10253985346891037, 0.11796990336378899, 0.14217547006445785, 0.09491155626081649, 0.11895394232006606, 0.10525776734902137, 0.13415784351105287, 0.10347989907876343, 0.12686342382771454, 0.16010805339044598, 0.10631175935947235, 0.09776311473756583, 0.09555153910019143, 0.13692623610952792, 0.9577260881294014, 0.9197513607278762, 0.9583340995712389, 0.9726612102070217, 0.9610841117528744, 0.9427768431041049, 0.971737149554657, 0.961607658951047, 0.9574773497879441, 0.43553706474220877, 0.3963677298348416, 0.411001562007986, 0.45011133249080826, 0.3499932709843554, 0.3936116034085386, 0.3971287808588929, 0.388689913880079, 0.43355525863929556, 0.22530199266130668, 0.359626650213706, 0.7541683967155617, 0.21133572291317881, 0.2155335413502809, 0.19843318095439755, 0.22851037269859797, 0.7334229311788834, 0.7077020877648504, 0.26336838251452743, 0.16958589030659166, 0.1203791545833286, 0.12226380182562646, 0.18131111037187697, 0.13936864181214514, 0.16461836393400664, 0.13418034085380548, 0.17649812135966603, 0.20714887110140467, 0.12298102910472475, 0.11401117152953921, 0.1941591105243945, 0.15941356212877889, 0.11604166816344152, 0.12230487591701111, 0.19318849254113957, 0.16104548718253087, 0.0674504617108016, 9.999999999998899e-05, 0.001848883622428188, 0.01493870209415804, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050853219614713785, 0.00010828332192813761, 0.07071515651912164, 0.11251774679507509, 0.12017549895348456, 0.08306247834660951, 0.07039115790550055, 0.025162752061648863, 0.03203734072004172, 0.07312153173458413, 0.0624673216366497, 0.08652756291158026, 0.10506958052804216, 0.04337082823132532, 0.07415122363059856, 0.09480313122976258, 0.07018430336271342, 0.0820193843762188, 0.08965302293219302, 0.11758716200565289, 0.08451950356197446, 0.1421769636545156, 0.13226303638395764, 0.17626945714491526, 0.3299666469455145, 0.1272752613657775, 0.10026709213977414, 0.08406958976380863, 0.09505214700091724, 0.07825531543807973, 0.5667081710618587, 0.551797402595003, 0.4962373494776431, 0.5459152533476361, 0.5121386038005145, 0.5328227832254806, 0.5354232499031362, 0.5191584104579463, 0.5599175343085763, 0.10994789565824725, 0.09539479877330237, 0.09249766920735314, 0.10971829209800688, 0.10961547072372191, 0.10617456207975429, 0.14333310113262943, 0.11528994653934332, 0.14482394210282323, 0.22411376872722744, 0.14618727924869912, 0.20315754462678037, 0.22802772579085484, 0.1906968923723159, 0.24651228961270077, 0.23939612268826282, 0.3170303248456551, 0.2111648373544759, 0.41691101954612275, 0.42311901773854854, 0.41830121266612774, 0.3011813907290043, 0.21640961444635098, 0.29345924901529363, 0.43336095197466207, 0.4777480643541908, 0.2664471279193331, 0.2850854957684088, 0.2875160420566082, 0.22507410044036646, 0.2237095001757562, 0.2632176890230782, 0.3111133917036498, 0.33315363365851924, 0.2564895684312558, 0.1646004511716216, 0.20189789938671832, 0.19839476553544144, 0.20609075665916998, 0.19858485948422644, 0.19553813956994026, 0.17733032781289237, 0.19246335495634725, 0.20222289783738323, 0.19262854733310464, 0.21578016797633837, 0.19905746475041197, 0.1961379951216905, 0.2112060198938045, 0.20792604903063083, 0.17990611415299484, 0.524148665576452, 0.1999481282472122, 0.19932940985729952, 0.1648931998081602, 0.16353690687695366, 0.1693612980941398, 0.8446938298876102, 0.19701564415765627, 0.19483560855884785, 0.1414547661939598, 0.19740521818975543, 0.8532899742210909, 0.5988355522316052, 0.21088040153680532, 0.07335562559533992, 0.12745602711437987, 0.20867394265259842, 0.1535325324020168, 0.11120254707074395, 0.43146026322658504, 0.0941307741684908, 0.18127167420136503, 0.20402750633224775, 0.1883837907101953, 0.18029899326225263, 0.19904448733355407, 0.1820664835198953, 0.18820102440752884, 0.20841840066583384, 0.17780609616055332, 0.07578218704615614, 0.07753153603434315, 0.08211933863314769, 0.07117747683812281, 0.09235985122498391, 0.0803688206401999, 0.07883772040413695, 0.084069900076012, 0.07393441700982328]}, "mutation_prompt": null}
{"id": "8b7e3081-1c0e-4c3c-89e2-0c9d3317532f", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Enhanced differential weight\n        self.CR_base = 0.9  # Enhanced crossover probability\n        self.w_base = 0.5  # Enhanced inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.98  # Enhanced decay factor for differential weight\n        self.CR_growth = 1.02  # Enhanced growth factor for crossover probability\n        self.diversity_threshold = 0.1  # Threshold for diversity re-introduction\n    \n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            diversity = np.mean(np.std(pop, axis=0))\n            if diversity < self.diversity_threshold:\n                pop += np.random.uniform(-0.5, 0.5, pop.shape)\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Enhanced QuantumCooperativeOptimizer with dynamic adaptation of parameters and improved diversity maintenance for efficient convergence.", "configspace": "", "generation": 60, "fitness": 0.24730881927280682, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.4512985020512369, 0.44222140061108417, 0.4336098575495658, 0.4588276613671044, 0.4966995366026916, 0.4574228919399188, 0.4454104530023316, 0.4498016539890215, 0.48631947303862333, 0.24757617789731112, 0.17372668976377048, 0.23067795529250668, 0.2599444347626262, 0.2529934848584465, 0.2608297304137216, 0.20636897441494062, 0.05220313299191526, 0.24913656364780046, 0.14133119956151496, 0.13505030986848465, 0.10665999022879769, 0.13092297497100447, 0.11506516125889543, 0.15082743828549994, 0.1466623820107268, 0.1416871826286883, 0.1362444702254344, 0.10591697165821079, 0.12716837817496307, 0.1330077742015825, 0.10801161742058774, 0.12808740337361157, 0.1254216851151022, 0.10966664734953213, 0.1197485861028017, 0.12584435289886953, 0.9540234993090279, 0.9534293501181299, 0.9648474812429486, 0.9560121057620209, 0.9666537403471042, 0.9432023268785297, 0.9651776792269245, 0.9644963665547678, 0.9667026529937343, 0.2928724217539572, 0.2573339618741701, 0.2270861869896863, 0.31403459834994407, 0.28261827275033924, 0.31269370730387935, 0.1683694099223605, 0.2628224767300238, 0.3336301535051779, 0.1926062053917904, 0.7327273258183473, 0.6899235814182612, 0.3058007199742758, 0.21200128743809188, 0.19807267684647767, 0.7109227535331044, 0.25967337060284856, 0.7455871977038392, 0.1781646523603696, 0.18615320942084335, 0.14084789053935087, 0.13949256873429583, 0.16645078353828247, 0.15769060300081694, 0.26567747384091767, 0.1590808223860014, 0.1878704423453461, 0.19269713877389183, 0.1662728865984584, 0.15908249912364614, 0.16537727420590742, 0.20424041567432927, 0.16322392100155847, 0.20771597501084682, 0.09004742217735207, 0.25724094126399555, 0.03376622339382662, 0.00013263178922173768, 9.999999999998899e-05, 0.04156613517702368, 0.006992002651147189, 0.034828536727313786, 0.01578589870884206, 9.999999999998899e-05, 0.0069249572536982384, 0.067349877117583, 0.07554930885397915, 0.07374150970377136, 0.06962868479365647, 0.05180906441813349, 0.13389151807249433, 0.08320640700977966, 0.08820446733454468, 0.06673603935794015, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006989597617726995, 0.1047913333129995, 0.11819327960388804, 0.051068695638635475, 0.12951174974393964, 0.13010038226736464, 0.08034864504986872, 0.11188749598399661, 0.06554133283892827, 0.07385743145510082, 0.4288012276661246, 0.4217194425371338, 0.4276326341472928, 0.4234982028383313, 0.44615281830308107, 0.46595314367868546, 0.4421679546166041, 0.41972773212932835, 0.4439017530999809, 0.14122202972099984, 0.09410653547188319, 0.11339823183482256, 0.1283865321503883, 0.11918403693342372, 0.11674400368226778, 0.11591113203067993, 0.11946235091675395, 0.12095323021184579, 0.18364631990587343, 0.2280967968585338, 0.16061961497075095, 0.21710313779457857, 0.16131432982102456, 0.15766802584375184, 0.17814389806017372, 0.23843622575592727, 0.15762670803387047, 0.2987401317609951, 0.31832353965099613, 0.3123147910058176, 0.3090167472488592, 0.3060352154894429, 0.3160249287347813, 0.3030007418242904, 0.2997566297447768, 0.3068351028050944, 0.21093005256481, 0.23716993406116504, 0.248357437703411, 0.23616300033054394, 0.2182098601986675, 0.22659986479117378, 0.20763273537141191, 0.2616384178885569, 0.26396586684909085, 0.21373710227787346, 0.22327123336443988, 0.1945954483570046, 0.17937966590920462, 0.19652980169102519, 0.22892502872154363, 0.22836067108423286, 0.199367640636825, 0.2278164269659011, 0.21652910805926784, 0.3553443433648512, 0.23753697002354424, 0.21932613319717376, 0.2447928172539361, 0.2217743891388072, 0.20926905768630832, 0.23778528078132388, 0.21443173666589033, 0.6670850865118578, 0.15545840618894347, 0.11280523731996384, 0.6957726472905724, 0.1995594941108053, 0.7023525452307968, 0.47598114040073625, 0.17394144056532845, 0.7537152799367585, 0.6221831468645009, 0.21003388806747414, 0.07334567839520534, 0.5824518209810058, 0.15132395176732694, 0.16804061262366854, 0.10412881479344793, 0.5981810118374733, 0.5567270391286097, 0.18849052366060426, 0.18735389657811186, 0.18233524692752578, 0.18730296254718137, 0.20434474081380982, 0.17402376668220698, 0.18697888120996742, 0.19439334808741748, 0.17890978144696723, 0.0767897206724163, 0.0727132690408232, 0.08100096018008374, 0.0977012878324327, 0.09058897591480108, 0.0804005505665073, 0.08285075538333708, 0.08245894070440829, 0.08576011256169458]}, "mutation_prompt": null}
{"id": "a64c6d91-df26-4b5e-b6f6-ea949cff293a", "solution": "import numpy as np\n\nclass HybridQuantumGeneticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slightly increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Enhanced differential weight\n        self.CR_base = 0.85  # Higher crossover probability\n        self.w_base = 0.5  # Increased inertia weight for PSO\n        self.c1 = 1.8  # Further increased personal attraction coefficient\n        self.c2 = 1.8  # Further increased global attraction coefficient\n        self.F_decay = 0.9  # Faster decay factor for differential weight\n        self.CR_growth = 1.02  # Slightly adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1.5, 1.5, (self.pop_size, self.dim))  # Adjusted velocity range\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)  # Altered mutation strategy\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumGeneticSwarmOptimizer", "description": "Hybrid Quantum-Genetic Swarm Optimizer utilizing adaptive mutation and genetic crossover for enhanced exploration and exploitation.", "configspace": "", "generation": 61, "fitness": 0.24744916113839283, "feedback": "The algorithm HybridQuantumGeneticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7022470429121671, 0.7333842834623332, 0.7214847332279449, 0.7542023270331348, 0.7469052791274424, 0.711805972023715, 0.6948839906174497, 0.7333724252220681, 0.7254568330488818, 0.06704788959420693, 0.4881048572704991, 0.037144219962243374, 0.3249136725381495, 0.4956287997311679, 0.44004026430805165, 0.04913043000142647, 0.05681855075762687, 0.04648649389043058, 0.13108717097095834, 0.1052301751049276, 0.09529877942810705, 0.10428822482546507, 0.1316163686798142, 0.11930429571629197, 0.13275479118222755, 0.11084749756125656, 0.37519405752026547, 0.10084035047169981, 0.08975176540604168, 0.11063138109394244, 0.13396619454920822, 0.11726547440934265, 0.11756194110103424, 0.11815189355185485, 0.14152581565637523, 0.11534276528423926, 0.960570526812703, 0.9467435252799824, 0.9789580241189927, 0.9746960778521566, 0.9624271080996761, 0.9636476357682867, 0.9594135049657607, 0.9730069162206789, 0.9713214163438234, 0.3069154063462648, 0.3877660239947628, 0.2986911274336591, 0.33236283710052883, 0.2866815848577261, 0.1587607461282361, 0.2734891805112032, 0.3175729218449981, 0.3390395042542719, 0.22222056028196335, 0.2244925656463258, 0.33790453447186397, 0.6789089099990093, 0.20145600756134574, 0.21191069475498658, 0.38816664310877314, 0.21226420365374277, 0.34434309079840253, 0.12999349999756016, 0.1645820272678391, 0.09876535362664696, 0.1202590657751671, 0.11757240620400533, 0.16959006477435945, 0.170684674030393, 0.1980108935032433, 0.14996167639186775, 0.11749680839416177, 0.13104408451822547, 0.18888170616886257, 0.20272696791101097, 0.21291045693138777, 0.20676110449071172, 0.19355452208360213, 0.11952043590992378, 0.18957620272229447, 9.999999999998899e-05, 0.023867478751347204, 9.999999999998899e-05, 0.013738671888291143, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002563090630880782, 0.026754369228292885, 0.03436078605716142, 0.02295346091218542, 0.08409430749800118, 0.07578263758650627, 0.02645706323226893, 0.056865650194113715, 0.07969237029581366, 0.054702705420877296, 0.026794078063219984, 0.024619729651584876, 0.03800462503437341, 0.12488538764911661, 0.10359864559699783, 0.060860029321055165, 0.129095716631486, 0.05484276372824337, 0.07004316269411592, 0.07335852292632095, 0.03868068482899212, 0.057268348441027905, 0.1737663909118412, 0.13276404274685794, 0.08188325577688849, 0.07210763980070256, 0.05301442221759012, 0.07403055334734221, 0.49545214398230575, 0.49416730449360924, 0.4553180676123477, 0.47491969217994656, 0.4805660783533694, 0.4838557691580997, 0.5105666978677783, 0.5341947230503952, 0.4888472334203102, 0.11033792443989254, 0.08793013460374, 0.10153863958693488, 0.0807853065627755, 0.09809046219421924, 0.10084252420182327, 0.11012488940291665, 0.09630684606748052, 0.11961448645473682, 0.1600702459045379, 0.1677603162068395, 0.19594494607891144, 0.18656175449582413, 0.14915786479335946, 0.23866722580277355, 0.19339324708149142, 0.15915354230546053, 0.21557153948182406, 0.3679890503243063, 0.36039180561952733, 0.2832511489501609, 0.2899330995442265, 0.35291892682576864, 0.3154102459415806, 0.40150232667673147, 0.3398012233435991, 0.3736209243103584, 0.20216197627573473, 0.32082904888222785, 0.2487260934215827, 0.3229856282934336, 0.2426822535733043, 0.20793852780365307, 0.294074604025246, 0.2622396221087565, 0.24495127853895216, 0.1748831044099245, 0.18640634888307428, 0.1926481146244038, 0.21981012490412022, 0.19414015912236382, 0.19027469323255586, 0.18930029621200806, 0.19167127127565786, 0.21122915787288077, 0.19932061367683995, 0.18994259208480757, 0.18520266138497554, 0.19323500465662247, 0.2229811337449592, 0.2010250542178016, 0.20994721193071242, 0.1967762979226928, 0.21251198481899813, 0.7370692452109848, 0.18621957770773767, 0.16066307032701022, 0.7343320739602301, 0.19651693495742306, 0.6715530666672269, 0.1410608699034558, 0.15695126112861257, 0.1702076603129361, 0.5382104968167876, 0.20774782993665142, 0.24500218433924692, 0.380667033236187, 0.11240010328738959, 0.14499866708575715, 0.10424639097828403, 0.20973631080979738, 0.11198508165902565, 0.19051875966672738, 0.1737387613730652, 0.18251050588411388, 0.18663487827468483, 0.21771284331209628, 0.18346190562366005, 0.18744772162238643, 0.18194394861850538, 0.17503587080554628, 0.08210332515616015, 0.08015200206468143, 0.07872833261432222, 0.07986218197095551, 0.07806561709100934, 0.07355169458018995, 0.07002603166292543, 0.08497374372727284, 0.08313878108467665]}, "mutation_prompt": null}
{"id": "ba969f7e-3683-46e1-8c03-e8a6ec5e358d", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizerEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Modified personal attraction coefficient\n        self.c2 = 1.9  # Modified global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizerEnhanced", "description": "Enhanced Adaptive Strategy utilizing Quantum-inspired Mechanisms and Crossover Adaptation for Efficient Global and Local Search.", "configspace": "", "generation": 62, "fitness": 0.2513478196340656, "feedback": "The algorithm QuantumCooperativeOptimizerEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7259577808516994, 0.728440703411888, 0.7040012737848693, 0.7535704526056815, 0.7458397893101194, 0.7456867814430581, 0.7264721546632731, 0.7595615081198559, 0.7454005846112148, 0.44124904478666294, 0.06554522726343803, 0.4306190848082734, 9.999999999998899e-05, 0.4656146571926829, 0.5155662236810842, 0.04248141440693376, 0.08902295637137536, 0.4378886351116523, 0.13841868459787543, 0.1325352174756843, 0.10634714601754491, 0.139425758444504, 0.1067341907447551, 0.0755896306704732, 0.14205867747292578, 0.11312774244035428, 0.260470405614179, 0.12682194373956113, 0.09835363456734336, 0.14526608837924326, 0.11112370631176649, 0.09103256840461071, 0.13114883883597828, 0.1256918048165382, 0.11934789330431117, 0.098043598529161, 0.969754448964983, 0.9477940638049775, 0.9732260149134919, 0.9817178192441149, 0.9619289160452277, 0.9706855952193536, 0.960273368434819, 0.972911620851298, 0.971132517077633, 0.32353160260978664, 0.3696252973991042, 0.31734996353714173, 0.3733547623324692, 0.3327180162054576, 0.36553539581586203, 0.34794154462062965, 0.08730585693286486, 0.40194094952118486, 0.347334910910583, 0.64073938998726, 0.6823677733219514, 0.7131803357612483, 0.20182981996732918, 0.26522623402158907, 0.20833489569104002, 0.1356917512450393, 0.21043895619114128, 0.23982863962593304, 0.18380019193573538, 0.37265338376429424, 0.11827669429476795, 0.11641183882270656, 0.1937048396224208, 0.12833026725347751, 0.14001911430350955, 0.11006117919766889, 0.12537903134523076, 0.1586829912155192, 0.18577505141659023, 0.17129243306831754, 0.18205103987391447, 0.23628828370439225, 0.17071188477684152, 0.1999312660967021, 0.1799488809623344, 9.999999999998899e-05, 0.030059569070451708, 0.02047235576972639, 0.03651979577793574, 0.08607353807197526, 0.022642981635954462, 9.999999999998899e-05, 9.999999999998899e-05, 0.003279053031888579, 0.0522102788341966, 0.05001498132750515, 0.05087665242937767, 0.08698974552745309, 0.049724530209274254, 0.016782370890944698, 0.03503100229154332, 0.04689145529673133, 0.02571109963050111, 0.07655824083283058, 9.999999999998899e-05, 0.037851056907385994, 0.10812716695181113, 0.07909057036626088, 0.058234284264967795, 0.169310089508395, 0.05511953114635049, 0.09255082684416671, 0.15401313883362888, 0.0504472873121804, 0.20533632351751663, 0.15000495416468418, 0.11806759097677644, 0.16440062841109115, 0.13667916992889018, 0.07410243151396134, 0.09728975391183081, 0.4630526524467039, 0.4643852000054579, 0.45982346844234834, 0.4732478213772261, 0.4953184305463645, 0.46436625698820644, 0.5281823505615841, 0.49613490034287633, 0.4869728432004071, 0.09111847626723024, 0.13041498808680385, 0.08078906729190971, 0.11337478721227767, 0.08540918481580306, 0.10701139279867689, 0.12599146393903993, 0.08413625623795484, 0.129556779256349, 0.25017916493880854, 0.22561268094840825, 0.20827354657157848, 0.2001659139333556, 0.2279677419621987, 0.20082510074339244, 0.1592620009926029, 0.14077121517644686, 0.19071966554807973, 0.20271760879188927, 0.23288972518812767, 0.4331433653742601, 0.3587982381778534, 0.3319129357716434, 0.31493135228016467, 0.3866929296963, 0.2697250803490403, 0.2754448351667437, 0.17209352696989133, 0.20964109988021573, 0.21041130116371531, 0.2165905046206873, 0.2933597873525501, 0.17628282279960616, 0.27332059062293235, 0.3000908239884039, 0.26800975755047807, 0.20070586888068898, 0.1876236578873527, 0.18775301585753534, 0.1944503082523632, 0.20291942674495178, 0.1774338714699043, 0.1869595766223524, 0.18689834837660335, 0.21439343786233755, 0.20496739566757083, 0.18277004297716315, 0.24392131866278854, 0.20179421858947721, 0.20391597598045452, 0.2005705223432429, 0.18304945446245613, 0.20851577622340078, 0.18208498151698627, 0.7809210915227285, 0.1865337081821714, 0.16395715938827893, 0.16690028423694547, 0.19689999004080772, 0.14514661683889518, 0.1406213567646093, 0.1692602318306301, 0.16895016484482206, 0.6769560417127887, 0.20879319570090427, 0.18253623141493935, 0.380487873063603, 0.11204680362887898, 0.1458568689419273, 0.10445614073210707, 0.20773071024280376, 0.11229488937765941, 0.19087921278378395, 0.1753045851157985, 0.1986746375493561, 0.19028478838733986, 0.1742952476212153, 0.18588479842535277, 0.20154041158059466, 0.19576558902345298, 0.1687965930131795, 0.08809639310148487, 0.0849300588069416, 0.0699500580121496, 0.10039241554660361, 0.071485174540447, 0.07468927331227382, 0.07273143166554696, 0.0811285560539261, 0.083666533312305]}, "mutation_prompt": null}
{"id": "5313464b-dd46-4f70-87f0-f57bfd475706", "solution": "import numpy as np\n\nclass AdaptiveQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Increased differential weight\n        self.CR_base = 0.9  # Increased crossover probability\n        self.w_base = 0.5  # Increased inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.9  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Adjusted decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)  # Increased indices for mutation\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "AdaptiveQuantumSwarmOptimizer", "description": "Hybrid Quantum-inspired Evolutionary and Swarm Metaheuristic with Adaptive Population Dynamics for Enhanced Convergence.", "configspace": "", "generation": 63, "fitness": 0.26779856257668094, "feedback": "The algorithm AdaptiveQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7270644154658578, 0.7081223406443277, 0.720645627358958, 0.737801517501788, 0.7358061226916686, 0.73541072944672, 0.7300231401557429, 0.729916250280426, 0.7159534489043811, 0.035340666489304784, 0.5084106377950409, 0.3717012140367879, 0.4718382513813554, 0.4609239564723968, 0.038097972691693016, 0.5280336579156317, 0.05331184715686743, 0.47328559448368224, 0.12630357908356526, 0.12555640231234155, 0.12306348745353513, 0.1215981842893723, 0.1268866373443891, 0.3353878506077834, 0.10601038093189741, 0.12970460850060572, 0.1284142770994633, 0.10726516131508601, 0.11294305836181007, 0.10178070850693244, 0.0957556844754972, 0.1303199425390218, 0.12749125507192238, 0.11484758651375337, 0.11200802151975897, 0.10018877824246397, 0.9720150105066809, 0.9482496162846161, 0.9734568575281376, 0.9816514527657267, 0.9712377262412626, 0.9463055862806238, 0.9602613392814174, 0.9877422701790131, 0.9717612218717593, 0.36840940447786996, 0.378316926536464, 0.14731996689655802, 0.3230630933152403, 0.3549997924523479, 0.39405786762504236, 0.07820039498316234, 0.31831535853358706, 0.352008529087792, 0.3330096675463916, 0.6393744679001886, 0.67253451691796, 0.20325295651382058, 0.1905051533319826, 0.2009614021691506, 0.2167811225678371, 0.7497136793479438, 0.2276770256862346, 0.18168094826805448, 0.18713008714059987, 0.28945953558190285, 0.09439569707784834, 0.11223880004542863, 0.12246910384869503, 0.1925500447221009, 0.18367116480743018, 0.21505989181964902, 0.17282822520714436, 0.14739177425830663, 0.18550615333457976, 0.161512823164222, 0.19480655297018423, 0.12015687882496573, 0.1805789444435506, 0.19378243854195087, 0.1224914825589778, 0.03926385423644385, 0.0001302907123301722, 9.999999999998899e-05, 0.028144887533145035, 0.0182566262816376, 0.06337770260157816, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031048100136187307, 0.03653405674117716, 0.07657861286138434, 0.10438848117996391, 0.08276608517256523, 0.06459665197196518, 0.04629135691826791, 0.04432214741354423, 0.026405332069745935, 0.040383130078299634, 0.02681008789194239, 0.01998812523808624, 0.03955683922908704, 0.0910622608912739, 0.08092785605042951, 0.05805741732358305, 0.07507436880556673, 0.07164836445648903, 0.12327046256005214, 0.15802227065649965, 0.038322406688345634, 0.06972070058854063, 0.00799958902955844, 0.03516585948023043, 0.1712211617602878, 0.11655069239544014, 0.056075138883272535, 0.07488995254029363, 0.4619201230349539, 0.5221116385763287, 0.5119514986512812, 0.48284657735966885, 0.45432165365983146, 0.5095303255512802, 0.5052586747390868, 0.509865445855179, 0.5137823634919281, 0.08872014741157908, 0.06656783130291277, 0.07380305520212127, 0.11634446718881541, 0.10124543929500085, 0.1288433645401219, 0.11401209079779095, 0.08427217239948881, 0.07578577968657485, 0.22360267478439677, 0.3224038856870206, 0.1999334130472975, 0.20637389188271438, 0.349726378538496, 0.2539541022721965, 0.18823916606207247, 0.21570548091219433, 0.1691453521872881, 0.25966654046820337, 0.37466737433320774, 0.34148759868592793, 0.41818873880011675, 0.3435909721433561, 0.23436296382276978, 0.2718930228133404, 0.3047767084588633, 0.44326023842732964, 0.2355544519371766, 0.23678927220823176, 0.2819303426382441, 0.243214934084095, 0.24852233300530113, 0.21273511145824553, 0.240146958042332, 0.2648341806623239, 0.2684174120018402, 0.19320943529327772, 0.1962711181369139, 0.18917596821847005, 0.18755462097022524, 0.1898184949145022, 0.20432255890896445, 0.1879384709162889, 0.20275664121259007, 0.18863157877818904, 0.19213123690307166, 0.18035064028569325, 0.19388990255325023, 0.21026915280377978, 0.21407278343968383, 0.20130490553438762, 0.2117634721689967, 0.18993240598145944, 0.2061001224648138, 0.8012874423381668, 0.1860443355205197, 0.14659595178794427, 0.16386855224731134, 0.19727619376428351, 0.7553892597562907, 0.6852100493815575, 0.1940720025854955, 0.7271272364282071, 0.6038733391620397, 0.5901772214392782, 0.4000007089596709, 0.1998477605994955, 0.11150046453255313, 0.6553459843585125, 0.20755457723106896, 0.20149397445340111, 0.6440670025820456, 0.18421840548740698, 0.1848900965784228, 0.18991773887392016, 0.17870539238234795, 0.24689218223468923, 0.18221617356937558, 0.187685951519175, 0.19208731279763025, 0.18311516833456976, 0.07627019050009554, 0.08266369920849426, 0.08570910026724488, 0.07865074227508051, 0.08293690189991687, 0.07930341352708292, 0.07236151084273645, 0.07671631767666609, 0.08030397512642562]}, "mutation_prompt": null}
{"id": "e6e1b048-f789-4995-bd8d-a0202942d2f0", "solution": "import numpy as np\n\nclass QuantumHarmonySearchOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Reduced personal attraction coefficient\n        self.c2 = 1.9  # Increased global attraction coefficient\n        self.harmony_memory_consideration_rate = 0.9  # New parameter for harmony memory consideration\n        self.pitch_adjustment_rate = 0.3  # New parameter for pitch adjustment\n        self.evaluations = 0\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base\n            CR = self.CR_base\n            w = self.w_base\n            \n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n                \n                # Harmony Search operations\n                if np.random.rand() < self.harmony_memory_consideration_rate:\n                    new_solution = np.random.choice(pop, size=self.dim, replace=True).mean(axis=0)\n                    if np.random.rand() < self.pitch_adjustment_rate:\n                        new_solution += np.random.normal(0, 1, self.dim)\n                    new_solution = np.clip(new_solution, self.lower_bound, self.upper_bound)\n                    new_fitness = func(new_solution)\n                    eval_count += 1\n                    if new_fitness < fitness[i]:\n                        pop[i] = new_solution\n                        fitness[i] = new_fitness\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity +\n                        self.c1 * r1 * (personal_best - pop) +\n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumHarmonySearchOptimizer", "description": "Quantum Harmony Search Hybridizing Differential Evolution and Particle Swarm Optimizer for Enhanced Convergence.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {}, "mutation_prompt": null}
{"id": "87fe1f7e-511b-466a-bba2-328beb8f9703", "solution": "import numpy as np\n\nclass QuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Enhanced differential weight\n        self.CR_base = 0.9  # Enhanced crossover probability\n        self.w_base = 0.5  # Enhanced inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.90  # Adapted decay factor for differential weight\n        self.CR_growth = 1.07  # Enhanced growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi / 2))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumHybridOptimizer", "description": "Novel Hybrid Optimization combining Quantum-inspired Differential Evolution, Adaptive Velocity Control, and Self-Adaptive Mutation for efficient global search convergence.", "configspace": "", "generation": 65, "fitness": 0.28903420732860946, "feedback": "The algorithm QuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.27.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8563166994524342, 0.8377725998107847, 0.8331758633017107, 0.851497066046398, 0.84070477191915, 0.8490275874276755, 0.8628973900259796, 0.8357949473373331, 0.8373441966328921, 0.04505534157869073, 0.6906319711595871, 0.052508543419347964, 0.6803163624354328, 0.09891020749499746, 0.6556492936984748, 0.03912713157760028, 0.6583171850255668, 9.999999999998899e-05, 0.11085151445400321, 0.1128453420627391, 0.10597499514313258, 0.11668843445669064, 0.10686449653546315, 0.17868084022660247, 0.13313708305356942, 0.11830694377548678, 0.11084541517721513, 0.09278873901817097, 0.14049946675648606, 0.09455809212530852, 0.12851155185235763, 0.11366412198914366, 0.11715002600734647, 0.09181805682725208, 0.09420554548714022, 0.09076311881266541, 0.9847102909217136, 0.9818192704203704, 0.9726745523395581, 0.9713824055783712, 0.9632044680969779, 0.9736489636375346, 0.9727060946447934, 0.9801416249385598, 0.9739119676860558, 0.546475944037491, 0.5876618612568004, 0.6285640026274744, 0.633821323075999, 0.583555277838816, 0.6316154719990844, 0.621153345264737, 0.5919890575028144, 0.5889278124370121, 0.372090899011964, 0.768605317952486, 0.1363814928073913, 0.209219422997326, 0.36704794812600827, 0.8532947248354793, 0.7381809607752297, 0.8542837817741071, 0.1774616170366775, 0.19299921668159448, 0.1770716125509083, 0.0931391737981665, 0.160814312106216, 0.2199845850597537, 0.19966640421822845, 0.17800842192780697, 0.2124164843605053, 0.17143154176502828, 0.12806263020223363, 0.05884213916872871, 0.1317759832703601, 0.16569764349922333, 0.17959955083712542, 0.14807256797408153, 0.2218258312514969, 9.999999999998899e-05, 0.12417065470782385, 9.999999999998899e-05, 0.02525204209217502, 0.07321971670286498, 9.999999999998899e-05, 0.038183787537726, 9.999999999998899e-05, 0.0060899912289004154, 0.043324853012987274, 9.999999999998899e-05, 0.101420916482036, 0.030651088344311628, 0.12259582488920007, 0.06953892972672948, 0.08077357042313738, 0.0137225786785935, 0.04188786334776429, 0.04306167928997606, 0.06064761506163663, 0.42616438416041624, 0.06898175866481637, 0.25853882397880024, 0.08401315019663635, 0.08895131372456655, 0.11120834719726913, 0.09161737917549417, 0.12341754485691347, 0.09424396112295108, 0.20374355993924842, 0.04368234163518281, 0.20720034825370837, 0.1053218632254499, 0.07658470353864211, 0.2346524933417733, 0.1318629501517149, 0.05585014218091333, 0.08361675071529351, 0.5676731981420611, 0.6285591999103348, 0.5148180738879682, 0.5720837733001689, 0.5483881711714294, 0.5550684497403001, 0.5942877918438993, 0.5495278314617835, 0.5671223560385794, 0.12812000089405318, 0.1300990358689802, 0.10545142408845753, 0.08635224729342139, 0.1230894382253871, 0.07584196692725764, 0.08798436912183061, 0.08186833535509908, 0.1202879633825058, 0.15309153898222372, 0.21033099176093506, 0.1693047142625812, 0.39365339628062335, 0.21515979757956682, 0.24575998661117615, 0.40827954949192236, 0.18858792862471796, 0.15950829737565986, 0.37071379392953885, 0.24724095698114967, 0.3638671123505617, 0.4852566415403562, 0.303110832140127, 0.256152117359985, 0.307916464973907, 0.5096345048656128, 0.31528208474859376, 0.20692253823214402, 0.16275236232702484, 0.3518688316219324, 0.19471707304317487, 0.26471266742027566, 0.22265104562296545, 0.16653817657100867, 0.20829174596368227, 0.29158662791098, 0.22166989531400738, 0.1712362167381496, 0.20581683810772777, 0.16868905617934982, 0.21327278248765402, 0.19567615066523603, 0.19763909826733872, 0.18688909793083386, 0.20635259539001127, 0.19648077366973293, 0.2193231719334594, 0.21356560514861744, 0.19939667324788368, 0.1959837924168033, 0.24351580867074152, 0.1937657227805375, 0.1793805598189272, 0.18909656611296788, 0.15258559393673787, 0.16900690526378714, 0.15199041752994236, 0.9080217563543332, 0.19916258941516474, 0.8411078822457969, 0.14211377707751438, 0.16893897314838746, 0.1984083556593761, 0.8237574814544417, 0.20968999608716699, 0.1678353291298541, 0.7943591130351682, 0.16799302402888605, 0.12768850100231632, 0.19789420065162733, 0.11304904712955344, 0.2047950031517206, 0.18583739952974487, 0.1864952706300934, 0.188211049747263, 0.20264518308395507, 0.19407689099607428, 0.18236332994650495, 0.18873483503313637, 0.17778435053799746, 0.18088177172391884, 0.08167572561220315, 0.0777448466740136, 0.07671239468390889, 0.0788478690613732, 0.08158020592909832, 0.07723918747546665, 0.1028536430702729, 0.08448830685371467, 0.08562089800043393]}, "mutation_prompt": null}
{"id": "87bbfc2b-c8f2-44e6-b3b5-f064c4e5c522", "solution": "import numpy as np\n\nclass HybridQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Differential weight\n        self.CR_base = 0.9  # Increased crossover probability\n        self.w_base = 0.3  # Inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.F_decay = 0.92  # Decay factor for differential weight\n        self.CR_growth = 1.07  # Growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Reduced initial velocity\n\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n\n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.3 + 0.7 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumSwarmOptimizer", "description": "Hybrid Quantum-Inspired Swarm and Adaptive Differential Evolution for efficient global exploration and local exploitation.", "configspace": "", "generation": 66, "fitness": 0.2699030653441949, "feedback": "The algorithm HybridQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8733289951913682, 0.8814938221331486, 0.8513477102298053, 0.849100491481397, 0.8658413100386482, 0.864519141890274, 0.8622293873882917, 0.8829207897846442, 0.8693132890877805, 0.7508497359364521, 0.10535791742128808, 0.2446908275481604, 0.014417097999153361, 0.009733922632142455, 0.1566460212770353, 0.2030562636894261, 0.3911827704573527, 9.999999999998899e-05, 0.09711827700770392, 0.1422059340382571, 0.08351941360463211, 0.13776554500522908, 0.10408242281689839, 0.13646291933443266, 0.1402781894113999, 0.14994747820715437, 0.1429814471491534, 0.15177404199809041, 0.11096262942093071, 0.10820241387242147, 0.1160331551068493, 0.07562904816771954, 0.1054007944716222, 0.1195107624863998, 0.10883138431686057, 0.09742301038429191, 0.906137074617084, 0.7897090718647233, 0.9179296669377356, 0.957877272128111, 0.9559683934085713, 0.18461877031050322, 0.942378457751579, 0.9467102627668701, 0.9330950024291147, 0.3105914674217807, 0.36033637158839615, 0.5726233685509112, 0.6277237052702709, 0.2550719744630193, 0.6661732305311354, 0.5699440419503277, 0.19460077170761092, 0.21408034799705444, 0.3884128083753482, 0.22724144975156557, 0.22199693190621383, 0.2127121248017383, 0.19212562720341753, 0.21556008323324105, 0.22234052505469581, 0.2200756919479716, 0.17475484357520255, 0.12112390954845509, 0.24853637952404428, 0.15481857814910838, 0.22400574839854726, 0.14121523424855498, 0.1251075968033627, 0.1502240660222044, 0.13108294320023828, 0.14930541622921212, 0.12761256904197593, 0.21425746284417668, 0.15276062882364372, 0.1504400633890366, 0.14742498022298756, 0.16781351221438823, 0.13042441882699274, 0.2387766204713887, 0.1544706005798847, 9.999999999998899e-05, 9.999999999998899e-05, 0.03847165089304294, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06105466313556096, 9.999999999998899e-05, 0.06808301445614584, 0.1095176777449024, 0.08667003107036708, 0.1066434101550301, 0.07372288458624865, 0.07580134570874342, 0.01897446829526217, 0.07767089821749973, 0.07852484815071148, 0.16007634970601825, 0.4693982028428514, 0.05589904632006559, 0.0809212805120042, 0.1100039011584506, 0.23309705920628376, 0.1095582177078317, 0.09614348934651229, 0.17383462886215384, 0.09679083491281926, 0.12953363440084797, 0.061398811839665, 0.35380732405984194, 0.1332041937631646, 0.2943895945395778, 0.11296461553682835, 0.14896921539315955, 0.08248946368325072, 0.1689816815042703, 0.5155754051587551, 0.627408517885686, 0.49722284763428015, 0.524705677029704, 0.4156056461183889, 0.6277110359911562, 0.480704918624942, 0.41157004881115167, 0.597779778666796, 0.11569424495410618, 0.09816098631705827, 0.0939125669432802, 0.12810053811714428, 0.1298599447181661, 0.12974719128370793, 0.15286414865448783, 0.09010833464520107, 0.10689332861276102, 0.15799109071868656, 0.20645153498374103, 0.19067567713402966, 0.24266426264419072, 0.2442749211184564, 0.20653171957503658, 0.16922295856185787, 0.5117738687771247, 0.26582154693804516, 0.22830512651094592, 0.29271191006699304, 0.45050780201824203, 0.2650894187741366, 0.34346486115061037, 0.4971821151167716, 0.4834989094836355, 0.3164036048863682, 0.2203623336760997, 0.2816695219842167, 0.26625669002805596, 0.3549552548764081, 0.14888042166856452, 0.26009670153641695, 0.3119887846119047, 0.1494063273244125, 0.33222403758226005, 0.23684459562526905, 0.2856519613151228, 0.20840619892467172, 0.19865439996188672, 0.24127170812277643, 0.21156628974256386, 0.2101351210074719, 0.2132482668866389, 0.20073065094654796, 0.23363573163805995, 0.18024930466022737, 0.1777164791792618, 0.18867754922690205, 0.1957238498839199, 0.20840784844469862, 0.19182020335529704, 0.24735864680335162, 0.17796875520641575, 0.22299477585406158, 0.18617112150023718, 0.9097013428002875, 0.16776572201741924, 0.9092826379879686, 0.1995635117498057, 0.14720289051315938, 0.8693341958827531, 0.1732628044864648, 0.1418525334370635, 0.41080745776268046, 0.2112801588745029, 0.07348519593162894, 0.3545647014506056, 0.846504400685921, 0.2096403616653485, 0.16805353102876674, 0.16731557872518443, 0.44587494974226216, 0.18139509235013385, 0.1844247296465592, 0.17926974715669908, 0.18734582587598902, 0.18496734771789658, 0.18080427603180993, 0.19963210477782278, 0.19103385110140603, 0.20394673805521202, 0.07952671403673373, 0.09524268905980493, 0.0876363533483514, 0.08259115375054282, 0.09326955702232098, 0.10008869413418475, 0.09249927232136956, 0.09685283481849327, 0.13212827342164768]}, "mutation_prompt": null}
{"id": "788550d6-e94f-48e8-ba1e-eb5af81ddcbc", "solution": "import numpy as np\n\nclass QuantumAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Altered differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.5  # Modified inertia weight for PSO\n        self.c1 = 1.8  # Adjusted personal attraction coefficient\n        self.c2 = 1.6  # Altered global attraction coefficient\n        self.F_decay = 0.9  # Altered decay factor for differential weight\n        self.CR_growth = 1.02  # Modified growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)  # Use 5 indices for mutation\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumAdaptiveHybridOptimizer", "description": "Hybrid Quantum-inspired Evolutionary Algorithm with Adaptive Parameter Control for Efficient Convergence.", "configspace": "", "generation": 67, "fitness": 0.259258444711066, "feedback": "The algorithm QuantumAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7427755103094935, 0.759033675735957, 0.743593453310145, 0.768292346065302, 0.7642372092196041, 0.7503874284014843, 0.733779445832696, 0.7699578815084067, 0.7393223480043077, 0.032011873473230534, 0.10561979349982009, 0.5212977385955235, 0.5259211304554086, 0.4950937099719035, 0.5063448107041262, 0.4703619082802376, 0.5199436243888238, 0.4591154533625009, 0.0981696786633669, 0.14147661561035807, 0.10677994665362933, 0.12639150067636273, 0.10577623378015233, 0.08419774032493532, 0.09592845072908962, 0.16271522141035133, 0.11200195606078378, 0.09527353013383066, 0.12442968868592363, 0.10869367944549935, 0.11947196597935694, 0.11600832528280647, 0.10468199057209782, 0.12362967155147286, 0.11621765540734974, 0.12014403573774013, 0.9706193422884156, 0.9484224033537916, 0.9727133684728884, 0.974187479645078, 0.960823767528585, 0.9631451878642282, 0.9605047787385945, 0.9617339263703409, 0.9714479551225891, 0.45186394316743095, 0.4256491461273906, 0.3694434669400598, 0.38271063003974937, 0.3374152635582879, 0.35482496762717564, 0.36599745329511024, 0.3480460066554504, 0.3787499278299412, 0.3257053848815762, 0.333000177065208, 0.3336534718379397, 0.25914799292544644, 0.19134006369796996, 0.21639140510124832, 0.5124373185920054, 0.686123535054694, 0.22644174578808818, 0.18264631148981803, 0.15419699234383444, 0.17374181500335084, 0.12141577326398822, 0.12186219918425756, 0.16279884024836833, 0.2002999598955456, 0.14064797486070124, 0.1045938890334086, 0.1375291295110621, 0.13012102173357687, 0.17385324117980672, 0.17267881888963332, 0.29074357353215863, 0.1868003428051186, 0.16579537957324808, 0.12001486149203378, 0.18898096810844867, 9.999999999998899e-05, 9.999999999998899e-05, 0.020266762984792352, 0.00045477238531166364, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014582047311093138, 0.05061613281901334, 0.0714532029927013, 0.08798398493080839, 0.07777409922420397, 0.014625580177209163, 0.023412140300120843, 0.04615915353791766, 0.05335691596243963, 0.03621782323919509, 0.06231642558504158, 0.21671276444877863, 0.10277464480427079, 0.0816580486864299, 0.059559895831340914, 0.07527072421972458, 0.10382070215244055, 0.11001136466403261, 0.16245314201886374, 0.03985695042178794, 0.12674133826260425, 0.19857855405682534, 0.04465647727261712, 0.13222923705681966, 0.16563518086307982, 0.052687419577205796, 0.09449796335139049, 0.5016200435742383, 0.4782550844217256, 0.47087450976747214, 0.5072764316585716, 0.49250643410340367, 0.5036656115130702, 0.5128924900559408, 0.5119576905806278, 0.5067690066655, 0.11268099740035376, 0.11629910055719539, 0.11177682223213414, 0.10499785659748251, 0.11910156068395228, 0.09659067114355135, 0.09203304177514526, 0.1377238955876281, 0.09462699417704534, 0.27517591776292916, 0.13355523201471364, 0.13747858562700344, 0.2061004620052309, 0.19486337651574426, 0.1620411018448793, 0.13811194847878128, 0.15642834298782615, 0.1581420118461494, 0.24202736258811208, 0.30281531523207583, 0.31806272095928556, 0.3695217361944848, 0.3361727678011244, 0.33683180710838234, 0.3807147785268249, 0.43552491785536185, 0.31603603734158525, 0.18447543141853096, 0.23581204890822793, 0.217946267570991, 0.2659130517842141, 0.2307655727878446, 0.3153256940638104, 0.26640175015213985, 0.2998216792589963, 0.16529502007840224, 0.19881265130246406, 0.19855745440530215, 0.18328694845488824, 0.19643296592988024, 0.20866600216920972, 0.20148793506290608, 0.19890231872963737, 0.19782297432668305, 0.2059765198825496, 0.18331438628982555, 0.2000232819959047, 0.23447756081999538, 0.18614149754311393, 0.1954482161862927, 0.23042704082178123, 0.1955095521492729, 0.1965158385463489, 0.19123415372269714, 0.8370016467863788, 0.18548621209118343, 0.18189615137189907, 0.8136738833460138, 0.19849770549889845, 0.14594054752414853, 0.14149965709027734, 0.16366074054654112, 0.1709174421824844, 0.7185662124296439, 0.20811541291707214, 0.196322399267448, 0.20294521478090832, 0.11170446714800142, 0.1464182921838768, 0.10338741058173506, 0.21020589897661213, 0.12532300526199347, 0.18095765625938875, 0.17882590445182245, 0.1844639088850285, 0.19202200079697085, 0.17670448479934509, 0.18878534251218593, 0.18070121002692852, 0.18647370557472553, 0.20145904388150115, 0.08401764948921131, 0.0738503577873375, 0.08128637156004404, 0.08221004233837625, 0.08532529775108777, 0.06800572751043021, 0.08291812604052884, 0.07585254243570361, 0.07095402727730493]}, "mutation_prompt": null}
{"id": "8340bac0-64f2-4081-9270-812f5f436250", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adaptive differential weight\n        self.CR_base = 0.9  # Adaptive crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Balanced personal attraction coefficient\n        self.c2 = 1.8  # Enhanced global attraction coefficient\n        self.F_decay = 0.93  # Modified decay factor for differential weight\n        self.CR_growth = 1.07  # Adjusted growth factor for crossover probability\n        self.learning_factor = 0.03  # Learning rate for adaptive strategy\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity +\n                        self.c1 * r1 * (personal_best - pop) +\n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            # Adaptive adjustment based on performance\n            if np.mean(fitness) < np.mean(personal_best_fitness):\n                self.F_base += self.learning_factor\n                self.CR_base -= self.learning_factor\n            else:\n                self.F_base -= self.learning_factor\n                self.CR_base += self.learning_factor\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Enhanced Quantum-Cooperative strategy with adaptive mutation and learning rate dynamics for improved exploration-exploitation balance.", "configspace": "", "generation": 68, "fitness": 0.2755642830428078, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8001988214258806, 0.7966966632107941, 0.8026469742051493, 0.7701421627785598, 0.789918207081816, 0.8111076196533216, 0.8058823912396851, 0.7909974969179026, 0.7955021720597324, 0.4827177145739885, 0.48835818410104925, 0.03813543347281356, 0.46093649788798363, 0.05894145627127523, 0.5268919201125262, 0.03908792734025979, 0.566143920316326, 0.051189694939407726, 0.10691270316030754, 0.10745098242995321, 0.1372275828902353, 0.09756811559598177, 0.2957003287006652, 0.10350854220083072, 0.1285071285230731, 0.12373760910117049, 0.12739245813959055, 0.11004973855585942, 0.10748415073386475, 0.0930222652757895, 0.12719708742290836, 0.10327942015263814, 0.10332994240403037, 0.13616413740999467, 0.15591434974138008, 0.1190420481596357, 0.9651905498247574, 0.9645130289441319, 0.9650527591276745, 0.9548951067203886, 0.9667323050402717, 0.9328875696506753, 0.9655670435305052, 0.955071776255163, 0.9765177192160619, 0.49271999709699665, 0.4443473718280663, 0.05962829743284925, 0.46323802575781947, 0.448000435429707, 0.48442517429484344, 0.0752805804158555, 0.08771328444098858, 0.4809204249481869, 0.31790849298604773, 0.22360626185080568, 0.3580261880352016, 0.84038821425772, 0.33808515181892307, 0.11533767166391296, 0.7318138504530711, 0.23437397022169904, 0.1716568401577795, 0.29322205774977295, 0.12654085968769269, 0.1993251286641765, 0.09384920740986358, 0.13083020790331445, 0.12573803145880047, 0.12398858199689877, 0.1831347709408384, 0.20035650948610673, 0.12749930651402608, 0.11140739676459888, 0.1261223450610296, 0.1579967190435153, 0.12390813646146803, 0.18600725970173848, 0.16095735908474385, 0.17801038426303328, 0.13074867920409794, 0.026333903528960034, 0.010809401639681138, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06374455473393115, 0.04882348279796822, 0.0726269621026302, 0.08072102349433186, 0.08965096495029679, 0.08156347295813393, 0.03149827964571961, 0.06705638363933886, 0.09571042292369003, 0.0894403857898175, 0.04333813120665686, 0.08963288452461371, 0.1665408897247065, 0.12236933541118145, 0.10462416844913147, 0.13212452055186608, 0.2559364770311765, 0.13275162756701153, 0.10678795120822293, 0.04189168990510184, 0.038893308715157615, 0.0409755683203773, 0.14526207432079685, 0.20908119874573494, 0.19946774233947895, 0.051310308122905046, 0.054583312731044, 0.20575059547896546, 0.4865618771821252, 0.546121891090358, 0.49047236403718086, 0.5384462862239727, 0.5757911208256433, 0.5239461377519448, 0.5157680206755598, 0.5248753767691345, 0.5242014920623799, 0.1310801849994908, 0.08498583569558271, 0.06836345226664309, 0.1037495017293415, 0.08248554363573202, 0.1478412788985043, 0.12301869838938906, 0.08576692252549023, 0.14183925082283255, 0.18557558761854398, 0.3494383876493309, 0.22704217638585555, 0.23043507899865656, 0.3315907429528242, 0.15363719743325632, 0.34775092336181657, 0.2517820111922844, 0.22452277162262602, 0.31545382663526533, 0.2531501075205249, 0.3716318890035202, 0.37342342105496074, 0.4102060452320091, 0.3083297586182302, 0.43828054587850884, 0.46672597444891517, 0.2399800775735108, 0.2541406171775772, 0.32940750412610165, 0.34873147647701785, 0.23545484563375918, 0.32764007210811275, 0.34434471513107157, 0.23112626253043966, 0.2686841633964976, 0.40846882104828075, 0.20927405215842998, 0.16593037705224234, 0.20322374641018337, 0.23107229060668355, 0.19526434572899698, 0.19309865077909905, 0.1856188507055313, 0.20425885565175572, 0.21240019357120266, 0.22497384487355343, 0.1913182513778514, 0.17777777422130026, 0.1931000172637437, 0.22137766070671883, 0.17886506881605602, 0.20165438098453647, 0.1995888519401151, 0.6182587240910672, 0.16591298258828535, 0.1640141180034418, 0.1126241847357553, 0.8422376413629551, 0.19846074561461013, 0.7927010509930068, 0.14168534842725045, 0.16228703702520275, 0.8568176292100629, 0.5342235300572871, 0.2101091038882379, 0.07318854762939841, 0.20714549529370307, 0.15214092591012773, 0.48638379929949793, 0.3254841831316633, 0.6330491209006106, 0.20850453607154262, 0.1815085569584275, 0.18286388766291917, 0.22819858042249885, 0.1944806911625414, 0.18014321309165537, 0.18583549546254885, 0.18855303319998584, 0.2002155794064282, 0.18224624321429528, 0.08053953892587729, 0.07989755644992924, 0.07964374150142373, 0.08475903926693695, 0.07958758977152014, 0.07904040016133551, 0.09647527576728843, 0.08807426739459245, 0.08110039041294292]}, "mutation_prompt": null}
{"id": "9edf0b1d-29f1-4c13-b3d2-b54d74bf7567", "solution": "import numpy as np\n\nclass HybridQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted for exploration and exploitation\n        self.CR_base = 0.9  # Higher probability to promote diversity\n        self.w_base = 0.6  # Heavier inertia for better momentum\n        self.c1 = 1.5\n        self.c2 = 1.9  # Enhanced global pull\n        self.F_decay = 0.9\n        self.CR_growth = 1.07  # Slightly more aggressive growth\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n\n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)  # Increased diversity\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity +\n                        self.c1 * r1 * (personal_best - pop) +\n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridQuantumOptimizer", "description": "Hybrid Quantum Evolution blending Adaptive Memetic Search with Stochastic Differential and Particle Swarm strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.24167872952912825, "feedback": "The algorithm HybridQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6726658919765428, 0.6800689195280034, 0.6666003230898374, 0.676565361895236, 0.6538107648442674, 0.6506442686605927, 0.6777460248639093, 0.6276544818110061, 0.6559111229347774, 0.2785520897631577, 0.39537475471045125, 0.35490005934119373, 0.037916570973881014, 0.31152739968144505, 0.05199600171655516, 0.356578188971592, 0.013276556587972888, 0.3559714793561062, 0.11623372565414047, 0.10130036366614381, 0.10716578344594341, 0.1090820266506416, 0.09650972061446628, 0.06363541529132888, 0.06176242034770696, 0.09366700032397945, 0.11240442930057326, 0.10880421454079237, 0.09241280045408606, 0.07678660174861163, 0.09514504224341891, 0.10101063111089426, 0.09534266454543161, 0.09651281119917954, 0.10764691800073578, 0.09750248859866173, 0.9703308609223403, 0.9467507579302146, 0.9713396729773844, 0.972692860438902, 0.972219748687395, 0.9600468133143802, 0.9721992883609476, 0.9862510642518172, 0.9715601928988443, 0.32122380811967366, 0.28781321369952884, 0.35574341335065696, 0.27179771435524713, 0.2602732029425835, 0.1436945874947162, 0.32231926937005617, 0.27559601260641076, 0.34466100517081655, 0.4896886500850959, 0.17203529703560994, 0.48842330285706115, 0.20605623146992713, 0.20356587752221666, 0.19115558548051492, 0.31752422759920595, 0.47895700580933265, 0.2987872717353701, 0.14797413056170827, 0.19550673934812823, 0.09110570308044841, 0.12147519136741103, 0.14973045613342162, 0.10851783709980445, 0.1989100338630838, 0.20236326070791177, 0.14329976005032496, 0.1768762004330472, 0.15414197719937206, 0.17474195416303084, 0.14759346157779873, 0.19657539720919692, 0.1822789157379363, 0.15032334658631374, 0.1377917814011287, 0.09004333030235234, 9.999999999998899e-05, 9.999999999998899e-05, 0.02039927949273934, 0.0003324497646568503, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06500117759210922, 0.06547612564277228, 0.1027907476436749, 0.0543106134125354, 0.07360254799478883, 0.06163971424619319, 0.016203359526118177, 0.04290331745605713, 0.059320113833646104, 0.1519428834190183, 0.05525905428165845, 0.08446512619334468, 0.07243714706586812, 0.07321051127220124, 0.0473984146621671, 0.06622418854701395, 0.044135371237927545, 0.057586826412865055, 0.1779287903897897, 0.16509178375245703, 0.07726025638235023, 0.03342306877663048, 0.052728931704182136, 0.10757483742450225, 0.07058660172048281, 0.046961709542320595, 0.07018702186035375, 0.43802136126548663, 0.5116941733866337, 0.4616601848329438, 0.45155185061395964, 0.47825711620710176, 0.47544739308110906, 0.4640545097086607, 0.45110756959764053, 0.4496412655485569, 0.08226042677268575, 0.11162625431907802, 0.10009899190099691, 0.09804319868012668, 0.14375426701916372, 0.0950775015824793, 0.1177787194540022, 0.09263694524578314, 0.10258568010403724, 0.21878073024512013, 0.219384822306665, 0.1809563030325151, 0.17462318839943547, 0.2954850066341702, 0.15853216278494386, 0.1820059604586396, 0.1829571453916634, 0.29412856361019235, 0.21882034964989716, 0.38646508811037783, 0.27005570791732814, 0.2779066221967157, 0.3272034308824051, 0.28544752837773446, 0.34593551868813344, 0.37238850832140846, 0.3600989693212654, 0.27033752138395484, 0.19053393464793644, 0.2359155705292888, 0.21565936845807077, 0.1759785518248207, 0.19608140792388618, 0.2552461281009236, 0.2460836068159068, 0.21531522794481095, 0.18309590876428128, 0.18408946911924584, 0.18682702235550097, 0.19001237123867654, 0.17729569856671, 0.165243242584325, 0.18482656222830873, 0.19702965629049007, 0.2340359304115106, 0.18365391967188982, 0.20125646223104332, 0.18609243809786213, 0.2198039466636078, 0.1878491989584664, 0.21718238972802684, 0.3651176617862144, 0.2015944742598057, 0.1951759732311441, 0.16692951856420768, 0.1846554266775282, 0.16294137065623127, 0.1748622959763041, 0.19696518682665143, 0.7311099850642434, 0.6326853818496718, 0.637343731289258, 0.1693071809541239, 0.4715634939646115, 0.20560183477361738, 0.125221886532916, 0.5238852168453284, 0.11177292062273159, 0.1488734017237393, 0.10326345699737027, 0.20199649347603732, 0.5112918165538243, 0.18221178719391595, 0.18161308552380917, 0.18346897398464335, 0.18919098344718221, 0.1943704620150689, 0.18776620805768185, 0.1784689228020303, 0.21115490955723648, 0.17929888672569827, 0.08047900095923177, 0.08404396378469214, 0.08115516949101442, 0.07251218516035374, 0.07368213829642867, 0.07530274720459951, 0.09050532463859695, 0.08749294817803244, 0.08208691945496593]}, "mutation_prompt": null}
{"id": "ee985826-99b7-4cb8-bca4-2d4e42063909", "solution": "import numpy as np\n\nclass SynergisticHarmonyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.7  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.5  # Global attraction coefficient\n        self.F_decay = 0.92  # Modified decay factor for differential weight\n        self.CR_growth = 1.03  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** (t * 0.5))\n            CR = min(self.CR_base * (self.CR_growth ** (t * 0.5)), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "SynergisticHarmonyOptimizer", "description": "Synergistic Harmony Optimizer using adaptive weight and crossover modulation for enhanced exploration and exploitation.", "configspace": "", "generation": 70, "fitness": 0.29533453304289214, "feedback": "The algorithm SynergisticHarmonyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.27.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8442821344669477, 0.8482643702840389, 0.8471334286709056, 0.8511101282130118, 0.8504554510823134, 0.853932755983934, 0.8388140878020878, 0.8475674756817825, 0.8536539463979886, 0.6920756928399352, 0.0678921149179279, 0.14381196806891727, 0.6948591267655988, 0.04534319817076815, 0.0747029626850888, 0.6452215150885844, 0.05677530874595482, 0.11155413803518077, 0.14875452423700863, 0.12049561245323914, 0.12188276298738399, 0.13009876720701663, 0.13807734729786802, 0.1209354864116371, 0.109598344793565, 0.12011096226152695, 0.11455569892111739, 0.1124339312490934, 0.09527754637908092, 0.1116388057030403, 0.10994682231448383, 0.08976647754156364, 0.1071093584931112, 0.1368644058363947, 0.09962413052269237, 0.13794708851641613, 0.9543128805468474, 0.9724827417332266, 0.9705871903695494, 0.9623726481808316, 0.9667147154686814, 0.9730517267851391, 0.9633837123740565, 0.9652394955653741, 0.963683306465547, 0.6392402070215498, 0.6340983137784113, 0.6233562163633882, 0.5999859889126766, 0.6478648448778872, 0.6056854707984165, 0.6256414362636588, 0.6112157429217305, 0.6415428532078435, 0.8042071441922344, 0.16497639827591426, 0.16975717631242748, 0.22016239324734233, 0.2753713226706108, 0.15952344906945293, 0.2299205692114762, 0.7441446739543065, 0.38365170681304084, 0.1722292182655195, 0.14865831669191465, 0.1306130408331293, 0.12606362641163382, 0.19032675402372756, 0.1309096060757965, 0.13045553048784353, 0.11328772685083022, 0.1307973680215322, 0.25932995105520995, 0.22137714545402865, 0.18792866772095407, 0.1706023382002455, 0.17331399045799445, 0.17017250120441663, 0.14126982639958063, 0.09817957740204508, 0.20754276036469643, 0.015173163392619426, 0.03702063912303544, 0.00013896440548921696, 0.000175204183047728, 9.999999999998899e-05, 9.999999999998899e-05, 0.032072437698068446, 9.999999999998899e-05, 9.999999999998899e-05, 0.11249210031822954, 0.10002090156827903, 0.15273913622766289, 0.08055808519432017, 0.08848367903563381, 0.09126073473140639, 0.04442527321595058, 0.15483370649972017, 0.0529907088172582, 0.06199319001856507, 0.0328969633932884, 0.07600490364110501, 0.1354569457785597, 0.11298107355806186, 0.09941870478650561, 0.09396828470627805, 0.1598684270716576, 0.06868595520819931, 0.04985940994506055, 0.1640583487220687, 0.04325346413421194, 0.18987212408363807, 0.1126156566757972, 0.1291298767296707, 0.05574144131472858, 0.12654742035242905, 0.11236502230642131, 0.5537044543338502, 0.5354836465846495, 0.5587611601927128, 0.6087652961477019, 0.5362673321332667, 0.5770956656292863, 0.5843068913459258, 0.5801675225852195, 0.5696818624844145, 0.0743806725220808, 0.12853308469921298, 0.16904595567854452, 0.13095943908923668, 0.1121668986572304, 0.14496616894091008, 0.13005590825798663, 0.10716872092694307, 0.13620999777976028, 0.2088079925271905, 0.20412089618726414, 0.21411465290640685, 0.37652106129945406, 0.18437934290099722, 0.21455565453612413, 0.3323401325133709, 0.312158787639252, 0.17724486506279336, 0.27088238099287953, 0.2792756351493795, 0.33092292774371523, 0.44291314872845056, 0.5309947989430699, 0.33514335041259535, 0.4638372103541626, 0.5274454267745764, 0.450038482806455, 0.3241159672332058, 0.26371023639251734, 0.27056735182182, 0.3328767552831532, 0.2594177279039642, 0.315303166699782, 0.3002272633455946, 0.27952373250617024, 0.21987847472385125, 0.20066439446304962, 0.2173413573498264, 0.20605667683755358, 0.22453201728697936, 0.1644821718433488, 0.18942966701885866, 0.19339103492179333, 0.19431561114361806, 0.23302348013792828, 0.6813165133158904, 0.23061531655442413, 0.218408578877047, 0.24063291014211574, 0.23751941812320498, 0.1987316026781204, 0.21421879686863599, 0.19911039005663922, 0.20030049006123107, 0.16570166320901458, 0.16513275041615272, 0.14702729224235878, 0.8876750375174919, 0.1992107855539188, 0.1970670602166117, 0.8647952550074535, 0.16921435350444847, 0.17368615844947288, 0.8550660670999989, 0.21133171498510572, 0.6348132632575686, 0.8145378943245655, 0.6821257733364153, 0.15451610215089295, 0.16382517214533876, 0.3465544463161915, 0.16358518239608766, 0.19238997689516124, 0.18293247397328483, 0.17940887783465664, 0.1717688430824863, 0.18116322520388561, 0.17474862284921144, 0.19720166177978316, 0.17696279336972998, 0.18274919124024258, 0.09301678843273675, 0.11207773678508315, 0.08189750328169743, 0.08475981957143408, 0.08704832859741585, 0.08372280628430051, 0.09980452292446751, 0.08030519191962993, 0.07600417688612782]}, "mutation_prompt": null}
{"id": "adc4bfad-4482-415b-a70e-5d953473fd0b", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "116cc638-41b9-4ed6-9b16-ac04e3b917c7", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size for better diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n            \n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Enhanced Quantum-Cooperative Optimizer with adaptive hybrid mutation and learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 72, "fitness": 0.2890277589952671, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8044213712452113, 0.8142691568727498, 0.7898989249717041, 0.799478082719456, 0.7986855357488716, 0.8013782750267867, 0.8024431807422127, 0.806161938848007, 0.7931971094536139, 0.10404981077696662, 0.5877695651768933, 0.5777817155325995, 0.5558782788940602, 0.6269994796427056, 0.5953962106693679, 0.46003597518608386, 0.6126981410678247, 9.999999999998899e-05, 0.14387202955931266, 0.1323174165201897, 0.0834234497332309, 0.13503187696658547, 0.12373974205073479, 0.12988994666445086, 0.10835210199042755, 0.09577798261877413, 0.16414050724998175, 0.1457944156748162, 0.09099883027873601, 0.09096186205675605, 0.13985226104047432, 0.10628868133284108, 0.13248252749737022, 0.10814321411804828, 0.10916531563738341, 0.10488957655552311, 0.9305445348642948, 0.9436244076087782, 0.9197974926917111, 0.9581987039804122, 0.9567332769679061, 0.918508211139896, 0.958627758456481, 0.9445480348743899, 0.9454480735864348, 0.5381865658135745, 0.5779081160193108, 0.5117147687779101, 0.44286781156865584, 0.5228533846757462, 0.5088713390892596, 0.48955331369751454, 0.45566769748295255, 0.5114599531474873, 0.2265957552433291, 0.22411324141527866, 0.7680150644004171, 0.16059685879559293, 0.21190461233682167, 0.3623355453149879, 0.7941509015238459, 0.21733178775652495, 0.22110200564286542, 0.22118124586691135, 0.14754795726730097, 0.16583616145928315, 0.16044892939428157, 0.17702798011233223, 0.1262373411587674, 0.16539086685380278, 0.18061183710889706, 0.21454301281065913, 0.15719932044035723, 0.17647265720739236, 0.21135541734775598, 0.15891431629948727, 0.20158329454937762, 0.20762204931510553, 0.17041078864577652, 0.13373552364473762, 0.14178237030901897, 0.07896651595591098, 9.999999999998899e-05, 0.06945067201282706, 0.02869482854149341, 9.999999999998899e-05, 9.999999999998899e-05, 0.069852404137695, 0.08628949951618758, 0.040249982947940355, 0.07372503186412727, 0.07058677584586326, 0.09905550016098641, 0.11122990254522047, 0.08079343101074121, 0.0613513460595394, 0.049024904707171246, 0.10518271804388402, 0.19442470642083687, 0.06836181080486314, 0.03861771723690166, 0.34508141878213316, 0.16396854344413314, 0.1663406599664078, 0.08561074672774993, 0.12288149949484117, 0.10774077175017627, 0.09164982808901112, 0.18376950510934253, 0.04950730915790469, 0.11952907208855179, 0.2223673722919176, 0.13723121229373714, 0.287467266135499, 0.15836823791932475, 0.1103293992149682, 0.1521724471626612, 0.5165080189541121, 0.5188967359259866, 0.4984078052815245, 0.5997110338473421, 0.5162743260137668, 0.5275378664622977, 0.5422605844434398, 0.5285374293424354, 0.5117588580263965, 0.16484009347978446, 0.06401350352880275, 0.10145816582402112, 0.12781128445064494, 0.13008236409442286, 0.17052861819171705, 0.12826743256159678, 0.12909493478329093, 0.09874172334680154, 0.1973542976737933, 0.17055548358470407, 0.24686955978955516, 0.1803880582996128, 0.2989486294768795, 0.40708681002350755, 0.1370401218584384, 0.19247165609985717, 0.1577936315552062, 0.42825520003747053, 0.35700321466326, 0.2774664284636984, 0.41619916791038614, 0.44698347258399607, 0.42749413963601957, 0.5465896499845992, 0.4850541378689004, 0.46260439761115524, 0.32940526194107045, 0.2509940114393501, 0.26230256850497635, 0.3431352573619576, 0.2189990275621586, 0.30871647147440595, 0.3624671755780614, 0.24963565802780008, 0.21288179237940064, 0.20051441429957417, 0.20106224055627075, 0.18776962781154816, 0.2167040431475079, 0.23511416407099894, 0.20564992526911152, 0.2242614880349909, 0.216223697144296, 0.21867469884845547, 0.19920243858190367, 0.1934076238367155, 0.21035010831921808, 0.22782426835401026, 0.19056625202669675, 0.2170281010182673, 0.19978581932219608, 0.24004583220762443, 0.20348772764263356, 0.18617573555736766, 0.18789142957773952, 0.16671454452335388, 0.8682632563653111, 0.19895987926266612, 0.14704600049779581, 0.14150121452088382, 0.17299549145799942, 0.14139787484395205, 0.7047186969269983, 0.2109441166675946, 0.20585416179110827, 0.20782592643027442, 0.4388830262818142, 0.2086047626394748, 0.16697372881991157, 0.16778079835229964, 0.7766059797790653, 0.18148313580861308, 0.17637673464045223, 0.1877632959233413, 0.1787377392196693, 0.18293557806335892, 0.21007621276842847, 0.18236528257367224, 0.19842556064088157, 0.1838735449868153, 0.08452780424966799, 0.08156478425645508, 0.08965934776854811, 0.0872241734201068, 0.09587094505562888, 0.07635709889520492, 0.08682027845183926, 0.08399855153599822, 0.08060290575786566]}, "mutation_prompt": null}
{"id": "5893ccd2-70ff-4ba5-adb9-bdc747e2b477", "solution": "import numpy as np\n\nclass EnhancedQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Increased crossover probability\n        self.w_base = 0.3  # Reduced inertia weight for PSO\n        self.c1 = 2.0  # Enhanced personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                crowding_dist = np.linalg.norm(x0 - x1) + np.linalg.norm(x2 - x3)\n                F_adapted = F * np.exp(-crowding_dist)  # Adapt F with crowding distance\n                mutant = x0 + F_adapted * (x1 - x2) + F_adapted * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumOptimizer", "description": "Enhanced Quantum-inspired Differential Evolution with dynamic parameter adaptation and crowding distance for improved exploration and exploitation balance.", "configspace": "", "generation": 73, "fitness": 0.2558814704899508, "feedback": "The algorithm EnhancedQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8462934682466557, 0.8615824838237607, 0.8385170501219168, 0.8385229752234042, 0.8539967396174738, 0.8479813547059171, 0.37706278198060583, 0.8475702047789503, 0.810837615623898, 0.126580573796086, 0.09120246018381073, 9.999999999998899e-05, 0.15927149157373843, 0.41199199567030886, 9.999999999998899e-05, 9.999999999998899e-05, 0.1529944381709214, 0.3260454311170754, 0.14232476179301012, 0.0967993918411274, 0.13676008988852484, 0.17127160282837217, 0.08489050376586094, 0.10825481340719889, 0.09796506291103602, 0.1086356660688923, 0.13194247078846788, 0.10539255988959106, 0.12688255965342377, 0.092194722153634, 0.10717602158459305, 0.07978629493711109, 0.07453644584600316, 0.10775790022390086, 0.07956883225679989, 0.13394562950415945, 0.916516680909416, 0.9294273671826246, 0.9151270012848455, 0.9173917946341857, 0.95518233740493, 0.8203219118231713, 0.9451809895306724, 0.9279798697363628, 0.9584167794227679, 0.6615422608981133, 0.5920085977823457, 0.06707990367922922, 0.6022931931926044, 0.4231655538849751, 0.5908322660780294, 0.49881339265411917, 0.5800303332523155, 0.6403348836559535, 0.38725370200724163, 0.1708379669346588, 0.18161426651383317, 0.21280012111635938, 0.27501094096767675, 0.2723986227189268, 0.14744694417432314, 0.17737461388853937, 0.23142937896692273, 0.15528763244201493, 0.13490839754216433, 0.11508928718832578, 0.15260308182116877, 0.12679904272683928, 9.999999999998899e-05, 0.15106719757928655, 0.24377776751315705, 0.14148682010877833, 0.1253740866195605, 0.12886283828036937, 0.13258959931828618, 0.13249101523826612, 9.999999999998899e-05, 0.14982950479913104, 0.12870531740114388, 0.17857966819414228, 0.129146449003383, 9.999999999998899e-05, 0.03808767149069914, 0.048069558371671484, 0.041440803520179315, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003832610837817496, 0.07890353096451941, 0.04478070893762398, 0.05713489111375547, 0.08489288251250016, 0.047279283008618944, 0.019896855548012904, 0.06744352978067414, 0.039355878954559054, 0.04927318712236084, 0.08558559370246743, 0.11020972828290054, 0.18692009639909857, 0.09152621362175983, 0.19288484477886647, 0.2949542751441431, 0.07025333498864406, 0.14210915292701032, 0.20457616611901008, 0.1497361235086686, 0.07171253761196117, 0.09310197564097267, 0.12767480214196314, 0.12137117806386122, 0.18722303642470095, 0.2500908821424851, 0.08429872448388565, 0.08175418288628478, 0.5686048888483959, 0.4937215673205243, 0.51156614728472, 0.42172711983806443, 0.5399453864986675, 0.4690370880853326, 0.5848954051526016, 0.5615230421887163, 0.5438706628260737, 0.09004446215801165, 0.0654698856022955, 0.14148131211509718, 0.1543306703413373, 0.07792172203919068, 0.09571446318486121, 0.073553534098306, 0.12145061719030259, 0.12775160993104806, 0.16012929154520295, 0.18050791640742847, 0.18181727321052055, 0.2434394550005572, 0.25757024331910083, 0.23126960427159426, 0.49592758439164797, 0.2669004632885519, 0.1547136956399049, 0.3341929645651589, 0.2775737722850563, 0.4341813500498616, 0.36757993754275897, 0.34082801083414804, 0.3666366156781672, 0.3305467223260312, 0.25299710746301396, 0.3840244259294926, 0.2146851425679681, 0.25179033566450026, 0.27926634859459665, 0.24235912985098162, 0.23652927556239733, 0.28774563868526226, 0.21754230493930105, 0.26813891360580866, 0.16383737757175654, 0.20973696929276553, 0.20594323841778694, 0.1963619077951243, 0.21338801570033794, 0.18976553904573612, 0.18032499463849105, 0.1808171870394193, 0.26684238040196206, 0.22154065198203543, 0.2224797845230687, 0.17228679446784523, 0.19205712834121613, 0.18422664309019388, 0.20704490611280757, 0.18976786335925977, 0.19540032714884603, 0.19306658782062847, 0.18468282650988654, 0.26590015257978683, 0.18813349191112239, 0.16739391310764407, 0.8734925019373261, 0.199978996588821, 0.19752416868176437, 0.14181559558608092, 0.6458576815099601, 0.8825080517292597, 0.4102019933401583, 0.20717185644660152, 0.07340036430014174, 0.20780000064613147, 0.166115756621242, 0.1522900566653721, 0.12176619704749847, 0.10304878634098191, 0.3730550063549902, 0.17234077242996104, 0.16837819669348597, 0.1767786593968247, 0.1819757693380909, 0.17732597052737542, 0.1838542404307364, 0.18847059179511538, 0.17898034671002372, 0.18377217524314315, 0.07154002921554714, 0.07973641126291164, 0.07826713168878774, 0.09157562509046935, 0.08497888471820803, 0.08237323685687548, 0.08911897041899719, 0.074683980401273, 0.08939781595587826]}, "mutation_prompt": null}
{"id": "a23eaa34-0732-42ae-92f7-5ded7ef281d2", "solution": "import numpy as np\n\nclass QuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Tweaked differential weight\n        self.CR_base = 0.85  # Increased crossover probability\n        self.w_base = 0.5  # Increased inertia weight for PSO\n        self.c1 = 1.5  # Slightly reduced personal attraction coefficient\n        self.c2 = 1.5  # Slightly reduced global attraction coefficient\n        self.F_decay = 0.92  # Fine-tuned decay factor for differential weight\n        self.CR_growth = 1.03  # Fine-tuned growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Reduced initial velocity range\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumHybridOptimizer", "description": "Fusion of Quantum-inspired Differential Evolution, Particle Swarm Optimization, and Adaptive Parameter Control for enhanced convergence.", "configspace": "", "generation": 74, "fitness": 0.2887112154695334, "feedback": "The algorithm QuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.781241390777987, 0.7953313817078369, 0.8000471693224843, 0.7983565151291242, 0.8134900696494434, 0.7843136245905828, 0.7984254831174705, 0.7965424218851747, 0.7953506401082613, 0.5864714370342049, 0.118403415256643, 0.07385777416123296, 0.05545090881628856, 0.5372819011249126, 0.06923492059754843, 0.08919899667018927, 0.5639092513708895, 0.5769980619590642, 0.16299152082106594, 0.11539989310988208, 0.13721109865490522, 0.0996337422572422, 0.12601375737442355, 0.10187992148173652, 0.12008759779254219, 0.108671244343016, 0.1230762578537653, 0.10953166881524756, 0.12063348013340403, 0.10611079866673134, 0.10924056132254589, 0.10488471802064192, 0.1180771296247689, 0.10781986673403676, 0.10799843757331551, 0.10789699222418125, 0.9577199187572543, 0.9434826312130129, 0.9550458048689503, 0.9719171864605245, 0.9561212258532876, 0.9302533201486244, 0.9718426799456845, 0.9586842551403952, 0.9574704502554131, 0.5752275630650395, 0.4587312148961209, 0.5120191492844384, 0.5049798279686983, 0.53589192473007, 0.49855190621547896, 0.49278818925905055, 0.5248312110602219, 0.47470030931366136, 0.2197586297462253, 0.22474992873218447, 0.3715411062637156, 0.2759125916301831, 0.7824630082234447, 0.26686292416339186, 0.782338254216637, 0.7728603515989425, 0.22204974596418814, 0.15460329146802965, 0.12325413456666978, 0.15100559463730168, 0.1615635909459594, 0.12168079137917553, 0.1623138179929643, 0.15099726533879188, 0.17389809156684255, 0.16763554503786038, 0.1383408682998999, 0.12880958762988282, 0.11340610845627652, 0.23382910538547097, 0.23611343847450084, 0.1963961933793661, 0.1928964720010269, 0.2500711639558447, 0.21173802392757335, 0.041209984514886, 0.002047440422223379, 0.04801056460927722, 0.03928416537183044, 9.999999999998899e-05, 9.999999999998899e-05, 0.005862690603036014, 0.047057678693976035, 9.999999999998899e-05, 0.12239176669346308, 0.06922823126540056, 0.07958114209659028, 0.09792166281842529, 0.07637614558506645, 0.04106445097086875, 0.10867145792967692, 0.10468886565869562, 0.095877338453355, 0.07905618207518239, 0.0891333831877249, 0.2914837600283231, 0.1043694973601732, 0.06649633665173516, 0.3122925863757873, 0.08640794107797378, 0.16690660991657946, 0.18631323611388562, 0.06422517716194365, 0.09446626884194198, 0.08330592462211406, 0.04895298854574226, 0.18612299513402297, 0.14658412432292556, 0.2140148806572928, 0.11813194818337525, 0.0886064922642027, 0.5048978949023971, 0.5221237251620658, 0.5128544206218808, 0.5266724580569526, 0.5517556157592487, 0.5718649088639705, 0.5841312387450164, 0.5326027410237, 0.55281738332262, 0.14120159545580024, 0.11405273060834575, 0.1445479297683656, 0.0761241713022126, 0.12616205472802433, 0.12924562724471855, 0.12362469751967897, 0.1413524721320466, 0.15766743230393532, 0.20187244454903297, 0.38950257091907625, 0.16949004285716252, 0.24588468787764461, 0.3070885038160486, 0.23071108994107048, 0.19041459920208081, 0.3154190447022508, 0.24828693546730551, 0.3913944044588853, 0.4377490232248129, 0.36774661211846815, 0.3888349544831715, 0.2108765640185004, 0.46990287375727535, 0.44999695309544874, 0.51195109662878, 0.3258926313184991, 0.29133398120994314, 0.34506439359646224, 0.29820394357744373, 0.2137859185703146, 0.22077268276325768, 0.2980450787826632, 0.3230852365081599, 0.3528854183872622, 0.2771263745047988, 0.21350546989579144, 0.26898518380348346, 0.20309333382419203, 0.21077461049194768, 0.20255236230603346, 0.18811914598370483, 0.204475457506326, 0.1926643778484638, 0.21155192747151053, 0.19225763975408416, 0.2031923193928944, 0.24176662559297935, 0.21443702800648523, 0.20769226501513827, 0.2374658014215797, 0.24180704752570492, 0.21685265067366177, 0.18090682184146367, 0.1765990640288353, 0.8552228885144145, 0.16947953065448707, 0.8360337207331499, 0.1990024146551569, 0.14680051710778919, 0.14120516159026297, 0.17604085010343384, 0.8650194626618042, 0.758802747745972, 0.21027486466844714, 0.11040619476525393, 0.12674033783883965, 0.2085952546512292, 0.15415747286749193, 0.11216763413751285, 0.7407604160927276, 0.09433937349778077, 0.18731426204582158, 0.19013162361449765, 0.17827959148243167, 0.18204469341845575, 0.18091817371337005, 0.17800872179715965, 0.19045690221865008, 0.20367369043899497, 0.19553986104404353, 0.08594688903815417, 0.08958001570102592, 0.09149356786641438, 0.07900900028430258, 0.08552142358589554, 0.08499231614322655, 0.07419355571526376, 0.08788345730673297, 0.10101330176917056]}, "mutation_prompt": null}
{"id": "cc1ae570-677c-4bea-8390-9ac754b65b91", "solution": "import numpy as np\n\nclass EnhancedQuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.6  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Enhanced decay factor for differential weight\n        self.CR_growth = 1.1  # Enhanced growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** (t / self.max_iter))\n            CR = min(self.CR_base * (self.CR_growth ** (t / self.max_iter)), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumHybridOptimizer", "description": "Enhanced Quantum-inspired Hybrid Optimizer integrating Adaptive Mutation and Exponential Decay for efficient exploration and exploitation.", "configspace": "", "generation": 75, "fitness": 0.27074903563854646, "feedback": "The algorithm EnhancedQuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.743617636652798, 0.760304442768088, 0.7561670154643438, 0.7483336849489595, 0.7518896527767269, 0.7610995608970703, 0.7566439058102683, 0.7757445611637057, 0.7430536128177894, 0.5031769154878367, 0.47429343825474746, 0.49393325190987514, 0.49735118603863837, 0.49443008533826116, 0.4937254404118244, 0.5020001716325857, 0.4656379670353933, 0.5072728025667903, 0.1336166030459488, 0.11822055620822725, 0.10090679352341392, 0.07354914284887948, 0.11203834763092602, 0.12387935901633207, 0.12227868359159, 0.11925812853683859, 0.10795411971363389, 0.10429194765924199, 0.1218327669478333, 0.12798414124468438, 0.11595949041811093, 0.09082786939208576, 0.12819628186510257, 0.12579489202447602, 0.1263795107816459, 0.1036867350337558, 0.9637462082060257, 0.9544822515401458, 0.964894074418781, 0.9553986847750295, 0.9657711795235241, 0.943954890534617, 0.9655661978179156, 0.965076101843524, 0.9743519035904207, 0.30999679950259484, 0.2737224948539725, 0.19686111720308186, 0.2845865958846676, 0.3343434365824246, 0.3296505580536465, 9.999999999998899e-05, 0.2962489490939827, 0.35138045062999756, 0.5575257509546947, 0.4454927919261239, 0.3413442140408156, 0.20698791936836303, 0.26669160670447856, 0.19257707444298, 0.4790784048567033, 0.23268647323162195, 0.29651006631967014, 0.17894399913342096, 0.19957202963985565, 0.2415552759046492, 0.11027639844271708, 0.11777752394799867, 0.17984148064486583, 0.18743987932751116, 0.18587890258031803, 0.18133648567059757, 0.20237528908805602, 0.1865891967388289, 0.13579246146800228, 0.12456766229376737, 0.22831374986641872, 0.20073964478300144, 0.20899061568009658, 0.08892418115889411, 0.22197191514104941, 9.999999999998899e-05, 9.999999999998899e-05, 0.07117481612910359, 0.030389669189049395, 0.0014926824010895734, 9.999999999998899e-05, 0.012485136821168585, 9.999999999998899e-05, 0.012982304684044377, 0.08077650280447357, 0.10407551767237766, 0.02979249692248631, 0.061732663239669416, 0.07004642280849771, 0.046748787479377496, 0.08986457844827744, 0.11049585242529247, 0.05086079467293714, 0.04042288685938589, 0.04206138500179191, 0.10986525943621706, 0.09973867621736632, 0.06189041147305763, 0.07809760295806845, 0.16731588945876552, 0.09589803623982729, 0.061704619274881356, 0.05742921894944397, 0.1015340442247028, 0.04015259011757677, 0.26473373182066784, 0.09024307256348785, 0.11391611884145036, 0.20619980724784703, 0.12915967136211148, 0.07686849750890867, 0.4648167407671193, 0.5067265276868843, 0.4876761234430148, 0.49452322958447914, 0.5195250025564916, 0.4909621968785758, 0.5010921477111758, 0.48147989186436335, 0.5222088160583552, 0.08798447799076403, 0.10337180435056326, 0.1208282936737769, 0.09654045302807668, 0.11622747026698832, 0.10130268128037334, 0.13232713651339978, 0.1464877977112755, 0.142346356103753, 0.13940627273254647, 0.211011086194969, 0.16376221433315663, 0.21102374574563687, 0.2964598741755228, 0.13861618073651394, 0.42567229499272863, 0.1878695185714444, 0.20501044954816106, 0.35332301035675007, 0.34899515621100585, 0.42590565378947454, 0.34919241217312613, 0.391811294879583, 0.3088868171559378, 0.3841967620409644, 0.4123228157084393, 0.402240437061538, 0.22977158131808662, 0.23797406676068344, 0.29816382523321483, 0.2532182264020104, 0.2237386188932089, 0.23428568678247497, 0.26600025238426006, 0.2584783864545803, 0.24265164828681962, 0.19039131926589403, 0.1808079965153523, 0.1846571450560811, 0.1815436400711793, 0.19686504816186, 0.24207925731148994, 0.1754797445803652, 0.19066615071240778, 0.18932867316085356, 0.21886660820488346, 0.21639762420882835, 0.4489596072658968, 0.22868681491639975, 0.19437788729169125, 0.276368431146533, 0.19593799029652847, 0.2056501814381163, 0.19542725259856208, 0.1663359691206342, 0.16778627723284878, 0.1893169936968433, 0.8197355117545839, 0.19938617209034493, 0.8035227114319589, 0.18190271934885105, 0.16038592920115502, 0.8468645498168359, 0.5408052598508093, 0.20578428129707027, 0.07326190982844871, 0.41397332756438887, 0.15885528721644981, 0.16775160576377712, 0.10416697327315505, 0.5551835152658592, 0.19536425946269542, 0.1963618774830055, 0.18179442885482955, 0.18916058636596522, 0.18041625642725723, 0.17715254458215024, 0.17749897289220995, 0.18569846349687047, 0.18761984567277912, 0.1882485777007421, 0.07454618809157365, 0.07634345183344327, 0.08543428551155763, 0.07972829330754161, 0.08688250861747615, 0.08156326329836561, 0.08580235144862713, 0.07320263602058841, 0.06925377038746994]}, "mutation_prompt": null}
{"id": "275fa01d-da01-46a7-bafa-aab540c94016", "solution": "import numpy as np\n\nclass HarmonyCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.6  # Adjusted inertia weight for PSO\n        self.c1 = 1.6  # Adjusted personal attraction coefficient\n        self.c2 = 1.8  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n        self.HMCR = 0.95  # Harmony memory considering rate for Harmony Search\n        self.PAR = 0.3  # Pitch adjusting rate for Harmony Search\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                if np.random.rand() < self.HMCR:\n                    indices = np.random.choice(self.pop_size, 4, replace=False)\n                    x0, x1, x2, x3 = pop[indices]\n                    mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                    mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if np.random.rand() < self.PAR:\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HarmonyCooperativeOptimizer", "description": "Multi-phase Harmony Cooperative Algorithm blending Harmony Search, Particle Swarm Optimization, and Quantum-inspired Differential Evolution for enhanced convergence and robustness.", "configspace": "", "generation": 76, "fitness": 0.2546955469693099, "feedback": "The algorithm HarmonyCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6795048812225183, 0.6766042011704376, 0.6907406014165166, 0.736267737441691, 0.7151234624423466, 0.7097883045641981, 0.6859262146845424, 0.7181024394451929, 0.685403029412559, 0.42068998262310586, 0.3729936538525781, 0.07386916655402653, 0.05582817020593667, 0.3307032833243492, 0.4168383372728054, 0.018245155432522697, 0.3695275489926324, 0.43446581453965405, 0.12854910813424725, 0.12866090305870437, 0.09553263268453771, 0.09155760983964178, 0.2457526955707856, 0.1295426806634894, 0.10129591874476573, 0.1040791012404294, 0.10847494447891881, 0.13658584852832178, 0.09205705647466278, 0.1379597904269274, 0.12921948890689183, 0.10688179963296174, 0.11106737417350998, 0.10229116227765112, 0.09590723174470406, 0.0979118217940137, 0.9558450064824168, 0.9676450235224251, 0.9691668011041986, 0.9717015553142906, 0.9447509342662268, 0.930835790521107, 0.9718687045386022, 0.9628867588153859, 0.9584938180750803, 0.29133856669960945, 0.32697441730174237, 0.3036311798691905, 0.34670722837239165, 0.3073815814334977, 0.3146224829637374, 0.3291853723778281, 0.28655526147672095, 0.34204728138432006, 0.3059349044946701, 0.5675611279021082, 0.565082153784243, 0.20686200561501278, 0.15783307663434842, 0.5796299827502296, 0.12977551198109127, 0.21460098199579658, 0.22830860290989596, 0.09809685912722421, 0.09580579288240565, 0.17942987252662956, 0.15992119037716002, 0.16258281486949766, 0.161583075195613, 0.11286481648566626, 0.11212974630836647, 0.17299667360022286, 0.17153325058989066, 0.10812531749933718, 0.18623474133680917, 0.18611030639689807, 0.12327078919678747, 0.18874376214741273, 0.20077994359693496, 0.20091928229919598, 0.15921008922039348, 9.999999999998899e-05, 9.999999999998899e-05, 0.011953439795505116, 0.032363241233349105, 9.999999999998899e-05, 9.999999999998899e-05, 0.003962967298790088, 0.04127493750397748, 0.00010072243371528344, 0.061191588191396806, 0.04486520694475915, 0.03444664802917574, 0.08408919791335479, 0.0818200105454927, 0.07079688078722679, 0.08213439583818671, 0.06237725154674367, 0.05474063721737221, 0.036584604828569844, 0.03616384264955397, 0.12152390979380578, 0.05907273496062082, 0.11673362399462839, 0.06555147815357631, 0.07192770949621463, 0.12709900747419256, 0.08188638453162767, 0.20921951853432297, 0.09885006374374894, 0.1796832965903048, 0.04818586816804926, 0.17487008512943958, 0.13112059835059275, 0.08499385275434657, 0.14579815741617352, 0.10018171456109215, 0.46393473700585985, 0.473593613013656, 0.45148537963854984, 0.4432649186736557, 0.4909664680661834, 0.4790159409693726, 0.4929095965001189, 0.4711354271127163, 0.5258948774059258, 0.09827278136322093, 0.08273825454570705, 0.10805239277767364, 0.1267795729933776, 0.08514508036746615, 0.12492891717698418, 0.10045825020258181, 0.07503779667263566, 0.07326669350085468, 0.14090043252761209, 0.19820250009465012, 0.14241137708921703, 0.1547733172074608, 0.23309036500480318, 0.14089000577314492, 0.12623224941519962, 0.16679566931504963, 0.17900591464620008, 0.389112279944533, 0.2703668121897196, 0.3761080688015366, 0.3622366695899194, 0.2774336410005309, 0.32247012668088515, 0.36730390824653625, 0.3866024919207469, 0.3298335015648931, 0.1677283895419559, 0.2508939079160517, 0.24723277952297662, 0.29339517222797085, 0.26621476341078465, 0.2700603344700381, 0.3023799574203002, 0.25558520531793283, 0.3106562974293944, 0.22253772773574354, 0.2524048417633741, 0.20299071494035348, 0.19680547047165642, 0.2093602989707387, 0.19670661217002994, 0.20486214640731815, 0.1973542409752832, 0.1919298949097229, 0.19363333420941886, 0.207129291288899, 0.18379609980840783, 0.23262118924032782, 0.2128987206922538, 0.3333994958424411, 0.3658925418907517, 0.18320148983800377, 0.19274933699129204, 0.8208631157425436, 0.1856299082189361, 0.18076208350892264, 0.1660010518907038, 0.6178351791014312, 0.1964082486565354, 0.14145905718124596, 0.16076759438995336, 0.16007647801478686, 0.6476571627182517, 0.20749865356197172, 0.11020796219056317, 0.14983225837717895, 0.20497242976831087, 0.1671110974396841, 0.5457813923180603, 0.6187227011343872, 0.567833536315564, 0.17601693123761541, 0.19592775196662893, 0.16986006721745928, 0.17716278276169817, 0.18520399916724772, 0.1916329792759428, 0.17829458863064596, 0.18473901448643415, 0.20563934790466476, 0.07091806685591195, 0.0730384474608009, 0.08412923528528593, 0.07727171570146851, 0.07776644965956858, 0.0850649948113743, 0.0931333165882936, 0.07918218371112995, 0.07728891209183841]}, "mutation_prompt": null}
{"id": "8a83056a-428c-43a1-bf84-c0a892d7ec77", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.sin((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "StochasticHybridOptimizer", "description": "Stochastic Hybrid Optimizer integrating Adaptive Quantum-inspired strategies and Self-adaptive Differential Evolution for enhanced exploration and exploitation.", "configspace": "", "generation": 77, "fitness": 0.2851042895407361, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8822062505331232, 0.8720503111031327, 0.8747916303242095, 0.8711135491911466, 0.869643905124602, 0.8683405041363066, 0.8606930397463103, 0.8664351111136486, 0.869388666263006, 0.10766059391234417, 0.04163681706937006, 0.7503041463493888, 0.7679606947358144, 0.7188936831702286, 9.999999999998899e-05, 0.10397292187978269, 0.15970172630357826, 0.08220728716361969, 0.13877149733908667, 0.15858675535713862, 0.15203971176101094, 0.14175759165178037, 0.14962622986272234, 0.17841750194133232, 0.09350728559956167, 0.11643685732627762, 0.15907873042849918, 0.15285452519034715, 0.10286669049195551, 0.11399642936146559, 0.10937430129693493, 0.1505711536611647, 0.13481140458381302, 0.13697545697362434, 0.12972711451487762, 0.12777915719308353, 0.9739937196577998, 0.9618028120201307, 0.966403570259555, 0.9758466834124936, 0.9784824366618727, 0.9592676452009433, 0.9748825049031492, 0.9674408757747484, 0.9763080179851596, 0.6103974865986457, 0.6717245343753315, 0.6590452865493159, 0.6446641451785231, 0.713222351734611, 0.6990535710466108, 0.7147617415669596, 0.6689489135744107, 0.6842110584684129, 0.24625545262839454, 0.17142411886361153, 0.22204635477009216, 0.2753085359465022, 0.27406146117360264, 0.2107777042634269, 0.21762344844551784, 0.857997183424741, 0.8511974632048557, 0.20932033904157066, 0.14625445968843254, 0.14630269612681113, 0.13678800943103941, 0.2442213500641276, 0.17948492995580378, 0.17469774388399928, 0.1251150962460924, 0.1409351749903024, 0.1719237801964566, 0.21302129698138306, 0.13021788397702472, 0.15501867633982513, 0.14542409783927046, 0.15122498447137134, 0.17003445611706525, 0.13710483488463543, 0.13269839973998443, 9.999999999998899e-05, 0.008155363362218893, 0.0629252971401364, 9.999999999998899e-05, 9.999999999998899e-05, 0.016185572017263117, 0.022419473628322195, 0.09263418880826901, 0.05091553656238923, 0.1359443391297004, 0.08237431856067001, 0.2217245527256131, 0.11065185313767256, 0.06638803960336337, 0.08348098715785468, 0.06337011365851264, 0.10624489521469893, 0.03423463692015649, 0.15475018963302867, 0.1157655233185847, 0.2728895541664622, 0.07852274610140264, 0.07740261411883353, 0.13357329580752197, 0.1391813588047679, 0.0908104565663922, 0.15268151875469904, 0.34397140318790587, 0.07191598173093883, 0.05143965158379249, 0.20304936690107356, 0.13033201454315824, 0.1476719833185689, 0.04836016241213059, 0.15456842898296996, 0.09552665440868846, 0.581477171583827, 0.49816079789399736, 0.5936555073870468, 0.5305667646430646, 0.4996467768663432, 0.6123595697860919, 0.48994576169642146, 0.4956464724870655, 0.5228380098062906, 0.11131775726038085, 0.1182562299441352, 0.09054463754661013, 0.11807587432761679, 0.09842950633766467, 0.10300516167466045, 0.11664270095808893, 0.10608041923988953, 0.14789133145136402, 0.18724496107094735, 0.22926640845005763, 0.17701572035584812, 0.30580927878691344, 0.38785732580803667, 0.24091224402948297, 0.1948615567690959, 0.21162875184268037, 0.19488282252211064, 0.2147286866284016, 0.4359045852253538, 0.2795390827883092, 0.46748343464012465, 0.42717662033918136, 0.25713545834986595, 0.45455865433354437, 0.3853569862183762, 0.4253637753538747, 0.27696841516777626, 0.18491710854133603, 0.3540305616797569, 0.21119907230002022, 0.26529728301135114, 0.2356962334802125, 0.31754343896305537, 0.2767997343798082, 0.24644550530987208, 0.21354875589360833, 0.19685097506178184, 0.2194181604366625, 0.22572786741888273, 0.17870180204641506, 0.20810507947602608, 0.19317016880113447, 0.18699104344456352, 0.1939021310711545, 0.20545775658692012, 0.19577528946588385, 0.18218613968615993, 0.18610378574631947, 0.20449115403284235, 0.18302130620636403, 0.20265603328273296, 0.20885751617778336, 0.22179628240418636, 0.19956585669145166, 0.12598889993555562, 0.15309133991306278, 0.20929630133821808, 0.1996076234069769, 0.19780694692540168, 0.1423975952877159, 0.16305335982125468, 0.1638789159353402, 0.5406937354545425, 0.5137335762161224, 0.21720543925611135, 0.20774474161174328, 0.211706033966521, 0.15444762014796776, 0.20915835139299987, 0.21120264882231155, 0.3156890750799217, 0.19121563158918553, 0.18561068608723397, 0.21055367945308512, 0.19140575659028414, 0.17355389956823442, 0.18398544413933127, 0.20020788510814425, 0.17993689878232266, 0.19151385234886542, 0.07654159322126886, 0.08615816106586427, 0.08015992220628432, 0.0867083945809789, 0.07419920526260726, 0.10457029886288549, 0.08493409586065936, 0.08803938058551597, 0.09845969752099082]}, "mutation_prompt": null}
{"id": "acb6239d-36ad-4aa9-b934-494827449772", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizerEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slightly increased population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly higher base differential weight\n        self.CR_base = 0.85  # Slightly increased crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Reduced personal attraction coefficient\n        self.c2 = 1.9  # Increased global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.03  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.6 + 0.4 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizerEnhanced", "description": "Enhanced Quantum-Cooperative Optimization using Adaptive Constraint Handling and Dynamic Parameter Tuning for Improved Convergence.", "configspace": "", "generation": 78, "fitness": 0.268018976314543, "feedback": "The algorithm QuantumCooperativeOptimizerEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7522342625024887, 0.7632696156475771, 0.7574788414737098, 0.7525537661863726, 0.7688286504304714, 0.7369191708747855, 0.762994571040614, 0.7326811118632979, 0.7725892112323038, 0.5007873774205487, 0.5101412993769703, 0.07312672824964284, 0.0006985278092366265, 0.4872720109202586, 0.4937958202564079, 0.04545576596072165, 0.058493194378016033, 0.503600412035135, 0.13259395333034696, 0.13506541673355044, 0.14781641257616196, 0.12213471198259285, 0.12720897910108253, 0.1392373097160935, 0.12394733760145793, 0.0959494866478694, 0.11314194605730676, 0.11241003644325753, 0.13440007820481625, 0.11910836933988556, 0.1193460189090858, 0.1395690193654906, 0.12321243748060406, 0.14321106545659823, 0.1102044645777569, 0.10884157890030033, 0.9586345120684847, 0.9195043380844068, 0.9588776824266049, 0.9725205602337572, 0.9472689178570374, 0.94317922842018, 0.9725840346744932, 0.9613113880129154, 0.9574208901184768, 0.38836783765519933, 0.4036114037519605, 0.42121514727152953, 0.3863954239228762, 0.4064098038693338, 0.40770985813155614, 0.3797307530273002, 0.36264885232998156, 0.37097595649918136, 0.3607100632654784, 0.2190712364492049, 0.22065332447614894, 0.27178654630367705, 0.187820812787441, 0.15953866777690107, 0.6178919400063001, 0.3607756211156887, 0.3458748520883731, 0.2792730401790092, 0.2027680058573389, 0.11896432998392992, 0.35480448182252267, 0.19444423331266203, 0.1761640176641981, 0.17460136438465357, 0.178462429759899, 0.18985086927105044, 0.12488967363704795, 0.21083149082133168, 0.15734741853107626, 0.2147665719844315, 0.20925527407447453, 0.1057571916760236, 0.18251575069660975, 0.18852703109087088, 0.17183672991724053, 0.005061129292992295, 0.05243978827719997, 0.018953576630787006, 0.04639415512463563, 0.034938650819209216, 0.005075321052572912, 0.0190194684706686, 0.003034359084771454, 9.999999999998899e-05, 0.12375619910790392, 0.06020504142851746, 0.08308743025745313, 0.03585523049116146, 0.09058355892085124, 0.08540961031702032, 0.08707779387023495, 0.05485671650223101, 0.09107726939245764, 0.16842068869156734, 0.0597070530332805, 0.10188164726885385, 0.10081576840309425, 0.059630913018144716, 0.07468014543390977, 0.06675076527790824, 0.13890239728299436, 0.08116522277272875, 0.14174676034944989, 0.20664456020602018, 0.10950361673265174, 0.1328105456285129, 0.17882843333726328, 0.16894203413375908, 0.07402268711048965, 0.07454770993903181, 0.08286434087024697, 0.4923548525714333, 0.47802456439872476, 0.4916135532465664, 0.510281537538124, 0.5356077275695148, 0.5180349922269405, 0.4659701215047155, 0.49931123008137923, 0.5094239018450626, 0.09966775293497632, 0.073339106124642, 0.0925122255750701, 0.07682237026278216, 0.09380830011450247, 0.10320803747950535, 0.11611351155428207, 0.12058079008300904, 0.08462572603975371, 0.13694285936268769, 0.18771034334679804, 0.27886350393106907, 0.1806649803898781, 0.19137936321673898, 0.2630579018905539, 0.19817069732509618, 0.2725348470162021, 0.28356280021939395, 0.431924357300824, 0.22182867469543588, 0.32803807587344236, 0.37002121408833977, 0.2135390239982704, 0.3663951092328632, 0.3726036489237249, 0.4647496868350458, 0.3984861482089932, 0.2769347116347195, 0.20687126428684066, 0.36484630197031775, 0.1513645514647447, 0.23197580950006136, 0.33269079638025967, 0.29495288738090086, 0.28332241662336155, 0.1959395196523006, 0.2346652153788228, 0.1985447480025645, 0.2069181079230854, 0.18330565501441975, 0.19379876692057685, 0.21856440174813696, 0.21029394126847678, 0.20598347454757604, 0.18477112641870597, 0.20155158129194894, 0.5083396024841011, 0.19687604231463085, 0.20893596196072517, 0.2312576379679644, 0.2096426596424602, 0.18658963269451057, 0.21936827434535222, 0.48198134447557706, 0.1645406522681906, 0.16436385691280297, 0.16928477742060966, 0.8399539238702933, 0.19753008726702181, 0.19135692217129296, 0.1415015725688321, 0.7752227300813274, 0.8009796635114728, 0.7749151864526271, 0.2103915423569298, 0.19466378665027717, 0.12691688082827446, 0.20775865217770362, 0.15144627894021356, 0.11170946350651556, 0.09326333596049718, 0.09396254176896857, 0.176653693478386, 0.2086419267066426, 0.1807611712675824, 0.1717039593437959, 0.17777329611816972, 0.1947194972234092, 0.18642185233084485, 0.20171433890050816, 0.19204285084951622, 0.08795673104417112, 0.08269438425922604, 0.07842822522126558, 0.07729373403255158, 0.07173362451586052, 0.07865681419020187, 0.08286700489564058, 0.07608853132262772, 0.07746631732530862]}, "mutation_prompt": null}
{"id": "4fd9c43a-6810-41d2-a65e-c0e43b37bc86", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "8aadddb4-c506-416a-931c-22e1ab63cfe0", "solution": "import numpy as np\n\nclass EnhancedQuantumMetaheuristic:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Slightly increased differential weight\n        self.CR_base = 0.85  # Enhanced crossover probability\n        self.w_base = 0.5  # Improved inertia weight\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Faster decay for differential weight\n        self.CR_growth = 1.03  # Refined growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))  # Narrower velocity range\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.6 + 0.4 * np.cos((t / self.max_iter) * np.pi))  # Adjusted inertia dynamic\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)  # Reduced number of individuals\n                x0, x1, x2 = pop[indices]\n                mutant = x0 + F * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumMetaheuristic", "description": "Enhanced Quantum-inspired Metaheuristic blending Adaptive Differential Evolution and Particle Swarm for diverse optimization challenges.", "configspace": "", "generation": 80, "fitness": 0.3009139384391887, "feedback": "The algorithm EnhancedQuantumMetaheuristic got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7710431720338446, 0.7692040134204428, 0.7692986019299219, 0.7828280708588125, 0.7702033787046705, 0.7757769553885102, 0.7878176427207816, 0.7567126241124938, 0.7604618283390936, 0.564237056513403, 0.5539103220537416, 0.5424250011279159, 0.5743202675136534, 0.5359739499586424, 0.5985446908503003, 0.559949291346053, 0.05347090595601889, 0.560373718584127, 0.10690796837524774, 0.15923691299751064, 0.14318501429957908, 0.126857224151534, 0.13064602117796564, 0.14948116414039947, 0.12285826715051695, 0.14702786920973998, 0.14083175799453818, 0.08673942189274964, 0.11469501489251777, 0.10563697074756184, 0.10707429494946064, 0.12504510801201563, 0.09322977722225023, 0.10439621322216774, 0.0980551943854584, 0.10742870950808847, 0.9589543003567091, 0.9507550280459387, 0.9718837813050725, 0.9602728380331974, 0.9590723103407618, 0.9593913184911667, 0.9590597820957235, 0.9468236721238552, 0.958588307551993, 0.44450683495568355, 0.4628901467832176, 0.47785908917826814, 0.49786366332337606, 0.5312821770208624, 0.454968680577283, 0.463528079938062, 0.4551282508996001, 0.5176537535715251, 0.3709580193199459, 0.7470238668106598, 0.7667707137459956, 0.8665470296438179, 0.3533075595415375, 0.2606474589307377, 0.8243633730016602, 0.23227815417210262, 0.7226236931216071, 0.34968935694918324, 0.12001591751375018, 0.21111508518006172, 0.16804932458011212, 0.17104299363275255, 0.11671453980626134, 0.148363226215111, 0.1520027039313382, 0.1846830832780797, 0.13195656930367372, 0.22003088096291434, 0.20527832119171607, 0.21919970745695228, 0.16337148977573468, 0.17757166181038775, 0.15372666331355067, 0.14427506038503468, 0.17450707071323635, 9.999999999998899e-05, 0.055466031393414994, 0.006466604489873129, 0.016934614125927894, 0.04706323930485956, 0.028105220594739855, 9.999999999998899e-05, 9.999999999998899e-05, 0.007592320719044809, 0.09749104560320432, 0.03620054236194159, 0.0851624091821408, 0.10407901688462351, 0.038656313155461475, 0.06063385192772164, 0.059673765223352215, 0.09137656487058043, 0.08536341874737285, 0.05931240817768635, 0.031087582795474522, 0.02946223995259023, 0.13741280960792246, 0.08338337108658722, 0.06627013823286576, 0.08380034703752193, 0.07050694074103081, 0.11151093100580256, 0.11556604087316846, 0.040660357755155196, 0.08221152105735163, 0.1760194605651797, 0.06686552639653676, 0.22711289823196523, 0.11880282266180142, 0.12124796873280941, 0.07710660940961023, 0.515350639976125, 0.5666275853019075, 0.5017872704564097, 0.5330503641940594, 0.4954650716729516, 0.5351579083038274, 0.5026382062545435, 0.5658882860092599, 0.5403919823674831, 0.08130516136748756, 0.09469994162207984, 0.1348387587694979, 0.11070933479703926, 0.07215525243696097, 0.11616272727802512, 0.14605494603995717, 0.10647080258474106, 0.08705280253136827, 0.271267178267555, 0.4883436979737791, 0.31430081526057163, 0.28674503852820477, 0.29250988193549954, 0.18767871602578312, 0.4378458653562073, 0.3051380064429684, 0.1933966284895009, 0.2970852403698546, 0.3795627597642537, 0.3108061488472781, 0.4616975069932415, 0.4624160230182115, 0.2912648794585161, 0.4304979686826881, 0.28548696761808745, 0.46123817827187663, 0.1940005771202029, 0.2341675497120942, 0.2515798616318632, 0.29211325569318614, 0.2538966067313144, 0.2613551559503504, 0.25178565399917574, 0.26247510124480045, 0.255476528790307, 0.21321616784799824, 0.20975249093413362, 0.19591636157846992, 0.20920433099072944, 0.21609762466097282, 0.21074185543965185, 0.234522385579093, 0.18982291775091253, 0.19943979671910217, 0.4549097964754316, 0.6309563151496977, 0.19496147688495913, 0.20409327458806437, 0.22432228892426964, 0.19124927190788343, 0.204680272281497, 0.2024372930822229, 0.18509207085655033, 0.8486404018372371, 0.1861213841220819, 0.18602710389929655, 0.846113334646306, 0.19909731491706917, 0.19891455576479056, 0.14155208153446397, 0.16190117617836353, 0.17054467147285957, 0.6658189073260368, 0.20830953413162367, 0.6565317715820377, 0.597353367442244, 0.12690430908628791, 0.39500915531478054, 0.65038843257192, 0.15234984135022311, 0.16639307515039858, 0.19904723343309194, 0.1858719731791162, 0.19698386524742462, 0.17053447732197746, 0.17645863196833056, 0.22144076436329452, 0.1878027318639136, 0.19638179912348153, 0.18465916636969926, 0.08099803844317721, 0.07595525445918139, 0.08440444458161966, 0.09103882167639332, 0.0797173583104186, 0.08592115369113307, 0.08323374087347113, 0.09805854068668085, 0.08819259562432602]}, "mutation_prompt": null}
{"id": "c356a6b2-21da-4b77-aad4-4ca14abeb24d", "solution": "import numpy as np\n\nclass QuantumEnhancedEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 9 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7\n        self.CR_base = 0.85\n        self.w_base = 0.5\n        self.c1 = 2.0\n        self.c2 = 1.5\n        self.F_decay = 0.9\n        self.CR_growth = 1.03\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n\n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n\n        eval_count = self.pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - global_best)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                \n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity +\n                        self.c1 * r1 * (personal_best - pop) +\n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n\n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n\n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumEnhancedEvolution", "description": "QuantumEnhancedEvolution merges Quantum Superposition techniques with Adaptive Evolutionary Strategies for improved solution exploration and convergence.", "configspace": "", "generation": 81, "fitness": 0.2628010816622877, "feedback": "The algorithm QuantumEnhancedEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8321164485778998, 0.8007406588508371, 0.8071723828965515, 0.7988375486644892, 0.7915822872731266, 0.7955275021789465, 0.8004701580262235, 0.8051539917782099, 0.778624488497865, 9.999999999998899e-05, 0.07647101224052644, 0.07545925132111009, 9.999999999998899e-05, 0.19229127545825764, 0.5893683566258894, 0.5590077804725314, 0.6312065297215785, 9.999999999998899e-05, 0.12310654408969313, 0.13919141448979755, 0.1628455170077424, 0.13344926963371095, 0.1578516290521227, 0.11401142815472864, 0.1412870492060685, 0.10760234676647773, 0.14574058022583125, 0.12219137002907499, 0.10083057667543183, 0.09492893039204231, 0.1011425368840253, 0.12475366965692936, 0.10024092884645375, 0.13421948535400574, 0.1316030373594489, 0.11676125363758638, 0.9531170384726338, 0.9627042583116621, 0.9635862126085787, 0.9614259766671018, 0.9718452922903615, 0.9422083264263288, 0.9684928815544936, 0.9623367120759616, 0.9721765270252677, 0.4607263513727521, 0.40556567622126005, 0.4404243628979554, 0.44991984548745156, 0.4181543246831657, 0.4354852739983479, 0.4582134312142958, 0.5002793928148224, 0.46689645236928123, 0.35264656487206136, 0.222635170532121, 0.42138563152340935, 0.21307385914892507, 0.20368267997164435, 0.2004705919876787, 0.22569909632415386, 0.3333201711674548, 0.22449008763311995, 0.34268823481951827, 0.09827850283189132, 0.1963317275321893, 0.12431758748918276, 0.12191460913532648, 0.12295081565102717, 0.14384659685077783, 0.15919216241251066, 0.30134975141079523, 0.14580698966487549, 0.1197313657699095, 0.20574893879528833, 0.16839848026512205, 0.13911132701980566, 0.15492628029834554, 0.20219998999728084, 0.19341577745023564, 0.15291030659194238, 0.00016886351514189268, 9.999999999998899e-05, 0.03331304648723521, 0.02666296443600802, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.042806230074459606, 0.08403948225949098, 0.048333136521505726, 0.0722857931016504, 0.07691716332588128, 0.05425857850765081, 0.015518204387384271, 0.06380625880649804, 0.051946355954086365, 0.04317985912741673, 0.04763983922469939, 0.030387703607501093, 0.14883394833009678, 0.07250306570578469, 0.08122751002635609, 0.07196929933913687, 0.08495719690126169, 0.15902402611827815, 0.12645152644384083, 0.1748333667596147, 0.040920458505124935, 0.14317143303184188, 0.14631789548722207, 0.1541836987097993, 0.14005758100219956, 0.1878083657836218, 0.16917226750659609, 0.08189757946081866, 0.5212834512697648, 0.4714326173979161, 0.5252813813760608, 0.521763176587646, 0.5930814958501729, 0.5582178344497477, 0.5407372199119368, 0.5194668834259999, 0.4929929720711286, 0.09085927911489522, 0.09086830696632864, 0.06918707794886536, 0.10494646695299781, 0.09741474371710224, 0.09906842668890459, 0.14022648027882734, 0.08502094793163084, 0.12957648258723198, 0.17824266463050176, 0.13771297792212123, 0.15964008609659652, 0.15753394525313946, 0.2050140676238642, 0.14436719442541235, 0.23425407104729867, 0.17563062089783799, 0.176629659909588, 0.43675782507125727, 0.4036256442156796, 0.2859944999538674, 0.44633997492934296, 0.3798620690004625, 0.33204891676543524, 0.33738790667739005, 0.3699156976811636, 0.46288695582389205, 0.34822268957606606, 0.33054807762818617, 0.2334454317382283, 0.1985951287205271, 0.2288375677886778, 0.23512512538069663, 0.19965159443835778, 0.26153670582783506, 0.24595820098213406, 0.1993163692690496, 0.1999847694534702, 0.19345768767873384, 0.19860428328067792, 0.21245343477411316, 0.1868222168315532, 0.20553504264498557, 0.18858007208288485, 0.1929488763511098, 0.21790536387535486, 0.18427095840059926, 0.1893739134758916, 0.23508592044067578, 0.18676859178598781, 0.19634468803963878, 0.1938439640839814, 0.19091632689626736, 0.21810566542679888, 0.8010144401996762, 0.16076749636696497, 0.1517550587581019, 0.8469635355720998, 0.19790837567943087, 0.1968222084669845, 0.14121001387110532, 0.16839903875263296, 0.16194552057164235, 0.488157623165277, 0.2084651710990929, 0.38613494542282667, 0.20640754702837416, 0.22244252018202038, 0.4659030500332244, 0.10482237070144274, 0.20876667698943574, 0.2831331072739578, 0.18151552805295823, 0.17708522190996323, 0.19525048692369273, 0.18573736073071434, 0.18891601146299064, 0.18314338682013853, 0.18296298528849142, 0.1850329034829309, 0.19175808764206215, 0.08876775714298202, 0.07361591387453992, 0.08171873552036013, 0.06865524798563838, 0.08415947573803628, 0.07751251739205312, 0.08303335607144946, 0.07065838801967184, 0.07172131340496812]}, "mutation_prompt": null}
{"id": "ea6c4ee4-c39d-4495-81e4-660055a47b11", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "2bdd4287-eb8a-480e-89ba-51f58e5b612f", "solution": "import numpy as np\n\nclass ParallelQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.init_pop_size = 10 * dim\n        self.max_iter = budget // self.init_pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.7  # Adjusted crossover probability\n        self.w_base = 0.3  # Adjusted inertia weight for PSO\n        self.c1 = 1.8  # Enhanced personal attraction\n        self.c2 = 1.5  # Enhanced global attraction\n        self.F_decay = 0.9  # Decay factor for differential weight\n        self.CR_growth = 1.1  # Growth factor for crossover probability\n        self.pop_size_reduction = 0.9  # Reduction factor for population size\n\n    def __call__(self, func):\n        pop_size = self.init_pop_size\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = pop_size\n\n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(pop_size):\n                indices = np.random.choice(pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            if eval_count >= self.budget:\n                break\n\n            r1, r2 = np.random.rand(pop_size, self.dim), np.random.rand(pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            pop_size = int(self.pop_size_reduction * pop_size)\n            pop = pop[:pop_size]\n            velocity = velocity[:pop_size]\n            fitness = fitness[:pop_size]\n            personal_best = personal_best[:pop_size]\n            personal_best_fitness = personal_best_fitness[:pop_size]\n\n        return global_best", "name": "ParallelQuantumCooperativeOptimizer", "description": "Parallel Quantum-Cooperative Strategy integrating dynamic population sizing with adaptive DE-PSO elements for enhanced convergence efficiency.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {}, "mutation_prompt": null}
{"id": "5b591d61-0b01-42e6-9d93-45ba73687229", "solution": "import numpy as np\n\nclass GaussianQuantumOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.7  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Adjusted growth factor for crossover probability\n        self.perturbation_stddev = 0.1  # Standard deviation for Gaussian perturbation\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2)\n                perturbed_mutant = mutant + np.random.normal(0, self.perturbation_stddev, self.dim)\n                perturbed_mutant = np.clip(perturbed_mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, perturbed_mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "GaussianQuantumOptimizer", "description": "Hybrid Adaptive Algorithm integrating Gaussian Perturbation and Quantum-inspired Differential Evolution for improved search diversity.", "configspace": "", "generation": 84, "fitness": 0.29436782499511577, "feedback": "The algorithm GaussianQuantumOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8026041489958065, 0.7922767302656671, 0.7992413798042945, 0.8012127098792365, 0.7896798298474347, 0.7973811799262204, 0.8106726307424261, 0.8150358664575609, 0.8086765136933165, 0.558692544392971, 0.600036515634398, 0.032117294813521546, 0.4053168925099896, 0.5919724312220677, 0.6085010072156132, 0.42871584009840746, 0.6194491668902964, 0.5423113520315649, 0.1223185651215073, 0.1329752471718222, 0.11417131421822269, 0.12580410334501413, 0.11650809940242157, 0.13070386221027508, 0.13839372972357344, 0.1486005091733017, 0.1632125344548393, 0.13732033786379594, 0.11992095157039218, 0.09991861837704696, 0.09323931493261772, 0.1367600050454294, 0.10856759575702402, 0.08017127688112324, 0.14784758256898078, 0.10536731088190476, 0.9551567836438741, 0.9660700630638397, 0.9541619296821046, 0.966374390561484, 0.9551868509844972, 0.9535307482681216, 0.9546266381397566, 0.9669618048726548, 0.9658794144516104, 0.4678583637182929, 0.4746727511949195, 0.43262000123626354, 0.4792633877583925, 0.43159211104390505, 0.48666467574633876, 0.40199843642872524, 0.4155304259607231, 0.4368309857238223, 0.21167672331061071, 0.22113163132041158, 0.20994887424577924, 0.8371060015376536, 0.20582040547373148, 0.20846555465879402, 0.17320039326721048, 0.4672000711220218, 0.22633484909642043, 0.18352556521581942, 0.17553323643219187, 0.180556439010515, 0.1289168968803064, 0.18282636998733892, 0.18637763336325375, 0.18340936041769895, 0.12808556564352325, 0.18240037766645478, 0.20395203085460667, 0.21016292079632637, 0.18658879448144994, 0.12969554842166942, 0.21095598611290245, 0.12387079381090627, 0.1850722011059559, 0.19722337118861766, 0.20260850033441669, 0.04398059110700958, 0.05335320871221849, 9.999999999998899e-05, 0.028442695681184182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003728845153416649, 0.0033208550870518216, 0.08200264572259452, 0.04369230439214411, 0.05936733154804097, 0.09303492918368605, 0.02333599686418497, 0.046198988664109986, 0.10373934859096223, 0.10202631758651881, 0.07631936971190789, 0.05425800549375981, 0.24164342844136688, 0.06596378922028068, 0.06886043334879322, 0.13562550528635908, 0.08420404012335292, 0.2341085274673853, 0.06483295828952285, 0.08673467426552994, 0.08971078487074424, 0.04585323879826497, 0.40188366603087733, 0.16920117795194256, 0.04678109069202385, 0.13258880907526105, 0.08220284684510115, 0.18354756030323405, 0.1513353320766797, 0.5272518583625818, 0.527309249960434, 0.5004142838889483, 0.5124897784685387, 0.5141537461592338, 0.5301894467549233, 0.5348401794837527, 0.48064981524944816, 0.5254890876394251, 0.13238787193130297, 0.12936850949212586, 0.12230886717700418, 0.10160835139161428, 0.12911407786728035, 0.12642557191139292, 0.11547097236111281, 0.11323784832707295, 0.12419418297863849, 0.18448444506814976, 0.32759821848609516, 0.1865580125869436, 0.14056842189813035, 0.34163741681900306, 0.2299652128316264, 0.44406134597511193, 0.19422731399004278, 0.30002862421592336, 0.35664489900434926, 0.24473921289944256, 0.5253164114691886, 0.38378223580506243, 0.2244820126115552, 0.4648612910210077, 0.4923659135502282, 0.4949090516797304, 0.37621649309276495, 0.2455327434444894, 0.28182642073774566, 0.2493487501662408, 0.20496094025139167, 0.27475814451885094, 0.24191265006491502, 0.25318138829935544, 0.25159358426716727, 0.27673258029583225, 0.2316692136031191, 0.2081159326664791, 0.19944433150561813, 0.22032032262589374, 0.21313347789453652, 0.2200326171942727, 0.2023060098843109, 0.19526912341652003, 0.21470796142617932, 0.21321473610966268, 0.2041417394576085, 0.19345770460569622, 0.24247235913399867, 0.2405731601774842, 0.2382018527872073, 0.18383775321862117, 0.19763116460619967, 0.20304005632622402, 0.8761711340526364, 0.16577864531500797, 0.15203567754164538, 0.861179327441296, 0.19940156504800932, 0.17821160972930172, 0.14224057416992253, 0.16158011988450982, 0.8238167230335276, 0.6240993440103918, 0.21059368655709754, 0.7093713533169392, 0.6491129456161553, 0.5203075027026798, 0.1525133913598754, 0.7065617170815889, 0.5759509734268574, 0.08225873988537657, 0.18078329618669575, 0.18443946682224255, 0.20030623398244263, 0.1996496835303999, 0.18475800801898956, 0.21507815611532455, 0.18527308314327318, 0.1763757394168104, 0.17851261959900044, 0.0989145244700721, 0.09267087373926985, 0.09138623446538263, 0.08837589054043204, 0.07999395814125054, 0.07889096002626372, 0.09642477660526261, 0.08143404940201049, 0.08263051553074818]}, "mutation_prompt": null}
{"id": "279f0fe0-8e79-45c1-9f08-3ec7bcb09448", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.9  # Increased global attraction coefficient\n        self.F_decay = 0.92  # Modified decay factor for differential weight\n        self.CR_growth = 1.03  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.zeros((self.pop_size, self.dim))  # Start with zero velocity\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.3 + 0.7 * (1 - (t / self.max_iter)))  # Dynamic inertia weight\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedStochasticHybridOptimizer", "description": "Enhanced Stochastic Hybrid Optimizer combining Quantum-Inspired Differential Evolution with Adaptive Momentum Particle Swarm for versatile convergence.", "configspace": "", "generation": 85, "fitness": 0.26141607004524303, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7657921341449022, 0.7649508116082988, 0.7893501475350369, 0.7742254563338462, 0.3077193675659339, 0.7677663960370953, 0.7899121528201687, 0.7728917770622706, 0.7478297473625437, 0.5636993341790204, 0.03675288888859196, 0.0024172904700906495, 0.5931757261940138, 0.5699771200994689, 0.5620360956945929, 0.5162948180466425, 0.5730782944962263, 9.999999999998899e-05, 0.12884076205626227, 0.13455156102402088, 0.12076402555295462, 0.14258945510646792, 0.09611073089413114, 0.1344660212009552, 0.1319272721594822, 0.1245108921534891, 0.05188044265672065, 0.11623373674627124, 0.11240483702971393, 0.10048897907701304, 0.0969872522438181, 0.14155194000199023, 0.12074517609098079, 0.11992638902748676, 0.14565397691232507, 0.10146152809839493, 0.975939306595696, 0.966977720451881, 0.9660444752076565, 0.9771182957451138, 0.9766544880320149, 0.9720252438267022, 0.9782342430817844, 0.9931823398500992, 0.9772719696278988, 0.46551998945247863, 0.4295612355501055, 0.43698641265527116, 0.3975334424777093, 0.47777338329858243, 0.14522011436221405, 0.08773785075837182, 0.08792417757432724, 0.41996183423328814, 0.7233794842283584, 0.22384548362117151, 0.3268386470382848, 0.1931893412021375, 0.2674355065220363, 0.19819365000272005, 0.12449177268618727, 0.33526042982395476, 0.3551826069124474, 0.5581573005313113, 0.11848920442167599, 0.1434130355152372, 0.11272642517547016, 0.1246292601794885, 0.12118237442781665, 0.17386840127715364, 0.20582834566856312, 0.1893957102923206, 0.18417895861832567, 0.18418077212606765, 0.09844563737185708, 0.1685291168513986, 0.13713858137270474, 0.12338243739905064, 0.19804001407108784, 0.12800799059176138, 0.16591585220867433, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013562444244451521, 0.013235481517112402, 0.011272600505451535, 0.038712011688850745, 0.0481591937241197, 0.06856203154472629, 0.022952784410527283, 0.0321232882443897, 0.07478846649636472, 0.06505807683942344, 0.06490913915656771, 0.10846589983119304, 0.046518639554079866, 0.018635984844258546, 0.04211201141647092, 0.030252003057149146, 0.027405939899642018, 0.12464128330728874, 0.07821850125095953, 0.06624172708260412, 0.0821706565764816, 0.15626077255221593, 0.060936754489487654, 0.158471226960208, 0.040129559595195485, 0.014926429606148539, 0.005874971855451827, 0.06172765854652684, 0.12758543343971618, 0.07525711620264519, 0.05331588771345941, 0.07868982952166537, 0.49701135670613017, 0.4994263461483597, 0.5010298587593744, 0.4871154880523658, 0.4978179792040792, 0.5148728592465049, 0.5225576702101113, 0.5418020387249107, 0.5519061621666264, 0.08016845796046457, 0.06847053615695509, 0.0952782460367605, 0.13263882931687598, 0.11685091054175467, 0.1014507375988265, 0.12966117336231786, 0.06989356060846352, 0.13620081084470237, 0.1495660277646852, 0.18258302836688067, 0.2831390399196767, 0.1793087383469827, 0.20550039067390402, 0.17465201130743568, 0.19155687523811316, 0.19979983449962213, 0.17823715466256362, 0.3819120777099322, 0.3868908072810867, 0.31845625121971466, 0.23147712280569943, 0.3491818866061398, 0.44467916479910996, 0.272416766908844, 0.42644827944445274, 0.39253885354189666, 0.13169528033805677, 0.22146512972781907, 0.29127143600657524, 0.27337854891279234, 0.1828825051197146, 0.2617304248546638, 0.3403573411449593, 0.26358854465162873, 0.1776266369379058, 0.18532547663903254, 0.16109695822417802, 0.19170358231354634, 0.19250132662064756, 0.1977766373602965, 0.19151248704826918, 0.2072269523471143, 0.206305524293109, 0.24867027225264182, 0.20186308579084056, 0.18339473385903904, 0.2135523433821107, 0.19811658703740964, 0.20786131386424567, 0.240170365337514, 0.23414758984328, 0.1975616185722967, 0.182804478666727, 0.710610590149826, 0.1659109804691603, 0.16410941488799147, 0.8207263472282833, 0.19821760990893467, 0.7613252842834726, 0.17627700303066174, 0.6884161764585579, 0.16375880614214433, 0.658271761443124, 0.20629186120997234, 0.20470398752955465, 0.42656057970639294, 0.20849172769901814, 0.1459779134660656, 0.15553622850157556, 0.20137141697689376, 0.19553900706043592, 0.18329666993552762, 0.17587971316667084, 0.1760059460501634, 0.19584671652124785, 0.19115140522992913, 0.1745784255877012, 0.17081861597550085, 0.17795575449114331, 0.19738981798449018, 0.0742531784890742, 0.08082552134706888, 0.07500074694761794, 0.0822865582284501, 0.08316732029912, 0.08584710565873943, 0.09239199553846178, 0.08163569849981722, 0.10393372443645044]}, "mutation_prompt": null}
{"id": "13d2cedd-5150-436a-991e-b1057125f581", "solution": "import numpy as np\n\nclass MultiStrategyQuantumSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Modified personal attraction coefficient\n        self.c2 = 1.5  # Modified global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "MultiStrategyQuantumSwarmOptimizer", "description": "Multi-Strategy Quantum Swarm Optimizer combining adaptive Differential Evolution and enhanced Particle Swarm components for versatile exploration and exploitation.", "configspace": "", "generation": 86, "fitness": 0.2810932507974691, "feedback": "The algorithm MultiStrategyQuantumSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.787352806899327, 0.7783188576986293, 0.7931897098283308, 0.778762223178003, 0.7806902936350166, 0.7829846354843712, 0.7750245371616241, 0.7953848261954574, 0.7763368947408127, 9.999999999998899e-05, 0.5823512176010733, 0.07917306545532521, 0.04437128539980728, 0.06089321097115041, 0.5569994486346648, 0.0671585357809481, 0.5288432522254669, 0.04702726067403751, 0.1390198636264125, 0.16952215449057972, 0.13101345207206028, 0.16043641405647013, 0.10410578155310324, 0.12591157859382496, 0.13179390909280098, 0.14676084458157912, 0.14402551495900917, 0.11759573472640572, 0.099839575152332, 0.08906207623761364, 0.0989037765361831, 0.10456048978594534, 0.11034379544702844, 0.12363785163950125, 0.10586528710925502, 0.13935615021771997, 0.9437317951784221, 0.9592406296372654, 0.9719116081434733, 0.9720248175653947, 0.9486728553664862, 0.9449317999980987, 0.9625293281502296, 0.9761909782204444, 0.9668832878983016, 0.5226588413013338, 0.47644388512329816, 0.5327345738655329, 0.5168450097687731, 0.48074659014238086, 0.5007794903714218, 0.5115514817109879, 0.4122566468380833, 0.5108604502921534, 0.21866666250251732, 0.2219127686640998, 0.22265653320127865, 0.20772474488722292, 0.2082464459134834, 0.7707490905987184, 0.7684929460901371, 0.7413504455697164, 0.7207920576731801, 0.11651313481639414, 0.2538622912569214, 0.20086692719515686, 0.12102558623929582, 0.1533865616127127, 0.12823710706847635, 0.1734994797495094, 0.15907891998103973, 0.15762588850159376, 0.18397946713639624, 0.16686633271346896, 0.11454937464787018, 0.1253993433016456, 0.14136392496988737, 0.11131375680590627, 0.1539792780299053, 0.1489881916749649, 0.10769425152715306, 9.999999999998899e-05, 0.003604336706014344, 0.00246062277124659, 0.04033006565744579, 0.04418397118171835, 9.999999999998899e-05, 0.021909156847090938, 9.999999999998899e-05, 9.999999999998899e-05, 0.049540239083962656, 0.09154288529715049, 0.05915099922568057, 0.07258563065944146, 0.057483682012700044, 0.03160667277339635, 0.060727791017340715, 0.08682927509232508, 0.11150150110085888, 0.02981671528706642, 0.031239240535330448, 0.14863606986094668, 0.09438640269786935, 0.08360648680475302, 0.06405643799571914, 0.08665669706975221, 0.1897040930699493, 0.05899719108203283, 0.08169890876104668, 0.040016074622907905, 0.15076840062006247, 0.19395545572639417, 0.06681279157160369, 0.13378361217936785, 0.10031762807207267, 0.05388077070920749, 0.1664490399652968, 0.5209301438568001, 0.5177459919156034, 0.538687982316457, 0.52032926917543, 0.5246087029191981, 0.5303897113647043, 0.5513183732202462, 0.5280933499224496, 0.5403001159210368, 0.13340389741328196, 0.1109447182380533, 0.09341390547243467, 0.10570090507512486, 0.10373638616381864, 0.12043358683559602, 0.1393544509379312, 0.06194399440264009, 0.10817650516407595, 0.15038354063616732, 0.19585411130569252, 0.1975918535862653, 0.2119286685950147, 0.1743080030122981, 0.2045151088163767, 0.2050242435642733, 0.1657752536165401, 0.25728368374812893, 0.389506990767194, 0.32688372424805257, 0.3142009502519526, 0.45021584165386797, 0.3568206167370225, 0.41845603060615577, 0.21439679824433, 0.42962621131708933, 0.4539643955226721, 0.16892232475453728, 0.23372465583844104, 0.31864202851392187, 0.2924992072262873, 0.262085947276507, 0.2892997148137534, 0.2573118986879852, 0.3524406244435345, 0.19803256610459707, 0.27797459400936764, 0.21732608463790626, 0.20925661756198277, 0.21890518557658012, 0.17612567807084656, 0.15090802937457537, 0.20257194814642276, 0.2012425289431281, 0.204036709299649, 0.1860046374324199, 0.2045559020351584, 0.5150899258056713, 0.21410582782391452, 0.21589802611814712, 0.18259613524069418, 0.21380774849542084, 0.20686942140564957, 0.21112276435512445, 0.16970925589697783, 0.18321451212876472, 0.7190661707080874, 0.8265037548207572, 0.19935291841196612, 0.8569012599528476, 0.806169438210862, 0.8079307827615457, 0.17063649353932064, 0.7011421069888604, 0.20871864153609498, 0.1264616976394729, 0.20634586657668408, 0.11245754663991392, 0.15118181894002047, 0.10406515323862497, 0.2065177075332223, 0.7137156897356682, 0.18942102767869606, 0.17531985969027497, 0.204563475923917, 0.20052460641990488, 0.18362156496916382, 0.17378337016430856, 0.1986391617625014, 0.181588013845715, 0.18323364073220616, 0.09634878627206822, 0.08951931296882298, 0.09183739060136087, 0.0854078483121612, 0.089633917463521, 0.09332132413979921, 0.0931495670657907, 0.0822812351922263, 0.11108176585464369]}, "mutation_prompt": null}
{"id": "f21c2a6d-8f60-4046-b857-1e67da74a753", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "27ea506f-39f2-42ff-81cd-dedf1b53d5f8", "solution": "import numpy as np\n\nclass QuantumHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7\n        self.CR_base = 0.9\n        self.w_base = 0.5\n        self.c1 = 1.5\n        self.c2 = 2.0\n        self.memory_size = 5\n        self.memory = []\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base\n            CR = self.CR_base\n            w = self.w_base\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n                            self.memory.append(global_best)\n                            if len(self.memory) > self.memory_size:\n                                self.memory.pop(0)\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n                self.memory.append(global_best)\n                if len(self.memory) > self.memory_size:\n                    self.memory.pop(0)\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumHybridOptimizer", "description": "Quantum-Inspired Hybrid Differential Evolution and Swarm Optimization with Adaptive Memory for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 88, "fitness": 0.2422696732626671, "feedback": "The algorithm QuantumHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7081452586248244, 0.7083422725881346, 0.6920245416091222, 0.6872251243463076, 0.6682835302712906, 0.714852733639994, 0.6113266791310001, 0.7020636967274357, 0.7038099145108934, 9.999999999998899e-05, 0.034761037240603754, 0.35083863985523356, 0.3610113411872712, 0.3686936246888127, 0.36532249841034536, 0.3805562530362542, 0.26706210892194726, 0.369507178415306, 0.12382037607212837, 0.11898570408557374, 0.14990670977347087, 0.1192238588613651, 0.10504536133217646, 0.13587416501356964, 0.09518679532820529, 0.10107473432308378, 0.2386787032617016, 0.09416411953138026, 0.08204681844046868, 0.10552599923348138, 0.0984595892707939, 0.09932300258237925, 0.08659600941283208, 0.09732935967440204, 0.09169761470256288, 0.09288094804870384, 0.9700336148888989, 0.9315684530931255, 0.9578415304169089, 0.97123521939758, 0.9471843159931128, 0.9576075303091054, 0.9767969970480747, 0.9699375648494185, 0.9582248798503004, 0.2713863718070946, 0.21880544628098963, 0.2670650917244396, 0.33492717409955053, 0.2298625562426363, 0.19872484023602388, 0.2468113909567181, 0.2151453041083623, 0.2922145988795315, 0.6551047586992986, 0.22166776406570543, 0.2393361571937347, 0.26992145115687605, 0.18701084078907826, 0.18594996661338958, 0.239679875592531, 0.2738391073810271, 0.2607767164153767, 0.22501907879236027, 0.1625114213787634, 0.128161552006137, 0.22908150531593274, 0.18263322672194082, 0.14790370543163822, 0.17128410146616058, 0.14914497767930002, 0.18829487012979296, 0.1439319760790564, 0.14646770761100325, 0.13997320452393547, 0.1934422263814306, 0.17114947934555858, 0.1824230046971661, 0.1915229268028028, 0.19413065579566047, 0.1911343302993158, 0.005500554428798599, 0.0005128896683525008, 9.999999999998899e-05, 0.0399286451147014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005550657783844337, 0.07307498607220952, 0.027794859419768225, 0.0915558843716282, 0.07065545231055259, 0.08949399983966, 0.04149004674315748, 0.048050467489189064, 0.04416477253392426, 0.03526865675215163, 0.10213399455922023, 0.02467369331081104, 0.08400197198167203, 0.0803208032631394, 0.05870331667167561, 0.0672935725490954, 0.055033061038416986, 0.07769674815872418, 0.06661821764769882, 0.22180278990089808, 0.12985420224883182, 0.06723361774098702, 0.1781352195578012, 0.07553368173837849, 0.11310360632198313, 0.20415723154970888, 0.07581030783902165, 0.20499625190403314, 0.4998897091103892, 0.47625614982141173, 0.4712994034224506, 0.5152947083324297, 0.48032365981088154, 0.4776002096645381, 0.42814500806302347, 0.46866744737612487, 0.507482358233182, 0.08043156253760686, 0.07460558820320329, 0.1103063083712017, 0.07787217578267613, 0.08577766449672652, 0.10822761098642475, 0.09301025785075212, 0.08272930472983753, 0.11764266019308833, 0.157436633937584, 0.13956232443490513, 0.16339718596583952, 0.14131845531701215, 0.15513600891294266, 0.19031109622441178, 0.17750598443098475, 0.12433581638434932, 0.185854198763863, 0.29062623529771003, 0.2678666888722162, 0.33365999720074746, 0.3395959954149067, 0.3362868310750976, 0.33375690345675857, 0.3581717893520865, 0.2700916720252653, 0.2648020969400897, 0.22173376281988744, 0.18637884259395687, 0.24586721613028029, 0.18840033207953455, 0.23627582290070503, 0.266175617468444, 0.23393070332835508, 0.22692988539694403, 0.1844467175832052, 0.19621838568040306, 0.18297863682136228, 0.1854069355099165, 0.17945675108254056, 0.19101031917625244, 0.18431764128698158, 0.20397956969471998, 0.1738591472671578, 0.19817912873879773, 0.1951356103262133, 0.2094916225214294, 0.19621644845179176, 0.23650285898903656, 0.1981330892820664, 0.18349071373943093, 0.18918051932474222, 0.2063167761486484, 0.19387275492372302, 0.19667059549947175, 0.6853021827523128, 0.16874440461721407, 0.7563501205154757, 0.19720613437657808, 0.15690409043769182, 0.17093585758584173, 0.1600075971746583, 0.7434465772984866, 0.4903599806742943, 0.2081968323848239, 0.20360038208639986, 0.12658527073904402, 0.2058014691822806, 0.14897542256829366, 0.10314839804849907, 0.20360675811201012, 0.4390151992136758, 0.18236646480525787, 0.16891472190465762, 0.17498149110610994, 0.18296079394842724, 0.17221550813002973, 0.18068354000813092, 0.18883125981335924, 0.1946776914427676, 0.19724939869737823, 0.09251598422113916, 0.061569277028984515, 0.07282849969499183, 0.08062236536876044, 0.07517868893573287, 0.06924820732806058, 0.07150370927949878, 0.07828055360449238, 0.064340554682085]}, "mutation_prompt": null}
{"id": "c3d0242a-1e78-4b32-ab79-afaccddabf2b", "solution": "import numpy as np\n\nclass HybridAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.85  # Adjusted crossover probability\n        self.w_base = 0.3  # Adjusted inertia weight for PSO\n        self.c1 = 1.5  # Modified personal attraction coefficient\n        self.c2 = 1.5  # Modified global attraction coefficient\n        self.F_decay = 0.9  # Optimized decay factor for differential weight\n        self.CR_growth = 1.03  # Reduced growth factor for crossover probability\n\n    def __call__(self, func):\n        current_lower_bound = self.lower_bound\n        current_upper_bound = self.upper_bound\n        pop = np.random.uniform(current_lower_bound, current_upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, current_lower_bound, current_upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, current_lower_bound, current_upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            # Dynamic shrinking bounds\n            bound_shrink_factor = (1 - t / self.max_iter) * 0.5\n            current_lower_bound = global_best - bound_shrink_factor * (self.upper_bound - self.lower_bound)\n            current_upper_bound = global_best + bound_shrink_factor * (self.upper_bound - self.lower_bound)\n            current_lower_bound = np.clip(current_lower_bound, self.lower_bound, global_best)\n            current_upper_bound = np.clip(current_upper_bound, global_best, self.upper_bound)\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "HybridAdaptiveOptimizer", "description": "Hybrid Adaptive Algorithm combining Quantum-inspired Differential Evolution, Particle Swarm Optimization, and Dynamic Search Space Shrinking for enhanced exploitation and exploration balance.", "configspace": "", "generation": 89, "fitness": 0.25700428995986974, "feedback": "The algorithm HybridAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.25.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8877612799204433, 0.880921018247279, 0.8814623138082485, 0.8659832412728101, 0.883951607635716, 0.8754085831917551, 0.8799806757541767, 0.8866204002172946, 0.8789670513408392, 0.08782704650218531, 9.999999999998899e-05, 0.31656166811300723, 0.19787193419846405, 0.08408558994842497, 9.999999999998899e-05, 0.06698727058404019, 0.09821817840021685, 9.999999999998899e-05, 0.10748375912033625, 0.08425252950416273, 0.12140132910373502, 0.1460932486055626, 0.1365180594675245, 0.09051187339695022, 0.13287985799436808, 0.11619070324499625, 0.1749736150402903, 0.15811239550115874, 0.098221361812599, 0.10631041432932076, 0.1423177439942428, 0.11877786589994743, 0.11969442544967801, 0.12923694821513854, 0.0903692562206061, 0.0895080120364482, 0.9520988378689246, 0.9541989209842251, 0.9341561922975796, 0.9545805551897014, 0.9657342864151126, 0.11806601431798913, 0.9660402976475101, 0.9446049429262154, 0.9652406224052822, 0.744846196617045, 0.08816342443951108, 0.056986027922379834, 0.6572140796649947, 0.6750458245178379, 0.29832211648556717, 0.04907260236537536, 0.13178895955167136, 0.1469423460027932, 0.22787054228852555, 0.22812434115979652, 0.3906541614120361, 0.21275896950668605, 0.211004278665623, 0.37721647654655943, 0.3955598731877493, 0.1757001168162995, 0.16720107529789818, 0.1303120879327605, 0.15264272509856924, 9.999999999998899e-05, 9.999999999998899e-05, 0.1392554726539904, 0.13774316796086294, 0.15977853059921432, 0.14733571373482812, 0.16706528805518972, 0.17436402590181754, 0.13942521196101954, 9.999999999998899e-05, 0.1261435032421825, 0.18062064646252252, 0.19900974809313265, 0.209254955955271, 9.999999999998899e-05, 0.14609706761109043, 0.07389145975980027, 0.038001278454333765, 9.999999999998899e-05, 9.999999999998899e-05, 0.015760155009653998, 9.999999999998899e-05, 9.999999999998899e-05, 0.09592547102364446, 0.034155341338568124, 0.09418440779244919, 0.1454488827179099, 0.06663273048975094, 0.07508282458894633, 0.013021866339073873, 0.06005551669184406, 0.08855232325878182, 0.11281538024856053, 0.18043933001860202, 0.09441075390673126, 0.06793204253844742, 0.07340225682961266, 0.10175460318532681, 0.0928581656341968, 0.0952486081264986, 0.2390543861379596, 0.1563629487128454, 0.2045001780543434, 0.13840885983899787, 0.17051654511555858, 0.15180646252872176, 0.09547943114941915, 0.04059230250316992, 0.16822424865584595, 0.08302080874760809, 0.0865809442103529, 0.09962413573127182, 0.5917386532850011, 0.5099245723666146, 0.49330848716144093, 0.5076707444319601, 0.5333885540731134, 0.5820487680424151, 0.5416213816176378, 0.48702898972861375, 0.5095868768066796, 0.11558923554832201, 0.10145500062424051, 0.08543909374596537, 0.13481422725814396, 0.17971796074964919, 0.15319984777749507, 0.10446290283941284, 0.14473636830553027, 0.1076187386099633, 0.20560145624664772, 0.32983345691156996, 0.20996556096598584, 0.31827639661807006, 0.46995580707072426, 0.2648559794521078, 0.3891413306513818, 0.27731781621506035, 0.2115005922224752, 0.3499352442346475, 0.3530861161931267, 0.3505044203807173, 0.4011295442235867, 0.32343116971100916, 0.29421644185057216, 0.28339809592278964, 0.37077833155781315, 0.2342850103328742, 0.22621964530405847, 0.27112129408609154, 0.18801556198424796, 0.2512062633285711, 0.24025955218426764, 0.48785227471435, 0.23272611119995712, 0.24287991112490614, 0.19331728691159333, 0.22909289623539952, 0.19103211838513323, 0.2188212242118398, 0.2263844757578467, 0.20795388078067512, 0.2203546916197997, 0.19912666981458793, 0.21508532847995854, 0.18628277775587299, 0.2091240252544162, 0.20136704623628143, 0.1934655439436873, 0.22488978915745506, 0.2284679847073885, 0.18672735007175556, 0.18340563222588058, 0.20862243558769755, 0.20592939508437846, 0.14593789898107368, 0.16664760106877108, 0.14719239724650524, 0.9217164599234551, 0.2004954038183442, 0.12631126893057443, 0.17765225397897155, 0.16033051708487345, 0.9099374736966919, 0.41381250147211635, 0.21178164546386302, 0.209502286745479, 0.622465519816112, 0.8716041047720955, 0.1686704817774204, 0.10417404724157264, 0.283569085150845, 0.2081248338752575, 0.19194833700413683, 0.18420486702349104, 0.1996821768319874, 0.18880179289844845, 0.1839143444193828, 0.17684028916554595, 0.20226063731975608, 0.20758868038755374, 0.1877722297677511, 0.10191283352750646, 0.07771711721782615, 0.0819662020642703, 0.07193444709272989, 0.07674126398681635, 0.09752177232106185, 0.08431408499860249, 0.08821382019778246, 0.0808254790076095]}, "mutation_prompt": null}
{"id": "f45d06e6-5eeb-4061-bd20-9543954a393b", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Enhanced differential weight\n        self.CR_base = 0.7  # Enhanced crossover probability\n        self.w_base = 0.5  # Adaptive inertia weight for PSO\n        self.c1 = 1.4  # Balanced personal attraction coefficient\n        self.c2 = 1.6  # Enhanced global attraction coefficient\n        self.F_decay = 0.9  # Enhanced decay factor for differential weight\n        self.CR_growth = 1.02  # Growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.6 + 0.4 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Quantum-Cooperative Strategy blending Adaptive Inertia, Crossover Dynamics, and Particle Swarm Elements for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 90, "fitness": 0.2821391246507499, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.26.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8432423602451029, 0.8440668287920181, 0.8307651392380238, 0.8455011922065161, 0.8457585857136063, 0.8307886809392064, 0.8324103403544045, 0.83219816249788, 0.8345764299168965, 0.0498602559955903, 0.6518262984360175, 0.6940391088082292, 0.6662526716329851, 0.048600460450118455, 0.6909663659451694, 0.6753988040063197, 0.05664585226623442, 0.6770824893045703, 0.12094821812768985, 0.13676434257953585, 0.10817469730446971, 0.1056452402031629, 0.10544582703258498, 0.08619888786763474, 0.09103030389674494, 0.1259617507626204, 0.15232010651187688, 0.11658146333175878, 0.10301242615254946, 0.11737520524558587, 0.0983512062506301, 0.12740988209656257, 0.1027517621915115, 0.10328164433516862, 0.0921573761211334, 0.14192771030864237, 0.9730547232855918, 0.9804695287324026, 0.9719181282911955, 0.9726020760431547, 0.9814051842419539, 0.9744202009587544, 0.9733013649892933, 0.9791290498585739, 0.9736547591311764, 0.6257643176873537, 0.6263280647441234, 0.6117146269775207, 0.14822568322013197, 0.6062768021557126, 0.4903820396327746, 0.5396100606810569, 0.6108568443416238, 0.6255538230612638, 0.7694804647905669, 0.3667136030067484, 0.22333190545307002, 0.280396802010744, 0.2710544033508845, 0.15915973928811, 0.22783901993620936, 0.22271960960942616, 0.2287485676608355, 0.1853767526592479, 0.12836185984655457, 0.1728993740632363, 0.1106747765967091, 0.12685805004982342, 0.1275829453215307, 0.15966474355110982, 0.3429045865942738, 0.12648448066008555, 0.06578544100479389, 0.16617163225399978, 0.19786289452558015, 0.26710149998996324, 0.1870417145818467, 0.3104657625889249, 0.17378567031558445, 0.134532540881669, 0.10851671314878164, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04939857865191932, 0.007575731665133256, 9.999999999998899e-05, 0.02751975867511225, 9.999999999998899e-05, 0.0238850573071151, 0.05822581608975774, 0.021631858809790128, 0.04992634567884402, 0.04200826865229812, 0.06709109289823989, 0.010319916623042436, 0.06572323453826667, 0.16028478459054418, 0.04532204067145651, 9.999999999998899e-05, 0.07003596070613072, 0.2327272796240013, 0.08694957102165612, 0.07227721281022514, 0.10354761026239445, 0.06906903694612543, 0.06655664822877538, 0.13150014658382714, 0.14816046560236973, 9.999999999998899e-05, 0.19459239612993917, 0.3287035668152677, 0.19485594742581291, 0.226433833192066, 0.1477969996992311, 0.1633894819173063, 0.0824546858174543, 0.5052147029959942, 0.5618696477707557, 0.5731223122530891, 0.5770733599858302, 0.5651483598720091, 0.5785762122525262, 0.5672630291182509, 0.56115491538173, 0.5616365825187224, 0.12939650365056765, 0.07900695356855358, 0.07387626556075721, 0.09201873799653604, 0.09017721394858325, 0.09990613658739023, 0.10938259119446592, 0.11065815889973796, 0.13143425801846098, 0.37699006899625187, 0.2564127068946771, 0.23955002335772868, 0.143580975891203, 0.27552478467606933, 0.19600446748778744, 0.15730930424745582, 0.20791254118876956, 0.2902439277631955, 0.3341187690568791, 0.3458834931914384, 0.44208512255961985, 0.2595846670668338, 0.3687782567176685, 0.21964839291736693, 0.3672234564587258, 0.4563871618044506, 0.4677655459771177, 0.17390156029029513, 0.2809636618385014, 0.31643121046794676, 0.2508340395206673, 0.3249222794044735, 0.1934269256693375, 0.257608416943253, 0.2950543778864687, 0.32933326915497496, 0.2015672827444973, 0.15652508069749071, 0.18917813614720946, 0.21198107281439893, 0.23958631598103675, 0.1959981427558508, 0.20113439405897637, 0.19005397867025764, 0.21275305991221682, 0.21171101155107952, 0.2001803060642311, 0.2020601217914606, 0.21217760101507188, 0.21785444150113398, 0.1958282858330196, 0.21898527354686603, 0.21860720093022223, 0.18280898189954664, 0.15721960456679096, 0.16801002623482053, 0.1650410763719885, 0.8821175373122871, 0.19974197591787324, 0.11881124988644265, 0.14227725771768218, 0.20888319596222493, 0.8877423900860351, 0.6584164469828726, 0.21012590903216433, 0.15543718710267262, 0.20641903519325555, 0.20901689272696045, 0.20996712013329777, 0.10467717854043967, 0.11225505967181759, 0.11208778075096137, 0.17530962368645853, 0.18027661693734476, 0.1752670982157135, 0.1884703504856532, 0.1792987654181064, 0.1889414643933054, 0.1798304822683694, 0.174874769858949, 0.17707307350882462, 0.07672340418987711, 0.07916634906767317, 0.0853730836652814, 0.0781494127256046, 0.07419366030971652, 0.0783883143356503, 0.07549592987263676, 0.07570760933892418, 0.0977137186988033]}, "mutation_prompt": null}
{"id": "dd19bc4c-9471-4e3d-b216-c76c5eb7527f", "solution": "import numpy as np\n\nclass ProgressiveQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.55  # Slightly adjusted differential weight\n        self.CR_base = 0.85  # Increased crossover probability\n        self.w_base = 0.5  # Increased inertia weight for PSO\n        self.c1 = 1.5  # Personal attraction coefficient\n        self.c2 = 1.9  # Increased global attraction coefficient\n        self.F_decay = 0.9  # Adjusted decay factor for differential weight\n        self.CR_growth = 1.02  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.3 + 0.7 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "ProgressiveQuantumCooperativeOptimizer", "description": "A novel Progressive Quantum Cooperative Optimizer using adaptive variance reduction and dynamic parameter tuning for enhanced exploration and convergence.", "configspace": "", "generation": 91, "fitness": 0.2691460351836351, "feedback": "The algorithm ProgressiveQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7600524439444584, 0.7608295442606625, 0.7681351973709385, 0.7705779230162373, 0.7741163010100026, 0.7603234307930671, 0.7657982127750889, 0.7973089417296565, 0.7932450667879434, 0.461581444174716, 0.564734273468725, 9.999999999998899e-05, 0.5928230956513779, 0.040563008505221654, 0.565451624516011, 0.5467774086363502, 0.49515827471413176, 0.5866527040108567, 0.09832765212027883, 0.14777751220059365, 0.09689589637381146, 0.1344682255958327, 0.1490745647870848, 0.1249391949646752, 0.10536234828869162, 0.09357355666677813, 0.10430674634721149, 0.08781520575175894, 0.1055315245099, 0.10562041504718145, 0.0848599463761438, 0.10455957712302921, 0.09593282032848471, 0.13103311209799262, 0.1102611591909668, 0.11354172327060275, 0.9791304183486685, 0.9658033406415, 0.9669725545784094, 0.9678538413663592, 0.9772908549815359, 0.9640529466901928, 0.9756560462951442, 0.9755712506310105, 0.9660941956229244, 0.4742087103854956, 0.5081841011981028, 0.41408076425989093, 0.433450641279573, 0.5065596191261406, 0.3798093182429432, 0.4097238946519547, 0.45213620136087074, 0.44805413274063766, 0.21131987226005422, 0.17236523262061998, 0.30991744763213525, 0.8098248544648275, 0.21015886770802839, 0.208501925085267, 0.11797653024562182, 0.20652738686315308, 0.2256154428550785, 0.19964660602214035, 0.11870711695632996, 0.20806357821155474, 0.09722035533358264, 0.12233126321470478, 0.15584965333346412, 0.16328249697252573, 0.16872422775263762, 0.17126757559204142, 0.19630125957692401, 0.12182929897727568, 0.20503863828233249, 0.161265503583363, 0.10684170062791165, 0.20341740516020768, 0.1714902753554336, 0.09722317207459907, 0.20318820660220116, 9.999999999998899e-05, 0.002556846971441651, 9.999999999998899e-05, 0.04262970437289171, 9.999999999998899e-05, 0.0005921019213530609, 0.008686282760468567, 0.07835676782848755, 0.0076561627325621995, 0.11875870666736499, 0.035331586379567126, 0.037239464628773034, 0.09667832342198324, 0.00040557386033945875, 0.06860814177052088, 0.08393913932564723, 0.08776787545050269, 0.058790162653764355, 0.14935629677553175, 0.07913230310041874, 0.10401195843881683, 0.08127959345332603, 0.07793452723072825, 0.06419515829562739, 0.17182053090414595, 0.08065694545576663, 0.06096021361822346, 0.030084042533779942, 0.03991593304593022, 0.16117720722704065, 0.26707593347227643, 0.18045425364436818, 0.10997163170526347, 0.13855826481130373, 0.05320297516118333, 0.2074550656876315, 0.49368120076843514, 0.5055079146126624, 0.4989495057639284, 0.5185757716295586, 0.4978746749767431, 0.504241701483751, 0.5302140623918922, 0.5177474686803509, 0.5335728326777833, 0.07621619963000992, 0.0847761854361142, 0.12356677262515625, 0.11979712003879561, 0.1093146072468697, 0.13512916614124038, 0.08445831323163622, 0.11836604339267964, 0.08810325466741431, 0.1812831020366945, 0.1838192490635574, 0.26201655791611556, 0.26478182809760087, 0.20815640215923814, 0.2505389933242893, 0.19889143426370204, 0.17220896904396055, 0.2443211421373791, 0.22170802545801316, 0.41221297537424617, 0.38261815025260226, 0.18814329378386574, 0.3347131115702606, 0.4542923380679956, 0.3870286448049941, 0.4156697173311965, 0.4572300219493445, 0.2883917695596506, 0.1694945396828791, 0.22009068956619182, 0.24168813147927481, 0.2906497162578767, 0.18045790950409724, 0.2732677421399218, 0.2817216846481648, 0.2992704260154698, 0.21370311164992517, 0.18684459025286748, 0.21159699503474239, 0.2219767277393555, 0.17940727361761222, 0.2229337442186724, 0.22792033853030758, 0.19352441310936808, 0.186473378908519, 0.18452397169340762, 0.18344672673940876, 0.20964944388218343, 0.18507045486436413, 0.18645803049775855, 0.20907384519366612, 0.19172371414343825, 0.19492735630086344, 0.23261910761164473, 0.18353744252607918, 0.15978064871887177, 0.18409902035539794, 0.19745172715364767, 0.1966746291941357, 0.196093705719109, 0.1419148419469708, 0.160151089054128, 0.8490782830503223, 0.6541068172978073, 0.16873217126928597, 0.20645833658223933, 0.5369370943749778, 0.20547381014258392, 0.22109110636866391, 0.20492848407137265, 0.2108660712491215, 0.6871775321756326, 0.19649022861343468, 0.18447142463671784, 0.1870808641175291, 0.17595565841050942, 0.18277251714872, 0.1947685639875565, 0.22405791040597434, 0.17425016190124587, 0.19499218235345117, 0.08638565307203516, 0.09777046003399614, 0.08239575278928801, 0.06774620616545612, 0.0783124092518781, 0.08063543798225714, 0.08818368052768111, 0.07446075081365688, 0.08144986385287611]}, "mutation_prompt": null}
{"id": "2583ce11-e54b-4b71-8970-90d5bf53db81", "solution": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Adjusted population size\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6\n        self.CR_base = 0.7  # Slightly reduced crossover probability\n        self.w_base = 0.3  # Modified inertia weight for PSO\n        self.c1 = 1.5  # Reduced personal attraction coefficient\n        self.c2 = 1.9  # Increased global attraction coefficient\n        self.F_decay = 0.93\n        self.CR_growth = 1.07  # Increased growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = pop[indices]\n                mutant = x0 + F * (x1 - x2)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum Enhanced Adaptive Differential Evolution blending Estimation of Distribution and Dynamic Parameter Adjustment.", "configspace": "", "generation": 92, "fitness": 0.27721162757606815, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.27.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8774782767676425, 0.866632808129903, 0.8775108179162147, 0.882761362840717, 0.8843864581220682, 0.2789735671686806, 0.8727276685887734, 0.8816007059114286, 0.8791094933543817, 0.7600492143145727, 9.999999999998899e-05, 0.714699992242523, 9.999999999998899e-05, 0.04762360988670222, 0.06398862749535983, 9.999999999998899e-05, 0.749184203591557, 0.23200238016465058, 0.153867985254996, 0.11403952470380185, 0.14003858124100266, 0.10785950390467802, 0.1274542445231951, 0.11464494183472507, 0.1010853917364799, 0.15655306063353236, 0.18462713527106833, 0.10374135393308004, 0.12443870486834352, 0.1133861638605056, 0.10211932204303542, 0.08343465686939566, 0.08193249072863551, 0.13577235029758594, 0.12455388048393656, 0.1480043901257233, 0.9716909095246666, 0.9629352818938467, 0.9719596386573134, 0.9742427290510314, 0.9718523354601003, 0.9719460399931644, 0.9767993554506216, 0.9627666369034725, 0.9641283970824306, 0.7175901827702912, 0.6960807884640732, 0.058591264427952816, 0.22479844667911097, 0.14952992865329995, 0.5003702547722145, 0.0876139854126825, 0.18899351729017944, 0.6656632921892609, 0.8139247435623238, 0.1686563357114519, 0.1699061524500226, 0.3769583141903393, 0.19165000624995154, 0.21967634604082142, 0.1237323613954161, 0.15013547643645342, 0.24023505267240797, 0.19357831345822496, 0.25548731015680937, 0.10928002563673145, 0.12887798633008607, 0.1342386742725743, 0.15649797482242633, 0.1659453784729703, 0.12926081945777768, 0.14838924306785706, 0.180828345460593, 0.14319518971373235, 0.19926814972457707, 0.13737902890479037, 0.15045775520471527, 0.22207495033934843, 0.12650254024518603, 0.13065589305705105, 0.18160355997980215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.058744856423108116, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.019043068985227007, 0.07593574016080606, 0.01725960095814061, 0.17678553799049246, 0.08590439058115584, 0.011780652541273917, 0.10778538716828223, 0.12414706935036934, 0.07019781248284251, 0.04852500856536013, 0.049584295211191454, 9.999999999998899e-05, 0.09013501298782045, 0.10491623174346387, 0.09501863839200864, 0.07739727014097786, 0.11741669628967721, 0.0970025884207043, 0.32730463755899186, 0.11695283011494906, 9.999999999998899e-05, 0.17992512536516447, 0.050530395107528436, 0.27065026777160384, 0.11123862475368218, 0.24814415903324805, 0.056527256513752566, 0.08139951637323461, 0.5393233603293537, 0.5186557731537629, 0.5711511432915204, 0.5653355766889282, 0.49770164841368036, 0.5038253149479948, 0.5677245947465874, 0.551794025007792, 0.5588070469627379, 0.08120355556157688, 0.08988773765412228, 0.14628980489606747, 0.10322222921831214, 0.1416046565490645, 0.1175079288307439, 0.13957514252431424, 0.07769166809807226, 0.13517667674135447, 0.2485835893961319, 0.15766132749239403, 0.2219027445108136, 0.2630753870912741, 0.2070350184845018, 0.16503364244697027, 0.4054335037592417, 0.18640310407892668, 0.23063999289702453, 0.3658592395882049, 0.2522615616318016, 0.34875131000543214, 0.38132511755814624, 0.4436565296701567, 0.40385147950370215, 0.3161299264223606, 0.4623227598974843, 0.21950242782824247, 0.17927125438927305, 0.251269595586755, 0.1331634533336049, 0.23619939864772654, 0.3101614399473388, 0.2933523829742075, 0.26786810578575404, 0.16440403828675976, 0.21240475470795317, 0.20906258215097406, 0.21220275841573943, 0.21811819042887004, 0.20713369032883888, 0.20392925794198968, 0.18191420868475383, 0.23134435751257898, 0.19347539747429787, 0.19974701214951995, 0.18326755844853315, 0.22035750653664088, 0.8065614651622176, 0.22620642533379576, 0.24742090715139953, 0.24635805141173983, 0.7494806418061637, 0.20583178733541463, 0.20612737901355294, 0.9012693233454485, 0.16504422289203502, 0.15133460513333752, 0.8781690919073368, 0.19991105957994637, 0.19844270982372203, 0.14212219725658393, 0.16834419385477417, 0.9022315753562445, 0.5920278333712425, 0.1688738022597196, 0.8552001944820371, 0.32707281214641437, 0.616171659578583, 0.16791269317676416, 0.1044963932929861, 0.10358860872248987, 0.1664744000236047, 0.19115973279507292, 0.20033181633707464, 0.1884654234493668, 0.18239506114908577, 0.19011501001029452, 0.18645395957802446, 0.18346562294459667, 0.207663243090369, 0.20378304219868337, 0.10024888475872651, 0.09068905002622374, 0.10078042714607438, 0.09017520132136103, 0.09089965394884858, 0.08325926380863036, 0.10229190741857619, 0.10007661719948846, 0.07054566473766011]}, "mutation_prompt": null}
{"id": "28ea29b6-5881-4300-af25-05242937d126", "solution": "import numpy as np\n\nclass EnhancedQuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for more diversity\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.5  # Reduced differential weight for finer exploration\n        self.CR_base = 0.9  # Increased crossover probability for diversity in offspring\n        self.w_base = 0.5  # Increased inertia weight for more influence of previous velocity\n        self.c1 = 1.5  # Adjusted personal attraction coefficient\n        self.c2 = 1.5  # Adjusted global attraction coefficient\n        self.F_decay = 0.9  # Modified decay factor for differential weight\n        self.CR_growth = 1.1  # Increased growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base + 0.3 * np.sin((t / self.max_iter) * np.pi)  # Dynamic inertia weight adjustment\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedQuantumCooperativeOptimizer", "description": "Synergistic Integration of Adaptive Differential Evolution and Particle Swarm Optimization with Dynamic Coefficients for Enhanced Global Search.", "configspace": "", "generation": 93, "fitness": 0.27794715316101254, "feedback": "The algorithm EnhancedQuantumCooperativeOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.7484171182170329, 0.7768199387432543, 0.7521352804180478, 0.7402405985467087, 0.757637885183152, 0.7468530034653702, 0.7458791245945224, 0.7747874071129125, 0.73638316715281, 0.36252758242416117, 0.3915594675611864, 0.39817030920219576, 0.3726820882412546, 0.4117810959137881, 0.5100362648556354, 0.4092709156421771, 0.39566778448217077, 0.4096364852566956, 0.14276142966211713, 0.12778362014629507, 0.0783985965527143, 0.10327364974194075, 0.1452121016310166, 0.11392955535618876, 0.1119907222292773, 0.11424452754663106, 0.09501870828452064, 0.12528827628738837, 0.1377577969335695, 0.09457004873409769, 0.11762768806558233, 0.0760615260140941, 0.11079320046365992, 0.09479848656659451, 0.12995931831611707, 0.10755416084444491, 0.9307513963733889, 0.9436259927558287, 0.92687154178699, 0.9581983538769688, 0.95666091587857, 0.9186679719821421, 0.9586332414813582, 0.9446575187892288, 0.946175955000497, 0.33881030513855226, 0.30447731932468336, 0.3392271014665983, 0.35762788032699255, 0.3408086826549148, 0.3518915622703874, 0.31149917740113586, 0.3385347528402658, 0.32645063082468595, 0.7462046745752005, 0.6843385262050417, 0.2247541352509479, 0.16072860947589962, 0.19215629129416834, 0.8063053172218348, 0.7312480948557905, 0.7183888864138113, 0.2737010279181823, 0.2019517048995112, 0.20337930534625603, 0.20080734651045795, 0.20426111198044639, 0.19188773783094037, 0.19850375027938505, 0.12830386162440732, 0.17865143788595783, 0.27908491466045504, 0.15444022299621396, 0.22129459953717334, 0.19981214585629137, 0.21139103543162374, 0.23778706470136568, 0.2309908349879949, 0.19988976327928742, 0.2263465399669431, 0.24689227969412653, 0.05244492463695882, 9.999999999998899e-05, 0.014443719007487532, 0.008223552666692169, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008790661259583943, 0.03159749248940602, 0.09314643637645681, 0.050779166226002204, 0.10598885082764609, 0.06337521101148125, 0.0561719000708496, 0.03289426878760171, 0.06085820417308696, 0.08922401428463111, 0.15278944260045757, 0.09359124171040767, 0.03840267108185058, 0.13514196753201702, 0.19078865543473988, 0.22034513028119296, 0.07821428278628173, 0.08624110482607483, 0.09227739482203323, 0.07959824960322037, 0.1655088886245929, 0.11254041246474267, 0.20166381767399066, 0.22623867703678713, 0.22162981190203668, 0.14732531765929158, 0.08384247545161672, 0.10221280491571416, 0.1998997145003124, 0.4903062959622576, 0.49275350741963286, 0.5370586623237348, 0.556408376039244, 0.4805306769841018, 0.5024599223830577, 0.5175620176375905, 0.5375182186711867, 0.5030093295154621, 0.10035722559921922, 0.06400138871743677, 0.07928460527080972, 0.10800954813495978, 0.09587334903876454, 0.09630554505217082, 0.1079659608427288, 0.1501936198033027, 0.09197920139866056, 0.19490081217860245, 0.3647475399677723, 0.18186134177651825, 0.20030756053967858, 0.24841721397491578, 0.15750105169896156, 0.1538939818995494, 0.13265828623949272, 0.19461496768999076, 0.2748400848496474, 0.34404951875018674, 0.3693010480613621, 0.2862378332099095, 0.3749481997476648, 0.35738987723525983, 0.3715600828273894, 0.42731794380833044, 0.3954710714063404, 0.263639678971478, 0.2813314599338447, 0.23423709658157377, 0.29629816764286254, 0.29877992216913274, 0.24437885791436942, 0.2619413474828157, 0.29751489742896997, 0.20837397211319675, 0.21943120725401766, 0.21142227879422593, 0.18965933888760567, 0.20045163633964624, 0.1971337841123193, 0.20594013897881314, 0.20329977799464716, 0.19953628633659815, 0.19396782989957828, 0.23310034854912043, 0.19222084355354807, 0.2334456206906329, 0.2384542712428367, 0.18653455527906093, 0.22652207956410986, 0.1962470117279933, 0.23919554056086467, 0.23928294334696776, 0.18594454063526078, 0.1876756626074677, 0.16658630394131524, 0.8465356434333196, 0.19904132146297948, 0.14710318443114279, 0.14160675508753884, 0.172971257800696, 0.14094811179534594, 0.7463579849875914, 0.2109205433790755, 0.20578462883408233, 0.20799290106848167, 0.5878084352999512, 0.2079126563566257, 0.16705029949932415, 0.16772321302973525, 0.6612099444682378, 0.20347573869527458, 0.199224426623538, 0.17489703352332286, 0.18361328908848618, 0.17899339669409853, 0.180170769809338, 0.18408715840634193, 0.19485625133288487, 0.1873441568771531, 0.07478406608971933, 0.07101984082526158, 0.08028605849845594, 0.07561461744240061, 0.08555009308322148, 0.08055932172233937, 0.07294750218575241, 0.10076337587018502, 0.11211692391856853]}, "mutation_prompt": null}
{"id": "42c61d45-2034-45aa-9416-9d33167ca4b7", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "da2a1af6-7b78-4c57-8102-80017fb75268", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "6f50da26-6dd0-4926-a362-cc7ab04cc3a2", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "901573c4-35be-40ed-ad77-0c4039f96d00", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
{"id": "23c71139-ead8-4879-a874-66e53f614136", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.7  # Adjusted differential weight\n        self.CR_base = 0.9  # Adjusted crossover probability\n        self.w_base = 0.5  # Adjusted inertia weight for PSO\n        self.c1 = 1.8  # Increased personal attraction coefficient\n        self.c2 = 1.8  # Increased global attraction coefficient\n        self.F_decay = 0.92  # Modified decay factor for differential weight\n        self.CR_growth = 1.07  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 5, replace=False)\n                x0, x1, x2, x3, x4 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x4)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "EnhancedHybridOptimizer", "description": "Hybrid Quantum Differential Evolution and Particle Swarm Optimization with Dynamic Parameter Adjustments for Enhanced Exploration-Exploitation Balance.", "configspace": "", "generation": 98, "fitness": 0.252272443320004, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.6935760439964223, 0.7048224257195999, 0.70835249657982, 0.7303368061008837, 0.7309050307595887, 0.6979926754365686, 0.7362864375090542, 0.7358958973246276, 0.7059135972994128, 0.4734984413785349, 0.07619547190074372, 0.45536723595672524, 0.42010400251022395, 0.48187047730355803, 0.47376620768404176, 0.42819628094838336, 0.05058830487031485, 0.4331729546773966, 0.14114282943243106, 0.08649565612856835, 0.10735432587474825, 0.12851791207149688, 0.11238575728008926, 0.11580249280701405, 0.11494124635593217, 0.10407361787155056, 0.12787509817263254, 0.12297026189397708, 0.09336079711896617, 0.08730128170321372, 0.09799783927579664, 0.12925621429167677, 0.09553507282300999, 0.08295624146699043, 0.11427316879977056, 0.09073463051142028, 0.9719899072788986, 0.9597841135398804, 0.9732135747521043, 0.9755162420736184, 0.9486256539020583, 0.9456231536796323, 0.9605517158372906, 0.9877422701790131, 0.9718025280188709, 0.30694980657068716, 0.2983934376541981, 0.2931156681106073, 0.29631008373337675, 0.2290083541406207, 0.34036287111511465, 0.23821531222041747, 0.32884970744142306, 0.30983043152148804, 0.2207584543316481, 0.35202546445817784, 0.6604127119614633, 0.20302233866640296, 0.20615923175645468, 0.20471008288367987, 0.19140665893569697, 0.3066336041212413, 0.5321836426944309, 0.1724711860393625, 0.16919054181567084, 0.17417618570188276, 0.09589997474432765, 0.22779002690623984, 0.1590170929477377, 0.19052122290903617, 0.17092581793491957, 0.1886850995386644, 0.17071121747367923, 0.18912560518374577, 0.09966759652766455, 0.12878629235267658, 0.18302924738229553, 0.19847350721694557, 0.12089057942201964, 0.1168011951580753, 0.08174941421883375, 9.999999999998899e-05, 0.04045787958657365, 0.012899661006027463, 9.999999999998899e-05, 0.0007692299895023513, 9.999999999998899e-05, 9.999999999998899e-05, 0.009489913443536335, 9.999999999998899e-05, 0.004231340549851859, 0.04201214892623717, 0.06390416153600786, 0.07830473712746788, 0.05251178455316041, 0.018388706826784063, 0.06419123350918454, 0.06816226522850988, 0.04753354510385088, 0.02519764959980131, 0.03288927584060952, 0.11664503966269946, 0.08191854326297765, 0.11796930209893941, 0.05525097802261758, 0.07078868699422147, 0.21788729120615435, 0.0897157045653959, 0.16968642024735914, 0.061075414885527035, 0.10831827283608397, 0.1688309895439315, 0.040439508087315335, 0.09708149593376747, 0.0533521542878711, 0.05308747394108981, 0.07201085031132459, 0.4626881086186926, 0.474057499216035, 0.4645027851768283, 0.4912879091800101, 0.4668247763241081, 0.49370321364750935, 0.45569059935461, 0.5053210367541683, 0.4889448571178773, 0.1132678290864142, 0.09368104769278196, 0.1005542801493633, 0.10572539108410872, 0.0819299337685998, 0.08801273530662035, 0.09831326809479646, 0.10980629939354913, 0.10034800220308626, 0.1996851833558808, 0.18395256112618286, 0.1520016312941993, 0.19876946620003277, 0.21163183809231956, 0.16168008305012316, 0.15409413021267193, 0.25140008147604154, 0.14615392869948318, 0.3428436498517705, 0.3362789962624868, 0.3561395443355103, 0.2893442699666383, 0.32764712458831735, 0.33955254789170153, 0.2755212341953759, 0.2777765186578708, 0.35352220582866667, 0.26371571779458414, 0.20851948100918638, 0.2502696158937331, 0.2626745873274038, 0.2527229216936999, 0.24627761884985044, 0.27696202858626007, 0.24926420390899606, 0.228680977368384, 0.18799392897544198, 0.19093492092975128, 0.17656187465201278, 0.18293248813003837, 0.1827498312274234, 0.20026062406909562, 0.1830812452229208, 0.1980771764390371, 0.1949374630942866, 0.21476078645416752, 0.18784755166352263, 0.1848453434572872, 0.2193442105240636, 0.18752289248080323, 0.2056532740045286, 0.1957799984043731, 0.19793720530281433, 0.1857384701520236, 0.6993712990859002, 0.6779377201218866, 0.14585137550845229, 0.16447456176262043, 0.1960869241345201, 0.7604191910205821, 0.140780214841572, 0.16383011154227556, 0.16798856284690022, 0.5868009264951626, 0.3033553506104889, 0.11079018157392329, 0.1913180522691167, 0.16104884800383046, 0.4854821757897234, 0.2075628098319483, 0.2065372046455699, 0.4184435585424191, 0.17804780673137832, 0.18789611656041694, 0.17998807171713938, 0.18295344031570226, 0.18196419839966882, 0.1885763328252792, 0.18161959646168835, 0.18025460910281088, 0.19921165548280328, 0.07205595074381965, 0.06772476482760481, 0.08113681713940346, 0.08513834917088137, 0.07520856544283194, 0.08557227471076856, 0.07219915080027617, 0.0753594392463971, 0.08273482834313894]}, "mutation_prompt": null}
{"id": "e555f167-135c-4eb6-b5ca-e1638942b897", "solution": "import numpy as np\n\nclass QuantumCooperativeOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.max_iter = budget // self.pop_size\n        self.F_base = 0.6  # Adjusted differential weight\n        self.CR_base = 0.8  # Adjusted crossover probability\n        self.w_base = 0.4  # Adjusted inertia weight for PSO\n        self.c1 = 1.7  # Increased personal attraction coefficient\n        self.c2 = 1.7  # Increased global attraction coefficient\n        self.F_decay = 0.95  # Modified decay factor for differential weight\n        self.CR_growth = 1.05  # Adjusted growth factor for crossover probability\n\n    def __call__(self, func):\n        pop = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        velocity = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        \n        fitness = np.apply_along_axis(func, 1, pop)\n        personal_best = pop.copy()\n        personal_best_fitness = fitness.copy()\n        global_best = pop[np.argmin(fitness)]\n        \n        eval_count = self.pop_size\n        \n        for t in range(self.max_iter):\n            F = self.F_base * (self.F_decay ** t)\n            CR = min(self.CR_base * (self.CR_growth ** t), 1.0)\n            w = self.w_base * (0.5 + 0.5 * np.cos((t / self.max_iter) * np.pi))\n\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 4, replace=False)\n                x0, x1, x2, x3 = pop[indices]\n                mutant = x0 + F * (x1 - x2) + F * (x3 - x0)\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, pop[i])\n                trial_fitness = func(trial)\n                eval_count += 1\n                \n                if trial_fitness < fitness[i]:\n                    pop[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < func(global_best):\n                            global_best = trial\n\n            r1, r2 = np.random.rand(self.pop_size, self.dim), np.random.rand(self.pop_size, self.dim)\n            velocity = (w * velocity + \n                        self.c1 * r1 * (personal_best - pop) + \n                        self.c2 * r2 * (global_best - pop))\n            pop = np.clip(pop + velocity, self.lower_bound, self.upper_bound)\n            \n            fitness = np.apply_along_axis(func, 1, pop)\n            eval_count += self.pop_size\n            \n            better_mask = fitness < personal_best_fitness\n            personal_best[better_mask] = pop[better_mask]\n            personal_best_fitness[better_mask] = fitness[better_mask]\n            if np.min(fitness) < func(global_best):\n                global_best = pop[np.argmin(fitness)]\n\n            if eval_count >= self.budget:\n                break\n\n        return global_best", "name": "QuantumCooperativeOptimizer", "description": "Adaptive Cooperative Strategy blending Quantum-inspired Differential Evolution and Particle Swarm Optimization for robust convergence.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "40969494-040d-4ead-b7d1-ee255e04e1fa", "metadata": {"aucs": [0.8495698401384033, 0.8485758402491197, 0.8433546692321657, 0.8410497920454364, 0.8552884104350005, 0.8500685021917675, 0.8429169806855505, 0.839448505090107, 0.8422493677583455, 0.6967386835597444, 0.07486009417976636, 9.999999999998899e-05, 0.7041592887995798, 0.6605038273057282, 0.7000110369594312, 0.08919841249856142, 0.1363318651176172, 0.05627000554666006, 0.13156343650391444, 0.17558282785454393, 0.14417918692232834, 0.11237322337978206, 0.1442293238220953, 0.6325801363846137, 0.11400323139601098, 0.11731364798346733, 0.10855544814234364, 0.4552302180619713, 0.14757844674664944, 0.09397472541883944, 0.1354049360475127, 0.3975514554378633, 0.10808053700366871, 0.12059010839491435, 0.10490127754031242, 0.4479554776903849, 0.9558683050549291, 0.9526300250723694, 0.9629707045161333, 0.9447397407820148, 0.9330917779521711, 0.8982424246024303, 0.9659464780264363, 0.9538468781698537, 0.9451155320933968, 0.5651344772645959, 0.4958401885798466, 0.1337758399944572, 0.544405252871246, 0.58965067063268, 0.55142605572225, 0.604089205576883, 0.5657337067253152, 0.5645753377464112, 0.7236600206087187, 0.7083480527474829, 0.7833461296464054, 0.27690035844441274, 0.8203308459262608, 0.2104968675788893, 0.7375360440093388, 0.17675096646307242, 0.3821470749518868, 0.11156786003403796, 0.259468617598017, 0.282819828613597, 0.2441953092929915, 0.18577656603537318, 0.19186547497456097, 0.2191835203626229, 0.16126182754725105, 0.1470860936601448, 0.2175913950922369, 0.21578017712112774, 0.11459681230792063, 0.17706249654048245, 0.1324109918823948, 0.2827851717848726, 0.16294401401250158, 0.16525115214024988, 0.1887498701499819, 0.04153988999113045, 0.011097688404462347, 0.02910187269994835, 0.05421412384953184, 9.999999999998899e-05, 9.999999999998899e-05, 0.09740904806368822, 0.04314174385203173, 0.021300161180137, 0.07171104663550976, 0.052044162572213226, 0.0518649702711631, 0.08329337516908963, 0.09732438129958443, 0.03799149506298438, 0.05305679505819516, 0.0728705769805511, 0.06983649337423048, 0.05211796042103778, 0.0352581991744606, 0.12829340553968183, 0.18148945417452012, 0.08949785252359865, 0.07133590568060355, 0.0910915941871655, 0.13349206688016424, 0.10055779586527458, 0.1587634164105084, 0.07970561052875413, 0.11789651747519037, 0.07330215963739006, 0.16901304478329526, 0.19487607442446686, 0.16329072755337404, 0.05066371818000792, 0.08087581828842083, 0.5541132455584548, 0.560163546401844, 0.5393355324026479, 0.5764475192826435, 0.5881568805572971, 0.6259166852327986, 0.6252011734024125, 0.5787010138605089, 0.576424543088748, 0.09944245378245398, 0.08013699664962548, 0.08764614938437643, 0.12476442992424364, 0.09551896130341175, 0.12005836188698904, 0.1234238268860065, 0.1405012984171874, 0.1045197192546028, 0.2553353002513977, 0.18219243568811583, 0.3045428435611258, 0.21198854824552538, 0.33262103863990156, 0.34604424946301215, 0.20608303969796882, 0.23676994382411554, 0.22491665718098086, 0.4954594292394282, 0.28890413400896864, 0.39217846157593417, 0.3539810706971125, 0.33937791323064015, 0.4543925666598295, 0.26983676938390233, 0.48980143529086895, 0.47228232442085394, 0.25036491269390104, 0.29855476497354916, 0.2531227883781839, 0.22566023392227896, 0.22310125819298077, 0.2523846333023051, 0.24890224803853167, 0.41449859689686097, 0.28308930960959333, 0.2421723270829803, 0.18493440120460358, 0.17464880279481076, 0.20102146788937247, 0.20937837955403615, 0.2037118242708168, 0.20515166621671865, 0.23643628489044233, 0.2150727470819701, 0.24557030651226197, 0.2055239619939846, 0.2063220709605118, 0.21571118286079694, 0.23430696303788723, 0.18926172744894643, 0.21960733720115744, 0.19968819771208157, 0.24464827524667587, 0.8089830364749866, 0.14785415977029148, 0.1538128915456537, 0.16448454003698698, 0.19927892682169357, 0.1959649264103812, 0.14174564684673574, 0.1655536660544863, 0.21030191076952343, 0.8024150874100471, 0.20935638536265022, 0.25512798262531255, 0.7831794938949675, 0.20475769268619004, 0.210608098146439, 0.8101419212661524, 0.10477516712309021, 0.808951870248177, 0.18252398947185533, 0.17621408453145393, 0.1842885355337811, 0.19129875365323445, 0.18168835150315843, 0.1894507411802031, 0.19548207114788196, 0.18514499809113072, 0.1719061804349149, 0.08663009087518492, 0.08939051247688312, 0.08511963471245731, 0.09015958870021679, 0.09087727887896868, 0.09862798214120616, 0.09451791695399137, 0.07871233548857015, 0.08233905582576462]}, "mutation_prompt": null}
